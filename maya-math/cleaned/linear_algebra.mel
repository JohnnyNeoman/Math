/******************************************************************************
 * LINEAR ALGEBRA - CLEANED MEL PROCEDURES
 *
 * Category:    linear-algebra
 * Layer:       affine (GL(4,R))
 * Description: Matrix operations, rotations, transformations
 * Procedures:  229
 *
 * All variable declarations moved to procedure start.
 * Generated by cleanup_mel_v2.py
 ******************************************************************************/


/******************************************************************************
 * @procedure    crossProduct
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $v1 : float[]
 *   $v2 : float[]
 *   $normalizeInputs : int
 *   $normalizeResult : int
 *
 * @returns      float[]
 * @source       crossProduct (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
global proc float[] crossProduct(float $v1[], float $v2[], int $normalizeInputs, int $normalizeResult)
{

    if ( size($v1) != 3 )
    warning (uiRes("m_crossProduct.kFirstArgument"));
    if ( size($v2) != 3 )
    warning (uiRes("m_crossProduct.kSecondArgument"));

    if ( $normalizeInputs == 1 )
    {
    // normalize the input vectors
    //
    normalize( $v1 );
    normalize( $v2 );
    }

    // the cross product
    //
    $cross[0] = $v1[1]*$v2[2] - $v1[2]*$v2[1];
    $cross[1] = $v1[2]*$v2[0] - $v1[0]*$v2[2];
    $cross[2] = $v1[0]*$v2[1] - $v1[1]*$v2[0];

    if ( $normalizeResult == 1 )
    {
    // normalize the cross product result
    //
    normalize( $cross );
    }

    return $cross;

}


/******************************************************************************
 * @procedure    xyzRotation
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $theta : float
 *   $axis : float[]
 *
 * @returns      float []
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] xyzRotation(float $theta, float $axis[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $rotation[];
    float $w = cos($theta);
    float $factor = sin($theta);
    float $axisLen2 = dotProduct( $axis, $axis, 0 );
    float $x = $factor * $axis[0];
    float $y = $factor * $axis[1];
    float $z = $factor * $axis[2];
    float $matrix[];
    float $ww = $w*$w;
    float $xx = $x*$x;
    float $yy = $y*$y;
    float $zz = $z*$z;
    float $s = 2.0 / ($ww + $xx + $yy + $zz);
    float $xy = $x*$y;
    float $xz = $x*$z;
    float $yz = $y*$z;
    float $wx = $w*$x;
    float $wy = $w*$y;
    float $wz = $w*$z;
    float $solution1[];
    float $solution2[];
    float $cosB = sqrt($matrix[0]*$matrix[0] + $matrix[1]*$matrix[1]);
    float $pi = 3.14159265;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //
    //	Description:
    //		Given an angle for rotation (in radians) and an axis about which to
    //		do the rotation, return the rotation about the X,Y,Z axes (in $rotation).
    //

    // set up the xyzw quaternion values

    $theta *= 0.5;
    $w = cos($theta);
    $factor = sin($theta);
    $axisLen2 = dotProduct( $axis, $axis, 0 );
    if ( $axisLen2 != 1.0 && $axisLen2 != 0.0 ) $factor /= sqrt($axisLen2);
    $x = $factor * $axis[0];
    $y = $factor * $axis[1];
    $z = $factor * $axis[2];

    // setup rotation in a matrix
    //
    $ww = $w*$w;
    $xx = $x*$x;
    $yy = $y*$y;
    $zz = $z*$z;
    $s = 2.0 / ($ww + $xx + $yy + $zz);
    $xy = $x*$y;
    $xz = $x*$z;
    $yz = $y*$z;
    $wx = $w*$x;
    $wy = $w*$y;
    $wz = $w*$z;
    $matrix[0] = 1.0 - $s * ($yy + $zz);
    $matrix[1] = $s * ($xy + $wz);
    $matrix[2] = $s * ($xz - $wy);
    $matrix[5] = 1.0 - $s * ($xx + $zz);
    $matrix[6] = $s * ($yz + $wx);
    $matrix[9] = $s * ($yz - $wx);
    $matrix[10] = 1.0 - $s * ($xx + $yy);

    // get x,y,z values for rotation
    //
    $cosB = sqrt($matrix[0]*$matrix[0] + $matrix[1]*$matrix[1]);
    if ( $cosB > 1.0e-10 )
    {
    $pi = 3.14159265;

    $solution1[0] = $a = atan2( $matrix[6], $matrix[10]);
    $solution1[1] = $b = atan2(-$matrix[2], $cosB);
    $solution1[2] = $c = atan2( $matrix[1], $matrix[0]);

    $solution2[0] = $a + (($a < $pi) ? $pi : -$pi);
    $solution2[1] = (($b > -$pi) ? $pi : -$pi) - $b;
    $solution2[2] = $c + (($c < $pi) ? $pi : -$pi);

    if ( abs($solution2[0]) + abs($solution2[1]) + abs($solution2[2]) <
    abs($solution1[0]) + abs($solution1[1]) + abs($solution1[2]) )
    {
    $rotation = $solution2;
    }
    else
    {
    $rotation = $solution1;
    }
    }
    else
    {
    $rotation[0] = atan2(-$matrix[9], $matrix[5]);
    $rotation[1] = atan2(-$matrix[2], $cosB);
    $rotation[2] = 0.0;
    }

    return $rotation;


}


/******************************************************************************
 * @procedure    findParamAtDistance
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $curve : string
 *   $arcLD : string
 *   $distance : float
 *   $epsilon : float
 *
 * @returns      float
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float findParamAtDistance(string $curve, string $arcLD, float $distance, float $epsilon)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $pass = 1;
    float $u = 0.0;
    float $min = `getAttr ( $curve + ".minValue" )`;
    float $max = `getAttr ( $curve + ".maxValue" )`;
    float $arcLength = `getAttr ( $arcLD + ".arcLength" )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $u = 0.0;
    $min = `getAttr ( $curve + ".minValue" )`;
    $max = `getAttr ( $curve + ".maxValue" )`;
    setAttr ( $arcLD + ".uParamValue" ) $max;
    $arcLength = `getAttr ( $arcLD + ".arcLength" )`;
    if ( $distance <= 0.0 ) return 0.0;
    if ( $distance >= $arcLength ) return $max;
    $pass = 1;

    while( true ){
    $u = ( $min + $max ) / 2.0;
    setAttr ( $arcLD + ".uParamValue" ) $u;
    $arcLength = `getAttr ( $arcLD + ".arcLength" )`;
    if ( abs( $arcLength - $distance ) < $epsilon ) break;
    if ( $arcLength > $distance ) $max = $u;
    else $min = $u;
    $pass++;
    }
    return $u;

}


/******************************************************************************
 * @procedure    plotLocator
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $curve : string
 *   $uParam : float
 *
 * @returns      string
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string plotLocator(string $curve, float $uParam)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $locator[] = `spaceLocator -p $p[0] $p[1] $p[2]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    float $p[3] = `pointOnCurve -pr $uParam -p $curve`;
    $locator = `spaceLocator -p $p[0] $p[1] $p[2]`;
    return $locator[0];

}


/******************************************************************************
 * @procedure    plotLocVec
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $curve : string
 *   $uParam : float
 *
 * @returns      vector
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector plotLocVec(string $curve, float $uParam)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $pV = FloatToVec( `pointOnCurve -pr $uParam -p $curve`);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pV = FloatToVec( `pointOnCurve -pr $uParam -p $curve`);
    return $pV;

}


/******************************************************************************
 * @procedure    plotVecEquidistLocOnCurve
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $curve : string
 *   $count : float
 *
 * @returns      vector []
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] plotVecEquidistLocOnCurve(string $curve, float $count)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    float $maxU = `getAttr ( $curve + ".maxValue" )`;
    float $arcLength = `getAttr ( $arcLD + ".arcLength" )`;
    float $span = $arcLength / ( $count - 1 );
    float $epsilon = 0.0001;
    float $distance = $span * $i;
    float $uParam = findParamAtDistance( $curve, $arcLD, $distance, $epsilon );
    string $arcLD = `arcLengthDimension ( $curve + ".u[" + $maxU + "]" )`;
    vector $AllPoints[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    // if ( $count < 2 ) error( "Must plot at least two equidistant locators." );
    $maxU = `getAttr ( $curve + ".maxValue" )`;
    $arcLD = `arcLengthDimension ( $curve + ".u[" + $maxU + "]" )`;
    $arcLength = `getAttr ( $arcLD + ".arcLength" )`;
    $span = $arcLength / ( $count - 1 );
    $AllPoints[`size($AllPoints)`]= plotLocVec( $curve, 0.0 );
    $epsilon = 0.0001;
    for ( $i = 1; $i < ( $count - 1 ); $i++ ){
    $distance = $span * $i;
    $uParam = findParamAtDistance( $curve, $arcLD, $distance, $epsilon );
    $AllPoints[`size($AllPoints)`]= plotLocVec( $curve, $uParam );
    }
    $AllPoints[`size($AllPoints)`]= plotLocVec( $curve, $maxU );
    delete `listRelatives -fullPath -parent $arcLD`;
    return $AllPoints;

}


/******************************************************************************
 * @procedure    RatioFourS
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $VecF : vector[]
 *
 * @returns      float
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float RatioFourS(vector $VecF[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $whRatioS = sqrt( abs ($whRatio));
    vector $ma = $VecF[0];
    vector $mb = $VecF[1];
    vector $mc = $VecF[2];
    vector $md = $VecF[3];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $ma = $VecF[0];
    $mb = $VecF[1];
    $mc = $VecF[2];
    $md = $VecF[3];




    $ma.y*$md.x)/avoidZero(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) -
    1)*((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)/avoidZero(($mb.y -
    $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x) - 1)*
    ( avoidZero ( `pow ((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)*$mb.y/avoidZero
    (($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x) - $ma.y) 2`/avoidZero(((($ma.y - $md.y)*$mb.x -
    ($ma.x - $md.x)*$mb.y + $ma.x*$md.y - $ma.y*$md.x)*$mc.y/avoidZero(($mc.y - $md.y)*$mb.x - ($mc.x -
    $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) - $ma.y)*((($ma.y - $md.y)*$mc.x - ($ma.x -
    $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)*$mb.y/avoidZero(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y
    + $mb.x*$md.y - $mb.y*$md.x) - $ma.y) + ((($ma.y - $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y +
    $ma.x*$md.y - $ma.y*$md.x)*$mc.x/avoidZero(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y
    - $mc.y*$md.x) - $ma.x)*((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y -
    $ma.y*$md.x)*$mb.x/avoidZero(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x)
    - $ma.x)) + ((($ma.y - $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y + $ma.x*$md.y -
    $ma.y*$md.x)/avoidZero(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) -
    1)*((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)/avoidZero(($mb.y -
    $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x) - 1)*
    ( avoidZero ( `pow((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)*$mb.x/avoidZero(($mb.y - $md.y)*$mc.x
    - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x) - $ma.x) 2`))/avoidZero(((($ma.y - $md.y)*$mb.x -
    ($ma.x - $md.x)*$mb.y + $ma.x*$md.y - $ma.y*$md.x)*$mc.y/avoidZero(($mc.y - $md.y)*$mb.x - ($mc.x -
    $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) - $ma.y)*((($ma.y - $md.y)*$mc.x - ($ma.x -
    $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)*$mb.y/avoidZero(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y
    + $mb.x*$md.y - $mb.y*$md.x) - $ma.y) + ((($ma.y - $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y +
    $ma.x*$md.y - $ma.y*$md.x)*$mc.x/avoidZero(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y
    - $mc.y*$md.x) - $ma.x)*((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y -
    $ma.y*$md.x)*$mb.x/avoidZero(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x)
    - $ma.x)) - ( avoidZero ( `pow ((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y -
    $ma.y*$md.x)/avoidZero(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x) -
    1) 2`)))/avoidZero(((($ma.y - $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y + $ma.x*$md.y -
    $ma.y*$md.x)/avoidZero(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) -
    1)*((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)/avoidZero(($mb.y -
    $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x) - 1)* ( avoidZero ( `pow ((($ma.y -
    $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y + $ma.x*$md.y - $ma.y*$md.x)*$mc.y/avoidZero(($mc.y - $md.y)*$mb.x
    - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) - $ma.y) 2`))/avoidZero(((($ma.y - $md.y)*$mb.x -
    ($ma.x - $md.x)*$mb.y + $ma.x*$md.y - $ma.y*$md.x)*$mc.y/avoidZero(($mc.y - $md.y)*$mb.x - ($mc.x -
    $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) - $ma.y)*((($ma.y - $md.y)*$mc.x - ($ma.x -
    $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)*$mb.y/avoidZero(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y
    + $mb.x*$md.y - $mb.y*$md.x) - $ma.y) + ((($ma.y - $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y +
    $ma.x*$md.y - $ma.y*$md.x)*$mc.x/avoidZero(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y
    - $mc.y*$md.x) - $ma.x)*((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y -
    $ma.y*$md.x)*$mb.x/avoidZero(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x)
    - $ma.x)) + ((($ma.y - $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y + $ma.x*$md.y -
    $ma.y*$md.x)/avoidZero(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) -
    1)*((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)/avoidZero(($mb.y -
    $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x) - 1)* ( avoidZero ( `pow ((($ma.y -
    $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y + $ma.x*$md.y - $ma.y*$md.x)*$mc.x/avoidZero
    (($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) - $ma.x) 2`))/avoidZero(((($ma.y - $md.y)*$mb.x -
    ($ma.x - $md.x)*$mb.y + $ma.x*$md.y - $ma.y*$md.x)*$mc.y/avoidZero(($mc.y - $md.y)*$mb.x - ($mc.x -
    $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) - $ma.y)*((($ma.y - $md.y)*$mc.x - ($ma.x -
    $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)*$mb.y/avoidZero(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y
    + $mb.x*$md.y - $mb.y*$md.x) - $ma.y) + ((($ma.y - $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y +
    $ma.x*$md.y - $ma.y*$md.x)*$mc.x/avoidZero(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y
    - $mc.y*$md.x) - $ma.x)*((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y -
    $ma.y*$md.x)*$mb.x/avoidZero(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x)
    - $ma.x)) - ( avoidZero ( `pow ((($ma.y - $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y + $ma.x*$md.y -
    $ma.y*$md.x)/avoidZero(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) -
    1) 2`)))));
    print $whRatio;
    $whRatioS = sqrt( abs ($whRatio));

    return $whRatioS;

}


/******************************************************************************
 * @procedure    avoidZero
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $N : float
 *
 * @returns      float
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float avoidZero(float $N)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $NearZero;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if($N == 0){
    $NearZero = 0.00000001;
    return $NearZero;
    }else{ return $N;}

}


/******************************************************************************
 * @procedure    RatioFour
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $VecF : vector[]
 *
 * @returns      float
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float RatioFour(vector $VecF[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $ma = $VecF[0];
    vector $mb = $VecF[1];
    vector $mc = $VecF[2];
    vector $md = $VecF[3];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $ma = $VecF[0];
    $mb = $VecF[1];
    $mc = $VecF[2];
    $md = $VecF[3];

    $ma.y*$md.x)/(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) -
    1)*((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)/(($mb.y -
    $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x) - 1)*((($ma.y -
    $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)*$mb.y/Power(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x) - $ma.y))
    /(((($ma.y - $md.y)*$mb.x -($ma.x - $md.x)*$mb.y + $ma.x*$md.y - $ma.y*$md.x)*$mc.y/(($mc.y - $md.y)*$mb.x - ($mc.x -
    $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) - $ma.y)*((($ma.y - $md.y)*$mc.x - ($ma.x -
    $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)*$mb.y/(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y
    + $mb.x*$md.y - $mb.y*$md.x) - $ma.y) + ((($ma.y - $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y +
    $ma.x*$md.y - $ma.y*$md.x)*$mc.x/(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y
    - $mc.y*$md.x) - $ma.x)*((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y -
    $ma.y*$md.x)*$mb.x/(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x)
    - $ma.x)) + ((($ma.y - $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y + $ma.x*$md.y -
    $ma.y*$md.x)/(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) -
    1)*((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)/(($mb.y -
    $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x) - 1)*((($ma.y -
    $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)*$mb.x/Power(($mb.y - $md.y)*$mc.x
    - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x) - $ma.x))/(((($ma.y - $md.y)*$mb.x -
    ($ma.x - $md.x)*$mb.y + $ma.x*$md.y - $ma.y*$md.x)*$mc.y/(($mc.y - $md.y)*$mb.x - ($mc.x -
    $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) - $ma.y)*((($ma.y - $md.y)*$mc.x - ($ma.x -
    $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)*$mb.y/(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y
    + $mb.x*$md.y - $mb.y*$md.x) - $ma.y) + ((($ma.y - $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y +
    $ma.x*$md.y - $ma.y*$md.x)*$mc.x/(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y
    - $mc.y*$md.x) - $ma.x)*((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y -
    $ma.y*$md.x)*$mb.x/(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x)
    - $ma.x)) - ((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)/
    (Power(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x) - 1.0)))/(((($ma.y
    - $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y + $ma.x*$md.y - $ma.y*$md.x)/(($mc.y - $md.y)*$mb.x -
    ($mc.x - $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) -1)*((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)/(($mb.y -
    $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x) - 1)*((($ma.y -
    $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y + $ma.x*$md.y - $ma.y*$md.x)*$mc.y/Power(($mc.y - $md.y)*$mb.x
    - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) - $ma.y))/(((($ma.y - $md.y)*$mb.x -
    ($ma.x - $md.x)*$mb.y + $ma.x*$md.y - $ma.y*$md.x)*$mc.y/(($mc.y - $md.y)*$mb.x - ($mc.x -
    $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) - $ma.y)*((($ma.y - $md.y)*$mc.x - ($ma.x -
    $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)*$mb.y/(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y
    + $mb.x*$md.y - $mb.y*$md.x) - $ma.y) + ((($ma.y - $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y +
    $ma.x*$md.y - $ma.y*$md.x)*$mc.x/(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y
    - $mc.y*$md.x) - $ma.x)*((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y -
    $ma.y*$md.x)*$mb.x/(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x)
    - $ma.x)) + ((($ma.y - $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y + $ma.x*$md.y -$ma.y*$md.x)/(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) -
    1)*((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)/(($mb.y -
    $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x) - 1)*((($ma.y -$md.y)*$mb.x - ($ma.x - $md.x)*$mb.y + $ma.x*$md.y - $ma.y*$md.x)*$mc.x/Power(($mc.y - $md.y)*$mb.x
    - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) - $ma.x))/(((($ma.y - $md.y)*$mb.x -
    ($ma.x - $md.x)*$mb.y + $ma.x*$md.y - $ma.y*$md.x)*$mc.y/(($mc.y - $md.y)*$mb.x - ($mc.x -
    $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) - $ma.y)*((($ma.y - $md.y)*$mc.x - ($ma.x -
    $md.x)*$mc.y + $ma.x*$md.y - $ma.y*$md.x)*$mb.y/(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y
    + $mb.x*$md.y - $mb.y*$md.x) - $ma.y) + ((($ma.y - $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y +
    $ma.x*$md.y - $ma.y*$md.x)*$mc.x/(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y
    - $mc.y*$md.x) - $ma.x)*((($ma.y - $md.y)*$mc.x - ($ma.x - $md.x)*$mc.y + $ma.x*$md.y -
    $ma.y*$md.x)*$mb.x/(($mb.y - $md.y)*$mc.x - ($mb.x - $md.x)*$mc.y + $mb.x*$md.y - $mb.y*$md.x)
    - $ma.x)) - (Power(($ma.y - $md.y)*$mb.x - ($ma.x - $md.x)*$mb.y + $ma.x*$md.y -
    $ma.y*$md.x)/(($mc.y - $md.y)*$mb.x - ($mc.x - $md.x)*$mb.y + $mc.x*$md.y - $mc.y*$md.x) -
    1))));

    return $whRatio;

}


/******************************************************************************
 * @procedure    Power
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $N : float
 *
 * @returns      float
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float Power(float $N)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $P = `pow $N 2.0`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $P = `pow $N 2.0`;
    return $P;

}


/******************************************************************************
 * @procedure    FindifFourCurvesShareSurface
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Foundboundarycurves : string[]
 *
 * @returns      int
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindifFourCurvesShareSurface(string $Foundboundarycurves[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $historyShapes = `size($firstcurveConnectionsz)`;
    int $trueorFalse = 0;
    string $Intersectboundarycurves[];
    string $myIntersector = `stringArrayIntersector`;
    string $selectedCurve[];
    string $firstcurveRelatives[];
    string $firstcurveConnectionsz[];
    string $firstcurveshapes[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $myIntersector = `stringArrayIntersector`;

    for ( $eachboundry in $Foundboundarycurves ) {

    clear $selectedCurve;
    $selectedCurve[0] = $eachboundry;
    $firstcurveRelatives = `listRelatives -shapes  $selectedCurve`;
    $firstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true $firstcurveRelatives`;
    $historyShapes = `size($firstcurveConnectionsz)`;
    if ($historyShapes > 0){

    $firstcurveshapes = `listConnections -shapes 1 - type nurbsSurface $firstcurveConnectionsz`;
    stringArrayIntersector -edit -allowDuplicates  false -intersect $firstcurveshapes  $myIntersector;
    }

    }
    $Intersectboundarycurves =  `stringArrayIntersector -query $myIntersector`;

    stringArrayIntersector -edit -reset  $myIntersector;
    $trueorFalse = 0;
    if (size($Intersectboundarycurves) == 0){
    $trueorFalse=0;}else{$trueorFalse=1;}

    return $trueorFalse;


}


/******************************************************************************
 * @procedure    NumberOFSurf
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Zeachboundry : string
 *
 * @returns      int
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int NumberOFSurf(string $Zeachboundry)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $XnumOFcurveConnections;
    int $historyShapes = `size($ZfirstcurveConnectionsz)`;
    string $ZfirstcurveRelatives[];
    string $ZfirstcurveConnectionsz[];
    string $Zfirstcurveshapes[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $ZfirstcurveRelatives = `listRelatives -shapes $Zeachboundry`;
    $ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
    $historyShapes = `size($ZfirstcurveConnectionsz)`;
    if ($historyShapes > 0){

    $ZfirstcurveshapesA = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;
    $ZfirstcurveshapesB = `listConnections -shapes 1  -type mesh $ZfirstcurveConnectionsz`;
    $XnumOFcurveConnections = (`size($ZfirstcurveshapesA)`) + (`size($ZfirstcurveshapesB)`) ;
    }else{ $XnumOFcurveConnections = 0;}

    return $XnumOFcurveConnections;

}


/******************************************************************************
 * @procedure    ForAllCurvesFindSurfaceEdges
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $newallCurves : string[]
 *
 * @returns      string[]
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] ForAllCurvesFindSurfaceEdges(string $newallCurves[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Zfirstcurveshapesi = `NumberOFSurf($Zeachboundry)`;
    string $ZnewfoundEdge[];
    string $ZselectedCurve[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ( $Zeachboundry in $newallCurves ) {
    $ZselectedCurve[0] = $Zeachboundry;
    $Zfirstcurveshapesi = `NumberOFSurf($Zeachboundry)`;
    if ($Zfirstcurveshapesi == 1){
    appendStringArray($ZnewfoundEdge, $ZselectedCurve, 1);
    }
    if ($Zfirstcurveshapesi == 0){
    appendStringArray($ZnewfoundEdge,  $ZselectedCurve, 1);
    }
    }
    return $ZnewfoundEdge;

}


/******************************************************************************
 * @procedure    FindNumOfConnectionsToCurveRemove
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $boundaryCurves : string[]
 *   $XiC : int
 *   $everyFirstCurveShapeset : string[]
 *
 * @returns      int
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindNumOfConnectionsToCurveRemove(string $boundaryCurves[], int $XiC, string $everyFirstCurveShapeset[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numberofconnections;
    string $selectedCurve[];
    string $firstcurveConn[] = stringArrayRemove ($selectedCurve, $everyFirstCurveShapeset);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ( $eachboundry in $boundaryCurves ) {
    $selectedCurve[0] = $eachboundry;
    $numberofconnections += NumberOFSurf($eachboundry);
    if ( $numberofconnections == $XiC ) {
    $firstcurveConn = stringArrayRemove ($selectedCurve, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset = $firstcurveConn;
    }
    }
    return  $numberofconnections;

}


/******************************************************************************
 * @procedure    GetVectorArrayBetweenCurveEnds
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $CurveItem : string[]
 *
 * @returns      vector[]
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] GetVectorArrayBetweenCurveEnds(string $CurveItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    float $EACHCVposAZ[];
    float $eachCVpos[];
    string $CurveSelection[];
    vector $CurveA = << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $CurveB = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $CurveAB[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
    $EACHCVposAZ = 0; string $MakeXBetweenB[];
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA   )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){$EACHCVposAZ = $eachCVpos;}
    if ( $numIntZB == 2 ){$EACHCVposBZ = $eachCVpos;}
    }
    $CurveA = << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    $CurveB = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    $CurveAB = $CurveA; $CurveAB[1] = $CurveB;
    return $CurveAB;

}


/******************************************************************************
 * @procedure    PointsEquivalentTol
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      int
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int PointsEquivalentTol(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $pX = equivalentTol($posA[0], $posB[0],  0.01);
    int $pY = equivalentTol($posA[1], $posB[1],  0.01);
    int $pZ = equivalentTol($posA[2], $posB[2],  0.01);
    int $addedResults = $pX + $pY + $pZ;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pX = equivalentTol($posA[0], $posB[0],  0.01);
    $pY = equivalentTol($posA[1], $posB[1],  0.01);
    $pZ = equivalentTol($posA[2], $posB[2],  0.01);
    $addedResults = $pX + $pY + $pZ;
    return $addedResults;

}


/******************************************************************************
 * @procedure    FindifCurveEndsMeet
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $CurveA1 : vector[]
 *   $CurveA2 : vector[]
 *
 * @returns      int
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindifCurveEndsMeet(vector $CurveA1[], vector $CurveA2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CurveMeetsTrue = 0;
    int $indexN = 0;
    int $indexN2 = 0;
    int $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    int $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);
    float $firstC[];
    float $SecondCA[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveMeetsTrue = 0;
    $indexN = 0;
    $indexN2 = 0;
    while ($indexN < 2){
    $firstC = $CurveA1[$indexN];
    $SecondC = $CurveA2[0];
    $SecondCA = $CurveA2[1];
    $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);
    if (($NumberE == 3)||($NumberE2 == 3)){$CurveMeetsTrue = $CurveMeetsTrue +1; }
    if ($indexN==1){$indexN1 = 1;}
    $indexN++;
    }
    return $CurveMeetsTrue;

}


/******************************************************************************
 * @procedure    IfCurvesTouch
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $curveA : string
 *   $curveB : string
 *
 * @returns      int
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int IfCurvesTouch(string $curveA, string $curveB)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $intIfTrue = FindifCurveEndsMeet($CurveOne, $CurveTwo);
    string $Acurve[];
    string $Bcurve[];
    vector $CurveOne[] = GetVectorArrayBetweenCurveEnds($Acurve);
    vector $CurveTwo[] = GetVectorArrayBetweenCurveEnds($Bcurve);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Acurve = {$curveA};
    $Bcurve = {$curveB};
    $CurveOne = GetVectorArrayBetweenCurveEnds($Acurve);
    $CurveTwo = GetVectorArrayBetweenCurveEnds($Bcurve);
    $intIfTrue = FindifCurveEndsMeet($CurveOne, $CurveTwo);
    return $intIfTrue;

}


/******************************************************************************
 * @procedure    GetSurfConnectNameIfexists
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Zeachboundry : string
 *
 * @returns      string []
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] GetSurfConnectNameIfexists(string $Zeachboundry)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $XnumOFcurveConnections;
    int $XnumConnectionsM;
    int $XnumConnectionsN;
    int $historyShapes = `size($ZfirstcurveConnectionsz)`;
    string $connectionSurfaceName[];
    string $ZfirstcurveRelatives[];
    string $ZfirstcurveConnectionsz[];
    string $ZfirstcurveshapesA[];
    string $ZfirstcurveshapesB[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    //string $Zeachboundry = $first[0];
    $ZfirstcurveRelatives = `listRelatives -shapes $Zeachboundry`;
    $ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
    $historyShapes = `size($ZfirstcurveConnectionsz)`;
    if ($historyShapes > 0){
    $ZfirstcurveshapesA = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;
    $ZfirstcurveshapesB = `listConnections -shapes 1  -type mesh $ZfirstcurveConnectionsz`;
    $XnumConnectionsN = `size($ZfirstcurveshapesA)`;
    $XnumConnectionsM = `size($ZfirstcurveshapesB)`;
    $XnumOFcurveConnections = (`size($ZfirstcurveshapesA)`) + (`size($ZfirstcurveshapesB)`) ;
    if($XnumConnectionsN > 0){$connectionSurfaceName[size($connectionSurfaceName)] = $ZfirstcurveshapesA[0] ;}
    if($XnumConnectionsM > 0){$connectionSurfaceName[size($connectionSurfaceName)] = $ZfirstcurveshapesB[0] ;}
    }

    return $connectionSurfaceName;


}


/******************************************************************************
 * @procedure    boundryall
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $everyFirstCurveShapeset : string[]
 *
 * @returns      string[]
 * @source       matrixRotations (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] boundryall(string $everyFirstCurveShapeset[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $EndAll = 0;
    int $everycurveSize = size($everyFirstCurveShapeset);
    int $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
    int $numberofconnections = size($firstcurveConn);
    int $divide;
    int $switchNumber;
    int $n;
    int $n2 = $n * 2;
    int $ISTRUE0A1;
    int $numIntZZ;
    int $numIntAX1 = size($TEMPzCurveAAb);
    int $switchNumberA;
    int $ISTRUE0B = catchQuiet($intersectCurveZ1 = `curveIntersect -ch 0 -ud 0 -tol 0.01 $FirstCurvesZ $eachAB`);
    int $numIntZZZ = size($intersectCurveZ1);
    int $numInts2a;
    int $numIntxZB;
    int $X = 1;
    int $ENDLOOPA;
    int $i = 1;
    int $ENDLOOP;
    int $B = 0;
    int $ISTRUE0A001;
    int $numIntZZA;
    int $numIntZZAB;
    int $ISTRUE0B002;
    int $endtrigger = 0;
    int $NEARsize;
    int $XendtriggerSearch = 1;
    int $numsizeNearest = size($NearestCurvesZ);
    int $numsizediffX = size($diffX);
    int $boundaryCurvessize = size($boundaryCurves);
    int $numberofconnectionsFIRST = size($firstcurveConn);
    string $EdgeCurveZ3[];
    string $EdgeCurveZ2[];
    string $EdgeCurveZ[];
    string $FirstCurvesZ[];
    string $firstcurveRelatives[];
    string $firstcurveConnectionsz[];
    string $firstcurveshapes[];
    string $firstcurveConn[] = stringArrayRemove($firstcurveRelatives, $firstcurveshapes);
    string $NearestCurvesZ[] = (NearestObjectArray($n, $everyFirstCurveShapeset));
    string $NearestCurvesZn2[] = (NearestObjectArray($n2, $everyFirstCurveShapeset));
    string $TEMPzCurveAAb[];
    string $removeoneFromeveryFirstA[];
    string $diff[];
    string $NearestCurvesZA[];
    string $diffremove[];
    string $TEMPAlldiffCurveZBBBB[];
    string $diffX[];
    string $boundaryCurvesAA[];
    string $boundaryCurves[];
    string $boundaryCurves1[];
    string $removecurveAz2[];
    string $removecurveAz[];
    string $selectedCurve[];
    string $removeoneFromeveryFirst[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $EndAll = 0;

    $everycurveSize = size($everyFirstCurveShapeset);
    while( size($everyFirstCurveShapeset) > 2 ){
    $EndAll++;

    if ( $EndAll == 1000 ){
    clear $everyFirstCurveShapeset;
    }


    if (size($everyFirstCurveShapeset) == 3 ){
    stringArrayInsertAtIndex(0, $EdgeCurveZ2, $everyFirstCurveShapeset[0]);
    stringArrayInsertAtIndex(0, $EdgeCurveZ2, $everyFirstCurveShapeset[1]);
    stringArrayInsertAtIndex(0, $EdgeCurveZ2, $everyFirstCurveShapeset[2]);
    }

    $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
    $FirstCurvesZ[0] = $everyFirstCurveShapeset[$everycurveSizeIndex];

    $firstcurveRelatives = `listRelatives -shapes $FirstCurvesZ`;
    $firstcurveConnectionsz = `listConnections $firstcurveRelatives`;
    $firstcurveshapes = `listConnections -shapes 1 $firstcurveConnectionsz`;
    $firstcurveConn = stringArrayRemove($firstcurveRelatives, $firstcurveshapes);
    $numberofconnections = size($firstcurveConn);


    if ( $numberofconnections >= 2 ) {
    stringArrayRemoveAtIndex($everycurveSizeIndex, $everyFirstCurveShapeset);
    $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
    $FirstCurvesZ[0] = $everyFirstCurveShapeset[$everycurveSizeIndex];
    }
    $everycurveSize = size($everyFirstCurveShapeset);
    if (( $everycurveSize < 1000 ) && ( $everycurveSize >= 500 )){
    $divide = $everycurveSize / 50;
    $switchNumber = 0;
    print $divide;}
    if (( $everycurveSize < 500 ) && ( $everycurveSize >= 250 )){
    $divide = $everycurveSize / 25;
    $switchNumber = 0;}
    if (( $everycurveSize < 250 ) && ( $everycurveSize >= 100 )){
    $divide = $everycurveSize / 12; }
    if (( $everycurveSize < 100 ) && ( $everycurveSize >= 50 )){
    $divide = $everycurveSize / 5;
    $switchNumber = 0;}
    if (( $everycurveSize < 50 ) && ( $everycurveSize >= 20 )){
    $divide =$everycurveSize / 4;
    $switchNumber = 0;}
    if (( $everycurveSize < 20 ) && ( $everycurveSize > 18 )){
    $divide = $everycurveSize / 2;
    $switchNumber = 0;
    print $divide;
    }
    if ( $everycurveSize <= 18 ){
    $switchNumber = 1;
    }


    switch($switchNumber)

    {
    case 0:
    $n = $divide;
    $NearestCurvesZ = (NearestObjectArray($n, $everyFirstCurveShapeset));
    $n2 = $n * 2;
    $NearestCurvesZn2 = (NearestObjectArray($n2, $everyFirstCurveShapeset));
    break;

    case 1:
    $NearestCurvesZ = $everyFirstCurveShapeset;
    $NearestCurvesZn2 = $everyFirstCurveShapeset;
    break;

    }

    print $NearestCurvesZ;

    if ( size($TEMPzCurveAAb) > 0){
    clear $TEMPzCurveAAb;
    }
    for ( $eachZ in $NearestCurvesZ ) {

    $ISTRUE0A1 = catchQuiet($intersectCurveZ0 = `curveIntersect -ch 0 -ud 0 -tol 0.01 $FirstCurvesZ $eachZ`);
    $numIntZZ = size($intersectCurveZ0);
    if (($ISTRUE0A1 > 0) || ($numIntZZ > 0)) {
    stringArrayInsertAtIndex(0, $TEMPzCurveAAb, $eachZ);
    }
    }


    $NearestCurvesZ = $TEMPzCurveAAb;
    $numIntAX1 = size($TEMPzCurveAAb);

    if ( $numIntAX1 == 0 ){
    $removeoneFromeveryFirstA = stringArrayRemove($FirstCurvesZ, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset = $removeoneFromeveryFirstA;
    $switchNumberA = 0;
    }


    $numInts2 = size($TEMPzCurveA);
    if ( $numInts2 > 0 ){
    clear $TEMPzCurveA;
    }


    if ( $numIntAX1 == 0 ){
    $switchNumberA = 0;
    }


    if ( size($diff) > 0){
    clear $diff;
    }
    $diff = stringArrayRemove($NearestCurvesZ, $NearestCurvesZn2);


    if( size($diff) == 0 ) {
    clear $everyFirstCurveShapeset;
    clear $NearestCurvesZ;
    $switchNumberA = 1;
    } else if( size($diff) > 0 ){
    $switchNumberA = 2;
    }

    if(( size($NearestCurvesZ) == 3 ) && ($everycurveSize == 3)) {
    $switchNumberA = 1; }

    switch($switchNumberA)

    {
    case 0:

    stringArrayRemoveAtIndex($everycurveSizeIndex, $everyFirstCurveShapeset);
    $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
    $FirstCurvesZ[0] = $everyFirstCurveShapeset[$everycurveSizeIndex];

    print "next";
    break;

    case 1:
    print "done";
    stringArrayInsertAtIndex(0, $EdgeCurveZ, $NearestCurvesZ[0]);
    stringArrayInsertAtIndex(0, $EdgeCurveZ, $NearestCurvesZ[1]);
    stringArrayInsertAtIndex(0, $EdgeCurveZ, $NearestCurvesZ[2]);
    break;

    case 2:

    for ( $eachAB in $diff ) {
    $ISTRUE0B = catchQuiet($intersectCurveZ1 = `curveIntersect -ch 0 -ud 0 -tol 0.01 $FirstCurvesZ $eachAB`);
    $numIntZZZ = size($intersectCurveZ1);
    if (($ISTRUE0B > 0) || ($numIntZZZ > 0)) {
    stringArrayInsertAtIndex(0, $TEMPzCurveA, $eachAB);
    }
    }
    $numInts2a = size($NearestCurvesZA);
    if ( $numInts2a > 0 ){
    clear $NearestCurvesZA;
    }
    $NearestCurvesZA = stringArrayCatenate($NearestCurvesZ, $TEMPzCurveA);
    $NearestCurvesZ = $NearestCurvesZA;
    $numInts2a = size($diffremove);
    if ( $numInts2a > 0 ){
    clear $diffremove;
    }
    $diffremove = stringArrayRemove($TEMPzCurveA, $diff);
    $numInts = size($TEMPAlldiffCurveZBBBB);
    if ( $numInts > 0 ){
    clear $TEMPAlldiffCurveZBBBB;
    }
    $TEMPAlldiffCurveZBBBB = $diffremove;
    //////////////////////////////////////////////////////

    clear $boundaryCurves;
    clear $boundaryCurves1;
    $X = 1;
    $i = 1;
    $B = 0;
    $endtrigger = 0;

    while (size($NearestCurvesZ) > 0 ){
    if ( $endtrigger == 2 ){
    clear $NearestCurvesZ;
    size($NearestCurvesZ); }
    $NEARsize = size($NearestCurvesZ);
    if ( $NEARsize == 1 ){
    clear $NearestCurvesZ;
    }
    for ( $each in $NearestCurvesZ ) {
    stringArrayInsertAtIndex(0, $boundaryCurves1, $each);
    clear $oneboundaryCurve;
    stringArrayInsertAtIndex(0, $oneboundaryCurve, $boundaryCurves1[0]);
    $X = 1;
    $ENDLOOPA = size($TEMPAlldiffCurveZBBBB);
    for ( $eachA in $TEMPAlldiffCurveZBBBB ) {
    stringArrayInsertAtIndex(0, $boundaryCurves1, $each);
    clear $oneboundaryCurve;
    stringArrayInsertAtIndex(0, $oneboundaryCurve, $boundaryCurves1[0]);
    $ISTRUE0A001 = catchQuiet($intersectCurveZ0A = `curveIntersect -ch 0 -ud 0 -tol 1.0 $each $eachA`);
    $ENDLOOPA = size($TEMPAlldiffCurveZBBBB);
    $X++;
    $numIntZZA = size($intersectCurveZ0A);
    if ((($ISTRUE0A001 == 0) && ( $X == $ENDLOOPA)) || (($numIntZZA == 0) && ( $X == $ENDLOOPA))) {
    $removecurveAz2[0] = $each;
    $NearestCurvesZ = stringArrayRemove($removecurveAz2, $NearestCurvesZ);
    $NEARsize = size($NearestCurvesZ);

    } else if (($ISTRUE0A001 > 0) || ($numIntZZA > 0)){
    clear $diffX;
    $diffX = stringArrayRemoveExact($oneboundaryCurve, $NearestCurvesZ);
    $ENDLOOP = size($diffX);

    $XendtriggerSearch = 1;

    for ( $eachB in $diffX ) {
    $XendtriggerSearch++;

    if ( $endtrigger == 2 ){
    clear $NearestCurvesZ; }

    $ISTRUE0B002 = catchQuiet($intersectCurveZAB = `curveIntersect -ch 0 -ud 0 -tol 0.001 $eachA $eachB`);

    $numIntZZAB = size($intersectCurveZAB);
    $numsizeNearest = size($NearestCurvesZ);
    $numsizediffX = size($diffX);
    //
    //

    if (( $endtrigger == 0 ) && ( $numsizeNearest < 2 )){
    $removeoneFromeveryFirstA = stringArrayRemove($FirstCurvesZ, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset = $removeoneFromeveryFirstA;
    }
    if (($ISTRUE0B002 > 0) || ($numIntZZAB > 0)) {
    boundary -ch 1 -or 0 -ep 0 -rn 1 -po 1 -ept 0.001 $FirstCurvesZ $each $eachA $eachB;
    $endtrigger = $endtrigger +1;
    if ( $endtrigger == 1 || $endtrigger == 2 ) {
    stringArrayInsertAtIndex(0, $boundaryCurves, $each);
    stringArrayInsertAtIndex(0, $boundaryCurves, $eachB);
    stringArrayInsertAtIndex(0, $boundaryCurves, $eachA);
    }
    if ( $endtrigger < 2 ){
    $removecurveAz[0] = $each;
    $removecurveBz[0] = $eachB;
    $removecurveCz[0] = $eachA;
    $NearestCurvesZ = stringArrayRemove($removecurveAz, $NearestCurvesZ);
    $NearestCurvesZ = stringArrayRemove($removecurveBz, $NearestCurvesZ);
    $TEMPAlldiffCurveZBBBB = stringArrayRemove($removecurveCz, $TEMPAlldiffCurveZBBBB);
    else if ( $endtrigger == 2 ){
    clear $NearestCurvesZ; }

    }
    }
    //end of if
    }
    //end of For
    }
    }
    }

    $boundaryCurvessize = size($boundaryCurves);
    if( $boundaryCurvessize > 0 ) {
    for ( $eachboundry in $boundaryCurves ) {
    clear $selectedCurve;
    $selectedCurve[0] = $eachboundry;
    $firstcurveRelatives = `listRelatives -shapes $selectedCurve`;
    $firstcurveConnectionsz = `listConnections $firstcurveRelatives`;
    $firstcurveshapes = `listConnections -shapes 1 $firstcurveConnectionsz`;
    $firstcurveConn = stringArrayRemove($firstcurveRelatives, $firstcurveshapes);
    $numberofconnections = size($firstcurveConn);

    if (( $endtrigger == 1 ) && ( $numberofconnections == 1 )) {

    stringArrayInsertAtIndex(0, $EdgeCurveZ3, $FirstCurvesZ[0]); }

    if ( $numberofconnections == 2 ) {
    $firstcurveConn = stringArrayRemove($selectedCurve, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset = $firstcurveConn;

    }
    }

    }
    clear $selectedCurve;
    $selectedCurve[0] = $FirstCurvesZ[0];
    $firstcurveRelatives = `listRelatives -shapes $selectedCurve`;
    $firstcurveConnectionsz = `listConnections $firstcurveRelatives`;
    $firstcurveshapes = `listConnections -shapes 1 $firstcurveConnectionsz`;
    $firstcurveConn = stringArrayRemove($firstcurveRelatives, $firstcurveshapes);
    $numberofconnectionsFIRST = size($firstcurveConn);

    if (( $endtrigger == 1 ) && ( $numberofconnectionsFIRST == 1 )) {

    stringArrayInsertAtIndex(0, $EdgeCurveZ2, $FirstCurvesZ[0]); }



    if ( $endtrigger == 0 ){
    stringArrayInsertAtIndex(0, $EdgeCurveZ2, $FirstCurvesZ[0]); }

    $removeoneFromeveryFirst = stringArrayRemove($FirstCurvesZ, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset = $removeoneFromeveryFirst;
    clear $FirstCurvesZ;
    break;
    }
    playButtonStepForward;
    select -r $everyFirstCurveShapeset;

    }

    return $EdgeCurveZ2;


}


/******************************************************************************
 * @procedure    DELETE_OR_KEEP
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $CURVES : string[]
 *
 * @returns      int []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] DELETE_OR_KEEP(string $CURVES[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $TrackInfrontA[];
    int $curves_Keep[];
    int $iC;
    int $SizeSeg = `size($CreateSegAT)`;
    int $CountT = 0;
    int $TrackIT = 0;
    int $keep[];
    int $C1;
    int $Inx;
    int $SizeCuts = `size($N_Us)`;
    int $m_Or_e[];
    int $Tsize = `size($iU)`;
    int $Size = `size($VEC_pt)`;
    int $IndexTrack[];
    int $sIze = `size($aF)`-1;
    int $Zss = $XNum*2;
    int $Yss = $Zss+1;
    int $pair[];
    int $AB;
    int $iNdex = 0;
    int $IntArrayInex[];
    int $SizeVp = `size($vecRs)`;
    int $CountF[];
    int $CountFN = 0;
    int $trackit[];
    int $TF = 0;
    int $TFcn = 0;
    int $MCurveIndex[];
    int $DistSortA[];
    int $DistSortB[];
    int $CountConnect[];
    int $A = $DistSortA[0];
    int $CurveIndexA;
    int $B = $DistSortB[0];
    int $CurveIndexB;
    int $SizeV = `size($AllKnowVecEnds)`;
    int $SizeB = $Size+1;
    int $CurveEndPairs[];
    int $XTFb = 0;
    int $KeyToPairIndex[];
    int $CURVeINDEX[] = CreateIntIndex(`size($CurveNames)`);
    int $SizeSelectedCRVs = `size($FoundDuplicates)`;
    int $CnIndex = 0;
    int $NumbersINDEX[] = CreateIntIndex($SizeSelectedCRVs);
    int $CRV_CONNECT[];
    int $TrackIt[];
    int $CRVNumber[];
    int $Cn = 0;
    int $CnXX = 0;
    int $Xn = 0;
    int $AAi = int ($ARRAY_A[0]) + int ($ADDit[0]);
    int $BAi = int ($ARRAY_B[0]) + int ($ADDit[2]);
    int $AX = int ($A);
    int $BX = int ($B);
    int $AddUp = 0;
    int $NumerinArray = `size($numberArrayi)`-1;
    int $Ni = $Ai;
    int $Nii = $Bi;
    int $range = abs ($Ai-$Bi);
    int $ixNa = $iC+$Ai;
    int $MatrixNi = $MatrixN-1;
    int $BytNum[];
    int $BytNumSort[] = $BytNum;
    int $BytNumLarg = $BytNumSort[`size($BytNumSort)`-1];
    int $BytNumSmall = $BytNumSort[0];
    int $BytNumDiff[];
    int $IndXeF = 0;
    int $IndXeFi = 0;
    int $Count = 0;
    int $Xz = 0;
    int $IndexLetters[] = CreateIntIndex(`size($ArrayLetter)`);
    int $BytNumi;
    int $StringIndex[];
    int $countIndex = 0;
    int $indexStart[];
    int $indexFirstCharItems[];
    int $BytNx = 0;
    int $freezeTrigger = 0;
    int $eachInt = 0;
    int $iixI = 0;
    int $TFandIndex[];
    int $TFandIndexii[];
    int $FirstLFindIndex;
    int $Tri = 0;
    int $Trii = 2;
    int $CountFoundletters = 0;
    int $SizeItem = `size $matchTemp`;
    int $CountTotalFindIndex = 0;
    int $CountIndex[];
    int $findByt;
    int $iX = 0;
    int $AddAll;
    int $FindNum = 0;
    int $FindIndexN[];
    int $LineNumberA[];
    int $CountN = 0;
    int $i;
    int $indexS = `size($indexA)`;
    int $len = size( $list );
    int $Xi = 0;
    int $newInt[];
    int $Ix = 0;
    int $ii = 0;
    int $Ixi = 0;
    int $IndeXxz[];
    int $size = `size($IndeXxI)`-1;
    int $index = 0;
    int $IndeXxiz[] = sort($IndeXz);
    int $SizA = `size($IndeXz)`;
    int $Ixx = 0;
    int $IntA[];
    int $Trigger = 0;
    int $CountCase = 0;
    int $returnCaseN[];
    int $Number;
    int $BytS = 1;
    int $TRUEA = 0;
    int $X = 0;
    int $NumberE[];
    int $ixX = 0;
    int $CC = 0;
    int $fileId = `fopen $exampleFileName "r"`;
    int $failsafe = 0;
    int $CNX = 0;
    int $SizeAll = `size($shorterListAllVarZ)`;
    int $CountLineX = 0;
    int $fileIdW = `fopen $exampleFileNameW "w"`;
    int $NegPosZA[];
    int $WhenZero = 2;
    int $CountNL = 1;
    int $CountFindNL = 0;
    int $CountX = 0;
    int $TriggerLineFound = 0;
    int $START = 0;
    int $DontWrite = 0;
    int $LineNumber[];
    int $CountMasterInDex = 0;
    int $EArray[];
    int $SizeL = `size($CollectAllLines)`;
    int $iL;
    int $tempLineNumber[];
    int $foundNA[];
    int $intIDXSort[] = SortIntIndexTrack($foundNA);
    int $IndexR[];
    int $IndeXCN[];
    int $SizeCD = `size($newCollectDupString)`-1;
    int $intIDXSortX[] = SortIntIndexTrack($IndeXCN);
    int $newfoundNA[];
    int $TempSaveLine[];
    int $CurrentLineN[];
    int $CurrentLineNF[];
    int $IndexX[];
    int $MasterLineN[];
    int $LN_temp[];
    int $CurrentLineNX[];
    int $Aint = size($CollectAllLines);
    int $Bint = size($AllFoundProcs);
    int $Cint = size($CAL_temp);
    int $CHECK = $Aint-$Cint;
    int $TRIGGEREND = 2;
    int $NewMasterLineN[];
    int $XIndexN[];
    int $SortedList[];
    int $LINEplace[];
    int $STARTN = 0;
    int $FLOATindex = 0;
    int $Inxb = 0;
    int $colori[];
    int $COUNT = 0;
    int $CN = 0;
    int $SizeF = `sizeBytes  $Find `;
    int $SizeABCs = `sizeBytes  $ABCs `;
    int $j;
    int $lowest = -1;
    int $father = tournamentSelect($fitness, $tournamentSize);
    int $mother = tournamentSelect($fitness, $tournamentSize);
    int $parent = (int)rand ($gPopulationSize), $i, $tmp;
    int $script_jobToolChangedNum1 = 505;
    int $script_jobToolChangedNum2 = 606;
    int $scriptt_jobAllCurvesToolsNumA;
    int $scriptt_jobAllCurvesToolsNumB;
    int $jobNumtranslateCAM;
    int $jobNumrotateCAM;
    int $addNumbersA;
    int $scriptt_jobNumConnectionChanged = `scriptJob -conditionChange delete evalVectorIndexAdditionSubtract`;
    int $script_jobNumIdle_MoveZCURVEM = `scriptJob   -runOnce 1 -event idle EVALCamScripts`;
    int $intIndexCurveZ[] = CreateIntIndex(`size($objVecMain)`);
    int $indexNumberZ[] = stringArrayGmatchArrayIndex($diffBZ, $KnowObjList);
    int $indexX = 0;
    int $iXn = 0;
    int $newOrderA[];
    int $indexLoc = 0;
    int $newOrderB[];
    int $IfemptyIsTrue = 0;
    int $numCVs = `getAttr -size ($CurveItem[0]+".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $XiV = 0;
    int $IndexVec = 0;
    int $IndexVecRemain = 0;
    int $IndexV[] = CreateIntIndex(`size($AllPlaneLocPosition)`);
    int $IndexReduced[];
    int $indexRecord = 0;
    int $indexPoints = 0;
    int $Lastindex = 0;
    int $lastIntIndex[];
    int $indexM = 0;
    int $FourDiections = 0;
    int $inDexName = 0;
    int $Value = stringArrayGmatchFind($idnodeType3, "controlPoint");
    int $sizeitem = `size($itemA)`;
    int $ResultIndex[];
    int $Index = 0;
    int $BreakTrigger = 0;
    int $vectorSize = `size($worldPosZ)`;
    int $vecCount = `size($worldPosZ)`;
    int $Vii = 0;
    int $Numberlist[];
    int $triggerendsB = 0;
    int $newlistSize = size($singleStringItemB);
    int $ci = 0;
    int $zeroORZe1 = `gmatch "e" $nameAe`;
    int $zeroORZe2 = `gmatch "e" $nameBe`;
    int $zeroORZe3 = `gmatch "e" $nameCe`;
    int $SizeOfArrayA = size($EdgeCurveZ1);
    int $SizeOfArray = size($EdgeCurveZ1) -1;
    int $E = -1;
    int $SizeOfArrayB = size($EdgeCurveZ1);
    int $zeroOR1Z = `gmatch "Curve" $nameA`;
    int $CreatedObjectCurve = `ISobjectSelectedTypeCurve`;
    int $pX = equivalentTol($posA[0], $posB[0], $TRange);
    int $pY = equivalentTol($posA[1], $posB[1], $TRange);
    int $pZ = equivalentTol($posA[2], $posB[2], $TRange);
    int $addedResults = $pX + $pY + $pZ;
    int $sIZes = 2;
    int $NUmers[] = CreateIntIndex($sIZes);
    int $iNew;
    int $Ai = 0;
    int $Bi = 0;
    int $N = 0;
    int $store;
    int $Times = $AS*2;
    int $CombA = PointsEquivalentTol ($PointN, $pAv);
    int $MasterCount = 0;
    int $Par = 0;
    int $CountSteps;
    int $TwoNew[];
    int $count = 0;
    int $evenOdd = fmod($sIZes, 2);
    int $sIZesHalf = (($sIZes)/2)+1;
    int $countN = 0;
    int $CountVV = 0;
    int $xyz = $EmptyIndx[0];
    int $isOrthoTrueZi = 0;
    int $edgeZsetA;
    int $edgeZsetB;
    int $ReducedIndexA[] = floatArrayCountDuplicates($distancesEachToCurve);
    int $ReducedIndexB[] = floatArrayCountDuplicates($distancesEachToCurveB);
    int $NearestInt[] = SortNumbersIntIndex($distAz);
    int $NearestIntB[] = SortNumbersIntIndex($distBz);
    int $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    int $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];
    int $NearestIndex;
    int $NearestIndexEach;
    int $ReducedIndexXAB[];
    int $AxisOrthoLineA = $AxisOrthoLine;
    int $iVc = 0;
    int $TrackFoundN[];
    int $TrackN[];
    int $TwoPointsi[];
    int $ALLlikeness[];
    int $ALLlikenessForce[];
    int $TriggerPoints;
    int $SortedForce[];
    int $Sorted[] = SortNumbersIntIndex($distTo3DCurveEnd);
    int $ReducedIndex[] = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    int $OntheSameLine = 0;
    int $AddInt = $AdditR;
    int $NoneDup[];
    int $indexAx[] = CreateIntIndex(6);
    int $indexAxNew[] = ArrayToIntList( $BestThree);
    int $color;
    int $iiX = 0;
    int $Cindex = 0;
    int $IndexZ = $indexAxNew[$Count];
    int $triggerMiddle = 0;
    int $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
    int $iv = -1;
    int $CRV_index_number = 0;
    int $CRc = 0;
    int $CRcT = 0;
    int $countS = 0;
    int $COuntN = 0;
    int $EDGEpoints[];
    int $pointNearEdgeCurve[];
    int $SnappingVector = 0;
    int $OneIsNotNearThePlane = 0;
    int $Sortedi[] = SortNumbersIntIndex($distancesTo3DCurveEndi);
    int $iiz = 0;
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum2 = (( $numEPs -1 ) * 2 );
    int $COuntNN = 0;
    int $In[] = {1,0,2,3};
    int $CountIntA = 0;
    int $CountInt = 0;
    int $CountIndexV = 0;
    int $xIndex = $Index[$r];
    int $q = Partition($a, $Index, $p, $r);
    int $trueOrFalse = IsPointInLine ($Vecbv[0], $Vecbv[1], $centerCross);
    int $returnVal = 0;
    int $EIndex[];
    int $Ii = 0;
    int $one;
    int $START_END[];
    int $EndsAtZero;
    int $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);
    int $IfTrue;
    int $weighedtFindings = 0;
    int $weighedtFindingsZ = 0;
    int $weighedtFindingsN = 0;
    int $triggerStraitCRV = 0;
    int $triggerNoTransENDA = 0;
    int $triggerNoTransENDB = 0;
    int $First_Second_Both_None = 0;
    int $trigger_straitC = 0;
    int $Trueii = 0;
    int $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
    int $TrackAllExisting3DCrv[] = CreatePairIntIndex($SizeCrvi);
    int $SizeCrvR = `size($LayerCurvesRangeA)`;
    int $triggerNoTrans = 0;
    int $triggerNoTransA = 0;
    int $triggerNoTransB = 0;
    int $iia = 0;
    int $iis = 0;
    int $AllLocsi[] = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    int $New_AllLocs_A[];
    int $Near_index_A = $New_AllLocs_A[0];
    int $New_AllLocs_B[];
    int $Near_index_B = $New_AllLocs_B[0];
    int $ConnectedEnds = $triggerNoTransENDA + $triggerNoTransENDB;
    int $AddAB = $triggerNoTransA+$triggerNoTransB;
    int $New_AllLocs_AB[];
    int $PairInt[];
    int $ifCond_is_True = `ISSelectedTypeCurve`;
    int $LocatorLoop = 0;
    float $SizeC = `size($CURVES)`;
    float $CreateSegAT[];
    float $t = 0;
    float $numEPrealNum3 = ( $numEPs -1 );
    float $ArcL = `arclen $myCurvex`;
    float $Steps_toG = (1.0/$numEPrealNum3)/4;
    float $findPointU[];
    float $distance;
    float $N_Us[];
    float $N_UsB[];
    float $N_UsS[];
    float $Usize = `size($N_UsB)`;
    float $theta = 90;
    float $iU[] = $N_Us;
    float $Arc = `arclen($CRV_ItemI)`;
    float $TempU[];
    float $MperS = ($Arc*($iU[0]));
    float $MperE = ($Arc*(1-$iU[$SizeCuts-1]));
    float $TempUi[];
    float $Hsize = `size($iU)`;
    float $CrvTSi = $iU[$iC];
    float $CrvTEi = $iU[$iC+1];
    float $Mper = ($Arc*($iU[$iC+1]-$iU[$iC]));
    float $ct = cos($theta);
    float $st = sin($theta);
    float $Nxx = (float) ($xx * $ct + $zx * $st);
    float $Nxy = (float) ($xy * $ct + $zy * $st);
    float $Nxz = (float) ($xz * $ct + $zz * $st);
    float $Nxo = (float) ($xo * $ct + $zo * $st);
    float $Nzx = (float) ($zx * $ct - $xx * $st);
    float $Nzy = (float) ($zy * $ct - $xy * $st);
    float $Nzz = (float) ($zz * $ct - $xz * $st);
    float $Nzo = (float) ($zo * $ct - $xo * $st);
    float $PI_Static = 3.14159265;
    float $zxi = $Nzx[0];
    float $zyi = $Nzx[1];
    float $zzi = $Nzx[2];
    float $Points[];
    float $aF[] = $allFloatToSort;
    float $valN;
    float $locsA[];
    float $Addit[] = $VecLineDirM;
    float $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    float $Dist2LStart = distance2Pts( $PN , $PoL);
    float $dist_A[] = ArrayDistancesVecTofloat($AllKnowVecEnds, $NewVecEnds[0]);
    float $dist_B[] = ArrayDistancesVecTofloat($AllKnowVecEnds, $NewVecEnds[1]);
    float $SmallestDistA = $dist_A[$DistSortA[0]];
    float $SmallestDistB = $dist_B[$DistSortB[0]];
    float $hfv = `camera -q -hfv ZCURVEModelingCAM`;
    float $ptx = (($ptVecCs.x/(-$ptVecCs.z))/tand($hfv/2))/2.0;
    float $vfv = `camera -q -vfv ZCURVEModelingCAM`;
    float $pty = (($ptVecCs.y/(-$ptVecCs.z))/tand($vfv/2))/2.0;
    float $ptz = $ptVecCs.z;
    float $FixVecT[];
    float $R[] = $O;
    float $Pi = 3.1415926535;
    float $pi = 3.1415926535;
    float $CamPos1[];
    float $LivePlanePos[];
    float $CamerasDirectionVectorNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
    float $FloatDirectionA[] = DirectionFN($CamPos1, $LocPos1);
    float $DistanceLoc = distance2Pts( $LocPos1, $CamPos1 );
    float $DistanceLocA = $DistanceLoc;
    float $MultDirPC1[] = multiplyFloat($DistanceLoc, $CamerasDirectionVector);
    float $FloatDirectionCamNormal[] = AddFloats($CamPos1, $MultDirPC1);
    float $CamerasDirectionVectorA[] = DirectionFN($FloatDirectionCamNormal, $CamPos1);
    float $MultDirPC1A[] = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
    float $p1[] = $CamPos1;
    float $p2[] = $LocPos1;
    float $p3[] = $FloatDirectionCamNormal;
    float $center[];
    float $normal[];
    float $FloatPosZero[] = {0, 0, 0};
    float $FloatDirection[] = DirectionFN($FloatPosZero, $normal);
    float $FloatDirPerpCenterC[] = DirectionFN($center,$mid2);
    float $FloatDirPointAC[] = DirectionFN($p1, $p3);
    float $center8[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    float $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
    float $FloatDirLocToPerpIntersect[] = DirectionFN($center8,$p2);
    float $OnPlane[] = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );
    float $v[] = `getAttr $attr`;
    float $Nyx = (float) ($yx * $ct + $zx * $st);
    float $Nyy = (float) ($yy * $ct + $zy * $st);
    float $Nyz = (float) ($yz * $ct + $zz * $st);
    float $Nyo = (float) ($yo * $ct + $zo * $st);
    float $lxx = $xx * $rhs[0][0] + $yx * $rhs[1][0] + $zx * $rhs[2][0];
    float $lxy = $xy * $rhs[0][0] + $yy * $rhs[1][0] + $zy * $rhs[2][0];
    float $lxz = $xz * $rhs[0][0] + $yz * $rhs[1][0] + $zz * $rhs[2][0];
    float $lxo = $xo * $rhs[0][0] + $yo * $rhs[1][0] + $zo * $rhs[2][0] + $rhs[3][0];
    float $lyx = $xx * $rhs[0][1] + $yx * $rhs[1][1] + $zx * $rhs[2][1];
    float $lyy = $xy * $rhs[0][1] + $yy * $rhs[1][1] + $zy * $rhs[2][1];
    float $lyz = $xz * $rhs[0][1] + $yz * $rhs[1][1] + $zz * $rhs[2][1];
    float $lyo = $xo * $rhs[0][1] + $yo * $rhs[1][1] + $zo * $rhs[2][1] + $rhs[3][1];
    float $lzx = $xx * $rhs[0][2] + $yx * $rhs[1][2] + $zx * $rhs[2][2];
    float $lzy = $xy * $rhs[0][2] + $yy * $rhs[1][2] + $zy * $rhs[2][2];
    float $lzz = $xz * $rhs[0][2] + $yz * $rhs[1][2] + $zz * $rhs[2][2];
    float $lzo = $xo * $rhs[0][2] + $yo * $rhs[1][2] + $zo * $rhs[2][2] + $rhs[3][2];
    float $x = $v[$i];
    float $y = $v[$i + 1];
    float $z = $v[$i + 2];
    float $Mn[];
    float $Mng[];
    float $FLoatMatrixA[] = MatrixToFloat($MatriXM);
    float $matrixFloat[];
    float $MultDir[] = multiplyFloat($Length,  $Direction);
    float $FloatDirectionNormalA[] = AddFloats($posA, $MultDir);
    float $MatrizFloatiA[];
    float $Xcross[] = $PtsVecCross;
    float $XcrossP[] = {$Xcross[0],$Xcross[1],1.0};
    float $PtsFCrossBB[] = (lineIntersectionF($SQuarePts[0], $pointMakeS[1], $SQuarePts[1], $pointMakeS[0]));
    float $Yaxis[] = PositiveDirectionLine($SQuarePts[1],$pointMakeS[1]);
    float $Xaxis[] = crossProduct( $Yaxis, $DirNorA, 0, 0 );
    float $NormZ[] = $DirNorA;
    float $AllF[];
    float $DISTANCE = distance2Pts($Vec_Array, $PlaneP);
    float $ARCL = `arclen $CURVE[0] `;
    float $AngleA = `angle $DirLineX $DirLineCamTOx`;
    float $AngleADegreeX = `rad_to_deg $AngleA`;
    float $AngleB = `angle $DirLineN $DirLineCamTOy`;
    float $AngleADegreeY = (`rad_to_deg $AngleB`-90.0);
    float $FOUNDZ = 135.000001 -45.0;
    float $CamMfloatZ[];
    float $FirstTrans[] = $VrotatsFIRST;
    float $FirstRot[] = $VrotatsFIRST;
    float $AngleAX = `angle  $DirLineAX $DirLineX`;
    float $AngleAY = `angle  $DirLineAY $DirLineY`;
    float $AngleADegree = `rad_to_deg $AngleA`;
    float $fitness[];
    float $indexFitness = 100000;
    float $lowestFitness = $fitness[$lowest];
    float $roundScale = pow(10,$n);
    float $EACHCVposAZ[];
    float $eachCVpos[];
    float $pointAZ1[];
    float $AveragePoints[] = `xform -q -ws -t LiveSurfaceB`;
    float $Direct[] = DirectionF( $each, $AveragePoints);
    float $PlaneDimentionsV = distance2Pts( $SurfEnds[0], $SurfEnds[1]);
    float $PlaneDimentionsH = distance2Pts( $SurfEnds[1],$SurfEnds[3]);
    float $RadiusMax = distance2Pts( $AveragePoints, $SurfEnds[0]);
    float $FoundDistance;
    float $PlaneDimentionsVH = $PlaneDimentionsV/100;
    float $PlaneDimentionsHH = $PlaneDimentionsH/100;
    float $LocPoint[] = $eachPoint;
    float $MultDirAV[];
    float $DistanceA = distance2Pts( $MiddlePointA[$indexM],  $LocPoint);
    float $FloatDirectionPointz[] = AddFloats($MultDirAV, $LocPoint);
    float $DistanceB = distance2Pts( $MiddlePointA[$indexM],  $FloatDirectionPointz);
    float $Zx[] = $ThreeFLoatArrays;
    float $coiDistance = 0.0;
    float $coi[] = `getAttr ($ppm+".output")`;
    float $sum = 0;
    float $AllDistances[];
    float $MultDirDist[] = multiplyFloat($Distance ,$Direction);
    float $FloatPointLoc[] = AddFloats($PointA, $MultDirDist);
    float $Added_floats[] = { 0.0, 0.0, 0.0};
    float $FloatFromVec[];
    float $VposA;
    float $VposB;
    float $VposC;
    float $FloatFromVecA[] = $worldPosZ[$Vii];
    float $a = ($Added_floats[0])/float($vectorSize);
    float $b = ($Added_floats[1])/float($vectorSize);
    float $c = ($Added_floats[2])/float($vectorSize);
    float $PointsAverage[] = {$a , $b , $c};
    float $MagVectorZYHigher = mag ($vectorZFlatYHigher);
    float $MagVectorZYLower = mag ($vectorZFlatYLower);
    float $AddposA_AND_posB_float[];
    float $SubtractposA_AND_posB_float[];
    float $Timespos[];
    float $FloatZi[];
    float $vPoint[] = {$a , $b , $c};
    float $valuesBi[] = $eachVeCx;
    float $Floatlist[] = $allFloatToSort;
    float $MultLengthDir[] = multiplyFloat($Length, $Dir);
    float $AddMultDirPos[] = AddFloats($Pos, $MultLengthDir);
    float $RowA[] = $VecR[0];
    float $RowB[] = $VecR[1];
    float $RowC[] = $VecR[2];
    float $GivenPoint[] = $PtsVec;
    float $NewPoint[];
    float $NewPointa[];
    float $NewPointb[];
    float $NewPtMatrixMult[];
    float $pAv[] = AverageVectorPoint($Vec);
    float $n[] = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    float $MultDirCam[] = multiplyFloat($DistanceLoc, $n);
    float $FloatDirectionCamNormalA[] = AddFloats($pAv, $MultDirCam);
    float $PointN[] = ClosestPoint2LineVec($n, $pAv, $Veciiv);
    float $FloatDirectionAi[] = DirectionFN($pAv,$PointN);
    float $AddMultMiiF[] = AddFloats($Veciiv, $MultDirPC1);
    float $EulerAngleA[] = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $vector_SubUnitMagVec1[];
    float $UnitDirection[] = $vectorUnit;
    float $DirAB[] = DirectionF ($PosA, $PosB);
    float $DirCD[] = DirectionF ($PosC, $PosD);
    float $MatrixA[] = `MatrixToFloat($m)`;
    float $CleanFLoats[];
    float $values[];
    float $CurvatureRadi;
    float $point1[] = FloatToVec($Vecs[0]);
    float $point2[] = FloatToVec($Vecs[1]);
    float $point3[] = FloatToVec($Vecs[2]);
    float $normalA[] = `unit ($normalV[0])`;
    float $normalB[] = `unit ($normalV[1])`;
    float $normalAAdd = $normalA[0] + $normalA[1];
    float $normalAAdd2 = $normalB[0] + $normalB[1];
    float $FArrayInex[];
    float $AddF = 0;
    float $Divide = $AddAll/$Ix;
    float $Vt[];
    float $PastF;
    float $FloatDirA[];
    float $Anglei;
    float $ThreeFs[];
    float $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    float $distancesEachToCurve[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    float $distancesEachToCurveB[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    float $distAz[];
    float $distBz[];
    float $CamPos_A[];
    float $EpipolXx[] = {0.0,$CamPos_A[1],$CamPos_A[2]};
    float $PlaneEpipolXx[] = FloatPointsToCamPlane( $EpipolXx);
    float $EpipolYx[] = {$CamPos_A[0],0.0,$CamPos_A[2]};
    float $PlaneEpipolYx[] = FloatPointsToCamPlane( $EpipolYx);
    float $EpipolZx[] = {$CamPos_A[0],$CamPos_A[1],0.0};
    float $PlaneEpipolZx[] = FloatPointsToCamPlane( $EpipolZx);
    float $MidCurveA[] = MidPoint($CRV_ENDSi[0], $CRV_ENDSi[1]);
    float $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    float $FPointN_LineC[];
    float $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);
    float $XY[];
    float $XYZi[];
    float $XYZadd[];
    float $Xd;
    float $Yd;
    float $Zd;
    float $All_X[];
    float $All_Y[];
    float $All_Z[];
    float $All_ZYX[];
    float $All_ZYXDiff[];
    float $diffXYZ;
    float $Dist_3DNear = (($Dist_3D/3.0)*2.0);
    float $newOrderFloat;
    float $distTo3DCurveEnd[] = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    float $SdistTo3DCurveEnd[];
    float $Additi[];
    float $AdditiB[];
    float $AdditRi;
    float $AdditRiX;
    float $DistSnap;
    float $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    float $MatrixB[] = `MatrixToFloat($m2)`;
    float $DistToPoint = distance2Pts($Pos_A, $VecLoc);
    float $SnapD = 0.003;
    float $MultDirForWard[] = multiplyFloat(-1, $CamerasDirectionVector);
    float $DirectionVectorXn[] = {-2,0,0};
    float $DirectionVectorX[] = {2,0,0};
    float $DirectionVectorY[] = {0,-2,0};
    float $DirectionVectorYn[] = {0,2,0};
    float $DirectionVectorZn[] = {0,0,-2};
    float $DirectionVectorZ[] = {0,0,2};
    float $FloatPointDirectionXn[] = AddFloats($CamPos1, $DirectionVectorXn);
    float $FloatPointDirectionX[] = AddFloats($CamPos1, $DirectionVectorX);
    float $FloatPointDirectionY[] = AddFloats($CamPos1, $DirectionVectorY);
    float $FloatPointDirectionYn[] = AddFloats($CamPos1, $DirectionVectorYn);
    float $FloatPointDirectionZn[] = AddFloats($CamPos1, $DirectionVectorZn);
    float $FloatPointDirectionZ[] = AddFloats($CamPos1, $DirectionVectorZ);
    float $AverageVecXYZsOnP[] = AverageVectorPoint($VecXYZsOnPlane);
    float $AnglesAll[];
    float $ANgnew[] = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
    float $LengCRV_a = `arclen $CurveItemA`;
    float $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
    float $AverageVecCurEndsP[] = AverageVectorPoint($VecCurEnds);
    float $FloatPointDirectionZniY[];
    float $CurveDirectionZiY[];
    float $FloatPointDirectionZniiY[];
    float $CurveDirectionZiiY[];
    float $CurvePsD[] = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
    float $FloatPointDirectVpoint[];
    float $CurveDirectionVpoint[];
    float $locsAi[];
    float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;
    float $CamNormM[] = ` MirrorFloatXYZ 0 $MultDirCam`;
    float $MidEpipolZx[] = MidPoint($CamPos_M, $CamPos_A);
    float $MidEpipolPosFCam[] = FloatPointsToCamPlane($MidEpipolZx);
    float $INTERSECTIONLA[] = lineIntersectionF($VecCurEnds[0], $EpipLolar[0], $VecCurEnds[1],  $EpipLolar[1]);
    float $INTERSECTIONLB[] = lineIntersectionF($VecCurEnds[1], $EpipLolar[0], $VecCurEnds[0],  $EpipLolar[1]);
    float $IntersectEnds_Ai[];
    float $IntersectEnds_Bi[];
    float $distsA = $NdistA;
    float $distsB = $NdistB;
    float $PtsM_Ai[];
    float $PtsM_Bi[];
    float $INTERSECTIONLC[] = lineIntersectionF($EpipLolar[0], $PtsM_Ai, $INTERSECTIONLA, $EpipLolar[2]);
    float $INTERSECTIONL2C[] = lineIntersectionF($EpipLolar[0], $VecCurEnds[0], $INTERSECTIONLC, $EpipLolar[2]);
    float $INTERSECTIONL2D[] = lineIntersectionF($EpipLolar[1],$INTERSECTIONLC, $VecCurEnds[1],  $EpipLolar[2]);
    float $INTERSECTIONL3D[] = lineIntersectionF($EpipLolar[0],$INTERSECTIONL2D,$PtsM_Ai,  $EpipLolar[1]);
    float $ThreepointVecs[];
    float $EdgeDist;
    float $smallestDistance;
    float $distancesTo3DCurveEnd[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
    float $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
    float $distancesTo3DCurveEndi[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
    float $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
    float $XX = $VecA.x;
    float $XXX = $VecB.x;
    float $step = $numEPrealNum2;
    float $StepCycle = 0;
    float $AverageC = AverageFloats($CurvatureRadi);
    float $AboveOrBelow[] = GatherDataRR($CurvatureRadi, ($AverageC-(($AverageC/6.0)*5.0)));
    float $AVvects[];
    float $Aver;
    float $MultDirOne[] = multiplyFloat(1.0, $DirectionLineF);
    float $AddMultF[] = AddFloats($PointOnLine, $MultDirOne);
    float $FDirNorA[] = Normal3Points($PointOnLine, $AddMultF, $PointN);
    float $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    float $MultDirMx[] = multiplyFloat($DistToLineSTart, $FDirNorA);
    float $AddMultMiiFx[] = AddFloats($PointOnLine, $MultDirMx);
    float $FDirNorB[] = Normal3Points($PointOnLine, $AddMultMiiFx,  $AddMultF);
    float $MultDirMxz[] = multiplyFloat($DistToLineSTart,  $FDirNorB);
    float $AddMultMiiFxz[] = AddFloats($PointOnLine, $MultDirMxz);
    float $test[] = `xform -query -ws -t`;
    float $SideA = distance2Pts( $VecA, $VecB);
    float $SideB = distance2Pts( $VecB, $VecC);
    float $SideC = distance2Pts( $VecC, $VecA);
    float $ArcangleB = acos((((`pow $SideA 2.000`) + (`pow $SideC 2.000`) - (`pow $SideB 2.000`) )/(2.000*$SideA*$SideC)));
    float $AngleNPiB = ($ArcangleB*180)/$Pi;
    float $AngleNB = $AngleNPiB;
    float $LengthA = distance2Pts ($VecPairA[0], $VecPairA[1]);
    float $LengthB = distance2Pts ($VecPairB[0], $VecPairB[1]);
    float $LengthAB;
    float $Sign_F;
    float $TransL[];
    float $DistToPlane[];
    float $EachFloatA;
    float $Subs[];
    float $SCale = $mIB[3][3];
    float $TransLb[];
    float $NewPos[] = AddFloats($TransLb, $NewAXis);
    float $XYZsAxis[];
    float $EachFloat;
    float $SignPN[];
    float $MidPt[];
    float $CamDirVecNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM",  0);
    float $MatrizFloati[] = MatrixToFloat($mI);
    float $Va[] = $FixVeci[0];
    float $Vb[] = $FixVeci[1];
    float $FloatDirMajor[] = $DirLine;
    float $FDirNorAi[] = $LineDirYT;
    float $temp = $a[$j];
    float $tempIndex = $Index[$j];
    float $centerCross[] = lineIntersection( $Vecbv[0], $DirecA, $Vecbv[1], $DirecB);
    float $DPi = (distance2Pts($VecC[0], $VecC[1]))/2.0;
    float $DPiMid = distance2Pts($VecC[0], $MidPoint);
    float $DPa = distance2Pts( $MidPoint, $VecC[2]);
    float $u = $xi - $x;
    float $w = $zi - $z;
    float $e = 1;
    float $Y = ($e*$xi);
    float $U = ($e*$yi);
    float $radiusZ = distance2Pts( $p1, $center );
    float $CenterRadius[];
    float $MultDirP[] = multiplyFloat(2, $FloatDirection);
    float $FloatDirPerpCenter[] = DirectionF($center, $mid3);
    float $FloatDirPerpCenterB[] = DirectionF($center,$mid1);
    float $FloatDirPointAB[] = DirectionF($p1, $p2);
    float $FloatDirPointBC[] = DirectionF($p2, $p3);
    float $center6[] = lineIntersection( $p1, $FloatDirPerpCenter, $p2, $FloatDirPointBC );
    float $center7[] = lineIntersection( $p3,  $FloatDirPerpCenterB, $p1, $FloatDirPointAB );
    float $center9[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPerpCenter );
    float $OrthoCenterCir[] = midPoint2Pts( $center9, $center );
    float $Radius2HalfTimes2 = (distance2Pts( $center9, $center ))*2;
    float $Radius2BHalf = (distance2Pts( $center9, $center ));
    float $Radius3Half = $radiusZ/2;
    float $SnapR = 2.59;
    float $Smooth = 398;
    float $DiffSumTol = 97.95;
    float $CamPlane1[];
    float $EpipolPosCamM[] = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;
    float $MidPosFCam[] = $CamPlane1;
    float $FloatDirEpipol[] = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    float $FloatDirEpipolB[] = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
    float $DistTOEpipol_CurEndA;
    float $DistTOEpipol_CurEndB;
    float $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
    float $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
    float $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;
    float $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    float $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
    float $BCDiff = abs($BCurEndB - $BCurEndBNN);
    float $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd;
    float $BCDiffi = abs($BCurEndB - $BCurEndBNNi);
    float $FloatDirEndPtsA[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
    float $EulerAngle_A = $EulerAngleA[3];
    float $FloatDirEndPtsB[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
    float $EulerAngleB[] = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);
    float $EulerAngle_B = $EulerAngleB[3];
    float $FloatDirEndPtsAi[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
    float $EulerAngleAi[] = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);
    float $EulerAngle_Ai = $EulerAngleAi[3];
    float $FloatDirEndPtsBi[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
    float $EulerAngleBi[] = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);
    float $EulerAngle_Bi = $EulerAngleBi[3];
    float $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
    float $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;
    float $LengCRV_b = `arclen $CurveItemZbi`;
    float $DistEndsii;
    float $DiffMathB = $DistEndsii / ($LengCRV_b/100.0);
    float $PerDiffSum = ($DiffMathA+$DiffMathB)/2.0;
    float $MidCurveB[];
    float $DDirEpipol[] = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
    float $AngleXi;
    float $PointToCamDir[];
    float $PointsClos[];
    float $distToCurveE_A[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[0]);
    float $newOrdersZA[] = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    float $Distance_A = $distToCurveE_A[$Near_index_A];
    float $Found_pt_A[] = $LocCurveEndsVec3D[$Near_index_A];
    float $newOrdersZAM[] = $Found_pt_A;
    float $distToCurveE_B[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[1]);
    float $newOrdersZB[] = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    float $Distance_B = $distToCurveE_B[$Near_index_B];
    float $Found_pt_B[] = $LocCurveEndsVec3D[$Near_index_B];
    float $newOrdersZBM[] = $Found_pt_B;
    float $distToPlaneLoc[];
    float $DistToIntersectTOnear[];
    float $distToPlaneLoc3D[];
    float $DiffMathAm = $DistToIntersectTOnear[2]/ ($distToPlaneLoc3D[2]/100.0);
    float $DiffMathBm = $DistToIntersectTOnear[3] / ($distToPlaneLoc3D[3]/100.0);
    float $relativeDistanceA = ($DiffMathA+$DiffMathAm)/2.0;
    float $relativeDistanceB = ( $DiffMathB+$DiffMathBm)/2.0;
    float $distToCurveE_AB[];
    float $Point3DAM[];
    float $Point3DA[];
    float $lineEPointA[] = MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);
    float $PtsC[];
    string $myCPOC;
    string $myCurvex;
    string $CRV_Item[] = `ls -sl`;
    string $allSegments[];
    string $keepCRV[];
    string $eachCRV;
    string $item[] = `ls -sl`;
    string $ThefirstCurve = VecArrayToCurve($Pts_CRV);
    string $NewCutCRVs[];
    string $Sel[];
    string $quickFix[] = `ls -sl `;
    string $CurveEnds3D[];
    string $CurveNames[];
    string $NewCurveNames[];
    string $CurveVecIndex[];
    string $FoundDuplicates[] = $CurveNames;
    string $CurveEND_Count_LIST[];
    string $CurveConnectionsIndex[];
    string $CurveConnectionsIndexA[];
    string $CurveConnectionsIndexB[];
    string $CurveNumber[];
    string $CurveEND_LIST[];
    string $CurveNumberIndex[];
    string $CurveNumberIndexA[];
    string $itemBackUp[] = $item;
    string $Remove[];
    string $diff[];
    string $OnePAIR = stringArrayToString(IntArrayToStringArray($CurveEndPairs), ",");
    string $ADDit[] = stringToStringArray( $OnePAIR , ",");
    string $ARRAY_A[] = stringToStringArray($CurveEND_Count_LIST[int($eachOther)], ",");
    string $ARRAY_B[] = stringToStringArray($CurveEND_Count_LIST[int($Remove[0])], ",");
    string $T[] = `ls -sl`;
    string $sAddUp = 0;
    string $stringFloat[] = $StringArrayPrint;
    string $Syb = " ";
    string $printcommand = "";
    string $AddedSPaces = AddItemString($BytNumDiff[$IndXeF], $Syb);
    string $StartOfEach[];
    string $findEachstart = "";
    string $KnownMatchi[];
    string $listItem;
    string $AddItem = "";
    string $Find = "Vec.xithis+ float Y =  uVeci/(abs(sqrt ((`pow  uVeci 2`) + (`pow  vVeci 2`) + (`pow  wVeci 2`))));
    string $resultVar = "string float vector matrix int proc";
    string $resulti = "sin cos tan tand atan asin acos atand asind acosd";
    string $result = "abs angle bessel ceil clamp constrainValue cos cross crossProduct deg_to_rad delrandstr dot dotProduct equivalent  equivalentTol erf exp floatEq floor fmod gamma gauss getLastError getProcArguments hermite hsv_to_rgb hypot linstep log mag max min noise  normalize pointMatrixMult pow rad_to_deg rand randstate rgb_to_hsv rot seed sign sin smoothstep sphrand sqrt tan trunc unitprint ";
    string $AllMathfunction = "abs ,angle ,bessel ,ceil ,clamp ,constrainValue ,cos ,cross ,crossProduct ,deg_to_rad ,delrandstr ,dot  ,dotProduct ,equivalent ,equivalentTol ,erf ,exp ,floatEq ,floor ,fmod ,gamma ,gauss ,getLastError ,getProcArguments ,hermite ,hsv_to_rgb  ,hypot ,linstep ,log ,mag ,max ,min ,noise ,normalize ,pointMatrixMult ,pow ,rad_to_deg ,rand ,randstate ,rgb_to_hsv ,rot ,seed ,sign ,sin  ,smoothstep ,sphrand ,sqrt ,tan ,trunc ,unit";
    string $MathFuncClassData = $result+" "+ $resulti + " " + $resultVar;
    string $KnownMathTermsMEL[] = stringToStringArray($MathFuncClassData, " ");
    string $KnownMathTermsMELSorted[] = `sort $KnownMathTermsMEL`;
    string $startingChar[] = StringArrayStartOfStringinArray($KnownMathTermsMELSorted);
    string $shorterListstartingChar[] = stringArrayRemoveDuplicates ($startingChar);
    string $KnownMatch[] = $KnownMathTermsMELSorted;
    string $ArrayLetter[] = $shorterListstartingChar;
    string $Arraytemp[] = $KnownMathTermsMELSorted;
    string $StartOfEachS;
    string $gatherItems = "";
    string $eachStringL;
    string $eachString;
    string $all[];
    string $tempFind = $Find;
    string $tempFindwrite = $Find;
    string $StartS;
    string $LetterItem = "";
    string $FoundVariableItems[];
    string $FoundOtherItems[];
    string $StringFromReducedArray = "";
    string $reducedArray[];
    string $allTemp[];
    string $dontUse = "";
    string $matchingDontuse = "";
    string $matching = "";
    string $match;
    string $match0;
    string $matchMiddleDiff;
    string $matchi;
    string $MatchStage2;
    string $MatchStage3;
    string $addBracktoMatch3;
    string $addBracktoMatchD;
    string $matchTemp;
    string $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    string $ArrayFind[];
    string $StartOfEachSi = "";
    string $FOUND = "";
    string $printneat = stringArrayToString($FoundVariableItems, ",");
    string $printneati = stringArrayToString($FoundOtherItems, ",");
    string $FoundTerms[] = stringToStringArray($printneat, ",");
    string $BracketF;
    string $BracketL;
    string $Fb = "{";
    string $Lb = "}";
    string $NewSt = "";
    string $listTemp[];
    string $list[];
    string $FindN = $FindZ;
    string $stringRN;
    string $match0N;
    string $CollectFinds[];
    string $newVec[];
    string $Parts[];
    string $TEMPNAMES[];
    string $FoundP[];
    string $matchString;
    string $MatchPart = "";
    string $stringNX = "";
    string $AllFOUND[];
    string $FirstBracket;
    string $text = $Find;
    string $testM = "$XI[1]= FloatToVec (MidPoint($XI[0],$XI[2]));
    string $BB = "$In3 = FloatToVec (lineIntersection($Po4[$Fi], $Xd, $li,(DirectionFN( $Ca,$li)) ));
    string $testBBracket = `match "[\(][\(]*[^.]*[^\(]*[\)]" $BB`;
    string $testB[] = BracketFind($BB);
    string $B2 = `match ".*\\[" $B`;
    string $VartoReplace = "MultLenToDirAddToPoint";
    string $OriginalStart = `match ".*\=" $testM`;
    string $M = `match "($VartoReplace*[a-zA-Z_0-9]).+\;
    string $M2 = `match "[\(][^\(]*[^.]*[^\(]*[\)]" $M`;
    string $M3 = `match "\$*[^,]*" $result`;
    string $PartS[];
    string $resultTemp = $result;
    string $Fix = $OriginalStart+"\("+$PartS[0]+"\*"+$PartS[1]+"\)"+"\+"+$PartS[2]+"\;
    string $SS;
    string $S;
    string $Expr = "\\$";
    string $ExprA = "";
    string $arrayOut[];
    string $CHANGE;
    string $Path = "C:\\Users/johnny/Documents/maya/scripts/StereoCurveZTemp.TXT";
    string $exampleFileName = ( $Path );
    string $CollectAllLines[];
    string $LineN = "";
    string $FindItem = "";
    string $stringN;
    string $MatchPartA;
    string $nextLine = `fgetline $fileId`;
    string $TempAllVarZ[];
    string $AllVarZ[];
    string $shorterListAllVarZ[] = stringArrayRemoveDuplicates ($AllVarZ);
    string $startingCharV[] = RStringArrayStartOfStringinArray($shorterListAllVarZ);
    string $NewNames[] = stringArrayCountDuplicatesAUGMENT($startingCharV,"");
    string $NewLineChange;
    string $NewLineZ[];
    string $AddLineN;
    string $PathW = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
    string $exampleFileNameW = ( $PathW );
    string $nextLineN = "";
    string $MatchPartB = "";
    string $NewLineXA = "";
    string $ScriptNAME = ("proc[^\\n]*");
    string $GlobalSNAME = ("global[^\\n]*");
    string $JustNames[];
    string $TempN[];
    string $tempCollectAllLines[];
    string $CollectAllDuplicates[];
    string $newCollectDupString[];
    string $nextLineR;
    string $InputLine = ("///THIS IS A DUPLICATE ///"+"\r"+"\n");
    string $nextLineRN;
    string $PRINTPRoc_andNumber[];
    string $StringINDEXCN;
    string $SortCountProcUse[];
    string $CurrentProc[];
    string $FoundProc[];
    string $CollectL[];
    string $CAL_temp[];
    string $FoundProcTemp[];
    string $tempCollectProc[];
    string $AllFoundProcs[];
    string $WholeProc[];
    string $DebugS[];
    string $TempStringP = "";
    string $FINDX[];
    string $matchN;
    string $Xall[];
    string $attr = $object +".matrix";
    string $CurveBetween;
    string $curveAxisS[];
    string $selItemzCi[] = `ls-sl`;
    string $CurveItemZ[] = `ls -sl`;
    string $LocZ_Pts[] = `ls -sl`;
    string $planeLocs[];
    string $AllCirTemp[];
    string $CirTemp[];
    string $curveAxis = "";
    string $CURVE[];
    string $newPlaneCurve[];
    string $ABCs = "abcdefghijklmnopqrstuvwxyz";
    string $LETTERS[] = ArrayFromAllinString($ABCs);
    string $GENOME_LETTERS = "";
    string $ConnectionSet1 = `sets -name ExistingCurveZSet`;
    string $ConnectionSet2 = `sets -name CurveZSetOne`;
    string $newSet3 = `sets -name TheLastCurvesSet`;
    string $newSet1 = `sets -name ZEdgeCurvesSet`;
    string $newSet2 = `sets -name ZPlaneCurvesSet`;
    string $newCAMSet1;
    string $GetObjList[];
    string $KnowObjList[] = $GlobalObjListA;
    string $NewObjList[];
    string $diffAZ[] = stringArrayRemoveExact($GetObjList,$KnowObjList);
    string $diffCZ[] = stringArrayRemoveExact($KnowObjList, $GetObjList);
    string $diffBZ[] = stringArrayRemoveExact($diffAZ,$KnowObjList);
    string $listofallcurves[];
    string $ObjectsINcamLightCone[];
    string $OutofRange[];
    string $shortnameL;
    string $CurveItem[] = $listofallcurves;
    string $NurbplaneB = "LiveSurfaceBShape";
    string $ObjectsInFrontZ[];
    string $LocPointinPlane[];
    string $LocCurveEnds[];
    string $AllLocCurveEnds[];
    string $CurveLocPlanePoints[];
    string $shorterList[] = stringArrayRemoveDuplicates ($ObjectsINcamLightCone);
    string $queryLocB[];
    string $queryLocOnLivePlaneB[];
    string $queryLocCurveEnds[];
    string $querylayerMidPoint[];
    string $CurveSelection[];
    string $NameStart = ("LOC"+$CurveItem[0]+"START");
    string $NameEnd = ("LOC"+$CurveItem[0]+"END");
    string $LocSTART[] = `spaceLocator -p 0 0 0 -n $NameStart`;
    string $LocEND[] = `spaceLocator -p 0 0 0 -n $NameEnd`;
    string $STARTENDcurveLocs[] = { $LocSTART[0], $LocEND[0]};
    string $ObjectList[];
    string $ObjectsInFrontOfPlane[];
    string $EdgesSurface[];
    string $allObjectsInPlane[];
    string $stringName = ("Plane"+ $allObjectsInPlane[$inDexName]);
    string $isitYup = `upAxis -q -ax $cameraName`;
    string $selectionList[] = `ls -sl`;
    string $ppm;
    string $LocObjects[] = `spaceLocator -p 0 0 0`;
    string $idnodeType2;
    string $Relativesselection[];
    string $isSelectedZx[];
    string $POSAe = $FloatZ[0];
    string $POSCe = $FloatZ[2];
    string $nameAe;
    string $averaging[];
    string $nametypeZ[] = `ls -showType $C`;
    string $nameA;
    string $OBJall[] = `sets -q CurveZSetOne`;
    string $Intnumbers;
    string $array[];
    string $floatnumbers;
    string $K = "";
    string $curve = "curve -d 1";
    string $Newcurvez = `eval($curve)`;
    string $oneItemz[] = `ls -sl`;
    string $newOrderArray[];
    string $stringIndexTrack[] = IntArrayToStringArray($IndexTrack);
    string $nametypeZi;
    string $nameB;
    string $multNode;
    string $ThreePoints[] = { "0", "1", "2"};
    string $curveA = "curve -d 1";
    string $curveB = "curve -d 1";
    string $NewcurvezA = `eval($curveA)`;
    string $NewcurvezB = `eval($curveB)`;
    string $NewcurvezAB[];
    string $stringF[];
    string $EmptyIndx[];
    string $stringIndTr[] = IntArrayToStringArray($index);
    string $queryLocCurveEndsOLD[] = $queryLocCurveEnds;
    string $newNames;
    string $NearCurvesEnds[];
    string $BothCurves[];
    string $EmptyStringNewOrderA[];
    string $LocA = $queryLocCurveEnds[$NearestInt[0]];
    string $LocB = $queryLocCurveEnds[$NearestIntB[0]];
    string $LocName;
    string $Loc_AorB = "";
    string $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    string $AllarrayCurvesNear[];
    string $NewFoundLocs[];
    string $arrayCurvesNear[];
    string $CurvesV[];
    string $LocsV[];
    string $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    string $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    string $VanishingLOC[];
    string $DirectionsZ[] = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    string $Alll = "";
    string $AllStrings[];
    string $EmptyIndxNewOrder[];
    string $BestThree[];
    string $CirTempi[];
    string $newCurveii;
    string $CurveAv[];
    string $newNamesResultA1;
    string $ThreeDCurvesNear[];
    string $queryLocCurveEnds3D[];
    string $CurveItemAa[];
    string $StringAllNearA[];
    string $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    string $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    string $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    string $arrayCurvesNearA[];
    string $newNamesResultAx = substituteAllString($newNames, "Plane", "");
    string $arrayCurvesNearA1[];
    string $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    string $LocNames[];
    string $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
    string $myCurve = $curvesZ;
    string $CurveEPzCount = size  ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    string $CRVendPts[];
    string $circlesItemA[];
    string $circlesItem[];
    string $CrvNA[];
    string $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    string $LayerCurvesRangeA[];
    string $ThefirstCurvei;
    string $AllLocs_String[] = IntArrayToStringArray($AllLocsi);
    string $EmptyStringNewOrderB[];
    string $XLocsA = $NewFoundLocs[0];
    string $XLocsB = $NewFoundLocs[1];
    string $Na = (match ("[0-9]+", $XLocsA));
    string $Nb = (match ("[0-9]+", $XLocsB));
    string $arrayCurvesNearB[];
    string $itemAll[] = `ls -sl`;
    string $CamConeLocator[];
    string $MakespaceLocator[];
    string $objectZ[];
    vector $PointCRV;
    vector $Zero = <<0,0,1.5>>;
    vector $NewCurveVec[];
    vector $AXIS_XZY[];
    vector $p = $VecN[0];
    vector $n1 = $VecN[1];
    vector $PtsZ_A[];
    vector $AXIS = <<1,0,0>>;
    vector $RotatedAxis = $AXIS;
    vector $CRVSEG_A[];
    vector $CRVSEG_B[];
    vector $One[];
    vector $PositionsZ_A[];
    vector $Pts_CRV[];
    vector $Positions[];
    vector $VecN[];
    vector $V[];
    vector $D_v = <<0,0,1>>;
    vector $N_roti[];
    vector $Direction[];
    vector $vecRsA[];
    vector $NewPtsP[];
    vector $PtsVec;
    vector $Tran;
    vector $DirectC = DirectionFN($vecRs[0], $Midp);
    vector $tan = crossProduct($DirectC,$AvN, 0, 0 );
    vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
    vector $RECORD[];
    vector $VlocA;
    vector $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    vector $VecLineDir = PositiveDir($DirectionLineF);
    vector $VecLineDirM = $VecLineDiri-$VecLineDir;
    vector $DF = FloatToVec($DirectionLineF);
    vector $PoL = FloatToVec($PointOnLine);
    vector $PN = FloatToVec($PointN);
    vector $LocCurveEndsVec[] = ProjectCrv2PlaneNormalP($AllKnowVecEnds,$CamNormal*-1,$CamPosA[0]);
    vector $NewVecEnds[] = GetVectorArrayCRVEnds($NewCurveNames);
    vector $Avec = $AllKnowVecEnds[$DistSortA[0]];
    vector $Bvec = $AllKnowVecEnds[$DistSortB[0]];
    vector $CurvEnd[] = PointArrayT($CurveEnds3D);
    vector $CameraN = FloatToVec(nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0));
    vector $CamPosA;
    vector $VecBii[] = ProjectCrv2PlaneNormalP($CurvEnd,$CameraN*-1,$CamPosA);
    vector $ptVecWs = $eachVV;
    vector $ptVecCs = screenSpaceVecMult($ptVecWs,$cam_mat);
    vector $XYv = $ptVecCs;
    vector $Tdd[] = PointArrayT(`ls-sl`);
    vector $Dir = DirectionF($Tdd[0],$Tdd[1]);
    vector $EV = ($Dir*2.5)+$T[0];
    vector $TD[] = PointArrayT(`ls-sl`);
    vector $VecBi[] = ProjectCrv2PlaneNormalP($TD,$Dir,$Tdd[0]);
    vector $CamNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    vector $vecRs[];
    vector $AvN = $CamNormal*-1;
    vector $Midp = $CamPosA[0];
    vector $vecT[];
    vector $indexStartEnd[];
    vector $Poii[];
    vector $PtsVecAi[] = PointArrayT($selItemzCi);
    vector $NewAXis = MultPointMatrixPlusRel( $PtsVecAi[1], $MatrixNewB,$MatrixNewC);
    vector $newVecs[];
    vector $VPos_MC[];
    vector $PlaneLocZ[];
    vector $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM`;
    vector $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM`;
    vector $PtsVecA[] = PointArrayT(`ls -sl`);
    vector $PtsVecAX = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[1], $PtsVecA[2], $PtsVecA[3]));
    vector $PtsVecAY = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[3], $PtsVecA[1], $PtsVecA[2]));
    vector $PtsVecCross = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[2], $PtsVecA[1], $PtsVecA[3]));
    vector $Normal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    vector $DirLineCamXepip = DirectionFN( $PtsVecAX,$Cam_Trans);
    vector $Nvec = ($DirLineCamXepip*2.0)+$PtsVecAX;
    vector $PtsM_A[];
    vector $Line[];
    vector $CamM_B[];
    vector $SQuarePts[];
    vector $pointMakeS[];
    vector $DirNorA = Normal3Points($SQuarePts[0],  $pointMakeS[0], $pointMakeS[1]);
    vector $DirVector[];
    vector $PtsVecTemp[] = PointArrayT(`ls -sl`);
    vector $CrvN[];
    vector $norm = $DirectionVector[0];
    vector $bi = $DirectionVector[1];
    vector $AllLocPositionsZi[];
    vector $MMVEC[] = VecPointsMirrorVecPlaneN($PtsVec,$AXIS_XZY);
    vector $PlaneP = <<$PtZ[0],$PtZ[1],$PtZ[2]>>;
    vector $DirLineN = << 0.0, 0.0 , 1.0 >>;
    vector $DirLineX = << 1.0, 0.0 , 0.0 >>;
    vector $DirLineY = << 0.0, 1.0 , 0.0 >>;
    vector $DirLineCamTOx = DirectionFN($XcrossP,$PtsVecAX);
    vector $DirLineCamTOy = DirectionFN($XcrossP,$PtsVecAY);
    vector $DirLineAX = DirectionFN($PtsVecAX, $PtsVecCross);
    vector $DirLineAY = DirectionFN($PtsVecAY, $PtsVecCross);
    vector $DirLineYp = << 0.0, 1.0 , 0.0 >>;
    vector $DirLineYR = DirectionFN($VPos_MC[2], $VPos_MC[3]);
    vector $AllLocPositionsZ[];
    vector $AllPlaneLocPositionZ[] = VecPointsToCameraPlaneB($AllLocPositionsZ);
    vector $FixVec[] = PointArrayT($quickFix);
    vector $objVecMain[];
    vector $firstReduction[];
    vector $newAddedVec[] = PointArrayT($diffCZ);
    vector $VecArrayRemainsZ[];
    vector $AllCurveLocArrayVec[];
    vector $AllCurvePlaneLocZ[];
    vector $CurveLocArrayVec[];
    vector $VecArray[];
    vector $VecArrayRemains[];
    vector $ObjectToCamShiftA;
    vector $SurfEnds[] = PointArray($EdgesSurface);
    vector $MiddlePointA[];
    vector $DirectionsToCent[];
    vector $PointsZ[] = $firstReduction;
    vector $AllPointsInplane[];
    vector $NewVecArray[];
    vector $unitVectormagZYHL[];
    vector $xvex = << $posA[0], $posA[1], $posA[2] >>;
    vector $worldPos = `xform -q -ws -rp  $oneItemz[0]`;
    vector $newOrderVec[];
    vector $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
    vector $VecR[];
    vector $ReturnValVec = FloatToVec($NewPoint);
    vector $planePointN;
    vector $AllPlaneLocs[];
    vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
    vector $Ui = FloatToVec($p1p2);
    vector $Vi = FloatToVec($p1p3);
    vector $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;
    vector $U1 = TwoVecsOrFloats($point2, $point1);
    vector $V1 = TwoVecsOrFloats($point3, $point1);
    vector $U2 = TwoVecsOrFloats($point3, $point1);
    vector $V2 = TwoVecsOrFloats($point2, $point1);
    vector $U3 = TwoVecsOrFloats($point1, $point3);
    vector $V3 = TwoVecsOrFloats($point2, $point3);
    vector $normalV[];
    vector $eachVecLine;
    vector $Xdirect;
    vector $Ydirect;
    vector $Zdirect;
    vector $XYZdirect[];
    vector $NewDirectionZ;
    vector $VecCurEnds[] = VecCurveEnds({$TempCrv});
    vector $EndSnapAndEndProject[];
    vector $endNotNearZ[];
    vector $NearEndZ;
    vector $LocOnPlaneVec[] = PointArray($arrayCurvesNear );
    vector $Loc3D_Vec[] = PointArray($NewFoundLocs );
    vector $ALLLoc3D_VecAB[] = PointArray($AllarrayCurvesNear);
    vector $ReducedVecAB[];
    vector $ALLLoc3D_Vec[];
    vector $MovedEndPointPlane[] = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    vector $CRV_ENDSi[];
    vector $DDirEpipolXYZ[];
    vector $EpipolD[];
    vector $AllEpipolXYZ[];
    vector $XYZdirectL[];
    vector $LineMidi;
    vector $NewDirZi;
    vector $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    vector $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    vector $Dir_CamRay;
    vector $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    vector $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);
    vector $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    vector $each;
    vector $NearPointsXYZ[];
    vector $ReducedVec[];
    vector $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    vector $VecLineDirMi;
    vector $PointN_LineXYZ;
    vector $SnapN;
    vector $SnapPlaceN;
    vector $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);
    vector $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    vector $Points3DPair_And_2DPair[];
    vector $Crv_Pts[];
    vector $MirrorAcrossPlaneVecs[] = VecMultMatrixMirror($Crv_Pts);
    vector $FLoatPointA[];
    vector $DirLine = DirectionFN( $VecLoc, $Pos_A);
    vector $TranstatedVecs[];
    vector $PositionsZ_Ax[];
    vector $ZYplaneMatrix[];
    vector $VecDirection_A_XYZ[];
    vector $VecDirectionXYZ[];
    vector $VecXYZsOnPlane[] = VecPointsToCameraPlane($VecXYZs);
    vector $VecXYZsOnPlaneiY[];
    vector $VecXYZsOnPlaneiiY[];
    vector $VecXYZsOnPlaneVpoint[];
    vector $EpipLolar[];
    vector $PositionsZ_Aii[];
    vector $HighCurvePoints[];
    vector $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
    vector $Dir_VecA;
    vector $VecPtsMirrorEnds_A[];
    vector $VIntersectEnds_A[];
    vector $ObjLoc3DCurv[];
    vector $LocCurveEndsVec_3D[] = PointArray($arrayCurvesNearA1);
    vector $LoCz_3D[];
    vector $TXI = << -1.0 , 1.0, 1.0>>;
    vector $NearVecPts[];
    vector $PositionsZ_Aiix[];
    vector $VecTest[];
    vector $LocCurveEndsVec3D[] = PointArray($queryLocCurveEnds3D);
    vector $FistAndSecond[];
    vector $VecA = $FistAndSecond[0];
    vector $VecB = $FistAndSecond[1];
    vector $PositionsZ_Ai[];
    vector $ReversePositionsZ_Ai[] = ReverseVectorArray($PositionsZ_Ai);
    vector $PtsMirrorAi[];
    vector $XIntersect_Ax[];
    vector $CurveVectors[];
    vector $ReturnVec[];
    vector $CRV_EndsVec[];
    vector $CRV_PlaneNorm[];
    vector $EmptyVecA[];
    vector $EmptyVecB[];
    vector $NVecPointZ[];
    vector $VecROne[] = GetRotationVectorsMatrix($mIA );
    vector $tranSVec = << $TransL[0], $TransL[1], $TransL[2]>>;
    vector $tranSVecA = $VecROne[0]+$tranSVec;
    vector $tranSVecC = $VecROne[2]+$tranSVec;
    vector $SVecii[];
    vector $SVecPoint = $SVeci;
    vector $YZvec = PointToPlaneN($SVecPoint, $SVecii);
    vector $ZXvec = PointToPlaneN($SVecPoint, $SVecii);
    vector $XYvec = PointToPlaneN($SVecPoint, $SVecii);
    vector $VecPlanes[];
    vector $VecLineDirM_All[];
    vector $SIgnA[] = GetVectorFloatSign( $VecLineDirM_All);
    vector $SIgnB[] = GetVectorFloatSign($VecROne);
    vector $EachVec;
    vector $EachVecT;
    vector $NewPosVec = <<$NewPos[0], $NewPos[1], $NewPos[2]>>;
    vector $VecSIGNDirM[];
    vector $eachPointVd;
    vector $Vperp = crossProduct( $DirLine, $CamDirVecNormal, 0, 0 );
    vector $BInomalV = FloatToVec(MultLenToDirAddToPoint(2, $Vperp, $PtsVec[0]));
    vector $BInomalVDirLine = PositiveDirectionLine($PtsVec[0], $BInomalV);
    vector $TangentV = FloatToVec(MultLenToDirAddToPoint(4,$CamDirVecNormal,  $PtsVec[0]));
    vector $bi_two = `cross $tan $norm`;
    vector $FixVeci[];
    vector $LineAMain;
    vector $DirMTestVec;
    vector $ZeroA = <<0.0, 0.0, 0.0>>;
    vector $LineA = PositiveDirectionLine($FixVecB[0], $FixVecB[1]);
    vector $pointYVec = ClosestPoint2LineVec($LineA, $FixVecB[0], $ZeroA);
    vector $LineDirYT = PositiveDirectionLine($pointYVec, $ZeroA);
    vector $DirNormi = $LineDirYT;
    vector $DirecA = FloatToVec(DirectionFN($Vecbv[0],$Vecbvi[1]));
    vector $DirecB = FloatToVec(DirectionFN($Vecbv[1],$Vecbvi[0]));
    vector $VecC[];
    vector $MidPoint = FloatToVec (MidPoint($VecC[0], $VecC[1]));
    vector $Vai = << $posAZ[0], $posAZ[1], $posAZ[2] >>;
    vector $Vbi = << $posBZ[0],  $posBZ[1], $posBZ[2] >>;
    vector $VbiUnit = << $u, $v, $w >>;
    vector $VbiUnitA = `unit $VbiUnit`;
    vector $YUV = << $Y, $U, $V>>;
    vector $VecS[] = $AllVecsG;
    vector $EndrEndsa[];
    vector $VecCurEndsa[] = VecCurveEnds({$CurveItemZai});
    vector $VecCurEndsb[] = VecCurveEnds({$CurveItemZbi});
    vector $PositionsZ_B[];
    vector $VecPtsMirrorA[];
    vector $VecPtsMirrorB[];
    vector $VecPtsMirrorEnds_B[];
    vector $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
    vector $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);
    vector $Vecbv[];
    vector $Vecbvi[];
    vector $NewVecENDsi[];
    vector $CRV_ENDSii[];
    vector $PointsA[];
    vector $PointsB[];
    vector $VecOnPlaneA[];
    vector $VecOnPlaneB[];
    vector $IntersectEnds_Ax[];
    vector $Intersect_A[];
    vector $PositionsZ_Bi[];
    vector $PositionsZ_Bii[];
    vector $UnconnectedEnds[];
    vector $Intersect_LineB_a;
    vector $Intersect_LineB_b;
    vector $Xdirection = << 1.0,0.0,0.0>>;
    vector $Intersect_BX[];
    vector $PairVectors[];
    vector $EpipolXLine;
    vector $CrvNormalA[] = CRVEndNormals( $CrvNA[0] );
    vector $CrvNormalB[] = CRVEndNormals( $CrvNA[1] );
    vector $aveNorm = unit(($CrvNormalA[$START_END[0]]+$CrvNormalB[$START_END[1]])/2.0);
    vector $MidPointC = ($Intersect_A[0]+$Intersect_A[`size($Intersect_A)`-1])/2.0;
    vector $NormPts = (($aveNorm*2.5)+$MidPointC);
    vector $P1 = ClosestPoint2LineVecX($DirectC, $MidPointC, $NormPts);
    vector $NewNormal = (DirectionFN($NormPts, $P1));
    vector $AB_endPts[];
    vector $NewFvec[];
    vector $Intersect_B[];
    vector $ViNew[];
    vector $VecMult;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    global int $in_front_of_PlaneX;
    global vector $WORLD_AXIS_XYZ[];
    $SizeC = `size($CURVES)`;
    $Zero = <<0,0,1.5>>;
    for($iC=0; $iC<$SizeC; $iC++){
    $myCurvex=$CURVES[$iC];
    ////
    $myCPOC = `pointOnCurve  -ch on -pr 0.0 -p $myCurvex`;
    setAttr ($myCPOC +  ".parameter") 0.5 ;
    $PointCRV  = `getAttr  ($myCPOC + ".position")`;

    /*
    $distanceA=PtDist_to_Plane({$PointCRV},{$Zero,$WORLD_AXIS_XYZ[0]});
    print ($in_front_of_PlaneX+"\n");
    $TrackInfrontA[0]=$in_front_of_PlaneX;
    $distanceB=PtDist_to_Plane({$PointCRV},{$Zero,$WORLD_AXIS_XYZ[1]});
    */

    $distanceA=PtDist_to_Plane({$PointCRV},{$WORLD_AXIS_XYZ[0]});
    print ($in_front_of_PlaneX+"\n");
    $TrackInfrontA[0]=$in_front_of_PlaneX;
    $distanceB=PtDist_to_Plane({$PointCRV},{$WORLD_AXIS_XYZ[1]});


    $TrackInfrontA[1]=$in_front_of_PlaneX;
    print ($in_front_of_PlaneX+"\n");
    if(( $TrackInfrontA[0] ==0)&&( $TrackInfrontA[1] ==1)){
    //if((`sign($TrackInfrontA[0])`==1)&&(`sign($TrackInfrontA[1])`==-1)){
    $curves_Keep[$iC] = 1;
    }else{
    $curves_Keep[$iC] = 0;
    }
    delete $myCPOC;
    }
    print $TrackInfrontA;
    return $curves_Keep;
    }

    //int $keep[];
    //$keep=DELETE_OR_KEEP($allSegments);


    proc vector [] RenderCurveSeg(string $SelC,float $STEPCrv,float $CrvTSi,float $CrvTEi){
    //#print " RenderCurveSeg " ; print "line 870 "; print "\n" ;
    //float $STEPCrv =22.0;
    $CreateSegAT =FloatArrayAB($CrvTSi,$CrvTEi,$STEPCrv);
    $myCurvex = $SelC;
    $myCPOC = `pointOnCurve  -ch on -pr 0.0 -p $myCurvex`;
    $SizeSeg = `size($CreateSegAT)`;
    $CountT = 0;
    $t = 0;
    for($a = 0; $a < $SizeSeg;$a++){
    $t =  $CreateSegAT[$CountT];
    if($t>=1){$t=1;}
    if($t<=0){$t=0;}
    setAttr ($myCPOC +  ".parameter") $t ;
    $NewCurveVec[$CountT] = `getAttr  ($myCPOC + ".position")`;
    $CountT++;
    }
    delete $myCPOC;
    return $NewCurveVec;
    }


    global int $in_front_of_PlaneX;
    global int $TrackInfront[];


    proc float [] Cut_CRV_Axis(string $myCurvex,int $axis){

    global vector $WORLD_AXIS_ORIGIN;
    global vector $WORLD_AXIS_XYZ[];
    $AXIS_XZY[0]=$WORLD_AXIS_ORIGIN;
    $AXIS_XZY[1]=$WORLD_AXIS_XYZ[$axis];



    global int $in_front_of_PlaneX;

    global int $TrackInfront[];


    $CurveSelection = `ls -fl  ($myCurvex+".ep[0:*]")`;
    $CurveEPzCount = size($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum2 = ( $numEPs -1 ) * 2;
    $numEPrealNum3 = ( $numEPs -1 );
    $myCPOC = `pointOnCurve  -ch on -pr 0.0 -p $myCurvex`;
    $ArcL = `arclen $myCurvex`;
    $Steps_toG = (1.0/$numEPrealNum3)/4;

    $step = $numEPrealNum2;
    $step = $numEPrealNum3;
    $a =0;
    //$t =  $a/$step;
    $t =0;
    $ArcLT= $ArcL;
    $TrackIT = 0;
    for($a = 0; $t <= 1.0;$a++){

    setAttr ($myCPOC +  ".parameter") $t ;
    $PointCRV  = `getAttr  ($myCPOC + ".position")`;
    $distance=PtDist_to_Plane({$PointCRV},$AXIS_XZY);
    print ($in_front_of_PlaneX+"\n");
    if($TrackIT==0){
    $TrackInfront[`size($TrackInfront)`]=$in_front_of_PlaneX;
    }
    $TrackIT++;
    if($distance<$ArcL){

    $Steps_toC =PercentofN($ArcL,$distance);
    $Steps_toD =((100.0-$Steps_toC)/100.0)/2.0;
    $t += $Steps_toD;
    }
    if($distance<0.0008){
    $TrackIT=0;
    Loc $PointCRV;
    $findPointU[`size($findPointU)`] = $t;
    print ("steps Taken : "+$a+"\n");
    $t +=$Steps_toG;
    }
    if($a>3900){break;}

    }
    delete $myCPOC;
    return $findPointU;
    }



    proc float PtDist_to_Plane(vector $V[],vector $VecN[]){
    global int $in_front_of_PlaneX;
    $p = $VecN[0];
    $n1 = $VecN[1];
    $F = $n1;
    $e = $V[0];
    $M = $e+($F);
    $D = distance2PtS($e, $p);
    if((`sign ($D)`==1)||($D==0)){
    $in_front_of_PlaneX=1; print $D;
    }else{$in_front_of_PlaneX=0; print $D;
    }
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $D1 = distance2Pts($P1, $p);
    return $D1;
    }


    proc float distance2PtS( float $p1[], float $p2[] ){
    $v[0] = $p1[0] - $p2[0];
    $distance = $v[0];
    return $distance;
    }

    // radial
    /*


    global vector $WORLD_AXIS_XYZ[];
    $WORLD_AXIS_XYZ[0]=<<1,0,0>>;
    $WORLD_AXIS_XYZ[1]=<<0,0,1>>;
    global vector $WORLD_AXIS_ORIGIN;
    $WORLD_AXIS_ORIGIN=<<0,0,0>>;


    //////////START
    PencilCurveTool;

    $CRV_Item = `ls -sl`;
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 22 -d 3 -tol 0.05 $CRV_Item[0];

    clear $N_Us;
    $N_Us= Cut_CRV_Axis($CRV_Item[0],0);

    print $TrackInfront;
    clear $TrackInfront;

    clear $N_UsB;
    $N_UsB= Cut_CRV_Axis($CRV_Item[0],1);

    $N_UsS=$N_Us;
    $Usize = `size($N_UsB)`;
    for($iC=0; $iC<$Usize; $iC++){
    $N_UsS[`size($N_UsS)`]=$N_UsB[$iC];
    }
    print $N_UsS;

    //print $N_Us;
    //$N_UsS=$N_UsB;
    $N_UsS =`sort($N_UsS)`;
    $allSegments = Cut_and_Mirror($N_UsS,$CRV_Item[0]);

    $keep=DELETE_OR_KEEP($allSegments);
    for($iC=0; $iC<`size($keep)`; $iC++){
    if($keep[$iC]==1){
    $keepCRV[`size($keepCRV)`]=$allSegments[$iC];
    }else{delete $allSegments[$iC];}
    }



    /// for each in remaining CRV get vectors // this is just to test the radial SCRIPTS
    $AXIS = <<1,0,0>>;
    $RotatedAxis = $AXIS;
    for ($eachCRV in $keepCRV ){
    $PtsZ_A = VecCurveCvs($eachCRV);
    $CRVSEG_B= $PtsZ_A;
    $theta = 90;
    for($Inx = 0; $Inx < 3; $Inx++){
    $CRVSEG_B=VecPointsMirrorVecPlaneN($CRVSEG_B,{<<0,0,0>>,$RotatedAxis});
    PAUSE;
    UnitMATRIX;
    SetGMATRIX;
    $MatrixC= $MatrixGlobalA;
    $MatrixD= $MatrixGlobalA;
    yrotMATRIX(($theta));
    SetGMATRIX;
    $MatrixD= $MatrixGlobalA;
    $One=MultPointMatrixArray({$RotatedAxis}, $MatrixC,$MatrixD);
    $RotatedAxis= $One[0];
    }

    }


    for($Inx = 0; $Inx <= (360/45); $Inx++){
    //$MatrixC= $MatrixGlobalA;







    $Inx++;



    proc vector [] VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){
    $p = $VecN[0];
    $n1 = $VecN[1];
    $F = $n1;
    $C1=0;
    for($e in $V){
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+(($D1*2.0)*$F3);
    $O[$C1] = $F4;
    $C1++;
    }
    VecArrayToCurveB($O);
    ResetTransEachSL;

    return $O;
    }


    proc float VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){
    $p = $VecN[0];
    $n1 = $VecN[1];
    $F = $n1;
    $e = $V[0];
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    return $D1;
    }



    $item = `ls -sl`;
    select -r $item[0];
    $PositionsZ_A = VecCurveEps($item[0]);




    $Pts_CRV=$PositionsZ_A;
    $theta = 90;
    UnitMATRIX;
    SetGMATRIX;
    $MatrixC= $MatrixGlobalA;
    PrintMatrix($MatrixC , 4);
    $MatrixD= $MatrixGlobalA;
    $MatrixE=$MatrixGlobalA;
    $Inx = 2;

    //	for($Inx = 0; $Inx <= (360/45); $Inx++){
    //$MatrixC= $MatrixGlobalA;

    //UnitMATRIX;
    //SetGMATRIX;

    yrotMATRIX(($theta));
    SetGMATRIX;
    $MatrixD= $MatrixGlobalA;

    if(fmod($Inx,3)==0){
    print " YES 3 ";}

    if(fmod($Inx,3)==0){
    print "  YES 2  ";

    /*
    $MatrixC[0][0]=($MatrixC[0][0]*-1);
    $MatrixC[1][0]=($MatrixC[1][0]*-1);
    $MatrixC[2][0]=($MatrixC[2][0]*-1);
    */
    $MatrixD[0][0]=($MatrixD[0][0]*-1);
    $MatrixD[1][0]=($MatrixD[1][0]*-1);
    $MatrixD[2][0]=($MatrixD[2][0]*-1);

    $MatrixD[3][3]=($MatrixD[3][3]*-1);

    }


    $RotatedAxis = MultPointMatrixArray({$AXIS}, $MatrixC,$MatrixD);
    $ThefirstCurve = VecArrayToCurve($Pts_CRV);

    $Inx++;

    $MatrixE=$MatrixD;

    $MatrixGlobalA=$MatrixE;
    SetGMATRIX;



    $Mn  = MatrixToFloat($MatrixGlobalA);
    ShowMatrixAXIS($Mn);
    }










    what need to be done is make  it so that .. name sysmetry

    */


    proc string [] Cut_and_Mirror(float $N_Us[],string $CRV_ItemI){
    global vector $WORLD_AXIS_XYZ[];
    global vector $WORLD_AXIS_ORIGIN;
    $Sel[0]=$CRV_ItemI;
    $SizeCuts = `size($N_Us)`;
    $iU = $N_Us;
    $Arc = `arclen($CRV_ItemI)`;
    if($SizeCuts>0){
    $Tsize = `size($iU)`;
    if($Tsize!= 1){

    $MperS = ($Arc*($iU[0]));
    $MperE = ($Arc*(1-$iU[$SizeCuts-1]));
    if( $MperS >= 5.5){
    $TempU[`size($TempU)`]=0.0;
    $m_Or_e[`size($m_Or_e)`]=1;
    }
    for($iC=0; $iC<$SizeCuts; $iC++){
    $TempU[`size($TempU)`]=$iU[$iC];
    }
    for($iC=0; $iC<$SizeCuts-1; $iC++){
    $m_Or_e[`size($m_Or_e)`]=0;
    }
    if($MperE>=5.5){
    $TempU[`size($TempU)`]=1.0;
    $m_Or_e[`size($m_Or_e)`]=2;
    }
    $iU=$TempU;
    }

    if($Tsize== 1){
    $TempUi[0]=0.0;
    $TempUi[1]=$iU[0];
    $TempUi[2]=1.0;
    $iU=$TempUi;
    $MperS = (100*($iU[1]));
    $MperE = (100*(1-$iU[1]));
    if( $MperS >= 15){$TempU[`size($TempU)`]=0.0; $m_Or_e[`size($m_Or_e)`]=1;  }
    $TempU[`size($TempU)`]=$iU[1];
    if($MperE>=15){$TempU[`size($TempU)`]=1.0; $m_Or_e[`size($m_Or_e)`]=2; }
    clear $iU;
    $iU=$TempU;
    }



    $AXIS_XZY[0]=$WORLD_AXIS_ORIGIN;
    $AXIS_XZY[1]=$WORLD_AXIS_XYZ[0];

    $AXIS_Z[0]=$WORLD_AXIS_ORIGIN;
    $AXIS_Z[1]=$WORLD_AXIS_XYZ[1];





    $Hsize = `size($iU)`;
    $Hsize-=1;

    for($iC=0; $iC<$Hsize; $iC++){
    clear $CRVSEG_A;
    $CrvTSi = $iU[$iC];
    $CrvTEi = $iU[$iC+1];
    $Mper = ($Arc*($iU[$iC+1]-$iU[$iC]));
    $CRVSEG_A=RenderCurveSeg($Sel[0],22,$CrvTSi,$CrvTEi);
    PAUSE;
    $NewCutCRVs[`size($NewCutCRVs)`]=VecArrayToCurveB($CRVSEG_A);
    }
    delete $Sel[0];
    }else{ $NewCutCRVs[`size($NewCutCRVs)`]=$Sel[0]; }

    return $NewCutCRVs;

    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




    $quickFix = `ls -sl `;
    clear $Positions;
    $Positions = PointArrayT($quickFix);

    //proc vector [] VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){

    $VecN={(<<0,0,0>>),(<<1,0,0>>)};
    $V={$Positions[0]};
    $p = $VecN[0];
    $n1 = $VecN[1];

    $F = $n1;
    $C1=0;

    /////////////for($e in $V){////////////
    $e = $V[0];
    $M = $e+($F);


    $D = distance2PtS($e, $p);

    if((`sign ($D)`==1)||($D==0)){
    print ("yes"+"\n");
    }else{print ("NO!"+"\n");}

    proc float distance2PtS( float $p1[], float $p2[] ){
    $v[0] = $p1[0] - $p2[0];
    $distance = $v[0];
    return $distance;
    }



    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+(($D1*2.0)*$F3);
    $O[$C1] = $F4;
    $C1++;
    }
    VecArrayToCurveB($O);
    ResetTransEachSL;

    return $O;
    }


    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    ///////////////////////////////////

    ///////////////////////////////////





    proc vector [] VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){
    $p = $VecN[0];
    $n1 = $VecN[1];
    $F = $n1;
    $C1=0;
    for($e in $V){
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+(($D1*2.0)*$F3);
    $O[$C1] = $F4;
    $C1++;
    }
    VecArrayToCurveB($O);
    ResetTransEachSL;

    return $O;
    }








    $D_v = <<0,0,1>>;
    //vector $D_v =<<-1,0,0>>;
    Loc $D_v;
    clear $N_roti;
    $N_roti=RotateDir_Axis(1, 45, <<1,0,0>>, $D_v);
    LocS $N_roti;

    print $N_roti;


    $N_roti[0]=RotateDir_Axis(1, 45, <<1,0,0>>, $N_roti[0]);
    LocS $N_roti;



    proc yrotMATRIX(float $theta) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static;

    $theta *= ($PI_Static / 180.0);
    $ct = cos($theta);
    $st = sin($theta);
    $Nxx = (float) ($xx * $ct + $zx * $st);
    $Nxy = (float) ($xy * $ct + $zy * $st);
    $Nxz = (float) ($xz * $ct + $zz * $st);
    $Nxo = (float) ($xo * $ct + $zo * $st);
    $Nzx = (float) ($zx * $ct - $xx * $st);
    $Nzy = (float) ($zy * $ct - $xy * $st);
    $Nzz = (float) ($zz * $ct - $xz * $st);
    $Nzo = (float) ($zo * $ct - $xo * $st);
    $xo = $Nxo;
    $xx = $Nxx;
    $xy = $Nxy;
    $xz = $Nxz;
    $zo = $Nzo;
    $zx = $Nzx;
    $zy = $Nzy;
    $zz = $Nzz;
    }




    proc vector [] RotateDir_Axis(float $Rot_T, float $theta, vector $Axis, vector $Direct) {

    $xx=$Axis.x; $xy=$Axis.y; $xz=$Axis.z;
    $zx=$Direct.x; $zy=$Direct.y; $zz=$Direct.z;
    $PI_Static = 3.14159265;

    $theta *= ($PI_Static / 180.0);
    $ct = cos($theta);
    $st = sin($theta);


    for($i = 0; $i < 4;$i++){
    $ct = cos($theta);
    $st = sin($theta);

    $Nzx[0] = (float) ($zx * $ct + $xx * $st);
    $Nzx[1] = (float) ($zy * $ct + $xy * $st);
    $Nzx[2] = (float) ($zz * $ct + $xz * $st);
    $zxi = $Nzx[0];
    $zyi = $Nzx[1];
    $zzi = $Nzx[2];
    $zx = $Nzx[0];
    $zy = $Nzx[1];
    $zz = $Nzx[2];

    $theta+=$theta;

    $Nzx=$Direction[$i]=`unit(<<$zx, $zy, $zz>>)`;
    $zx = $Nzx[0];
    $zy = $Nzx[1];
    $zz = $Nzx[2];
    }
    return $Direction;
    }

    proc string [] LocS(vector $VEC_pt[]){

    $Size = `size($VEC_pt)`;
    for($i = 0; $i < $Size;$i++){
    $Points = $VEC_pt[$i];
    $LocObject= `spaceLocator -p 0 0 0`;
    $LocObjectsi[$i]=$LocObject[0];
    setAttr ($LocObject[0]+".translate")  $Points[0] $Points[1] $Points[2];
    }
    return $LocObjectsi;
    }


    proc vector RotateDir_Axis(float $Rot_T, float $theta, vector $Axis, vector $Direct) {

    $xx=$Axis.x; $xy=$Axis.y; $xz=$Axis.z;
    $zx=$Direct.x; $zy=$Direct.y; $zz=$Direct.z;
    $PI_Static = 3.14159265;

    $theta *= ($PI_Static / 180.0);


    $ct = cos($theta);
    $st = sin($theta);
    $Nzx = (float) ($zx * $ct - $xx * $st);
    $Nzy = (float) ($zy * $ct - $xy * $st);
    $Nzz = (float) ($zz * $ct - $xz * $st);
    $zx = $Nzx;
    $zy = $Nzy;
    $zz = $Nzz;

    $Direction = <<$zx, $zy, $zz>>;
    return $Direction;
    }



    //Programing tools and scripts toorganize script


    $CurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
    //curve made
    //if it is on the ZY plane or one or both vector are onthe posidtive side
    //place into a set or layer

    ///

    proc int[] SortNumbersIntIndex(float $allFloatToSort[]){
    $aF = $allFloatToSort;
    $sIze = `size($aF)`-1;
    $IndexTrack = CreateIntIndex(`size($aF)`);
    quickSort($aF, $IndexTrack, 0, $sIze);
    $IndexTrack = ReverseIntArray($IndexTrack);
    return $IndexTrack;
    }

    proc int [] IndexPairFunc(int $XNum){
    $Zss = $XNum*2;
    $Yss = $Zss+1;
    $pair={$Zss,$Yss};
    return $pair;
    }

    proc int IndexPairFuncN(int $XNum, int $XNumV){
    $Zss = $XNum*2;
    $Yss = $Zss+1;
    if($XNumV==0){
    $AB=$Zss;
    }
    else{$AB=$Yss;}

    return $AB;
    }

    proc int [] CreateIntIndex(int $ArraySize){
    $iNdex = 0;
    while($iNdex < $ArraySize){
    $IntArrayInex[$iNdex] = $iNdex;
    $iNdex++;
    }
    return $IntArrayInex;
    }




    proc vector [] ProjectCrv2PlaneNormalP(vector $vecRs[],vector $AvN,vector $Midp){
    $DirectC = DirectionFN($vecRs[0], $Midp);
    $tan = crossProduct($DirectC,$AvN, 0, 0 );
    $RowA = $tan;
    $RowB = $DirectC;
    $RowC = $AvN;
    // cent of matrix
    $AxisO = $Tran = $Midp;
    $SizeVp = `size($vecRs)`;
    $CountFN = 0;
    for($Ind=0; $Ind<$SizeVp; $Ind++){
    $PtsVec=$vecRs[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $Xv = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    $Dv=DirectionF($Xv,$PtsVec);
    $ZEROIi = $Dv*$AvN;
    $valN= $ZEROIi.x*$ZEROIi.y*$ZEROIi.z;
    $sign = `sign $valN`;
    $valN = (int) (($valN + $sign*5/(1.0*10)) * 1.0);
    $valN = ($valN/1.0);
    if($valN==1){
    $NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    $vecRsA[$CountFN]=$PtsVec;
    $CountF[$CountFN]=$Ind;
    $CountFN++;
    }
    }
    $V= $vecRsA;
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = $AvN;
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F4 = $NewPtsP[$C1];
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    $MatrixNewB = GetMatrix("ZCURVEModelingCAM");
    $MtxF  = MatrixToFloat($MatrixNewB);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};
    $TF = 0;
    $SizeC = `size($O)`;
    for($Ind=0; $Ind<$SizeC; $Ind++){
    $PtsVec= $O[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $TF=rectContains(-0.5,-0.5, 1.0, 1.0,$PtZ[0], $PtZ[2]);
    if($TF==1){
    $RECORD[`size($RECORD)`]=$O[$Ind];
    }
    $TF=0;
    }
    return $RECORD;
    }

    ////////////////////////////////////////////////////////////



    proc float [] ClosestPoint2Line(float $DirectionLineF[], float $PointOnLine[], float  $PointN[]){
    $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    $VecLineDir = PositiveDir($DirectionLineF);
    $VecLineDirM = $VecLineDiri-$VecLineDir;
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    $DF = FloatToVec($DirectionLineF);
    $PoL = FloatToVec($PointOnLine);
    $PN = FloatToVec($PointN);
    if($AdditR != 0.0){
    $A =($DF*1.0)+$PoL;
    $N1 = Normal3Points($PoL, $A, $PN);
    $Dist2LStart = distance2Pts( $PN , $PoL);
    $A2 =($Dist2LStart*$N1)+$PoL;
    $N2 = Normal3Points($PoL, $A2, $A);
    $A3 =($Dist2LStart*$N2)+$PoL;
    $locsA = lineIntersection($PN, $A3, $PoL,  $DF);
    }else{$locsA =  $PointN ;}
    return $locsA;
    }
    proc vector ClosestPoint2LineVec(float $DirectionLineF[], float $PointOnLine[], float  $PointN[]){
    $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    $VecLineDir = PositiveDir($DirectionLineF);
    $VecLineDirM = $VecLineDiri-$VecLineDir;
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    $DF = FloatToVec($DirectionLineF);
    $PoL = FloatToVec($PointOnLine);
    $PN = FloatToVec($PointN);
    if($AdditR != 0.0){
    $A =($DF*1.0)+$PoL;
    $N1 = Normal3Points($PoL, $A, $PN);
    $Dist2LStart = distance2Pts( $PN , $PoL);
    $A2 =($Dist2LStart*$N1)+$PoL;
    $N2 = Normal3Points($PoL, $A2, $A);
    $A3 =($Dist2LStart*$N2)+$PoL;
    $locsA = lineIntersection($PN, $A3, $PoL,  $DF);
    $VlocA = <<$locsA[0],$locsA[1],$locsA[2]>>;
    }else{$VlocA = FloatToVec($PointN);}
    return $VlocA;
    }





    global string $CurveNames[];
    global int $MCurveIndex[];
    global vector $AllKnowVecEnds[];

    global vector $AllKnowVecEnds[];

    $LocCurveEndsVec = ProjectCrv2PlaneNormalP($AllKnowVecEnds,$CamNormal*-1,$CamPosA[0]);

    global int $Ind3dV2P[];
    global vector $AllKnowVecsInView[];

    $Ind3dV2P[]

    proc vector [] ProjectCrv2PlaneNormalPindex(vector $vecRs[],vector $AvN,vector $Midp){
    global int $Index3dVecs2P[];
    global vector $AllKnowVecsInView[];
    clear $Index3dVecs2P;
    clear $AllKnowVecsInView;

    $DirectC = DirectionFN($vecRs[0], $Midp);
    $tan = crossProduct($DirectC,$AvN, 0, 0 );
    $RowA = $tan;
    $RowB = $DirectC;
    $RowC = $AvN;
    // cent of matrix
    $AxisO = $Tran = $Midp;
    $SizeVp = `size($vecRs)`;
    $CountFN = 0;
    for($Ind=0; $Ind<$SizeVp; $Ind++){
    $PtsVec=$vecRs[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $Xv = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    $Dv=DirectionF($Xv,$PtsVec);
    $ZEROIi = $Dv*$AvN;
    $valN= $ZEROIi.x*$ZEROIi.y*$ZEROIi.z;
    $sign = `sign $valN`;
    $valN = (int) (($valN + $sign*5/(1.0*10)) * 1.0);
    $valN = ($valN/1.0);
    if($valN==1){
    $NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    $vecRsA[$CountFN]=$PtsVec;
    $CountF[$CountFN]=$Ind;
    $CountFN++;
    }
    }
    $V= $vecRsA;
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = $AvN;
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F4 = $NewPtsP[$C1];
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    $MatrixNewB = GetMatrix("ZCURVEModelingCAM");
    $MtxF  = MatrixToFloat($MatrixNewB);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};
    $TF = 0;
    $TFcn = 0;
    $SizeC = `size($O)`;
    for($Ind=0; $Ind<$SizeC; $Ind++){
    $PtsVec= $O[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $TF=rectContains(-0.5,-0.5, 1.0, 1.0,$PtZ[0], $PtZ[2]);
    if($TF==1){
    $RECORD[$TFcn`]=$O[$Ind];
    $AllKnowVecsInView[$TFcn]= $vecRsA[$Ind];
    $FinalIndex[$TFcn]=$CountF[$Ind];
    $TFcn++;
    }
    $TF=0;
    }
    $Ind3dV2P=$FinalIndex;
    return $RECORD;
    }








    /*
    temp
    $CurveNames= `ls -sl`;
    $AllKnowVecEnds = GetVectorArrayCRVEnds($CurveNames);
    print $AllKnowVecEnds;
    */

    $MCurveIndex= CreateIntIndex(`size($AllKnowVecEnds)`);

    clear $NewCurveNames;
    $NewCurveNames= `ls -sl`;
    $NewVecEnds = GetVectorArrayCRVEnds($NewCurveNames);

    $dist_A = ArrayDistancesVecTofloat($AllKnowVecEnds, $NewVecEnds[0]);
    $dist_B = ArrayDistancesVecTofloat($AllKnowVecEnds, $NewVecEnds[1]);

    $DistSortA=SortNumbersIntIndex($dist_A);
    $DistSortB=SortNumbersIntIndex($dist_B);
    $SmallestDistA = $dist_A[$DistSortA[0]];
    $SmallestDistB = $dist_B[$DistSortB[0]];


    /*
    what has to happen here..
    the  vector indexing system
    there are four vectors
    a new curve is added to two existing curves
    there are four vectors
    and now two new vectors
    */




    if($SmallestDistA<3){
    $CountConnect[0]=1;
    $A = $DistSortA[0];
    $Avec = $AllKnowVecEnds[$DistSortA[0]];
    $CurveIndexA=GetPairIndexNFunc($A);

    }{$CountConnect[0]=0;}

    if($SmallestDistB<3){
    $CountConnect[1]=1;
    $B = $DistSortB[0];
    $Bvec = $AllKnowVecEnds[$DistSortB[0]];
    $CurveIndexB=GetPairIndexNFunc($B);

    }else{$CountConnect[1]=0;}



    $Size = `size($MCurveIndex)`;
    $SizeV = `size($AllKnowVecEnds)`;


    if($CountConnect[0]+$CountConnect[1]!=2){

    if($CountConnect[0]==1){
    print "yes";
    $MCurveIndex[$Size]=$DistSortA[0];
    $MCurveIndex[$Size+1]=$SizeV;
    $AllENdVectorZ[$SizeV]=$NewVecEnds[1];
    }

    if($CountConnect[1]==1){
    $MCurveIndex[$Size]=$DistSortB[0];
    $MCurveIndex[$Size+1]=$SizeV;
    $AllENdVectorZ[$SizeV]=$NewVecEnds[0];
    }

    }


    if($CountConnect[0]+$CountConnect[1]==2){
    ////int $SizeB =$Size+1;
    ///  $CurveVecIndex[$Size-2]=$DistSortA[0]+","+$DistSortB[0];
    $MCurveIndex[$Size]=$DistSortA[0];
    $MCurveIndex[$Size+1]=$DistSortB[0];

    }


    if($CountConnect[0]+$CountConnect[1]==0){
    ////int $SizeB =$Size+1;
    ///  $CurveVecIndex[$Size-2]=$DistSortA[0]+","+$DistSortB[0];
    $MCurveIndex[$Size]=$SizeV;
    $MCurveIndex[$Size+1]=$SizeV+1;

    }












    //       choose append pair to vector index?

    //if $x =1

    /*
    clear $CurveVecIndex;
    $CurveVecIndex[0] ="0,1";
    $CurveVecIndex[1] ="2,3";
    print $CountConnect;

    $Size = `size($MCurveIndex)`;
    $SizeV = `size($AllKnowVecEnds)`;


    if($CountConnect[0]+$CountConnect[1]==0){
    $SizeB = $Size+1;
    $CurveVecIndex[$Size-2]=$Size+","+$SizeB;
    }
    */

    /////////////////////////////////////////GOLD

    if($CountConnect[0]+$CountConnect[1]!=2){

    if($CountConnect[0]==1){
    print "yes";
    $MCurveIndex[$Size]=$DistSortA[0];
    $MCurveIndex[$Size+1]=$SizeV;
    $AllENdVectorZ[$SizeV]=$NewVecEnds[1];
    }

    if($CountConnect[1]==1){
    $MCurveIndex[$Size]=$DistSortB[0];
    $MCurveIndex[$Size+1]=$SizeV;
    $AllENdVectorZ[$SizeV]=$NewVecEnds[0];
    }

    }


    if($CountConnect[0]+$CountConnect[1]==2){
    ////int $SizeB =$Size+1;
    ///  $CurveVecIndex[$Size-2]=$DistSortA[0]+","+$DistSortB[0];
    $MCurveIndex[$Size]=$DistSortA[0];
    $MCurveIndex[$Size+1]=$DistSortB[0];

    }


    if($CountConnect[0]+$CountConnect[1]==0){
    ////int $SizeB =$Size+1;
    ///  $CurveVecIndex[$Size-2]=$DistSortA[0]+","+$DistSortB[0];
    $MCurveIndex[$Size]=$SizeV;
    $MCurveIndex[$Size+1]=$SizeV+1;

    }






    0
    1
    2
    3
    3
    1

    0
    1
    2
    3
    3
    5

    clear $MCurveIndex;

    $MCurveIndex={0,1,2,3,3,1};




    size($AllENdVectorZ);
    print $AllENdVectorZ;

    /////////////////////////////////////////



    print $Size

    size($AllENdVectorZ);
    print $MCurveIndex;


    if($CountConnect[1]==1){
    print "yes";
    }



    if($CountConnect[0]+$CountConnect[1]==2){
    ////int $SizeB =$Size+1;
    ///  $CurveVecIndex[$Size-2]=$DistSortA[0]+","+$DistSortB[0];
    $MCurveIndex[$Size]=$DistSortA[0];
    $MCurveIndex[$Size+1]=$DistSortB[0];

    }

    print $MCurveIndex;
    print $CurveVecIndex;



    if no match exists
    add both new vectors to the vector list
    size known vec array plus 1 +1





    `






    $XTFb = 0;
    $CurveEndPairsZ = IfCurvesTouchIndexZ($CurveNames[0], $CurveNames[1],$XTFb);

    print $CurveNames;


    $KeyToPairIndex[0]=0;

    IndexPairFunc(1);




    curve34

    curve73

    $TrackIt[0] = IndexPairFuncN(int($Remove[0]), $CurveEndPairsZ[0]);


    $CURVeINDEX = CreateIntIndex(`size($CurveNames)`);
    $FoundDuplicates = $CurveNames;
    $SizeSelectedCRVs = `size($FoundDuplicates)`;
    $CnIndex = 0;
    for ($eachS in $FoundDuplicates)
    {$CurveEND_Count_LIST[$CnIndex++] = "0,0";
    }
    print $CurveEND_Count_LIST;
    $NumbersINDEX = CreateIntIndex($SizeSelectedCRVs);
    clear $CRV_CONNECT;
    clear $CurveConnectionsIndex;
    clear $CurveConnectionsIndexA;
    clear $CurveConnectionsIndexB;
    for($eachItemX in $NumbersINDEX){
    $CurveConnectionsIndex[$eachItemX] ="";
    $CurveConnectionsIndexA[$eachItemX] ="A";
    $CurveConnectionsIndexB[$eachItemX] ="B";
    }
    clear  $CRVNumber;
    clear $CurveNumber;
    $Cn = 0;
    $CnXX = 0;
    $Xn = 0;
    $XTFb = 0;
    $item = $FoundDuplicates;
    $item = IntArrayToStringArray($NumbersINDEX);
    $itemBackUp = $item;
    for ($each in $itemBackUp)
    {   $Remove = {$item[0]}
    ;
    $diff = stringArrayRemoveExact($Remove, $item);
    for($eachOther in $diff){
    ////////////////////////////////////////
    $IntIfTrueA = IfCurvesTouch($FoundDuplicates[int($eachOther)], $FoundDuplicates[int($Remove[0])]);
    if($IntIfTrueA==1){
    ////
    $CurveEndPairs = IfCurvesTouchIndex($FoundDuplicates[int($eachOther)], $FoundDuplicates[int($Remove[0])],$XTFb);
    select -r $FoundDuplicates[int($Remove[0])];  PAUSEn(2);
    select -add $FoundDuplicates[int($eachOther)]; PAUSEn(2);
    // $CurveEndPairsZ this is the zero or one indication Start or End _ A or B _  0 Or 1 _  of curve ends connecting  for two lines
    $OnePAIR = stringArrayToString(IntArrayToStringArray($CurveEndPairs), ",");
    //$CurveEND_LIST[$Cn] = stringArrayToString(IntArrayToStringArray($CurveEndPairs), ",");
    $IfTrueArray[$Cn]=1;
    $CRVNumber[$Xn++] = $matchN_a = `match "([0-9]+)([0-9])*" $FoundDuplicates[int($Remove[0])]`;
    $CRVNumber[$Xn++] = $matchN_b = `match "([0 -9]+)([0-9])*" $FoundDuplicates[int($eachOther)]`;
    $CurveNumber[$Cn] = ($matchN_a +" "+$matchN_b);
    $ADDit = stringToStringArray( $OnePAIR , ",");
    $ARRAY_A = stringToStringArray($CurveEND_Count_LIST[int($eachOther)], ",");
    $ARRAY_B = stringToStringArray($CurveEND_Count_LIST[int($Remove[0])], ",");
    $AAi = int ($ARRAY_A[0]) + int ($ADDit[0]); int $ABi = int ($ARRAY_A[1]) + int ($ADDit[1]);
    $BAi = int ($ARRAY_B[0]) + int ($ADDit[2]); int $BBi = int ($ARRAY_B[1]) + int ($ADDit[3]);
    $CurveEND_Count_LIST[int($eachOther)] = ($AAi+","+$ABi);
    $CurveEND_Count_LIST[int($Remove[0])] = ($BAi+","+$BBi);
    //string $ARray[] = stringToStringArray($OnePAIR, ",")
    //$CRV_CONNECT[int($Remove[0])]+= int ($ADDit[0]);
    //$CRV_CONNECT[int($eachOther)]+= int ($ADDit[1]);
    $CRV_CONNECT[int($Remove[0])]+= 1;
    $CRV_CONNECT[int($eachOther)]+= 1;
    /////////////////////////////////////////////////////////
    $CurveEndPairsZ = IfCurvesTouchIndexZ($FoundDuplicates[int($eachOther)], $FoundDuplicates[int($Remove[0])],$XTFb);
    $CurveEndPairsZ = IfCurvesTouchIndexZ($FoundDuplicates[int($Remove[0])],$FoundDuplicates[int($eachOther)],$XTFb);
    //curve inted Zero 0 -  1_1, 6_1, 7_1,
    // the first number is the curve it connects to
    // the following number is the vector index of the end pt that touches that curve
    $TrackIt[0] = IndexPairFuncN(int($Remove[0]), $CurveEndPairsZ[0]);
    $TrackIt[1] = IndexPairFuncN(int($eachOther), $CurveEndPairsZ[1]);
    $A = $Remove[0]; string $B = $eachOther;
    $AX = int ($A);
    $BX = int ($B);
    $CurveNumberIndex[$Cn] = ($A+","+$B);
    if($CurveEndPairsZ[0]==1){
    $CurveConnectionsIndexB[$AX] = $CurveConnectionsIndexB[$AX]+$B+"_"+ $CurveEndPairsZ[1]+",";
    }

    if($CurveEndPairsZ[1]==1){
    $CurveConnectionsIndexB[$BX] = $CurveConnectionsIndexB[$BX]+$A+"_"+ $CurveEndPairsZ[0]+",";
    }
    if($CurveEndPairsZ[0]==0){
    $CurveConnectionsIndexA[$AX] = $CurveConnectionsIndexA[$AX]+$B+"_"+ $CurveEndPairsZ[1]+",";
    }

    if($CurveEndPairsZ[1]==0){
    $CurveConnectionsIndexA[$BX] = $CurveConnectionsIndexA[$BX]+$A+"_"+ $CurveEndPairsZ[0]+",";
    }
    //curve inted Zero 0 -  1_1, 6_1, 7_1,
    // the first number is the curve it connects to $B
    // the following number is the vector index of the end pt that touches that curve $TrackIt[0]
    $CurveConnectionsIndex[$AX] = $CurveConnectionsIndex[$AX]+$B +"_"+ $TrackIt[0]+",";
    $CurveConnectionsIndex[$BX]= $CurveConnectionsIndex[$BX]+$A +"_"+ $TrackIt[1]+",";
    $CurveNumberIndexA[$CnXX++] =  $A;
    $CurveNumberIndexA[$CnXX++] =  $B;
    $AB = (" _ "+$A+","+$B);
    $OnePAIR += $AB;
    $CurveEND_LIST[$Cn] = $OnePAIR;
    $Cn++;
    ////
    }
    $item = $diff;
    //////////////////////////////////////////
    }
    }

    //////////////////////////////////////////END
    //////////////////////////////////////////
    //print $CurveConnectionsIndex;
    //print $CurveConnectionsIndexA;
    //print $CurveConnectionsIndexB;
    //print $CRV_CONNECT;







    proc vector [] VecPointsToPlaneX(vector $V[],vector $n1,vector $p){


    $CurvEnd = PointArrayT($CurveEnds3D);



    $CameraN = FloatToVec(nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0));
    $CamPosA = `xform -q -ws -t ZCURVEModelingCAM`;

    $VecBii = ProjectCrv2PlaneNormalP($CurvEnd,$CameraN*-1,$CamPosA);



    for($eachVV in $CurvEnd){

    $ptVecWs = $eachVV;
    // Grab the worldInverseMatrix from cam_main
    matrix $cam_mat[4][4] = screenSpaceGetMatrix("ZCURVEModelingCAM.worldInverseMatrix");
    // Multiply the point by that matrix
    $ptVecCs = screenSpaceVecMult($ptVecWs,$cam_mat);
    // Adjust the point's position for the camera perspective

    $hfv = `camera -q -hfv ZCURVEModelingCAM`;
    $ptx = (($ptVecCs.x/(-$ptVecCs.z))/tand($hfv/2))/2.0;
    $vfv = `camera -q -vfv ZCURVEModelingCAM`;
    $pty = (($ptVecCs.y/(-$ptVecCs.z))/tand($vfv/2))/2.0;
    $ptz = $ptVecCs.z;
    $XYv = $ptVecCs;
    //vector $XYv=<<$ptx,$pty,0.0>>;
    Loc ( $XYv);
    }



    $Tdd = PointArrayT(`ls-sl`);
    $Dir = DirectionF($Tdd[0],$Tdd[1]);
    /////
    $EV = ($Dir*2.5)+$T[0];
    Loc($EV);
    //

    $TD = PointArrayT(`ls-sl`);
    $VecBi = ProjectCrv2PlaneNormalP($TD,$Dir,$Tdd[0]);



    $CamPosA =`xform -q -ws -t "LiveSurfaceB"`;
    $CamNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);

    $VecBi = ProjectCrv2PlaneNormalP($AllKnowVecEnds,$CamNormal*-1,$CamPosA[0]);


    proc vector [] ProjectCrv2PlaneNormalP(vector $vecRs[],vector $AvN,vector $Midp){

    $DirectC = DirectionFN($vecRs[0], $Midp);
    $tan = crossProduct($DirectC,$AvN, 0, 0 );
    $RowA = $tan;
    $RowB = $DirectC;
    $RowC = $AvN;
    // cent of matrix
    $AxisO = $Tran = $Midp;
    $SizeVp = `size($vecRs)`;
    for($Ind=0; $Ind<$SizeVp; $Ind++){
    $PtsVec=$vecRs[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $Xv = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    $Dv=DirectionF($Xv,$PtsVec);
    $ZEROIi = $Dv*$AvN;
    $valN= $ZEROIi.x*$ZEROIi.y*$ZEROIi.z;
    $sign = `sign $valN`;
    $valN = (int) (($valN + $sign*5/(1.0*10)) * 1.0);
    $valN = ($valN/1.0);
    //if above0.5
    if($valN==1){
    $NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    //be careful..
    curve2points($Xv,$PtsVec);
    }
    }
    return $NewPtsP;
    }

    $CamPosA = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPosA =`xform -q -ws -t "LiveSurfaceB"`;
    $CamNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $VecBi = ProjectCrv2PlaneNormalP($AllKnowVecEnds,$CamNormal*-1,$CamPosA[0]);

    $vecRs ={$AllKnowVecEnds[0]};
    Loc  $vecRs[0];

    $AvN = $CamNormal*-1;
    $Midp = $CamPosA[0];



    $vecRs ={$AllKnowVecEnds[0]};
    $AvN = $CamNormal*-1;
    $Midp = $CamPosA[0];




    proc vector [] ProjectCrv2PlaneNormalP(vector $vecRs[],vector $AvN,vector $Midp){


    $DirectC = DirectionFN($vecRs[0], $Midp);
    $tan = crossProduct($DirectC,$AvN, 0, 0 );
    $RowA = $tan;
    $RowB = $DirectC;
    $RowC = $AvN;
    // cent of matrix
    $AxisO = $Tran = $Midp;
    $SizeVp = `size($vecRs)`;
    $CountFN = 0;
    for($Ind=0; $Ind<$SizeVp; $Ind++){
    $PtsVec=$vecRs[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));


    $Xv = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    $Dv=DirectionF($Xv,$PtsVec);
    $ZEROIi = $Dv*$AvN;
    $valN= $ZEROIi.x*$ZEROIi.y*$ZEROIi.z;
    $sign = `sign $valN`;
    $valN = (int) (($valN + $sign*5/(1.0*10)) * 1.0);
    $valN = ($valN/1.0);
    //if above0.5
    if($valN==1){
    PAUSE;
    cycleBackgroundColor;
    $NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    //be careful..
    curve2points($Xv,$PtsVec);
    //Loc $NewPtsP[0];

    $vecRsA[$CountFN]=$PtsVec;
    $CountF[$CountFN]=$Ind;
    $CountFN++;
    }

    }


    $V= $vecRsA;
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = $AvN;
    $C1=0;
    for($e in $V){

    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    ///both maybe redundant
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F4 = $NewPtsP[$C1];
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);

    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    curve2points($e,$O[$C1]);
    $C1++;
    }
    //print  $O;
    //Loc $O[0];

    $MatrixNewB = GetMatrix("ZCURVEModelingCAM");
    $MtxF  = MatrixToFloat($MatrixNewB);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};

    $TF = 0;
    $SizeC = `size($O)`;
    for($Ind=0; $Ind<$SizeC; $Ind++){

    $PtsVec= $O[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    Loc $PtZ;
    print $PtZ[0];
    print $PtZ[2];
    print $PtZ[1];
    //$TF=rectContains(-0.5,-0.5, -1.0, 1.0, $PtZ[0], $PtZ[2]);
    $TF=rectContains(-0.5,-0.5, 1.0, 1.0,$PtZ[0], $PtZ[2]);

    if($TF==1){
    $RECORD[`size($RECORD)`]=$O[$Ind];
    PAUSE;
    Loc $RECORD[`size($RECORD)`-1];
    }
    $TF=0;

    }


    return $RECORD;
    }

    $T = `ls -sl`;
    $vecT = PointArrayT($T);
    $FixVecT = $vecT[0];

    $TF=rectContains(-0.5,-0.5, 1.0, 1.0, $FixVecT[0], $FixVecT[2]);



    proc vector [] VecPointsToCameraPlane(vector $V[]){


    print $PtsVec;
    6.513704 -1.022943 4.744769
    // Result: <<65.077678, 30.853927, 35.481502>>  //
    // Result: <<71.591382, 29.830984, 40.226271>>  //

    $V= $vecRs;

    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $C1=0;
    for($e in $V){

    $e=$V[0];

    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    ///both maybe redundant

    $P1 = ClosestPoint2LineVec($n1, $p, $e);


    $F4 = $e+($D1*$F3);

    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);


    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));

    $C1++;
    }
    return $O;
    }




    proc vector [] VecPointsToCameraPlane(vector $V[]){
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+($D1*$F3);
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    return $O;
    }





    $TempVectorsCrv  = LineIntersectPlaneCam( $PositionsZ_Ax, $CamPos1, $ZYplaneMatrix);

    proc float [] FloatPointsToCamPlane(float $LocPos1[]){
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $C1=0;
    $e=FloatToVec( $LocPos1);
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+($D1*$F3);
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;

    $R = $O;
    return $R;
    }

    proc float [] FloatPointsToCamPlane(float $LocPos1[]){
    $Pi = 3.1415926535;
    $pi = 3.1415926535;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $LivePlanePos = `xform -q -ws -t LiveSurfaceB`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $CamerasDirectionVector = $CamerasDirectionVectorNormal;
    $FloatDirectionA = DirectionFN($CamPos1, $LocPos1);
    $DistanceLoc = distance2Pts( $LocPos1, $CamPos1 );
    $DistanceLocA = $DistanceLoc;
    $DistanceLoc = $DistanceLoc * -1;
    $MultDirPC1 = multiplyFloat($DistanceLoc, $CamerasDirectionVector);
    $FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1);
    $CamerasDirectionVectorA = DirectionFN($FloatDirectionCamNormal, $CamPos1);
    $MultDirPC1A = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
    $FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1A);
    $p1 = $CamPos1;
    $p2 = $LocPos1;
    $p3 = $FloatDirectionCamNormal;
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );
    $FloatPosZero = {0, 0, 0};
    $FloatDirection = DirectionFN($FloatPosZero, $normal);
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $mid3 = midPoint2Pts( $p2, $p3 );
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    $FloatDirPerpCenterC = DirectionFN($center,$mid2);
    $FloatDirPointAC = DirectionFN($p1, $p3);
    $center8 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
    $FloatDirLocToPerpIntersect = DirectionFN($center8,$p2);
    $OnPlane = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );
    return $OnPlane;
    }


    proc matrix screenSpaceGetMatrix(string $attr){
    $v = `getAttr $attr`;
    matrix $mat[4][4]=<<$v[0], $v[1], $v[2], $v[3];
    $v[4], $v[5], $v[6], $v[7];
    $v[8], $v[9], $v[10], $v[11];
    $v[12], $v[13], $v[14], $v[15]>>;
    return $mat;
    }

    // Multiply the vector v by the 4x4 matrix m, this is probably
    // already in mel but I cant find it.
    proc vector screenSpaceVecMult(vector $v, matrix $m){
    matrix $v1[1][4]=<<$v.x, $v.y, $v.z, 1>>;
    matrix $v2[1][4]=$v1*$m;
    return <<$v2[0][0], $v2[0][1],  $v2[0][2]>>;
    }




    $ptVecWs =  ;

    // Grab the worldInverseMatrix from cam_main
    matrix $cam_mat[4][4] = screenSpaceGetMatrix("cam_main.worldInverseMatrix");

    // Multiply the point by that matrix
    $ptVecCs = screenSpaceVecMult($ptVecWs,$cam_mat);

    // Adjust the point's position for the camera perspective
    $hfv = `camera -q -hfv cam_main`;
    $ptx = (($ptVecCs.x/(-$ptVecCs.z))/tand($hfv/2))/2.0+.5;
    $vfv = `camera -q -vfv cam_main`;
    $pty = (($ptVecCs.y/(-$ptVecCs.z))/tand($vfv/2))/2.0+.5;

    $ptz = $ptVecCs.z;

    $line = $ptx + " " + $pty + " " + "\n";





    proc int AddItemsFromIndexAtoB(int $Ai, int $Bi, int $numberArrayi[]){
    // float $numberArrayi[]= {0.2, 1.2, 3.2, 1.2, 6.2, 6.2, 9.3, -1.2};
    //int $Ai = 2;
    //int $Bi = 5;
    $AddUp = 0;
    $NumerinArray = `size($numberArrayi)`-1;
    if($NumerinArray!=-1){
    $Ni = $Ai;
    $Nii = $Bi;
    if($Nii< $Ni){
    $Ai=$Nii; $Bi=$Ni;
    }
    $range = abs ($Ai-$Bi);
    for ($iC=0;$iC<$range+1; $iC++){
    $ixNa = $iC+$Ai;
    $ixNa = `clamp 0 $NumerinArray $ixNa`;
    $AddUp+=$numberArrayi[$ixNa];
    if($ixNa ==$NumerinArray){break;}
    }
    }
    return $AddUp;
    }


    proc int[] AddItemsFromIndexAtoBFindZero(int $Ai, int $Bi, int $numberArrayi[]){
    // float $numberArrayi[]= {0.2, 1.2, 3.2, 1.2, 6.2, 6.2, 9.3, -1.2};
    //int $Ai = 2;
    //int $Bi = 5;
    $AddUp = 0;
    $NumerinArray = `size($numberArrayi)`-1;
    $catchIndex[0]= 1;
    if($NumerinArray!=-1){
    $Ni = $Ai;
    $Nii = $Bi;
    if($Nii< $Ni){
    $Ai=$Nii; $Bi=$Ni;
    }
    $range = abs ($Ai-$Bi);
    for ($iC=0;$iC<$range+1; $iC++){
    $ixNa = $iC+$Ai;
    $ixNa = `clamp 0 $NumerinArray $ixNa`;
    $AddUp+=$numberArrayi[$ixNa];
    if($AddUp ==0){$catchIndex[1] = $ixNa; $catchIndex[0]=0;break;}
    }
    }
    return $catchIndex;
    }

    proc string StringArrayItemsFromIndexAtoB(int $Ai, int $Bi, string $StringArrayi[]){
    $sAddUp = 0;
    $NumerinArray = `size($StringArrayi)`;
    if($NumerinArray!=0){
    $Ni = $Ai;
    $Nii = $Bi;
    if($Nii< $Ni){
    $Ai=$Nii; $Bi=$Ni;
    }
    $range = abs ($Ai-$Bi);
    for ($iC=0;$iC<$range+1; $iC++){
    $ixNa = $iC+$Ai;
    $sAddUp+=$StringArrayi[$ixNa];
    if($ixNa ==$NumerinArray){break;}
    }
    }
    return $sAddUp;
    }

    proc  PrintLongArrayNice(string $StringArrayPrint[] , int $MatrixN){
    $MatrixNi = $MatrixN-1;
    $stringFloat = $StringArrayPrint;
    clear $BytNum;
    for ($eachFloatz in $stringFloat){
    $BytNum[`size($BytNum)`] = (`sizeBytes $eachFloatz`)+2;
    }
    $BytNumSort = $BytNum;
    $BytNumSort = `sort $BytNumSort`;
    $BytNumLarg = $BytNumSort[`size($BytNumSort)`-1];
    $BytNumSmall = $BytNumSort[0];
    clear $BytNumDiff;
    for ($eachBytNum in $BytNum){
    $BytNumDiff[`size($BytNumDiff)`] = (`abs ($eachBytNum - $BytNumLarg)`)+2;
    }
    $IndXeF = 0;
    $IndXeFi = 0;
    $Syb = " ";
    $printcommand = "";
    for ($eachItemF in $stringFloat){
    $AddedSPaces = AddItemString($BytNumDiff[$IndXeF], $Syb);
    if($IndXeFi==$MatrixNi){ $printcommand += $AddedSPaces + $eachItemF + "|"+ "\n" ;
    $IndXeFi= -1; }else{ if($IndXeFi==0){$printcommand += "|"+$AddedSPaces + $eachItemF;}else{ $printcommand +=  $AddedSPaces + $eachItemF;}}
    $IndXeFi++;
    $IndXeF++;
    }


    }

    proc string[] StringArrayStartOfStringinArray(string $Array[]){
    $findEachstart = "";
    for ($eachString in $Array){
    $StartOfEach[`size($StartOfEach)`]= startString($eachString, 1);
    $findEachstart+= startString($eachString, 1);
    $findEachstart+= " ";
    }

    return $StartOfEach;
    }

    ///////////////////////
    proc string[] ReturnArrayFromNestedStringAtIndex(string $StringData[], int $ind){
    $KnownMatchi = stringToStringArray($StringData[$ind], ",");
    return $KnownMatchi;
    }

    proc int[] TFArrayContains(string $item, string $list[])
    {	int $TF[1];
    $TF[0] = false;
    $Count = 0;
    for ($listItem in $list) {
    if ($item == $listItem) {
    $TF[0] = true;
    $TF[1] = $Count;
    break;
    } $Count++;
    }
    return $TF;
    }

    proc string AddItemString(int $iN, string $NumLetorSy){
    $Xz = 0;
    $AddItem = "";
    while($iN > $Xz){
    $AddItem+= $NumLetorSy;
    $Xz++;
    }
    return $AddItem;
    }

    ////////////////////////

    //Test pick one

    /*
    $Find = "Vec.xithis+ float Y =  uVeci/(abs(sqrt ((`pow  uVeci 2`) + (`pow  vVeci 2`) + (`pow  wVeci 2`)))); Vec.vecthisH , float i =  Vec.x - Vec.y; float ii = Vec.vecthisH - Vec.z + Vec.thisy / Vec.Tthis - Vec.this;";

    $Find = "r = a*exp(radians(Delta_angle*n)*cot(b))x = r*cos(radians(Delta_angle*n))if(n ==0):y = 0else:y = 10*(rBefore -r) z = sin (radians(Delta_angle*n))  SomeNumber::FuctionWeird please work II + math = joy;" ;
    */
    ////////////////////////


    proc string [] FindNameOfVariables(string $Find, int $sortN){

    $resultVar = "string float vector matrix int proc";
    $resulti = "sin cos tan tand atan asin acos atand asind acosd";
    $result = "abs angle bessel ceil clamp constrainValue cos cross crossProduct deg_to_rad delrandstr dot dotProduct equivalent  equivalentTol erf exp floatEq floor fmod gamma gauss getLastError getProcArguments hermite hsv_to_rgb hypot linstep log mag max min noise  normalize pointMatrixMult pow rad_to_deg rand randstate rgb_to_hsv rot seed sign sin smoothstep sphrand sqrt tan trunc unitprint ";
    $AllMathfunction = "abs ,angle ,bessel ,ceil ,clamp ,constrainValue ,cos ,cross ,crossProduct ,deg_to_rad ,delrandstr ,dot  ,dotProduct ,equivalent ,equivalentTol ,erf ,exp ,floatEq ,floor ,fmod ,gamma ,gauss ,getLastError ,getProcArguments ,hermite ,hsv_to_rgb  ,hypot ,linstep ,log ,mag ,max ,min ,noise ,normalize ,pointMatrixMult ,pow ,rad_to_deg ,rand ,randstate ,rgb_to_hsv ,rot ,seed ,sign ,sin  ,smoothstep ,sphrand ,sqrt ,tan ,trunc ,unit";
    $MathFuncClassData = $result+" "+ $resulti + " " + $resultVar ;
    //string  $KnownMathTermsMELAtomizes[] = ArrayFromAllinString($MathFuncClassData);
    $KnownMathTermsMEL = stringToStringArray($MathFuncClassData, " ");
    $KnownMathTermsMELSorted = `sort $KnownMathTermsMEL`;



    $startingChar = StringArrayStartOfStringinArray($KnownMathTermsMELSorted);
    $shorterListstartingChar = stringArrayRemoveDuplicates ($startingChar);
    $KnownMatch = $KnownMathTermsMELSorted;
    $ArrayLetter = $shorterListstartingChar;
    $Arraytemp = $KnownMathTermsMELSorted;
    $findEachstart = "";
    clear $StartOfEachSTable $itemBackUp;
    $itemBackUp = $ArrayLetter;
    $gatherItems = "";

    for ($eachStringL in $ArrayLetter){
    for ($eachString in $KnownMathTermsMELSorted){
    $StartOfEachS = startString($Arraytemp[0], 1);
    if ($StartOfEachS==$eachStringL){
    $gatherItems += ($Arraytemp[0]+",");
    $Arraytemp = stringArrayRemoveExact({$Arraytemp[0]}, $Arraytemp);
    }
    //else{	$gatherItems="";}	//
    }
    if(`size($gatherItems)`>0){
    $StartOfEachSTable[`size($StartOfEachSTable)`]= $gatherItems;
    }
    $gatherItems="";
    }

    //////////////////////////////////////////////////////////////


    $IndexLetters = CreateIntIndex(`size($ArrayLetter)`);
    $BytNumi = `sizeBytes $Find`;
    clear $all;
    clear $StringIndex;
    $all = ArrayFromAllinString($Find);
    $StringIndex = CreateIntIndex( `size($all)` );
    //map string

    $tempFind = $Find;
    $tempFindwrite = $Find;
    $countIndex = 0;
    clear $indexStart;
    $LetterItem = "";
    clear $FoundVariableItems $FoundOtherItems;
    clear $indexFirstCharItems;
    $BytNx = 0;
    $StringFromReducedArray = "";
    clear $reducedArray;
    clear $allTemp;
    $allTemp = $all;
    $dontUse = "";
    $matchingDontuse = "";
    $freezeTrigger = 0;
    $matching = "";
    $eachInt = 0;
    $iixI = 0;


    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $Find`;
    $match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $Find`;
    $matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $Find`;
    $matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $Find`;
    $MatchStage2 = endString($match, 3);

    $MatchStage3 = startString($match, `sizeBytes $match`-2);
    $MatchStage3i = startString($match, `sizeBytes $matchii`-2);
    $addBracktoMatch3 = ("\["+$MatchStage3+"\]");

    $matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;
    if($matchMiddleDiff=="\."){

    $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    if($matchMaybeVec2!=""){
    $MatchStage4 = startString($match, `sizeBytes $match`-1);
    $match = $MatchStage4;
    }else{ $dontUse = $matchi; $match=$matchi; }
    }else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//
    }

    $matchTemp = $match;
    $BytNx =`sizeBytes $match`;

    $IndexLetters = CreateIntIndex(`size($ArrayLetter)`);
    $StartOfEachSi = "";
    $FOUND = "";
    clear $ArrayFind $TFandIndex $TFandIndexii;
    $Tri = 0;
    $Trii = 2;
    $CountFoundletters = 0;
    clear $indexStartEnd;


    for ($eachItemArray in $StringIndex){
    $eachInt = $StringIndex[$iixI];

    if( `gmatch $allTemp[$eachInt] "[a-zA-Z0-9_\.]*"` == 1){
    if($Trii==2){$Trii=1; $Tri=2;}
    if(!($CountFoundletters>=1)){
    $FirstLFindIndex=$iixI+1;

    }
    $CountFoundletters++;
    if($Tri==2){

    $Tri=0;
    }
    $LetterItem+= $allTemp[$eachInt];
    $BytNx = `sizeBytes $LetterItem`;
    if(`gmatch $matchTemp $LetterItem`==1){
    $BytNx = `sizeBytes $LetterItem`;

    //$LetterItem ="pow";
    $StartOfEachSi = startString($LetterItem, 1);
    $TFandIndex = TFArrayContains($StartOfEachSi, $ArrayLetter);
    if($TFandIndex[0]==1){
    $ArrayFind = ReturnArrayFromNestedStringAtIndex($StartOfEachSTable, $TFandIndex[1]);
    $TFandIndexii = TFArrayContains($LetterItem, $ArrayFind);

    if($TFandIndexii[0]==1){
    $FOUND = $ArrayFind[$TFandIndexii[1]];
    if(`gmatch $FOUND $LetterItem`==1){

    $FoundOtherItems[`size($FoundOtherItems)`]= $FOUND;
    }
    }
    }
    if(`gmatch $FOUND $LetterItem`!=1){
    if($matchTemp!=$dontUse){
    $FoundVariableItems[`size($FoundVariableItems)`]= $LetterItem;
    $SizeItem = `size $matchTemp`;
    $indexStartEnd[`size($indexStartEnd)`] = <<$FirstLFindIndex, $iixI, ($iixI-$SizeItem+3)>> ;
    $indexStart[`size($indexStart)`]= $FirstLFindIndex;
    }
    } else{$CountFoundletters=0;          }
    clear $TFandIndex $ArrayFind $TFandIndexii;
    $FOUND="";
    $reducedArray = $allTemp;
    stringArrayRemoveToIndex($eachInt+1, $reducedArray);
    $StringFromReducedArray = stringArrayToString($reducedArray, "");

    /////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////
    $LetterItem ="";
    if($matchTemp==$dontUse){ $freezeTrigger = 1; }
    if( `gmatch $allTemp[$eachInt] $match` != 1){$Trii=2; $CountFoundletters=0;}

    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;

    //if(`size($StringFromReducedArray)`>4){
    $match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $StringFromReducedArray`;
    $matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $StringFromReducedArray`;
    $matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $StringFromReducedArray`;
    $MatchStage2 = endString($match, 3);
    $MatchStage3 = startString($match, `sizeBytes $match`-2);
    $MatchStage3i = startString($match, `sizeBytes $matchii`-2);
    $addBracktoMatch3 = ("\["+$MatchStage3+"\]");
    //$addBracktoMatchD = ("\(["+"\"+$matchi+"\])+([a-zA-Z]+)([a-zA-Z0-9_])");
    $matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;

    if($matchMiddleDiff=="\."){

    $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    if($matchMaybeVec2!=""){
    $MatchStage4 = startString($match, `sizeBytes $match`-1);
    $match = $MatchStage4;
    }else{ $dontUse = $matchi; $match=$matchi; }
    }else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//
    }
    }
    }else{$LetterItem ="";  }
    ///}else{$match = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;}
    $matchTemp = $match;

    $iixI++;
    }

    ///////////////

    $printneat = stringArrayToString($FoundVariableItems, ",");
    $printneati = stringArrayToString($FoundOtherItems, ",");
    $FoundTerms = stringToStringArray($printneat, ",");

    if($sortN== 1){$FoundTerms = `sort $FoundTerms`;}

    return $FoundTerms;

    }
    //////////////////////////////


    proc string [] FindNameOfVariables(string $Find, int $sortN, int $EmptyIntArray[] ){

    $resultVar = "string float vector matrix int proc";
    $resulti = "sin cos tan tand atan asin acos atand asind acosd";
    $result = "abs angle bessel ceil clamp constrainValue cos cross crossProduct deg_to_rad delrandstr dot dotProduct equivalent  equivalentTol erf exp floatEq floor fmod gamma gauss getLastError getProcArguments hermite hsv_to_rgb hypot linstep log mag max min noise  normalize pointMatrixMult pow rad_to_deg rand randstate rgb_to_hsv rot seed sign sin smoothstep sphrand sqrt tan trunc unitprint ";
    $AllMathfunction = "abs ,angle ,bessel ,ceil ,clamp ,constrainValue ,cos ,cross ,crossProduct ,deg_to_rad ,delrandstr ,dot  ,dotProduct ,equivalent ,equivalentTol ,erf ,exp ,floatEq ,floor ,fmod ,gamma ,gauss ,getLastError ,getProcArguments ,hermite ,hsv_to_rgb  ,hypot ,linstep ,log ,mag ,max ,min ,noise ,normalize ,pointMatrixMult ,pow ,rad_to_deg ,rand ,randstate ,rgb_to_hsv ,rot ,seed ,sign ,sin  ,smoothstep ,sphrand ,sqrt ,tan ,trunc ,unit";
    $MathFuncClassData = $result+" "+ $resulti + " " + $resultVar ;
    //string  $KnownMathTermsMELAtomizes[] = ArrayFromAllinString($MathFuncClassData);
    $KnownMathTermsMEL = stringToStringArray($MathFuncClassData, " ");
    $KnownMathTermsMELSorted = `sort $KnownMathTermsMEL`;



    $startingChar = StringArrayStartOfStringinArray($KnownMathTermsMELSorted);
    $shorterListstartingChar = stringArrayRemoveDuplicates ($startingChar);
    $KnownMatch = $KnownMathTermsMELSorted;
    $ArrayLetter = $shorterListstartingChar;
    $Arraytemp = $KnownMathTermsMELSorted;
    $findEachstart = "";
    clear $StartOfEachSTable $itemBackUp;
    $itemBackUp = $ArrayLetter;
    $gatherItems = "";

    for ($eachStringL in $ArrayLetter){
    for ($eachString in $KnownMathTermsMELSorted){
    $StartOfEachS = startString($Arraytemp[0], 1);
    if ($StartOfEachS==$eachStringL){
    $gatherItems += ($Arraytemp[0]+",");
    $Arraytemp = stringArrayRemoveExact({$Arraytemp[0]}, $Arraytemp);
    }
    //else{	$gatherItems="";}	//
    }
    if(`size($gatherItems)`>0){
    $StartOfEachSTable[`size($StartOfEachSTable)`]= $gatherItems;
    }
    $gatherItems="";
    }

    //////////////////////////////////////////////////////////////


    $IndexLetters = CreateIntIndex(`size($ArrayLetter)`);
    $BytNumi = `sizeBytes $Find`;
    clear $all;
    clear $StringIndex;
    $all = ArrayFromAllinString($Find);
    $StringIndex = CreateIntIndex( `size($all)` );
    //map string

    $tempFind = $Find;
    $tempFindwrite = $Find;
    $countIndex = 0;
    clear $indexStart;
    $LetterItem = "";
    clear $FoundVariableItems $FoundOtherItems;
    clear $indexFirstCharItems;
    $BytNx = 0;
    $StringFromReducedArray = "";
    clear $reducedArray;
    clear $allTemp;
    $allTemp = $all;
    $dontUse = "";
    $matchingDontuse = "";
    $freezeTrigger = 0;
    $matching = "";
    $eachInt = 0;
    $iixI = 0;


    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $Find`;
    $match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $Find`;
    $matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $Find`;
    $matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $Find`;
    $MatchStage2 = endString($match, 3);

    $MatchStage3 = startString($match, `sizeBytes $match`-2);
    $MatchStage3i = startString($match, `sizeBytes $matchii`-2);
    $addBracktoMatch3 = ("\["+$MatchStage3+"\]");

    $matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;
    if($matchMiddleDiff=="\."){

    $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    if($matchMaybeVec2!=""){
    $MatchStage4 = startString($match, `sizeBytes $match`-1);
    $match = $MatchStage4;
    }else{ $dontUse = $matchi; $match=$matchi; }
    }else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//
    }

    $matchTemp = $match;
    $BytNx =`sizeBytes $match`;

    $IndexLetters = CreateIntIndex(`size($ArrayLetter)`);
    $StartOfEachSi = "";
    $FOUND = "";
    clear $ArrayFind $TFandIndex $TFandIndexii;
    $Tri = 0;
    $Trii = 2;
    $CountFoundletters = 0;
    $CountTotalFindIndex = 0;
    clear $indexStartEnd;


    for ($eachItemArray in $StringIndex){
    $eachInt = $StringIndex[$iixI];
    $CountTotalFindIndex++;
    if( `gmatch $allTemp[$eachInt] "[a-zA-Z0-9_\.]*"` == 1){
    if($Trii==2){$Trii=1; $Tri=2;}
    if(!($CountFoundletters>=1)){
    $FirstLFindIndex=$iixI+1;

    }
    $CountFoundletters++;
    if($Tri==2){

    $Tri=0;
    }
    $LetterItem+= $allTemp[$eachInt];
    $BytNx = `sizeBytes $LetterItem`;
    if(`gmatch $matchTemp $LetterItem`==1){
    $BytNx = `sizeBytes $LetterItem`;

    //$LetterItem ="pow";
    $StartOfEachSi = startString($LetterItem, 1);
    $TFandIndex = TFArrayContains($StartOfEachSi, $ArrayLetter);
    if($TFandIndex[0]==1){
    $ArrayFind = ReturnArrayFromNestedStringAtIndex($StartOfEachSTable, $TFandIndex[1]);
    $TFandIndexii = TFArrayContains($LetterItem, $ArrayFind);

    if($TFandIndexii[0]==1){
    $FOUND = $ArrayFind[$TFandIndexii[1]];
    if(`gmatch $FOUND $LetterItem`==1){

    $FoundOtherItems[`size($FoundOtherItems)`]= $FOUND;
    }
    }
    }
    if(`gmatch $FOUND $LetterItem`!=1){
    if($matchTemp!=$dontUse){
    $FoundVariableItems[`size($FoundVariableItems)`]= $LetterItem;
    $SizeItem = `size $matchTemp`;
    $indexStartEnd[`size($indexStartEnd)`] = <<$FirstLFindIndex, $iixI, ($iixI-$SizeItem+3)>> ;
    $indexStart[`size($indexStart)`]= $FirstLFindIndex;
    $findByt = `sizeBytes $LetterItem`;
    $CountIndex[`size($CountIndex)`] =  ($CountTotalFindIndex -$findByt)-1;
    }
    } else{$CountFoundletters=0;          }
    clear $TFandIndex $ArrayFind $TFandIndexii;
    $FOUND="";
    $reducedArray = $allTemp;
    stringArrayRemoveToIndex($eachInt+1, $reducedArray);
    $StringFromReducedArray = stringArrayToString($reducedArray, "");

    /////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////
    $LetterItem ="";
    if($matchTemp==$dontUse){ $freezeTrigger = 1; }
    if( `gmatch $allTemp[$eachInt] $match` != 1){$Trii=2; $CountFoundletters=0;}

    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;

    //if(`size($StringFromReducedArray)`>4){
    $match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $StringFromReducedArray`;
    $matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $StringFromReducedArray`;
    $matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $StringFromReducedArray`;
    $MatchStage2 = endString($match, 3);
    $MatchStage3 = startString($match, `sizeBytes $match`-2);
    $MatchStage3i = startString($match, `sizeBytes $matchii`-2);
    $addBracktoMatch3 = ("\["+$MatchStage3+"\]");
    //$addBracktoMatchD = ("\(["+"\"+$matchi+"\])+([a-zA-Z]+)([a-zA-Z0-9_])");
    $matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;

    if($matchMiddleDiff=="\."){

    $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    if($matchMaybeVec2!=""){
    $MatchStage4 = startString($match, `sizeBytes $match`-1);
    $match = $MatchStage4;
    }else{ $dontUse = $matchi; $match=$matchi; }
    }else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//
    }
    }
    }else{$LetterItem ="";  }
    ///}else{$match = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;}
    $matchTemp = $match;

    $iixI++;
    }

    ///////////////

    $printneat = stringArrayToString($FoundVariableItems, ",");
    $printneati = stringArrayToString($FoundOtherItems, ",");
    $FoundTerms = stringToStringArray($printneat, ",");

    if($sortN== 1){$FoundTerms = `sort $FoundTerms`;}
    $EmptyIntArray = $CountIndex;
    return $FoundTerms;

    }



    proc int BracketFindPosNeg(string $Find, int $NegPosZ[]){

    $Fb = "{";
    $Lb = "}";
    $BracketF = `match "[\{]" $Find`;
    $BracketL = `match "[\}]" $Find`;
    $NewSt = "";
    if(($BracketF != "")||($BracketL != "")){
    $BytNumi = `sizeBytes $Find`;
    $all = ArrayFromAllinString($Find);
    $iX = 0;
    for($i=0;$i<$BytNumi;$i++){
    if(( $all[$i] == $Fb ) || ( $all[$i] == $Lb )){
    $NewSt = $all[$i];
    if($NewSt == $Fb){
    $NegPosZ[`size($NegPosZ)`] = 1;
    }else if($NewSt == $Lb){
    $NegPosZ[`size($NegPosZ)`] = -1;
    }
    $iX++;
    }
    }
    }
    for($eachInt in $NegPosZ){
    $AddAll+= $eachInt;
    }
    return $AddAll;
    }


    proc string [] stringArrayFindDupIndexSPair(string $listA[], int $foundN[], int $LineNumberB[])
    {
    $FindNum = 0;
    clear $foundN;
    $LineNumberA = $LineNumberB;
    $list = $listA;
    $listTemp  = $list;
    for ($item in $list) {
    clear $FindIndexN;
    $FindNum = stringArrayCountIndex($item,  $listTemp, $FindIndexN);
    if ($FindNum>1){
    $foundN[`size($foundN)`] = $LineNumberA[$FindIndexN[`size($FindIndexN)`-1]];
    $result[`size($result)`] =  $listTemp[$FindIndexN[`size($FindIndexN)`-1]];
    $LineNumberA = IntRemoveIndexN( $LineNumberA, $FindIndexN);
    $listTemp = RemoveStringAtIndex( $listTemp, $FindIndexN);
    }else{
    if ($FindNum==1){
    $foundN[`size($foundN)`] = $LineNumberA[$FindIndexN[0]];
    $result[`size($result)`] =  $listTemp[$FindIndexN[0]];
    }
    }
    }
    return $result;
    }


    proc int stringArrayCountIndexOne(string $item, string $list[], int $FindIndexN[])
    {
    $result = 0;
    $CountN = 0;
    clear $FindIndexN;

    for ($listItem in $list) {
    if ($item == $listItem){
    $FindIndexN[$result]=$CountN;
    $result++;
    }
    $CountN++;
    }
    return $result;
    }

    proc int [] stringArrayRemoveAtIndexZ( int $indexA, int $list[] )
    {
    $indexS = `size($indexA)`;
    $len = size( $list );
    $Xi = 0;
    while($Xi< $indexS){
    for ( $i = 0; $i < $Xi; $i++ ) {
    $result[$i] = $list[$i];
    }
    $Xi++;
    }
    //$list = $result;
    return $result;
    }

    proc int [] RemoveINTAtIndex(int $VecS[],int $IndeXxI[]){
    $Ix = 0;
    $ii = 0;
    $Ixi = 0;
    $IndeXxz = `sort $IndeXxI`;
    $size = `size($IndeXxI)`-1;
    for ($eachVc in $VecS){
    if($VecS[$ii]>$IndeXxz[$Ixi]){
    if($size==$Ixi){$Ixi=0;}
    $Ixi++;
    }
    if(!($eachVc== $IndeXxz[$Ixi])){
    $newInt[`size($newInt)`] = $eachVc;
    $ii=$Ix;
    }else{$Ixi++;
    if( $Ixi> `size($IndeXxI)`){break;}
    }
    $Ix++;
    }
    return $newInt;
    }


    proc int [] IntArrayRemoveAtIndex( int $index, int $IntArray[] )
    {

    $list = IntArrayToStringArray( $IntArray );
    $len = `size( $list )`;
    for ( $i = 0; $i < $index; $i++ ) {
    $result[$i] = $list[$i];
    }
    for ( ; $i < $len - 1; $i++ ) {
    $result[$i] = $list[$i + 1];
    }
    $list = $result;
    $IntArray = StringArrayToIntArray($list);
    //string [] IntArrayToStringArray(int $IntArray[])
    return $IntArray;
    }

    proc int stringArrayCountIndex(string $item, string $list[], int $FindIndexN[])
    {
    $result = 0;
    $CountN = 0;
    clear $FindIndexN;
    for ($listItem in $list) {
    if ($item == $listItem){
    $FindIndexN[$result]=$CountN;
    $result++;
    }
    $CountN++;
    }
    return $result;
    }

    proc string [] stringArrayStrip(string $list[])
    {
    $index = 0;
    for ($item in $list) {
    $result[$index++] = substituteAllString($item, " ", "");
    }
    return $result;
    }


    proc string [] stringArrayFindDuplicates(string $list[])
    {
    $index = 0;
    for ($item in $list) {
    if (1 < stringArrayCount($item, $list)) {
    $result[$index++] = $item;
    }
    }
    return $result;
    }


    proc int [] stringArrayRemoveAtIndexZ( int $indexA, int $list[] )
    {
    $indexS = `size($indexA)`;
    $len = size( $list );
    $Xi = 0;
    while($Xi< $indexS){
    for ( $i = 0; $i < $Xi; $i++ ) {
    $result[$i] = $list[$i];
    }
    $Xi++;
    }
    //$list = $result;
    return $result;
    }


    proc int [] RemoveINTAtIndex(int $VecS[],int $IndeXxI[]){
    $Ix = 0;
    $ii = 0;
    $Ixi = 0;
    $IndeXxz = `sort $IndeXxI`;
    $size = `size($IndeXxI)`-1;
    for ($eachVc in $VecS){
    if($VecS[$ii]>$IndeXxz[$Ixi]){
    if($size==$Ixi){$Ixi=0;}
    $Ixi++;
    }
    if(!($eachVc== $IndeXxz[$Ixi])){
    $newInt[`size($newInt)`] = $eachVc;
    $ii=$Ix;
    }else{$Ixi++;
    if( $Ixi> `size($IndeXxI)`){break;}
    }
    $Ix++;
    }
    return $newInt;
    }


    proc string [] stringArrayStrip(string $list[])
    {
    $index = 0;
    for ($item in $list) {
    $result[$index++] = substituteAllString($item, " ", "");
    }
    return $result;
    }


    proc string [] stringArrayFindDuplicates(string $list[])
    {
    $index = 0;
    for ($item in $list) {
    if (1 < stringArrayCount($item, $list)) {
    $result[$index++] = $item;
    }
    }
    return $result;
    }

    ////////////////


    proc string[] FindStringVarZ(string $FindZ){
    $FindN = $FindZ;
    $Size =  `sizeBytes  $FindN`;
    while($Size>0){

    $match0N = `match "([\$]+)([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
    if(`sizeBytes $match0N`>0){
    $stringRN = `substitute $match0N $FindN ""`;
    $FindN = $stringRN;
    }

    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
    $Size =  `sizeBytes  $match0`;
    if($Size>0){
    $CollectFinds[`size($CollectFinds)`]= $match0;
    $stringRN = `substitute $match0 $FindN""`;
    $FindN = $stringRN;
    }
    }
    return $CollectFinds;
    }

    proc string[] FindTrueStringVarZ(string $FindZ){
    $FindN = $FindZ;
    $Size =  `sizeBytes  $FindN`;
    while($Size>0){
    $match0 = `match "([\$]+)([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
    // $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;

    $Size =  `sizeBytes  $match0`;
    if($Size>0){
    $CollectFinds[`size($CollectFinds)`]= $match0;
    $stringRN = `substitute $match0 $FindN""`;
    $FindN = $stringRN;
    }
    }
    return $CollectFinds;
    }



    proc string [] RemoveStringAtIndex(string $VecS[],int $IndeXz[]){
    $IndeXxiz = sort($IndeXz);
    $SizA = `size($IndeXz)`;
    $Ixx = 0;
    $Ixi = 0;
    for ($eachVc in $VecS){
    if(!($Ixx== $IndeXxiz[$Ixi])){
    $newVec[`size($newVec)`] = $eachVc;
    }else{$Ixi++;}
    $Ixx++;
    }
    return $newVec;
    }

    proc int [] RemoveIntAtIndex(int $VecS[],int $IndeXz[]){
    $IndeXxiz = sort($IndeXz);
    $SizA = `size($IndeXz)`;
    $Ixx = 0;
    $Ixi = 0;
    for ($eachVc in $VecS){
    if(!($Ixx== $IndeXxiz[$Ixi])){
    $newVec[`size($newVec)`] = $eachVc;
    }else{$Ixi++;}
    $Ixx++;
    }
    return $newVec;
    }



    proc int [] StringArrayToIntArray(string $listA[]){
    for($eachString in $listA){
    $IntA[`size($IntA)`]=$eachString;
    }
    return $IntA;
    }




    proc int FindSCRIPTNAME(string $LineNA){
    $Trigger = 0;
    $Parts =FindStringVarZ($LineNA);
    if(`size($Parts)`>0){
    for($eachP in $Parts){
    if(`gmatch "proc" $eachP` == 1){$Trigger=1;}
    }
    }
    return $Trigger;
    }

    /*
    $TEMPNAMES =RuleBasedMatchM($IndexX,$CAL_temp, $DebugS);
    print $TEMPNAMES
    print $IndexX;
    clear$IndexX;
    clear$TEMPNAMES;

    print $DebugS[22];


    $Parts =FindStringVarZ($DebugS[22]);
    */


    proc string [] RuleBasedMatchM(int $IndexN[],string $FindItemAllCase[], string $LineNA[]){

    $CountCase = 0;
    $Trigger = 0;

    if(`size($IndexN)`>0){
    clear $IndexN;
    }

    for($LineN in $LineNA){
    $CountCase =0;
    for($eachFindItem in $FindItemAllCase){

    //$matchString = `match $eachFindItem $LineN`;
    $Parts =FindStringVarZ($LineN);

    if(`size($Parts)`>0){
    for($eachP in $Parts){
    if(`gmatch $eachFindItem $eachP` == 1){
    $FoundP[`size($FoundP)`]= $eachFindItem;
    $Trigger=1;
    clear $Parts;
    break;
    }
    }
    }

    $matchString="";
    if($Trigger==1){break;}
    $CountCase++;
    }

    if(($CountCase>0)||($Trigger==1)){
    $returnCaseN[`size($returnCaseN)`] = $CountCase;
    $IndexN =$returnCaseN;
    }
    $Trigger=0;
    }

    return $FoundP;
    }


    proc string [] RuleBasedMatchMM(int $IndexN[],string $FindItemAllCase[], string $LineNA[]){
    $CountCase = 0;
    $Trigger = 0;
    for($LineN in $LineNA){
    $CountCase =1;
    $Number=-1;
    $Parts =FindStringVarZ($LineN);
    print $Parts;
    if(`size($Parts)`>0){

    for($eachP in $Parts){
    $Number = RuleBasedMatch($FindItemAllCase, $eachP);
    if($Number != -1){
    $FoundP[`size($FoundP)`]= $FindItemAllCase[$Number];
    $Trigger=1;
    }

    if($Trigger==1){break;}
    }
    clear $Parts;
    }

    if($Trigger==1){$returnCaseN[`size($returnCaseN)`] = $Number;}
    $Trigger=0;
    }
    $IndexN =$returnCaseN;
    return $FoundP;
    }


    proc int RuleBasedMatch(string $FindItemAllCase[], string $LineN){
    $CountCase = 0;
    $returnCaseN = 0;
    for($eachFindItem in $FindItemAllCase){
    //$matchString = `match $eachFindItem $LineN`;
    if(`gmatch $eachFindItem $LineN` == 1){
    $returnCaseN = $CountCase;
    break;
    }
    $CountCase++;
    }
    return $returnCaseN;
    }





    proc string [] AppendArrayZ(string $A[] , string $B[]){
    for($eachF in $B){
    $A[`size($A)`]= $eachF;
    }
    return $A;
    }



    proc int [] intArrayRemoveDuplicates(int $list[])
    {
    $index = 0;
    for ($item in $list) {
    if (0 == intArrayCount($item, $result)) {
    $result[$index++] = $item;
    }
    }
    return $result;
    }


    proc int intArrayCount(int $item, int $list[])
    {
    $result = 0;
    for ($listItem in $list) {
    if ($item == $listItem) $result++;
    }
    return $result;
    }


    proc string RemoveEscapedLine(string $TEXTA){
    $MatchPart = "";
    $stringNX = "";
    $MatchPart=match( "//", $TEXTA );
    if(`sizeBytes $MatchPart`>0){
    $MatchPart="";
    $MatchPart=match( "//[^\n]*", $TEXTA  );
    $stringNX = `substitute $MatchPart $TEXTA ""`;
    }else{$stringNX =$TEXTA;}
    return $stringNX;
    }



    proc string [] BracketFind(string $Find){
    $BytNumi = `sizeBytes $Find`;
    for($i=0;$i<$BytNumi;$i++){
    if($i==100){
    break;}
    $FirstBracket = `match "[\(][^\(]*[^.]*[^\(]*[\)]" $Find`;
    if($FirstBracket != ""){
    $AllFOUND[`size($AllFOUND)`] = $FirstBracket;
    $text = $Find;
    $result = substituteAllString($text, $FirstBracket, "#");
    $Find =  $result;
    }else if($FirstBracket == ""){
    print "found nothing";
    print $AllFOUND;
    $i = $BytNumi +2;
    break;
    }
    }
    return $AllFOUND;
    }

    proc string [] BracketFind(string $Find){
    $BytNumi = `sizeBytes $Find`;
    for($i=0;$i<$BytNumi;$i++){
    if($i==100){
    break;}
    $FirstBracket = `match "[\(][^\)]*[^.]*[^\(]*[\)]" $Find`;
    if($FirstBracket != ""){
    print ("found something"+"\n");
    $AllFOUND[`size($AllFOUND)`] = $FirstBracket;
    $text = $Find;
    $result = substituteAllString($text, $FirstBracket, "#");
    $Find =  $result;
    }else if($FirstBracket == ""){
    $i = $BytNumi +2;
    break;
    }
    }
    return $AllFOUND;
    }

    /*

    $testM = "$XI[1]= FloatToVec (MidPoint($XI[0],$XI[2]));";
    $BB = "$In3 = FloatToVec (lineIntersection($Po4[$Fi], $Xd, $li,(DirectionFN( $Ca,$li)) ));";

    $testBBracket = `match "[\(][\(]*[^.]*[^\(]*[\)]" $BB`;
    $testBBracket = `match "[\(]*[^.]*[\)]*[\)^]" $testBBracket`;


    $testB = BracketFind($BB);
    print $testB;


    $testM = "float $Po12[] = {($Po13[0]*-1), $Po13[1],$Po13[2]};";
    $testM = "float $Po12 = {($Po13[0]*-1), $Po13[1],$Po13[2]};";



    $B = `match "(float*[a-zA-Z_0-9]).+\=" $testM`;
    $B2 = `match ".*\\[" $B`;

    //
    ///



    $testM = "float $lineEPointA[]= MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);";
    $testM = "float $li[]= MultLenToDirAddToPoint($Le, $Fl, $Ve8[$Fi]);";
    $testM = "$BInomalV = FloatToVec(MultLenToDirAddToPoint(4, $BInomalVDirLine, $PtsVec [0]));";


    //current line
    //the command to replace
    $VartoReplace = "MultLenToDirAddToPoint";
    $OriginalStart = `match ".*\=" $testM`;
    //string $OriginalStart=`match ".*=*[+^M]" $testM`;
    $M = `match "($VartoReplace*[a-zA-Z_0-9]).+\;" $testM`;
    $M2 = `match "[\(][^\(]*[^.]*[^\(]*[\)]" $M`;
    $result = substituteAllString($M2, "(", "");
    $result = substituteAllString($result, ")", "");
    $M3 = `match "\$*[^,]*" $result`;
    clear $PartS;

    $resultTemp = $result;
    $BytS = 1;
    $PartS = stringToStringArray($resultTemp, ",");
    $Fix = $OriginalStart+"\("+$PartS[0]+"\*"+$PartS[1]+"\)"+"\+"+$PartS[2]+"\;";

    print ($testM+"\n");
    print ($Fix+"\n");







    //string $M3 = `match "[\[][^\[]*[^.]*[^\[]*[\]]" $M`;
    // $result = substituteAllString($result, $M3, "");
    $In3 = FloatToVec (lineIntersection($Po4[$Fi], $Xd, $li,(DirectionFN( $Ca,$li)) ));

    */


    proc int BracketFindPosNegRuleE( int $CN, string $NewLineX, string $TEXTA, int $NegPosZ[]){

    $AddAll = 0;
    $NewLineX="";
    $BracketF = `match "[\/]+[\*]"$TEXTA`;
    $BracketL = `match "[\*]+[\/]" $TEXTA`;
    $TRUEA = 0; int $TRUEB=0;

    if(`sizeBytes $BracketF`>0){$TRUEA=1;}
    if(`sizeBytes $BracketL`>0){$TRUEB=1;}

    if($TRUEA+$TRUEB!=2){
    if($TRUEA==1){
    $NegPosZ[`size($NegPosZ)`] = 1;
    $NewLineX=`substitute "//\*[^\n]*" $TEXTA ""`;
    }
    if($TRUEB==1){
    $NegPosZ[`size($NegPosZ)`] = 2;
    $NewLineX= `substitute ".*\*/" $TEXTA ""`;
    }
    for($eachInt in $NegPosZ){
    $CN++;
    $AddAll+= $eachInt;
    }
    }else{

    if($TRUEA+$TRUEB==3){
    $MatchPartA=`substitute "//\*[^\n]*" $TEXTA ""`;
    $MatchPartB=`substitute ".*\*/" $TEXTA ""`;
    $NewLineX=($MatchPartA+" "+$MatchPartB);
    $AddAll=0;
    }
    }


    return $AddAll;
    }


    proc string[] RStringArrayStartOfStringinArray(string $Array[]){
    $findEachstart = "";
    for ($eachString in $Array){

    $stringRN = `substitute "[/$]" $eachString ""`;
    $S=startString($eachString, 3);

    $findEachstart= $S;
    $findEachstart+= "";
    $StartOfEach[`size($StartOfEach)`]= $findEachstart;
    }

    return $StartOfEach;
    }

    proc string [] stringArrayCountDuplicatesAUGMENT(string $listX[],string $AddtoEnd)
    {
    $list = $listX;
    $list = ReverseStringArray($list);
    $index = 0;
    $X = 0;
    $C = 0;
    $result = $list;
    $Expr = "\\$";
    $ExprA = "";

    for ($item in $list) {
    $NumberE[$X] = stringArrayCount($item, $result);
    if (1 == $NumberE[$X]) {
    if(startString($item, 1)!= "$"){
    $CollectR[$X] = $ExprA+$item+$AddtoEnd;
    }
    if(startString($item, 1)== "$"){
    $CollectR[$X] = $item+$AddtoEnd;}
    }else{
    if (1 < $NumberE[$X]) {
    $C = $NumberE[$X]-1;
    if(startString($item, 1)!= "$"){
    $CollectR[$X] = $ExprA+$item+$C+$AddtoEnd;
    }
    if(startString($item, 1)== "$"){
    $CollectR[$X] = $item+$C+$AddtoEnd;
    }
    }
    }
    stringArrayRemoveToIndex(1, $result);
    $X++;	}
    $CollectR = ReverseStringArray($CollectR);
    return $CollectR;
    }

    proc string[] ReverseStringArray(string $array[]){
    for($i=0;$i<size($array);$i++){
    $arrayOut[$i]=$array[(size($array)-1-$i)];}
    return $arrayOut;
    }
    proc stringArrayRemoveToIndex(int $ix, string $stringArray[]){
    $ixX = 0;
    while($ixX<$ix){
    stringArrayRemoveAtIndex(0, $stringArray);
    $ixX++;
    }
    }
    proc int [] CreateIntIndex(int $ArraySize){
    $iNdex = 0;
    while($iNdex < $ArraySize){
    $IntArrayInex[$iNdex] = $iNdex;
    $iNdex++;
    }
    return $IntArrayInex;
    }

    proc string RuleBasedMatchReplaceLine(string $FindItemAllCase[],string $ReplaceCase[], string $LineN){
    $CC = 0;
    $returnCaseN = 0;
    $CHANGE=$LineN;
    for($eachFindItem in $FindItemAllCase){
    $matchString = `match $eachFindItem $CHANGE`;
    $Size =  `sizeBytes  $matchString`;
    if($Size>0){
    $CHANGE = substituteAllString($CHANGE, $matchString,  $ReplaceCase[$CC]);
    }
    $CC++;
    }
    return $CHANGE;
    }



    ///////////////////////////////////////


    $Path = "C:\\Users/johnny/Documents/maya/scripts/StereoCurveZTemp.TXT";
    $exampleFileName = ( $Path );


    clear $CollectAllLines;
    $LineN = "";
    $FindItem = "";

    $fileId = `fopen $exampleFileName "r"`;
    $nextLine = `fgetline $fileId`;
    $failsafe = 0;

    while ( !`feof $fileId` ) {

    //print $nextLine;
    $stringRN =  $nextLine;
    $stringRN = `substitute "(\n)" $stringRN ""`;
    $MatchPartA=match( ".*[^\t\r\n]", $nextLine );

    if(`sizeBytes $MatchPartA`>0){

    //$stringN = $nextLine;

    $LineN = $stringRN;
    //$matchString = `match $FindItem $LineN`;
    //if(`gmatch $matchString $FindItem` == 1){

    $CollectAllLines[`size($CollectAllLines)`]=$LineN;
    //}

    }
    $nextLine = `fgetline $fileId`;
    $failsafe++;

    if($failsafe==600){
    break;
    }
    }

    fclose $fileId;

    //  print $CollectAllLines;

    /////////////////////////////////////////////////////////////////////////////////////////////////// end of new change ^
    // print $CollectAllLines;





    $CNX = 0;
    for ($eachString in $CollectAllLines){
    $TempAllVarZ = FindTrueStringVarZ($eachString);
    AppendArrayZ($AllVarZ , $TempAllVarZ);
    if(`size($TempAllVarZ)`>0){
    clear $TempAllVarZ;
    }
    $CNX++;
    }


    $shorterListAllVarZ = stringArrayRemoveDuplicates ($AllVarZ);
    $SizeAll = `size($shorterListAllVarZ)`;
    $startingCharV = RStringArrayStartOfStringinArray($shorterListAllVarZ);


    $NewNames = stringArrayCountDuplicatesAUGMENT($startingCharV,"");
    clear $NewLineZ;
    $CountLineX = 0;

    for ($eachStringL in $CollectAllLines){
    $NewLineChange = RuleBasedMatchReplaceLine($shorterListAllVarZ ,$NewNames, $eachStringL);
    $NewLineZ[`size($NewLineZ)`] = $NewLineChange;
    $CountLineX++;
    }
    print $NewLineZ;






    $PathW = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
    $exampleFileNameW = ( $PathW );

    $Path = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEW.TXT";
    $exampleFileName = ( $Path );


    //clears the file i think
    $fileIdW = `fopen $exampleFileNameW "w"`;
    fclose $fileIdW;


    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $CountX = 0;
    $fileIdW = `fopen $exampleFileNameW "w"`;
    $fileId = `fopen $exampleFileName "r"`;
    $nextLine = "";
    $nextLineN = "";
    $TriggerLineFound = 0;
    $START = 0;
    $MatchPartA = "";
    $MatchPartB = "";
    $NewLineXA = "";
    $DontWrite = 0;
    $NegPosZA[0]=0;
    clear $NegPosZA;
    $CountN = 1;

    while ( !`feof $fileId` ) {
    $nextLine = `fgetline $fileId`;
    $nextLineN = $nextLine;

    $nextLineN=RemoveEscapedLine($nextLineN);
    $MatchPartA=match( ".*[^\t\r\n]", $nextLineN );
    if(`sizeBytes $MatchPartA`>0){
    $MatchPartA=match( ".*[^\t\r\n]", $nextLineN );
    $nextLineN=( $MatchPartA +"\r"+"\n");
    fprint $fileIdW $nextLineN;
    }

    }

    fclose $fileIdW;
    fclose $fileId;




    $PathW = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
    $exampleFileNameW = ( $PathW );

    $Path = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEW.TXT";
    $exampleFileName = ( $Path );

    $Path = "C:\\Users/johnny/Documents/maya/scripts/TESTRUN.TXT";
    $exampleFileName = ( $Path );

    //clears the file i think
    $fileIdW = `fopen $exampleFileNameW "w"`;
    fclose $fileIdW;


    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $CountX = 0;
    $fileIdW = `fopen $exampleFileNameW "w"`;
    $fileId = `fopen $exampleFileName "r"`;
    $nextLine = "";
    $nextLineN = "";
    $TriggerLineFound = 0;
    $START = 0;
    $MatchPartA = "";
    $MatchPartB = "";
    $NewLineXA = "";
    $DontWrite = 0;
    $NegPosZA[0]=0;
    clear $NegPosZA;
    $CountN = 1;

    while ( !`feof $fileId` ) {
    $nextLine = `fgetline $fileId`;
    $nextLineN = $nextLine;



    $MatchPartA=match( ".*[^\t\r\n]", $nextLineN );

    // if(`sizeBytes $MatchPartA`>0){
    $WhenZero = BracketFindPosNegRuleE($CountN,$NewLineXA,$nextLineN, $NegPosZA);

    if($WhenZero!=0){
    $CountN+=$WhenZero;
    }
    if($WhenZero==3){
    $CountN*=-1;
    print $CountN;
    }

    if(($CountN==2)||($WhenZero==3)){
    $nextLineN=$NewLineXA;
    }


    if(($CountN<=2)||($WhenZero==3)){

    if(($CountN<0)&&($WhenZero!=3)){
    // do nothing
    }else{

    $nextLineN=RemoveEscapedLine($nextLineN);
    $MatchPartA=match( ".*[^\r\n]", $nextLineN );
    $nextLineN=( $MatchPartA +"\r"+"\n");
    fprint $fileIdW $nextLineN;
    }

    }

    if($CountN<0){
    clear $NegPosZA;
    $CountN=1;
    }

    //}

    }

    fclose $fileIdW;
    fclose $fileId;
    -13-24-100-11-19-194-160-534-262-22-38-20-12-876-70-18-800-74-74-118-34-12-10-100-1982-404-1100-10-40-240-840-10-16-60-2534-610-44-126-498-36-2018-1106-118
    -12-23-90-10-18-182-138-456-256-18-36-16-6-746-58-14-646-46-54-102-28-6-6-88-1794-364-982-6-34-208-808-6-6-50-2330-548-38-120-428-34-1654-990-104
    -12-23-90-10-18-180-136-454-254-16-34-14-6-746-58-14-646-46-54-102-28-6-6-88-1794-364-982-6-34-208-808-6-6-50-2330-548-38-120-428-34-1654-990-104fclose $fileIdW;





    $PathW = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
    $exampleFileNameW = ( $PathW );

    $Path = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEW.TXT";
    $exampleFileName = ( $Path );

    //clears the file i think
    $fileIdW = `fopen $exampleFileNameW "w"`;
    fclose $fileIdW;


    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $CountX = 0;
    $fileIdW = `fopen $exampleFileNameW "w"`;
    $fileId = `fopen $exampleFileName "r"`;
    $nextLine = "";
    $nextLineN = "";
    $TriggerLineFound = 0;
    $START = 0;
    $MatchPartA = "";
    $MatchPartB = "";
    $NewLineXA = "";
    $DontWrite = 0;

    while ( !`feof $fileId` ) {
    $nextLine = `fgetline $fileId`;
    $nextLineN = $nextLine;

    $nextLineN=RemoveEscapedLine($nextLineN);

    $MatchPartA=match( ".*[\n]", $nextLineN );
    if(`sizeBytes $MatchPartA`>0){


    $MatchPartB=match( "/", $nextLineN );
    if(`sizeBytes $MatchPartB`>0){

    $WhenZero = BracketFindPosNegRuleE($NewLineXA,$nextLineN, $NegPosZA);
    $nextLineN=$NewLineXA;


    if(($WhenZero==1)||($WhenZero==0)){

    if($DontWrite==0){
    $nextLineN=($nextLineN +"\r"+"\n");
    fprint $fileIdW $nextLineN;
    }

    }

    if(`size($NegPosZA)`>0){
    $DontWrite=1;
    }
    if(($WhenZero==0)&&(`size($NegPosZA)`>0)){
    if($DontWrite==1){
    $WhenZero=2;
    clear $NegPosZA;
    $DontWrite=0;
    }
    }
    }
    ////////////

    if(`size($NegPosZA)`==0){
    if($DontWrite==0){
    $nextLineN=($nextLineN +"\r"+"\n");
    fprint $fileIdW $nextLineN;
    }
    }

    }

    }

    fclose $fileIdW;
    fclose $fileId;







    $Path = "C:\\Users/johnny/Documents/maya/scripts/STEREOCURVESPROC2011.TXT";
    $exampleFileName = ( $Path );

    //string $Path = "C:\\Users/johnny/Documents/maya/scripts/ArrayRotationIterative.TXT";
    //string $exampleFileName = ( $Path );


    $ScriptNAME = ("proc[^\\n]*");
    $FindItem = "proc";
    $GlobalSNAME = ("global[^\\n]*");



    clear $CollectAllLines;
    $LineN = "";
    clear $LineNumber;
    $CountNL = 1;
    $CountFindNL = 0;
    $CountMasterInDex = 0;

    $fileId = `fopen $exampleFileName "r"`;

    while ( !`feof $fileId` ) {

    $nextLine = `fgetline $fileId `;
    $stringN = match( "^[^(\r\n)]*", $nextLine );


    //$stringN = $nextLine;
    $LineN =  $stringN;

    //$LineN =match( "[/(proc)]*", $stringN  );
    if(`FindSCRIPTNAME($LineN )` == 1){

    //if(`gmatch $FindItem $LineN` == 1){
    //$LineN =match( $ScriptNAME, $nextLine);

    $CollectAllLines[`size($CollectAllLines)`]=  $LineN ;
    $LineNumber[$CountFindNL] = $CountNL;
    $CountFindNL++;
    }
    $CountNL++;
    $CountMasterInDex++;
    }

    fclose $fileId;
    print $CollectAllLines[0];

    print $LineNumber


    //////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////

    // FIND LAST DUPLICATES

    proc int[] SortIntIndexTrack(int $AllFloatToSort[]){
    for($ii=0; $ii<`size($AllFloatToSort)`; $ii++){
    $aF[$ii]= ($AllFloatToSort[$ii]);
    }
    $sIze = `size($aF)`-1;
    $IndexTrack = CreateIntIndex(`size($aF)`);
    quickSort($aF, $IndexTrack, 0, $sIze);
    $IndexTrack = ReverseIntArray($IndexTrack);
    return $IndexTrack;
    }



    $SizeL = `size($CollectAllLines)`;
    clear $JustNames;
    for($iL=0; $iL<$SizeL; $iL++){
    $TempN = FindStringVarZ($CollectAllLines[$iL]);
    $JustNames[$iL]=$TempN[`size($TempN)`-1];
    }
    size($JustNames);
    size($CollectAllLines);

    $CollectAllLines = $JustNames;


    clear $tempLineNumber;
    $tempLineNumber = $LineNumber;
    clear $foundNA;
    // line number is an extraction...... //
    clear $tempCollectAllLines;
    $tempCollectAllLines = $CollectAllLines;
    clear $CollectAllDuplicates;

    /////////////////////////////string $tempCollectAllLines[] = stringArrayStrip($CollectAllLines);

    $CollectAllDuplicates = stringArrayFindDupIndexSPair($tempCollectAllLines,$foundNA, $tempLineNumber);


    $intIDXSort = SortIntIndexTrack($foundNA);

    for($ii=0; $ii<`size($intIDXSort)`; $ii++){
    $newCollectDupString[$ii]= $CollectAllDuplicates[$intIDXSort[$ii]];
    }
    print $newCollectDupString;



    //print  $foundNA;
    //print $CollectAllDuplicates

    //string $shouldBEZero[];
    //$shouldBEZero= stringArrayFindDuplicates($CollectAllDuplicates);



    // IMPORTANT SORT

    $foundNA =`sort $foundNA`;


    //int $foundNA[];
    //$foundNA =$MasterLineN;


    $Path = "C:\\Users/johnny/Documents/maya/scripts/STEREOCURVESPROC2011.TXT";
    $exampleFileName = ( $Path );


    $PathW = "C:\\Users/johnny/Documents/maya/scripts/NewPlaceHere.TXT";
    $exampleFileNameW = ( $PathW );

    //clears the file i think
    $fileIdW = `fopen $exampleFileNameW "w"`;
    fclose $fileIdW;


    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $CountX = 0;
    $fileIdW = `fopen $exampleFileNameW "w"`;
    $fileId = `fopen $exampleFileName "r"`;
    $nextLine = "";
    $nextLineN = "";
    $TriggerLineFound = 0;
    $START = 0;
    $InputLine = ("///THIS IS A DUPLICATE ///"+"\r"+"\n");

    while ( !`feof $fileId` ) {
    $nextLine = `fgetline $fileId`;
    $nextLineN = $nextLine;
    $nextLineR = match( ".*[^(\n)]", $nextLine );

    if($foundNA[$CountFindNL] == $CountNL){
    fprint $fileIdW ("\r"+"\n");
    $CountFindNL++;
    $TriggerLineFound=1;
    }

    if($TriggerLineFound==1){
    $WhenZero = BracketFindPosNeg($nextLine, $NegPosZA);
    $START++;
    $nextLineN=($nextLineR +"\r"+"\n");

    fprint $fileIdW $nextLineN;


    if((`size($NegPosZA)`>0)&&($START>1)){
    if($WhenZero==0){
    $START=$TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
    fprint $fileIdW ("\r"+"\n");
    }
    }

    }
    $CountNL++;
    }

    fclose $fileIdW;
    fclose $fileId;



    //////////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////////
    //small addOn




    $Path = "C:\\Users/johnny/Documents/maya/scripts/PlaceHere.TXT";
    $exampleFileName = ( $Path );
    clear $IndeXCN;
    $IndeXCN
    clear $IndexR;
    $SizeCD = `size($newCollectDupString)`-1;

    $fileId = `fopen $exampleFileName "r"`;

    while ( !`feof $fileId` ) {

    $nextLine = `fgetline $fileId `;
    $nextLineR = match( ".*[^(\n)]", $nextLine );
    //$nextLineRN = match( ".*[^(\n)]", $nextLine );

    $Size =  `sizeBytes  $nextLineR`;
    if($Size>0){
    RuleBasedMatchM($IndexR,$newCollectDupString, {$nextLineR});
    for($ii=0; $ii<`size($IndexR)`; $ii++){
    $IndeXCN[$IndexR[$ii]]+=1;
    }
    clear $IndexR;
    }
    }

    fclose $fileId;



    for($ii=0; $ii<`size($newCollectDupString)`; $ii++){
    $StringINDEXCN=$IndeXCN[$ii];
    $PRINTPRoc_andNumber[$ii]=($newCollectDupString[$ii]+" "+$StringINDEXCN);

    }
    print $PRINTPRoc_andNumber;
    size($IndeXCN);
    size($PRINTPRoc_andNumber);
    print $IndeXCN;


    $IndeXCN = RemoveIntAtIndex($IndeXCN,{(`size($IndeXCN)`-1)});


    $intIDXSortX = SortIntIndexTrack($IndeXCN);

    for($ii=0; $ii<`size($intIDXSort)`; $ii++){
    $SortCountProcUse[$ii]= $newCollectDupString[$intIDXSortX[$ii]];
    }
    print $SortCountProcUse;



    clear $newfoundNA;
    for($ii=0; $ii<`size($IndeXCN)`; $ii++){

    if($IndeXCN[$ii]!=1){
    $newfoundNA[`size($newfoundNA)`]= $foundNA[$ii];
    }
    }


    print $newfoundNA;

    size($newfoundNA);

    size($newCollectDupString);
    size($IndexR);
    size($IndeXCN);
    size($foundNA);
    size($CollectAllDuplicates);
    size($intIDXSort);
    size($newCollectDupString);


    $newfoundNA =`sort ($newfoundNA)`;



    $Path = "C:\\Users/johnny/Documents/maya/scripts/STEREOCURVESPROC2011.TXT";
    $exampleFileName = ( $Path );


    $PathW = "C:\\Users/johnny/Documents/maya/scripts/NewPlaceHere.TXT";
    $exampleFileNameW = ( $PathW );

    //clears the file i think
    $fileIdW = `fopen $exampleFileNameW "w"`;
    fclose $fileIdW;


    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $CountX = 0;
    $fileIdW = `fopen $exampleFileNameW "w"`;
    $fileId = `fopen $exampleFileName "r"`;
    $nextLine = "";
    $nextLineN = "";
    $TriggerLineFound = 0;
    $START = 0;
    $InputLine = ("///THIS IS A DUPLICATE ///"+"\r"+"\n");

    while ( !`feof $fileId` ) {
    $nextLine = `fgetline $fileId`;
    $nextLineN = $nextLine;
    $nextLineR = match( ".*[^(\n)]", $nextLine );

    if($newfoundNA[$CountFindNL] == $CountNL){
    fprint $fileIdW ("\r"+"\n");
    $CountFindNL++;
    $TriggerLineFound=1;
    }

    if($TriggerLineFound==1){
    $WhenZero = BracketFindPosNeg($nextLine, $NegPosZA);
    $START++;
    $nextLineN=($nextLineR +"\r"+"\n");

    fprint $fileIdW $nextLineN;


    if((`size($NegPosZA)`>0)&&($START>1)){
    if($WhenZero==0){
    $START=$TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
    fprint $fileIdW ("\r"+"\n");
    }
    }

    }
    $CountNL++;
    }

    fclose $fileIdW;
    fclose $fileId;








    ////////////////////

    //START X




    $Path = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
    $exampleFileName = ( $Path );


    $FindItem = "proc";
    //string $FindItem = "print";
    //string $FindItem = "//";


    clear $CollectAllLines;
    $LineN = "";
    clear $LineNumber;
    $CountNL = 1;
    $CountFindNL = 0;
    $CountMasterInDex = 0;

    $fileId = `fopen $exampleFileName "r"`;
    //string $nextLine = `fgetline $fileId`;
    while ( !`feof $fileId` ) {


    $nextLine = `fgetline $fileId`;
    $stringN = match( "^[^(\r\n)]*", $nextLine );
    $LineN = $stringN;

    if(`FindSCRIPTNAME($LineN )` == 1){
    $CollectAllLines[`size($CollectAllLines)`]=  $LineN ;
    $LineNumber[$CountFindNL] = $CountNL;
    $CountFindNL++;
    }

    $CountNL++;
    $CountMasterInDex++;
    }

    fclose $fileId;


    size($CollectAllLines);
    size($LineNumber);

    print $CollectAllLines[0];
    FindStringVarZ($CollectAllLines[0]);


    //////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////

    // FIND LAST DUPLICATES

    $SizeL = `size($CollectAllLines)`;
    clear $JustNames;
    for($iL=0; $iL<$SizeL; $iL++){
    $TempN = FindStringVarZ($CollectAllLines[$iL]);
    $JustNames[$iL]=$TempN[`size($TempN)`-1];
    }




    size($JustNames);
    size($CollectAllLines);
    size($LineNumber);

    $TempSaveLine=$LineNumber;
    $CollectAllLines = $JustNames;

    //TempERROR hack

    $CurrentProc[0] ="proc";

    $i = 0;
    clear $IndexX;
    clear $FoundProc;
    clear $CurrentLineN;
    $FoundProc =RuleBasedMatchM($IndexX,$CollectAllLines, $CurrentProc);
    //print $IndexX;
    for($i=0; $i<`size($IndexX)`; $i++){
    $CurrentLineNF[$i] =$LineNumber[$IndexX[$i]];
    }
    print $CurrentLineNF;

    $CollectAllLines=RemoveStringAtIndex($CollectAllLines,$IndexX);
    $LineNumber = RemoveIntAtIndex($LineNumber,$IndexX);

    //!!!Super Crazy Error!!! A String call "proc" was gathered as a function proc!
    /*
    print $CollectAllLines[$IndexX[0]];
    $CollectAllLines=RemoveStringAtIndex($CollectAllLines,$IndexX);
    $LineNumber = RemoveIntAtIndex($LineNumber,$IndexX);
    */
    /// End of error hack




    //start of normal script



    $TempSaveLine=$LineNumber;
    $CollectAllLines = $JustNames;



    $CurrentProc[0] ="AutoCurveScriptsTwoCurve";
    $CurrentProc[1] ="RUNMoveZCURVEM";
    $CurrentProc[2] ="EvalAllCurvesToolZ";
    $CurrentProc[3] ="CreateCAMforIntCurveScript";
    $CurrentProc[4] ="createStageOneForRetopo";



    clear $CurrentProc;
    $CurrentProc[0] ="CreateCAMforIntCurveScript";
    $CurrentProc[1] ="createStageOneForRetopo";







    $TempSaveLine=$LineNumber;
    $CollectAllLines = $JustNames;



    clear $CurrentProc;
    $CurrentProc[0] ="AutoCurveScriptsTwoCurve";




    $TempSaveLine=$LineNumber;
    $CollectAllLines = $JustNames;



    $CurrentProc[0] ="AutoCurveScriptsTwoCurve";
    $CurrentProc[1] ="RUNMoveZCURVEM";
    $CurrentProc[2] ="EvalAllCurvesToolZ";
    $CurrentProc[3] ="CreateCAMforIntCurveScript";
    $CurrentProc[4] ="createStageOneForRetopo";




    clear $CurrentLineNF;

    $i = 0;
    clear $IndexX;
    clear $FoundProc;

    $FoundProc =RuleBasedMatchM($IndexX,$CollectAllLines, $CurrentProc);
    //print $IndexX;
    for($i=0; $i<`size($IndexX)`; $i++){
    $CurrentLineNF[$i] =$LineNumber[$IndexX[$i]];
    }
    print $CurrentLineNF;






    $CurrentProc[0] ="AutoCurveScriptsTwoCurve";


    $i = 0;
    clear $IndexX;
    clear $FoundProc;
    clear $CurrentLineN;
    $FoundProc =RuleBasedMatchM($IndexX,$CollectAllLines, $CurrentProc);
    //print $IndexX;
    for($i=0; $i<`size($IndexX)`; $i++){
    $CurrentLineNF[$i] =$LineNumber[$IndexX[$i]];
    }
    print $CurrentLineNF;



    ////////////////  run both ONCE
    ////////////////  run both ONCE




    $Path = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
    $exampleFileName = ( $Path );

    // search AutoCurveScriptsTwoCurve	 find procs then within those procs find more procs until
    // $MasterLineN

    clear $MasterLineN;


    $CurrentLineN = $CurrentLineNF;
    $CurrentLineN = sort ($CurrentLineN);
    clear $CollectL;
    clear $CAL_temp;
    clear $LN_temp;


    $CAL_temp =$CollectAllLines;
    $LN_temp =$LineNumber;
    $IndexX = sort ($IndexX);
    $CAL_temp=RemoveStringAtIndex($CAL_temp,$IndexX);
    $LN_temp = RemoveIntAtIndex($LN_temp,$IndexX);


    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $START = 0;
    $TriggerLineFound = 0;
    clear $CurrentLineNX;
    clear $tempCollectProc;
    clear $IndexX;

    $Aint = size($CollectAllLines);
    $Bint = size($AllFoundProcs);
    $Cint = size($CAL_temp);
    $CHECK = $Aint-$Cint ;

    //int $fileId =`fopen $exampleFileName "r"`;
    //string $nextLine = `fgetline $fileId`;
    //int $eachInt = $CurrentLineN[0];
    clear $tempCollectProc;
    clear $AllFoundProcs;

    clear $WholeProc;
    $TRIGGEREND = 2;

    clear $DebugS;

    $fileId = `fopen $exampleFileName "r"`;


    while($TRIGGEREND>1){



    ///////////////////////////
    ///////////////////////////



    for($eachInt in $CurrentLineN){


    //this is the number that is the first line of a group of lines that are a proc


    $WhenZero=2;
    $CountNL = 1;
    $CountFindNL = 0;
    $START = 0;
    $TriggerLineFound=0;



    ///////////////////////////////////////////////////////////////////

    while ( !`feof $fileId` ) {


    $nextLine = `fgetline $fileId`;
    $nextLineN = match( "^[^(\r\n)]*", $nextLine );
    $nextLineR = match( ".*[^(\n)]", $nextLine );

    //FOUND LINE NUMBER
    //CHANGE HERE

    if($CurrentLineN[$CountFindNL] == $CountNL){
    print $nextLineR;
    clear $NegPosZA;
    $CountFindNL++;
    $TriggerLineFound=1;
    }



    if($TriggerLineFound==1){

    $WhenZero = BracketFindPosNeg($nextLineR, $NegPosZA);
    $START++;
    $CollectL[`size($CollectL)`]= $nextLineR;
    //$DebugS[`size($DebugS)`]= $nextLineR;



    /// WHEN PROC IS FULLY SCANNED HERE BELOW

    if(($WhenZero==0)&&($START>1)){
    clear $IndexX;
    clear $FoundProcTemp;

    $START=$TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
    // $CAL_temp IS $CollectAllLines;  MATCH NAMES//
    if(`size($CAL_temp)`==0){break;}

    $FoundProcTemp =RuleBasedMatchM($IndexX,$CAL_temp, $CollectL);
    clear $CollectL;
    // $LN_temp =$LineNumber;
    if(`size($IndexX)`>0){

    $IndexX=intArrayRemoveDuplicates($IndexX);
    if(`size($IndexX)`>0){
    $IndexX = sort($IndexX);

    for($i=0; $i<`size($IndexX)`; $i++){
    if($LN_temp[$IndexX[$i]]!=0){
    $CurrentLineNX[`size($CurrentLineNX)`] =$LN_temp[$IndexX[$i]];
    }
    }



    $CAL_temp=RemoveStringAtIndex($CAL_temp,$IndexX);
    $LN_temp = RemoveIntAtIndex($LN_temp,$IndexX);
    }
    clear $IndexX;
    /////////////

    }

    $tempCollectProc =AppendArrayZ($tempCollectProc, $FoundProcTemp);

    clear $FoundProcTemp;
    /////////////////////




    }
    }
    //LINE NUMBER
    $CountNL++;

    }

    ///////////////////////////////////////////////////////////////////

    clear $DebugS;
    //print $tempCollectProc;

    }
    frewind $fileId;

    ///////////////////////////
    ///////////////////////////




    $tempCollectProc= stringArrayRemoveDuplicates($tempCollectProc);
    AppendArrayZ($AllFoundProcs,$tempCollectProc);

    $TempStringP = "";
    $TempStringP = stringArrayToString($tempCollectProc, ", ");
    //print ($TempStringP+"\n");
    $WholeProc[`size($WholeProc)`]=$TempStringP;


    clear $tempCollectProc;

    //////////////////////

    $list = IntArrayToStringArray($CurrentLineNX);
    $list= stringArrayRemoveDuplicates($list);

    clear $CurrentLineN;
    $CurrentLineN=StringArrayToIntArray($list);
    $CurrentLineN =sort ($CurrentLineN);


    clear $CurrentLineNX;
    //////////////////////

    clear $tempCollectProc;
    //////////////////////

    if(`size($CurrentLineN)`>0){
    for($i=0; $i<`size($CurrentLineN)`; $i++){
    $MasterLineN[`size($MasterLineN)`] =$CurrentLineN[$i];
    }
    $MasterLineN=sort($MasterLineN);
    $MasterLineN=intArrayRemoveDuplicates($MasterLineN);

    }


    //print ($TempStringP+"\n");
    print $CurrentLineN[0];





    if($CurrentLineN[0]==0){
    print "STOPSTOP";
    $TRIGGEREND =0;
    break;
    }

    if(`size($CurrentLineN)`==0){
    print "STOPSTOP";
    $TRIGGEREND =0;
    break;
    }



    }

    print $WholeProc;

    fclose $fileId;

    print $MasterLineN





    proc int [] intArrayRemoveEqual(int $list[],int $listB[]){
    $index = 0;
    $i = 0;
    $S = `size($listB)`-1;
    for ($item in $list) {
    if ($listB[$i]== $item) {

    $i++;
    if($i>$S){break;}
    }else{$result[$index++] = $item;}
    }

    return $result;
    }



    print $MasterLineN[0]
    $MasterLineN=sort($MasterLineN);
    $MasterLineN=intArrayRemoveDuplicates($MasterLineN);




    /*
    print $CollectL;
    $TEMPNAMES =RuleBasedMatchM($IndexX,$CAL_temp, $DebugS);
    print $TEMPNAMES
    print $IndexX;
    clear$IndexX;
    clear$TEMPNAMES;

    $TEMPNAMES=RuleBasedMatchMM($IndexX,$CAL_temp, $DebugS);


    print $DebugS;
    size($DebugS)
    print $CollectL


    $FindN = $DebugS[22];

    $match0N = `match "([\$]+)([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
    $stringRN = `substitute "([\$]+)([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN ""`;

    print $tempCollectProc
    print $CurrentLineNX


    */











    $CurrentLineN = $CurrentLineNF;
    clear $CollectL;
    clear $CAL_temp;
    clear $LN_temp;
    $CAL_temp =$CollectAllLines;
    $LN_temp =$LineNumber;
    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $START = 0;
    $TriggerLineFound = 0;
    clear $AllFoundProcs;
    clear $FoundProcTemp;
    clear $CurrentLineNX;
    clear $tempCollectProc;

    $Aint = size($CollectAllLines);
    $Bint = size($AllFoundProcs);
    $Cint = size($CAL_temp);
    $CHECK = $Aint-$Cint ;

    //int $fileId =`fopen $exampleFileName "r"`;
    //string $nextLine = `fgetline $fileId`;
    $eachInt = $CurrentLineN[0];
    clear $tempCollectProc;
    clear $AllFoundProcs;

    clear $WholeProc;
    $TRIGGEREND = 2;

    //while($TRIGGEREND>1){

    //$eachInt=$CurrentLineN[0];

    for($eachInt in $CurrentLineN){


    //this is the number that is the first line of a group of lines that are a proc
    clear $LN_temp;
    clear $CollectL;
    clear $NegPosZA;
    clear $IndexX;
    //clear $FoundProcTemp;
    $WhenZero=2;
    $CountNL = 1;
    $CountFindNL = 0;
    $START = 0;
    $TriggerLineFound=0;

    $fileId = `fopen $exampleFileName "r"`;

    while ( !`feof $fileId` ) {



    $nextLine = `fgetline $fileId`;
    $nextLineN = match( "^[^(\r\n)]*", $nextLine );
    if($eachInt == $CountNL){
    clear $NegPosZA;
    $CountFindNL++;
    $TriggerLineFound=1;
    }

    if($TriggerLineFound==1){
    $WhenZero = BracketFindPosNeg($nextLine, $NegPosZA);
    $START++;

    $CollectL[`size($CollectL)`]= $nextLineN;

    if(($WhenZero==0)&&($START>1)){$START=$TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
    clear $IndexX;

    //clear $FoundProcTemp;
    $FoundProcTemp =RuleBasedMatchM($IndexX,$CAL_temp, $CollectL);

    //print $FoundProcTemp;

    if(`size($IndexX)`>0){
    IndexX=intArrayRemoveDuplicates(IndexX);
    $IndexX = sort($IndexX);


    for($i=0; $i<`size($IndexX)`; $i++){
    $CurrentLineNX[`size($CurrentLineNX)`] =$LN_temp[$IndexX[$i]];
    }

    $CAL_temp=RemoveStringAtIndex($CAL_temp,$IndexX);
    $LN_temp = RemoveIntAtIndex($LN_temp,$IndexX);
    clear $IndexX;
    }

    $FoundProcTemp= stringArrayRemoveDuplicates($FoundProcTemp);
    $tempCollectProc =AppendArrayZ($tempCollectProc, $FoundProcTemp);
    $tempCollectProc= stringArrayRemoveDuplicates($tempCollectProc);
    break;

    }
    }

    $CountNL++;
    }


    //print $FoundProcTemp
    //$tempCollectProc
    //print $tempCollectProc
    //$AllFoundProcs=stringArrayRemoveDuplicates($AllFoundProcs);
    frewind $fileId;
    //fclose $fileId;

    }

    AppendArrayZ($AllFoundProcs,$tempCollectProc);

    $TempStringP = "";
    $TempStringP = stringArrayToString($tempCollectProc, ", ");
    //clear $tempCollectProc;

    $list = IntArrayToStringArray($CurrentLineNX);
    $list= stringArrayRemoveDuplicates($list);

    clear $CurrentLineN;
    $CurrentLineN=StringArrayToIntArray($list);

    $CurrentLineN =sort ($CurrentLineN);
    if(`size($CurrentLineN)`>0){
    for($i=0; $i<`size($CurrentLineN)`-1; $i++){
    $MasterLineN[`size($MasterLineN)`] =$CurrentLineN[$i];
    }
    }
    //clear $tempCollectProc;
    clear $CurrentLineNX;
    // print $CurrentLineN[0];


    $WholeProc[`size($WholeProc)`]=$TempStringP;
    //clear $TempStringP;

    if(`size($CurrentLineN)`==0){
    print "STOPSTOP";
    }

    if(`size($TempStringP)`==0){
    print "STOP SEARCH FINISHED END ";
    $TRIGGEREND =0;
    //break;
    }
    if(`size($CurrentLineN)`==1){
    if($CurrentLineN[0]==0){
    print "STOPSTOP";
    $TRIGGEREND =0;
    //break;
    }
    }

    print $WholeProc;


    //}

    print $WholeProc;

    //clear $AllFoundProcs
    //size($MasterLineN);
    //size($AllFoundProcs);
    // string $shouldBEZero[];
    // $shouldBEZero= stringArrayFindDuplicates($AllFoundProcs);
    //size($CollectAllLines);
    //size($LineNumber);
    //size($CollectAllLines);
    //size($MasterLineN);
    ///// now write each proc to a single file..
    //print $MasterLineN;

    $list = IntArrayToStringArray($MasterLineN);
    $list= stringArrayRemoveDuplicates($list);
    $list=sort($list);
    if($list[0]==0){
    $list=RemoveStringAtIndex($list,{0});}
    $NewMasterLineN=StringArrayToIntArray($list);
    $NewMasterLineN=sort($NewMasterLineN);

    clear $list;
    $list= stringArrayRemoveDuplicates($AllFoundProcs);

    //size($list);
    //size($NewMasterLineN);
    //size($AllFoundProcs);
    /////////////////////////////GOT IT
    //$TempSaveLine
    //$JustNames

    clear $XIndexN;
    clear $FINDX;
    $FINDX =RuleBasedMatchM($XIndexN,$JustNames,$list);

    $SortedList=sort($XIndexN);
    clear $LINEplace;
    for($eachINT in $SortedList){
    $LINEplace[`size($LINEplace)`]=$TempSaveLine[$eachINT];
    }




    clear $foundNA;
    $foundNA= $LINEplace ;
    $foundNA=sort($foundNA);


    $Path = "C:\\Users/johnny/Documents/maya/scripts/PlaceHere.TXT";
    $PathW = "C:\\Users/johnny/Documents/maya/scripts/NEWAllStereoRelated.TXT";
    $exampleFileName = ( $Path);
    $exampleFileNameW = ( $PathW );
    //clears the file i think
    $fileIdW = `fopen $exampleFileNameW "w"`;
    fclose $fileIdW;
    clear $Xall;
    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $CountX = 0;
    $fileIdW = `fopen $exampleFileNameW "w"`;
    $fileId = `fopen $exampleFileName "r"`;
    $nextLine = "";
    $nextLineN = "";
    $TriggerLineFound = 0;
    $START = 0;
    $STARTN = 0;
    $InputLine = ("///THIS IS A DUPLICATE ///"+"\r"+"\n");

    while ( !`feof $fileId` ) {
    $nextLine = `fgetline $fileId`;


    $nextLineN =$nextLine;
    if($foundNA[$CountFindNL] == $CountNL){
    clear $NegPosZA;
    $WhenZero=2;
    print ($nextLine+"\n");
    fprint $fileIdW ("\r"+"\n");
    $CountFindNL++;
    $TriggerLineFound=1;
    }

    if($TriggerLineFound==1){
    $Xall[`size($Xall)`]=$nextLine;
    $WhenZero = BracketFindPosNeg($nextLine, $NegPosZA);
    $nextLineN=($nextLineN +"\r"+"\n");
    fprint $fileIdW $nextLineN;

    if(($WhenZero==0)&&(`size($NegPosZA)`>0)){
    $TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
    fprint $fileIdW ("\r"+"\n");
    }
    }

    $CountNL++;
    }

    fclose $fileIdW;
    fclose $fileId;











    //////////
    /////////////////////////NEW





    proc Matrix3D(){
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $xx = 1.0;
    $yy = 1.0;
    $zz = 1.0;
    }

    proc scaleMATRIX_A(float $f) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $xx *= $f;
    $xy *= $f;
    $xz *= $f;
    $xo *= $f;
    $yx *= $f;
    $yy *= $f;
    $yz *= $f;
    $yo *= $f;
    $zx *= $f;
    $zy *= $f;
    $zz *= $f;
    $zo *= $f;
    }
    proc scaleMATRIX_B(float $xf, float $yf, float $zf) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $xx *= $xf;
    $xy *= $xf;
    $xz *= $xf;
    $xo *= $xf;
    $yx *= $yf;
    $yy *= $yf;
    $yz *= $yf;
    $yo *= $yf;
    $zx *= $zf;
    $zy *= $zf;
    $zz *= $zf;
    $zo *= $zf;
    }
    proc translateMATRIX_float(float $x, float $y, float $z) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $xo += $x;
    $yo += $y;
    $zo += $z;
    }
    ///////////////////////////////////////////
    proc translateMATRIX_VEC(vector $t) {
    translateMATRIX_float((VecCom($t,0)),(VecCom($t,1)),(VecCom($t,2)));
    }

    proc yrotMATRIX(float $thetaX) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static;
    $theta=$thetaX;
    $theta *= ($PI_Static / 180.0);
    $ct = cos($theta);
    $st = sin($theta);
    $Nxx = (float) ($xx * $ct + $zx * $st);
    $Nxy = (float) ($xy * $ct + $zy * $st);
    $Nxz = (float) ($xz * $ct + $zz * $st);
    $Nxo = (float) ($xo * $ct + $zo * $st);
    $Nzx = (float) ($zx * $ct - $xx * $st);
    $Nzy = (float) ($zy * $ct - $xy * $st);
    $Nzz = (float) ($zz * $ct - $xz * $st);
    $Nzo = (float) ($zo * $ct - $xo * $st);
    $xo = $Nxo;
    $xx = $Nxx;
    $xy = $Nxy;
    $xz = $Nxz;
    $zo = $Nzo;
    $zx = $Nzx;
    $zy = $Nzy;
    $zz = $Nzz;
    }
    proc xrotMATRIX(float $thetaX) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static;
    $theta=$thetaX;
    $theta *= ($PI_Static / 180.0);
    $ct = cos($theta);
    $st = sin($theta);
    $Nyx = (float) ($yx * $ct + $zx * $st);
    $Nyy = (float) ($yy * $ct + $zy * $st);
    $Nyz = (float) ($yz * $ct + $zz * $st);
    $Nyo = (float) ($yo * $ct + $zo * $st);
    $Nzx = (float) ($zx * $ct - $yx * $st);
    $Nzy = (float) ($zy * $ct - $yy * $st);
    $Nzz = (float) ($zz * $ct - $yz * $st);
    $Nzo = (float) ($zo * $ct - $yo * $st);
    $yo = $Nyo;
    $yx = $Nyx;
    $yy = $Nyy;
    $yz = $Nyz;
    $zo = $Nzo;
    $zx = $Nzx;
    $zy = $Nzy;
    $zz = $Nzz;
    }
    proc zrotMATRIX(float $thetaX) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static;
    $theta=$thetaX;
    $theta *= ($PI_Static / 180.0);
    $ct = cos($theta);
    $st = sin($theta);
    $Nyx = (float) ($yx * $ct + $xx * $st);
    $Nyy = (float) ($yy * $ct + $xy * $st);
    $Nyz = (float) ($yz * $ct + $xz * $st);
    $Nyo = (float) ($yo * $ct + $xo * $st);
    $Nxx = (float) ($xx * $ct - $yx * $st);
    $Nxy = (float) ($xy * $ct - $yy * $st);
    $Nxz = (float) ($xz * $ct - $yz * $st);
    $Nxo = (float) ($xo * $ct - $yo * $st);
    $yo = $Nyo;
    $yx = $Nyx;
    $yy = $Nyy;
    $yz = $Nyz;
    $xo = $Nxo;
    $xx = $Nxx;
    $xy = $Nxy;
    $xz = $Nxz;
    }
    /*
    $xx $yx $zx D
    $xy $yy $zy H
    $xz $yz $zz L
    $xo $yo $zo P

    [0][0] [0][1] C D
    [1][0] [1][1] G H
    [2][0] [2][1] K L
    [3][0] [3][1] O P

    A B C D
    E F G H
    I J K L
    M N O P
    */

    proc MultMATRIX(matrix $rhs[][]) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;

    $lxx = $xx * $rhs[0][0] + $yx * $rhs[1][0] + $zx * $rhs[2][0];
    $lxy = $xy * $rhs[0][0] + $yy * $rhs[1][0] + $zy * $rhs[2][0];
    $lxz = $xz * $rhs[0][0] + $yz * $rhs[1][0] + $zz * $rhs[2][0];
    $lxo = $xo * $rhs[0][0] + $yo * $rhs[1][0] + $zo * $rhs[2][0] + $rhs[3][0];
    $lyx = $xx * $rhs[0][1] + $yx * $rhs[1][1] + $zx * $rhs[2][1];
    $lyy = $xy * $rhs[0][1] + $yy * $rhs[1][1] + $zy * $rhs[2][1];
    $lyz = $xz * $rhs[0][1] + $yz * $rhs[1][1] + $zz * $rhs[2][1];
    $lyo = $xo * $rhs[0][1] + $yo * $rhs[1][1] + $zo * $rhs[2][1] + $rhs[3][1];
    $lzx = $xx * $rhs[0][2] + $yx * $rhs[1][2] + $zx * $rhs[2][2];
    $lzy = $xy * $rhs[0][2] + $yy * $rhs[1][2] + $zy * $rhs[2][2];
    $lzz = $xz * $rhs[0][2] + $yz * $rhs[1][2] + $zz * $rhs[2][2];
    $lzo = $xo * $rhs[0][2] + $yo * $rhs[1][2] + $zo * $rhs[2][2] + $rhs[3][2];
    $xx = $lxx;
    $xy = $lxy;
    $xz = $lxz;
    $xo = $lxo;
    $yx = $lyx;
    $yy = $lyy;
    $yz = $lyz;
    $yo = $lyo;
    $zx = $lzx;
    $zy = $lzy;
    $zz = $lzz;
    $zo = $lzo;
    }

    proc transformMATRIX_A(float $v[], int $tv[], int $nvert) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
    $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
    $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
    for ($i = $nvert * 3; ($i -= 3) >= 0;) {
    $x = $v[$i];
    $y = $v[$i + 1];
    $z = $v[$i + 2];
    $tv[$i    ] = (int) ($x * $lxx + $y * $lxy + $z * $lxz + $lxo);
    $tv[$i + 1] = (int) ($x * $lyx + $y * $lyy + $z * $lyz + $lyo);
    $tv[$i + 2] = (int) ($x * $lzx + $y * $lzy + $z * $lzz + $lzo);
    }
    }
    proc transformMATRIX_B(vector $v[]) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
    $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
    $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
    for ( $i = 0; $i < `size($v)`; $i++) {
    $x = VecCom($v[$i],0);
    $y = VecCom($v[$i],1);
    $z = VecCom($v[$i],2);
    VecEqual($v[$i], 0 , ($x * $lxx + $y * $lxy + $z * $lxz + $lxo));
    VecEqual($v[$i], 0 , ($x * $lyx + $y * $lyy + $z * $lyz + $lyo));
    VecEqual($v[$i], 0 , ($x * $lzx + $y * $lzy + $z * $lzz + $lzo));
    }
    }
    proc transformMATRIX_Vec(vector $p) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
    $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
    $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
    $x = VecCom($p,0);
    $y = VecCom($p,1);
    $z = VecCom($p,2);
    VecEqual($p,0,($x * $lxx + $y * $lxy + $z * $lxz + $lxo));
    VecEqual($p,1,($x * $lyx + $y * $lyy + $z * $lyz + $lyo));
    VecEqual($p,2,($x * $lzx + $y * $lzy + $z * $lzz + $lzo));
    }
    proc string StringtoStringMATRIX() {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    return ("[" + $xx + "," + $xy + "," + $xz + "," + $xo + "\n "
    + $yx + "," + $yy + "," + $yz + "," + $yo + "\n "
    + $zx + "," + $zy + "," + $zz + "," + $zo + "]");
    }




    /*
    global matrix $matrixA_GlobalX[4][4];
    $matrixA_GlobalX  = << $xx, $yx, $zx, 0.0;
    $xy, $yy, $zy, 0.0;
    $xz, $yz, $zz, 0.0;
    $xo, $yo, $zo, 1.0 >>;
    */


    //////////New


    proc SetGMATRIX() {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $Sx, $Sy, $Sz, $So;
    $Mn[0] =$xx;
    $Mn[4] =$xy;
    $Mn[8] =$xz;
    $Mn[12] =$xo;

    $Mn[1] =$yx;
    $Mn[5] =$yy;
    $Mn[9] =$yz;
    $Mn[13]=$yo;

    $Mn[2] =$zx;
    $Mn[6] =$zy;
    $Mn[10]=$zz;
    $Mn[14]=$zo;

    $Mn[3] =$Sx;
    $Mn[7] =$Sy;
    $Mn[11]=$Sz;
    $Mn[15]=$So;
    global matrix $MatrixGlobalA[4][4];
    $MatrixGlobalA=<<$Mn[0], $Mn[1], $Mn[2], $Mn[3];
    $Mn[4], $Mn[5], $Mn[6], $Mn[7];
    $Mn[8], $Mn[9], $Mn[10], $Mn[11];
    $Mn[12], $Mn[13], $Mn[14], $Mn[15]>>;
    }

    proc UnitMATRIX() {

    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $Sx, $Sy, $Sz, $So;
    global matrix $MatrixGlobalA[4][4];
    $MatrixGlobalA=<< 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $Mn  = MatrixToFloat($MatrixGlobalA);

    $xx=$Mn[0];
    $xy=$Mn[4];
    $xz=$Mn[8];
    $xo=$Mn[12];
    $yx=$Mn[1];
    $yy=$Mn[5];
    $yz=$Mn[9];
    $yo=$Mn[13];
    $zx=$Mn[2];
    $zy=$Mn[6];
    $zz=$Mn[10];
    $zo=$Mn[14];

    $Sx=$Mn[3];
    $Sy=$Mn[7];
    $Sz=$Mn[11];
    $So=$Mn[15];

    }


    global matrix $MatrixGlobalA[4][4];
    $MatrixGlobalA =  << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;

    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static = 3.14159265;

    UnitMATRIX;
    $Mng  = MatrixToFloat($MatrixGlobalA);
    PrintMatrix($MatrixGlobalA , 4);

    UnitMATRIX;
    SetGMATRIX;
    $Mn  = MatrixToFloat($MatrixGlobalA);
    ShowMatrixAXIS($Mn);

    UnitMATRIX;
    SetGMATRIX;
    $MatrixC= $MatrixGlobalA;
    $MatrixD= $MatrixGlobalA;

    $item = `ls -sl`;
    select -r $item[0];
    $PositionsZ_A = VecCurveEps($item[0]);
    $Pts_CRV=$PositionsZ_A;
    $theta = 45;

    UnitMATRIX;
    SetGMATRIX;
    $MatrixC= $MatrixGlobalA;
    PrintMatrix($MatrixC , 4);
    $MatrixD= $MatrixGlobalA;
    $MatrixE=$MatrixGlobalA;


    for($Inx = 0; $Inx <= (360/45); $Inx++){
    //$MatrixC= $MatrixGlobalA;
    yrotMATRIX(($theta));
    SetGMATRIX;
    $MatrixD= $MatrixGlobalA;
    $Pts_CRV=MultPointMatrixArray($PositionsZ_A, $MatrixC,$MatrixD);
    $ThefirstCurve = VecArrayToCurve($Pts_CRV);
    $Mn  = MatrixToFloat($MatrixGlobalA);
    ShowMatrixAXIS($Mn);
    $MatrixE=$MatrixD;
    for($Inxi = 0; $Inxi <= (360/45); $Inxi++){
    xrotMATRIX(($theta));
    SetGMATRIX;
    $MatrixD= $MatrixGlobalA;
    $Pts_CRV=MultPointMatrixArray($Pts_CRV, $MatrixE,$MatrixD);
    $ThefirstCurve = VecArrayToCurve($Pts_CRV);
    }
    $MatrixGlobalA=$MatrixE;
    SetGMATRIX;
    }




    PrintMatrix($MatrixC , 4);
    PrintMatrix($MatrixD , 4);

    $item = `ls -sl`;
    $MatrixC= GetMatrix($item[0]);
    PrintMatrix($MatrixC , 4);

    $item = `ls -sl`;
    $MatrixD= GetMatrix($item[0]);
    PrintMatrix($MatrixD , 4);

    $item = `ls -sl`;
    $MatrixE= GetMatrix($item[0]);
    PrintMatrix($MatrixE , 4);

    PrintMatrix($MatrixC , 4);
    PrintMatrix($MatrixD , 4);
    PrintMatrix($MatrixE , 4);









    proc matrix GetMatrix(string $object){
    $attr = $object +".matrix";
    $v = `getAttr $attr`;
    matrix $mat[4][4]= `FloatToMatrix($v)`;
    return $mat;
    }

    proc  PrintMatrix(matrix $MatriXM[][] , int $MatrixN){

    $MatrixNi = $MatrixN-1;
    $FLoatMatrixA = MatrixToFloat($MatriXM);
    $FLoatMatrixA = MakeCleanFloatsZ($FLoatMatrixA);
    $stringFloat = FloatArrayToStringArray($FLoatMatrixA);
    clear $BytNum;
    for ($eachFloatz in $stringFloat){
    $BytNum[`size($BytNum)`] = (`sizeBytes $eachFloatz`)+2;
    }
    $BytNumSort = $BytNum;
    $BytNumSort = `sort $BytNumSort`;
    $BytNumLarg = $BytNumSort[`size($BytNumSort)`-1];
    $BytNumSmall = $BytNumSort[0];
    clear $BytNumDiff;
    for ($eachBytNum in $BytNum){
    $BytNumDiff[`size($BytNumDiff)`] = (`abs ($eachBytNum - $BytNumLarg)`)+2;
    }

    $IndXeF = 0;
    $IndXeFi = 0;
    $Syb = " ";
    $printcommand = "";
    for ($eachItemF in $stringFloat){
    $AddedSPaces = AddItemString($BytNumDiff[$IndXeF], $Syb);
    if($IndXeFi==$MatrixNi){ $printcommand += $AddedSPaces + $eachItemF + "|"+ "\n" ;
    $IndXeFi= -1; }else{ if($IndXeFi==0){$printcommand += "|"+$AddedSPaces + $eachItemF;}else{ $printcommand += $AddedSPaces + $eachItemF;}}
    $IndXeFi++;
    $IndXeF++;
    }
    print $printcommand;
    }

    proc float[] MatrixToFloat(matrix $FourByFour_matrix[][]){
    $FLOATindex = 0;
    $Inx = 0;
    $Inxb = 0;
    for($Inx = 0; $Inx <= 3; $Inx++){
    for($Inxb = 0; $Inxb <= 3; $Inxb++){
    $matrixFloat[$FLOATindex] = $FourByFour_matrix[$Inx][$Inxb];
    $FLOATindex++;
    }
    }
    return $matrixFloat;
    }

    proc string makeCurvePointDirectionLength(float $Length, float $Direction[], float $posA[]){
    $MultDir = multiplyFloat($Length,  $Direction);
    $FloatDirectionNormalA = AddFloats($posA, $MultDir);
    $CurveBetween = curve2points($posA,  $FloatDirectionNormalA);
    return $CurveBetween;
    }

    proc ShowMatrixAXIS(float $Mn[]){
    $curveAxisS[0]= makeCurvePointDirectionLength((6), <<$Mn[0], $Mn[1], $Mn[2]>>, <<$Mn[12], $Mn[13], $Mn[14]>>); //
    $curveAxisS[1]= makeCurvePointDirectionLength((6), <<$Mn[4], $Mn[5], $Mn[6]>>, <<$Mn[12], $Mn[13], $Mn[14]>>); //
    $curveAxisS[2]= makeCurvePointDirectionLength((6), <<$Mn[8], $Mn[9], $Mn[10]>>, <<$Mn[12], $Mn[13], $Mn[14]>>); //
    SetItemColorString ($curveAxisS[0], 13);
    SetItemColorString ($curveAxisS[1], 14);
    SetItemColorString ($curveAxisS[2], 6);
    select -cl  ;
    }

    ///////////////////////////NEW
    /*

    ///////////OLD
    proc UnitMATRIX() {

    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $tx, $ty, $tz, $to;
    global matrix $MatrixGlobalA[4][4];
    $MatrixGlobalA=<< 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $Mn  = MatrixToFloat($MatrixGlobalA);
    $xx =$Mn[0];
    $xy =$Mn[1];
    $xz =$Mn[2];
    $xo =$Mn[3];
    $yx =$Mn[4];
    $yy =$Mn[5];
    $yz =$Mn[6];
    $yo =$Mn[7];
    $zx =$Mn[8];
    $zy =$Mn[9];
    $zz =$Mn[10];
    $zo =$Mn[11];
    $tx =$Mn[12];
    $ty =$Mn[13];
    $tz =$Mn[14];
    $to =$Mn[15];
    }

    proc SetGMATRIX() {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $tx, $ty, $tz, $to;
    $Mn[0]=$xx;
    $Mn[1]=$xy;
    $Mn[2]=$xz;
    $Mn[3]=$xo;
    $Mn[4]=$yx;
    $Mn[5]=$yy;
    $Mn[6]=$yz;
    $Mn[7]=$yo;
    $Mn[8]=$zx;
    $Mn[9]=$zy;
    $Mn[10]=$zz;
    $Mn[11]=$zo;
    $Mn[12]=$tx;
    $Mn[13]=$ty;
    $Mn[14]=$tz;
    $Mn[15]=$to;
    global matrix $MatrixGlobalA[4][4];
    $MatrixGlobalA=<<$Mn[0], $Mn[1], $Mn[2], $Mn[3];
    $Mn[4], $Mn[5], $Mn[6], $Mn[7];
    $Mn[8], $Mn[9], $Mn[10], $Mn[11];
    $Mn[12], $Mn[13], $Mn[14], $Mn[15]>>;
    }


    ////////////////////////////////////////

    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static = 3.14159265;

    proc Matrix3D(){
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $xx = 1.0;
    $yy = 1.0;
    $zz = 1.0;
    }

    proc scaleMATRIX_A(float $f) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $xx *= $f;
    $xy *= $f;
    $xz *= $f;
    $xo *= $f;
    $yx *= $f;
    $yy *= $f;
    $yz *= $f;
    $yo *= $f;
    $zx *= $f;
    $zy *= $f;
    $zz *= $f;
    $zo *= $f;
    }
    proc scaleMATRIX_B(float $xf, float $yf, float $zf) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $xx *= $xf;
    $xy *= $xf;
    $xz *= $xf;
    $xo *= $xf;
    $yx *= $yf;
    $yy *= $yf;
    $yz *= $yf;
    $yo *= $yf;
    $zx *= $zf;
    $zy *= $zf;
    $zz *= $zf;
    $zo *= $zf;
    }
    proc translateMATRIX_float(float $x, float $y, float $z) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $xo += $x;
    $yo += $y;
    $zo += $z;
    }
    ///////////////////////////////////////////
    proc translateMATRIX_VEC(vector $t) {
    translateMATRIX_float((VecCom($t,0)),(VecCom($t,1)),(VecCom($t,2)));
    }

    proc yrotMATRIX(float $theta) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static;

    $theta *= ($PI_Static / 180.0);
    $ct = cos($theta);
    $st = sin($theta);
    $Nxx = (float) ($xx * $ct + $zx * $st);
    $Nxy = (float) ($xy * $ct + $zy * $st);
    $Nxz = (float) ($xz * $ct + $zz * $st);
    $Nxo = (float) ($xo * $ct + $zo * $st);
    $Nzx = (float) ($zx * $ct - $xx * $st);
    $Nzy = (float) ($zy * $ct - $xy * $st);
    $Nzz = (float) ($zz * $ct - $xz * $st);
    $Nzo = (float) ($zo * $ct - $xo * $st);
    $xo = $Nxo;
    $xx = $Nxx;
    $xy = $Nxy;
    $xz = $Nxz;
    $zo = $Nzo;
    $zx = $Nzx;
    $zy = $Nzy;
    $zz = $Nzz;
    }
    proc xrotMATRIX(float $theta) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static;
    $theta *= ($PI_Static / 180.0);
    $ct = cos($theta);
    $st = sin($theta);
    $Nyx = (float) ($yx * $ct + $zx * $st);
    $Nyy = (float) ($yy * $ct + $zy * $st);
    $Nyz = (float) ($yz * $ct + $zz * $st);
    $Nyo = (float) ($yo * $ct + $zo * $st);
    $Nzx = (float) ($zx * $ct - $yx * $st);
    $Nzy = (float) ($zy * $ct - $yy * $st);
    $Nzz = (float) ($zz * $ct - $yz * $st);
    $Nzo = (float) ($zo * $ct - $yo * $st);
    $yo = $Nyo;
    $yx = $Nyx;
    $yy = $Nyy;
    $yz = $Nyz;
    $zo = $Nzo;
    $zx = $Nzx;
    $zy = $Nzy;
    $zz = $Nzz;
    }
    proc zrotMATRIX(float $theta) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static;
    $theta *= ($PI_Static / 180.0);
    $ct = cos($theta);
    $st = sin($theta);
    $Nyx = (float) ($yx * $ct + $xx * $st);
    $Nyy = (float) ($yy * $ct + $xy * $st);
    $Nyz = (float) ($yz * $ct + $xz * $st);
    $Nyo = (float) ($yo * $ct + $xo * $st);
    $Nxx = (float) ($xx * $ct - $yx * $st);
    $Nxy = (float) ($xy * $ct - $yy * $st);
    $Nxz = (float) ($xz * $ct - $yz * $st);
    $Nxo = (float) ($xo * $ct - $yo * $st);
    $yo = $Nyo;
    $yx = $Nyx;
    $yy = $Nyy;
    $yz = $Nyz;
    $xo = $Nxo;
    $xx = $Nxx;
    $xy = $Nxy;
    $xz = $Nxz;
    }
    /*
    $xx $yx $zx D
    $xy $yy $zy H
    $xz $yz $zz L
    $xo $yo $zo P

    [0][0] [0][1] C D
    [1][0] [1][1] G H
    [2][0] [2][1] K L
    [3][0] [3][1] O P

    A B C D
    E F G H
    I J K L
    M N O P
    */

    proc MultMATRIX(matrix $rhs[][]) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;

    $lxx = $xx * $rhs[0][0] + $yx * $rhs[1][0] + $zx * $rhs[2][0];
    $lxy = $xy * $rhs[0][0] + $yy * $rhs[1][0] + $zy * $rhs[2][0];
    $lxz = $xz * $rhs[0][0] + $yz * $rhs[1][0] + $zz * $rhs[2][0];
    $lxo = $xo * $rhs[0][0] + $yo * $rhs[1][0] + $zo * $rhs[2][0] + $rhs[3][0];
    $lyx = $xx * $rhs[0][1] + $yx * $rhs[1][1] + $zx * $rhs[2][1];
    $lyy = $xy * $rhs[0][1] + $yy * $rhs[1][1] + $zy * $rhs[2][1];
    $lyz = $xz * $rhs[0][1] + $yz * $rhs[1][1] + $zz * $rhs[2][1];
    $lyo = $xo * $rhs[0][1] + $yo * $rhs[1][1] + $zo * $rhs[2][1] + $rhs[3][1];
    $lzx = $xx * $rhs[0][2] + $yx * $rhs[1][2] + $zx * $rhs[2][2];
    $lzy = $xy * $rhs[0][2] + $yy * $rhs[1][2] + $zy * $rhs[2][2];
    $lzz = $xz * $rhs[0][2] + $yz * $rhs[1][2] + $zz * $rhs[2][2];
    $lzo = $xo * $rhs[0][2] + $yo * $rhs[1][2] + $zo * $rhs[2][2] + $rhs[3][2];
    $xx = $lxx;
    $xy = $lxy;
    $xz = $lxz;
    $xo = $lxo;
    $yx = $lyx;
    $yy = $lyy;
    $yz = $lyz;
    $yo = $lyo;
    $zx = $lzx;
    $zy = $lzy;
    $zz = $lzz;
    $zo = $lzo;
    }
    proc UnitMATRIX() {

    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;

    $xo = 0;
    $xx = 1;
    $xy = 0;
    $xz = 0;
    $yo = 0;
    $yx = 0;
    $yy = 1;
    $yz = 0;
    $zo = 0;
    $zx = 0;
    $zy = 0;
    $zz = 1;
    }
    proc transformMATRIX_A(float $v[], int $tv[], int $nvert) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
    $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
    $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
    for ($i = $nvert * 3; ($i -= 3) >= 0;) {
    $x = $v[$i];
    $y = $v[$i + 1];
    $z = $v[$i + 2];
    $tv[$i    ] = (int) ($x * $lxx + $y * $lxy + $z * $lxz + $lxo);
    $tv[$i + 1] = (int) ($x * $lyx + $y * $lyy + $z * $lyz + $lyo);
    $tv[$i + 2] = (int) ($x * $lzx + $y * $lzy + $z * $lzz + $lzo);
    }
    }
    proc transformMATRIX_B(vector $v[]) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
    $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
    $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
    for ( $i = 0; $i < `size($v)`; $i++) {
    $x = VecCom($v[$i],0);
    $y = VecCom($v[$i],1);
    $z = VecCom($v[$i],2);
    VecEqual($v[$i], 0 , ($x * $lxx + $y * $lxy + $z * $lxz + $lxo));
    VecEqual($v[$i], 0 , ($x * $lyx + $y * $lyy + $z * $lyz + $lyo));
    VecEqual($v[$i], 0 , ($x * $lzx + $y * $lzy + $z * $lzz + $lzo));
    }
    }
    proc transformMATRIX_Vec(vector $p) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
    $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
    $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
    $x = VecCom($p,0);
    $y = VecCom($p,1);
    $z = VecCom($p,2);
    VecEqual($p,0,($x * $lxx + $y * $lxy + $z * $lxz + $lxo));
    VecEqual($p,1,($x * $lyx + $y * $lyy + $z * $lyz + $lyo));
    VecEqual($p,2,($x * $lzx + $y * $lzy + $z * $lzz + $lzo));
    }
    proc string StringtoStringMATRIX() {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    return ("[" + $xx + "," + $xy + "," + $xz + "," + $xo + "\n "
    + $yx + "," + $yy + "," + $yz + "," + $yo + "\n "
    + $zx + "," + $zy + "," + $zz + "," + $zo + "]");
    }



    UnitMATRIX;
    global matrix $matrixA_GlobalX[4][4];
    $matrixA_GlobalX  = << $xx, $yx, $zx, 0.0;
    $xy, $yy, $zy, 0.0;
    $xz, $yz, $zz, 0.0;
    $xo, $yo, $zo, 1.0 >>;
    */
    ///////////////////

    /*

    $selItemzCi = `ls-sl`;
    $PtsVecAi = PointArrayT($selItemzCi);

    $MatrixNewB = GetMatrix($selItemz[1]);
    $MtxF  = MatrixToFloat($MatrixNewB);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};



    print $MatrixNewB;
    $MatrixNewC = GetMatrix($selItemz[2]);

    $NewAXis = MultPointMatrixPlusRel( $PtsVecAi[1], $MatrixNewB,$MatrixNewC);
    Loc $NewAXis;
    */

    proc vector MultPointMatrixPlusRel( vector $PtsVec, matrix $mIA[][],matrix $mIB[][]){
    /*
    Given an input vector (a, b, c) and an input matrix:
    A B C D
    E F G H
    I J K L
    M N O P
    Then Vector Matrix Product is defined as follows:
    x = (a*A) - (b*B) - (c*C)
    y = (a*E) - (b*F) - (c*G)
    z = (a*I) - (b*J) - (c*K)
    And the Point Matrix Product is defined as follows:
    x = (a*A) - (b*B) - (c*C) - D
    y = (a*E) - (b*F) - (c*G) - H
    z = (a*I) - (b*J) - (c*K) - L
    */


    $MtxF  = MatrixToFloat($mIA);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};

    $Pts = $PtsVec;


    // cent of matrix
    $AxisO = $Tran = << $mIA[3][0], $mIA[3][1], $mIA[3][2]>>;
    ////////////////////////////////////////

    $MtxFB  = MatrixToFloat($mIB);
    $RowAi = {$MtxFB[0], $MtxFB[1], $MtxFB[2]};
    $RowBi = {$MtxFB[4], $MtxFB[5], $MtxFB[6]};
    $RowCi = {$MtxFB[8], $MtxFB[9], $MtxFB[10]};

    ////////////////////////////////////////

    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]))*$MtxFB[15];
    $PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]))*$MtxFB[15];
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]))*$MtxFB[15];

    ////////////////////////////////////// YOU GOT IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



    $PtZT[0] = (($RowAi[0])*($PtZ[0])) + (($RowBi[0])*$PtZ[1]) + (($RowCi[0])*$PtZ[2])+$MtxF[3];
    $PtZT[1] = (($RowAi[1])*($PtZ[0])) + (($RowBi[1])*$PtZ[1]) + (($RowCi[1])*$PtZ[2])+$MtxF[7];
    $PtZT[2] = (($RowAi[2])*($PtZ[0])) + (($RowBi[2])*$PtZ[1]) + (($RowCi[2])*$PtZ[2])+$MtxF[11];


    $ReturnValVec = << $PtZT[0], $PtZT[1], $PtZT[2]>>;
    $TranB = << $mIB[3][0], $mIB[3][1], $mIB[3][2]>>;
    $ReturnValVec += $TranB;

    return $ReturnValVec;
    }


    proc vector [] MultPointMatrixArray( vector $Vec_Array[], matrix $mIA[][],matrix $mIB[][]){
    /*
    Given an input vector (a, b, c) and an input matrix:
    A B C D
    E F G H
    I J K L
    M N O P
    Then Vector Matrix Product is defined as follows:
    x = (a*A) - (b*B) - (c*C)
    y = (a*E) - (b*F) - (c*G)
    z = (a*I) - (b*J) - (c*K)
    And the Point Matrix Product is defined as follows:
    x = (a*A) - (b*B) - (c*C) - D
    y = (a*E) - (b*F) - (c*G) - H
    z = (a*I) - (b*J) - (c*K) - L
    */


    $MtxF  = MatrixToFloat($mIA);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};

    // cent of matrix
    $AxisO = $Tran = << $mIA[3][0], $mIA[3][1], $mIA[3][2]>>;
    ////////////////////////////////////////

    $MtxFB  = MatrixToFloat($mIB);
    $RowAi = {$MtxFB[0], $MtxFB[1], $MtxFB[2]};
    $RowBi = {$MtxFB[4], $MtxFB[5], $MtxFB[6]};
    $RowCi = {$MtxFB[8], $MtxFB[9], $MtxFB[10]};
    for ( $ii = 0; $ii < (`size($Vec_Array)` ); $ii++ ){
    $Pts = $Vec_Array[$ii];
    ////////////////////////////////////////
    $PtZ[0] = (($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    $PtZ[1] = (($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    $PtZ[2] = (($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    ////////////////////////////////////// YOU GOT IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    $PtZT[0] = (($RowAi[0])*($PtZ[0])) + (($RowBi[0])*$PtZ[1]) + (($RowCi[0])*$PtZ[2])+$MtxF[3];
    $PtZT[1] = (($RowAi[1])*($PtZ[0])) + (($RowBi[1])*$PtZ[1]) + (($RowCi[1])*$PtZ[2])+$MtxF[7];
    $PtZT[2] = (($RowAi[2])*($PtZ[0])) + (($RowBi[2])*$PtZ[1]) + (($RowCi[2])*$PtZ[2])+$MtxF[11];
    $ReturnValVec = << $PtZT[0], $PtZT[1], $PtZT[2]>>;
    $TranB = << $mIB[3][0], $mIB[3][1], $mIB[3][2]>>;
    $ReturnValVec += $TranB;
    $newVecs[$ii]=$ReturnValVec;
    }
    return $newVecs;
    }


    ///////////////////////////////////////////////////////////////////////////


    proc matrix FloatToMatrixThree(vector $vi[]){
    $v = $vi[0]; float $vb[]= $vi[1]; float $vc[]= $vi[2];
    matrix $mat[3][3]=<<$v[0], $v[1], $v[2];
    $vb[0], $vb[1], $vb[2];
    $vc[0], $vc[1], $vc[2]>>;
    return $mat;
    }

    proc matrix SetRotationVectorsMatrix(matrix $mAtRiX[][], float $MfloatRot[]){
    $MatrizFloatiA = MatrixToFloat($mAtRiX);
    $MatrizFloatiA[0]=$MfloatRot[0];
    $MatrizFloatiA[1]=$MfloatRot[1];
    $MatrizFloatiA[2]=$MfloatRot[2];
    $MatrizFloatiA[4]=$MfloatRot[3];
    $MatrizFloatiA[5]=$MfloatRot[4];
    $MatrizFloatiA[6]=$MfloatRot[5];
    $MatrizFloatiA[8]=$MfloatRot[6];
    $MatrizFloatiA[9]=$MfloatRot[7];
    $MatrizFloatiA[10]=$MfloatRot[8];
    $newRotM = FloatToMatrix($MatrizFloatiA);
    return $newRotM;
    }

    proc float[] MatrixToFloatNN(matrix $FourByFour_matrix[][], int $N){
    $FLOATindex = 0;
    $Inx = 0;
    $Inxb = 0;
    for($Inx = 0; $Inx <= $N; $Inx++){
    for($Inxb = 0; $Inxb <= $N; $Inxb++){
    $matrixFloat[$FLOATindex] = $FourByFour_matrix[$Inx][$Inxb];
    $FLOATindex++;
    }
    }
    return $matrixFloat;
    }

    proc matrix MatrixToFloatN(vector $Vec_matrix[]){

    //eval("\matrix $N_matrix["+$X+"\]["+$X+"\]");
    $FLOATindex = 0;
    $Inx = 0;
    $Inxb = 0;
    $Xi = 3-1;
    for($Inx = 0; $Inx <= $Xi; $Inx++){
    for($Inxb = 0; $Inxb <= $Xi; $Inxb++){
    $N_matrix[$Inx][$Inxb]=$Vec_matrix[$FLOATindex];
    $FLOATindex++;
    }
    }
    return $N_matrix;
    }



    $CurveItemZ = `ls -sl`;
    PointCurvesToPlaneCurve($CurveItemZ);

    $LocZ_Pts = `ls -sl`;
    $VPos_MC = PointArrayT(`ls -sl`);
    $PlaneLocZ = VecPointsToCameraPlane($VPos_MC);
    for($EachVec in  $PlaneLocZ){
    $planeLocs[`size($planeLocs)`] = `Loc $EachVec`;

    }

    $CurveItemZ = `ls -sl`;
    PointCurvesToPlaneCurveB($CurveItemZ);

    //select cam and points



    $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM`;
    $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM`;



    ////////////////////////////////////////////////////////START


    $PtsVecA = PointArrayT(`ls -sl`);

    $PtsVecAX = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[1], $PtsVecA[2], $PtsVecA[3]));
    //Loc $PtsVecAX;
    $PtsVecAY = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[3], $PtsVecA[1], $PtsVecA[2]));
    //Loc $PtsVecAY;
    $PtsVecCross = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[2], $PtsVecA[1], $PtsVecA[3]));
    //Loc $PtsVecCross;
    $Xcross = $PtsVecCross;
    Loc $Xcross;
    $XcrossP = {$Xcross[0],$Xcross[1],1.0};
    $Normal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);



    $DirLineCamXepip = DirectionFN( $PtsVecAX,$Cam_Trans);
    $Nvec = ($DirLineCamXepip*2.0)+$PtsVecAX;
    Loc $Nvec;
    $Line[0]=$Nvec;
    $Line[1]=$DirLineCamXepip;
    $PtsM_A = VecPointsMirrorVecPlaneN($PtsVecA,$Line);
    $CamM_B = VecPointsMirrorVecPlaneN({$Cam_Trans},$Line);


    $SQuarePts[0] = FloatToVec (lineIntersectionF($Cam_Trans, $PtsVecA[0], $CamM_B[0], $PtsM_A[1]));
    $SQuarePts[1] = FloatToVec (lineIntersectionF($Cam_Trans, $PtsVecA[1], $CamM_B[0], $PtsM_A[0]));
    $SQuarePts[2] = FloatToVec (lineIntersectionF($Cam_Trans, $PtsVecA[2], $CamM_B[0], $PtsM_A[3]));
    $SQuarePts[3] = FloatToVec (lineIntersectionF($Cam_Trans, $PtsVecA[3], $CamM_B[0], $PtsM_A[2]));
    $pointMakeS[0] = ClosestPoint2LineVec(DirectionFN($SQuarePts[2],$SQuarePts[3]), $SQuarePts[2], $SQuarePts[0]);
    $pointMakeS[1] = ClosestPoint2LineVec(DirectionFN($SQuarePts[2],$SQuarePts[3]), $SQuarePts[2], $SQuarePts[1]);
    Loc  $pointMakeS[0];
    Loc  $pointMakeS[1];
    Loc $SQuarePts[1];

    $DirNorA = Normal3Points($SQuarePts[0],  $pointMakeS[0], $pointMakeS[1]);
    $PtsFCrossBB = (lineIntersectionF($SQuarePts[0], $pointMakeS[1], $SQuarePts[1], $pointMakeS[0]));

    //PositiveDirectionLine

    Loc $PtsVecCrossBB;

    $Yaxis = PositiveDirectionLine($SQuarePts[1],$pointMakeS[1]);
    $Xaxis = crossProduct( $Yaxis, $DirNorA, 0, 0 );

    $NormZ = $DirNorA ;
    $DirVector[0]= << $Xaxis[0], $Xaxis[1], $Xaxis[2]>>;
    $DirVector[1]= << $Yaxis[0], $Yaxis[1], $Yaxis[2]>>;
    $DirVector[2]= << $NormZ[0], $NormZ[1], $NormZ[2]>>;

    $matrixIMAGE  = << $Xaxis[0], $Xaxis[1], $Xaxis[2], 0.0;
    $Yaxis[0], $Yaxis[1], $Yaxis[2], 0.0;
    $NormZ[0], $NormZ[1], $NormZ[2], 0.0;
    $PtsFCrossBB[0], $PtsFCrossBB[0], $PtsFCrossBB[0], 1.0 >>;





    MakeMatrixAxis($DirVector,FloatToVec($PtsFCrossBB));

    matrix $mIA[4][4] = $matrixIMAGE;
    $PtsVec = $Cam_Trans;
    matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    matrix $mIB[4][4] = $mI;

    $PtsVecTemp = PointArrayT(`ls -sl`);

    for($eachVec in $PtsVecTemp){
    $CrvN[`size($CrvN)`] = MultPointMatrixPlusRel( $eachVec, $matrixIMAGE ,$mI);
    }
    $ThefirstCurve = VecArrayToCurve($CrvN);



    proc vector MultPointMatrixPlusRel( vector $PtsVec, matrix $mIA[][],matrix $mIB[][]){


    $MtxF  = MatrixToFloat($mIA);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};

    $Pts = $PtsVec;

    // cent of matrix
    $AxisO = $Tran = << $mIA[3][0], $mIA[3][1], $mIA[3][2]>>;
    ////////////////////////////////////////

    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));

    //Loc $PtZ;

    ////////////////////////////////////// YOU GOT IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    $MtxFB  = MatrixToFloat($mIB);
    $RowAi = {$MtxFB[0], $MtxFB[1], $MtxFB[2]};
    $RowBi = {$MtxFB[4], $MtxFB[5], $MtxFB[6]};
    $RowCi = {$MtxFB[8], $MtxFB[9], $MtxFB[10]};

    $PtZT[0] = (($RowAi[0])*($PtZ[0])) + (($RowBi[0])*$PtZ[1]) + (($RowCi[0])*$PtZ[2])+$MtxF[3];
    $PtZT[1] = (($RowAi[1])*($PtZ[0])) + (($RowBi[1])*$PtZ[1]) + (($RowCi[1])*$PtZ[2])+$MtxF[7];
    $PtZT[2] = (($RowAi[2])*($PtZ[0])) + (($RowBi[2])*$PtZ[1]) + (($RowCi[2])*$PtZ[2])+$MtxF[11];

    $ReturnValVec = << $PtZT[0], $PtZT[1], $PtZT[2]>>;
    $TranB = << $mIB[3][0], $mIB[3][1], $mIB[3][2]>>;
    $ReturnValVec += $TranB;

    //Loc $PtZT;

    return $ReturnValVec;
    }






    proc MakeMatrixAxis(vector $DirectionVector[],vector $MidPt){
    $norm = $DirectionVector[0];
    $bi = $DirectionVector[1];
    $tan = $DirectionVector[2];

    // "Xn", "X", "Y", "Yn", "Zn", "Z"

    $colori[`size($colori)`] = 13;
    $colori[`size($colori)`] = 14;
    $colori[`size($colori)`] = 6;

    $curveAxis = "";
    $curveAxis += makeCurvePointDirectionLength((6), $norm, $MidPt); //
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[0]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    $curveAxis += makeCurvePointDirectionLength((6), $bi, $MidPt); //
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[1]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    $curveAxis += makeCurvePointDirectionLength((6), $tan, $MidPt); //
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[2]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    }




    proc float VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){
    $p = $VecN[0];
    $n1 = $VecN[1];
    $F = $n1;
    $e = $V;
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    return $D1;
    }

    $CRV_Item = `ls -sl`;
    $AllLocPositionsZi = VecCurveCvs( $CRV_Item[0]);

    $AXIS_XZY[0]=<<0,0,1>>;
    $AXIS_XZY[1]=<<1,0,0>>;

    $COUNT = 0;
    clear $Find;
    clear $AllF;
    for($EachV in $AllLocPositionsZi){

    $AllF[$COUNT]=VecPointsMirrorVecPlaneN({$EachV},$AXIS_XZY);
    //print ($AllF[$COUNT]+"\n");
    if($AllF[$COUNT]<0.25){
    //print ("  #######HERE###### "+"\n");
    $Find[`size($Find)`]=$COUNT;
    }

    $COUNT++;
    }

    for($EachINT in $Find){
    Loc ($AllLocPositionsZi[$EachINT]);
    }



    proc float VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){
    $p = $VecN[0];
    $n1 = $VecN[1];
    $F = $n1;
    $e = $V[0];
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    return $D1;
    }





    proc vector [] VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){
    $p = $VecN[0];
    $n1 = $VecN[1];
    $F = $n1;
    $C1=0;
    for($e in $V){
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    print $D1;
    $F4 = $e+(($D1*2.0)*$F3);
    $O[$C1] = $F4;
    $C1++;
    }
    VecArrayToCurveB($O);
    ResetTransEachSL;

    return $O;
    }

    $AXIS_XZY[0]=<<0,0,0>>;
    $AXIS_XZY[1]=<<1,0,0>>;
    $MMVEC = VecPointsMirrorVecPlaneN($PtsVec,$AXIS_XZY);
    Loc $MMVEC[0];
    $CURVE[0]= curve2points( $MMVEC[0], $PtsVec[0]);

    print $PtsVec;





    $PtsVec = PointArrayT(`ls -sl`);

    $AXIS_XZY[0]=<<1,0,0>>;
    $AXIS_XZY[1]=<<0,1,0>>;
    $AXIS_XZY[2]=<<0,0,1>>;

    PointDistance_Plane( $PtsVec[0], $AXIS_XZY,<<1,0,9>>);


    proc float PointDistance_Plane( vector $Vec_Array, vector $AXIS_XZY[],vector $midpoint){

    $RowA = $AXIS_XZY[0];
    $RowB = $AXIS_XZY[1];
    $RowC = $AXIS_XZY[2];
    // cent of matrix
    $AxisO = $Tran = $midpoint;
    ////////////////////////////////////////
    $Pts = $Vec_Array;
    ////////////////////////////////////////
    $PtZ[0] = (($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2])));
    $PtZ[1] = (($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2])));
    $PtZ[2] = (($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2])));

    $PlaneP = <<$PtZ[0],$PtZ[1],$PtZ[2]>>;
    $DISTANCE = distance2Pts($Vec_Array, $PlaneP);

    $CURVE[0]= curve2points($Vec_Array, $PlaneP);
    $ARCL = `arclen $CURVE[0] `;
    print $ARCL;

    return  $DISTANCE;
    }





    $DirLineN = << 0.0, 0.0 , 1.0 >>;
    $DirLineX = << 1.0, 0.0 , 0.0 >>;
    $DirLineY = << 0.0, 1.0 , 0.0 >>;


    $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM`;
    $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM`;

    $DirLineCamTOx = DirectionFN($XcrossP,$PtsVecAX);
    $DirLineCamTOy = DirectionFN($XcrossP,$PtsVecAY);

    //vector $DirLineCamTOx = DirectionFN($PtsVecAX, $Cam_Trans);
    //vector $DirLineCamTOy = DirectionFN($PtsVecAY, $Cam_Trans);


    $AngleA = `angle $DirLineX $DirLineCamTOx`;
    $AngleADegreeX = `rad_to_deg $AngleA`;

    $AngleB = `angle $DirLineN $DirLineCamTOy`;
    $AngleADegreeY = (`rad_to_deg $AngleB`-90.0);

    // Result: 45 //
    // Result: -33.778758 //








    $PtsVecA = PointArrayT(`ls -sl`);

    $PtsVecAX = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[1], $PtsVecA[2], $PtsVecA[3]));
    //Loc $PtsVecAX;
    $PtsVecAY = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[3], $PtsVecA[1], $PtsVecA[2]));
    //Loc $PtsVecAY;
    $PtsVecCross = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[2], $PtsVecA[1], $PtsVecA[3]));
    Loc $PtsVecCross;
    $Xcross = $PtsVecCross;
    $XcrossP = {$Xcross[0],$Xcross[1],1.0};
    $Normal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM1", 0);

    $DirLineN = << 0.0, 0.0 , 1.0 >>;
    $DirLineX = << 1.0, 0.0 , 0.0 >>;
    $DirLineY = << 0.0, 1.0 , 0.0 >>;



    $DirLineCamTOx = DirectionFN($Xcross,$PtsVecAX);
    $DirLineCamTOy = DirectionFN($Xcross,$PtsVecAY);

    //vector $DirLineCamTOx = DirectionFN($PtsVecAX, $Cam_Trans);
    //vector $DirLineCamTOy = DirectionFN($PtsVecAY, $Cam_Trans);


    $AngleA = `angle $DirLineX $DirLineCamTOx`;
    $AngleADegreeX = `rad_to_deg $AngleA`;

    $AngleB = `angle $DirLineN $DirLineCamTOy`;
    $AngleADegreeY = (`rad_to_deg $AngleB`-90.0);

    $FOUNDZ = 135.000001 -45.0;



    $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM1`;
    $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM1`;


    /*


    $DirLineCamTOy = DirectionFN($PtsVecAY, $Cam_Trans);
    // Result: <<5.16314e-010, -0.831191, -0.555988>>  //
    $AngleA = `angle $DirLineX $DirLineCamTOx`;
    $AngleADegreeX = `rad_to_deg $AngleA`;
    // Result: 135.000001 //
    $AngleB = `angle $DirLineN $DirLineCamTOy`;
    $AngleADegreeY = (`rad_to_deg $AngleB`-90.0);
    // Result: 33.77876 //
    $FOUNDZ = 135.000001 -45.0;
    // Result: 90.000001 //

    */










    setAttr "ZCURVEModelingCAM.rotate" $AngleADegreeY $AngleADegreeX 0;

    print $AngleADegreeX $AngleADegreeX



    $CamMatrixX = GetMatrix("ZCURVEModelingCAM");
    // Result: << 0.372095 0 -0.928195 0;  -0.492072 0.847911 -0.197262 0;  0.787026 0.530139 0.315504 0;  0 0 1 1 >> //


    $CamMfloatZ[0] = $CamMatrixX[0][0];
    $CamMfloatZ[1] = $CamMatrixX[0][1];
    $CamMfloatZ[2] = $CamMatrixX[0][2];

    $PtsVecAX = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[1], $PtsVecA[2], $PtsVecA[3]));
    Loc $PtsVecAX;
    $PtsVecAY = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[3], $PtsVecA[1], $PtsVecA[2]));
    Loc $PtsVecAY;
    $PtsVecCross = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[2], $PtsVecA[1], $PtsVecA[3]));
    Loc $PtsVecCross;
    $Xcross = $PtsVecCross;
    $XcrossP = {$Xcross[0],$Xcross[1],1.0};
    $Normal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);

    $DirLineCamTOx = DirectionFN($XcrossP,$PtsVecAX);

    $DirLineN = << 0.0, 0.0 , 1.0 >>;
    $DirLineX = << 1.0, 0.0 , 0.0 >>;
    $DirLineY = << 0.0, 1.0 , 0.0 >>;


    $DirLineCamTOx = DirectionFN($XcrossP,$PtsVecAX);
    $DirLineCamTOy = DirectionFN($XcrossP,$PtsVecAY);



    $CamMatrixXt = GetMatrix("ZCURVEModelingCAM3");

    -32.014843
    68.15511
    0

    yrotMATRIX(68.15511);
    xrotMATRIX(-32.014843);


    PrintMatrix($CamMatrixXt,4);
    |  1  0  0  0|
    |  0  1  0  0|
    |  0  0  1  0|
    |  0  0  1  1|
    PrintMatrix($CamMatrixX,4);
    |   0.3720951716              0  -0.9281945826              0|
    |  -0.4920720897   0.8479107896  -0.1972621389              0|
    |   0.7870262015   0.5301389373   0.3155035108              0|
    |              0              0              1              1|

    StringtoStringMATRIX;

    MultMATRIX($CamMatrixX);

    vector [] GetRotationVectorsMatrix(


    TransformRelByMatrixXform($CamMatrixX, "ZCURVEModelingCAM3");


    //TransformItemByMatrixXform($CamMatrixX, "ZCURVEModelingCAM3");


    $matrixA_GlobalX  = << $xx, $yx, $zx, 0.0;
    $xy, $yy, $zy, 0.0;
    $xz, $yz, $zz, 0.0;
    $xo, $yo, $zo, 1.0 >>;
    PrintMatrix($matrixA_GlobalX,4);

    UnitMATRIX;



    TransformRelByMatrixXform( $matrixA_GlobalX, "ZCURVEModelingCAM3");




    $FirstTrans = $VrotatsFIRST;
    $FirstRot = $VrotatsFIRST;
    setAttr "ZCURVEModelingCAM.translate" $FirstTrans[0] $FirstTrans[1] $FirstTrans[2];
    setAttr "ZCURVEModelingCAM.rotate" 0 $FirstRot 0;




    $DirLineAX = DirectionFN($PtsVecAX, $PtsVecCross);
    $DirLineAY = DirectionFN($PtsVecAY, $PtsVecCross);
    $Zero = << 0.0, 0.0 , 0.0 >>;
    $DirLineX = << -1.0, 0.0 , 0.0 >>;
    $DirLineY = << 0.0, -1.0 , 0.0 >>;
    $DirLineYp = << 0.0, 1.0 , 0.0 >>;
    $AngleAX = `angle  $DirLineAX $DirLineX`;
    $AngleADegreeX = `rad_to_deg $AngleAX`;

    $AngleAY = `angle  $DirLineAY $DirLineY`;
    $AngleADegreeY = `rad_to_deg $AngleAY`;

    $FirstTrans = $VrotatsFIRST;
    $FirstRot = $VrotatsFIRST;
    setAttr "ZCURVEModelingCAM.translate" $FirstTrans[0] $FirstTrans[1] $FirstTrans[2];
    setAttr "ZCURVEModelingCAM.rotate" 0 $FirstRot 0;

    $DirLineN = << 0.0, 0.0 , 1.0 >>;
    $DirLineX = << 1.0, 0.0 , 0.0 >>;
    $DirLineY = << 0.0, 1.0 , 0.0 >>;



    $VPos_MC[0]= $VecCurEndsa[0];  $VPos_MC[1]= $VecCurEndsa[1];
    $VPos_MC[2]= $VecCurEndsb[0];  $VPos_MC[3]= $VecCurEndsb[1];
    $DirLineY = DirectionFN($VPos_MC[0], $VPos_MC[1]);
    $DirLineYR = DirectionFN($VPos_MC[2], $VPos_MC[3]);
    $AngleA = `angle $DirLineY $DirLineYR`;
    $AngleADegree = `rad_to_deg $AngleA`;




    proc vector [] VecPointsToCameraPlaneB(vector $V[]){
    $p = `xform -q -ws -t "LiveSurfaceB1"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM1`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM1", 0);
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+($D1*$F3);
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    return $O;
    }
    proc string [] PointCurvesToPlaneCurveB(string $CurveItemZ[]){
    $CN = 0;
    for ($eachCurve in $CurveItemZ){
    clear $AllLocPositionsZ;
    $AllLocPositionsZ = VecCurveEps( $eachCurve );
    $AllPlaneLocPositionZ = VecPointsToCameraPlaneB($AllLocPositionsZ);
    $newPlaneCurve[$CN] = VecArrayToCurve($AllPlaneLocPositionZ);
    ResetTranslation({$newPlaneCurve[$CN]});
    $CN++;
    }
    return $newPlaneCurve;

    }





    vector [] GetRotationVectorsMatrix(


    TransformRelByMatrixXform(matrix $m[][], string $item)
    TransformItemByMatrixXform(matrix $m[][], string $item)



    matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;

    global matrix $matrixA_GlobalX[4][4];
    $matrixA_GlobalX = << $xx, $yx, $zx, 0.0;
    $xy, $yy, $zy, 0.0;
    $xz, $yz, $zz, 0.0;
    $xo, $yo, $zo, 1.0 >>;







    //geneticEngine.mel by Martin Hemberg 2004

    //This is a genetic engine, ie a simple genetic algorithm for
    //evolutionary search implemented in MEL. In order to make it useful,
    //one must define a fitness function.

    //Some global variables. Unfortunately, matrix sizes can not be set
    //dynamically in MEL. Moreover, one can't declare constants. Thus I'm
    //using this method, I think it's marginally better than not having
    //them. Thus, we are stuck with a fixed size, if you want to change pop
    //size or length, change these numbers and do a search and replace on
    //the rest of the file



    global int $gGenomeLength = 100;
    global int $gPopulationSize = 50;
    global int $gMaxGeneValue = 42; //For a limit when generating random numbers, you may need to adjust this depending on your problem.

    evolve(125, 19, 55, 25.9);

    $ABCs = "abcdefghijklmnopqrstuvwxyz";
    $LETTERS = ArrayFromAllinString($ABCs);
    $Find = "hellojohn";
    $SizeF = `sizeBytes  $Find `;
    $SizeABCs = `sizeBytes  $ABCs `;

    global int $gGenomeLength = 9;
    global int $gPopulationSize = 50;
    global int $gMaxGeneValue =26;
    global matrix $genomes[50][9];
    $genomes = `initializePopulation`;

    print $genomes

    $GENOME_LETTERS = "";
    $j=1;
    for($i=0; $i<$gGenomeLength; $i++){
    $GENOME_LETTERS+= $LETTERS[int($genomes[$j][$i])];
    gmatch $GENOME_LETTERS  $Find;
    print ($GENOME_LETTERS+"\n");
    }

    gmatch "zza" "abc";


    $Find = "hellojohn";

    $FindN = "012";
    sizeBytes(` match "[l-l]" "hellojohn"`)

    match "[a-d]+" "acbdefg" "


    //This function creates a population of individuals with random gene values.


    proc matrix initializePopulation()
    {
    global int $gPopulationSize;
    global int $gGenomeLength;
    global int $gMaxGeneValue;
    global matrix $genomes[50][9];
    //Set each gene to a random value
    for($i=0; $i<$gPopulationSize; $i++){
    for($j=0; $j<$gGenomeLength; $j++)
    $genomes[$i][$j] = int(rand ($gMaxGeneValue));
    }
    return $genomes;
    }



    //This function is used to evaluate the fitness of the population. It
    //contains a large gap - you'll have to insert your own fitness function
    //that maps the array of doubles (the genome) to a scalar value (the
    //fitness). The fitness should be set so that a low value indicates a fit
    //individual.
    proc float[] evaluate(matrix $genomes)
    {
    global int $gPopulationSize;
    for($i=0; $i<$gPopulationSize; $i++){
    //Here each individual should be evaluated

    $fitness[$i] =
    }
    return $fitness;
    }



    proc evolve(int $generations, int $elites, int $tournamentSize, float $mutationRate)
    {
    //Call this function in order to do an evolutionary run for a
    //fixed number of generations. Unfortunately, there is no way to
    //continue running with the same population. However, that should not be
    //to hard to fix. It's just a matter of saving the variables in the
    //scene adn writing a function for reading them again at re-start.
    global matrix $genomes[50][9];
    matrix $genomes[50][9] = initializePopulation(); //[popsize][geneomelength] Each row represents an individual
    //Iterate through the generations
    for($i=0; $i<$generations; $i++){
    $fitness = evaluate($genomes); //Find out who's best
    $genomes = breed($genomes, $fitness, $elites, $tournamentSize, $mutationRate); //Create the population for the next generation
    }
    }




    //This function is used to create the population for the next generation
    proc matrix breed(matrix $genomes, float $fitness[], int $elites, int $tournamentSize, float $mutationRate)
    {
    global int $gPopulationSize;
    global int $gGenomeLength;
    $lowest = -1;
    //Copy the elites to the new generation, they will automatically be the first individuals in the new generation.
    for($i=0; $i<$elites; $i++){
    $lowest = findLowestFitness($fitness, $lowest);
    for($j=0; $j<$gGenomeLength; $j++)
    $newGenomes[$i][$j] = $genomes[$lowest][$j];
    }
    //Create the rest through tournament selection
    for($i=$elites; $i<$gPopulationSize; $i++){
    $father = tournamentSelect($fitness, $tournamentSize);
    $mother = tournamentSelect($fitness, $tournamentSize);
    $newGenomes = crossover($genomes, $newGenomes, $father, $mother, $i);
    }
    return mutate($newGenomes, $elites, $mutationRate);
    }

    //Returns the index of the individual with the lowest fitness above the one indicated by the argument $lowest.
    //If $lowest==-1, return the global minimum
    proc int findLowestFitness(float $fitness[], int $lowest)
    {
    $indexFitness = 100000;
    $lowestFitness = $fitness[$lowest];
    for($i=0; $i<size($fitness); $i++){
    if($fitness[$i]<$indexFitness && $fitness[$i]>=$lowestFitness && $i>$lowest){
    $index = $i;
    $indexFitness = $fitness[$i];
    }
    }
    return $index;
    }

    //Choose a parent using tournament selection. $tournamentSize
    //individuals are randomly chosen from the population. The best one of
    //these is then used as one of the parents for a member of the next
    //generation. A high value of $tournamentSize (compared to the pop size)
    //means that there will be less variation since the fittest individuals
    //are more likely to be picked in every tournament.

    proc int tournamentSelect(float $fitness[], int $tournamentSize) {
    global int $gPopulationSize;
    $parent = (int)rand ($gPopulationSize), $i, $tmp;
    for($i=1; $i<$tournamentSize; $i++){
    $tmp = (int)rand ($gPopulationSize);
    if($fitness[$tmp]<$fitness[$parent]) //Fitness minimization
    $parent = $tmp;
    }
    return $parent;
    }


    //Combine to individuals to produce a new one for the next generation.
    proc matrix crossover(matrix $genomes, matrix $newGenomes, int $father, int $mother, int $child)
    {
    global int $gGenomeLength;
    $i = (int)rand ($gGenomeLength);
    for($i=0; $i<$crossoverPoint; $i++)
    $newGenomes[$child][$i] = $genomes[$father][$i];
    for($i=$crossoverPoint; $i<$gGenomeLength; $i++)
    $newGenomes[$child][$i] = $genomes[$mother][$i];
    return $newGenomes;
    }

    //Random mutation
    proc matrix mutate(matrix $newGenomes, int $elites, float $mutationRate)
    {
    global int $gPopulationSize;
    global int $gGenomeLength;
    for($i=$elites; $i<$gPopulationSize; $i++){ //Don't mutate the elites
    for($j=0; $j<$gGenomeLength; $j++){
    if($mutationRate>`rand 100.0`){ //Mutate
    if(`rand 2.0`>1.0)
    $newGenomes[$i][$j] = $newGenomes[$i][$j] + 1;
    else
    $newGenomes[$i][$j] = $newGenomes[$i][$j] - 1;
    }
    }
    }
    return $newGenomes;
    }




    proc float roundoff( float $f, int $n )
    {
    // we divide if n < 0 to avoid numeric
    // precision problems
    if( $n > 0 )
    {
    $roundScale = pow(10,$n);
    if( $f > 0 )
    return( ((float)(int)($f * $roundScale + 0.5)) /$roundScale );
    else
    return( ((float)(int)($f * $roundScale - 0.5)) /$roundScale );
    }
    else
    {
    $roundScale = pow(10,-$n);
    if( $f > 0 )
    return( ((float)(int)($f/$roundScale + 0.5)) *$roundScale );
    else
    return( ((float)(int)($f/$roundScale - 0.5)) *$roundScale );

    }
    }
















    //////////








    clear $MasterLineN;


    $CurrentLineN = $CurrentLineNF;
    clear $CollectL;
    clear $CAL_temp;
    clear $LN_temp;
    $CAL_temp =$CollectAllLines;
    $LN_temp =$LineNumber;
    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $START = 0;
    $TriggerLineFound = 0;
    clear $CurrentLineNX;
    clear $tempCollectProc;

    $Aint = size($CollectAllLines);
    $Bint = size($AllFoundProcs);
    $Cint = size($CAL_temp);
    $CHECK = $Aint-$Cint ;

    //int $fileId =`fopen $exampleFileName "r"`;
    //string $nextLine = `fgetline $fileId`;
    //int $eachInt = $CurrentLineN[0];
    clear $tempCollectProc;
    clear $AllFoundProcs;

    $TRIGGEREND = 2;

    $fileId = `fopen $exampleFileName "r"`;


    while($TRIGGEREND>1){



    ///////////////////////////
    ///////////////////////////




    for($eachInt in $CurrentLineN){


    //this is the number that is the first line of a group of lines that are a proc


    $WhenZero=2;
    $CountNL = 1;
    $CountFindNL = 0;
    $START = 0;
    $TriggerLineFound=0;



    ///////////////////////////////////////////////////////////////////

    while ( !`feof $fileId` ) {


    $nextLine = `fgetline $fileId`;
    $nextLineN = match( "^[^(\r\n)]*", $nextLine );

    //FOUND LINE NUMBER
    //CHANGE HERE

    if($CurrentLineN[$CountFindNL] == $CountNL){
    clear $NegPosZA;
    $CountFindNL++;
    $TriggerLineFound=1;
    }



    if($TriggerLineFound==1){
    $WhenZero = BracketFindPosNeg($nextLine, $NegPosZA);
    $START++;
    $CollectL[`size($CollectL)`]= $nextLineN;



    /// WHEN PROC IS FULLY SCANNED HERE BELOW

    if(($WhenZero==0)&&($START>1)){



    $START=$TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
    // $CAL_temp IS $CollectAllLines;  MATCH NAMES//
    if(`size($CAL_temp)`==0){break;}
    $FoundProcTemp =RuleBasedMatchM($IndexX,$CAL_temp, $CollectL);
    // $LN_temp =$LineNumber;
    if(`size($IndexX)`>0){

    $IndexX = sort($IndexX);
    for($i=0; $i<`size($IndexX)`; $i++){
    $CurrentLineNX[`size($CurrentLineNX)`] =$LN_temp[$IndexX[$i]];
    }



    $CAL_temp=RemoveStringAtIndex($CAL_temp,$IndexX);
    $LN_temp = RemoveIntAtIndex($LN_temp,$IndexX);

    clear $IndexX;
    /////////////

    }

    $tempCollectProc =AppendArrayZ($tempCollectProc, $FoundProcTemp);

    clear $FoundProcTemp;
    /////////////////////




    }
    }
    //LINE NUMBER
    $CountNL++;

    }

    ///////////////////////////////////////////////////////////////////


    frewind $fileId;



    }


    ///////////////////////////
    ///////////////////////////


    $tempCollectProc= stringArrayRemoveDuplicates($tempCollectProc);
    AppendArrayZ($AllFoundProcs,$tempCollectProc);

    $TempStringP = "";
    $TempStringP = stringArrayToString($tempCollectProc, ", ");
    print ($TempStringP+"\n");
    $WholeProc[`size($WholeProc)`]=$TempStringP;

    clear $tempCollectProc;
    //////////////////////


    $list = IntArrayToStringArray($CurrentLineNX);
    $list= stringArrayRemoveDuplicates($list);

    clear $CurrentLineN;
    $CurrentLineN=StringArrayToIntArray($list);
    $CurrentLineN =sort ($CurrentLineN);

    clear $CurrentLineNX;
    //////////////////////

    clear $tempCollectProc;
    //////////////////////

    if(`size($CurrentLineN)`>0){
    for($i=0; $i<`size($CurrentLineN)`; $i++){
    $MasterLineN[`size($MasterLineN)`] =$CurrentLineN[$i];
    }
    }


    if($CurrentLineN[0]==0){
    print "STOPSTOP";
    $TRIGGEREND =0;
    break;
    }

    if(`size($CurrentLineN)`==0){
    print "STOPSTOP";
    $TRIGGEREND =0;
    break;
    }



    }

    print $WholeProc;




    ////////
    /////////////START OF AUTOMATIC SCENE SETUP for STEREOSCRIPTS######################################
    /////////////START OF AUTOMATIC SCENE SETUP for STEREOSCRIPTS######################################
    /*




    global vector $ObjCurv[];
    //print  $GlobalObjListA[46];
    global vector $ObjVec[];
    global string $GlobalObjListA[];
    global string $GlobalObjOne[];
    $ConnectionSet1 = `sets -name ExistingCurveZSet`;
    $ConnectionSet2 = `sets -name CurveZSetOne`;
    clear $ObjCurv;
    clear $GlobalObjListA;
    clear $GlobalObjOne;
    clear $ObjVec;

    global int $ifSingleCurve;
    $ifSingleCurve =0;
    createDisplayLayer -name "VanishingPointsLines"  -empty;
    setAttr VanishingPointsLines.visibility 1; setAttr VanishingPointsLines.displayType 0; setAttr VanishingPointsLines.color 0;


    if ( `objExists NurbsPlanes` == 0  ) {
    createDisplayLayer -name "NurbsPlanes" - number 1 -empty;
    setAttr NurbsPlanes.color 30;
    }
    if ( `objExists IntersectFormLayer` == 0  ) {
    createDisplayLayer -name "IntersectFormLayer" - number 1 -empty;
    setAttr IntersectFormLayer.color 30;
    }
    if ( `objExists IntersectFormLayerOutofRange` ==  0  ) {
    createDisplayLayer -name  "IntersectFormLayerOutofRange" -number 1 -empty;
    setAttr IntersectFormLayerOutofRange.color 2;
    }
    if ( `objExists IntersectFormLayerINRange` == 0   ) {
    createDisplayLayer -name  "IntersectFormLayerINRange" -number 1 -empty;
    setAttr IntersectFormLayerINRange.color 3;
    }
    if ( `objExists layerYZYXPlains` == 0  ) {
    createDisplayLayer -name "layerYZYXPlains" - number 1 -empty;
    }
    if ( `objExists layerAllCurves1` == 0  ) {
    createDisplayLayer -name "layerAllCurves1" - number 1 -empty;
    }
    if ( `objExists layerEdgeCurveZ1` == 0  ) {
    createDisplayLayer -name "layerEdgeCurveZ1" - number 1 -empty;
    }
    if ( `objExists layerCurvesOutofRange1` == 0  ) {
    createDisplayLayer -name "layerCurvesOutofRange1"  -number 1 -empty;
    setAttr layerCurvesOutofRange1.color 12;
    }
    if ( `objExists layerCurvesINRange1` == 0  ) {
    createDisplayLayer -name "layerCurvesINRange1" - number 1 -empty;
    setAttr layerCurvesINRange1.color 6;
    }
    if ( `objExists TheLastCurvesSet` == 0  ) {
    $newSet3 = `sets -name TheLastCurvesSet`;
    }
    if ( `objExists ZEdgeCurvesSet` == 0  ) {
    $newSet1 = `sets -name ZEdgeCurvesSet`;
    }
    if ( `objExists ZPlaneCurvesSet` == 0  ) {
    $newSet2 = `sets -name ZPlaneCurvesSet`;
    }
    global int $xii;
    global int $xii = 0;
    $script_jobToolChangedNum1 = 505;
    $script_jobToolChangedNum2 = 606;
    $addNumbersA = 0;
    global int $script_jobNumIdle_MoveZCURVEM;
    global string $dialogBoxWin;
    global string $EdgeCurveZ2[];
    global int $plainNum;
    clear $EdgeCurveZ2;
    global int $plainNum = 0;
    global string $CamConeLocator[];


    if ( `objExists ZCURVEModelingCAM` == 0  ) {
    handleScriptEditorAction "toggleSuppressInfos";
    handleScriptEditorAction  "toggleSuppressWarnings";
    handleScriptEditorAction "toggleSuppressErrors";
    setWireframeOnShadedOption 1 modelPanel4;
    $CamConeLocator = `CreateCAMforIntCurveScript`;
    if ( `objExists CamConeLocatorSet` == 0  ) {
    $newCAMSet1 = `sets -name CamConeLocatorSet`;
    sets -include CamConeLocatorSet $CamConeLocator;
    }
    createStageOneForRetopo;
    select -r $CamConeLocator;
    HideSelectedObjects;
    shadingNode -asShader lambert;
    $material = `shadingNode -asShader lambert -name  LIVEsurfaceslambert`;
    $sg = `sets -renderable true - noSurfaceShader true -empty -name ($material +  "SG")`;
    setAttr "LIVEsurfaceslambert.transparency" -type  double3 1 1 1 ;
    defaultNavigation -source LIVEsurfaceslambert - destination  |LiveSurfaceB|LiveSurfaceBShape.instObjGroups[0]  - connectToExisting;
    connectNodeToAttrOverride("LIVEsurfaceslambert",  "LiveSurfaceBShape.instObjGroups[0]");
    defaultNavigation -source LIVEsurfaceslambert - destination |Zplane|ZplaneShape.instObjGroups[0]  -connectToExisting;
    connectNodeToAttrOverride("LIVEsurfaceslambert",  "ZplaneShape.instObjGroups[0]");
    defaultNavigation -source LIVEsurfaceslambert - destination |Xplane|XplaneShape.instObjGroups[0]  -connectToExisting;
    connectNodeToAttrOverride("LIVEsurfaceslambert",  "XplaneShape.instObjGroups[0]");
    }
    if (( `objExists ZCURVEModelingCAM` == 1  )&& (  `objExists layerCurvesINRange1` == 1 )) {
    setAttr "ZCURVEModelingCAM.centerOfInterest"  75;
    //select -r ZCURVEModelingCAM ;
    //select -tgl LiveSurfaceB ;
    //scale -r 10 10 10 ; // SEt Camera Scale

    if ( `objExists CamConeLocatorSet` == 1  ) {
    eval( "global string $CamConeLocator[];");
    eval( "$CamConeLocator= `sets -q  CamConeLocatorSet`;");
    }
    }
    //

    if ( `objExists LocOnLivePlaneB` == 0  ) {
    createDisplayLayer -name "LocOnLivePlaneB" - number 1 -empty;
    setAttr LocOnLivePlaneB.color 9;
    }
    if ( `objExists LocCurveEnds` == 0  ) {
    createDisplayLayer -name "LocCurveEnds" - number 1 -empty;
    setAttr LocCurveEnds.color 13;
    }

    if ( `objExists layerMidPoint` == 0  ) {
    createDisplayLayer -name "layerMidPoint" - number 1 -empty;
    setAttr layerMidPoint.color 14;
    }


    ////////

    EvalAllCurvesToolZ;
    $scriptt_jobNumConnectionChanged = `scriptJob -conditionChange delete evalVectorIndexAdditionSubtract`;
    eval(" $jobNumtranslateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.translate  RUNMoveZCURVEM`;");
    eval(" $jobNumrotateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.rotate  RUNMoveZCURVEM`;");

    select -r LiveSurfaceB ;
    MakeLive;
    PencilCurveTool;



    ////////



    */
    /////////////START OF AUTOMATIC SCENE SETUP for STEREOSCRIPTS######################################
    /////////////START OF AUTOMATIC SCENE SETUP for STEREOSCRIPTS######################################

    proc EvalAllCurvesToolZ(){
    eval("int $scriptt_jobAllCurvesToolsNumAZ =  `scriptJob -event DagObjectCreated  AutoCurveScriptsTwoCurve -compressUndo true -protected  `;");
    }

    proc RUNMoveZCURVEM(){
    $script_jobNumIdle_MoveZCURVEM = `scriptJob   -runOnce 1 -event idle EVALCamScripts`;
    }

    proc createStageOneForRetopo(){
    nurbsPlane -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u  1 -v 1 -ch 1 -n Zplane;
    rotate -r -os 0 0 -90 ;
    setAttr "Zplane.scaleX" 3000;
    setAttr "Zplane.scaleY" 3000;
    setAttr "Zplane.scaleZ" 3000;
    nurbsPlane -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u  1 -v 1 -ch 1 -n Xplane;
    setAttr "Xplane.scaleX" 3000;
    setAttr "Xplane.scaleY" 3000;
    setAttr "Xplane.scaleZ" 3000;
    editDisplayLayerMembers -noRecurse  NurbsPlanes "Zplane";
    editDisplayLayerMembers -noRecurse  NurbsPlanes "Xplane";
    layerEditorLayerButtonVisibilityChange NurbsPlanes;
    curve -d 3 -p 0 0 0 -p 0 0 4 -p 0 0 8 -p 0 0 12  -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -n Zcurvez;
    curve -d 3 -p 0 0 0 -p 4 0 0 -p 8 0 0 -p 12 0 0  -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -n Xcurvez;
    if ( `objExists layerZcurvez` == 0  ) {
    createDisplayLayer -name "layerZcurvez" -number 1  -empty;
    setAttr layerZcurvez.color 6;
    editDisplayLayerMembers -noRecurse layerZcurvez  Zcurvez;
    }
    if ( `objExists layerXcurvez` == 0  ) {
    createDisplayLayer -name "layerXcurvez" -number 1  -empty;
    setAttr layerXcurvez.color 13;
    editDisplayLayerMembers -noRecurse layerXcurvez  "Xcurvez";
    }
    }

    proc int[] SortNumbersIntIndex(float $allFloatToSort[]){
    $aF = $allFloatToSort;
    $sIze = `size($aF)`-1;
    $IndexTrack = CreateIntIndex(`size($aF)`);
    quickSort($aF, $IndexTrack, 0, $sIze);
    $IndexTrack = ReverseIntArray($IndexTrack);
    return $IndexTrack;
    }
    proc quickFix(){
    global vector $ObjVec[];
    global string $GlobalObjListA[];
    $quickFix = `sets -q ExistingCurveZSet`;
    $FixVec = PointArrayT($quickFix);
    $GlobalObjListA=$quickFix;
    $ObjVec=$FixVec;
    }
    proc evalVectorIndexAdditionSubtract(){
    global vector $ObjVec[];
    global string $GlobalObjListA[];
    $objVecMain  = $ObjVec;
    $intIndexCurveZ = CreateIntIndex(`size($objVecMain)`) ;
    clear $firstReduction;
    $GetObjList = `sets -q ExistingCurveZSet`;
    $KnowObjList = $GlobalObjListA;
    $diffAZ = stringArrayRemoveExact($GetObjList,$KnowObjList);
    $diffCZ = stringArrayRemoveExact($KnowObjList, $GetObjList);
    if((`size($diffCZ)`>0)||(`size($diffAZ)`>0)){
    if(`size($diffAZ)`>0){
    $diffBZ = stringArrayRemoveExact($diffAZ,$KnowObjList);
    $NewObjList= $diffBZ;
    $indexNumberZ = stringArrayGmatchArrayIndex($diffBZ, $KnowObjList);
    $indexX = 0;
    for ($eachVec in $indexNumberZ){
    $firstReduction[`size($firstReduction)`]= $objVecMain[$eachVec];
    }
    }
    if(`size($diffCZ)`>0){
    $newAddedVec = PointArrayT($diffCZ);
    $iXn = 0;
    for ($eachVecB in $newAddedVec){
    $firstReduction[`size($firstReduction)`]=  $eachVecB ;
    stringArrayInsertAtIndex(`size($NewObjList)`, $NewObjList, $diffCZ[$iXn]);
    $iXn++;
    }
    }
    $GlobalObjListA = $NewObjList;
    clear $ObjVec;
    $ObjVec= $firstReduction;
    }
    }
    proc string[] MoveZCURVEModelingCAM2010(string $EdgeCurves[], string $CamConeLocator[], vector $ObjVecX[]){
    RemoveNoLongerExistingFromArray($EdgeCurves);
    $listofallcurves = $EdgeCurves;
    layerEditorRemoveObjects layerCurvesINRange1 ;
    editDisplayLayerMembers -noRecurse "defaultLayer"  $ObjectsINcamLightCone;
    layerEditorRemoveObjects layerCurvesOutofRange1 ;
    editDisplayLayerMembers -noRecurse "defaultLayer"  $OutofRange;
    clear $ObjectsINcamLightCone;
    if ( `objExists LocOnLivePlaneB` == 0  ) {
    createDisplayLayer -name "LocOnLivePlaneB" - number 1 -empty;
    setAttr LocOnLivePlaneB.color 9;
    }
    queryLocOnLivePlaneBLayerDelete;
    queryLocCurveEndsLayerDelete;
    querylayerMidPointLayerDelete;
    catch ( $shortnameL = "PlaneLOC*");
    if ( `objExists $shortnameL` == 1  ) {
    catch (`delete $shortnameL`);
    }
    $CurveItem = $listofallcurves;
    ResetTransEachSL;
    $NurbplaneB = "LiveSurfaceBShape";
    $ObjectsInFrontZ = GetObjectsInFrontOfPlane2($CurveItem, $ObjVecX, $VecArrayRemainsZ);
    if(`size($ObjectsInFrontZ)`>0){
    clear $AllLocPositionsZ;
    $AllPlaneLocPositionZ = VecPointsToCameraPlane($VecArrayRemainsZ);
    $LocPointinPlane = PointInNurbPlane($AllPlaneLocPositionZ, $ObjectsInFrontZ, $newOrderA, 0);
    }
    if(`size($LocPointinPlane)`>0){
    $indexLoc = 0;
    for ($each in $LocPointinPlane){
    stringArrayInsertAtIndex(0,  $ObjectsINcamLightCone, $each);
    $LocCurveEnds = LocCurveEnds({$each},$AllCurveLocArrayVec);
    appendStringArray($AllLocCurveEnds, $LocCurveEnds, size($LocCurveEnds));
    }
    clear $AllCurvePlaneLocZ;
    $AllCurvePlaneLocZ = VecPointsToCameraPlane($AllCurveLocArrayVec);
    select -cl  ;
    $CurveLocPlanePoints = PointInNurbPlane($AllCurvePlaneLocZ, $AllLocCurveEnds, $newOrderB, 1);
    }
    $shorterList = stringArrayRemoveDuplicates ($ObjectsINcamLightCone);
    $ObjectsINcamLightCone = $shorterList;
    $OutofRange = stringArrayRemoveExact ($ObjectsINcamLightCone, $listofallcurves);
    editDisplayLayerMembers -noRecurse  layerCurvesOutofRange1 $OutofRange;
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ObjectsINcamLightCone;
    return $ObjectsINcamLightCone;
    }
    proc CatchMoveZCURVECAM2010(string $EdgeCurveZa[], string $CamConeLocator[], vector $ObjVecX[]){
    global string $StereoCurveZ[];
    global string $VanishingPointsLinesTempGuides[];
    global int $addNumbersA;
    quickFix;
    if ( catchQuiet(MoveZCURVEModelingCAM2010 ($EdgeCurveZa, $CamConeLocator, $ObjVecX ))) {
    evalVectorIndexAdditionSubtract;
    MoveZCURVEModelingCAM2010($EdgeCurveZa, $CamConeLocator, $ObjVecX );
    clear $StereoCurveZ;
    clear $VanishingPointsLinesTempGuides;
    $addNumbersA =0;
    quickFix;
    } else {
    clear $StereoCurveZ;
    $addNumbersA =0;
    quickFix;
    }
    }
    proc string[] queryLocOnLivePlaneBLayer(){
    $queryLocB = `editDisplayLayerMembers  -q LocOnLivePlaneB`;
    $IfemptyIsTrue = 0;
    if (`size( $queryLocB)` > 0){
    $IfemptyIsTrue = 0;
    }
    if (`size( $queryLocB)`== 0){
    $IfemptyIsTrue = 1;
    }
    return $queryLocB;
    }
    proc queryLocOnLivePlaneBLayerDelete(){
    $queryLocOnLivePlaneB = `editDisplayLayerMembers  -q LocOnLivePlaneB`;
    if (`size( $queryLocOnLivePlaneB)` > 0){
    delete  $queryLocOnLivePlaneB;
    }
    }
    proc queryLocCurveEndsLayerDelete(){
    $queryLocCurveEnds = `editDisplayLayerMembers  -q LocCurveEnds`;
    if (`size($queryLocCurveEnds)` > 0){
    delete $queryLocCurveEnds;
    }
    }
    proc querylayerMidPointLayerDelete(){
    $querylayerMidPoint = `editDisplayLayerMembers  -q layerMidPoint`;
    if (`size($querylayerMidPoint)` > 0){
    delete $querylayerMidPoint;
    }
    }
    proc string[] LocCurveEnds(string $CurveItem[], vector $CurveLocArrayVec[]){
    $numCVs = `getAttr -size ($CurveItem[0]+".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
    $EACHCVposAZ = 0; string $MakeXBetweenB[];
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ($eachZA)`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){$EACHCVposAZ = $eachCVpos;}
    if ( $numIntZB == 2 ){$EACHCVposBZ = $eachCVpos;}
    }
    $NameStart = ("LOC"+$CurveItem[0]+"START");
    $NameEnd = ("LOC"+$CurveItem[0]+"END");
    $LocSTART = `spaceLocator -p 0 0 0 -n $NameStart`;
    MoveObject2($EACHCVposAZ);
    $LocEND = `spaceLocator -p 0 0 0 -n $NameEnd`;
    MoveObject2($EACHCVposBZ);
    $STARTENDcurveLocs = { $LocSTART[0], $LocEND[0]};
    setAttr ($LocSTART[0]+".scaleX") 0.5;
    setAttr ($LocSTART[0]+".scaleY") 0.5;
    setAttr ($LocSTART[0]+".scaleZ") 0.5;
    setAttr ($LocEND[0]+".scaleX") 0.5;
    setAttr ($LocEND[0]+".scaleY") 0.5;
    setAttr ($LocEND[0]+".scaleZ") 0.5;
    $CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    $CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    editDisplayLayerMembers -noRecurse LocCurveEnds $STARTENDcurveLocs;
    select -cl  ;
    return $STARTENDcurveLocs;
    }
    proc vector [] VecCurveEps(string $CurveItem ){
    $CurveSelection = `ls -fl ($CurveItem+".ep[0:*]")`;
    for ($eachZA in $CurveSelection) {
    $EACHCVposAZ = `pointPosition -w ($eachZA)`;
    $CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    }
    return $CurveLocArrayVec;
    }
    proc vector [] VecCurveCvs(string $CurveItem ){
    $CurveSelection = `ls -fl ($CurveItem+".cv[*]")`;
    for ($eachZA in $CurveSelection) {
    $EACHCVposAZ = `pointPosition -w ($eachZA)`;
    $CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    }
    return $CurveLocArrayVec;
    }
    proc vector[] PointArrayT(string $ObjectList[]){
    $XiV = 0;
    for ($each in $ObjectList){
    if (catch($pointAZ1 = `xform -q -ws -t ($each)`)){
    $pointAZ1 = `pointPosition -w ($each)`;
    }
    $VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
    $XiV++;
    }
    return $VecArray;
    }
    proc vector[] PointArray(string $ObjectList[]){
    $XiV = 0;
    for ($each in $ObjectList){
    if (catch($pointAZ1 = `pointPosition -w ($each)`)){
    $pointAZ1 = `xform -q -ws -rp ($each)`;
    }
    $VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
    $XiV++;
    }
    return $VecArray;
    }
    proc string [] GetObjectsInFrontOfPlane2(string $Loc[], vector $VecArray[], vector $VecArrayRemainsB[] ){
    $CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $IndexVec = 0;
    $IndexVecRemain = 0;
    clear $ObjectsInFrontOfPlane;
    for ($eachPoint in $VecArray){
    $ObjectToCam = distance2Pts( $CamPlane1, $VecArray[$IndexVec]);
    $ObjectToCamShiftA = ($CamerasDirectionVectorNormal* 10.5)+$VecArray[$IndexVec];
    $ObjToCamdistShiftDiff = distance2Pts( $CamPlane1, $ObjectToCamShiftA);
    if($ObjToCamdistShiftDiff<$ObjectToCam){
    stringArrayInsertAtIndex(`size($ObjectsInFrontOfPlane)`, $ObjectsInFrontOfPlane, $Loc[$IndexVec]);
    $VecArrayRemains[$IndexVecRemain]= $VecArray[$IndexVec];
    $IndexVecRemain++;
    }
    $IndexVec++;
    }
    $VecArrayRemainsB = $VecArrayRemains;
    return $ObjectsInFrontOfPlane;
    }
    proc string [] PointInNurbPlane(vector $AllPlaneLocPosition[], string $ObjectsInFront[], int $Newindex[], int $Locint ){
    clear $EdgesSurface;
    $EdgesSurface[0] = "LiveSurfaceBShape.cv[0][0]" ;
    $EdgesSurface[1] = "LiveSurfaceBShape.cv[0][3]" ;
    $EdgesSurface[2] = "LiveSurfaceBShape.cv[3][3]" ;
    $EdgesSurface[3] = "LiveSurfaceBShape.cv[3][0]" ;
    $SurfEnds = PointArray($EdgesSurface);
    $MiddlePointA[0] = FloatToVec(MidPoint($SurfEnds[0], $SurfEnds[1]));
    $MiddlePointA[1] = FloatToVec(MidPoint($SurfEnds[1], $SurfEnds[2]));
    $MiddlePointA[2] = FloatToVec(MidPoint($SurfEnds[2], $SurfEnds[3]));
    $MiddlePointA[3] = FloatToVec(MidPoint($SurfEnds[3], $SurfEnds[0]));
    $AveragePoints = `xform -q -ws -t LiveSurfaceB`;
    clear $DirectionsToCent;
    for ($each in $MiddlePointA){
    $Direct = DirectionF( $each, $AveragePoints);
    $DirectionsToCent[size($DirectionsToCent)] = <<$Direct[0], $Direct[1], $Direct[2]>>;
    }
    $PlaneDimentionsV = distance2Pts( $SurfEnds[0], $SurfEnds[1]);
    $PlaneDimentionsH = distance2Pts( $SurfEnds[1],$SurfEnds[3]);
    $IndexV = CreateIntIndex(`size($AllPlaneLocPosition)`);
    $RadiusMax = distance2Pts( $AveragePoints, $SurfEnds[0]);
    $indexRecord = 0;
    for ($eachVec in $AllPlaneLocPosition){
    $FoundDistance = distance2Pts( $AveragePoints, $eachVec);
    if($FoundDistance<=$RadiusMax){
    $IndexReduced[`size($IndexReduced)`] = $IndexV[$indexRecord];
    $firstReduction[`size($firstReduction)`]= $eachVec;
    }
    $indexRecord++;
    }
    $PlaneDimentionsVH = $PlaneDimentionsV/100;
    $PlaneDimentionsHH = $PlaneDimentionsH/100;
    $indexPoints = 0;
    $PointsZ = $firstReduction;
    $Lastindex = 0;
    $indexM = 0;
    $FourDiections = 0;
    for ($eachPoint in $firstReduction){
    $LocPoint = $eachPoint;
    $indexM = 0;
    $FourDiections = 0;
    for ($each in  $DirectionsToCent){
    $DistanceA = distance2Pts( $MiddlePointA[$indexM],  $LocPoint);
    if(($indexM==0)||($indexM==2)){
    $MultDirAV= multiplyFloat($PlaneDimentionsVH, $each);
    }
    if(($indexM==1)||($indexM==3)){
    $MultDirAV= multiplyFloat($PlaneDimentionsHH, $each);
    }
    $FloatDirectionPointz = AddFloats($MultDirAV, $LocPoint);
    $DistanceB = distance2Pts( $MiddlePointA[$indexM],  $FloatDirectionPointz);
    if( $DistanceB > $DistanceA){
    $FourDiections++;
    }
    $indexM++;
    }
    if( $FourDiections == 4 ){
    $AllPointsInplane[`size($AllPointsInplane)`]= $eachPoint;
    $lastIntIndex[$Lastindex]=  $IndexReduced[$indexPoints];
    $Lastindex++;
    }
    $indexPoints++;
    }
    for ($eachNumber in $lastIntIndex){
    stringArrayInsertAtIndex(`size($allObjectsInPlane)`, $allObjectsInPlane, $ObjectsInFront[$eachNumber]);
    }
    $Newindex = $lastIntIndex;
    for ($eachNumber in $lastIntIndex){
    $NewVecArray[`size($NewVecArray)`] =$AllPlaneLocPosition[$eachNumber];
    }
    $AllPlaneLocPosition=$NewVecArray;
    if($Locint==1){
    $inDexName = 0;
    for ($each in $AllPointsInplane){
    $stringName = ("Plane"+ $allObjectsInPlane[$inDexName]);
    spaceLocator -p 0 0 0 -n $stringName;
    MoveObject2($each);
    scale -r 0.01 0.01 0.01;
    editDisplayLayerMembers -noRecurse LocOnLivePlaneB $stringName;
    $inDexName++;
    }
    }
    return $allObjectsInPlane;
    }
    proc float[] MirrorFloatXYZ(int $XYZ, float $ThreeFLoatArrays[]){
    $Zx = $ThreeFLoatArrays;
    $Zx[$XYZ] *= -1.0;
    return $Zx;
    }
    proc float[] nurbsViewDirectionVectorCam( string $cameraName , int $onlyOrtho )
    {
    $isitYup = `upAxis -q -ax $cameraName`;
    if( "y" == $isitYup ) {
    $result[0] = 0.0 ;
    $result[1] = 1.0 ;
    $result[2] = 0.0 ;
    }
    else {
    $result[0] = 0.0 ;
    $result[1] = 0.0 ;
    $result[2] = 1.0 ;
    }
    "  Using the default (" + $result[0] + "," +
    $result[1] + "," + $result[2] + ")";
    if( $onlyOrtho && !`camera -q -o $cameraName` ) {
    return $result;
    }
    $coiDistance = 0.0 ;
    if( catch( $coiDistance = `camera -q -coi $cameraName` )) {
    warning $forTheWarning;
    return $result ;
    }
    $selectionList = `ls -sl`;
    if( catch($ppm = `createNode pointMatrixMult`) ) {
    warning $forTheWarning;
    select -r $selectionList;
    return $result ;
    }
    select -r $selectionList;
    setAttr ($ppm +".inPoint") -type double3 0.0 0.0 (-$coiDistance) ;
    setAttr ($ppm +".vectorMultiply") true ;
    connectAttr ($cameraName+".worldMatrix[0]") ($ppm+".inMatrix") ;
    $coi = `getAttr ($ppm+".output")` ;
    delete $ppm ;
    $sum = 0;
    for( $i = 0 ; $i < 3 ; $i++ ) {
    $sum += ($coi[$i] * $coi[$i]);
    $result[$i] = $coi[$i];
    }
    if( $sum > 0 ) {
    $sum = -1.0/sqrt($sum);
    for( $i = 0 ; $i < 3 ; $i++ ) {
    $result[$i] = $result[$i] * $sum;
    }
    }
    return $result ;
    }
    proc string Loc(float $Points[]){
    $LocObjects = `spaceLocator -p 0 0 0`;
    setAttr ($LocObjects[0]+".translate")  $Points[0] $Points[1] $Points[2];
    return $LocObjects[0];
    }
    proc string getTypeItemString(string $selectionFindType[]){
    $selectionFindType= `ls -fl $selectionFindType`;
    if(`size($selectionFindType)`>0){
    $Relativesselection = `listRelatives $selectionFindType[0]`;
    if (`size($Relativesselection)` == 0){ string $idnodeType3[] = `nodeType -inherited $selectionFindType[0]`;
    $Value = stringArrayGmatchFind($idnodeType3, "controlPoint");
    if($Value == 1){ $idnodeType2="controlPoint";}else{ $idnodeType2=$idnodeType3[(`size($idnodeType3)`)-1];}
    }else{ $idnodeType2 = `nodeType $Relativesselection[0]`;}
    }else{ $idnodeType2 = "EMPTY";}
    return $idnodeType2;
    }
    proc int [] stringArrayGmatchArrayIndex(string  $itemA[], string $list[]){
    $sizeitem = `size($itemA)`;
    $result = false;
    $Index = 0;
    $BreakTrigger = 0;
    for ($EachlistItem in $list) {
    for ($EachlistA in $itemA) {
    if ( $EachlistItem == $EachlistA ){
    $result = true; $ResultIndex[`size($ResultIndex)`] =  $Index;
    $BreakTrigger++;
    if ( $BreakTrigger == $sizeitem ){	break;	}
    }
    }
    $Index++;
    }
    return $ResultIndex;
    }
    proc int stringArrayGmatchFind(string $itemsA[], string $Item){
    $result = false;
    for ($EachlistA in $itemsA) {
    if ( $EachlistA == $Item ){
    $result = true;
    break;	}
    }	return $result;
    }
    proc float [] ArrayDistancesVecTofloat(vector $allVec[], float $point[]){
    for ($each in $allVec){
    $AllDistances[`size($AllDistances)`] = distance2Pts( $each, $point);
    }
    return $AllDistances;
    }
    proc float [] MovePointDirectionAndDistance( float $Direction[], float $Distance, float $PointA[]){
    $MultDirDist = multiplyFloat($Distance ,$Direction);
    $FloatPointLoc = AddFloats($PointA, $MultDirDist);
    return $FloatPointLoc;
    }
    proc SetItemColorString( string $isSelectedZz, int $Color ){
    if ( `objExists $isSelectedZz` == 1  ) {
    $ColorN = $Color;
    if ( $Color > 31  ) { $ColorN = $ColorN -31;}
    $isSelectedZx = `listRelatives $isSelectedZz`;
    setAttr ($isSelectedZx[0]+".overrideEnabled ") 1;
    if (catch (`setAttr ($isSelectedZx[0]+".overrideColor ") $ColorN `)){
    setAttr ($isSelectedZx[0]+".overrideColor ") 1;}
    }
    }
    proc MoveObject2(float $FloatPos[]){
    move -ws $FloatPos[0] $FloatPos[1] $FloatPos[2] ;
    }
    proc float[] AverageVectorPoint(vector $worldPosZ[]) {
    $vectorSize = `size($worldPosZ)`;
    $vecCount = `size($worldPosZ)`;
    $Added_floats = { 0.0, 0.0, 0.0};
    $Vii = 0;
    while ($Vii < $vecCount){
    $FloatFromVecA = $worldPosZ[$Vii];
    $VposA = $FloatFromVecA[0];
    $VposB =  $FloatFromVecA[1];
    $VposC =  $FloatFromVecA[2];
    $Added_floats = {($FloatFromVecA[0]+$Added_floats[0]), ($FloatFromVecA[1]+$Added_floats[1]), ($FloatFromVecA[2]+$Added_floats[2])} ;
    $Vii++;
    }
    $a = ($Added_floats[0])/float($vectorSize);
    $b = ($Added_floats[1])/float($vectorSize);
    $c = ($Added_floats[2])/float($vectorSize);
    $PointsAverage = {$a , $b , $c};
    return $PointsAverage;
    }
    global proc int[] ArrayToIntList(string  $singleStringItemB[]){
    $triggerendsB = 0;
    $newlistSize = size($singleStringItemB);
    $ci = 0;
    while ( $triggerendsB < $newlistSize ) {
    $Numberlist[$ci] = $singleStringItemB[$ci];
    $ci++;
    $triggerendsB = $triggerendsB + 1;
    }
    return $Numberlist;
    }
    proc int[] ReverseIntArray(int $array[]){
    for($i=0;$i<size($array);$i++){
    $arrayOut[$i]=$array[(size($array)-1-$i)];}
    return $arrayOut;
    }
    proc string[] ReverseStringArray(string $array[]){
    for($i=0;$i<size($array);$i++){
    $arrayOut[$i]=$array[(size($array)-1-$i)];}
    return $arrayOut;
    }
    proc vector[] ReverseVectorArray(vector $array[]){
    for($i=0;$i<size($array);$i++){
    $arrayOut[$i]=$array[(size($array)-1-$i)];}
    return $arrayOut;
    }
    proc vector[] MagTimesUnitVecs(vector  $vectorZFlatYHigher, vector $vectorZFlatYLower){
    $MagVectorZYHigher = mag ($vectorZFlatYHigher);
    $MagVectorZYLower = mag ($vectorZFlatYLower);
    $unitVectormagZYHL[0] = $MagVectorZYHigher *  unit($vectorZFlatYHigher);
    $unitVectormagZYHL[1] = $MagVectorZYLower * unit ($vectorZFlatYLower);
    return $unitVectormagZYHL;
    }
    proc float[] AddFloats(float $posA[], float  $posB[]){
    $AddposA_AND_posB_float = {($posA[0] + $posB[0]),  ($posA[1] + $posB[1]), ($posA[2] + $posB[2])} ;
    return $AddposA_AND_posB_float;
    }
    proc float[] SubtractFloats(float $posA[], float  $posB[]){
    $SubtractposA_AND_posB_float = {($posA[0] -  $posB[0]), ($posA[1] - $posB[1]), ($posA[2] -  $posB[2])} ;
    return $SubtractposA_AND_posB_float;
    }
    proc float[] multiplyFloatArray(float  $posA, float $posB[]){
    for($eachF in $posB){
    $Timespos[`size($Timespos)`] = $eachF*$posA;
    }
    return $Timespos;
    }
    proc vector FloatToVec(float $posA[]){
    $xvex = << $posA[0], $posA[1], $posA[2] >>  ;
    return $xvex;
    }
    proc float[] MakeCleanFloats(float $FloatZ[]){
    $POSAe = $FloatZ[0]; string $POSBe =  $FloatZ[1];
    $POSCe = $FloatZ[2];
    $nameAe = `match "e" $POSAe`;
    $nameBe = `match "e" $POSBe`;
    $nameCe = `match "e" $POSCe`;
    $zeroORZe1 = `gmatch "e" $nameAe`;
    $zeroORZe2 = `gmatch "e" $nameBe`;
    $zeroORZe3 = `gmatch "e" $nameCe`;
    if ( $zeroORZe1 == 1){ $FloatZ[0] = 0.0; }
    if ( $zeroORZe2 == 1){ $FloatZ[1] = 0.0; }
    if ( $zeroORZe3 == 1){ $FloatZ[2] = 0.0; }
    return $FloatZ;
    }
    proc float[] MakeCleanFloatsZ(float $FloatZ[]){
    $POSAe = FloatArrayToStringArray( $FloatZ);
    $index = 0;
    for ($eachS in $POSAe){
    $POSAe = $eachS;
    $nameAe = `match "e" $POSAe`;
    $zeroORZe1 = `gmatch "e" $nameAe`;
    if (( $zeroORZe1 == 1)||( $eachS == -0)){ $FloatZi[$index] = 0.0;
    }else{$FloatZi[$index] = $FloatZ[$index];}
    $index++;
    }
    return $FloatZi;
    }
    proc float[] MidPoint(float $loc1[],  float $loc2[]) {
    $a = ($loc2[0] + $loc1[0]) * (0.5);
    $b = ($loc2[1] + $loc1[1]) * (0.5);
    $c = ($loc2[2] + $loc1[2]) * (0.5);
    $vPoint = {$a , $b , $c};
    return $vPoint;
    }
    proc PAUSE(){
    playButtonStepForward;
    }
    proc averagingNode(string $firstObjectz, string  $averageObjectz, string $LastObjectz){
    $averaging[0] = `shadingNode -asUtility  plusMinusAverage`;
    setAttr ($averaging[0] + ".operation") 3;
    connectAttr -force ( $firstObjectz +  ".translate")($averaging[0] + ".input3D[1]");
    connectAttr -force ($averaging[0] + ".output3D") ("|" + $averageObjectz + ".translate");
    connectAttr -force ( $LastObjectz +  ".translate")($averaging[0] + ".input3D[0]");
    }
    proc ResetTranslation(string $oneItemz[]){
    xform -cp $oneItemz[0];
    $worldPos = `xform -q -ws -rp  $oneItemz[0]`;
    move -rpr 0 0 0  $oneItemz[0];
    makeIdentity -apply true  -t 1 -r 0 -s 0 $oneItemz[0];
    xform -t ($worldPos.x)  ($worldPos.y) ($worldPos.z) $oneItemz[0];
    }
    proc string[] RemoveNoLongerExistingFromArray (string $EdgeCurveZ1[]){
    $SizeOfArrayA = size($EdgeCurveZ1);
    if ( $SizeOfArrayA > 0){
    $SizeOfArray = size($EdgeCurveZ1) -1;
    $i = -1;
    $E = -1;
    while( $E < $SizeOfArray ){
    $i++;
    $E++;
    if ( `objExists $EdgeCurveZ1[$i]` == 0  ) {
    stringArrayRemoveAtIndex($i, $EdgeCurveZ1);
    if ($i == 0) { $i = -1;} else { $i = $i -1;}
    }
    }
    $SizeOfArrayB = size($EdgeCurveZ1);
    }
    return $EdgeCurveZ1;
    }
    proc int ISobjectSelectedTypeCurve(){
    $C = `ls -sl`;
    $nametypeZ = `ls -showType $C`;
    $nameA = `match "[a-zA-Z]+" $nametypeZ[0]`;
    $zeroOR1Z = `gmatch "Curve" $nameA`;
    return $zeroOR1Z;
    }
    proc int addNumbers(){
    $CreatedObjectCurve = `ISobjectSelectedTypeCurve`;
    return $CreatedObjectCurve;
    }
    proc int  PtsEquivalentF( float $posA[],  float $posB[], float $TRange){
    $pX = equivalentTol($posA[0], $posB[0], $TRange);
    $pY = equivalentTol($posA[1], $posB[1], $TRange);
    $pZ = equivalentTol($posA[2], $posB[2], $TRange);
    $addedResults = $pX + $pY + $pZ;
    if ($addedResults == 3 ){return 1;
    }else{
    return 0;}
    }
    proc CurveIndexVecTracking(string $OBJ[]){
    $OBJall = `sets -q CurveZSetOne` ;
    if(`size($OBJall)`>0){
    sets -remove CurveZSetOne $OBJall;
    }
    global string $GlobalObjOne[];
    global vector $ObjCurv[];
    sets -include CurveZSetOne $OBJ;
    eval("$GlobalObjOne= `sets -q CurveZSetOne`");
    eval("appendStringArray($GlobalObjListA,$GlobalObjOne, 1)");
    eval("vector $ObjCurv[] = PointArrayT($GlobalObjOne);");
    eval("$ObjVec[`size($ObjVec)`] =  $ObjCurv[0]");
    eval("sets -include ExistingCurveZSet $GlobalObjOne");
    sets -remove CurveZSetOne $OBJ;
    }
    proc EVALCamScripts(){
    $runit = "CatchMoveZCURVECAM2010($GlobalObjListA, $CamConeLocator, $ObjVec );";
    eval($runit); }
    proc string [] IntArrayToStringArray(int $IntArray[]){
    for($each in $IntArray){
    $Intnumbers += $each+" ";
    }
    $array = stringToStringArray($Intnumbers, " ");
    return $array;
    }
    proc string [] FloatArrayToStringArray(float $FloatArray[]){
    for($each in $FloatArray){
    $floatnumbers += $each+" ";
    }
    $array = stringToStringArray($floatnumbers, " ");
    return $array;
    }
    proc int [] CreateIntIndex(int $ArraySize){
    $iNdex = 0;
    while($iNdex < $ArraySize){
    $IntArrayInex[$iNdex] = $iNdex;
    $iNdex++;
    }
    return $IntArrayInex;
    }
    proc string curve2points(float $TanEnd1[], float $intersectposD1[]){
    $FixVec[0]  = << $TanEnd1[0], $TanEnd1[1], $TanEnd1[2]>>;
    $FixVec[1]  = <<$intersectposD1[0], $intersectposD1[1], $intersectposD1[2]>>;
    $sIZes = 2;
    $NUmers = CreateIntIndex($sIZes);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $curve = "curve -d 1";
    for ($eachVeCx in $FixVec){
    $valuesBi = $eachVeCx;
    $curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    }
    $curve += " "+ $K;
    $Newcurvez = `eval($curve)`;
    return $Newcurvez;
    }
    proc float[] multiplyFloat(float  $posA, float $posB[]){
    $TimesposA_AND_posB_float = {($posA * $posB[0]),  ($posA * $posB[1]), ($posA * $posB[2])} ;
    return $TimesposA_AND_posB_float;
    }
    proc int ArrayInsertAtEnd( string $INarray[],  string $NewItem){
    $SizeOfArray = size($INarray);
    $INarray[$SizeOfArray] = ( $NewItem );
    return $SizeOfArray;
    }
    proc ResetTransEachSL(){
    $oneItemz = `ls -sl`;
    for ($each in $oneItemz){
    xform -cp $each;
    $worldPos = `xform -q -ws -rp   $each`;
    move -rpr 0 0 0 $each;
    makeIdentity -apply true   -t 1 -r 0 -s 0 $each;
    xform -t ($worldPos.x)   ($worldPos.y) ($worldPos.z) $each;
    }
    }
    proc string [] NewArrayOrderWithIndexKey(string $stringIndexTrack[], string $ObjsCurve[]){
    for($each in $stringIndexTrack){
    $iNew = $each;
    stringArrayInsertAtIndex(`size($newOrderArray)`, $newOrderArray, $ObjsCurve[$iNew]);
    }
    return $newOrderArray;
    }
    proc float [] SortFloatArrayAndString( float $allFloatToSort[], string $ObjsCurve[], string $EmptyStringNewOrder[]){
    $Floatlist = $allFloatToSort;
    $sIze = `size($allFloatToSort)`-1;
    $aF = $allFloatToSort;
    $IndexTrack = CreateIntIndex(`size($aF)`);
    quickSort($aF, $IndexTrack, 0, $sIze);
    $stringIndexTrack = IntArrayToStringArray($IndexTrack);
    $newOrderArray = NewArrayOrderWithIndexKey($stringIndexTrack, $ObjsCurve);
    $EmptyStringNewOrder = $newOrderArray;
    return $aF;
    }
    proc string Circles_Direction(float $Point[], float $FloatDir[], float $FloatNum){
    -nr $FloatDir[0] $FloatDir[1] $FloatDir[2]
    -sw 360
    -r $FloatNum
    -d 3 -ut 0 -tol 0.001 -s 8 -ch 1`;
    return $circleItem[0];
    }
    proc  creatStereoCurve(){
    global string $VanishingPointsLinesTempGuides[];
    global int $addNumbersA;
    global string $StereoCurveZ[];
    global int $ifSingleCurve;
    global int $ForceOrthoOFFON;
    if(size($StereoCurveZ)>0){
    RemoveNoLongerExistingFromArray($StereoCurveZ);
    }
    if( $ForceOrthoOFFON == 1){
    $addNumbersA=-3;
    ForceOrtho($StereoCurveZ);
    }
    if( $ForceOrthoOFFON == 0){
    $x = $addNumbersA;
    print ($addNumbersA + "\n");
    if ($x == 1){
    $VanishingPointsLinesTempGuides = VanishingCurves($StereoCurveZ);
    if( $ifSingleCurve==1){
    delete $VanishingPointsLinesTempGuides;
    clear $VanishingPointsLinesTempGuides;
    clear $StereoCurveZ;
    $addNumbersA =0;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    $ifSingleCurve=0;
    }
    }
    if ($x == 2){
    StereoCurveZ($StereoCurveZ[0], $StereoCurveZ[1]);
    $addNumbersA =0;
    }
    }
    }
    proc vector[] NewVecOrderWithINTKey(int $IntIndexTrack[], vector $ObjsCurve[]){
    for($eachVi in $IntIndexTrack){
    $newOrderVec[`size($newOrderVec)`] = $ObjsCurve[$eachVi];
    }
    return $newOrderVec;
    }
    proc float [] MultLenToDirAddToPoint(float $Length, float $Dir[], float $Pos[]){
    $MultLengthDir = multiplyFloat($Length, $Dir);
    $AddMultDirPos = AddFloats($Pos, $MultLengthDir);
    return $AddMultDirPos;
    }
    proc int [] CreatePairIntIndex(int $AS){
    $Ai = 0;
    $Bi = 0;
    $N = 0;
    $Times = $AS*2;
    while($Bi < $Times){
    if($Ai == 0){$IntA[$Bi] = $N;}
    if($Ai == 1){ $Ai = -1; $IntA[$Bi] = $N;
    $N++; }
    $Ai++;
    $Bi++;
    }
    return $IntA;
    }
    proc vector [] GetRotationVectorsMatrix(matrix $mAtRiX[][]){
    $MatrizFloatiA = MatrixToFloat($mAtRiX);
    $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
    $VecR[0] = $VecAii;
    $VecAii = << $MatrizFloatiA[4], $MatrizFloatiA[5], $MatrizFloatiA[6]>>;
    $VecR[1] =$VecAii;
    $VecAii = << $MatrizFloatiA[8], $MatrizFloatiA[9], $MatrizFloatiA[10]>>;
    $VecR[2] = $VecAii;
    return $VecR;
    }
    proc vector MultPointMatrix( vector $PtsVec, matrix $mIA[][]){

    $MatrizFloatiA = MatrixToFloat($mIA);
    $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
    $VecR[0] = $VecAii;
    $VecAii = << $MatrizFloatiA[4], $MatrizFloatiA[5], $MatrizFloatiA[6]>>;
    $VecR[1] =$VecAii;
    $VecAii = << $MatrizFloatiA[8], $MatrizFloatiA[9], $MatrizFloatiA[10]>>;
    $VecR[2] = $VecAii;
    $RowA = $VecR[0];
    $RowB = $VecR[1];
    $RowC = $VecR[2];
    $GivenPoint = $PtsVec;
    $NewPoint = multiplyFloat($GivenPoint[0], $RowA);
    $NewPointa = multiplyFloat($GivenPoint[1], $RowB);
    $NewPointb = multiplyFloat($GivenPoint[2], $RowC);
    $NewPtMatrixMult = AddFloats($NewPoint, $NewPointa);
    $NewPtMatrixMult = AddFloats($NewPtMatrixMult, $NewPointb);
    $NewPoint[0] = (($RowA[0])*($GivenPoint[0])) + (($RowB[0])*$GivenPoint[1]) + (($RowC[0])*$GivenPoint[2]);
    $NewPoint[1] = (($RowA[1])*($GivenPoint[0])) + (($RowB[1])*$GivenPoint[1]) + (($RowC[1])*$GivenPoint[2]);
    $NewPoint[2] = (($RowA[2])*($GivenPoint[0])) + (($RowB[2])*$GivenPoint[1]) + (($RowC[2])*$GivenPoint[2]);
    $ReturnValVec = FloatToVec($NewPoint);
    return $ReturnValVec;
    }
    proc matrix FloatToMatrix(float $v[]){
    matrix $mat[4][4]=<<$v[0], $v[1], $v[2], $v[3];
    $v[4], $v[5], $v[6], $v[7];
    $v[8], $v[9], $v[10], $v[11];
    $v[12], $v[13], $v[14], $v[15]>>;
    return $mat;
    }
    proc float[] MatrixToFloat(matrix $FourByFour_matrix[][]){
    $FLOATindex = 0;
    $Inx = 0;
    $Inxb = 0;
    for($Inx = 0; $Inx <= 3; $Inx++){
    for($Inxb = 0; $Inxb <= 3; $Inxb++){
    $matrixFloat[$FLOATindex] = $FourByFour_matrix[$Inx][$Inxb];
    $FLOATindex++;
    }
    }
    return $matrixFloat;
    }
    proc vector PointToPlaneN( vector $Veciiv, vector $Vec[]){
    $pAv = AverageVectorPoint($Vec);
    $n = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    $DistanceLoc = distance2Pts(  $Veciiv, $pAv);
    $MultDirCam = multiplyFloat($DistanceLoc, $n);
    $FloatDirectionCamNormalA = AddFloats($pAv, $MultDirCam);
    $PointN = ClosestPoint2LineVec($n, $pAv, $Veciiv);
    $CombA = PointsEquivalentTol ($PointN, $pAv);
    if($CombA != 3){
    $FloatDirectionAi = DirectionFN($pAv,$PointN);
    $DistanceLoc = distance2Pts( $PointN, $pAv );
    $MultDirPC1 = multiplyFloat($DistanceLoc, $FloatDirectionAi);
    $AddMultMiiF = AddFloats($Veciiv, $MultDirPC1);
    $planePointN = << $AddMultMiiF[0], $AddMultMiiF[1], $AddMultMiiF[2]>>;
    }else{ $planePointN = $Veciiv;
    }
    return $planePointN;
    }
    proc string VecArrayToCurve(vector $FixVec[]){
    $sIZes = `size $FixVec `;
    $NUmers = CreateIntIndex($sIZes);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $curve = "curve -d 1";
    for ($eachVeCx in $FixVec){
    $valuesBi = $eachVeCx;
    $curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    }
    $curve += " "+ $K;
    $Newcurvez = `eval($curve)`;
    return $Newcurvez;
    }
    proc float [] EulerAngB(float $pointB1[], float $pointB2[]){
    $EulerAngleA = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
    return $EulerAngleA;
    }
    proc vector [] VecPtsToZMirrorPts(vector $AllLocPositionsZ[]){
    clear  $AllPlaneLocs;
    for ($eachVecEp in $AllLocPositionsZ){
    $Zx = $eachVecEp;
    $Zx[0] *= -1.0;
    $AllPlaneLocs[`size($AllPlaneLocs)`] = `FloatToVec ($Zx)`;
    }
    return $AllPlaneLocs;
    }
    proc int ISSelectedTypeCurve(){
    $C = `ls -sl`;
    $nametypeZi= `getTypeItemString $C`;
    $nameA = `match "[a-zA-Z]+" $nametypeZi`;
    $nameB = `match ".urve" $nameA`;
    $zeroOR1Z = `gmatch $nameB "*[C-c]urve*"`;
    return $zeroOR1Z;
    }
    proc int addCurveNumbers(int $addNumbersiA){
    $addNumbersiA++;
    if($addNumbersiA>2){$addNumbersiA=0;}
    return $addNumbersiA;
    }
    proc EvalAddingCurves(){
    global int $addNumbersA;
    $addNumbersA = addCurveNumbers($addNumbersA);
    print $addNumbersA;
    }
    proc float [] FloatPointsToCamPlane(float $LocPos1[]){
    $Pi = 3.1415926535;
    $pi = 3.1415926535;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $LivePlanePos = `xform -q -ws -t LiveSurfaceB`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $CamerasDirectionVector = $CamerasDirectionVectorNormal;
    $FloatDirectionA = DirectionFN($CamPos1, $LocPos1);
    $DistanceLoc = distance2Pts( $LocPos1, $CamPos1 );
    $DistanceLocA = $DistanceLoc;
    $DistanceLoc = $DistanceLoc * -1;
    $MultDirPC1 = multiplyFloat($DistanceLoc, $CamerasDirectionVector);
    $FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1);
    $CamerasDirectionVectorA = DirectionFN($FloatDirectionCamNormal, $CamPos1);
    $MultDirPC1A = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
    $FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1A);
    $p1 = $CamPos1;
    $p2 = $LocPos1;
    $p3 = $FloatDirectionCamNormal;
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );
    $FloatPosZero = {0, 0, 0};
    $FloatDirection = DirectionFN($FloatPosZero, $normal);
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $mid3 = midPoint2Pts( $p2, $p3 );
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    $FloatDirPerpCenterC = DirectionFN($center,$mid2);
    $FloatDirPointAC = DirectionFN($p1, $p3);
    $center8 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
    $FloatDirLocToPerpIntersect = DirectionFN($center8,$p2);
    $OnPlane = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );
    return $OnPlane;
    }
    proc float[] DirectionF(float $EACHCVposAZ[], float $EACHCVposBZ[]){
    $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]);


    $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
    $UnitDirection = $vectorUnit;
    return $UnitDirection;
    }
    proc float [] lineIntersectionF(float $PosA[], float $PosB[], float $PosC[], float $PosD[]){
    $DirAB = DirectionF ($PosA, $PosB);
    $DirCD = DirectionF ($PosC, $PosD);
    $locsA = lineIntersection($PosA, $DirAB, $PosC, $DirCD);
    return $locsA;
    }
    proc float[] pointMatrixMult( float $point[], float $matrix[] ){
    $result[0] = 0.0;
    $result[1] = 0.0;
    $result[2] = 0.0;
    if ( size($point) != 3 || size($matrix) != 16 )
    {
    warning (uiRes("m_pointMatrixMult.kPointArray"));
    return $result;
    }
    if ( catch($multNode = `createNode pointMatrixMult`) )
    {
    warning (uiRes("m_pointMatrixMult.kCouldNotCreateNode"));
    return $result;
    }
    setAttr ($multNode+".vectorMultiply") true;
    setAttr ($multNode+".inPoint") -type "double3" $point[0] $point[1] $point[2];
    setAttr ($multNode+".inMatrix") -type "matrix" $matrix[0] $matrix[1] $matrix[2] $matrix[3] $matrix[4] $matrix[5] $matrix[6] $matrix[7] $matrix[8] $matrix[9] $matrix[10] $matrix[11] $matrix[12] $matrix[13] $matrix[14] $matrix[15];
    $result = `getAttr ($multNode+".output")`;
    delete $multNode;
    return $result;
    }
    proc matrix MatrixCleanNegZero(matrix $m[][]){
    $MatrixA = `MatrixToFloat($m)`;
    $iX = 0;
    for ($eachFloat in $MatrixA){
    if(($eachFloat == 0)||($eachFloat == -0)){
    $CleanFLoats[`size($CleanFLoats)`] = 0.0;
    }else{$CleanFLoats[`size($CleanFLoats)`] = $eachFloat;}
    $iX++;
    }
    $CleanFLoats = MakeCleanFloatsZ($CleanFLoats);
    matrix $MatrixClean[4][4]= FloatToMatrix($CleanFLoats);
    return $MatrixClean;
    }
    proc int  PointsEquivalentTol( float $posA[],  float $posB[]){
    $pX = equivalentTol($posA[0], $posB[0],  0.001);
    $pY = equivalentTol($posA[1], $posB[1],  0.001);
    $pZ = equivalentTol($posA[2], $posB[2],  0.001);
    $addedResults = $pX + $pY + $pZ;
    return $addedResults;
    }
    proc string IteratCurve(float $step, string $paramlocatorpointOnCurvex, float $curveMin, int $FindSteps){
    $MasterCount = 0;
    $curve = "curve -d 3";
    while ($FindSteps < 4){
    $curve = "curve -d 3";
    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    if ( $CurvatureRadi <=  $curveMin){
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    $CountSteps++;
    }
    }
    $FindSteps = $CountSteps;
    if($FindSteps < 10){$curveMin += 18.0; $curve = "curve -d 3";  }
    if($MasterCount== 4){break;}
    $MasterCount++;
    }
    return $curve;
    }
    proc string VecArrayToCurveB(vector $FixVec[]){
    $sIZes = `size $FixVec `;
    $NUmers = CreateIntIndex($sIZes);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $K += "\-k"+" "+ $sIZes+" ";
    $sIZes++;
    $K += "\-k"+" "+ $sIZes+" ";
    $curve = "curve -d 3";
    for ($eachVeCx in $FixVec){
    $valuesBi = $eachVeCx;
    $curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    }
    $Newcurvez = `eval($curve)`;
    return $Newcurvez;
    }
    proc vector TwoVecsOrFloats(float $p1p2[], float $p1p3[]){
    $Ui = FloatToVec($p1p2);
    $Vi = FloatToVec($p1p3);
    $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;
    return $VEcLine;
    }
    proc int MostRightClockWiseInt ( vector $Vecs[], int $Two[]){
    $ThreePoints = { "0", "1", "2"};
    $point1 = FloatToVec($Vecs[0]);
    $point2 = FloatToVec($Vecs[1]);
    $point3 = FloatToVec($Vecs[2]);
    $U1 = TwoVecsOrFloats($point2, $point1);
    $V1 = TwoVecsOrFloats($point3, $point1);
    $U2 = TwoVecsOrFloats($point3, $point1);
    $V2 = TwoVecsOrFloats($point2, $point1);
    $U3 = TwoVecsOrFloats($point1, $point3);
    $V3 = TwoVecsOrFloats($point2, $point3);
    clear $normalV;
    $normalV[0] = FloatToVec( crossProduct( $U1, $V1, 0, 1 ) );
    $normalV[1] = FloatToVec( crossProduct( $U2, $V2, 0, 1 ) );
    $normalA = `unit ($normalV[0])`;
    $normalB = `unit ($normalV[1])`;
    $normalAAdd = $normalA[0] + $normalA[1];
    $normalAAdd2 = $normalB[0] + $normalB[1];
    if( $normalAAdd< $normalAAdd2){
    $TwoNew ={$Two[1], $Two[0]};
    }else{
    $TwoNew ={$Two[0], $Two[1]};
    }
    return $TwoNew[0];
    }
    proc float [] CreateIntIndexF(int $ArraySize, float $Fstep){
    $iNdex = 0;
    $AddF = 0;
    while($iNdex < $ArraySize){
    $AddF+= $Fstep;
    $FArrayInex[$iNdex] = $AddF;
    $iNdex++;
    }
    return $FArrayInex;
    }
    proc float AverageFloats(float $FloatArray[]){
    $Ix = 0;
    $AddAll = 0;
    for($eachF in $FloatArray){
    $AddAll+= $eachF;
    $Ix++;
    }
    $Divide = $AddAll/$Ix;
    return $Divide;
    }
    proc float [] GatherDataRR(float $Xt[], float $Av){
    $count = 0;
    for ($eachF in $Xt){
    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= -1;}
    if($count>0){
    if($PastF<$eachF){
    if($PastF<$Av){
    if(($PastF+$eachF/2.0)<$Av){
    $Vt[$count]= 1; }
    }
    }
    }
    $PastF = $eachF;
    $count++;
    }
    return $Vt;
    }
    proc string [] VecArrayToSplitCurve(vector $FixVec[]){
    $sIZes = `size $FixVec `;
    $evenOdd = fmod($sIZes, 2);
    $sIZesHalf = (($sIZes)/2)+1;
    $NUmers = CreateIntIndex($sIZesHalf);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $countN = 0;
    $curveA = "curve -d 1";
    for ($eachVeCx in $NUmers){
    $valuesBi  = $FixVec[$countN];
    $curveA += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    $countN++;
    }
    $curveA += " "+ $K;
    $curveB = "curve -d 1";
    $countN--;
    for ($eachVeCx in $NUmers){
    $valuesBi  = $FixVec[$countN];
    $curveB += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    $countN++;
    }
    $curveB += " "+ $K;
    $NewcurvezA = `eval($curveA)`;
    $NewcurvezB = `eval($curveB)`;
    $NewcurvezAB = {$NewcurvezA , $NewcurvezB};
    return $NewcurvezAB;
    }
    proc vector [] LineIntersectPlaneCam( vector $Vecii[], float $CamP[], vector $Vec[]){
    $pAv = AverageVectorPoint($Vec);
    $n = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    $CountVV = 0;
    for($eachVecLine in $Vecii){
    $FloatDirA  = DirectionF($eachVecLine, $CamP);
    $FloatDirNormalA = multiplyFloat(2, $FloatDirA);
    $MultDirA = AddFloats( $FloatDirNormalA, $eachVecLine);
    $DistanceLocA = distance2Pts(  $eachVecLine, $pAv);
    $MultDirCam  = multiplyFloat($DistanceLocA, $n);
    $FloatDirectionCamNormalA  = AddFloats($pAv, $MultDirCam);
    $PointN  = ClosestPoint2Line($n, $pAv, $eachVecLine);
    $FloatDirectionAi  = DirectionF($PointN, $pAv);
    $DistanceLoc = distance2Pts( $PointN, $pAv );
    $MultDirPC1  = multiplyFloat($DistanceLoc, $FloatDirectionAi);
    $FloatDirNormalDist  = AddFloats($eachVecLine, $MultDirPC1);
    $PointNii  = ClosestPoint2Line(DirectionF($PointN, $pAv), $eachVecLine, $MultDirA);
    $FloatDirectionAii  = DirectionF($PointNii, $MultDirA);
    $OnPlane[$CountVV] = FloatToVec (lineIntersection( $FloatDirNormalDist, $FloatDirectionAii, $eachVecLine, $FloatDirA));
    $CountVV++;
    }
    return $OnPlane;
    }
    proc vector FindIfCurveIsOrthoEpipol(vector $EpipolD[], vector $CRV_ENDS[], float $DistEnds, vector $LineMid){
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;
    if(`size($EpipolD)` == 3){
    $Xdirect = $EpipolD[0];
    $Ydirect = $EpipolD[1];
    $Zdirect = $EpipolD[2];
    }else{
    $Xdirect = << 1,0,0>>;
    $Ydirect = << 0,1,0>>;
    $Zdirect = << 0,0,1>>;
    }
    $XYZdirect[0] = $Xdirect;
    $XYZdirect[1] = $Ydirect;
    $XYZdirect[2] = $Zdirect;
    $LineAMain = PositiveDirectionLine($CRV_ENDS[0], $CRV_ENDS[1]);
    $EulerAngleA  = EulerAngB($Xdirect,$LineAMain);
    $EulerAngleB  = EulerAngB($Ydirect,$LineAMain);
    $EulerAngleC  = EulerAngB($Zdirect,$LineAMain);
    $EulerABCi[0]= $EulerAngleA[3];
    $EulerABCi[1]= $EulerAngleB[3];
    $EulerABCi[2]= $EulerAngleC[3];
    $stringF = FloatArrayToStringArray($EulerABCi);
    clear $EmptyIndx;
    $index = CreateIntIndex(3);
    $stringIndTr = IntArrayToStringArray($index);
    SortFloatArrayAndString( $EulerABCi, $stringIndTr, $EmptyIndx);
    $EmptyIndx = ReverseStringArray($EmptyIndx);
    $xyz = $EmptyIndx[0];
    $AxisOrthoLine = $xyz;
    $Anglei = $EulerABCi[$xyz];
    $NewDirectionZ = $XYZdirect[$xyz];
    $DistEnds= distance2Pts($CRV_ENDS[0], $CRV_ENDS[1]);
    $LineMid = ($CRV_ENDS[0] + $CRV_ENDS[1])/2.0;
    $AngleEpiPole = $Anglei;
    $isOrthoTrueZi = 0;
    if($Anglei < 8.55){
    $isOrthoTrueZi = 1;  print ("IsOrthoLineTrue :Anglei "+$Anglei+"\n");
    }
    print ("IsOrthoLineTrue :Anglei "+$Anglei+"\n");
    $IsOrthoLineTrue = $isOrthoTrueZi;
    return $NewDirectionZ;
    }
    proc int isCurveEndAtZY(vector $EndVectors[]){
    $Number = 0;
    for($eachVec in $EndVectors){
    $ThreeFs = $eachVec;
    if($ThreeFs[0] == 0){
    $Number++;
    }}
    return $Number;
    }
    proc string [] ForceOrtho(string  $CurveItemAX[]){
    global string $StereoCurveZ[];
    global int $addNumbersA;
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemAX[0];
    $Positions = VecCurveEps($CurveItemAX[0]);
    $TempCrv = VecArrayToCurve($Positions);
    delete $CurveItemAX[0];
    $VecCurEnds = VecCurveEnds({$TempCrv});
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEndsOLD = $queryLocCurveEnds;
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    if(`size($queryLocCurveEnds)` >= 2){
    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $distancesEachToCurveB = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    $ReducedIndexA = floatArrayCountDuplicates($distancesEachToCurve);
    $ReducedIndexB = floatArrayCountDuplicates($distancesEachToCurveB);
    for($eachInt in $ReducedIndexA){
    $distAz[`size($distAz)`]= $distancesEachToCurve[$eachInt];
    }
    for($eachInt in $ReducedIndexB){
    $distBz[`size($distBz)`]= $distancesEachToCurveB[$eachInt];
    }
    $NearestInt = SortNumbersIntIndex($distAz);
    $NearestIntB = SortNumbersIntIndex($distBz);
    $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$ReducedIndexA[$NearestInt[0]]];
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$ReducedIndexB[$NearestIntB[0]]];
    $NearestInt[0] =  $NewIntIndexAA;
    $NearestIntB[0] = $NewIntIndexBB;
    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];
    $LocA = $queryLocCurveEnds[$NearestInt[0]];
    $LocB = $queryLocCurveEnds[$NearestIntB[0]];
    clear $EndSnapAndEndProject;
    $Loc_AorB = "";
    if($NdistA<$NdistB){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    $Loc_AorB="B";
    }else{
    $Loc_AorB="A";
    $LocName =$LocB;
    $NearestIndex=$NearestIntB[0];
    $NearEndZ = $VecCurEnds[1];
    $endNotNearZ[0] = $VecCurEnds[0];}
    if($NdistA==$NdistB){
    $Loc_AorB="A";
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    }
    if($NearestInt[0]==$NearestIntB[0]){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    }
    $newNames = stringArrayToString($queryLocCurveEnds, " ");
    $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    $AllarrayCurvesNear = stringToStringArray($newNamesResultAX, " ");
    $NewFoundLocs[0]  = $AllarrayCurvesNear[$NearestIndex];
    $arrayCurvesNear[0] = $queryLocCurveEnds[$NearestIndex];

    $LocOnPlaneVec = PointArray($arrayCurvesNear );
    $Loc3D_Vec = PointArray($NewFoundLocs );
    $ALLLoc3D_VecAB = PointArray($AllarrayCurvesNear);
    if($Loc_AorB == "A"){
    $ReducedIndexXAB = $ReducedIndexA;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexA,$ALLLoc3D_VecAB);
    }
    if($Loc_AorB == "B"){
    $ReducedIndexXAB = $ReducedIndexB;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexB,$ALLLoc3D_VecAB);
    }
    $ALLLoc3D_Vec = $ReducedVecAB;
    $MovedEndPointPlane = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    $CRV_ENDSi[0]= $LocOnPlaneVec[0];
    $CRV_ENDSi[1]= $MovedEndPointPlane[0];
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);
    $MidCurveA = MidPoint($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
    $EpipolD = $DDirEpipolXYZ;
    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);
    $XYZdirectL[0] = << 1,0,0>>;
    $XYZdirectL[1] = << 0,1,0>>;
    $XYZdirectL[2] = << 0,0,1>>;
    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    $AxisOrthoLineA = $AxisOrthoLine;
    $Dir_CamRay =  DirectionFN($MovedEndPointPlane[0],$CamPos_A);
    $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);
    $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);
    $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    $XYZi  = $PointN_LineC;
    $XYZadd  = $PointN_LineC;
    $XYZi[0] = $XYZadd[0]+$XYZadd[1];
    $XYZi[1] = $XYZadd[1]+$XYZadd[2];
    $XYZi[2] = $XYZadd[0]+$XYZadd[2];
    $iVc = 0;
    clear $TrackFoundN;
    if($AxisOrthoLineA ==2){
    $TwoPointsi[0] = 0;
    }
    if($AxisOrthoLineA ==1){
    $TwoPointsi[0] = 2;
    }
    if($AxisOrthoLineA ==0){
    $TwoPointsi[0] = 1;
    }
    $AXIS = $AxisOrthoLineA;
    clear $ALLlikeness;
    $i = 0;
    $Dist_3DNear = (($Dist_3D/3.0)*2.0);
    for ($each in $ALLLoc3D_Vec){
    $One = $ALLLoc3D_Vec[$i];
    $XY[0] = $Xx  = $One.x;
    $XY[1] = $Yy  = $One.y;
    $XY[2] = $Zz  = $One.z;
    if( $ReducedIndexXAB[$iVc]!= $NearestIndex ){
    $TriggerPoints=0;
    if( (equivalentTol($XYZadd[0], $Xx,  0.01) )==1){
    $All_X[$i] = $Xx;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[1], $Yy,  0.01) )==1){
    $All_Y[$i] = $Yy;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[2], $Zz,  0.01) )==1){
    $All_Z[$i] = $Zz;
    $TriggerPoints++;
    }
    if( $TriggerPoints<2){
    $diffXYZ = `abs ($XY[$AXIS] - $XYZadd[$AXIS])`;
    if(($diffXYZ< $Dist_3DNear)&&($diffXYZ!=0)){
    $All_ZYX[`size($All_ZYX)`] =$XY[$AXIS];
    $All_ZYXDiff[`size($All_ZYXDiff)`] = $diffXYZ;
    }
    }
    if( $TriggerPoints==2){
    $ALLlikeness[`size($ALLlikeness)`] = $ReducedIndexXAB[$i];
    }
    }
    $i++;
    $iVc++;
    }
    if(`size($All_ZYXDiff)`> 0){
    $SortedForce = SortNumbersIntIndex($All_ZYXDiff);
    $newOrderFloat = $All_ZYX[$SortedForce[0]];
    }
    if(`size($ALLlikeness)`> 0){
    select -cl;
    for($eachIn in $ALLlikeness){
    select -add $AllarrayCurvesNear[$eachIn];
    PAUSE;
    }
    clear $NearPointsXYZ;
    $iVc =0;
    for($eachIn in $ALLlikeness){
    if( $iVc!= $NearestIndex ){
    $NearPointsXYZ[`size($NearPointsXYZ )`] =  $ALLLoc3D_VecAB[$eachIn];
    }
    $iVc++;
    }
    $distTo3DCurveEnd = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    $Sorted = SortNumbersIntIndex($distTo3DCurveEnd);
    $NearPointsXYZ = NewVecOrderWithINTKey($Sorted,$NearPointsXYZ);
    clear $SdistTo3DCurveEnd;
    for($eachIn in $Sorted){
    $SdistTo3DCurveEnd[`size($SdistTo3DCurveEnd)`] = $distTo3DCurveEnd[$eachIn];
    }
    $ReducedIndex = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    $ReducedVec = NewVecOrderWithINTKey($ReducedIndex,$NearPointsXYZ);
    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    $OntheSameLine = 0;
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $OntheSameLine =1;
    }
    $CountN = 0;
    for($eachVec in $ReducedVec){
    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $eachVec);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $PointN_LineXYZ = $eachVec;
    print " on same Line ";
    }else{
    $PointN_LineXYZ  = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $eachVec);
    }
    if( (distance2Pts($PointN_LineXYZ, $PointN_LineC))>0.001){
    $LocsV[`size($LocsV)`] = `Loc $PointN_LineXYZ`;
    $CurvesV[`size($CurvesV)`] = curve2points($eachVec, $PointN_LineXYZ);
    PAUSE;
    }
    if($CountN==0){
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapN = $eachVec;
    $SnapPlaceN = $PointN_LineXYZ;
    }
    if($CountN!=0){
    print  $DistSnap;
    if((distance2Pts($PointN_LineXYZ, $PointN_LineC))<  $DistSnap){
    $SnapN = $eachVec;
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapPlaceN = $PointN_LineXYZ;
    }
    }
    $CountN++;
    }
    $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);
    delete $CurvesV;
    delete $LocsV;
    if(($EulerAngleA[3] >85)&&($EulerAngleA[3]<95)){
    $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    if($Dist_3DSnap<($Dist_3D/2.0)){
    cycleBackgroundColor;
    PAUSE;
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    $AddInt = $AdditR;
    if($AddInt == 0){
    $PointN_LineC = $SnapPlaceN;
    PAUSE; PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }else{
    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $FPointN_LineC =  $PointN_LineC;
    $FPointN_LineC[$AXIS] = $newOrderFloat;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }
    }else{
    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }
    $Points3DPair_And_2DPair[0]= $Loc3D_Vec[0];
    $Points3DPair_And_2DPair[1]= $PointN_LineC;
    $Points3DPair_And_2DPair[2]= $LocOnPlaneVec[0];
    $Points3DPair_And_2DPair[3]= $NewPlanePoint;
    delete $TempCrv;
    $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 10 -d 3 -tol 0.05 $CurvesVi;
    $Crv_Pts = VecCurveEps($CurvesVi );
    $MirrorAcrossPlaneVecs = VecMultMatrixMirror($Crv_Pts);
    $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    clear $StereoCurveZ;
    $BothCurves[0] = $CurvesVi;
    $BothCurves[1] = $TheSecondCurve;
    $StereoCurveZ = $BothCurves;
    $addNumbersA =-3;
    ResetTranslation($BothCurves);
    CurveIndexVecTracking($BothCurves);
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $BothCurves;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    clear $StereoCurveZ;
    }
    return $BothCurves;
    }
    proc int [] floatArrayCountDuplicates(float $listX[]){
    $list = $listX;
    $index = 0;
    $X = 0;
    $Xi = 0;
    $C = 0;
    $result = $list;
    for ($item in $list) {
    $NumberE[$X] = floatArrayCount($item, $result);
    if (1 == $NumberE[$X]) {
    $NoneDup[`size($NoneDup)`] = $Xi;
    }else{
    if (1 < $NumberE[$X]) {
    floatArrayRemoveAtIndex($X, $result);
    $X--;
    }
    }
    $Xi++;
    $X++;	}
    return $NoneDup;
    }
    proc int floatArrayCount(float $item, float $list[]){
    $result = 0;
    for ($listItem in $list) {
    if ($item == $listItem) $result++;	}
    return $result;
    }
    proc int floatArrayRemoveAtIndex( int $index, float $list[] ){
    $len = size( $list );
    if( $index > $len  || $index < 0 ){
    return( false );
    }
    for( $i = 0; $i < $index; $i++ ){
    $result[$i] = $list[$i];
    }
    for( ; $i < $len - 1; $i++ ){
    $result[$i] = $list[$i + 1];
    }
    $list = $result;
    return( true );
    }
    proc vector [] VecMultMatrixMirror(vector $pointZ[]){
    matrix $m2[4][4]= <<	-1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0>>;
    $MatrixB = `MatrixToFloat($m2)`;
    for($eachVec in $pointZ){
    $FLoatPointA[`size($FLoatPointA)`] = FloatToVec(pointMatrixMult( $eachVec, $MatrixB ));
    }
    return $FLoatPointA;
    }
    proc vector [] MoveVectors(vector $Pos_A, vector $VecLoc, vector $Crv_Pts[]){
    $DirLine = DirectionFN( $VecLoc, $Pos_A);
    $DistToPoint = distance2Pts($Pos_A, $VecLoc);
    clear $TranstatedVecs;
    for($eachVector in $Crv_Pts){
    $TranstatedVecs[`size($TranstatedVecs)`] = ($eachVector+($DistToPoint*$DirLine));
    }
    return $TranstatedVecs;
    }
    proc string [] VanishingCurves( string  $CurveItemA[]){
    global string $VanishingPointsLinesTempGuides[];
    global int $ifSingleCurve;
    $SnapD = 0.003;
    global vector $TempVectorsCrv[];
    if(size($TempVectorsCrv)>0){
    clear $TempVectorsCrv;}
    $Positions = VecCurveEps($CurveItemA[0]);
    $TempCrv = VecArrayToCurve($Positions);
    delete $CurveItemA[0];
    $CurveItemA[0] = VecArrayToCurve($Positions);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 3 -tol 0.05 $CurveItemA[0];
    SetItemColorString ($CurveItemA[0], 9);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $TempCrv;
    $PositionsZ_Ax = VecCurveEps($TempCrv);
    $ZYplaneMatrix[0] = <<0, 0, 0>>;
    $ZYplaneMatrix[1] = <<0, 1, 0>>;
    $ZYplaneMatrix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $TempVectorsCrv  = LineIntersectPlaneCam( $PositionsZ_Ax, $CamPos1, $ZYplaneMatrix);
    delete $TempCrv;
    $Pi = 3.1415926535;
    $pi = 3.1415926535;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $CamerasDirectionVector = $CamerasDirectionVectorNormal;
    $MultDirForWard = multiplyFloat(-1, $CamerasDirectionVector);
    $MultDirCam = multiplyFloat(-3, $CamerasDirectionVector);
    $FloatDirectionCamNormalA = AddFloats($CamPos1, $MultDirCam);
    $DirectionVectorXn = {-2,0,0};
    $DirectionVectorX = {2,0,0};
    $DirectionVectorY = {0,-2,0};
    $DirectionVectorYn = {0,2,0};
    $DirectionVectorZn = {0,0,-2};
    $DirectionVectorZ = {0,0,2};
    $VecDirection_A_XYZ[0] = <<-2,0,0>>;
    $VecDirection_A_XYZ[1] = <<2,0,0>>;
    $VecDirection_A_XYZ[2] = <<0,2,0>>;
    $VecDirection_A_XYZ[3] = <<0,-2,0>>;
    $VecDirection_A_XYZ[4] = <<0,0,-2>>;
    $VecDirection_A_XYZ[5] = <<0,0,2>>;
    $VecDirectionXYZ[0] = <<-1,0,0>>;
    $VecDirectionXYZ[1] = <<1,0,0>>;
    $VecDirectionXYZ[2] = <<0,1,0>>;
    $VecDirectionXYZ[3] = <<0,-1,0>>;
    $VecDirectionXYZ[4] = <<0,0,-1>>;
    $VecDirectionXYZ[5] = <<0,0,1>>;
    $FloatPointDirectionXn = AddFloats($CamPos1, $DirectionVectorXn);
    $FloatPointDirectionX = AddFloats($CamPos1, $DirectionVectorX);
    $FloatPointDirectionY = AddFloats($CamPos1, $DirectionVectorY);
    $FloatPointDirectionYn = AddFloats($CamPos1, $DirectionVectorYn);
    $FloatPointDirectionZn = AddFloats($CamPos1, $DirectionVectorZn);
    $FloatPointDirectionZ = AddFloats($CamPos1, $DirectionVectorZ);
    clear $VecXYZs;
    $VecXYZs[0] = FloatToVec($FloatPointDirectionXn);
    $VecXYZs[1] = FloatToVec($FloatPointDirectionX);
    $VecXYZs[2] = FloatToVec($FloatPointDirectionY);
    $VecXYZs[3] = FloatToVec($FloatPointDirectionYn);
    $VecXYZs[4] = FloatToVec($FloatPointDirectionZn);
    $VecXYZs[5] = FloatToVec($FloatPointDirectionZ);
    $VecXYZsOnPlane = VecPointsToCameraPlane($VecXYZs);
    $AverageVecXYZsOnP = AverageVectorPoint($VecXYZsOnPlane);
    $DirectionsZ = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    $FloatDirxyz[0] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[0]));
    $FloatDirxyz[1] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[1]));
    $FloatDirxyz[2] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[3]));
    $FloatDirxyz[3] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[2]));
    $FloatDirxyz[4] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[4]));
    $FloatDirxyz[5] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[5]));
    $Alll = "";
    clear $AllStrings $AnglesAll ;
    for ($eachOrthD in $VecDirectionXYZ){
    $EulerAngleA = EulerAngB($eachOrthD, $CamerasDirectionVector);
    $AnglesAll[`size($AnglesAll)`]= $EulerAngleA[3];
    $stringFloat = FloatArrayToStringArray($EulerAngleA);
    $Alll  = stringArrayToString($stringFloat, " ");
    $AllStrings[`size($AllStrings)`]= $Alll;
    }
    clear $EmptyIndxNewOrder;
    $indexAx = CreateIntIndex(6);
    $stringIndTr = IntArrayToStringArray($indexAx);
    $ANgnew = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
    $EmptyIndxNewOrder = ReverseStringArray($EmptyIndxNewOrder);
    $BestThree = {$EmptyIndxNewOrder[0], $EmptyIndxNewOrder[1], $EmptyIndxNewOrder[2]};
    $BestThree = ReverseStringArray($BestThree);
    $BestThree = stringArrayRemoveDuplicates ($BestThree);
    $indexAxNew = ArrayToIntList( $BestThree);
    $VecCurEnds = VecCurveEnds($CurveItemA);
    $LengCRV_a = `arclen $CurveItemA`;
    $DistEndsi = distance2Pts($VecCurEnds[0], $VecCurEnds[1]);
    $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
    $AverageVecCurEndsP = AverageVectorPoint($VecCurEnds);
    $Count = 0;
    $CurvePsD = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
    size($EmptyIndxNewOrder);
    $DirectionsZ = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    clear $colori;
    $iiX = 0;
    for($eachDirection in $indexAxNew){
    if($eachDirection ==0 || $eachDirection ==1){$colori[`size($colori)`] = 13;}
    if($eachDirection ==3 || $eachDirection ==2){$colori[`size($colori)`] = 14;}
    if($eachDirection ==4 || $eachDirection ==5){$colori[`size($colori)`] = 6;}
    }
    clear $CurvesV;
    $Cindex = 0;
    for ($eachDii in $indexAxNew){
    $IndexZ = $indexAxNew[$Count];
    $FloatPointDirectionZniY  = AddFloats( $VecCurEnds[1], $VecDirection_A_XYZ[$IndexZ]);
    $VecXYZsOnPlaneiY = VecPointsToCameraPlane($FloatPointDirectionZniY);
    $CurveDirectionZiY =  DirectionF($VecCurEnds[1],  $VecXYZsOnPlaneiY[0]);
    $FloatPointDirectionZniiY = AddFloats( $VecCurEnds[0], $VecDirection_A_XYZ[$IndexZ]);
    $VecXYZsOnPlaneiiY = VecPointsToCameraPlane($FloatPointDirectionZniiY);
    $CurveDirectionZiiY =  DirectionF($VecCurEnds[0],  $VecXYZsOnPlaneiiY[0]);
    $locsAi = lineIntersection($VecCurEnds[1], $CurveDirectionZiY, $VecCurEnds[0],  $CurveDirectionZiiY);
    $EpipLolar[$Count] = FloatToVec($locsAi);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[0], $locsAi);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], $colori[$Cindex]);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[1], $locsAi);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], $colori[$Cindex]);
    editDisplayLayerMembers -noRecurse VanishingPointsLines $CurvesV;
    $Cindex++;
    $Count++;
    }
    $ifSingleCurve = 0;
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);
    $HighCurvePoints = CurvatureUtilityCurvature($CurveItemA[0], 60);
    $Cindex = 0;
    if(`size($HighCurvePoints)`>0){
    for ($eachVec in $HighCurvePoints){
    $CurvesV[`size($CurvesV)`] = curve2points($eachVec, $MidEpipolPosFCam);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 11);
    }
    }
    $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
    $Dir_VecA =   PositiveDirectionLine($VecCurEnds[0],$VecCurEnds[1]);
    $VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    $INTERSECTIONLA = lineIntersectionF($VecCurEnds[0], $EpipLolar[0], $VecCurEnds[1],  $EpipLolar[1]);
    $INTERSECTIONLB = lineIntersectionF($VecCurEnds[1], $EpipLolar[0], $VecCurEnds[0],  $EpipLolar[1]);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[0],$INTERSECTIONLA);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 14);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[1],$INTERSECTIONLB);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 14);
    $CurvesV[`size($CurvesV)`] = curve2points($EpipLolar[2],$INTERSECTIONLA);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 4);
    $CurvesV[`size($CurvesV)`] = curve2points($EpipLolar[2],$INTERSECTIONLB);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 4);
    $VecPtsMirrorEnds_A= VecPtsToZMirrorPts( $VecCurEnds);
    $triggerMiddle = 0;
    $VIntersectEnds_A[0] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[1], $CamPos_M, $VecPtsMirrorEnds_A[0]));
    $VIntersectEnds_A[1] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[0], $CamPos_M, $VecPtsMirrorEnds_A[1]));
    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
    $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
    $IntersectEnds_Ai =  FloatPointsToCamPlane($VIntersectEnds_A[0]);
    $IntersectEnds_Bi = FloatPointsToCamPlane($VIntersectEnds_A[1]);
    $CurveItemAa[0] = $CurveItemA[0];
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEndsOLD = queryLocOnLivePlaneBLayer();
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    if(`size($queryLocCurveEnds)` > 2){
    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $NearestInt = SortNumbersIntIndex($distancesEachToCurve);
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[0]];
    $distancesEachToCurveB = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    $NearestIntB = SortNumbersIntIndex($distancesEachToCurveB);
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$NearestIntB[0]];
    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];
    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    $iv = -1;
    $distsA = $NdistA;
    $distsB = $NdistB;
    for (  $i = 1; $i < 5; $i++) {
    if( $distsA < $distsB){
    $NdistA = $distancesEachToCurve[$NearestInt[$i]];
    if($iv==-1){
    $iv++;
    $StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[0]];}
    if (equivalentTol($NdistA, $distsA, 0.001) == 1){
    $StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[$i]];
    }
    }
    }
    $newNames = stringArrayToString( $StringAllNearA, " ");
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    $arrayCurvesNearA = stringToStringArray($newNamesResultC, " ");
    $CRV_index_number = 0;
    $CRc = 0;
    $CRcT = 0;
    for($eachCurve in $arrayCurvesNearA){
    if(`sets -im ZEdgeCurvesSet $eachCurve` ==1){
    $CRV_index_number = $CRc;
    $CRcT++;
    break;
    }
    $CRc++;
    }
    if($CRcT ==1){
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[$CRc]];
    }
    }
    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];
    $newNames = stringArrayToString($EmptyStringNewOrderA, " ");
    $newNamesResultAx = substituteAllString($newNames, "Plane", "");
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    $arrayCurvesNear = stringToStringArray($newNamesResultC, " ");
    $NearCurvesEnds[0] = $arrayCurvesNear[0];
    $NearCurvesEnds[1] = $arrayCurvesNear[1];
    $arrayCurvesNearA1 = stringToStringArray($newNamesResultAx, " ");
    $LocCurveEndsVec_3D = PointArray($arrayCurvesNearA1);
    $LoCz_3D = $LocCurveEndsVec_3D;
    $TXI = << -1.0 , 1.0, 1.0>>;
    $LoCz_3D[2] = MultVec($LoCz_3D[0],$TXI);
    $LoCz_3D[3] = MultVec($LoCz_3D[1], $TXI);
    $countS = 0;
    for($eachItemVEC in $LoCz_3D){
    $VanishingLOC[ size($VanishingLOC) ] = Loc($eachItemVEC);
    if(($countS==0)||($countS==2)){
    SetItemColorString ($VanishingLOC[ size($VanishingLOC) -1], 19);
    setAttr ( $VanishingLOC[ size($VanishingLOC) -1]+".scale") 4.0 4.0 4.0;
    }else{SetItemColorString ($VanishingLOC[size($VanishingLOC)-1], 18);
    setAttr ( $VanishingLOC[ size($VanishingLOC) -1]+".scale") 9.0 9.0 9.0;
    }
    $countS++;
    }
    $PtsM_Ai = FloatPointsToCamPlane($LoCz_3D[2]);
    $PtsM_Bi = FloatPointsToCamPlane($LoCz_3D[3]);
    $INTERSECTIONLC = lineIntersectionF($EpipLolar[0], $PtsM_Ai, $INTERSECTIONLA, $EpipLolar[2]);
    $CurvesV[`size($CurvesV)`] = curve2points($PtsM_Ai,$INTERSECTIONLC);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 14);
    $INTERSECTIONL2C = lineIntersectionF($EpipLolar[0], $VecCurEnds[0], $INTERSECTIONLC, $EpipLolar[2]);
    $CurvesV[`size($CurvesV)`] = curve2points($INTERSECTIONLC,$INTERSECTIONL2C);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 4);
    $INTERSECTIONL2D = lineIntersectionF($EpipLolar[1],$INTERSECTIONLC, $VecCurEnds[1],  $EpipLolar[2]);
    $INTERSECTIONL3D = lineIntersectionF($EpipLolar[0],$INTERSECTIONL2D,$PtsM_Ai,  $EpipLolar[1]);
    $CurvesV[`size($CurvesV)`] = curve2points($INTERSECTIONL2D,$INTERSECTIONL3D);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 14);
    $CurvesV[`size($CurvesV)`] = curve2points($PtsM_Ai,$INTERSECTIONL3D);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 6);
    $CurvesV[`size($CurvesV)`] = curve2points($INTERSECTIONLC,$INTERSECTIONL2D);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 6);
    $CurvesV[`size($CurvesV)`] = curve2points($INTERSECTIONL2C,$VecCurEnds[1]);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 6);
    appendStringArray($CurvesV, $VanishingLOC, size($VanishingLOC));
    $edgeZsetA = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[0]`;
    $edgeZsetB = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[1]`;
    $COuntN = 0;
    for($eachVec in $LocCurveEndsVec_3D){
    $ThreepointVecs = $eachVec;
    if (equivalentTol($ThreepointVecs[0], 0.00, 0.001) == 1){
    $EDGEpoints[$COuntN]= 1;
    }else{$EDGEpoints[$COuntN]= 0;}
    $COuntN++;
    }
    $edgeZsetA =$EDGEpoints[0];
    $edgeZsetB =$EDGEpoints[1];
    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    if(($NearCurvesEnds[0] == $NearCurvesEnds[1])&&( ($edgeZsetA+$edgeZsetB) ==2)){
    if($NdistA<$NdistB){
    $edgeZsetA =1;
    $edgeZsetB =0;
    }
    if($NdistA>$NdistB){
    $edgeZsetA =0;
    $edgeZsetB =1;
    }
    if($edgeZsetA==0){$NdistA=100;}
    if($edgeZsetB==0){$NdistB=100;}
    }
    }
    if(($NdistA>$SnapD)&&($NdistB>$SnapD)){
    $edgeZsetA =0;
    $edgeZsetB =0;
    }
    }
    if(($edgeZsetA==1)&&($NdistA<$SnapD)){
    $pointNearEdgeCurve[0]= 1;
    }
    if(($edgeZsetA==1)&&($NdistA>$SnapD)){
    $pointNearEdgeCurve[0]= 0;
    }
    if(($edgeZsetA==0)&&($NdistA>$SnapD)){
    $pointNearEdgeCurve[0]= 0;
    }
    if(($edgeZsetA==0)&&($NdistA<$SnapD)){
    $pointNearEdgeCurve[0]= 2;
    }
    if(($edgeZsetB==1)&&($NdistB<$SnapD)){
    $pointNearEdgeCurve[1]= 1;
    }
    if(($edgeZsetB==1)&&($NdistB>$SnapD)){
    $pointNearEdgeCurve[1]= 0;
    }
    if(($edgeZsetB==0)&&($NdistB>$SnapD)){
    $pointNearEdgeCurve[1]= 0;
    }
    if(($edgeZsetB==0)&&($NdistB<$SnapD)){
    $pointNearEdgeCurve[1]= 2;
    }
    if($edgeZsetA==1){
    $EdgeDist =$NdistA;
    }else{$EdgeDist=$NdistB;}
    $SnappingVector = 0;
    if($NdistA<$NdistB){
    $SnappingVector=0;
    }else{$SnappingVector=1;}
    if($NdistA>$SnapD){
    $edgeZsetA = 0;
    }
    if($NdistB>$SnapD){
    $edgeZsetB = 0;
    }
    $OneIsNotNearThePlane = 0;
    if(($NdistA>$SnapD)||($NdistB<$SnapD)){
    if(($NdistA<$SnapD)||($NdistB>$SnapD)){
    $OneIsNotNearThePlane =1;
    }
    }
    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    if(($edgeZsetA==1)||($edgeZsetB==1)){
    $EdgeDist =0.001;
    }
    }
    if($pointNearEdgeCurve[0]+$pointNearEdgeCurve[1]== 1){
    $newNamesResultA1 = substituteAllString($newNames, "Plane", "");
    $ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
    $ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
    $A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
    $A= `MakeCleanFloats($A)`;
    $B= `MakeCleanFloats($B)`;
    if(($A[0] ==0)||($B[0] ==0)){
    $triggerMiddle =2;
    $ifSingleCurve=1;
    if($edgeZsetA==1){
    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
    $NearVecPts[1]= $VecCurEnds[1];
    }else{
    $NearVecPts[0]= $VecCurEnds[0];
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
    }
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    if($EdgeDist<2.5){
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    $PositionsZ_Aii = $PositionsZ_Ai;
    }
    $PositionsZ_Aiix[0] = <<0, 0, 0>>;
    $PositionsZ_Aiix[1] = <<0, 1, 0>>;
    $PositionsZ_Aiix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    if($EdgeDist<2.5){
    $VecTest  = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
    }else{$VecTest  = LineIntersectPlaneCam($PositionsZ_A, $CamPos1, $PositionsZ_Aiix);
    }
    $CurveAv[0] = VecArrayToCurveB($VecTest);
    }
    }
    if( $pointNearEdgeCurve[1]==1){
    $newNamesResultA1 = substituteAllString($newNames, "Plane", "");
    $ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
    $ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
    $A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
    $A = MakeCleanFloatsZ($A);
    $B = MakeCleanFloatsZ($B);
    if(($A[0] ==0)&&($B[0] ==0)){
    $triggerMiddle =2;
    $ifSingleCurve=1;
    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    delete $CurveItemA;
    $CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);
    $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    if($DiffMathA >97.0){
    $PositionsZ_Aii[0] = $NearVecPts[0];
    $PositionsZ_Aii[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
    $PositionsZ_Aii[2]= $NearVecPts[1];
    } else{
    $PositionsZ_Aii = $PositionsZ_Ai;}
    $PositionsZ_Aiix[0] = <<0, 0, 0>>;
    $PositionsZ_Aiix[1] = <<0, 1, 0>>;
    $PositionsZ_Aiix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $VecTest = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
    if($DiffMathA >95.0){	$CurveAv[0] = VecArrayToCurve($VecTest);}else{
    $CurveAv[0] = VecArrayToCurve($VecTest);}
    }
    }
    if($triggerMiddle==0){
    if($GetSizeOfCRV_ends>0){
    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);
    $distancesTo3DCurveEnd = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
    $Sorted = SortNumbersIntIndex($distancesTo3DCurveEnd);
    $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
    $distancesTo3DCurveEndi = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
    $Sortedi = SortNumbersIntIndex($distancesTo3DCurveEndi);
    $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
    $FistAndSecond[0]=$LocCurveEndsVec3D[$Sorted[0]];
    $FistAndSecond[1]=$LocCurveEndsVec3D[$Sortedi[0]];
    $LocNames[0]=$queryLocCurveEnds3D[$Sorted[0]];
    $LocNames[1]=$queryLocCurveEnds3D[$Sortedi[0]];
    $LocNames[2]=$queryLocCurveEnds3D[$Sorted[1]];
    $LocNames[3]=$queryLocCurveEnds3D[$Sortedi[1]];
    $VecA = $FistAndSecond[0];
    $VecB = $FistAndSecond[1];
    $XX = $VecA.x;
    $XXX = $VecB.x;
    if( ($XX*-1)==$XXX){
    if($NptsDist<2.5){
    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($VecA));
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($VecB));
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    delete $CurveItemA;
    $CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);
    $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    clear $PositionsZ_A;
    if($DiffMathA >97.0){
    $PositionsZ_Ai[0] = $NearVecPts[0];
    $PositionsZ_Ai[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
    $PositionsZ_Ai[2]= $NearVecPts[1];
    }else{
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    }
    $ReversePositionsZ_Ai = ReverseVectorArray($PositionsZ_Ai);
    clear $PtsMirrorAi;
    $PtsMirrorAi= VecPtsToZMirrorPts($ReversePositionsZ_Ai);
    $iiz = 0;
    clear $XIntersect_Ax;
    for ($eachVecx in  $ReversePositionsZ_Ai){
    $XIntersect_Ax[`size($XIntersect_Ax)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_Ai[$iiz], $CamPos_M, $PtsMirrorAi[$iiz]));
    $iiz++;
    }
    if($DiffMathA >97.0){
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    }
    $CurveAv =  VecArrayToSplitCurve($XIntersect_Ax);
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
    $evalSmoothi += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmoothi);
    $ifSingleCurve=1;
    }
    }
    }
    }
    if(( $ifSingleCurve == 1)&&($triggerMiddle ==0)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[1];
    sets -include ZEdgeCurvesSet $CurveAv;
    }else{
    if(( $ifSingleCurve == 1)&&($triggerMiddle ==1)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    }
    }
    if( ($ifSingleCurve == 1)&&($triggerMiddle ==2)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv;
    $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    sets -include ZEdgeCurvesSet $CurveAv;
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    }
    $VanishingPointsLinesTempGuides = $CurvesV;
    editDisplayLayerMembers -noRecurse VanishingPointsLines $CurvesV;
    select -cl  ;
    return $CurvesV;
    }
    proc vector [] VecPointsToCameraPlane(vector $V[]){
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+($D1*$F3);
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    return $O;
    }
    proc vector [] CurvatureUtilityCurvature(string $curvesZ, int $NumberofSteps){
    $myCurve = $curvesZ;
    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum2 = (( $numEPs -1 ) * 2 );
    $numEPrealNum2 = $NumberofSteps;
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    $step = $numEPrealNum2;
    $StepCycle = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi[$ii] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    $CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
    $ii++;
    }
    $CurvatureRadi = AverageCurveFloat( $CurvatureRadi);
    $AverageC = AverageFloats($CurvatureRadi);
    $AboveOrBelow = GatherDataRR($CurvatureRadi, ($AverageC-(($AverageC/6.0)*5.0)));
    $COuntNN = 0;
    for($eachFloat in $AboveOrBelow){
    if($eachFloat ==1){
    $ReturnVec[`size($ReturnVec)`] = $CurveVectors[$COuntNN];
    }
    $COuntNN++;
    }
    delete $paramlocatorpointOnCurvex;
    return $ReturnVec;
    }
    proc float [] AverageCurveFloat( float $newVec[]){
    $range = 3;
    $TotalS = `size($newVec)`;
    $indexState = 0;
    while($indexState<$TotalS){
    $countS=1;
    $Xs=0;
    while($countS<$range){
    $indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
    $indexRight = fmod(($indexState + $countS),$TotalS);
    $indexLeftS[$Xs] = $indexLeft;
    $indexRightS[$Xs]= $indexRight;
    $countS++;
    $Xs++;
    }
    $Aver = ((($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0) + ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec [$indexState])/4.0;
    $AVvects[$indexState] = $Aver;
    clear $indexLeftS;
    clear $indexRightS;
    $indexState++;
    }
    return $AVvects;
    }
    proc vector [] VecCurveEnds(string $CurveItem[]){
    $numCVsL = `getAttr -size ($CurveItem[0]+".controlPoints")`-1;
    $numCVsSL = $numCVsL-1;
    $CRVendPts[0] = ($CurveItem[0] + ".cv[0]") ;
    $CRVendPts[1] = ($CurveItem[0] + ".cv[" +  $numCVsL + "]") ;
    for($i = 0; $i < 2;$i++){
    $CRV_EndsVec[$i]= `pointPosition -w ($CRVendPts[$i])`;
    }
    return $CRV_EndsVec;
    }
    proc vector ClosestPoint2LineVecX(float $DirectionLineF[], float $PointOnLine[], float  $PointN[]){
    $VecLineDiri = DirectionFN($PointOnLine, $PointN);
    $VecLineDir = $VecLineDiri;
    $MultDirOne = multiplyFloat(1.0, $DirectionLineF);
    $AddMultF = AddFloats($PointOnLine, $MultDirOne);
    $FDirNorA = Normal3Points($PointOnLine, $AddMultF, $PointN);
    $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    $MultDirMx = multiplyFloat($DistToLineSTart, $FDirNorA);
    $AddMultMiiFx = AddFloats($PointOnLine, $MultDirMx);
    $FDirNorB = Normal3Points($PointOnLine, $AddMultMiiFx,  $AddMultF);
    $MultDirMxz = multiplyFloat($DistToLineSTart,  $FDirNorB);
    $AddMultMiiFxz = AddFloats($PointOnLine, $MultDirMxz);
    $locsA = lineIntersection($PointN, $FDirNorB, $PointOnLine,  $DirectionLineF);
    $VlocA = <<$locsA[0],$locsA[1],$locsA[2]>>;
    return $VlocA;
    }
    proc vector [] CRVEndNormals( string $CurveItem ){
    $numCVsL = `getAttr -size ($CurveItem+".controlPoints")`-1;
    $numCVsSL = $numCVsL-1;
    $CRVendPts[0] = ($CurveItem + ".cv[0]") ;
    $CRVendPts[1] = ($CurveItem + ".cv[1]") ;
    $CRVendPts[2] = ($CurveItem + ".cv[" +  $numCVsSL + "]") ;
    $CRVendPts[3] = ($CurveItem + ".cv[" +  $numCVsL + "]") ;
    $In = {1,0,2,3};
    for($i = 0; $i < 4;$i++){
    $CRV_EndsVec[$i]= `pointPosition -w ($CRVendPts[$i])`;
    }
    for($i = 0; $i < 2;$i++){
    $CRV_PlaneNorm[$i]= unit( FloatToVec(DirectionFN($CRV_EndsVec[$In[(($i*2)+1)]],$CRV_EndsVec[$In[($i*2)]])));
    }
    return $CRV_PlaneNorm;
    }
    proc float[ ] BBoxInfo2D(string $i)
    {
    select $i;
    PolySelectConvert 3;
    $test = `xform -query -ws -t`;
    $sizeTest = ((`size $test`) / 3);
    for ($a=1, $bbInfo[0] = $test[0], $bbInfo[3] = $test[0], $x=3, $bbInfo[1] = $test[1], $bbInfo[4] = $test[1], $y=4, $bbInfo[2] = $test[2], $bbInfo[5] = $test[2], $z=5; $a < $sizeTest; $a++)
    {
    $tempX = $test[$x];
    $x = $x + 3;
    $bbInfo[0] = `min $bbInfo[0] $tempX`;
    $bbInfo[3] = `max $bbInfo[3] $tempX`;
    $tempY = $test[$y];
    $y = $y + 3;
    $bbInfo[1] = `min $bbInfo[1] $tempY`;
    $bbInfo[4] = `max $bbInfo[4] $tempY`;
    $tempZ = $test[$z];
    $z = $z + 3;
    $bbInfo[2] = `min $bbInfo[2] $tempZ`;
    $bbInfo[5] = `max $bbInfo[5] $tempZ`;
    }
    return $bbInfo;
    }
    proc vector [] ProjectCrv2PlaneNormal(vector $vecRs[],vector $AvN,vector $Midp){
    $RowC = $AvN;
    $AxisO = $Tran = $Midp;
    $SizeVp = `size($vecRs)`;
    for($Ind=0; $Ind<$SizeVp; $Ind++){
    $PtsVec=$vecRs[$Ind];
    $Pts = $PtsVec;
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    }
    return $NewPtsP;
    }
    proc float  VAnglesofThreeVec(vector $VecA, vector $VecB, vector $VecC){
    $SideA = distance2Pts( $VecA, $VecB);
    $SideB = distance2Pts( $VecB, $VecC);
    $SideC = distance2Pts( $VecC, $VecA);
    $Pi = 3.1415926535;
    $ArcangleB = acos((((`pow $SideA 2.000`) + (`pow $SideC 2.000`) - (`pow $SideB 2.000`) )/(2.000*$SideA*$SideC)));
    $AngleNPiB = ($ArcangleB*180)/$Pi;
    $AngleNB = $AngleNPiB;
    return $AngleNB;
    }
    proc vector [] MultPointMatrixArray( vector $Vec_Array[], matrix $mIA[][],matrix $mIB[][]){
    $MtxF  = MatrixToFloat($mIA);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};
    $AxisO = $Tran = << $mIA[3][0], $mIA[3][1], $mIA[3][2]>>;
    $MtxFB  = MatrixToFloat($mIB);
    $RowAi = {$MtxFB[0], $MtxFB[1], $MtxFB[2]};
    $RowBi = {$MtxFB[4], $MtxFB[5], $MtxFB[6]};
    $RowCi = {$MtxFB[8], $MtxFB[9], $MtxFB[10]};
    for ( $ii = 0; $ii < (`size($Vec_Array)` ); $ii++ ){
    $Pts = $Vec_Array[$ii];
    $PtZ[0] = (($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    $PtZ[1] = (($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    $PtZ[2] = (($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    $PtZT[0] = (($RowAi[0])*($PtZ[0])) + (($RowBi[0])*$PtZ[1]) + (($RowCi[0])*$PtZ[2])+$MtxF[3];
    $PtZT[1] = (($RowAi[1])*($PtZ[0])) + (($RowBi[1])*$PtZ[1]) + (($RowCi[1])*$PtZ[2])+$MtxF[7];
    $PtZT[2] = (($RowAi[2])*($PtZ[0])) + (($RowBi[2])*$PtZ[1]) + (($RowCi[2])*$PtZ[2])+$MtxF[11];
    $ReturnValVec = << $PtZT[0], $PtZT[1], $PtZT[2]>>;
    $TranB = << $mIB[3][0], $mIB[3][1], $mIB[3][2]>>;
    $ReturnValVec += $TranB;
    $newVecs[$ii]=$ReturnValVec;
    }
    return $newVecs;
    }
    proc vector [] Matrix_Curve_TranslationCC(vector $VecPairA[],vector $VecPairB[], vector $CurveVecPointZ[]){
    matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    matrix $matrixB[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $matrixA = TwoPointMatrixPlusAxisWorld($VecPairA, $EmptyVecA, 1);
    $matrixB = TwoPointMatrixPlusAxisWorld($VecPairB, $EmptyVecB, 1);
    $LengthA = distance2Pts ($VecPairA[0], $VecPairA[1]);
    $LengthB = distance2Pts ($VecPairB[0], $VecPairB[1]);
    if($LengthA<$LengthB){$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}else{$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}
    $LengthAB *= $Sign_F;
    $matrixB[3][3] =$LengthAB;
    $NVecPointZ = MultPointMatrixArray($CurveVecPointZ, $matrixA,$matrixB);
    return $NVecPointZ;
    }
    proc vector MatrixAxisTranlation(vector $SVeci, matrix $mIA, matrix $mIB){
    $TransL[0] = $mIA[3][0];
    $TransL[1] = $mIA[3][1];
    $TransL[2] = $mIA[3][2];
    $VecROne = GetRotationVectorsMatrix($mIA );
    $tranSVec = << $TransL[0], $TransL[1], $TransL[2]>>;
    $tranSVecA = $VecROne[0]+$tranSVec ;	vector $tranSVecB = $VecROne [1]+$tranSVec ;
    $tranSVecC = $VecROne[2]+$tranSVec ;
    clear $SVecii;
    $SVecii[0] = $tranSVecB;	$SVecii[1] = $tranSVecC;
    $SVecii[2] = $tranSVec;
    $SVecPoint = $SVeci ;
    $YZvec = PointToPlaneN($SVecPoint, $SVecii);
    clear $SVecii;
    $SVecii[0] = $tranSVecC;	$SVecii[1] = $tranSVecA;
    $SVecii[2] = $tranSVec;
    $ZXvec = PointToPlaneN($SVecPoint, $SVecii);
    clear $SVecii;
    $SVecii[0] = $tranSVecA;	$SVecii[1] = $tranSVecB;
    $SVecii[2] = $tranSVec;
    $XYvec = PointToPlaneN($SVecPoint, $SVecii);
    $VecPlanes[0] = $YZvec; $VecPlanes[1] = $ZXvec; $VecPlanes[2] = $XYvec;
    for($EachVec in $VecPlanes){
    $VecLineDirM_All[`size($VecLineDirM_All)`] = FloatToVec(DirectionFN($EachVec,$SVeci));
    }
    $SIgnA = GetVectorFloatSign( $VecLineDirM_All);
    $SIgnB = GetVectorFloatSign($VecROne);
    $CombA = 0;
    $CountN = 0;
    for($EachVec in $VecPlanes){
    $CombA = PtsEquivalentF ($EachVec,  $SVeci, 0.001);
    if($CombA != 3){
    $DistToPlane[$CountN]= distance2Pts($SVeci,$EachVec);
    }else{$DistToPlane[$CountN]= 0.0;}
    $CountN++;
    }
    $CombA = 0;
    $CountN = 0;
    for($EachFloatA in $DistToPlane){
    if($EachFloatA != 0){
    $EachVecT = $SIgnA[$CountN] * $SIgnB[$CountN];
    $Subs =$EachVecT;
    $AddF = $Subs[0]+$Subs[1]+$Subs[2];
    if($AddF==3){
    $DistToPlane[$CountN]*= 1.0;
    }
    if($AddF==-9){
    $DistToPlane[$CountN]*= -1.0;
    }
    }
    $CountN++;
    }
    $SCale = $mIB[3][3];
    $SCale *= -1.0;
    $DistToPlane = multiplyFloat($SCale, $DistToPlane);
    $NewAXis = MultPointMatrix($DistToPlane, $mIB);
    $TransLb[0] = $mIB[3][0];
    $TransLb[1] = $mIB[3][1];
    $TransLb[2] = $mIB[3][2];
    $NewPos = AddFloats($TransLb, $NewAXis);
    $NewPosVec = <<$NewPos[0], $NewPos[1], $NewPos[2]>>;
    return $NewPosVec;
    }
    proc vector [] GetVectorFloatSign(vector $VecLineDirM_All[]){
    clear $VecSIGNDirM;
    $CountIntA = 0;
    $CountInt = 0;
    for($EachVeci in $VecLineDirM_All){
    $XYZsAxis = $EachVeci;
    for($EachFloat in $XYZsAxis){
    $SignPN[$CountInt] = `sign $EachFloat`;
    if($SignPN[$CountInt]==0){
    $SignPN[$CountInt] = 1;
    }
    $CountInt++;
    }
    $CountInt=0;
    $VecSIGNDirM[$CountIntA] =FloatToVec($SignPN);
    clear $XYZsAxis;
    $CountIntA++;
    }
    return $VecSIGNDirM;
    }
    proc matrix TwoPointMatrixPlusAxisWorld(vector $PtsVecii[], vector $EmptyDirVector[],  int $ZeroOne){
    $PtsVec = $PtsVecii;
    $MidPt = MidPoint($PtsVec[0], $PtsVec[1]);
    $Line_Y_zeroMain = PositiveDirectionLine($PtsVec[0], $PtsVec[1]);
    $CombA = 0;
    $CountIndexV = 0;
    for ($eachPointVd in $PtsVec){
    $Dir_VecA = FloatToVec (DirectionFN($eachPointVd, $MidPt));
    $VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    if($AdditR != 0.0){break;}else{
    $CountIndexV++;}
    }
    if($CountIndexV == 1){
    $PtsVec = ReverseVectorArray($PtsVec);
    }
    $CamDirVecNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM",  0);
    $CamDirVecNormal= multiplyFloat(-1.0, $CamDirVecNormal);
    $DirLine = PositiveDirectionLine($PtsVec[0], $PtsVec[1]);
    $Vperp = crossProduct( $DirLine, $CamDirVecNormal, 0, 0 );
    $BInomalV = FloatToVec(MultLenToDirAddToPoint(2, $Vperp, $PtsVec[0]));
    $BInomalVDirLine = PositiveDirectionLine($PtsVec[0], $BInomalV);
    $BInomalV = FloatToVec(MultLenToDirAddToPoint(4, $BInomalVDirLine, $PtsVec [0]));
    $TangentV = FloatToVec(MultLenToDirAddToPoint(4,$CamDirVecNormal,  $PtsVec[0]));
    $norm = FloatToVec($CamDirVecNormal);
    $bi = $BInomalVDirLine;
    $tan = $DirLine;
    matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $DirectionVector[0] =  $norm;
    $DirectionVector[1] =  $bi;
    $DirectionVector[2] =  $tan;
    $EmptyDirVector = $DirectionVector;

    $bi_two = `cross $tan $norm`;
    if($ZeroOne== 0){
    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;
    ($bi.x), ($bi.y), ($bi.z),  0.0;
    ($tan.x), ($tan.y), ($tan.z), 0.0;
    0.0, 0.0, 0.0, 1.0  >>;
    }
    if($ZeroOne== 1){
    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;
    ($bi.x), ($bi.y), ($bi.z),  0.0;
    ($tan.x), ($tan.y), ($tan.z), 0.0;
    $MidPt[0], $MidPt[1], $MidPt[2], 1.0  >>;
    }
    $MatrizFloati = MatrixToFloat($mI);
    return $mI;
    }
    proc matrix TwoPointMatrix(vector $FixVecii[]){
    $FixVeci = $FixVecii;
    $LineAMain =FloatToVec (DirectionFN($FixVeci[0], $FixVeci[1]));
    $MidPt = MidPoint($FixVeci[0], $FixVeci[1]);
    $LineAMain = PositiveDirectionLine($FixVeci[0], $FixVeci[1]);
    $CombA = 0;
    $CountIndexV = 0;
    for ($eachPointVd in $FixVeci){
    $DirMTestVec = FloatToVec (DirectionFN($eachPointVd, $MidPt));
    $VecLineDirM = ( $DirMTestVec+$LineAMain );
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    if($AdditR != 0.0){break;}else{
    $CountIndexV++;}
    }
    if($CountIndexV == 1){
    $FixVeci= ReverseVectorArray($FixVeci);
    }
    $ZeroA = <<0.0, 0.0, 0.0>>;
    $Va = $FixVeci[0];
    $Vb = $FixVeci[1];
    $FixVecB[0]= << $Va[0], 0.0, $Va[2] >>;
    $FixVecB[1]= << $Vb[0], 0.0, $Vb[2] >>;
    $LineA = PositiveDirectionLine($FixVecB[0], $FixVecB[1]);
    $pointYVec = ClosestPoint2LineVec($LineA, $FixVecB[0], $ZeroA);
    $LineDirYT = PositiveDirectionLine($pointYVec, $ZeroA);
    $DirLine = PositiveDirectionLine($FixVeci[0], $FixVeci[1]);
    $Vperp = crossProduct( $DirLine, $LineDirYT, 0, 0 );
    $BInomalV = FloatToVec(MultLenToDirAddToPoint(2, $Vperp, $FixVeci[0]));
    $BInomalVDirLine = PositiveDirectionLine($FixVeci[0], $BInomalV);
    $BInomalV = FloatToVec(MultLenToDirAddToPoint(4, $BInomalVDirLine, $FixVeci [0]));
    $TangentV = FloatToVec(MultLenToDirAddToPoint(4, $LineDirYT, $FixVeci[0]));
    $FloatDirMajor = $DirLine;
    $FDirNorAi = $LineDirYT;
    $DirNormi = $LineDirYT;
    $normal = $BInomalVDirLine;
    matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $norm = $LineDirYT;
    $bi = $BInomalVDirLine;
    $tan = $DirLine;
    $tan  = `unit << ($tan.x), ($tan.y), ($tan.z) >>`;
    $norm = `unit << ($norm.x), ($norm.y), ($norm.z) >>`;
    $bi = `unit $bi`;

    $tan = FloatToVec(MakeCleanFloatsZ($tan));
    $norm = FloatToVec(MakeCleanFloatsZ($norm));
    $bi = FloatToVec(MakeCleanFloatsZ($bi));
    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;
    ($bi.x), ($bi.y), ($bi.z),  0.0;
    ($tan.x), ($tan.y), ($tan.z), 0.0;
    $MidPt[0], $MidPt[1], $MidPt[2], 1.0  >>;
    $mI = MatrixCleanNegZero($mI);
    $MatrizFloati = MatrixToFloat($mI);
    return $mI;
    }
    proc float [] ClosestPoint2Line(float $DirectionLineF[], float $PointOnLine[], float  $PointN[]){
    $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    $VecLineDir = PositiveDir($DirectionLineF);
    $VecLineDirM = $VecLineDiri-$VecLineDir;
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    if($AdditR != 0.0){
    $MultDirOne = multiplyFloat(1.0, $DirectionLineF);
    $AddMultF = AddFloats($PointOnLine, $MultDirOne);
    $FDirNorA = Normal3Points($PointOnLine, $AddMultF, $PointN);
    $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    $MultDirMx = multiplyFloat($DistToLineSTart, $FDirNorA);
    $AddMultMiiFx = AddFloats($PointOnLine, $MultDirMx);
    $FDirNorB = Normal3Points($PointOnLine, $AddMultMiiFx,  $AddMultF);
    $MultDirMxz = multiplyFloat($DistToLineSTart,  $FDirNorB);
    $AddMultMiiFxz = AddFloats($PointOnLine, $MultDirMxz);
    $locsA = lineIntersection($PointN, $FDirNorB, $PointOnLine,  $DirectionLineF);
    }else{$locsA =  $PointN ;}
    return $locsA;
    }
    proc vector ClosestPoint2LineVec(float $DirectionLineF[], float $PointOnLine[], float  $PointN[]){
    $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    $VecLineDir = PositiveDir($DirectionLineF);
    $VecLineDirM = $VecLineDiri-$VecLineDir;
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    if($AdditR != 0.0){
    $MultDirOne = multiplyFloat(1.0, $DirectionLineF);
    $AddMultF = AddFloats($PointOnLine, $MultDirOne);
    $FDirNorA = Normal3Points($PointOnLine, $AddMultF, $PointN);
    $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    $MultDirMx = multiplyFloat($DistToLineSTart, $FDirNorA);
    $AddMultMiiFx = AddFloats($PointOnLine, $MultDirMx);
    $FDirNorB = Normal3Points($PointOnLine, $AddMultMiiFx,  $AddMultF);
    $MultDirMxz = multiplyFloat($DistToLineSTart,  $FDirNorB);
    $AddMultMiiFxz = AddFloats($PointOnLine, $MultDirMxz);
    $locsA = lineIntersection($PointN, $FDirNorB, $PointOnLine,  $DirectionLineF);
    $VlocA = <<$locsA[0],$locsA[1],$locsA[2]>>;
    }else{$VlocA = FloatToVec($PointN);}
    return $VlocA;
    }
    proc int Partition(float $a[], int $Index[], int $p, int $r) {
    $x = $a[$r];
    $xIndex = $Index[$r];
    $j = $p - 1;
    for (  $i = $p; $i < $r; $i++) {
    if ($x <= $a[$i]) {
    $j = $j + 1;
    $temp = $a[$j];
    $tempIndex = $Index[$j];
    $a[$j] = $a[$i];
    $Index[$j] = $Index[$i];
    $a[$i] = $temp;
    $Index[$i] = $tempIndex;
    }
    }
    $a[$r] = $a[$j + 1];
    $Index[$r] = $Index[$j + 1];
    $a[$j + 1] = $x;
    $Index[$j + 1] = $xIndex;
    return ($j + 1);
    }
    proc  quickSort(float $a[], int $Index[], int $p, int $r) {
    if ($p < $r) {
    $q = Partition($a, $Index, $p, $r);
    quickSort($a, $Index, $p, $q - 1);
    quickSort($a, $Index, $q + 1, $r);
    }
    }
    proc float [] Normal3Points(float $p1[],float $p2[],float $p3[]){
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		 $p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		 $p1p3[2]= $p3[2]-$p1[2];
    $normalV = crossProduct( $p1p2, $p1p3, 0, 0 );
    $normal = `unit $normalV[0]`;
    return $normal;
    }
    proc int FindLineCross( vector $Vecbv[], vector $Vecbvi[]){
    $DirecA = FloatToVec(DirectionFN($Vecbv[0],$Vecbvi[1]));
    $DirecB = FloatToVec(DirectionFN($Vecbv[1],$Vecbvi[0]));
    $centerCross = lineIntersection( $Vecbv[0], $DirecA, $Vecbv[1], $DirecB);
    $trueOrFalse = IsPointInLine ($Vecbv[0], $Vecbv[1], $centerCross);
    return $trueOrFalse;
    }
    proc int IsPointInLine (float $a[], float $b[], float $c[]){
    $VecC[0] = FloatToVec($a);
    $VecC[1] = FloatToVec($b);
    $VecC[2] = FloatToVec($c);
    $DPi = (distance2Pts($VecC[0], $VecC[1]))/2.0;
    $MidPoint = FloatToVec (MidPoint($VecC[0], $VecC[1]));
    $DPiMid = distance2Pts($VecC[0], $MidPoint);
    $DPa = distance2Pts( $MidPoint, $VecC[2]);
    $returnVal = 0;
    if($DPa<=$DPiMid){
    $returnVal=1;}
    print $returnVal;
    return $returnVal;
    }
    proc float[] DirectionFN(float $posAZ[], float $posBZ[]){
    $Vai = << $posAZ[0], $posAZ[1], $posAZ[2] >> ;
    $Vbi = << $posBZ[0],  $posBZ[1], $posBZ[2] >> ;
    $xi = $Vai.x;
    $yi = $Vai.y;
    $zi = $Vai.z;
    $x = $Vbi.x;
    $y = $Vbi.y;
    $z = $Vbi.z;
    $u = $xi - $x;
    $v = $yi - $y;
    $w = $zi - $z;
    $VbiUnit = << $u, $v, $w >> ;
    $VbiUnitA = `unit $VbiUnit`;

    $UnitDirection = $VbiUnitA;
    return $UnitDirection;
    }
    proc vector PositiveDir(float $VecOrFloatA[]){
    $VecA = FloatToVec($VecOrFloatA);
    $Va = $VecA;
    $xi = $Va.x;
    $yi = $Va.y;
    $zi = $Va.z;
    $e = 1;
    if(`sign $xi` == -1){
    $e = -1.0;
    }
    if((`sign $xi` == -1)&&(`sign $yi` == -1)){
    $e = -1.0;
    }
    if((`sign $xi` == -1)&&(`sign $zi` == -1)){
    $e = -1.0;
    }
    $Y = ($e*$xi);
    $U = ($e*$yi);
    $V = ($e*$zi);
    $YUV = << $Y, $U, $V>>;
    return $YUV;
    }
    proc vector PositiveDirectionLine(vector $VecA, vector $VecB){
    $Va = $VecA;
    $Vb = $VecB;
    $xi = $Va.x;
    $yi = $Va.y;
    $zi = $Va.z;
    $x = $Vb.x;
    $y = $Vb.y;
    $z = $Vb.z;
    $u = $xi - $x;
    $v = $yi - $y;
    $w = $zi - $z;
    $e = 1.0;
    if(`sign $v` == -1){
    $e = -1.0;
    }
    if((`sign $v` == -1)&&(`sign $u` == -1)){
    $e = -1.0;
    }
    if((`sign $v` == -1)&&(`sign $w` == -1)){
    $e = -1.0;
    }
    $Y = $u/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $U = $v/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $V = $w/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $YUV = << $Y, $U, $V>>;
    return $YUV;
    }
    proc PAUSEn(int $n){
    $i = 0;
    while($i < $n){
    eval("playButtonStepForward");
    $i++;
    }
    }
    proc  float [] Circle3PtsM(float $p1[], float $p2[], float $p3[]){
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );
    $FloatPosZero = {0, 0, 0};
    $FloatDirection = DirectionF($FloatPosZero, $normal);
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    $radiusZ = distance2Pts( $p1, $center );
    $CenterRadius = $center;
    $CenterRadius[`size($CenterRadius)`]= $radiusZ;
    return $CenterRadius;
    }
    proc  float [] Circle3PtZFloats(float $p1[], float $p2[], float $p3[]){
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    $radiusZ = distance2Pts( $p1, $center );
    $CenterRadius = $center;
    $CenterRadius[`size($CenterRadius)`]= $radiusZ;
    return $CenterRadius;
    }
    proc float [] Circle3PtZFloatsI(float $p1[], float $p2[], float $p3[]){
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $p1p4[0] = $p2[0]-$p3[0]; 		$p1p4[1] = $p2[1]-$p3[1]; 		$p1p4[2]= $p2[2]-$p3[2];
    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );
    $FloatPosZero = {0, 0, 0};
    $FloatDirection = DirectionF($FloatPosZero, $normal);
    $MultDirP = multiplyFloat(2, $FloatDirection);
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $mid3 = midPoint2Pts( $p2, $p3 );
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $perp_p1p4 = crossProduct( $normal, $p1p4, 0, 1 );
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    $FloatDirPerpCenter = DirectionF($center, $mid3);
    $FloatDirPerpCenterB = DirectionF($center,$mid1);
    $FloatDirPerpCenterC = DirectionF($center,$mid2);
    $FloatDirPointAB = DirectionF($p1, $p2);
    $FloatDirPointBC = DirectionF($p2, $p3);
    $FloatDirPointAC = DirectionF($p1, $p3);
    $center6 = lineIntersection( $p1, $FloatDirPerpCenter, $p2, $FloatDirPointBC );
    $center7 = lineIntersection( $p3,  $FloatDirPerpCenterB, $p1, $FloatDirPointAB );
    $center8 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    curve2points($center, $mid1);
    curve2points($center,$mid2);
    curve2points($center,$mid3);
    $center9 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPerpCenter );
    $OrthoCenterCir = midPoint2Pts( $center9, $center );
    $Radius2HalfTimes2 = (distance2Pts( $center9, $center ))*2;
    $Radius2BHalf = (distance2Pts( $center9, $center ));
    $radiusZ = distance2Pts( $p1, $center );
    $Radius3Half = $radiusZ/2;
    $circlesItemA[0] = Circles_Direction($OrthoCenterCir, $FloatDirection, $Radius3Half);
    $circlesItem[0] = Circles_Direction($center, $FloatDirection, $radiusZ);
    $radiusZ = distance2Pts( $p1, $center );
    $CenterRadius = $center;
    $CenterRadius[`size($CenterRadius)`]= $radiusZ;
    return $CenterRadius;
    }
    proc vector [] VecArrayDiff(int $IndeXxz[]){
    global vector $AllVecsG[];
    global vector $WorkingAllVecsG[];
    $VecS = $AllVecsG;
    $Ixx = 0;
    $EIndex = $IndeXxz;
    $EIndex = `sort $EIndex`;
    $Ii = 0;
    for ($eachVc in $VecS){
    $one =$EIndex[$Ii];
    if(!($Ixx==$one)){
    $newVec[`size($newVec)`] = $VecS[$Ixx];
    }else{$Ii++;}
    $Ixx++;
    }
    $WorkingAllVecsG = $newVec;
    return $newVec;
    }
    proc vector [] VecArrayInclude(int $IndeXxz[]){
    global vector $AllVecsG[];
    global vector $WorkingAllVecsG[];
    $VecS = $AllVecsG;
    $Ixx = 0;
    $EIndex = $IndeXxz;
    $EIndex = `sort $EIndex`;
    $Ii = 0;
    for ($eachVc in $VecS){
    $one =$EIndex[$Ii];
    if(($Ixx==$one)){
    $newVec[`size($newVec)`] = $VecS[$Ixx];
    }else{$Ii++;}
    $Ixx++;
    }
    $WorkingAllVecsG = $newVec;
    return $newVec;
    }
    proc string AddItemString(int $iN, string $NumLetorSy){
    $Xz = 0;
    $AddItem = "";
    while($iN > $Xz){
    $AddItem+= $NumLetorSy;
    $Xz++;
    }
    return $AddItem;
    }
    proc StereoCurveZ(string $CurveItemZai, string $CurveItemZbi){
    global string $StereoCurveZ[];
    global string $VanishingPointsLinesTempGuides[];
    global int $addNumbersA;
    global float $VanishingPointGlobal[];
    global string $PlaneCurveS[];
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;
    $IsOrthoLineTrue =0;
    $SnapR = 2.59;
    $Smooth = 398;
    $DiffSumTol = 97.95;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 1 -tol 0.05 $CurveItemZai;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 1 -tol 0.05 $CurveItemZbi;
    clear $AllLocPositionsZi;
    $AllLocPositionsZi = VecCurveCvs( $CurveItemZai);
    $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    ResetTranslation({$newPlaneCurveA});
    delete $CurveItemZai;
    $CurveItemZai = $newPlaneCurveA;
    clear $AllLocPositionsZi;
    $AllLocPositionsZi = VecCurveCvs( $CurveItemZbi);
    $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    ResetTranslation({$newPlaneCurveA});
    delete $CurveItemZbi;
    $CurveItemZbi = $newPlaneCurveA;
    $VecCurEndsa = VecCurveEnds({$CurveItemZai});
    $VecCurEndsb = VecCurveEnds({$CurveItemZbi});
    $StereoCurveZ[0]= $CurveItemZai;
    $StereoCurveZ[1]= $CurveItemZbi;
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveCvs($CurveItemZai );
    clear $PositionsZ_B;
    $PositionsZ_B = VecCurveCvs($CurveItemZbi );
    clear $VecPtsMirrorA;
    clear $VecPtsMirrorB;
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
    $CamDirVecNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $MultDirCam = multiplyFloat(-1, $CamDirVecNormal);
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    clear $VecPtsMirrorEnds_A;
    clear $VecPtsMirrorEnds_B;
    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);
    $EpipolPosCamM = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;
    $MidPosFCam = $CamPlane1;
    $FloatDirEpipol = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    $FloatDirEpipolB = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
    $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
    $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);
    $DistTOEpipol_CurEndA = distance2Pts($PointN_Epi, $VecCurEndsb[0]);
    $DistTOEpipol_CurEndB = distance2Pts($PointN_EpiB, $VecCurEndsb[0]);
    $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
    $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
    $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;
    $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
    $BCDiff = abs($BCurEndB - $BCurEndBNN);
    $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd ;
    $BCDiffi = abs($BCurEndB - $BCurEndBNNi);
    $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);
    $FloatDirEndPtsA = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
    $EulerAngleA = EulerAngB($FloatDirEndPtsA, $FloatDirEpipol);
    $EulerAngle_A = $EulerAngleA[3];
    $FloatDirEndPtsB = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
    $EulerAngleB = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);
    $EulerAngle_B = $EulerAngleB[3];
    $FloatDirEndPtsAi = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
    $EulerAngleAi = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);
    $EulerAngle_Ai = $EulerAngleAi[3];
    $FloatDirEndPtsBi = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
    $EulerAngleBi = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);
    $EulerAngle_Bi = $EulerAngleBi[3];
    $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
    $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;
    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);

    $Vecbv  = $VecCurEndsa;
    $Vecbvi = $VecCurEndsb;
    $IfTrue = FindLineCross( $Vecbv , $Vecbvi );
    $weighedtFindings = 0;
    $weighedtFindingsZ = 0;
    $weighedtFindingsN = 0;
    if($IfTrue=1){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;
    }
    if($IntIfNearZero==1){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}
    if($EulerAngle_AB<$EulerAngle_AiBi){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}

    $LengCRV_a = `arclen $CurveItemZai`;
    $CRV_ENDSi = $VecCurEndsa;
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
    //float $DiffMathA = ($LengCRV_a-$DistEndsi) / ($DistEndsi/100.0);

    $LengCRV_b = `arclen $CurveItemZbi`;
    $CRV_ENDSii = $VecCurEndsb;
    $DistEndsii = distance2Pts($CRV_ENDSii[0], $CRV_ENDSii[1]);
    $DiffMathB = $DistEndsii / ($LengCRV_b/100.0);

    $PerDiffSum = ($DiffMathA+$DiffMathB)/2.0;

    //print (" DiffMathA " +$DiffMathA + " DiffMathB " +$DiffMathB +"\n");
    //if(($DiffMathA> 96.5) && ($DiffMathB > 96.5)){
    //$PerDiffSum =99;
    //}else{$PerDiffSum =1;}

    $triggerStraitCRV = 0;
    $triggerNoTransENDA = 0;
    $triggerNoTransENDB = 0;
    $First_Second_Both_None = 0;
    //print ("START FindIfCurveIsOrthoEpipol" +"\n");
    $XYZdirectL[0] = << 1,0,0>>;
    $XYZdirectL[1] = << 0,1,0>>;
    $XYZdirectL[2] = << 0,0,1>>;
    $trigger_straitC = 0;
    if( $PerDiffSum>$DiffSumTol){
    print ("FIRST IF : ENGAGED PerDiffSum" +$PerDiffSum +"\n");
    print ("ENGAGED FindIfCurveIsOrthoEpipol" +"\n");
    $triggerStraitCRV=1;
    $DDirEpipol = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
    $MidCurveA  = MidPoint($VecCurEndsa[0], $VecCurEndsa[1]);
    $MidCurveB  = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);
    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);

    $EpipolD = $DDirEpipolXYZ;
    $Trueii = 0;

    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];

    }
    print ("IsOrthoLineTrue = "+$IsOrthoLineTrue+"\n");

    if($weighedtFindingsZ<$weighedtFindingsN){
    /////////////////////////////REMOVED

    /////////////////////////////
    //if(($DistB<$DistA)||($weighedtFindingsZ<$weighedtFindingsN)){
    if( ($weighedtFindingsZ<$weighedtFindingsN)){

    cycleBackgroundColor;
    $PositionsZ_B = ReverseVectorArray($PositionsZ_B);
    $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);
    $VecCurEndsb = ReverseVectorArray($VecCurEndsb);
    $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
    }
    }

    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
    $queryLocCurveEnds3D = `sort $queryLocCurveEnds3D`;
    $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
    $TrackAllExisting3DCrv = CreatePairIntIndex($SizeCrvi);
    $LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;
    $SizeCrvR = `size($LayerCurvesRangeA)` ;
    $triggerNoTrans = 0;
    $triggerNoTransA = 0;
    $triggerNoTransB = 0;
    $triggerNoTrans = 0;
    clear $IntersectEnds_Ax;
    $iia = 0;

    if(!(`size($queryLocCurveEnds3D)` > 2)){

    if($PerDiffSum >$DiffSumTol){
    print ("ENGAGED PerDiffSum " +$PerDiffSum +"\n");
    print (" MAKING STRAIT  " +"\n");
    $iis = 0;
    for ($eachVecx in  $VecCurEndsb){
    $XIntersect_Ax[$iis] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsb[$iis], $CamPos_M, $VecPtsMirrorEnds_A[$iis]));
    $iis++;
    }
    $XIntersect_Ax[2] =  $XIntersect_Ax[1];
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    $XIntersect_Ax[0] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[0]);
    $XIntersect_Ax[2] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[2]);
    $PositionsZ_Bii= $XIntersect_Ax;
    $PositionsZ_Aii= VecPtsToZMirrorPts($PositionsZ_Bii);
    $ThefirstCurve = VecArrayToCurve($XIntersect_Ax);
    $PtsMirrorAi= VecPtsToZMirrorPts($XIntersect_Ax);
    $ThefirstCurvei = VecArrayToCurve($PtsMirrorAi);

    $trigger_straitC =1;
    }
    }

    ////////////
    if(`size( $queryLocCurveEnds3D)`>2){

    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);
    for ($eachVecx in  $VecCurEndsa)
    {
    $IntersectEnds_Ax[$iia] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsa[$iia], $CamPos_M, $VecPtsMirrorEnds_B[$iia]));
    $iia++;
    }

    $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[0]);
    $AllLocsi = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    $AllLocs_String = IntArrayToStringArray($AllLocsi);
    $newOrdersZA = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    $EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
    $New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
    $Near_index_A = $New_AllLocs_A[0];
    $Distance_A = $distToCurveE_A[$Near_index_A];
    $Found_pt_A = $LocCurveEndsVec3D[$Near_index_A];
    $newOrdersZAM = $Found_pt_A;
    $newOrdersZAM[0] = $Found_pt_A[0] *-1;
    $distToCurveE_B = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[1]);
    $newOrdersZB = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    $EmptyStringNewOrderB = ReverseStringArray($EmptyStringNewOrderB);
    $New_AllLocs_B = ArrayToIntList($EmptyStringNewOrderB);
    $Near_index_B = $New_AllLocs_B[0];
    $Distance_B = $distToCurveE_B[$Near_index_B];
    $Found_pt_B = $LocCurveEndsVec3D[$Near_index_B];
    $newOrdersZBM = $Found_pt_B;
    $newOrdersZBM[0] = $Found_pt_B[0] *-1;

    $PointsA[0] = FloatToVec($Found_pt_A);
    $PointsA[1] = FloatToVec($Found_pt_B);
    $PointsB[0] = FloatToVec($newOrdersZAM); // negative mirror of first endpoint of first curve
    $PointsB[1] = FloatToVec($newOrdersZBM);

    $VecOnPlaneA = VecPointsToCameraPlane($PointsA);
    $VecOnPlaneB = VecPointsToCameraPlane($PointsB);

    $NewFoundLocs[0] = $queryLocCurveEnds3D[$Near_index_A];
    $NewFoundLocs[1] = $queryLocCurveEnds3D[$Near_index_B];

    print($NewFoundLocs[0]+"\n");
    print($NewFoundLocs[1]+"\n");
    // string $XLocsA = "LOCcurve259START";
    // string $XLocsB = "LOCcurve200START";

    $XLocsA = $NewFoundLocs[0];
    $XLocsB = $NewFoundLocs[1];

    $START_END[0] = gmatch ((match("END",$XLocsA)),"END");
    $START_END[1] = gmatch ((match("END",$XLocsB)),"END");
    $CrvNA[0] =$CrvNA[1]="curve";
    $Na = (match ("[0-9]+", $XLocsA));
    $Nb = (match ("[0-9]+", $XLocsB));
    $CrvNA[0] = $CrvNA[0]+$Na;
    $CrvNA[1] = $CrvNA[1]+$Nb;

    select -r $CrvNA;
    PAUSEn(1);





    $arrayCurvesNear[0] = ("Plane"+$NewFoundLocs[0]);
    $arrayCurvesNear[1] = ("Plane"+$NewFoundLocs[1]);



    $NewFoundLocs = $arrayCurvesNear;
    $LocOnPlaneVec = PointArray($NewFoundLocs);
    $distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocOnPlaneVec[0]);
    $distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocOnPlaneVec[1]);
    $TXI = << -1.0 , 1.0, 1.0>>;
    $LoCz_3D[0] = MultVec($IntersectEnds_Ax[0],$TXI);
    $LoCz_3D[1] = MultVec($IntersectEnds_Ax[1], $TXI);

    ////////////////////////
    $DistToIntersectTOnear[0] = distance2Pts($IntersectEnds_Ax[0], $PointsA[0]);
    $DistToIntersectTOnear[1] = distance2Pts($IntersectEnds_Ax[1], $PointsA[1]);
    $DistToIntersectTOnear[2] = distance2Pts($LoCz_3D[0], $PointsB[0]);
    $DistToIntersectTOnear[3] = distance2Pts($LoCz_3D[1], $PointsB[1]);

    $distToPlaneLoc3D[0] = distance2Pts($VecCurEndsa[0], $PointsA[0]);
    $distToPlaneLoc3D[1] = distance2Pts($VecCurEndsa[1], $PointsA[1]);
    $distToPlaneLoc3D[2] = distance2Pts($VecCurEndsb[0], $PointsB[0]);
    $distToPlaneLoc3D[3] = distance2Pts($VecCurEndsb[1], $PointsB[1]);
    //////////////////////////

    $DiffMathA = $DistToIntersectTOnear[0]/ ($distToPlaneLoc3D[0]/100.0);
    $DiffMathB = $DistToIntersectTOnear[1] / ($distToPlaneLoc3D[1]/100.0);
    $DiffMathAm = $DistToIntersectTOnear[2]/ ($distToPlaneLoc3D[2]/100.0);
    $DiffMathBm = $DistToIntersectTOnear[3] / ($distToPlaneLoc3D[3]/100.0);

    $relativeDistanceA = ($DiffMathA+$DiffMathAm)/2.0;
    $relativeDistanceB = ( $DiffMathB+$DiffMathBm)/2.0;
    //////////////
    //REMOVED AND PLACE BELOW
    /////////////

    //print ("relativeDistanceA" + $relativeDistanceA+"\n");
    //print ("relativeDistanceB" + $relativeDistanceB+"\n");

    if($relativeDistanceA<$SnapR){
    $triggerNoTransA++;
    }
    if($relativeDistanceB <$SnapR){
    $triggerNoTransB++;
    }

    if(!($relativeDistanceA<$SnapR)){
    $VecOnPlaneA[0] = $VecCurEndsa[0];
    $VecOnPlaneB[0] = $VecCurEndsb[0];
    $triggerNoTransENDA=1;
    }else{$triggerNoTrans++;
    $First_Second_Both_None =0;
    }

    if(!($relativeDistanceB<$SnapR)){
    $VecOnPlaneA[1] = $VecCurEndsa[1];
    $VecOnPlaneB[1] = $VecCurEndsb[1];
    $triggerNoTransENDB=1;
    }else{$triggerNoTrans++;
    $First_Second_Both_None =1;

    if($triggerNoTransENDA==0){ $First_Second_Both_None =-2;}

    }


    if($triggerNoTrans==0){
    $First_Second_Both_None =-1;}

    //if(($triggerNoTransENDA +$triggerNoTransENDB)== 2){
    //}

    //if(($triggerNoTransENDA +$triggerNoTransENDB)== 0){
    //}

    $ConnectedEnds = $triggerNoTransENDA + $triggerNoTransENDB;
    if($triggerNoTransENDA==1){
    $UnconnectedEnds[0]= $VecOnPlaneA[0];
    $UnconnectedEnds[1]= $VecOnPlaneB[0];
    }else{$UnconnectedEnds[0]= $VecOnPlaneA[1];
    $UnconnectedEnds[1]= $VecOnPlaneB[1];}

    clear $arrayCurvesNearA;
    clear $arrayCurvesNearA;
    $AddAB = $triggerNoTransA+$triggerNoTransB;

    if($triggerNoTrans!=0){

    $PositionsZ_A = VecCurveCvs($CurveItemZai );
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEndsa,$VecOnPlaneA, $PositionsZ_A);
    $PositionsZ_Bi = Matrix_Curve_TranslationCC($VecCurEndsb, $VecOnPlaneB, $PositionsZ_B);
    clear $VecPtsMirrorA;
    $VecPtsMirrorA= VecPtsToZMirrorPts( $PositionsZ_Ai);
    clear $VecPtsMirrorB;
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_Bi);
    $PositionsZ_A = $PositionsZ_Ai;
    $PositionsZ_B = $PositionsZ_Bi;
    cycleBackgroundColor;
    }

    }

    //print (" IsOrthoTrueZi Eq  "+$IsOrthoLineTrue +"\n");

    if(($triggerNoTrans==0)&&($PerDiffSum >$DiffSumTol)){


    $iis = 0;
    for ($eachVecx in  $VecCurEndsb){
    $XIntersect_Ax[$iis] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsb[$iis], $CamPos_M, $VecPtsMirrorEnds_A[$iis]));
    $iis++;
    }
    $XIntersect_Ax[2] =  $XIntersect_Ax[1];
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    $XIntersect_Ax[0] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[0]);
    $XIntersect_Ax[2] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[2]);

    $PositionsZ_Bii= $XIntersect_Ax;
    $PositionsZ_Aii= VecPtsToZMirrorPts($PositionsZ_Bii);

    $ThefirstCurve = VecArrayToCurve($XIntersect_Ax);
    $PtsMirrorAi= VecPtsToZMirrorPts($XIntersect_Ax);
    $ThefirstCurvei = VecArrayToCurve($PtsMirrorAi);

    $trigger_straitC =1;

    }

    if($triggerNoTrans!=0){
    print ("triggerNoTrans Doesnt not Eq ZERO" +"\n");
    if($IsOrthoLineTrue==1){
    print ("IsOrthoLineTrue Eq ONE" +"\n");

    //############HERE

    if($AxisOrthoLine!=0){

    if($First_Second_Both_None>=0){

    $FloatDirEpipol = DirectionFN($VecOnPlaneA[$First_Second_Both_None], $FoundEpipol);
    $FloatDirEpipolB= DirectionFN($VecOnPlaneB[$First_Second_Both_None], $FoundEpipol);
    }

    }

    if($AxisOrthoLine==0){
    print ("HERE IS THE SPOT" +"\n");

    $lineEPointA = MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);
    $Xdirection = << 1.0,0.0,0.0>>;
    $Intersect_LineB_a = FloatToVec (lineIntersection($PointsA[$First_Second_Both_None], $Xdirection, $lineEPointA,(DirectionFN( $CamPos_A,$lineEPointA)) ));
    Loc $Intersect_LineB_a;
    $Point3DA = $Intersect_LineB_a;
    $Point3DAM = {($Point3DA[0]*-1), $Point3DA[1],$Point3DA[2]};

    }
    if($AxisOrthoLine!=0){
    print ("AxisOrthoLine Doesnt not Eq ZERO" +"\n");
    if($First_Second_Both_None>=0){
    if($First_Second_Both_None==1){
    print ("First_Second_Both_None Eq ONE! " +"\n");
    $PairInt={0,1};
    }else{ $PairInt={2,3};
    print ("First_Second_Both_None NOT Eq ONEZZZ! " +"\n");
    }
    }
    }


    //PROBLEM HERE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if($First_Second_Both_None>=0){
    if($AxisOrthoLine!=0){

    $Intersect_BX= VecPtsToZMirrorPts($IntersectEnds_Ax);

    $PairVectors[0]=FloatToVec(FloatPointsToCamPlane($IntersectEnds_Ax[0]));
    $PairVectors[1]= FloatToVec(FloatPointsToCamPlane($Intersect_BX[0]));
    $PairVectors[2]=FloatToVec(FloatPointsToCamPlane($IntersectEnds_Ax[1]));
    $PairVectors[3]= FloatToVec(FloatPointsToCamPlane($Intersect_BX[1]));
    $EpipolXLine = DirectionFN( $MidEpipolPosFCam, $PairVectors[$PairInt[0]]) ;
    print ("HERE IS THE SPOT AAAAAA" +"\n");
    }else{


    $PairVectors[0]=FloatToVec(FloatPointsToCamPlane($Point3DA));
    $PairVectors[1]= FloatToVec(FloatPointsToCamPlane($Point3DAM));
    $PairVectors[2]=FloatToVec(FloatPointsToCamPlane($Point3DA));
    $PairVectors[3]= FloatToVec(FloatPointsToCamPlane($Point3DAM));
    $EpipolXLine = DirectionFN( $MidEpipolPosFCam, $PairVectors[$PairInt[0]]) ;
    print ("HERE IS THE SPOT BBBBBB" +"\n");
    }


    $Intersect_LineB_a = FloatToVec (lineIntersection($VecOnPlaneA[$First_Second_Both_None], $FloatDirEpipol, $MidEpipolPosFCam,$EpipolXLine));
    $Intersect_LineB_b = FloatToVec (lineIntersection($VecOnPlaneB[$First_Second_Both_None], $FloatDirEpipolB, $MidEpipolPosFCam,$EpipolXLine));

    // Loc $Intersect_LineB_a;
    // Loc $Intersect_LineB_b;

    clear $PositionsZ_A;
    clear $PositionsZ_B;
    clear $VecPtsMirrorEnds_A;
    clear $VecPtsMirrorEnds_B;
    clear $VecPtsMirrorA;
    clear $VecPtsMirrorB;


    $PositionsZ_A[0] = $VecOnPlaneA[$First_Second_Both_None];
    $PositionsZ_A[1] = FloatToVec (MidPoint($VecOnPlaneA[$First_Second_Both_None],$Intersect_LineB_a));
    $PositionsZ_A[2] = $Intersect_LineB_a;
    $PositionsZ_B[0] = $VecOnPlaneB[$First_Second_Both_None];
    $PositionsZ_B[1] = FloatToVec (MidPoint($VecOnPlaneB[$First_Second_Both_None], $Intersect_LineB_b));
    $PositionsZ_B[2] = $Intersect_LineB_b;

    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);

    }





    }
    }

    if($trigger_straitC!=1){
    $iiz = 0;

    for ($eachVecx in  $VecPtsMirrorA)
    {
    $Intersect_A[`size($Intersect_A)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_B[$iiz], $CamPos_M, $VecPtsMirrorA[$iiz]));
    $iiz++;
    }

    if($triggerNoTrans==2){

    $CrvNormalA = CRVEndNormals( $CrvNA[0] );
    $CrvNormalB = CRVEndNormals( $CrvNA[1] );
    $aveNorm = unit(($CrvNormalA[$START_END[0]]+$CrvNormalB[$START_END[1]])/2.0);
    $MidPointC = ($Intersect_A[0]+$Intersect_A[`size($Intersect_A)`-1])/2.0;
    $DirectC = DirectionFN($Intersect_A[0], $MidPointC);

    //$Intersect_A= VecPointsToPlaneX($Intersect_A,$aveNorm,$MidPointC);
    $NormPts = (($aveNorm*2.5)+$MidPointC);
    $P1 = ClosestPoint2LineVecX($DirectC, $MidPointC, $NormPts);
    $NewNormal = (DirectionFN($NormPts, $P1));
    $Intersect_A=ProjectCrv2PlaneNormal($Intersect_A,$NewNormal,$MidPointC);
    }

    if(($triggerNoTransA+$triggerNoTransB)==1){
    /*
    $AB_endPts[$triggerNoTransA] =$Intersect_A[0] ;
    $AB_endPts[$triggerNoTransB] =$Intersect_A[`size($Intersect_A)`-1] ;
    //print ("HERE IS THE SPOT XXXX" +"\n");
    //print ("HERE IS THE SPOT XXXXHERE" +"\n");
    $NewFvec = VecEndsOrthoEqual($Intersect_A, $AB_endPts[1],  $AB_endPts[0], 8.5);
    if(`size($NewFvec)`!=0){
    $Intersect_A = $NewFvec;
    }
    */

    }

    $ThefirstCurve = VecArrayToCurve($Intersect_A);
    modifySelectedCurves smooth $Smooth 0;
    //float $arcL3 = (`arclen $ThefirstCurve`)*10.0;
    //SmoothCurvatureB3($arcL3);
    //vector $Intersect_ACD[];
    //$Intersect_ACD = VecCurveEps( $ThefirstCurve);
    $Intersect_B= VecPtsToZMirrorPts($Intersect_A);
    $ThefirstCurvei = VecArrayToCurve($Intersect_B);
    modifySelectedCurves smooth $Smooth 0;
    $EndrEndsa  = VecCurveEnds({$ThefirstCurvei});
    $EndsAtZero= isCurveEndAtZY($EndrEndsa);

    $EndsAtZero= isCurveEndAtZY($EndrEndsa);
    if($EndsAtZero>0){
    sets -include ZEdgeCurvesSet ({$ThefirstCurvei,$ThefirstCurve});
    }

    }
    $EndrEndsa = VecCurveEnds({$ThefirstCurvei});
    $EndsAtZero = isCurveEndAtZY($EndrEndsa);
    if($EndsAtZero>0){
    sets -include ZEdgeCurvesSet ({$ThefirstCurvei,$ThefirstCurve});
    }

    delete $VanishingPointsLinesTempGuides;
    delete $CurveItemZai $CurveItemZbi;
    clear $VanishingPointsLinesTempGuides;
    clear $StereoCurveZ;
    $addNumbersA =0;
    clear $VanishingPointGlobal;

    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $ThefirstCurve;
    smoothCurve -ch 0 -rpo 1 -s 95.60 ($ThefirstCurve +".cv [*]");
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $ThefirstCurvei;
    smoothCurve -ch 0 -rpo 1 -s 95.60 ($ThefirstCurvei +".cv [*]");
    //string $NewCircDX[];
    //string $NewCircD[] = {$ThefirstCurve,$ThefirstCurvei};
    //$NewCircDX = SphereDeform($NewCircD);
    //$ThefirstCurve = $NewCircDX[0];
    //$ThefirstCurvei = $NewCircDX[1];

    //$ThefirstCurve = Strait_ARC_or_FreeFormSS($ThefirstCurve, 5.5, 2.5 );


    //$ThefirstCurvei = Strait_ARC_or_FreeFormSS($ThefirstCurvei, 5.5, 2.5 );

    ResetTranslation({$ThefirstCurve});
    CurveIndexVecTracking({$ThefirstCurve});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ThefirstCurve;

    ResetTranslation({$ThefirstCurvei});
    CurveIndexVecTracking({$ThefirstCurvei});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ThefirstCurvei;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;

    }
    proc vector [] FlattenSnap(vector $Vec_A[], int $XYZvec ,float $Val){
    for($i=0;  $i < `size($Vec_A)`; $i++){
    $Vi= $Vec_A[$i];
    $xyz[0] = $Vi.x;
    $xyz[1] = $Vi.y;
    $xyz[2] = $Vi.z;
    $xyz[$XYZvec]= $Val;
    $ViNew[$i] = <<$xyz[0], $xyz[1], $xyz[2]>>;
    }
    return $ViNew;
    }
    proc vector MultVec(float $Va[],float $Vb[]){
    $PtsC[0]= $Va[0] * $Vb[0];
    $PtsC[1]= $Va[1] * $Vb[1];
    $PtsC[2]= $Va[2] * $Vb[2];
    $VecMult = << $PtsC[0],  $PtsC[1],  $PtsC[2] >>;
    return $VecMult;
    }
    proc AutoCurveScriptsTwoCurve(){
    global string $StereoCurveZ[];
    $itemAll = `ls -sl`;
    $ifCond_is_True = `ISSelectedTypeCurve`;
    if ($ifCond_is_True == 1){
    //   This is just the curve script you need this  to be where the switch is
    $item = `ls -sl`;
    $StereoCurveZ[`size($StereoCurveZ)`]= $item[0];
    EvalAddingCurves;
    creatStereoCurve;
    }
    }

    proc string[] CreateCAMforIntCurveScript(){
    CreateCameraOnly;
    rename ZCURVEModelingCAM;
    lookThroughModelPanelClipped ZCURVEModelingCAM  modelPanel4 0.001 1000;
    nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr  1 -n "LiveSurfaceB";
    editDisplayLayerMembers -noRecurse  layerYZYXPlains "LiveSurfaceB";
    clear $CamConeLocator;
    curve -d 3 -p 0 0 0 -p 0 0 -4 -p 0 0 -8 -p 0 0 - 12 -k 0 -k 0 -k 0 -k 12 -k 12 -k 12 -n  Deletethiscurve ;
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    $objectZcurv = `ls -sl`;
    $numCVs = `getAttr -size ($objectZcurv[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectZcurv[0] + ".cv[0]")  ;
    $CurveSelection[1] = ($objectZcurv[0] + ".cv[" +  $numCVrealNum + "]") ;
    for ($each in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $each  )`;
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n LocatorA`;
    ArrayInsertAtEnd($CamConeLocator,  $MakespaceLocator[0]);
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakespaceLocator[0];
    }
    $LocatorLoop = 0; int $LocatorLoopA = -1;
    while ($LocatorLoop++ < 7) {
    $LocatorLoopA = $LocatorLoopA +1;
    if ($LocatorLoopA == 0){
    clear $objectZ;
    stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
    stringArrayInsertAtIndex(1, $objectZ,  "LocatorA1");
    }
    if ($LocatorLoopA > 0){
    clear $objectZ;
    stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
    stringArrayInsertAtIndex(1, $objectZ,  $MakespaceLocator[0]);
    }
    if ($LocatorLoopA < 7){
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n  LocatorMiddleDistance`;
    ArrayInsertAtEnd($CamConeLocator,  $MakespaceLocator[0]);
    averagingNode($objectZ[0], $MakespaceLocator[0],  $objectZ[1]);
    }
    }
    ArrayInsertAtEnd( $CamConeLocator,  $CamConeLocator[0]);
    stringArrayRemoveAtIndex(0, $CamConeLocator);
    parentConstraint -mo -weight 1 ZCURVEModelingCAM  LocatorA1 ;
    parentConstraint -mo -weight 1 ZCURVEModelingCAM  LocatorA;
    delete  Deletethiscurve;
    align -atl -x Mid -y Mid -z Mid LiveSurfaceB  ZCURVEModelingCAM;
    move -r -os -wd 0 5 5 ZCURVEModelingCAM ;
    setAttr "ZCURVEModelingCAM.rotateX" -45;
    setAttr "LiveSurfaceB.rotateX" (`getAttr  ("ZCURVEModelingCAM" + ".rotateX")`+90);
    setAttr "LiveSurfaceB.rotateY" `getAttr  ("ZCURVEModelingCAM" + ".rotateY")`;
    setAttr "LiveSurfaceB.rotateZ" `getAttr  ("ZCURVEModelingCAM" + ".rotateZ")`;
    align -atl -x Mid -y Mid -z Mid LiveSurfaceB  ZCURVEModelingCAM;
    move -r -os -wd 0 -0.7 0 LiveSurfaceB ;
    move -r -os -wd 0 0 0.210031 LiveSurfaceB ;
    parentConstraint -mo -weight 1 ZCURVEModelingCAM  LiveSurfaceB;
    setAttr "ZCURVEModelingCAM.translateX" 48 ;
    setAttr "ZCURVEModelingCAM.translateY" 41 ;
    setAttr "ZCURVEModelingCAM.translateZ" 48 ;
    setAttr "ZCURVEModelingCAM.rotateX" -25 ;
    setAttr "ZCURVEModelingCAM.rotateY" 45;
    setAttr "ZCURVEModelingCAM.rotateZ" 0;
    return $CamConeLocator;
    }



}


/******************************************************************************
 * @procedure    RenderCurveSeg
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $SelC : string
 *   $STEPCrv : float
 *   $CrvTSi : float
 *   $CrvTEi : float
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] RenderCurveSeg(string $SelC, float $STEPCrv, float $CrvTSi, float $CrvTEi)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeSeg = `size($CreateSegAT)`;
    int $CountT = 0;
    float $CreateSegAT[];
    float $t = 0;
    string $myCurvex = $SelC;
    vector $NewCurveVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    //#print " RenderCurveSeg " ; print "line 870 "; print "\n" ;
    //float $STEPCrv =22.0;
    $CreateSegAT =FloatArrayAB($CrvTSi,$CrvTEi,$STEPCrv);
    $myCurvex = $SelC;
    $myCPOC = `pointOnCurve  -ch on -pr 0.0 -p $myCurvex`;
    $SizeSeg = `size($CreateSegAT)`;
    $CountT = 0;
    $t = 0;
    for($a = 0; $a < $SizeSeg;$a++){
    $t =  $CreateSegAT[$CountT];
    if($t>=1){$t=1;}
    if($t<=0){$t=0;}
    setAttr ($myCPOC +  ".parameter") $t ;
    $NewCurveVec[$CountT] = `getAttr  ($myCPOC + ".position")`;
    $CountT++;
    }
    delete $myCPOC;
    return $NewCurveVec;

}


/******************************************************************************
 * @procedure    Cut_CRV_Axis
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $myCurvex : string
 *   $axis : int
 *
 * @returns      float []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] Cut_CRV_Axis(string $myCurvex, int $axis)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $TrackIT = 0;
    float $numEPrealNum3 = ( $numEPs -1 );
    float $ArcL = `arclen $myCurvex`;
    float $Steps_toG = (1.0/$numEPrealNum3)/4;
    float $findPointU[];
    string $myCPOC = `pointOnCurve  -ch on -pr 0.0 -p $myCurvex`;
    vector $AXIS_XZY[];
    vector $PointCRV;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    global vector $WORLD_AXIS_ORIGIN;
    global vector $WORLD_AXIS_XYZ[];
    $AXIS_XZY[0]=$WORLD_AXIS_ORIGIN;
    $AXIS_XZY[1]=$WORLD_AXIS_XYZ[$axis];



    global int $in_front_of_PlaneX;

    global int $TrackInfront[];


    $CurveSelection = `ls -fl  ($myCurvex+".ep[0:*]")`;
    $CurveEPzCount = size($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum2 = ( $numEPs -1 ) * 2;
    $numEPrealNum3 = ( $numEPs -1 );
    $myCPOC = `pointOnCurve  -ch on -pr 0.0 -p $myCurvex`;
    $ArcL = `arclen $myCurvex`;
    $Steps_toG = (1.0/$numEPrealNum3)/4;

    $step = $numEPrealNum2;
    $step = $numEPrealNum3;
    $a =0;
    //$t =  $a/$step;
    $t =0;
    $ArcLT= $ArcL;
    $TrackIT = 0;
    for($a = 0; $t <= 1.0;$a++){

    setAttr ($myCPOC +  ".parameter") $t ;
    $PointCRV  = `getAttr  ($myCPOC + ".position")`;
    $distance=PtDist_to_Plane({$PointCRV},$AXIS_XZY);
    print ($in_front_of_PlaneX+"\n");
    if($TrackIT==0){
    $TrackInfront[`size($TrackInfront)`]=$in_front_of_PlaneX;
    }
    $TrackIT++;
    if($distance<$ArcL){

    $Steps_toC =PercentofN($ArcL,$distance);
    $Steps_toD =((100.0-$Steps_toC)/100.0)/2.0;
    $t += $Steps_toD;
    }
    if($distance<0.0008){
    $TrackIT=0;
    Loc $PointCRV;
    $findPointU[`size($findPointU)`] = $t;
    print ("steps Taken : "+$a+"\n");
    $t +=$Steps_toG;
    }
    if($a>3900){break;}

    }
    delete $myCPOC;
    return $findPointU;

}


/******************************************************************************
 * @procedure    PtDist_to_Plane
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $V : vector[]
 *   $VecN : vector[]
 *
 * @returns      float
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float PtDist_to_Plane(vector $V[], vector $VecN[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $p = $VecN[0];
    vector $n1 = $VecN[1];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global int $in_front_of_PlaneX;
    $p = $VecN[0];
    $n1 = $VecN[1];
    $F = $n1;
    $e = $V[0];
    $M = $e+($F);
    $D = distance2PtS($e, $p);
    if((`sign ($D)`==1)||($D==0)){
    $in_front_of_PlaneX=1; print $D;
    }else{$in_front_of_PlaneX=0; print $D;
    }
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $D1 = distance2Pts($P1, $p);
    return $D1;

}


/******************************************************************************
 * @procedure    distance2PtS
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $p1 : float[]
 *   $p2 : float[]
 *
 * @returns      float
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float distance2PtS(float $p1[], float $p2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $distance;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $v[0] = $p1[0] - $p2[0];
    $distance = $v[0];
    return $distance;

}


/******************************************************************************
 * @procedure    VecPointsMirrorVecPlaneN
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $V : vector[]
 *   $VecN : vector[]
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecPointsMirrorVecPlaneN(vector $V[], vector $VecN[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $C1;
    vector $p = $VecN[0];
    vector $n1 = $VecN[1];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $p = $VecN[0];
    $n1 = $VecN[1];
    $F = $n1;
    $C1=0;
    for($e in $V){
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+(($D1*2.0)*$F3);
    $O[$C1] = $F4;
    $C1++;
    }
    VecArrayToCurveB($O);
    ResetTransEachSL;

    return $O;

}


/******************************************************************************
 * @procedure    Cut_and_Mirror
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $N_Us : float[]
 *   $CRV_ItemI : string
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] Cut_and_Mirror(float $N_Us[], string $CRV_ItemI)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeCuts = `size($N_Us)`;
    int $m_Or_e[];
    int $Tsize = `size($iU)`;
    float $iU[] = $N_Us;
    float $Arc = `arclen($CRV_ItemI)`;
    float $TempU[];
    float $MperS = ($Arc*($iU[0]));
    float $MperE = ($Arc*(1-$iU[$SizeCuts-1]));
    float $TempUi[];
    float $Hsize = `size($iU)`;
    float $CrvTSi = $iU[$iC];
    float $CrvTEi = $iU[$iC+1];
    float $Mper = ($Arc*($iU[$iC+1]-$iU[$iC]));
    string $NewCutCRVs[];
    string $Sel[];
    vector $AXIS_XZY[];
    vector $CRVSEG_A[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global vector $WORLD_AXIS_XYZ[];
    global vector $WORLD_AXIS_ORIGIN;
    $Sel[0]=$CRV_ItemI;
    $SizeCuts = `size($N_Us)`;
    $iU = $N_Us;
    $Arc = `arclen($CRV_ItemI)`;
    if($SizeCuts>0){
    $Tsize = `size($iU)`;
    if($Tsize!= 1){

    $MperS = ($Arc*($iU[0]));
    $MperE = ($Arc*(1-$iU[$SizeCuts-1]));
    if( $MperS >= 5.5){
    $TempU[`size($TempU)`]=0.0;
    $m_Or_e[`size($m_Or_e)`]=1;
    }
    for($iC=0; $iC<$SizeCuts; $iC++){
    $TempU[`size($TempU)`]=$iU[$iC];
    }
    for($iC=0; $iC<$SizeCuts-1; $iC++){
    $m_Or_e[`size($m_Or_e)`]=0;
    }
    if($MperE>=5.5){
    $TempU[`size($TempU)`]=1.0;
    $m_Or_e[`size($m_Or_e)`]=2;
    }
    $iU=$TempU;
    }

    if($Tsize== 1){
    $TempUi[0]=0.0;
    $TempUi[1]=$iU[0];
    $TempUi[2]=1.0;
    $iU=$TempUi;
    $MperS = (100*($iU[1]));
    $MperE = (100*(1-$iU[1]));
    if( $MperS >= 15){$TempU[`size($TempU)`]=0.0; $m_Or_e[`size($m_Or_e)`]=1;  }
    $TempU[`size($TempU)`]=$iU[1];
    if($MperE>=15){$TempU[`size($TempU)`]=1.0; $m_Or_e[`size($m_Or_e)`]=2; }
    clear $iU;
    $iU=$TempU;
    }



    $AXIS_XZY[0]=$WORLD_AXIS_ORIGIN;
    $AXIS_XZY[1]=$WORLD_AXIS_XYZ[0];

    $AXIS_Z[0]=$WORLD_AXIS_ORIGIN;
    $AXIS_Z[1]=$WORLD_AXIS_XYZ[1];





    $Hsize = `size($iU)`;
    $Hsize-=1;

    for($iC=0; $iC<$Hsize; $iC++){
    clear $CRVSEG_A;
    $CrvTSi = $iU[$iC];
    $CrvTEi = $iU[$iC+1];
    $Mper = ($Arc*($iU[$iC+1]-$iU[$iC]));
    $CRVSEG_A=RenderCurveSeg($Sel[0],22,$CrvTSi,$CrvTEi);
    PAUSE;
    $NewCutCRVs[`size($NewCutCRVs)`]=VecArrayToCurveB($CRVSEG_A);
    }
    delete $Sel[0];
    }else{ $NewCutCRVs[`size($NewCutCRVs)`]=$Sel[0]; }

    return $NewCutCRVs;


}


/******************************************************************************
 * @procedure    RotateDir_Axis
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Rot_T : float
 *   $theta : float
 *   $Axis : vector
 *   $Direct : vector
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] RotateDir_Axis(float $Rot_T, float $theta, vector $Axis, vector $Direct)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $PI_Static = 3.14159265;
    float $ct = cos($theta);
    float $st = sin($theta);
    float $Nzx[];
    float $zxi = $Nzx[0];
    float $zyi = $Nzx[1];
    float $zzi = $Nzx[2];
    vector $Direction[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $xx=$Axis.x; $xy=$Axis.y; $xz=$Axis.z;
    $zx=$Direct.x; $zy=$Direct.y; $zz=$Direct.z;
    $PI_Static = 3.14159265;

    $theta *= ($PI_Static / 180.0);
    $ct = cos($theta);
    $st = sin($theta);


    for($i = 0; $i < 4;$i++){
    $ct = cos($theta);
    $st = sin($theta);

    $Nzx[0] = (float) ($zx * $ct + $xx * $st);
    $Nzx[1] = (float) ($zy * $ct + $xy * $st);
    $Nzx[2] = (float) ($zz * $ct + $xz * $st);
    $zxi = $Nzx[0];
    $zyi = $Nzx[1];
    $zzi = $Nzx[2];
    $zx = $Nzx[0];
    $zy = $Nzx[1];
    $zz = $Nzx[2];

    $theta+=$theta;

    $Nzx=$Direction[$i]=`unit(<<$zx, $zy, $zz>>)`;
    $zx = $Nzx[0];
    $zy = $Nzx[1];
    $zz = $Nzx[2];
    }
    return $Direction;

}


/******************************************************************************
 * @procedure    LocS
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $VEC_pt : vector[]
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] LocS(vector $VEC_pt[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Size = `size($VEC_pt)`;
    float $Points[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $Size = `size($VEC_pt)`;
    for($i = 0; $i < $Size;$i++){
    $Points = $VEC_pt[$i];
    $LocObject= `spaceLocator -p 0 0 0`;
    $LocObjectsi[$i]=$LocObject[0];
    setAttr ($LocObject[0]+".translate")  $Points[0] $Points[1] $Points[2];
    }
    return $LocObjectsi;

}


/******************************************************************************
 * @procedure    SortNumbersIntIndex
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $allFloatToSort : float[]
 *
 * @returns      int[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int[] SortNumbersIntIndex(float $allFloatToSort[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IndexTrack[];
    int $sIze = `size($aF)`-1;
    float $aF[] = $allFloatToSort;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $aF = $allFloatToSort;
    $sIze = `size($aF)`-1;
    $IndexTrack = CreateIntIndex(`size($aF)`);
    quickSort($aF, $IndexTrack, 0, $sIze);
    $IndexTrack = ReverseIntArray($IndexTrack);
    return $IndexTrack;

}


/******************************************************************************
 * @procedure    IndexPairFunc
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $XNum : int
 *
 * @returns      int []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IndexPairFunc(int $XNum)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Zss = $XNum*2;
    int $Yss = $Zss+1;
    int $pair[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Zss = $XNum*2;
    $Yss = $Zss+1;
    $pair={$Zss,$Yss};
    return $pair;

}


/******************************************************************************
 * @procedure    IndexPairFuncN
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $XNum : int
 *   $XNumV : int
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int IndexPairFuncN(int $XNum, int $XNumV)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Zss = $XNum*2;
    int $Yss = $Zss+1;
    int $AB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Zss = $XNum*2;
    $Yss = $Zss+1;
    if($XNumV==0){
    $AB=$Zss;
    }
    else{$AB=$Yss;}

    return $AB;

}


/******************************************************************************
 * @procedure    CreateIntIndex
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $ArraySize : int
 *
 * @returns      int []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] CreateIntIndex(int $ArraySize)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iNdex = 0;
    int $IntArrayInex[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $iNdex = 0;
    while($iNdex < $ArraySize){
    $IntArrayInex[$iNdex] = $iNdex;
    $iNdex++;
    }
    return $IntArrayInex;

}


/******************************************************************************
 * @procedure    ProjectCrv2PlaneNormalP
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $vecRs : vector[]
 *   $AvN : vector
 *   $Midp : vector
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] ProjectCrv2PlaneNormalP(vector $vecRs[], vector $AvN, vector $Midp)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeVp = `size($vecRs)`;
    int $CountF[];
    int $CountFN = 0;
    int $C1;
    int $trackit[];
    int $TF = 0;
    int $SizeC = `size($O)`;
    float $valN;
    vector $vecRsA[];
    vector $NewPtsP[];
    vector $PtsVec;
    vector $Tran;
    vector $DirectC = DirectionFN($vecRs[0], $Midp);
    vector $tan = crossProduct($DirectC,$AvN, 0, 0 );
    vector $V[];
    vector $p = `xform -q -ws -t "LiveSurfaceB"`;
    vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
    vector $n1 = $AvN;
    vector $RECORD[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $DirectC = DirectionFN($vecRs[0], $Midp);
    $tan = crossProduct($DirectC,$AvN, 0, 0 );
    $RowA = $tan;
    $RowB = $DirectC;
    $RowC = $AvN;
    // cent of matrix
    $AxisO = $Tran = $Midp;
    $SizeVp = `size($vecRs)`;
    $CountFN = 0;
    for($Ind=0; $Ind<$SizeVp; $Ind++){
    $PtsVec=$vecRs[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $Xv = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    $Dv=DirectionF($Xv,$PtsVec);
    $ZEROIi = $Dv*$AvN;
    $valN= $ZEROIi.x*$ZEROIi.y*$ZEROIi.z;
    $sign = `sign $valN`;
    $valN = (int) (($valN + $sign*5/(1.0*10)) * 1.0);
    $valN = ($valN/1.0);
    if($valN==1){
    $NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    $vecRsA[$CountFN]=$PtsVec;
    $CountF[$CountFN]=$Ind;
    $CountFN++;
    }
    }
    $V= $vecRsA;
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = $AvN;
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F4 = $NewPtsP[$C1];
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    $MatrixNewB = GetMatrix("ZCURVEModelingCAM");
    $MtxF  = MatrixToFloat($MatrixNewB);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};
    $TF = 0;
    $SizeC = `size($O)`;
    for($Ind=0; $Ind<$SizeC; $Ind++){
    $PtsVec= $O[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $TF=rectContains(-0.5,-0.5, 1.0, 1.0,$PtZ[0], $PtZ[2]);
    if($TF==1){
    $RECORD[`size($RECORD)`]=$O[$Ind];
    }
    $TF=0;
    }
    return $RECORD;

}


/******************************************************************************
 * @procedure    ClosestPoint2Line
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $DirectionLineF : float[]
 *   $PointOnLine : float[]
 *   $PointN : float[]
 *
 * @returns      float []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] ClosestPoint2Line(float $DirectionLineF[], float $PointOnLine[], float $PointN[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $locsA[];
    float $Addit[] = $VecLineDirM;
    float $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    float $Dist2LStart = distance2Pts( $PN , $PoL);
    vector $VlocA;
    vector $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    vector $VecLineDir = PositiveDir($DirectionLineF);
    vector $VecLineDirM = $VecLineDiri-$VecLineDir;
    vector $DF = FloatToVec($DirectionLineF);
    vector $PoL = FloatToVec($PointOnLine);
    vector $PN = FloatToVec($PointN);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    $VecLineDir = PositiveDir($DirectionLineF);
    $VecLineDirM = $VecLineDiri-$VecLineDir;
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    $DF = FloatToVec($DirectionLineF);
    $PoL = FloatToVec($PointOnLine);
    $PN = FloatToVec($PointN);
    if($AdditR != 0.0){
    $A =($DF*1.0)+$PoL;
    $N1 = Normal3Points($PoL, $A, $PN);
    $Dist2LStart = distance2Pts( $PN , $PoL);
    $A2 =($Dist2LStart*$N1)+$PoL;
    $N2 = Normal3Points($PoL, $A2, $A);
    $A3 =($Dist2LStart*$N2)+$PoL;
    $locsA = lineIntersection($PN, $A3, $PoL,  $DF);
    }else{$locsA =  $PointN ;}
    return $locsA;

}


/******************************************************************************
 * @procedure    ClosestPoint2LineVec
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $DirectionLineF : float[]
 *   $PointOnLine : float[]
 *   $PointN : float[]
 *
 * @returns      vector
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector ClosestPoint2LineVec(float $DirectionLineF[], float $PointOnLine[], float $PointN[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $locsA[];
    float $Addit[] = $VecLineDirM;
    float $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    float $Dist2LStart = distance2Pts( $PN , $PoL);
    vector $VlocA;
    vector $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    vector $VecLineDir = PositiveDir($DirectionLineF);
    vector $VecLineDirM = $VecLineDiri-$VecLineDir;
    vector $DF = FloatToVec($DirectionLineF);
    vector $PoL = FloatToVec($PointOnLine);
    vector $PN = FloatToVec($PointN);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    $VecLineDir = PositiveDir($DirectionLineF);
    $VecLineDirM = $VecLineDiri-$VecLineDir;
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    $DF = FloatToVec($DirectionLineF);
    $PoL = FloatToVec($PointOnLine);
    $PN = FloatToVec($PointN);
    if($AdditR != 0.0){
    $A =($DF*1.0)+$PoL;
    $N1 = Normal3Points($PoL, $A, $PN);
    $Dist2LStart = distance2Pts( $PN , $PoL);
    $A2 =($Dist2LStart*$N1)+$PoL;
    $N2 = Normal3Points($PoL, $A2, $A);
    $A3 =($Dist2LStart*$N2)+$PoL;
    $locsA = lineIntersection($PN, $A3, $PoL,  $DF);
    $VlocA = <<$locsA[0],$locsA[1],$locsA[2]>>;
    }else{$VlocA = FloatToVec($PointN);}
    return $VlocA;

}


/******************************************************************************
 * @procedure    ProjectCrv2PlaneNormalPindex
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $vecRs : vector[]
 *   $AvN : vector
 *   $Midp : vector
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] ProjectCrv2PlaneNormalPindex(vector $vecRs[], vector $AvN, vector $Midp)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeVp = `size($vecRs)`;
    int $CountF[];
    int $CountFN = 0;
    int $C1;
    int $trackit[];
    int $TF = 0;
    int $TFcn = 0;
    int $SizeC = `size($O)`;
    float $valN;
    vector $vecRsA[];
    vector $NewPtsP[];
    vector $PtsVec;
    vector $Tran;
    vector $DirectC = DirectionFN($vecRs[0], $Midp);
    vector $tan = crossProduct($DirectC,$AvN, 0, 0 );
    vector $V[];
    vector $p = `xform -q -ws -t "LiveSurfaceB"`;
    vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
    vector $n1 = $AvN;
    vector $RECORD[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global int $Index3dVecs2P[];
    global vector $AllKnowVecsInView[];
    clear $Index3dVecs2P;
    clear $AllKnowVecsInView;

    $DirectC = DirectionFN($vecRs[0], $Midp);
    $tan = crossProduct($DirectC,$AvN, 0, 0 );
    $RowA = $tan;
    $RowB = $DirectC;
    $RowC = $AvN;
    // cent of matrix
    $AxisO = $Tran = $Midp;
    $SizeVp = `size($vecRs)`;
    $CountFN = 0;
    for($Ind=0; $Ind<$SizeVp; $Ind++){
    $PtsVec=$vecRs[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $Xv = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    $Dv=DirectionF($Xv,$PtsVec);
    $ZEROIi = $Dv*$AvN;
    $valN= $ZEROIi.x*$ZEROIi.y*$ZEROIi.z;
    $sign = `sign $valN`;
    $valN = (int) (($valN + $sign*5/(1.0*10)) * 1.0);
    $valN = ($valN/1.0);
    if($valN==1){
    $NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    $vecRsA[$CountFN]=$PtsVec;
    $CountF[$CountFN]=$Ind;
    $CountFN++;
    }
    }
    $V= $vecRsA;
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = $AvN;
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F4 = $NewPtsP[$C1];
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    $MatrixNewB = GetMatrix("ZCURVEModelingCAM");
    $MtxF  = MatrixToFloat($MatrixNewB);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};
    $TF = 0;
    $TFcn = 0;
    $SizeC = `size($O)`;
    for($Ind=0; $Ind<$SizeC; $Ind++){
    $PtsVec= $O[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $TF=rectContains(-0.5,-0.5, 1.0, 1.0,$PtZ[0], $PtZ[2]);
    if($TF==1){
    $RECORD[$TFcn`]=$O[$Ind];
    $AllKnowVecsInView[$TFcn]= $vecRsA[$Ind];
    $FinalIndex[$TFcn]=$CountF[$Ind];
    $TFcn++;
    }
    $TF=0;
    }
    $Ind3dV2P=$FinalIndex;
    return $RECORD;

}


/******************************************************************************
 * @procedure    VecPointsToPlaneX
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $V : vector[]
 *   $n1 : vector
 *   $p : vector
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecPointsToPlaneX(vector $V[], vector $n1, vector $p)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeVp = `size($vecRs)`;
    int $CountF[];
    int $CountFN = 0;
    int $C1;
    int $trackit[];
    int $TF = 0;
    int $SizeC = `size($O)`;
    int $AddUp = 0;
    int $NumerinArray = `size($numberArrayi)`-1;
    int $Ni = $Ai;
    int $Nii = $Bi;
    int $range = abs ($Ai-$Bi);
    int $ixNa = $iC+$Ai;
    int $MatrixNi = $MatrixN-1;
    int $BytNum[];
    int $BytNumSort[] = $BytNum;
    int $BytNumLarg = $BytNumSort[`size($BytNumSort)`-1];
    int $BytNumSmall = $BytNumSort[0];
    int $BytNumDiff[];
    int $IndXeF = 0;
    int $IndXeFi = 0;
    int $Count = 0;
    int $Xz = 0;
    int $IndexLetters[] = CreateIntIndex(`size($ArrayLetter)`);
    int $BytNumi;
    int $StringIndex[];
    int $countIndex = 0;
    int $indexStart[];
    int $indexFirstCharItems[];
    int $BytNx = 0;
    int $freezeTrigger = 0;
    int $eachInt = 0;
    int $iixI = 0;
    int $TFandIndex[];
    int $TFandIndexii[];
    int $FirstLFindIndex;
    int $Tri = 0;
    int $Trii = 2;
    int $CountFoundletters = 0;
    int $SizeItem = `size $matchTemp`;
    int $CountTotalFindIndex = 0;
    int $CountIndex[];
    int $findByt;
    int $iX = 0;
    int $AddAll;
    int $FindNum = 0;
    int $FindIndexN[];
    int $LineNumberA[];
    int $CountN = 0;
    int $i;
    int $indexS = `size($indexA)`;
    int $len = size( $list );
    int $Xi = 0;
    int $newInt[];
    int $Ix = 0;
    int $ii = 0;
    int $Ixi = 0;
    int $IndeXxz[];
    int $size = `size($IndeXxI)`-1;
    int $index = 0;
    int $Size;
    int $IndeXxiz[] = sort($IndeXz);
    int $SizA = `size($IndeXz)`;
    int $Ixx = 0;
    int $IntA[];
    int $Trigger = 0;
    int $CountCase = 0;
    int $returnCaseN[];
    int $Number;
    int $BytS = 1;
    int $TRUEA = 0;
    int $X = 0;
    int $NumberE[];
    int $ixX = 0;
    int $iNdex = 0;
    int $IntArrayInex[];
    int $CC = 0;
    int $fileId = `fopen $exampleFileName "r"`;
    int $failsafe = 0;
    int $CNX = 0;
    int $SizeAll = `size($shorterListAllVarZ)`;
    int $CountLineX = 0;
    int $fileIdW = `fopen $exampleFileNameW "w"`;
    int $NegPosZA[];
    int $WhenZero = 2;
    int $CountNL = 1;
    int $CountFindNL = 0;
    int $CountX = 0;
    int $TriggerLineFound = 0;
    int $START = 0;
    int $DontWrite = 0;
    int $LineNumber[];
    int $CountMasterInDex = 0;
    int $IndexTrack[];
    int $sIze = `size($aF)`-1;
    int $EArray[];
    int $SizeL = `size($CollectAllLines)`;
    int $iL;
    int $tempLineNumber[];
    int $foundNA[];
    int $intIDXSort[] = SortIntIndexTrack($foundNA);
    int $IndexR[];
    int $IndeXCN[];
    int $SizeCD = `size($newCollectDupString)`-1;
    int $intIDXSortX[] = SortIntIndexTrack($IndeXCN);
    int $newfoundNA[];
    int $TempSaveLine[];
    int $CurrentLineN[];
    int $CurrentLineNF[];
    int $IndexX[];
    int $MasterLineN[];
    int $LN_temp[];
    int $CurrentLineNX[];
    int $Aint = size($CollectAllLines);
    int $Bint = size($AllFoundProcs);
    int $Cint = size($CAL_temp);
    int $CHECK = $Aint-$Cint;
    int $TRIGGEREND = 2;
    int $NewMasterLineN[];
    int $XIndexN[];
    int $SortedList[];
    int $LINEplace[];
    int $STARTN = 0;
    int $FLOATindex = 0;
    int $Inx = 0;
    int $Inxb = 0;
    int $colori[];
    int $COUNT = 0;
    int $CN = 0;
    int $SizeF = `sizeBytes  $Find `;
    int $SizeABCs = `sizeBytes  $ABCs `;
    int $j;
    int $lowest = -1;
    int $father = tournamentSelect($fitness, $tournamentSize);
    int $mother = tournamentSelect($fitness, $tournamentSize);
    int $parent = (int)rand ($gPopulationSize), $i, $tmp;
    int $script_jobToolChangedNum1 = 505;
    int $script_jobToolChangedNum2 = 606;
    int $scriptt_jobAllCurvesToolsNumA;
    int $scriptt_jobAllCurvesToolsNumB;
    int $jobNumtranslateCAM;
    int $jobNumrotateCAM;
    int $addNumbersA;
    int $scriptt_jobNumConnectionChanged = `scriptJob -conditionChange delete evalVectorIndexAdditionSubtract`;
    int $script_jobNumIdle_MoveZCURVEM = `scriptJob   -runOnce 1 -event idle EVALCamScripts`;
    int $intIndexCurveZ[] = CreateIntIndex(`size($objVecMain)`);
    int $indexNumberZ[] = stringArrayGmatchArrayIndex($diffBZ, $KnowObjList);
    int $indexX = 0;
    int $iXn = 0;
    int $newOrderA[];
    int $indexLoc = 0;
    int $newOrderB[];
    int $IfemptyIsTrue = 0;
    int $numCVs = `getAttr -size ($CurveItem[0]+".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $XiV = 0;
    int $IndexVec = 0;
    int $IndexVecRemain = 0;
    int $IndexV[] = CreateIntIndex(`size($AllPlaneLocPosition)`);
    int $IndexReduced[];
    int $indexRecord = 0;
    int $indexPoints = 0;
    int $Lastindex = 0;
    int $lastIntIndex[];
    int $indexM = 0;
    int $FourDiections = 0;
    int $inDexName = 0;
    int $Value = stringArrayGmatchFind($idnodeType3, "controlPoint");
    int $sizeitem = `size($itemA)`;
    int $ResultIndex[];
    int $Index = 0;
    int $BreakTrigger = 0;
    int $vectorSize = `size($worldPosZ)`;
    int $vecCount = `size($worldPosZ)`;
    int $Vii = 0;
    int $Numberlist[];
    int $triggerendsB = 0;
    int $newlistSize = size($singleStringItemB);
    int $ci = 0;
    int $zeroORZe1 = `gmatch "e" $nameAe`;
    int $zeroORZe2 = `gmatch "e" $nameBe`;
    int $zeroORZe3 = `gmatch "e" $nameCe`;
    int $SizeOfArrayA = size($EdgeCurveZ1);
    int $SizeOfArray = size($EdgeCurveZ1) -1;
    int $E = -1;
    int $SizeOfArrayB = size($EdgeCurveZ1);
    int $zeroOR1Z = `gmatch "Curve" $nameA`;
    int $CreatedObjectCurve = `ISobjectSelectedTypeCurve`;
    int $pX = equivalentTol($posA[0], $posB[0], $TRange);
    int $pY = equivalentTol($posA[1], $posB[1], $TRange);
    int $pZ = equivalentTol($posA[2], $posB[2], $TRange);
    int $addedResults = $pX + $pY + $pZ;
    int $sIZes = 2;
    int $NUmers[] = CreateIntIndex($sIZes);
    int $iNew;
    int $Ai = 0;
    int $Bi = 0;
    int $N = 0;
    int $store;
    int $Times = $AS*2;
    int $CombA = PointsEquivalentTol ($PointN, $pAv);
    int $MasterCount = 0;
    int $Par = 0;
    int $CountSteps;
    int $TwoNew[];
    int $count = 0;
    int $evenOdd = fmod($sIZes, 2);
    int $sIZesHalf = (($sIZes)/2)+1;
    int $countN = 0;
    int $CountVV = 0;
    int $xyz = $EmptyIndx[0];
    int $isOrthoTrueZi = 0;
    int $edgeZsetA;
    int $edgeZsetB;
    int $ReducedIndexA[] = floatArrayCountDuplicates($distancesEachToCurve);
    int $ReducedIndexB[] = floatArrayCountDuplicates($distancesEachToCurveB);
    int $NearestInt[] = SortNumbersIntIndex($distAz);
    int $NearestIntB[] = SortNumbersIntIndex($distBz);
    int $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    int $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];
    int $NearestIndex;
    int $NearestIndexEach;
    int $ReducedIndexXAB[];
    int $AxisOrthoLineA = $AxisOrthoLine;
    int $iVc = 0;
    int $TrackFoundN[];
    int $TrackN[];
    int $TwoPointsi[];
    int $AXIS = $AxisOrthoLineA;
    int $ALLlikeness[];
    int $ALLlikenessForce[];
    int $TriggerPoints;
    int $SortedForce[];
    int $Sorted[] = SortNumbersIntIndex($distTo3DCurveEnd);
    int $ReducedIndex[] = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    int $OntheSameLine = 0;
    int $AddInt = $AdditR;
    int $NoneDup[];
    int $indexAx[] = CreateIntIndex(6);
    int $indexAxNew[] = ArrayToIntList( $BestThree);
    int $color;
    int $iiX = 0;
    int $Cindex = 0;
    int $IndexZ = $indexAxNew[$Count];
    int $triggerMiddle = 0;
    int $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
    int $iv = -1;
    int $CRV_index_number = 0;
    int $CRc = 0;
    int $CRcT = 0;
    int $countS = 0;
    int $COuntN = 0;
    int $EDGEpoints[];
    int $pointNearEdgeCurve[];
    int $SnappingVector = 0;
    int $OneIsNotNearThePlane = 0;
    int $Sortedi[] = SortNumbersIntIndex($distancesTo3DCurveEndi);
    int $iiz = 0;
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum2 = (( $numEPs -1 ) * 2 );
    int $COuntNN = 0;
    int $In[] = {1,0,2,3};
    int $CountIntA = 0;
    int $CountInt = 0;
    int $CountIndexV = 0;
    int $xIndex = $Index[$r];
    int $q = Partition($a, $Index, $p, $r);
    int $trueOrFalse = IsPointInLine ($Vecbv[0], $Vecbv[1], $centerCross);
    int $returnVal = 0;
    int $EIndex[];
    int $Ii = 0;
    int $one;
    int $START_END[];
    int $EndsAtZero;
    int $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);
    int $IfTrue;
    int $weighedtFindings = 0;
    int $weighedtFindingsZ = 0;
    int $weighedtFindingsN = 0;
    int $triggerStraitCRV = 0;
    int $triggerNoTransENDA = 0;
    int $triggerNoTransENDB = 0;
    int $First_Second_Both_None = 0;
    int $trigger_straitC = 0;
    int $Trueii = 0;
    int $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
    int $TrackAllExisting3DCrv[] = CreatePairIntIndex($SizeCrvi);
    int $SizeCrvR = `size($LayerCurvesRangeA)`;
    int $triggerNoTrans = 0;
    int $triggerNoTransA = 0;
    int $triggerNoTransB = 0;
    int $iia = 0;
    int $iis = 0;
    int $AllLocsi[] = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    int $New_AllLocs_A[];
    int $Near_index_A = $New_AllLocs_A[0];
    int $New_AllLocs_B[];
    int $Near_index_B = $New_AllLocs_B[0];
    int $ConnectedEnds = $triggerNoTransENDA + $triggerNoTransENDB;
    int $AddAB = $triggerNoTransA+$triggerNoTransB;
    int $New_AllLocs_AB[];
    int $PairInt[];
    int $ifCond_is_True = `ISSelectedTypeCurve`;
    int $LocatorLoop = 0;
    float $hfv = `camera -q -hfv ZCURVEModelingCAM`;
    float $ptx = (($ptVecCs.x/(-$ptVecCs.z))/tand($hfv/2))/2.0;
    float $vfv = `camera -q -vfv ZCURVEModelingCAM`;
    float $pty = (($ptVecCs.y/(-$ptVecCs.z))/tand($vfv/2))/2.0;
    float $ptz = $ptVecCs.z;
    float $valN;
    float $FixVecT[];
    float $R[] = $O;
    float $Pi = 3.1415926535;
    float $pi = 3.1415926535;
    float $CamPos1[];
    float $LivePlanePos[];
    float $CamerasDirectionVectorNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
    float $FloatDirectionA[] = DirectionFN($CamPos1, $LocPos1);
    float $DistanceLoc = distance2Pts( $LocPos1, $CamPos1 );
    float $DistanceLocA = $DistanceLoc;
    float $MultDirPC1[] = multiplyFloat($DistanceLoc, $CamerasDirectionVector);
    float $FloatDirectionCamNormal[] = AddFloats($CamPos1, $MultDirPC1);
    float $CamerasDirectionVectorA[] = DirectionFN($FloatDirectionCamNormal, $CamPos1);
    float $MultDirPC1A[] = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
    float $p1[] = $CamPos1;
    float $p2[] = $LocPos1;
    float $p3[] = $FloatDirectionCamNormal;
    float $center[];
    float $normal[];
    float $FloatPosZero[] = {0, 0, 0};
    float $FloatDirection[] = DirectionFN($FloatPosZero, $normal);
    float $FloatDirPerpCenterC[] = DirectionFN($center,$mid2);
    float $FloatDirPointAC[] = DirectionFN($p1, $p3);
    float $center8[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    float $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
    float $FloatDirLocToPerpIntersect[] = DirectionFN($center8,$p2);
    float $OnPlane[] = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );
    float $v[] = `getAttr $attr`;
    float $aF[];
    float $theta;
    float $ct = cos($theta);
    float $st = sin($theta);
    float $Nxx = (float) ($xx * $ct + $zx * $st);
    float $Nxy = (float) ($xy * $ct + $zy * $st);
    float $Nxz = (float) ($xz * $ct + $zz * $st);
    float $Nxo = (float) ($xo * $ct + $zo * $st);
    float $Nzx = (float) ($zx * $ct - $xx * $st);
    float $Nzy = (float) ($zy * $ct - $xy * $st);
    float $Nzz = (float) ($zz * $ct - $xz * $st);
    float $Nzo = (float) ($zo * $ct - $xo * $st);
    float $Nyx = (float) ($yx * $ct + $zx * $st);
    float $Nyy = (float) ($yy * $ct + $zy * $st);
    float $Nyz = (float) ($yz * $ct + $zz * $st);
    float $Nyo = (float) ($yo * $ct + $zo * $st);
    float $lxx = $xx * $rhs[0][0] + $yx * $rhs[1][0] + $zx * $rhs[2][0];
    float $lxy = $xy * $rhs[0][0] + $yy * $rhs[1][0] + $zy * $rhs[2][0];
    float $lxz = $xz * $rhs[0][0] + $yz * $rhs[1][0] + $zz * $rhs[2][0];
    float $lxo = $xo * $rhs[0][0] + $yo * $rhs[1][0] + $zo * $rhs[2][0] + $rhs[3][0];
    float $lyx = $xx * $rhs[0][1] + $yx * $rhs[1][1] + $zx * $rhs[2][1];
    float $lyy = $xy * $rhs[0][1] + $yy * $rhs[1][1] + $zy * $rhs[2][1];
    float $lyz = $xz * $rhs[0][1] + $yz * $rhs[1][1] + $zz * $rhs[2][1];
    float $lyo = $xo * $rhs[0][1] + $yo * $rhs[1][1] + $zo * $rhs[2][1] + $rhs[3][1];
    float $lzx = $xx * $rhs[0][2] + $yx * $rhs[1][2] + $zx * $rhs[2][2];
    float $lzy = $xy * $rhs[0][2] + $yy * $rhs[1][2] + $zy * $rhs[2][2];
    float $lzz = $xz * $rhs[0][2] + $yz * $rhs[1][2] + $zz * $rhs[2][2];
    float $lzo = $xo * $rhs[0][2] + $yo * $rhs[1][2] + $zo * $rhs[2][2] + $rhs[3][2];
    float $x = $v[$i];
    float $y = $v[$i + 1];
    float $z = $v[$i + 2];
    float $Mn[];
    float $Mng[];
    float $FLoatMatrixA[] = MatrixToFloat($MatriXM);
    float $matrixFloat[];
    float $MultDir[] = multiplyFloat($Length,  $Direction);
    float $FloatDirectionNormalA[] = AddFloats($posA, $MultDir);
    float $MatrizFloatiA[];
    float $Xcross[] = $PtsVecCross;
    float $XcrossP[] = {$Xcross[0],$Xcross[1],1.0};
    float $PtsFCrossBB[] = (lineIntersectionF($SQuarePts[0], $pointMakeS[1], $SQuarePts[1], $pointMakeS[0]));
    float $Yaxis[] = PositiveDirectionLine($SQuarePts[1],$pointMakeS[1]);
    float $Xaxis[] = crossProduct( $Yaxis, $DirNorA, 0, 0 );
    float $NormZ[] = $DirNorA;
    float $AllF[];
    float $DISTANCE = distance2Pts($Vec_Array, $PlaneP);
    float $ARCL = `arclen $CURVE[0] `;
    float $AngleA = `angle $DirLineX $DirLineCamTOx`;
    float $AngleADegreeX = `rad_to_deg $AngleA`;
    float $AngleB = `angle $DirLineN $DirLineCamTOy`;
    float $AngleADegreeY = (`rad_to_deg $AngleB`-90.0);
    float $FOUNDZ = 135.000001 -45.0;
    float $CamMfloatZ[];
    float $FirstTrans[] = $VrotatsFIRST;
    float $FirstRot[] = $VrotatsFIRST;
    float $AngleAX = `angle  $DirLineAX $DirLineX`;
    float $AngleAY = `angle  $DirLineAY $DirLineY`;
    float $AngleADegree = `rad_to_deg $AngleA`;
    float $fitness[];
    float $indexFitness = 100000;
    float $lowestFitness = $fitness[$lowest];
    float $roundScale = pow(10,$n);
    float $EACHCVposAZ[];
    float $eachCVpos[];
    float $pointAZ1[];
    float $AveragePoints[] = `xform -q -ws -t LiveSurfaceB`;
    float $Direct[] = DirectionF( $each, $AveragePoints);
    float $PlaneDimentionsV = distance2Pts( $SurfEnds[0], $SurfEnds[1]);
    float $PlaneDimentionsH = distance2Pts( $SurfEnds[1],$SurfEnds[3]);
    float $RadiusMax = distance2Pts( $AveragePoints, $SurfEnds[0]);
    float $FoundDistance;
    float $PlaneDimentionsVH = $PlaneDimentionsV/100;
    float $PlaneDimentionsHH = $PlaneDimentionsH/100;
    float $LocPoint[] = $eachPoint;
    float $MultDirAV[];
    float $DistanceA = distance2Pts( $MiddlePointA[$indexM],  $LocPoint);
    float $FloatDirectionPointz[] = AddFloats($MultDirAV, $LocPoint);
    float $DistanceB = distance2Pts( $MiddlePointA[$indexM],  $FloatDirectionPointz);
    float $Zx[] = $ThreeFLoatArrays;
    float $coiDistance = 0.0;
    float $coi[] = `getAttr ($ppm+".output")`;
    float $sum = 0;
    float $AllDistances[];
    float $MultDirDist[] = multiplyFloat($Distance ,$Direction);
    float $FloatPointLoc[] = AddFloats($PointA, $MultDirDist);
    float $Added_floats[] = { 0.0, 0.0, 0.0};
    float $FloatFromVec[];
    float $VposA;
    float $VposB;
    float $VposC;
    float $FloatFromVecA[] = $worldPosZ[$Vii];
    float $a = ($Added_floats[0])/float($vectorSize);
    float $b = ($Added_floats[1])/float($vectorSize);
    float $c = ($Added_floats[2])/float($vectorSize);
    float $PointsAverage[] = {$a , $b , $c};
    float $MagVectorZYHigher = mag ($vectorZFlatYHigher);
    float $MagVectorZYLower = mag ($vectorZFlatYLower);
    float $AddposA_AND_posB_float[];
    float $SubtractposA_AND_posB_float[];
    float $Timespos[];
    float $FloatZi[];
    float $vPoint[] = {$a , $b , $c};
    float $valuesBi[] = $eachVeCx;
    float $Floatlist[] = $allFloatToSort;
    float $MultLengthDir[] = multiplyFloat($Length, $Dir);
    float $AddMultDirPos[] = AddFloats($Pos, $MultLengthDir);
    float $RowA[] = $VecR[0];
    float $RowB[] = $VecR[1];
    float $RowC[] = $VecR[2];
    float $GivenPoint[] = $PtsVec;
    float $NewPoint[];
    float $NewPointa[];
    float $NewPointb[];
    float $NewPtMatrixMult[];
    float $pAv[] = AverageVectorPoint($Vec);
    float $n[] = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    float $MultDirCam[] = multiplyFloat($DistanceLoc, $n);
    float $FloatDirectionCamNormalA[] = AddFloats($pAv, $MultDirCam);
    float $PointN[] = ClosestPoint2LineVec($n, $pAv, $Veciiv);
    float $FloatDirectionAi[] = DirectionFN($pAv,$PointN);
    float $AddMultMiiF[] = AddFloats($Veciiv, $MultDirPC1);
    float $EulerAngleA[] = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $vector_SubUnitMagVec1[];
    float $UnitDirection[] = $vectorUnit;
    float $DirAB[] = DirectionF ($PosA, $PosB);
    float $DirCD[] = DirectionF ($PosC, $PosD);
    float $locsA[] = lineIntersection($PosA, $DirAB, $PosC, $DirCD);
    float $MatrixA[] = `MatrixToFloat($m)`;
    float $CleanFLoats[];
    float $values[];
    float $CurvatureRadi;
    float $point1[] = FloatToVec($Vecs[0]);
    float $point2[] = FloatToVec($Vecs[1]);
    float $point3[] = FloatToVec($Vecs[2]);
    float $normalA[] = `unit ($normalV[0])`;
    float $normalB[] = `unit ($normalV[1])`;
    float $normalAAdd = $normalA[0] + $normalA[1];
    float $normalAAdd2 = $normalB[0] + $normalB[1];
    float $FArrayInex[];
    float $AddF = 0;
    float $Divide = $AddAll/$Ix;
    float $Vt[];
    float $PastF;
    float $FloatDirA[];
    float $Anglei;
    float $ThreeFs[];
    float $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    float $distancesEachToCurve[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    float $distancesEachToCurveB[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    float $distAz[];
    float $distBz[];
    float $CamPos_A[];
    float $EpipolXx[] = {0.0,$CamPos_A[1],$CamPos_A[2]};
    float $PlaneEpipolXx[] = FloatPointsToCamPlane( $EpipolXx);
    float $EpipolYx[] = {$CamPos_A[0],0.0,$CamPos_A[2]};
    float $PlaneEpipolYx[] = FloatPointsToCamPlane( $EpipolYx);
    float $EpipolZx[] = {$CamPos_A[0],$CamPos_A[1],0.0};
    float $PlaneEpipolZx[] = FloatPointsToCamPlane( $EpipolZx);
    float $MidCurveA[] = MidPoint($CRV_ENDSi[0], $CRV_ENDSi[1]);
    float $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    float $FPointN_LineC[];
    float $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);
    float $XY[];
    float $XYZi[];
    float $XYZadd[];
    float $Xd;
    float $Yd;
    float $Zd;
    float $All_X[];
    float $All_Y[];
    float $All_Z[];
    float $All_ZYX[];
    float $All_ZYXDiff[];
    float $diffXYZ;
    float $Dist_3DNear = (($Dist_3D/3.0)*2.0);
    float $newOrderFloat;
    float $distTo3DCurveEnd[] = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    float $SdistTo3DCurveEnd[];
    float $Additi[];
    float $AdditiB[];
    float $AdditRi;
    float $AdditRiX;
    float $DistSnap;
    float $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    float $Addit[];
    float $AdditR;
    float $MatrixB[] = `MatrixToFloat($m2)`;
    float $DistToPoint = distance2Pts($Pos_A, $VecLoc);
    float $SnapD = 0.003;
    float $MultDirForWard[] = multiplyFloat(-1, $CamerasDirectionVector);
    float $DirectionVectorXn[] = {-2,0,0};
    float $DirectionVectorX[] = {2,0,0};
    float $DirectionVectorY[] = {0,-2,0};
    float $DirectionVectorYn[] = {0,2,0};
    float $DirectionVectorZn[] = {0,0,-2};
    float $DirectionVectorZ[] = {0,0,2};
    float $FloatPointDirectionXn[] = AddFloats($CamPos1, $DirectionVectorXn);
    float $FloatPointDirectionX[] = AddFloats($CamPos1, $DirectionVectorX);
    float $FloatPointDirectionY[] = AddFloats($CamPos1, $DirectionVectorY);
    float $FloatPointDirectionYn[] = AddFloats($CamPos1, $DirectionVectorYn);
    float $FloatPointDirectionZn[] = AddFloats($CamPos1, $DirectionVectorZn);
    float $FloatPointDirectionZ[] = AddFloats($CamPos1, $DirectionVectorZ);
    float $AverageVecXYZsOnP[] = AverageVectorPoint($VecXYZsOnPlane);
    float $AnglesAll[];
    float $ANgnew[] = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
    float $LengCRV_a = `arclen $CurveItemA`;
    float $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
    float $AverageVecCurEndsP[] = AverageVectorPoint($VecCurEnds);
    float $FloatPointDirectionZniY[];
    float $CurveDirectionZiY[];
    float $FloatPointDirectionZniiY[];
    float $CurveDirectionZiiY[];
    float $CurvePsD[] = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
    float $FloatPointDirectVpoint[];
    float $CurveDirectionVpoint[];
    float $locsAi[];
    float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;
    float $CamNormM[] = ` MirrorFloatXYZ 0 $MultDirCam`;
    float $MidEpipolZx[] = MidPoint($CamPos_M, $CamPos_A);
    float $MidEpipolPosFCam[] = FloatPointsToCamPlane($MidEpipolZx);
    float $INTERSECTIONLA[] = lineIntersectionF($VecCurEnds[0], $EpipLolar[0], $VecCurEnds[1],  $EpipLolar[1]);
    float $INTERSECTIONLB[] = lineIntersectionF($VecCurEnds[1], $EpipLolar[0], $VecCurEnds[0],  $EpipLolar[1]);
    float $IntersectEnds_Ai[];
    float $IntersectEnds_Bi[];
    float $distsA = $NdistA;
    float $distsB = $NdistB;
    float $PtsM_Ai[];
    float $PtsM_Bi[];
    float $INTERSECTIONLC[] = lineIntersectionF($EpipLolar[0], $PtsM_Ai, $INTERSECTIONLA, $EpipLolar[2]);
    float $INTERSECTIONL2C[] = lineIntersectionF($EpipLolar[0], $VecCurEnds[0], $INTERSECTIONLC, $EpipLolar[2]);
    float $INTERSECTIONL2D[] = lineIntersectionF($EpipLolar[1],$INTERSECTIONLC, $VecCurEnds[1],  $EpipLolar[2]);
    float $INTERSECTIONL3D[] = lineIntersectionF($EpipLolar[0],$INTERSECTIONL2D,$PtsM_Ai,  $EpipLolar[1]);
    float $ThreepointVecs[];
    float $EdgeDist;
    float $smallestDistance;
    float $distancesTo3DCurveEnd[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
    float $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
    float $distancesTo3DCurveEndi[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
    float $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
    float $XX = $VecA.x;
    float $XXX = $VecB.x;
    float $step = $numEPrealNum2;
    float $StepCycle = 0;
    float $AverageC = AverageFloats($CurvatureRadi);
    float $AboveOrBelow[] = GatherDataRR($CurvatureRadi, ($AverageC-(($AverageC/6.0)*5.0)));
    float $AVvects[];
    float $Aver;
    float $MultDirOne[] = multiplyFloat(1.0, $DirectionLineF);
    float $AddMultF[] = AddFloats($PointOnLine, $MultDirOne);
    float $FDirNorA[] = Normal3Points($PointOnLine, $AddMultF, $PointN);
    float $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    float $MultDirMx[] = multiplyFloat($DistToLineSTart, $FDirNorA);
    float $AddMultMiiFx[] = AddFloats($PointOnLine, $MultDirMx);
    float $FDirNorB[] = Normal3Points($PointOnLine, $AddMultMiiFx,  $AddMultF);
    float $MultDirMxz[] = multiplyFloat($DistToLineSTart,  $FDirNorB);
    float $AddMultMiiFxz[] = AddFloats($PointOnLine, $MultDirMxz);
    float $test[] = `xform -query -ws -t`;
    float $SideA = distance2Pts( $VecA, $VecB);
    float $SideB = distance2Pts( $VecB, $VecC);
    float $SideC = distance2Pts( $VecC, $VecA);
    float $ArcangleB = acos((((`pow $SideA 2.000`) + (`pow $SideC 2.000`) - (`pow $SideB 2.000`) )/(2.000*$SideA*$SideC)));
    float $AngleNPiB = ($ArcangleB*180)/$Pi;
    float $AngleNB = $AngleNPiB;
    float $LengthA = distance2Pts ($VecPairA[0], $VecPairA[1]);
    float $LengthB = distance2Pts ($VecPairB[0], $VecPairB[1]);
    float $LengthAB;
    float $Sign_F;
    float $TransL[];
    float $DistToPlane[];
    float $EachFloatA;
    float $Subs[];
    float $SCale = $mIB[3][3];
    float $TransLb[];
    float $NewPos[] = AddFloats($TransLb, $NewAXis);
    float $XYZsAxis[];
    float $EachFloat;
    float $SignPN[];
    float $MidPt[];
    float $CamDirVecNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM",  0);
    float $MatrizFloati[] = MatrixToFloat($mI);
    float $Va[] = $FixVeci[0];
    float $Vb[] = $FixVeci[1];
    float $FloatDirMajor[] = $DirLine;
    float $FDirNorAi[] = $LineDirYT;
    float $temp = $a[$j];
    float $tempIndex = $Index[$j];
    float $centerCross[] = lineIntersection( $Vecbv[0], $DirecA, $Vecbv[1], $DirecB);
    float $DPi = (distance2Pts($VecC[0], $VecC[1]))/2.0;
    float $DPiMid = distance2Pts($VecC[0], $MidPoint);
    float $DPa = distance2Pts( $MidPoint, $VecC[2]);
    float $u = $xi - $x;
    float $w = $zi - $z;
    float $e = 1;
    float $Y = ($e*$xi);
    float $U = ($e*$yi);
    float $radiusZ = distance2Pts( $p1, $center );
    float $CenterRadius[];
    float $MultDirP[] = multiplyFloat(2, $FloatDirection);
    float $FloatDirPerpCenter[] = DirectionF($center, $mid3);
    float $FloatDirPerpCenterB[] = DirectionF($center,$mid1);
    float $FloatDirPointAB[] = DirectionF($p1, $p2);
    float $FloatDirPointBC[] = DirectionF($p2, $p3);
    float $center6[] = lineIntersection( $p1, $FloatDirPerpCenter, $p2, $FloatDirPointBC );
    float $center7[] = lineIntersection( $p3,  $FloatDirPerpCenterB, $p1, $FloatDirPointAB );
    float $center9[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPerpCenter );
    float $OrthoCenterCir[] = midPoint2Pts( $center9, $center );
    float $Radius2HalfTimes2 = (distance2Pts( $center9, $center ))*2;
    float $Radius2BHalf = (distance2Pts( $center9, $center ));
    float $Radius3Half = $radiusZ/2;
    float $SnapR = 2.59;
    float $Smooth = 398;
    float $DiffSumTol = 97.95;
    float $CamPlane1[];
    float $EpipolPosCamM[] = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;
    float $MidPosFCam[] = $CamPlane1;
    float $FloatDirEpipol[] = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    float $FloatDirEpipolB[] = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
    float $DistTOEpipol_CurEndA;
    float $DistTOEpipol_CurEndB;
    float $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
    float $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
    float $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;
    float $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    float $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
    float $BCDiff = abs($BCurEndB - $BCurEndBNN);
    float $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd;
    float $BCDiffi = abs($BCurEndB - $BCurEndBNNi);
    float $FloatDirEndPtsA[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
    float $EulerAngle_A = $EulerAngleA[3];
    float $FloatDirEndPtsB[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
    float $EulerAngleB[] = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);
    float $EulerAngle_B = $EulerAngleB[3];
    float $FloatDirEndPtsAi[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
    float $EulerAngleAi[] = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);
    float $EulerAngle_Ai = $EulerAngleAi[3];
    float $FloatDirEndPtsBi[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
    float $EulerAngleBi[] = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);
    float $EulerAngle_Bi = $EulerAngleBi[3];
    float $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
    float $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;
    float $LengCRV_b = `arclen $CurveItemZbi`;
    float $DistEndsii;
    float $DiffMathB = $DistEndsii / ($LengCRV_b/100.0);
    float $PerDiffSum = ($DiffMathA+$DiffMathB)/2.0;
    float $MidCurveB[];
    float $DDirEpipol[] = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
    float $AngleXi;
    float $PointToCamDir[];
    float $PointsClos[];
    float $distToCurveE_A[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[0]);
    float $newOrdersZA[] = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    float $Distance_A = $distToCurveE_A[$Near_index_A];
    float $Found_pt_A[] = $LocCurveEndsVec3D[$Near_index_A];
    float $newOrdersZAM[] = $Found_pt_A;
    float $distToCurveE_B[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[1]);
    float $newOrdersZB[] = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    float $Distance_B = $distToCurveE_B[$Near_index_B];
    float $Found_pt_B[] = $LocCurveEndsVec3D[$Near_index_B];
    float $newOrdersZBM[] = $Found_pt_B;
    float $distToPlaneLoc[];
    float $DistToIntersectTOnear[];
    float $distToPlaneLoc3D[];
    float $DiffMathAm = $DistToIntersectTOnear[2]/ ($distToPlaneLoc3D[2]/100.0);
    float $DiffMathBm = $DistToIntersectTOnear[3] / ($distToPlaneLoc3D[3]/100.0);
    float $relativeDistanceA = ($DiffMathA+$DiffMathAm)/2.0;
    float $relativeDistanceB = ( $DiffMathB+$DiffMathBm)/2.0;
    float $distToCurveE_AB[];
    float $Point3DAM[];
    float $Point3DA[];
    float $lineEPointA[] = MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);
    float $PtsC[];
    string $T[] = `ls -sl`;
    string $sAddUp = 0;
    string $stringFloat[] = $StringArrayPrint;
    string $Syb = " ";
    string $printcommand = "";
    string $AddedSPaces = AddItemString($BytNumDiff[$IndXeF], $Syb);
    string $StartOfEach[];
    string $findEachstart = "";
    string $KnownMatchi[];
    string $listItem;
    string $AddItem = "";
    string $Find = "Vec.xithis+ float Y =  uVeci/(abs(sqrt ((`pow  uVeci 2`) + (`pow  vVeci 2`) + (`pow  wVeci 2`))));
    string $resultVar = "string float vector matrix int proc";
    string $resulti = "sin cos tan tand atan asin acos atand asind acosd";
    string $result = "abs angle bessel ceil clamp constrainValue cos cross crossProduct deg_to_rad delrandstr dot dotProduct equivalent  equivalentTol erf exp floatEq floor fmod gamma gauss getLastError getProcArguments hermite hsv_to_rgb hypot linstep log mag max min noise  normalize pointMatrixMult pow rad_to_deg rand randstate rgb_to_hsv rot seed sign sin smoothstep sphrand sqrt tan trunc unitprint ";
    string $AllMathfunction = "abs ,angle ,bessel ,ceil ,clamp ,constrainValue ,cos ,cross ,crossProduct ,deg_to_rad ,delrandstr ,dot  ,dotProduct ,equivalent ,equivalentTol ,erf ,exp ,floatEq ,floor ,fmod ,gamma ,gauss ,getLastError ,getProcArguments ,hermite ,hsv_to_rgb  ,hypot ,linstep ,log ,mag ,max ,min ,noise ,normalize ,pointMatrixMult ,pow ,rad_to_deg ,rand ,randstate ,rgb_to_hsv ,rot ,seed ,sign ,sin  ,smoothstep ,sphrand ,sqrt ,tan ,trunc ,unit";
    string $MathFuncClassData = $result+" "+ $resulti + " " + $resultVar;
    string $KnownMathTermsMEL[] = stringToStringArray($MathFuncClassData, " ");
    string $KnownMathTermsMELSorted[] = `sort $KnownMathTermsMEL`;
    string $startingChar[] = StringArrayStartOfStringinArray($KnownMathTermsMELSorted);
    string $shorterListstartingChar[] = stringArrayRemoveDuplicates ($startingChar);
    string $KnownMatch[] = $KnownMathTermsMELSorted;
    string $ArrayLetter[] = $shorterListstartingChar;
    string $Arraytemp[] = $KnownMathTermsMELSorted;
    string $StartOfEachS;
    string $gatherItems = "";
    string $eachStringL;
    string $eachString;
    string $all[];
    string $tempFind = $Find;
    string $tempFindwrite = $Find;
    string $StartS;
    string $LetterItem = "";
    string $FoundVariableItems[];
    string $FoundOtherItems[];
    string $StringFromReducedArray = "";
    string $reducedArray[];
    string $allTemp[];
    string $dontUse = "";
    string $matchingDontuse = "";
    string $matching = "";
    string $match;
    string $match0;
    string $matchMiddleDiff;
    string $matchi;
    string $MatchStage2;
    string $MatchStage3;
    string $addBracktoMatch3;
    string $addBracktoMatchD;
    string $matchTemp;
    string $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    string $ArrayFind[];
    string $StartOfEachSi = "";
    string $FOUND = "";
    string $printneat = stringArrayToString($FoundVariableItems, ",");
    string $printneati = stringArrayToString($FoundOtherItems, ",");
    string $FoundTerms[] = stringToStringArray($printneat, ",");
    string $BracketF;
    string $BracketL;
    string $Fb = "{";
    string $Lb = "}";
    string $NewSt = "";
    string $listTemp[];
    string $list[];
    string $FindN = $FindZ;
    string $stringRN;
    string $match0N;
    string $CollectFinds[];
    string $newVec[];
    string $Parts[];
    string $TEMPNAMES[];
    string $FoundP[];
    string $matchString;
    string $MatchPart = "";
    string $stringNX = "";
    string $AllFOUND[];
    string $FirstBracket;
    string $text = $Find;
    string $testM = "$XI[1]= FloatToVec (MidPoint($XI[0],$XI[2]));
    string $BB = "$In3 = FloatToVec (lineIntersection($Po4[$Fi], $Xd, $li,(DirectionFN( $Ca,$li)) ));
    string $testBBracket = `match "[\(][\(]*[^.]*[^\(]*[\)]" $BB`;
    string $testB[] = BracketFind($BB);
    string $B = `match "(float*[a-zA-Z_0-9]).+\=" $testM`;
    string $B2 = `match ".*\\[" $B`;
    string $VartoReplace = "MultLenToDirAddToPoint";
    string $OriginalStart = `match ".*\=" $testM`;
    string $M = `match "($VartoReplace*[a-zA-Z_0-9]).+\;
    string $M2 = `match "[\(][^\(]*[^.]*[^\(]*[\)]" $M`;
    string $M3 = `match "\$*[^,]*" $result`;
    string $PartS[];
    string $resultTemp = $result;
    string $Fix = $OriginalStart+"\("+$PartS[0]+"\*"+$PartS[1]+"\)"+"\+"+$PartS[2]+"\;
    string $SS;
    string $S;
    string $Expr = "\\$";
    string $ExprA = "";
    string $arrayOut[];
    string $CHANGE;
    string $Path = "C:\\Users/johnny/Documents/maya/scripts/StereoCurveZTemp.TXT";
    string $exampleFileName = ( $Path );
    string $CollectAllLines[];
    string $LineN = "";
    string $FindItem = "";
    string $stringN;
    string $MatchPartA;
    string $nextLine = `fgetline $fileId`;
    string $TempAllVarZ[];
    string $AllVarZ[];
    string $shorterListAllVarZ[] = stringArrayRemoveDuplicates ($AllVarZ);
    string $startingCharV[] = RStringArrayStartOfStringinArray($shorterListAllVarZ);
    string $NewNames[] = stringArrayCountDuplicatesAUGMENT($startingCharV,"");
    string $NewLineChange;
    string $NewLineZ[];
    string $AddLineN;
    string $PathW = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
    string $exampleFileNameW = ( $PathW );
    string $nextLineN = "";
    string $MatchPartB = "";
    string $NewLineXA = "";
    string $ScriptNAME = ("proc[^\\n]*");
    string $GlobalSNAME = ("global[^\\n]*");
    string $JustNames[];
    string $TempN[];
    string $tempCollectAllLines[];
    string $CollectAllDuplicates[];
    string $newCollectDupString[];
    string $nextLineR;
    string $InputLine = ("///THIS IS A DUPLICATE ///"+"\r"+"\n");
    string $nextLineRN;
    string $PRINTPRoc_andNumber[];
    string $StringINDEXCN;
    string $SortCountProcUse[];
    string $CurrentProc[];
    string $FoundProc[];
    string $CollectL[];
    string $CAL_temp[];
    string $FoundProcTemp[];
    string $tempCollectProc[];
    string $AllFoundProcs[];
    string $WholeProc[];
    string $DebugS[];
    string $TempStringP = "";
    string $FINDX[];
    string $matchN;
    string $Xall[];
    string $item[] = `ls -sl`;
    string $ThefirstCurve = VecArrayToCurve($Pts_CRV);
    string $attr = $object +".matrix";
    string $CurveBetween;
    string $curveAxisS[];
    string $selItemzCi[] = `ls-sl`;
    string $CurveItemZ[] = `ls -sl`;
    string $LocZ_Pts[] = `ls -sl`;
    string $planeLocs[];
    string $AllCirTemp[];
    string $CirTemp[];
    string $curveAxis = "";
    string $CRV_Item[] = `ls -sl`;
    string $CURVE[];
    string $newPlaneCurve[];
    string $ABCs = "abcdefghijklmnopqrstuvwxyz";
    string $LETTERS[] = ArrayFromAllinString($ABCs);
    string $GENOME_LETTERS = "";
    string $ConnectionSet1 = `sets -name ExistingCurveZSet`;
    string $ConnectionSet2 = `sets -name CurveZSetOne`;
    string $newSet3 = `sets -name TheLastCurvesSet`;
    string $newSet1 = `sets -name ZEdgeCurvesSet`;
    string $newSet2 = `sets -name ZPlaneCurvesSet`;
    string $newCAMSet1;
    string $quickFix[] = `sets -q ExistingCurveZSet`;
    string $GetObjList[];
    string $KnowObjList[] = $GlobalObjListA;
    string $NewObjList[];
    string $diffAZ[] = stringArrayRemoveExact($GetObjList,$KnowObjList);
    string $diffCZ[] = stringArrayRemoveExact($KnowObjList, $GetObjList);
    string $diffBZ[] = stringArrayRemoveExact($diffAZ,$KnowObjList);
    string $listofallcurves[];
    string $ObjectsINcamLightCone[];
    string $OutofRange[];
    string $shortnameL;
    string $CurveItem[] = $listofallcurves;
    string $NurbplaneB = "LiveSurfaceBShape";
    string $ObjectsInFrontZ[];
    string $LocPointinPlane[];
    string $LocCurveEnds[];
    string $AllLocCurveEnds[];
    string $CurveLocPlanePoints[];
    string $shorterList[] = stringArrayRemoveDuplicates ($ObjectsINcamLightCone);
    string $queryLocB[];
    string $queryLocOnLivePlaneB[];
    string $queryLocCurveEnds[];
    string $querylayerMidPoint[];
    string $CurveSelection[];
    string $NameStart = ("LOC"+$CurveItem[0]+"START");
    string $NameEnd = ("LOC"+$CurveItem[0]+"END");
    string $LocSTART[] = `spaceLocator -p 0 0 0 -n $NameStart`;
    string $LocEND[] = `spaceLocator -p 0 0 0 -n $NameEnd`;
    string $STARTENDcurveLocs[] = { $LocSTART[0], $LocEND[0]};
    string $ObjectList[];
    string $ObjectsInFrontOfPlane[];
    string $EdgesSurface[];
    string $allObjectsInPlane[];
    string $stringName = ("Plane"+ $allObjectsInPlane[$inDexName]);
    string $isitYup = `upAxis -q -ax $cameraName`;
    string $selectionList[] = `ls -sl`;
    string $ppm;
    string $LocObjects[] = `spaceLocator -p 0 0 0`;
    string $idnodeType2;
    string $Relativesselection[];
    string $isSelectedZx[];
    string $POSAe = $FloatZ[0];
    string $POSCe = $FloatZ[2];
    string $nameAe;
    string $averaging[];
    string $nametypeZ[] = `ls -showType $C`;
    string $nameA;
    string $OBJall[] = `sets -q CurveZSetOne`;
    string $Intnumbers;
    string $array[];
    string $floatnumbers;
    string $K = "";
    string $curve = "curve -d 1";
    string $Newcurvez = `eval($curve)`;
    string $oneItemz[] = `ls -sl`;
    string $newOrderArray[];
    string $stringIndexTrack[] = IntArrayToStringArray($IndexTrack);
    string $nametypeZi;
    string $nameB;
    string $multNode;
    string $ThreePoints[] = { "0", "1", "2"};
    string $curveA = "curve -d 1";
    string $curveB = "curve -d 1";
    string $NewcurvezA = `eval($curveA)`;
    string $NewcurvezB = `eval($curveB)`;
    string $NewcurvezAB[];
    string $stringF[];
    string $EmptyIndx[];
    string $stringIndTr[] = IntArrayToStringArray($index);
    string $queryLocCurveEndsOLD[] = $queryLocCurveEnds;
    string $newNames;
    string $NearCurvesEnds[];
    string $BothCurves[];
    string $EmptyStringNewOrderA[];
    string $LocA = $queryLocCurveEnds[$NearestInt[0]];
    string $LocB = $queryLocCurveEnds[$NearestIntB[0]];
    string $LocName;
    string $Loc_AorB = "";
    string $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    string $AllarrayCurvesNear[];
    string $NewFoundLocs[];
    string $arrayCurvesNear[];
    string $CurvesV[];
    string $LocsV[];
    string $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    string $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    string $VanishingLOC[];
    string $DirectionsZ[] = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    string $Alll = "";
    string $AllStrings[];
    string $EmptyIndxNewOrder[];
    string $BestThree[];
    string $CirTempi[];
    string $newCurveii;
    string $CurveAv[];
    string $newNamesResultA1;
    string $ThreeDCurvesNear[];
    string $queryLocCurveEnds3D[];
    string $CurveItemAa[];
    string $StringAllNearA[];
    string $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    string $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    string $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    string $arrayCurvesNearA[];
    string $newNamesResultAx = substituteAllString($newNames, "Plane", "");
    string $arrayCurvesNearA1[];
    string $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    string $LocNames[];
    string $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
    string $myCurve = $curvesZ;
    string $CurveEPzCount = size  ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    string $CRVendPts[];
    string $circlesItemA[];
    string $circlesItem[];
    string $CrvNA[];
    string $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    string $LayerCurvesRangeA[];
    string $ThefirstCurvei;
    string $AllLocs_String[] = IntArrayToStringArray($AllLocsi);
    string $EmptyStringNewOrderB[];
    string $XLocsA = $NewFoundLocs[0];
    string $XLocsB = $NewFoundLocs[1];
    string $Na = (match ("[0-9]+", $XLocsA));
    string $Nb = (match ("[0-9]+", $XLocsB));
    string $arrayCurvesNearB[];
    string $itemAll[] = `ls -sl`;
    string $CamConeLocator[];
    string $MakespaceLocator[];
    string $objectZ[];
    vector $CurvEnd[] = PointArrayT($CurveEnds3D);
    vector $CameraN = FloatToVec(nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0));
    vector $CamPosA;
    vector $VecBii[] = ProjectCrv2PlaneNormalP($CurvEnd,$CameraN*-1,$CamPosA);
    vector $ptVecWs = $eachVV;
    vector $ptVecCs = screenSpaceVecMult($ptVecWs,$cam_mat);
    vector $XYv = $ptVecCs;
    vector $Tdd[] = PointArrayT(`ls-sl`);
    vector $Dir = DirectionF($Tdd[0],$Tdd[1]);
    vector $EV = ($Dir*2.5)+$T[0];
    vector $TD[] = PointArrayT(`ls-sl`);
    vector $VecBi[] = ProjectCrv2PlaneNormalP($TD,$Dir,$Tdd[0]);
    vector $CamNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    vector $NewPtsP[];
    vector $PtsVec;
    vector $Tran;
    vector $DirectC = DirectionFN($vecRs[0], $Midp);
    vector $tan = crossProduct($DirectC,$AvN, 0, 0 );
    vector $vecRs[];
    vector $AvN = $CamNormal*-1;
    vector $Midp = $CamPosA[0];
    vector $vecRsA[];
    vector $V[];
    vector $p = `xform -q -ws -t "LiveSurfaceB"`;
    vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
    vector $n1 = $AvN;
    vector $RECORD[];
    vector $vecT[];
    vector $indexStartEnd[];
    vector $Poii[];
    vector $PositionsZ_A[];
    vector $Pts_CRV[];
    vector $PtsVecAi[] = PointArrayT($selItemzCi);
    vector $NewAXis = MultPointMatrixPlusRel( $PtsVecAi[1], $MatrixNewB,$MatrixNewC);
    vector $newVecs[];
    vector $VPos_MC[];
    vector $PlaneLocZ[];
    vector $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM`;
    vector $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM`;
    vector $PtsVecA[] = PointArrayT(`ls -sl`);
    vector $PtsVecAX = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[1], $PtsVecA[2], $PtsVecA[3]));
    vector $PtsVecAY = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[3], $PtsVecA[1], $PtsVecA[2]));
    vector $PtsVecCross = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[2], $PtsVecA[1], $PtsVecA[3]));
    vector $Normal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    vector $DirLineCamXepip = DirectionFN( $PtsVecAX,$Cam_Trans);
    vector $Nvec = ($DirLineCamXepip*2.0)+$PtsVecAX;
    vector $PtsM_A[];
    vector $Line[];
    vector $CamM_B[];
    vector $SQuarePts[];
    vector $pointMakeS[];
    vector $DirNorA = Normal3Points($SQuarePts[0],  $pointMakeS[0], $pointMakeS[1]);
    vector $DirVector[];
    vector $PtsVecTemp[] = PointArrayT(`ls -sl`);
    vector $CrvN[];
    vector $norm = $DirectionVector[0];
    vector $bi = $DirectionVector[1];
    vector $AllLocPositionsZi[];
    vector $AXIS_XZY[];
    vector $MMVEC[] = VecPointsMirrorVecPlaneN($PtsVec,$AXIS_XZY);
    vector $PlaneP = <<$PtZ[0],$PtZ[1],$PtZ[2]>>;
    vector $DirLineN = << 0.0, 0.0 , 1.0 >>;
    vector $DirLineX = << 1.0, 0.0 , 0.0 >>;
    vector $DirLineY = << 0.0, 1.0 , 0.0 >>;
    vector $DirLineCamTOx = DirectionFN($XcrossP,$PtsVecAX);
    vector $DirLineCamTOy = DirectionFN($XcrossP,$PtsVecAY);
    vector $DirLineAX = DirectionFN($PtsVecAX, $PtsVecCross);
    vector $DirLineAY = DirectionFN($PtsVecAY, $PtsVecCross);
    vector $Zero = << 0.0, 0.0 , 0.0 >>;
    vector $DirLineYp = << 0.0, 1.0 , 0.0 >>;
    vector $DirLineYR = DirectionFN($VPos_MC[2], $VPos_MC[3]);
    vector $AllLocPositionsZ[];
    vector $AllPlaneLocPositionZ[] = VecPointsToCameraPlaneB($AllLocPositionsZ);
    vector $FixVec[] = PointArrayT($quickFix);
    vector $objVecMain[];
    vector $firstReduction[];
    vector $newAddedVec[] = PointArrayT($diffCZ);
    vector $VecArrayRemainsZ[];
    vector $AllCurveLocArrayVec[];
    vector $AllCurvePlaneLocZ[];
    vector $CurveLocArrayVec[];
    vector $VecArray[];
    vector $VecArrayRemains[];
    vector $ObjectToCamShiftA;
    vector $SurfEnds[] = PointArray($EdgesSurface);
    vector $MiddlePointA[];
    vector $DirectionsToCent[];
    vector $PointsZ[] = $firstReduction;
    vector $AllPointsInplane[];
    vector $NewVecArray[];
    vector $unitVectormagZYHL[];
    vector $xvex = << $posA[0], $posA[1], $posA[2] >>;
    vector $worldPos = `xform -q -ws -rp  $oneItemz[0]`;
    vector $newOrderVec[];
    vector $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
    vector $VecR[];
    vector $ReturnValVec = FloatToVec($NewPoint);
    vector $planePointN;
    vector $AllPlaneLocs[];
    vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
    vector $Ui = FloatToVec($p1p2);
    vector $Vi = FloatToVec($p1p3);
    vector $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;
    vector $U1 = TwoVecsOrFloats($point2, $point1);
    vector $V1 = TwoVecsOrFloats($point3, $point1);
    vector $U2 = TwoVecsOrFloats($point3, $point1);
    vector $V2 = TwoVecsOrFloats($point2, $point1);
    vector $U3 = TwoVecsOrFloats($point1, $point3);
    vector $V3 = TwoVecsOrFloats($point2, $point3);
    vector $normalV[];
    vector $eachVecLine;
    vector $Xdirect;
    vector $Ydirect;
    vector $Zdirect;
    vector $XYZdirect[];
    vector $NewDirectionZ;
    vector $Positions[];
    vector $VecCurEnds[] = VecCurveEnds({$TempCrv});
    vector $LocCurveEndsVec[] = PointArray($queryLocCurveEnds);
    vector $EndSnapAndEndProject[];
    vector $endNotNearZ[];
    vector $NearEndZ;
    vector $LocOnPlaneVec[] = PointArray($arrayCurvesNear );
    vector $Loc3D_Vec[] = PointArray($NewFoundLocs );
    vector $ALLLoc3D_VecAB[] = PointArray($AllarrayCurvesNear);
    vector $ReducedVecAB[];
    vector $ALLLoc3D_Vec[];
    vector $MovedEndPointPlane[] = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    vector $CRV_ENDSi[];
    vector $DDirEpipolXYZ[];
    vector $EpipolD[];
    vector $AllEpipolXYZ[];
    vector $XYZdirectL[];
    vector $LineMidi;
    vector $NewDirZi;
    vector $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    vector $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    vector $Dir_CamRay;
    vector $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    vector $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);
    vector $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    vector $One;
    vector $each;
    vector $NearPointsXYZ[];
    vector $ReducedVec[];
    vector $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    vector $VecLineDirMi;
    vector $PointN_LineXYZ;
    vector $SnapN;
    vector $SnapPlaceN;
    vector $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);
    vector $VecLineDirM;
    vector $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    vector $Points3DPair_And_2DPair[];
    vector $Crv_Pts[];
    vector $MirrorAcrossPlaneVecs[] = VecMultMatrixMirror($Crv_Pts);
    vector $FLoatPointA[];
    vector $DirLine = DirectionFN( $VecLoc, $Pos_A);
    vector $TranstatedVecs[];
    vector $PositionsZ_Ax[];
    vector $ZYplaneMatrix[];
    vector $VecDirection_A_XYZ[];
    vector $VecDirectionXYZ[];
    vector $VecXYZsOnPlane[] = VecPointsToCameraPlane($VecXYZs);
    vector $VecXYZsOnPlaneiY[];
    vector $VecXYZsOnPlaneiiY[];
    vector $VecXYZsOnPlaneVpoint[];
    vector $EpipLolar[];
    vector $PositionsZ_Aii[];
    vector $HighCurvePoints[];
    vector $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
    vector $Dir_VecA;
    vector $VecPtsMirrorEnds_A[];
    vector $VIntersectEnds_A[];
    vector $ObjLoc3DCurv[];
    vector $LocCurveEndsVec_3D[] = PointArray($arrayCurvesNearA1);
    vector $LoCz_3D[];
    vector $TXI = << -1.0 , 1.0, 1.0>>;
    vector $NearVecPts[];
    vector $PositionsZ_Aiix[];
    vector $VecTest[];
    vector $LocCurveEndsVec3D[] = PointArray($queryLocCurveEnds3D);
    vector $FistAndSecond[];
    vector $VecA = $FistAndSecond[0];
    vector $VecB = $FistAndSecond[1];
    vector $PositionsZ_Ai[];
    vector $ReversePositionsZ_Ai[] = ReverseVectorArray($PositionsZ_Ai);
    vector $PtsMirrorAi[];
    vector $XIntersect_Ax[];
    vector $CurveVectors[];
    vector $ReturnVec[];
    vector $CRV_EndsVec[];
    vector $VlocA;
    vector $VecLineDiri = DirectionFN($PointOnLine, $PointN);
    vector $VecLineDir = $VecLineDiri;
    vector $CRV_PlaneNorm[];
    vector $EmptyVecA[];
    vector $EmptyVecB[];
    vector $NVecPointZ[];
    vector $VecROne[] = GetRotationVectorsMatrix($mIA );
    vector $tranSVec = << $TransL[0], $TransL[1], $TransL[2]>>;
    vector $tranSVecA = $VecROne[0]+$tranSVec;
    vector $tranSVecC = $VecROne[2]+$tranSVec;
    vector $SVecii[];
    vector $SVecPoint = $SVeci;
    vector $YZvec = PointToPlaneN($SVecPoint, $SVecii);
    vector $ZXvec = PointToPlaneN($SVecPoint, $SVecii);
    vector $XYvec = PointToPlaneN($SVecPoint, $SVecii);
    vector $VecPlanes[];
    vector $VecLineDirM_All[];
    vector $SIgnA[] = GetVectorFloatSign( $VecLineDirM_All);
    vector $SIgnB[] = GetVectorFloatSign($VecROne);
    vector $EachVec;
    vector $EachVecT;
    vector $NewPosVec = <<$NewPos[0], $NewPos[1], $NewPos[2]>>;
    vector $VecSIGNDirM[];
    vector $eachPointVd;
    vector $Vperp = crossProduct( $DirLine, $CamDirVecNormal, 0, 0 );
    vector $BInomalV = FloatToVec(MultLenToDirAddToPoint(2, $Vperp, $PtsVec[0]));
    vector $BInomalVDirLine = PositiveDirectionLine($PtsVec[0], $BInomalV);
    vector $TangentV = FloatToVec(MultLenToDirAddToPoint(4,$CamDirVecNormal,  $PtsVec[0]));
    vector $bi_two = `cross $tan $norm`;
    vector $FixVeci[];
    vector $LineAMain;
    vector $DirMTestVec;
    vector $ZeroA = <<0.0, 0.0, 0.0>>;
    vector $LineA = PositiveDirectionLine($FixVecB[0], $FixVecB[1]);
    vector $pointYVec = ClosestPoint2LineVec($LineA, $FixVecB[0], $ZeroA);
    vector $LineDirYT = PositiveDirectionLine($pointYVec, $ZeroA);
    vector $DirNormi = $LineDirYT;
    vector $DirecA = FloatToVec(DirectionFN($Vecbv[0],$Vecbvi[1]));
    vector $DirecB = FloatToVec(DirectionFN($Vecbv[1],$Vecbvi[0]));
    vector $VecC[];
    vector $MidPoint = FloatToVec (MidPoint($VecC[0], $VecC[1]));
    vector $Vai = << $posAZ[0], $posAZ[1], $posAZ[2] >>;
    vector $Vbi = << $posBZ[0],  $posBZ[1], $posBZ[2] >>;
    vector $VbiUnit = << $u, $v, $w >>;
    vector $VbiUnitA = `unit $VbiUnit`;
    vector $YUV = << $Y, $U, $V>>;
    vector $VecS[] = $AllVecsG;
    vector $EndrEndsa[];
    vector $VecCurEndsa[] = VecCurveEnds({$CurveItemZai});
    vector $VecCurEndsb[] = VecCurveEnds({$CurveItemZbi});
    vector $PositionsZ_B[];
    vector $VecPtsMirrorA[];
    vector $VecPtsMirrorB[];
    vector $VecPtsMirrorEnds_B[];
    vector $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
    vector $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);
    vector $Vecbv[];
    vector $Vecbvi[];
    vector $NewVecENDsi[];
    vector $CRV_ENDSii[];
    vector $PointsA[];
    vector $PointsB[];
    vector $VecOnPlaneA[];
    vector $VecOnPlaneB[];
    vector $IntersectEnds_Ax[];
    vector $Intersect_A[];
    vector $PositionsZ_Bi[];
    vector $PositionsZ_Bii[];
    vector $UnconnectedEnds[];
    vector $Intersect_LineB_a;
    vector $Intersect_LineB_b;
    vector $Xdirection = << 1.0,0.0,0.0>>;
    vector $Intersect_BX[];
    vector $PairVectors[];
    vector $EpipolXLine;
    vector $CrvNormalA[] = CRVEndNormals( $CrvNA[0] );
    vector $CrvNormalB[] = CRVEndNormals( $CrvNA[1] );
    vector $aveNorm = unit(($CrvNormalA[$START_END[0]]+$CrvNormalB[$START_END[1]])/2.0);
    vector $MidPointC = ($Intersect_A[0]+$Intersect_A[`size($Intersect_A)`-1])/2.0;
    vector $NormPts = (($aveNorm*2.5)+$MidPointC);
    vector $P1 = ClosestPoint2LineVecX($DirectC, $MidPointC, $NormPts);
    vector $NewNormal = (DirectionFN($NormPts, $P1));
    vector $AB_endPts[];
    vector $NewFvec[];
    vector $Intersect_B[];
    vector $ViNew[];
    vector $VecMult;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $CurvEnd = PointArrayT($CurveEnds3D);



    $CameraN = FloatToVec(nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0));
    $CamPosA = `xform -q -ws -t ZCURVEModelingCAM`;

    $VecBii = ProjectCrv2PlaneNormalP($CurvEnd,$CameraN*-1,$CamPosA);



    for($eachVV in $CurvEnd){

    $ptVecWs = $eachVV;
    // Grab the worldInverseMatrix from cam_main
    matrix $cam_mat[4][4] = screenSpaceGetMatrix("ZCURVEModelingCAM.worldInverseMatrix");
    // Multiply the point by that matrix
    $ptVecCs = screenSpaceVecMult($ptVecWs,$cam_mat);
    // Adjust the point's position for the camera perspective

    $hfv = `camera -q -hfv ZCURVEModelingCAM`;
    $ptx = (($ptVecCs.x/(-$ptVecCs.z))/tand($hfv/2))/2.0;
    $vfv = `camera -q -vfv ZCURVEModelingCAM`;
    $pty = (($ptVecCs.y/(-$ptVecCs.z))/tand($vfv/2))/2.0;
    $ptz = $ptVecCs.z;
    $XYv = $ptVecCs;
    //vector $XYv=<<$ptx,$pty,0.0>>;
    Loc ( $XYv);
    }



    $Tdd = PointArrayT(`ls-sl`);
    $Dir = DirectionF($Tdd[0],$Tdd[1]);
    /////
    $EV = ($Dir*2.5)+$T[0];
    Loc($EV);
    //

    $TD = PointArrayT(`ls-sl`);
    $VecBi = ProjectCrv2PlaneNormalP($TD,$Dir,$Tdd[0]);



    $CamPosA =`xform -q -ws -t "LiveSurfaceB"`;
    $CamNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);

    $VecBi = ProjectCrv2PlaneNormalP($AllKnowVecEnds,$CamNormal*-1,$CamPosA[0]);


    proc vector [] ProjectCrv2PlaneNormalP(vector $vecRs[],vector $AvN,vector $Midp){

    $DirectC = DirectionFN($vecRs[0], $Midp);
    $tan = crossProduct($DirectC,$AvN, 0, 0 );
    $RowA = $tan;
    $RowB = $DirectC;
    $RowC = $AvN;
    // cent of matrix
    $AxisO = $Tran = $Midp;
    $SizeVp = `size($vecRs)`;
    for($Ind=0; $Ind<$SizeVp; $Ind++){
    $PtsVec=$vecRs[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $Xv = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    $Dv=DirectionF($Xv,$PtsVec);
    $ZEROIi = $Dv*$AvN;
    $valN= $ZEROIi.x*$ZEROIi.y*$ZEROIi.z;
    $sign = `sign $valN`;
    $valN = (int) (($valN + $sign*5/(1.0*10)) * 1.0);
    $valN = ($valN/1.0);
    //if above0.5
    if($valN==1){
    $NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    //be careful..
    curve2points($Xv,$PtsVec);
    }
    }
    return $NewPtsP;
    }

    $CamPosA = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPosA =`xform -q -ws -t "LiveSurfaceB"`;
    $CamNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $VecBi = ProjectCrv2PlaneNormalP($AllKnowVecEnds,$CamNormal*-1,$CamPosA[0]);

    $vecRs ={$AllKnowVecEnds[0]};
    Loc  $vecRs[0];

    $AvN = $CamNormal*-1;
    $Midp = $CamPosA[0];



    $vecRs ={$AllKnowVecEnds[0]};
    $AvN = $CamNormal*-1;
    $Midp = $CamPosA[0];




    proc vector [] ProjectCrv2PlaneNormalP(vector $vecRs[],vector $AvN,vector $Midp){


    $DirectC = DirectionFN($vecRs[0], $Midp);
    $tan = crossProduct($DirectC,$AvN, 0, 0 );
    $RowA = $tan;
    $RowB = $DirectC;
    $RowC = $AvN;
    // cent of matrix
    $AxisO = $Tran = $Midp;
    $SizeVp = `size($vecRs)`;
    $CountFN = 0;
    for($Ind=0; $Ind<$SizeVp; $Ind++){
    $PtsVec=$vecRs[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));


    $Xv = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    $Dv=DirectionF($Xv,$PtsVec);
    $ZEROIi = $Dv*$AvN;
    $valN= $ZEROIi.x*$ZEROIi.y*$ZEROIi.z;
    $sign = `sign $valN`;
    $valN = (int) (($valN + $sign*5/(1.0*10)) * 1.0);
    $valN = ($valN/1.0);
    //if above0.5
    if($valN==1){
    PAUSE;
    cycleBackgroundColor;
    $NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    //be careful..
    curve2points($Xv,$PtsVec);
    //Loc $NewPtsP[0];

    $vecRsA[$CountFN]=$PtsVec;
    $CountF[$CountFN]=$Ind;
    $CountFN++;
    }

    }


    $V= $vecRsA;
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = $AvN;
    $C1=0;
    for($e in $V){

    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    ///both maybe redundant
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F4 = $NewPtsP[$C1];
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);

    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    curve2points($e,$O[$C1]);
    $C1++;
    }
    //print  $O;
    //Loc $O[0];

    $MatrixNewB = GetMatrix("ZCURVEModelingCAM");
    $MtxF  = MatrixToFloat($MatrixNewB);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};

    $TF = 0;
    $SizeC = `size($O)`;
    for($Ind=0; $Ind<$SizeC; $Ind++){

    $PtsVec= $O[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    Loc $PtZ;
    print $PtZ[0];
    print $PtZ[2];
    print $PtZ[1];
    //$TF=rectContains(-0.5,-0.5, -1.0, 1.0, $PtZ[0], $PtZ[2]);
    $TF=rectContains(-0.5,-0.5, 1.0, 1.0,$PtZ[0], $PtZ[2]);

    if($TF==1){
    $RECORD[`size($RECORD)`]=$O[$Ind];
    PAUSE;
    Loc $RECORD[`size($RECORD)`-1];
    }
    $TF=0;

    }


    return $RECORD;
    }

    $T = `ls -sl`;
    $vecT = PointArrayT($T);
    $FixVecT = $vecT[0];

    $TF=rectContains(-0.5,-0.5, 1.0, 1.0, $FixVecT[0], $FixVecT[2]);



    proc vector [] VecPointsToCameraPlane(vector $V[]){


    print $PtsVec;
    6.513704 -1.022943 4.744769
    // Result: <<65.077678, 30.853927, 35.481502>>  //
    // Result: <<71.591382, 29.830984, 40.226271>>  //

    $V= $vecRs;

    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $C1=0;
    for($e in $V){

    $e=$V[0];

    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    ///both maybe redundant

    $P1 = ClosestPoint2LineVec($n1, $p, $e);


    $F4 = $e+($D1*$F3);

    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);


    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));

    $C1++;
    }
    return $O;
    }




    proc vector [] VecPointsToCameraPlane(vector $V[]){
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+($D1*$F3);
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    return $O;
    }





    $TempVectorsCrv  = LineIntersectPlaneCam( $PositionsZ_Ax, $CamPos1, $ZYplaneMatrix);

    proc float [] FloatPointsToCamPlane(float $LocPos1[]){
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $C1=0;
    $e=FloatToVec( $LocPos1);
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+($D1*$F3);
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;

    $R = $O;
    return $R;
    }

    proc float [] FloatPointsToCamPlane(float $LocPos1[]){
    $Pi = 3.1415926535;
    $pi = 3.1415926535;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $LivePlanePos = `xform -q -ws -t LiveSurfaceB`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $CamerasDirectionVector = $CamerasDirectionVectorNormal;
    $FloatDirectionA = DirectionFN($CamPos1, $LocPos1);
    $DistanceLoc = distance2Pts( $LocPos1, $CamPos1 );
    $DistanceLocA = $DistanceLoc;
    $DistanceLoc = $DistanceLoc * -1;
    $MultDirPC1 = multiplyFloat($DistanceLoc, $CamerasDirectionVector);
    $FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1);
    $CamerasDirectionVectorA = DirectionFN($FloatDirectionCamNormal, $CamPos1);
    $MultDirPC1A = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
    $FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1A);
    $p1 = $CamPos1;
    $p2 = $LocPos1;
    $p3 = $FloatDirectionCamNormal;
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );
    $FloatPosZero = {0, 0, 0};
    $FloatDirection = DirectionFN($FloatPosZero, $normal);
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $mid3 = midPoint2Pts( $p2, $p3 );
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    $FloatDirPerpCenterC = DirectionFN($center,$mid2);
    $FloatDirPointAC = DirectionFN($p1, $p3);
    $center8 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
    $FloatDirLocToPerpIntersect = DirectionFN($center8,$p2);
    $OnPlane = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );
    return $OnPlane;
    }


    proc matrix screenSpaceGetMatrix(string $attr){
    $v = `getAttr $attr`;
    matrix $mat[4][4]=<<$v[0], $v[1], $v[2], $v[3];
    $v[4], $v[5], $v[6], $v[7];
    $v[8], $v[9], $v[10], $v[11];
    $v[12], $v[13], $v[14], $v[15]>>;
    return $mat;
    }

    // Multiply the vector v by the 4x4 matrix m, this is probably
    // already in mel but I cant find it.
    proc vector screenSpaceVecMult(vector $v, matrix $m){
    matrix $v1[1][4]=<<$v.x, $v.y, $v.z, 1>>;
    matrix $v2[1][4]=$v1*$m;
    return <<$v2[0][0], $v2[0][1],  $v2[0][2]>>;
    }




    $ptVecWs =  ;

    // Grab the worldInverseMatrix from cam_main
    matrix $cam_mat[4][4] = screenSpaceGetMatrix("cam_main.worldInverseMatrix");

    // Multiply the point by that matrix
    $ptVecCs = screenSpaceVecMult($ptVecWs,$cam_mat);

    // Adjust the point's position for the camera perspective
    $hfv = `camera -q -hfv cam_main`;
    $ptx = (($ptVecCs.x/(-$ptVecCs.z))/tand($hfv/2))/2.0+.5;
    $vfv = `camera -q -vfv cam_main`;
    $pty = (($ptVecCs.y/(-$ptVecCs.z))/tand($vfv/2))/2.0+.5;

    $ptz = $ptVecCs.z;

    $line = $ptx + " " + $pty + " " + "\n";





    proc int AddItemsFromIndexAtoB(int $Ai, int $Bi, int $numberArrayi[]){
    // float $numberArrayi[]= {0.2, 1.2, 3.2, 1.2, 6.2, 6.2, 9.3, -1.2};
    //int $Ai = 2;
    //int $Bi = 5;
    $AddUp = 0;
    $NumerinArray = `size($numberArrayi)`-1;
    if($NumerinArray!=-1){
    $Ni = $Ai;
    $Nii = $Bi;
    if($Nii< $Ni){
    $Ai=$Nii; $Bi=$Ni;
    }
    $range = abs ($Ai-$Bi);
    for ($iC=0;$iC<$range+1; $iC++){
    $ixNa = $iC+$Ai;
    $ixNa = `clamp 0 $NumerinArray $ixNa`;
    $AddUp+=$numberArrayi[$ixNa];
    if($ixNa ==$NumerinArray){break;}
    }
    }
    return $AddUp;
    }


    proc int[] AddItemsFromIndexAtoBFindZero(int $Ai, int $Bi, int $numberArrayi[]){
    // float $numberArrayi[]= {0.2, 1.2, 3.2, 1.2, 6.2, 6.2, 9.3, -1.2};
    //int $Ai = 2;
    //int $Bi = 5;
    $AddUp = 0;
    $NumerinArray = `size($numberArrayi)`-1;
    $catchIndex[0]= 1;
    if($NumerinArray!=-1){
    $Ni = $Ai;
    $Nii = $Bi;
    if($Nii< $Ni){
    $Ai=$Nii; $Bi=$Ni;
    }
    $range = abs ($Ai-$Bi);
    for ($iC=0;$iC<$range+1; $iC++){
    $ixNa = $iC+$Ai;
    $ixNa = `clamp 0 $NumerinArray $ixNa`;
    $AddUp+=$numberArrayi[$ixNa];
    if($AddUp ==0){$catchIndex[1] = $ixNa; $catchIndex[0]=0;break;}
    }
    }
    return $catchIndex;
    }

    proc string StringArrayItemsFromIndexAtoB(int $Ai, int $Bi, string $StringArrayi[]){
    $sAddUp = 0;
    $NumerinArray = `size($StringArrayi)`;
    if($NumerinArray!=0){
    $Ni = $Ai;
    $Nii = $Bi;
    if($Nii< $Ni){
    $Ai=$Nii; $Bi=$Ni;
    }
    $range = abs ($Ai-$Bi);
    for ($iC=0;$iC<$range+1; $iC++){
    $ixNa = $iC+$Ai;
    $sAddUp+=$StringArrayi[$ixNa];
    if($ixNa ==$NumerinArray){break;}
    }
    }
    return $sAddUp;
    }

    proc  PrintLongArrayNice(string $StringArrayPrint[] , int $MatrixN){
    $MatrixNi = $MatrixN-1;
    $stringFloat = $StringArrayPrint;
    clear $BytNum;
    for ($eachFloatz in $stringFloat){
    $BytNum[`size($BytNum)`] = (`sizeBytes $eachFloatz`)+2;
    }
    $BytNumSort = $BytNum;
    $BytNumSort = `sort $BytNumSort`;
    $BytNumLarg = $BytNumSort[`size($BytNumSort)`-1];
    $BytNumSmall = $BytNumSort[0];
    clear $BytNumDiff;
    for ($eachBytNum in $BytNum){
    $BytNumDiff[`size($BytNumDiff)`] = (`abs ($eachBytNum - $BytNumLarg)`)+2;
    }
    $IndXeF = 0;
    $IndXeFi = 0;
    $Syb = " ";
    $printcommand = "";
    for ($eachItemF in $stringFloat){
    $AddedSPaces = AddItemString($BytNumDiff[$IndXeF], $Syb);
    if($IndXeFi==$MatrixNi){ $printcommand += $AddedSPaces + $eachItemF + "|"+ "\n" ;
    $IndXeFi= -1; }else{ if($IndXeFi==0){$printcommand += "|"+$AddedSPaces + $eachItemF;}else{ $printcommand +=  $AddedSPaces + $eachItemF;}}
    $IndXeFi++;
    $IndXeF++;
    }


    }

    proc string[] StringArrayStartOfStringinArray(string $Array[]){
    $findEachstart = "";
    for ($eachString in $Array){
    $StartOfEach[`size($StartOfEach)`]= startString($eachString, 1);
    $findEachstart+= startString($eachString, 1);
    $findEachstart+= " ";
    }

    return $StartOfEach;
    }

    ///////////////////////
    proc string[] ReturnArrayFromNestedStringAtIndex(string $StringData[], int $ind){
    $KnownMatchi = stringToStringArray($StringData[$ind], ",");
    return $KnownMatchi;
    }

    proc int[] TFArrayContains(string $item, string $list[])
    {	int $TF[1];
    $TF[0] = false;
    $Count = 0;
    for ($listItem in $list) {
    if ($item == $listItem) {
    $TF[0] = true;
    $TF[1] = $Count;
    break;
    } $Count++;
    }
    return $TF;
    }

    proc string AddItemString(int $iN, string $NumLetorSy){
    $Xz = 0;
    $AddItem = "";
    while($iN > $Xz){
    $AddItem+= $NumLetorSy;
    $Xz++;
    }
    return $AddItem;
    }

    ////////////////////////

    //Test pick one

    /*
    $Find = "Vec.xithis+ float Y =  uVeci/(abs(sqrt ((`pow  uVeci 2`) + (`pow  vVeci 2`) + (`pow  wVeci 2`)))); Vec.vecthisH , float i =  Vec.x - Vec.y; float ii = Vec.vecthisH - Vec.z + Vec.thisy / Vec.Tthis - Vec.this;";

    $Find = "r = a*exp(radians(Delta_angle*n)*cot(b))x = r*cos(radians(Delta_angle*n))if(n ==0):y = 0else:y = 10*(rBefore -r) z = sin (radians(Delta_angle*n))  SomeNumber::FuctionWeird please work II + math = joy;" ;
    */
    ////////////////////////


    proc string [] FindNameOfVariables(string $Find, int $sortN){

    $resultVar = "string float vector matrix int proc";
    $resulti = "sin cos tan tand atan asin acos atand asind acosd";
    $result = "abs angle bessel ceil clamp constrainValue cos cross crossProduct deg_to_rad delrandstr dot dotProduct equivalent  equivalentTol erf exp floatEq floor fmod gamma gauss getLastError getProcArguments hermite hsv_to_rgb hypot linstep log mag max min noise  normalize pointMatrixMult pow rad_to_deg rand randstate rgb_to_hsv rot seed sign sin smoothstep sphrand sqrt tan trunc unitprint ";
    $AllMathfunction = "abs ,angle ,bessel ,ceil ,clamp ,constrainValue ,cos ,cross ,crossProduct ,deg_to_rad ,delrandstr ,dot  ,dotProduct ,equivalent ,equivalentTol ,erf ,exp ,floatEq ,floor ,fmod ,gamma ,gauss ,getLastError ,getProcArguments ,hermite ,hsv_to_rgb  ,hypot ,linstep ,log ,mag ,max ,min ,noise ,normalize ,pointMatrixMult ,pow ,rad_to_deg ,rand ,randstate ,rgb_to_hsv ,rot ,seed ,sign ,sin  ,smoothstep ,sphrand ,sqrt ,tan ,trunc ,unit";
    $MathFuncClassData = $result+" "+ $resulti + " " + $resultVar ;
    //string  $KnownMathTermsMELAtomizes[] = ArrayFromAllinString($MathFuncClassData);
    $KnownMathTermsMEL = stringToStringArray($MathFuncClassData, " ");
    $KnownMathTermsMELSorted = `sort $KnownMathTermsMEL`;



    $startingChar = StringArrayStartOfStringinArray($KnownMathTermsMELSorted);
    $shorterListstartingChar = stringArrayRemoveDuplicates ($startingChar);
    $KnownMatch = $KnownMathTermsMELSorted;
    $ArrayLetter = $shorterListstartingChar;
    $Arraytemp = $KnownMathTermsMELSorted;
    $findEachstart = "";
    clear $StartOfEachSTable $itemBackUp;
    $itemBackUp = $ArrayLetter;
    $gatherItems = "";

    for ($eachStringL in $ArrayLetter){
    for ($eachString in $KnownMathTermsMELSorted){
    $StartOfEachS = startString($Arraytemp[0], 1);
    if ($StartOfEachS==$eachStringL){
    $gatherItems += ($Arraytemp[0]+",");
    $Arraytemp = stringArrayRemoveExact({$Arraytemp[0]}, $Arraytemp);
    }
    //else{	$gatherItems="";}	//
    }
    if(`size($gatherItems)`>0){
    $StartOfEachSTable[`size($StartOfEachSTable)`]= $gatherItems;
    }
    $gatherItems="";
    }

    //////////////////////////////////////////////////////////////


    $IndexLetters = CreateIntIndex(`size($ArrayLetter)`);
    $BytNumi = `sizeBytes $Find`;
    clear $all;
    clear $StringIndex;
    $all = ArrayFromAllinString($Find);
    $StringIndex = CreateIntIndex( `size($all)` );
    //map string

    $tempFind = $Find;
    $tempFindwrite = $Find;
    $countIndex = 0;
    clear $indexStart;
    $LetterItem = "";
    clear $FoundVariableItems $FoundOtherItems;
    clear $indexFirstCharItems;
    $BytNx = 0;
    $StringFromReducedArray = "";
    clear $reducedArray;
    clear $allTemp;
    $allTemp = $all;
    $dontUse = "";
    $matchingDontuse = "";
    $freezeTrigger = 0;
    $matching = "";
    $eachInt = 0;
    $iixI = 0;


    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $Find`;
    $match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $Find`;
    $matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $Find`;
    $matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $Find`;
    $MatchStage2 = endString($match, 3);

    $MatchStage3 = startString($match, `sizeBytes $match`-2);
    $MatchStage3i = startString($match, `sizeBytes $matchii`-2);
    $addBracktoMatch3 = ("\["+$MatchStage3+"\]");

    $matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;
    if($matchMiddleDiff=="\."){

    $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    if($matchMaybeVec2!=""){
    $MatchStage4 = startString($match, `sizeBytes $match`-1);
    $match = $MatchStage4;
    }else{ $dontUse = $matchi; $match=$matchi; }
    }else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//
    }

    $matchTemp = $match;
    $BytNx =`sizeBytes $match`;

    $IndexLetters = CreateIntIndex(`size($ArrayLetter)`);
    $StartOfEachSi = "";
    $FOUND = "";
    clear $ArrayFind $TFandIndex $TFandIndexii;
    $Tri = 0;
    $Trii = 2;
    $CountFoundletters = 0;
    clear $indexStartEnd;


    for ($eachItemArray in $StringIndex){
    $eachInt = $StringIndex[$iixI];

    if( `gmatch $allTemp[$eachInt] "[a-zA-Z0-9_\.]*"` == 1){
    if($Trii==2){$Trii=1; $Tri=2;}
    if(!($CountFoundletters>=1)){
    $FirstLFindIndex=$iixI+1;

    }
    $CountFoundletters++;
    if($Tri==2){

    $Tri=0;
    }
    $LetterItem+= $allTemp[$eachInt];
    $BytNx = `sizeBytes $LetterItem`;
    if(`gmatch $matchTemp $LetterItem`==1){
    $BytNx = `sizeBytes $LetterItem`;

    //$LetterItem ="pow";
    $StartOfEachSi = startString($LetterItem, 1);
    $TFandIndex = TFArrayContains($StartOfEachSi, $ArrayLetter);
    if($TFandIndex[0]==1){
    $ArrayFind = ReturnArrayFromNestedStringAtIndex($StartOfEachSTable, $TFandIndex[1]);
    $TFandIndexii = TFArrayContains($LetterItem, $ArrayFind);

    if($TFandIndexii[0]==1){
    $FOUND = $ArrayFind[$TFandIndexii[1]];
    if(`gmatch $FOUND $LetterItem`==1){

    $FoundOtherItems[`size($FoundOtherItems)`]= $FOUND;
    }
    }
    }
    if(`gmatch $FOUND $LetterItem`!=1){
    if($matchTemp!=$dontUse){
    $FoundVariableItems[`size($FoundVariableItems)`]= $LetterItem;
    $SizeItem = `size $matchTemp`;
    $indexStartEnd[`size($indexStartEnd)`] = <<$FirstLFindIndex, $iixI, ($iixI-$SizeItem+3)>> ;
    $indexStart[`size($indexStart)`]= $FirstLFindIndex;
    }
    } else{$CountFoundletters=0;          }
    clear $TFandIndex $ArrayFind $TFandIndexii;
    $FOUND="";
    $reducedArray = $allTemp;
    stringArrayRemoveToIndex($eachInt+1, $reducedArray);
    $StringFromReducedArray = stringArrayToString($reducedArray, "");

    /////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////
    $LetterItem ="";
    if($matchTemp==$dontUse){ $freezeTrigger = 1; }
    if( `gmatch $allTemp[$eachInt] $match` != 1){$Trii=2; $CountFoundletters=0;}

    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;

    //if(`size($StringFromReducedArray)`>4){
    $match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $StringFromReducedArray`;
    $matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $StringFromReducedArray`;
    $matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $StringFromReducedArray`;
    $MatchStage2 = endString($match, 3);
    $MatchStage3 = startString($match, `sizeBytes $match`-2);
    $MatchStage3i = startString($match, `sizeBytes $matchii`-2);
    $addBracktoMatch3 = ("\["+$MatchStage3+"\]");
    //$addBracktoMatchD = ("\(["+"\"+$matchi+"\])+([a-zA-Z]+)([a-zA-Z0-9_])");
    $matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;

    if($matchMiddleDiff=="\."){

    $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    if($matchMaybeVec2!=""){
    $MatchStage4 = startString($match, `sizeBytes $match`-1);
    $match = $MatchStage4;
    }else{ $dontUse = $matchi; $match=$matchi; }
    }else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//
    }
    }
    }else{$LetterItem ="";  }
    ///}else{$match = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;}
    $matchTemp = $match;

    $iixI++;
    }

    ///////////////

    $printneat = stringArrayToString($FoundVariableItems, ",");
    $printneati = stringArrayToString($FoundOtherItems, ",");
    $FoundTerms = stringToStringArray($printneat, ",");

    if($sortN== 1){$FoundTerms = `sort $FoundTerms`;}

    return $FoundTerms;

    }
    //////////////////////////////


    proc string [] FindNameOfVariables(string $Find, int $sortN, int $EmptyIntArray[] ){

    $resultVar = "string float vector matrix int proc";
    $resulti = "sin cos tan tand atan asin acos atand asind acosd";
    $result = "abs angle bessel ceil clamp constrainValue cos cross crossProduct deg_to_rad delrandstr dot dotProduct equivalent  equivalentTol erf exp floatEq floor fmod gamma gauss getLastError getProcArguments hermite hsv_to_rgb hypot linstep log mag max min noise  normalize pointMatrixMult pow rad_to_deg rand randstate rgb_to_hsv rot seed sign sin smoothstep sphrand sqrt tan trunc unitprint ";
    $AllMathfunction = "abs ,angle ,bessel ,ceil ,clamp ,constrainValue ,cos ,cross ,crossProduct ,deg_to_rad ,delrandstr ,dot  ,dotProduct ,equivalent ,equivalentTol ,erf ,exp ,floatEq ,floor ,fmod ,gamma ,gauss ,getLastError ,getProcArguments ,hermite ,hsv_to_rgb  ,hypot ,linstep ,log ,mag ,max ,min ,noise ,normalize ,pointMatrixMult ,pow ,rad_to_deg ,rand ,randstate ,rgb_to_hsv ,rot ,seed ,sign ,sin  ,smoothstep ,sphrand ,sqrt ,tan ,trunc ,unit";
    $MathFuncClassData = $result+" "+ $resulti + " " + $resultVar ;
    //string  $KnownMathTermsMELAtomizes[] = ArrayFromAllinString($MathFuncClassData);
    $KnownMathTermsMEL = stringToStringArray($MathFuncClassData, " ");
    $KnownMathTermsMELSorted = `sort $KnownMathTermsMEL`;



    $startingChar = StringArrayStartOfStringinArray($KnownMathTermsMELSorted);
    $shorterListstartingChar = stringArrayRemoveDuplicates ($startingChar);
    $KnownMatch = $KnownMathTermsMELSorted;
    $ArrayLetter = $shorterListstartingChar;
    $Arraytemp = $KnownMathTermsMELSorted;
    $findEachstart = "";
    clear $StartOfEachSTable $itemBackUp;
    $itemBackUp = $ArrayLetter;
    $gatherItems = "";

    for ($eachStringL in $ArrayLetter){
    for ($eachString in $KnownMathTermsMELSorted){
    $StartOfEachS = startString($Arraytemp[0], 1);
    if ($StartOfEachS==$eachStringL){
    $gatherItems += ($Arraytemp[0]+",");
    $Arraytemp = stringArrayRemoveExact({$Arraytemp[0]}, $Arraytemp);
    }
    //else{	$gatherItems="";}	//
    }
    if(`size($gatherItems)`>0){
    $StartOfEachSTable[`size($StartOfEachSTable)`]= $gatherItems;
    }
    $gatherItems="";
    }

    //////////////////////////////////////////////////////////////


    $IndexLetters = CreateIntIndex(`size($ArrayLetter)`);
    $BytNumi = `sizeBytes $Find`;
    clear $all;
    clear $StringIndex;
    $all = ArrayFromAllinString($Find);
    $StringIndex = CreateIntIndex( `size($all)` );
    //map string

    $tempFind = $Find;
    $tempFindwrite = $Find;
    $countIndex = 0;
    clear $indexStart;
    $LetterItem = "";
    clear $FoundVariableItems $FoundOtherItems;
    clear $indexFirstCharItems;
    $BytNx = 0;
    $StringFromReducedArray = "";
    clear $reducedArray;
    clear $allTemp;
    $allTemp = $all;
    $dontUse = "";
    $matchingDontuse = "";
    $freezeTrigger = 0;
    $matching = "";
    $eachInt = 0;
    $iixI = 0;


    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $Find`;
    $match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $Find`;
    $matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $Find`;
    $matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $Find`;
    $MatchStage2 = endString($match, 3);

    $MatchStage3 = startString($match, `sizeBytes $match`-2);
    $MatchStage3i = startString($match, `sizeBytes $matchii`-2);
    $addBracktoMatch3 = ("\["+$MatchStage3+"\]");

    $matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;
    if($matchMiddleDiff=="\."){

    $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    if($matchMaybeVec2!=""){
    $MatchStage4 = startString($match, `sizeBytes $match`-1);
    $match = $MatchStage4;
    }else{ $dontUse = $matchi; $match=$matchi; }
    }else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//
    }

    $matchTemp = $match;
    $BytNx =`sizeBytes $match`;

    $IndexLetters = CreateIntIndex(`size($ArrayLetter)`);
    $StartOfEachSi = "";
    $FOUND = "";
    clear $ArrayFind $TFandIndex $TFandIndexii;
    $Tri = 0;
    $Trii = 2;
    $CountFoundletters = 0;
    $CountTotalFindIndex = 0;
    clear $indexStartEnd;


    for ($eachItemArray in $StringIndex){
    $eachInt = $StringIndex[$iixI];
    $CountTotalFindIndex++;
    if( `gmatch $allTemp[$eachInt] "[a-zA-Z0-9_\.]*"` == 1){
    if($Trii==2){$Trii=1; $Tri=2;}
    if(!($CountFoundletters>=1)){
    $FirstLFindIndex=$iixI+1;

    }
    $CountFoundletters++;
    if($Tri==2){

    $Tri=0;
    }
    $LetterItem+= $allTemp[$eachInt];
    $BytNx = `sizeBytes $LetterItem`;
    if(`gmatch $matchTemp $LetterItem`==1){
    $BytNx = `sizeBytes $LetterItem`;

    //$LetterItem ="pow";
    $StartOfEachSi = startString($LetterItem, 1);
    $TFandIndex = TFArrayContains($StartOfEachSi, $ArrayLetter);
    if($TFandIndex[0]==1){
    $ArrayFind = ReturnArrayFromNestedStringAtIndex($StartOfEachSTable, $TFandIndex[1]);
    $TFandIndexii = TFArrayContains($LetterItem, $ArrayFind);

    if($TFandIndexii[0]==1){
    $FOUND = $ArrayFind[$TFandIndexii[1]];
    if(`gmatch $FOUND $LetterItem`==1){

    $FoundOtherItems[`size($FoundOtherItems)`]= $FOUND;
    }
    }
    }
    if(`gmatch $FOUND $LetterItem`!=1){
    if($matchTemp!=$dontUse){
    $FoundVariableItems[`size($FoundVariableItems)`]= $LetterItem;
    $SizeItem = `size $matchTemp`;
    $indexStartEnd[`size($indexStartEnd)`] = <<$FirstLFindIndex, $iixI, ($iixI-$SizeItem+3)>> ;
    $indexStart[`size($indexStart)`]= $FirstLFindIndex;
    $findByt = `sizeBytes $LetterItem`;
    $CountIndex[`size($CountIndex)`] =  ($CountTotalFindIndex -$findByt)-1;
    }
    } else{$CountFoundletters=0;          }
    clear $TFandIndex $ArrayFind $TFandIndexii;
    $FOUND="";
    $reducedArray = $allTemp;
    stringArrayRemoveToIndex($eachInt+1, $reducedArray);
    $StringFromReducedArray = stringArrayToString($reducedArray, "");

    /////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////
    $LetterItem ="";
    if($matchTemp==$dontUse){ $freezeTrigger = 1; }
    if( `gmatch $allTemp[$eachInt] $match` != 1){$Trii=2; $CountFoundletters=0;}

    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;

    //if(`size($StringFromReducedArray)`>4){
    $match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $StringFromReducedArray`;
    $matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $StringFromReducedArray`;
    $matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $StringFromReducedArray`;
    $MatchStage2 = endString($match, 3);
    $MatchStage3 = startString($match, `sizeBytes $match`-2);
    $MatchStage3i = startString($match, `sizeBytes $matchii`-2);
    $addBracktoMatch3 = ("\["+$MatchStage3+"\]");
    //$addBracktoMatchD = ("\(["+"\"+$matchi+"\])+([a-zA-Z]+)([a-zA-Z0-9_])");
    $matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;

    if($matchMiddleDiff=="\."){

    $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    if($matchMaybeVec2!=""){
    $MatchStage4 = startString($match, `sizeBytes $match`-1);
    $match = $MatchStage4;
    }else{ $dontUse = $matchi; $match=$matchi; }
    }else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//
    }
    }
    }else{$LetterItem ="";  }
    ///}else{$match = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;}
    $matchTemp = $match;

    $iixI++;
    }

    ///////////////

    $printneat = stringArrayToString($FoundVariableItems, ",");
    $printneati = stringArrayToString($FoundOtherItems, ",");
    $FoundTerms = stringToStringArray($printneat, ",");

    if($sortN== 1){$FoundTerms = `sort $FoundTerms`;}
    $EmptyIntArray = $CountIndex;
    return $FoundTerms;

    }



    proc int BracketFindPosNeg(string $Find, int $NegPosZ[]){

    $Fb = "{";
    $Lb = "}";
    $BracketF = `match "[\{]" $Find`;
    $BracketL = `match "[\}]" $Find`;
    $NewSt = "";
    if(($BracketF != "")||($BracketL != "")){
    $BytNumi = `sizeBytes $Find`;
    $all = ArrayFromAllinString($Find);
    $iX = 0;
    for($i=0;$i<$BytNumi;$i++){
    if(( $all[$i] == $Fb ) || ( $all[$i] == $Lb )){
    $NewSt = $all[$i];
    if($NewSt == $Fb){
    $NegPosZ[`size($NegPosZ)`] = 1;
    }else if($NewSt == $Lb){
    $NegPosZ[`size($NegPosZ)`] = -1;
    }
    $iX++;
    }
    }
    }
    for($eachInt in $NegPosZ){
    $AddAll+= $eachInt;
    }
    return $AddAll;
    }


    proc string [] stringArrayFindDupIndexSPair(string $listA[], int $foundN[], int $LineNumberB[])
    {
    $FindNum = 0;
    clear $foundN;
    $LineNumberA = $LineNumberB;
    $list = $listA;
    $listTemp  = $list;
    for ($item in $list) {
    clear $FindIndexN;
    $FindNum = stringArrayCountIndex($item,  $listTemp, $FindIndexN);
    if ($FindNum>1){
    $foundN[`size($foundN)`] = $LineNumberA[$FindIndexN[`size($FindIndexN)`-1]];
    $result[`size($result)`] =  $listTemp[$FindIndexN[`size($FindIndexN)`-1]];
    $LineNumberA = IntRemoveIndexN( $LineNumberA, $FindIndexN);
    $listTemp = RemoveStringAtIndex( $listTemp, $FindIndexN);
    }else{
    if ($FindNum==1){
    $foundN[`size($foundN)`] = $LineNumberA[$FindIndexN[0]];
    $result[`size($result)`] =  $listTemp[$FindIndexN[0]];
    }
    }
    }
    return $result;
    }


    proc int stringArrayCountIndexOne(string $item, string $list[], int $FindIndexN[])
    {
    $result = 0;
    $CountN = 0;
    clear $FindIndexN;

    for ($listItem in $list) {
    if ($item == $listItem){
    $FindIndexN[$result]=$CountN;
    $result++;
    }
    $CountN++;
    }
    return $result;
    }

    proc int [] stringArrayRemoveAtIndexZ( int $indexA, int $list[] )
    {
    $indexS = `size($indexA)`;
    $len = size( $list );
    $Xi = 0;
    while($Xi< $indexS){
    for ( $i = 0; $i < $Xi; $i++ ) {
    $result[$i] = $list[$i];
    }
    $Xi++;
    }
    //$list = $result;
    return $result;
    }

    proc int [] RemoveINTAtIndex(int $VecS[],int $IndeXxI[]){
    $Ix = 0;
    $ii = 0;
    $Ixi = 0;
    $IndeXxz = `sort $IndeXxI`;
    $size = `size($IndeXxI)`-1;
    for ($eachVc in $VecS){
    if($VecS[$ii]>$IndeXxz[$Ixi]){
    if($size==$Ixi){$Ixi=0;}
    $Ixi++;
    }
    if(!($eachVc== $IndeXxz[$Ixi])){
    $newInt[`size($newInt)`] = $eachVc;
    $ii=$Ix;
    }else{$Ixi++;
    if( $Ixi> `size($IndeXxI)`){break;}
    }
    $Ix++;
    }
    return $newInt;
    }


    proc int [] IntArrayRemoveAtIndex( int $index, int $IntArray[] )
    {

    $list = IntArrayToStringArray( $IntArray );
    $len = `size( $list )`;
    for ( $i = 0; $i < $index; $i++ ) {
    $result[$i] = $list[$i];
    }
    for ( ; $i < $len - 1; $i++ ) {
    $result[$i] = $list[$i + 1];
    }
    $list = $result;
    $IntArray = StringArrayToIntArray($list);
    //string [] IntArrayToStringArray(int $IntArray[])
    return $IntArray;
    }

    proc int stringArrayCountIndex(string $item, string $list[], int $FindIndexN[])
    {
    $result = 0;
    $CountN = 0;
    clear $FindIndexN;
    for ($listItem in $list) {
    if ($item == $listItem){
    $FindIndexN[$result]=$CountN;
    $result++;
    }
    $CountN++;
    }
    return $result;
    }

    proc string [] stringArrayStrip(string $list[])
    {
    $index = 0;
    for ($item in $list) {
    $result[$index++] = substituteAllString($item, " ", "");
    }
    return $result;
    }


    proc string [] stringArrayFindDuplicates(string $list[])
    {
    $index = 0;
    for ($item in $list) {
    if (1 < stringArrayCount($item, $list)) {
    $result[$index++] = $item;
    }
    }
    return $result;
    }


    proc int [] stringArrayRemoveAtIndexZ( int $indexA, int $list[] )
    {
    $indexS = `size($indexA)`;
    $len = size( $list );
    $Xi = 0;
    while($Xi< $indexS){
    for ( $i = 0; $i < $Xi; $i++ ) {
    $result[$i] = $list[$i];
    }
    $Xi++;
    }
    //$list = $result;
    return $result;
    }


    proc int [] RemoveINTAtIndex(int $VecS[],int $IndeXxI[]){
    $Ix = 0;
    $ii = 0;
    $Ixi = 0;
    $IndeXxz = `sort $IndeXxI`;
    $size = `size($IndeXxI)`-1;
    for ($eachVc in $VecS){
    if($VecS[$ii]>$IndeXxz[$Ixi]){
    if($size==$Ixi){$Ixi=0;}
    $Ixi++;
    }
    if(!($eachVc== $IndeXxz[$Ixi])){
    $newInt[`size($newInt)`] = $eachVc;
    $ii=$Ix;
    }else{$Ixi++;
    if( $Ixi> `size($IndeXxI)`){break;}
    }
    $Ix++;
    }
    return $newInt;
    }


    proc string [] stringArrayStrip(string $list[])
    {
    $index = 0;
    for ($item in $list) {
    $result[$index++] = substituteAllString($item, " ", "");
    }
    return $result;
    }


    proc string [] stringArrayFindDuplicates(string $list[])
    {
    $index = 0;
    for ($item in $list) {
    if (1 < stringArrayCount($item, $list)) {
    $result[$index++] = $item;
    }
    }
    return $result;
    }

    ////////////////


    proc string[] FindStringVarZ(string $FindZ){
    $FindN = $FindZ;
    $Size =  `sizeBytes  $FindN`;
    while($Size>0){

    $match0N = `match "([\$]+)([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
    if(`sizeBytes $match0N`>0){
    $stringRN = `substitute $match0N $FindN ""`;
    $FindN = $stringRN;
    }

    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
    $Size =  `sizeBytes  $match0`;
    if($Size>0){
    $CollectFinds[`size($CollectFinds)`]= $match0;
    $stringRN = `substitute $match0 $FindN""`;
    $FindN = $stringRN;
    }
    }
    return $CollectFinds;
    }

    proc string[] FindTrueStringVarZ(string $FindZ){
    $FindN = $FindZ;
    $Size =  `sizeBytes  $FindN`;
    while($Size>0){
    $match0 = `match "([\$]+)([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
    // $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;

    $Size =  `sizeBytes  $match0`;
    if($Size>0){
    $CollectFinds[`size($CollectFinds)`]= $match0;
    $stringRN = `substitute $match0 $FindN""`;
    $FindN = $stringRN;
    }
    }
    return $CollectFinds;
    }



    proc string [] RemoveStringAtIndex(string $VecS[],int $IndeXz[]){
    $IndeXxiz = sort($IndeXz);
    $SizA = `size($IndeXz)`;
    $Ixx = 0;
    $Ixi = 0;
    for ($eachVc in $VecS){
    if(!($Ixx== $IndeXxiz[$Ixi])){
    $newVec[`size($newVec)`] = $eachVc;
    }else{$Ixi++;}
    $Ixx++;
    }
    return $newVec;
    }

    proc int [] RemoveIntAtIndex(int $VecS[],int $IndeXz[]){
    $IndeXxiz = sort($IndeXz);
    $SizA = `size($IndeXz)`;
    $Ixx = 0;
    $Ixi = 0;
    for ($eachVc in $VecS){
    if(!($Ixx== $IndeXxiz[$Ixi])){
    $newVec[`size($newVec)`] = $eachVc;
    }else{$Ixi++;}
    $Ixx++;
    }
    return $newVec;
    }



    proc int [] StringArrayToIntArray(string $listA[]){
    for($eachString in $listA){
    $IntA[`size($IntA)`]=$eachString;
    }
    return $IntA;
    }




    proc int FindSCRIPTNAME(string $LineNA){
    $Trigger = 0;
    $Parts =FindStringVarZ($LineNA);
    if(`size($Parts)`>0){
    for($eachP in $Parts){
    if(`gmatch "proc" $eachP` == 1){$Trigger=1;}
    }
    }
    return $Trigger;
    }

    /*
    $TEMPNAMES =RuleBasedMatchM($IndexX,$CAL_temp, $DebugS);
    print $TEMPNAMES
    print $IndexX;
    clear$IndexX;
    clear$TEMPNAMES;

    print $DebugS[22];


    $Parts =FindStringVarZ($DebugS[22]);
    */


    proc string [] RuleBasedMatchM(int $IndexN[],string $FindItemAllCase[], string $LineNA[]){

    $CountCase = 0;
    $Trigger = 0;

    if(`size($IndexN)`>0){
    clear $IndexN;
    }

    for($LineN in $LineNA){
    $CountCase =0;
    for($eachFindItem in $FindItemAllCase){

    //$matchString = `match $eachFindItem $LineN`;
    $Parts =FindStringVarZ($LineN);

    if(`size($Parts)`>0){
    for($eachP in $Parts){
    if(`gmatch $eachFindItem $eachP` == 1){
    $FoundP[`size($FoundP)`]= $eachFindItem;
    $Trigger=1;
    clear $Parts;
    break;
    }
    }
    }

    $matchString="";
    if($Trigger==1){break;}
    $CountCase++;
    }

    if(($CountCase>0)||($Trigger==1)){
    $returnCaseN[`size($returnCaseN)`] = $CountCase;
    $IndexN =$returnCaseN;
    }
    $Trigger=0;
    }

    return $FoundP;
    }


    proc string [] RuleBasedMatchMM(int $IndexN[],string $FindItemAllCase[], string $LineNA[]){
    $CountCase = 0;
    $Trigger = 0;
    for($LineN in $LineNA){
    $CountCase =1;
    $Number=-1;
    $Parts =FindStringVarZ($LineN);
    print $Parts;
    if(`size($Parts)`>0){

    for($eachP in $Parts){
    $Number = RuleBasedMatch($FindItemAllCase, $eachP);
    if($Number != -1){
    $FoundP[`size($FoundP)`]= $FindItemAllCase[$Number];
    $Trigger=1;
    }

    if($Trigger==1){break;}
    }
    clear $Parts;
    }

    if($Trigger==1){$returnCaseN[`size($returnCaseN)`] = $Number;}
    $Trigger=0;
    }
    $IndexN =$returnCaseN;
    return $FoundP;
    }


    proc int RuleBasedMatch(string $FindItemAllCase[], string $LineN){
    $CountCase = 0;
    $returnCaseN = 0;
    for($eachFindItem in $FindItemAllCase){
    //$matchString = `match $eachFindItem $LineN`;
    if(`gmatch $eachFindItem $LineN` == 1){
    $returnCaseN = $CountCase;
    break;
    }
    $CountCase++;
    }
    return $returnCaseN;
    }





    proc string [] AppendArrayZ(string $A[] , string $B[]){
    for($eachF in $B){
    $A[`size($A)`]= $eachF;
    }
    return $A;
    }



    proc int [] intArrayRemoveDuplicates(int $list[])
    {
    $index = 0;
    for ($item in $list) {
    if (0 == intArrayCount($item, $result)) {
    $result[$index++] = $item;
    }
    }
    return $result;
    }


    proc int intArrayCount(int $item, int $list[])
    {
    $result = 0;
    for ($listItem in $list) {
    if ($item == $listItem) $result++;
    }
    return $result;
    }


    proc string RemoveEscapedLine(string $TEXTA){
    $MatchPart = "";
    $stringNX = "";
    $MatchPart=match( "//", $TEXTA );
    if(`sizeBytes $MatchPart`>0){
    $MatchPart="";
    $MatchPart=match( "//[^\n]*", $TEXTA  );
    $stringNX = `substitute $MatchPart $TEXTA ""`;
    }else{$stringNX =$TEXTA;}
    return $stringNX;
    }



    proc string [] BracketFind(string $Find){
    $BytNumi = `sizeBytes $Find`;
    for($i=0;$i<$BytNumi;$i++){
    if($i==100){
    break;}
    $FirstBracket = `match "[\(][^\(]*[^.]*[^\(]*[\)]" $Find`;
    if($FirstBracket != ""){
    $AllFOUND[`size($AllFOUND)`] = $FirstBracket;
    $text = $Find;
    $result = substituteAllString($text, $FirstBracket, "#");
    $Find =  $result;
    }else if($FirstBracket == ""){
    print "found nothing";
    print $AllFOUND;
    $i = $BytNumi +2;
    break;
    }
    }
    return $AllFOUND;
    }

    proc string [] BracketFind(string $Find){
    $BytNumi = `sizeBytes $Find`;
    for($i=0;$i<$BytNumi;$i++){
    if($i==100){
    break;}
    $FirstBracket = `match "[\(][^\)]*[^.]*[^\(]*[\)]" $Find`;
    if($FirstBracket != ""){
    print ("found something"+"\n");
    $AllFOUND[`size($AllFOUND)`] = $FirstBracket;
    $text = $Find;
    $result = substituteAllString($text, $FirstBracket, "#");
    $Find =  $result;
    }else if($FirstBracket == ""){
    $i = $BytNumi +2;
    break;
    }
    }
    return $AllFOUND;
    }

    /*

    $testM = "$XI[1]= FloatToVec (MidPoint($XI[0],$XI[2]));";
    $BB = "$In3 = FloatToVec (lineIntersection($Po4[$Fi], $Xd, $li,(DirectionFN( $Ca,$li)) ));";

    $testBBracket = `match "[\(][\(]*[^.]*[^\(]*[\)]" $BB`;
    $testBBracket = `match "[\(]*[^.]*[\)]*[\)^]" $testBBracket`;


    $testB = BracketFind($BB);
    print $testB;


    $testM = "float $Po12[] = {($Po13[0]*-1), $Po13[1],$Po13[2]};";
    $testM = "float $Po12 = {($Po13[0]*-1), $Po13[1],$Po13[2]};";



    $B = `match "(float*[a-zA-Z_0-9]).+\=" $testM`;
    $B2 = `match ".*\\[" $B`;

    //
    ///



    $testM = "float $lineEPointA[]= MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);";
    $testM = "float $li[]= MultLenToDirAddToPoint($Le, $Fl, $Ve8[$Fi]);";
    $testM = "$BInomalV = FloatToVec(MultLenToDirAddToPoint(4, $BInomalVDirLine, $PtsVec [0]));";


    //current line
    //the command to replace
    $VartoReplace = "MultLenToDirAddToPoint";
    $OriginalStart = `match ".*\=" $testM`;
    //string $OriginalStart=`match ".*=*[+^M]" $testM`;
    $M = `match "($VartoReplace*[a-zA-Z_0-9]).+\;" $testM`;
    $M2 = `match "[\(][^\(]*[^.]*[^\(]*[\)]" $M`;
    $result = substituteAllString($M2, "(", "");
    $result = substituteAllString($result, ")", "");
    $M3 = `match "\$*[^,]*" $result`;
    clear $PartS;

    $resultTemp = $result;
    $BytS = 1;
    $PartS = stringToStringArray($resultTemp, ",");
    $Fix = $OriginalStart+"\("+$PartS[0]+"\*"+$PartS[1]+"\)"+"\+"+$PartS[2]+"\;";

    print ($testM+"\n");
    print ($Fix+"\n");







    //string $M3 = `match "[\[][^\[]*[^.]*[^\[]*[\]]" $M`;
    // $result = substituteAllString($result, $M3, "");
    $In3 = FloatToVec (lineIntersection($Po4[$Fi], $Xd, $li,(DirectionFN( $Ca,$li)) ));

    */


    proc int BracketFindPosNegRuleE( int $CN, string $NewLineX, string $TEXTA, int $NegPosZ[]){

    $AddAll = 0;
    $NewLineX="";
    $BracketF = `match "[\/]+[\*]"$TEXTA`;
    $BracketL = `match "[\*]+[\/]" $TEXTA`;
    $TRUEA = 0; int $TRUEB=0;

    if(`sizeBytes $BracketF`>0){$TRUEA=1;}
    if(`sizeBytes $BracketL`>0){$TRUEB=1;}

    if($TRUEA+$TRUEB!=2){
    if($TRUEA==1){
    $NegPosZ[`size($NegPosZ)`] = 1;
    $NewLineX=`substitute "//\*[^\n]*" $TEXTA ""`;
    }
    if($TRUEB==1){
    $NegPosZ[`size($NegPosZ)`] = 2;
    $NewLineX= `substitute ".*\*/" $TEXTA ""`;
    }
    for($eachInt in $NegPosZ){
    $CN++;
    $AddAll+= $eachInt;
    }
    }else{

    if($TRUEA+$TRUEB==3){
    $MatchPartA=`substitute "//\*[^\n]*" $TEXTA ""`;
    $MatchPartB=`substitute ".*\*/" $TEXTA ""`;
    $NewLineX=($MatchPartA+" "+$MatchPartB);
    $AddAll=0;
    }
    }


    return $AddAll;
    }


    proc string[] RStringArrayStartOfStringinArray(string $Array[]){
    $findEachstart = "";
    for ($eachString in $Array){

    $stringRN = `substitute "[/$]" $eachString ""`;
    $S=startString($eachString, 3);

    $findEachstart= $S;
    $findEachstart+= "";
    $StartOfEach[`size($StartOfEach)`]= $findEachstart;
    }

    return $StartOfEach;
    }

    proc string [] stringArrayCountDuplicatesAUGMENT(string $listX[],string $AddtoEnd)
    {
    $list = $listX;
    $list = ReverseStringArray($list);
    $index = 0;
    $X = 0;
    $C = 0;
    $result = $list;
    $Expr = "\\$";
    $ExprA = "";

    for ($item in $list) {
    $NumberE[$X] = stringArrayCount($item, $result);
    if (1 == $NumberE[$X]) {
    if(startString($item, 1)!= "$"){
    $CollectR[$X] = $ExprA+$item+$AddtoEnd;
    }
    if(startString($item, 1)== "$"){
    $CollectR[$X] = $item+$AddtoEnd;}
    }else{
    if (1 < $NumberE[$X]) {
    $C = $NumberE[$X]-1;
    if(startString($item, 1)!= "$"){
    $CollectR[$X] = $ExprA+$item+$C+$AddtoEnd;
    }
    if(startString($item, 1)== "$"){
    $CollectR[$X] = $item+$C+$AddtoEnd;
    }
    }
    }
    stringArrayRemoveToIndex(1, $result);
    $X++;	}
    $CollectR = ReverseStringArray($CollectR);
    return $CollectR;
    }

    proc string[] ReverseStringArray(string $array[]){
    for($i=0;$i<size($array);$i++){
    $arrayOut[$i]=$array[(size($array)-1-$i)];}
    return $arrayOut;
    }
    proc stringArrayRemoveToIndex(int $ix, string $stringArray[]){
    $ixX = 0;
    while($ixX<$ix){
    stringArrayRemoveAtIndex(0, $stringArray);
    $ixX++;
    }
    }
    proc int [] CreateIntIndex(int $ArraySize){
    $iNdex = 0;
    while($iNdex < $ArraySize){
    $IntArrayInex[$iNdex] = $iNdex;
    $iNdex++;
    }
    return $IntArrayInex;
    }

    proc string RuleBasedMatchReplaceLine(string $FindItemAllCase[],string $ReplaceCase[], string $LineN){
    $CC = 0;
    $returnCaseN = 0;
    $CHANGE=$LineN;
    for($eachFindItem in $FindItemAllCase){
    $matchString = `match $eachFindItem $CHANGE`;
    $Size =  `sizeBytes  $matchString`;
    if($Size>0){
    $CHANGE = substituteAllString($CHANGE, $matchString,  $ReplaceCase[$CC]);
    }
    $CC++;
    }
    return $CHANGE;
    }



    ///////////////////////////////////////


    $Path = "C:\\Users/johnny/Documents/maya/scripts/StereoCurveZTemp.TXT";
    $exampleFileName = ( $Path );


    clear $CollectAllLines;
    $LineN = "";
    $FindItem = "";

    $fileId = `fopen $exampleFileName "r"`;
    $nextLine = `fgetline $fileId`;
    $failsafe = 0;

    while ( !`feof $fileId` ) {

    //print $nextLine;
    $stringRN =  $nextLine;
    $stringRN = `substitute "(\n)" $stringRN ""`;
    $MatchPartA=match( ".*[^\t\r\n]", $nextLine );

    if(`sizeBytes $MatchPartA`>0){

    //$stringN = $nextLine;

    $LineN = $stringRN;
    //$matchString = `match $FindItem $LineN`;
    //if(`gmatch $matchString $FindItem` == 1){

    $CollectAllLines[`size($CollectAllLines)`]=$LineN;
    //}

    }
    $nextLine = `fgetline $fileId`;
    $failsafe++;

    if($failsafe==600){
    break;
    }
    }

    fclose $fileId;

    //  print $CollectAllLines;

    /////////////////////////////////////////////////////////////////////////////////////////////////// end of new change ^
    // print $CollectAllLines;





    $CNX = 0;
    for ($eachString in $CollectAllLines){
    $TempAllVarZ = FindTrueStringVarZ($eachString);
    AppendArrayZ($AllVarZ , $TempAllVarZ);
    if(`size($TempAllVarZ)`>0){
    clear $TempAllVarZ;
    }
    $CNX++;
    }


    $shorterListAllVarZ = stringArrayRemoveDuplicates ($AllVarZ);
    $SizeAll = `size($shorterListAllVarZ)`;
    $startingCharV = RStringArrayStartOfStringinArray($shorterListAllVarZ);


    $NewNames = stringArrayCountDuplicatesAUGMENT($startingCharV,"");
    clear $NewLineZ;
    $CountLineX = 0;

    for ($eachStringL in $CollectAllLines){
    $NewLineChange = RuleBasedMatchReplaceLine($shorterListAllVarZ ,$NewNames, $eachStringL);
    $NewLineZ[`size($NewLineZ)`] = $NewLineChange;
    $CountLineX++;
    }
    print $NewLineZ;






    $PathW = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
    $exampleFileNameW = ( $PathW );

    $Path = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEW.TXT";
    $exampleFileName = ( $Path );


    //clears the file i think
    $fileIdW = `fopen $exampleFileNameW "w"`;
    fclose $fileIdW;


    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $CountX = 0;
    $fileIdW = `fopen $exampleFileNameW "w"`;
    $fileId = `fopen $exampleFileName "r"`;
    $nextLine = "";
    $nextLineN = "";
    $TriggerLineFound = 0;
    $START = 0;
    $MatchPartA = "";
    $MatchPartB = "";
    $NewLineXA = "";
    $DontWrite = 0;
    $NegPosZA[0]=0;
    clear $NegPosZA;
    $CountN = 1;

    while ( !`feof $fileId` ) {
    $nextLine = `fgetline $fileId`;
    $nextLineN = $nextLine;

    $nextLineN=RemoveEscapedLine($nextLineN);
    $MatchPartA=match( ".*[^\t\r\n]", $nextLineN );
    if(`sizeBytes $MatchPartA`>0){
    $MatchPartA=match( ".*[^\t\r\n]", $nextLineN );
    $nextLineN=( $MatchPartA +"\r"+"\n");
    fprint $fileIdW $nextLineN;
    }

    }

    fclose $fileIdW;
    fclose $fileId;




    $PathW = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
    $exampleFileNameW = ( $PathW );

    $Path = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEW.TXT";
    $exampleFileName = ( $Path );

    $Path = "C:\\Users/johnny/Documents/maya/scripts/TESTRUN.TXT";
    $exampleFileName = ( $Path );

    //clears the file i think
    $fileIdW = `fopen $exampleFileNameW "w"`;
    fclose $fileIdW;


    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $CountX = 0;
    $fileIdW = `fopen $exampleFileNameW "w"`;
    $fileId = `fopen $exampleFileName "r"`;
    $nextLine = "";
    $nextLineN = "";
    $TriggerLineFound = 0;
    $START = 0;
    $MatchPartA = "";
    $MatchPartB = "";
    $NewLineXA = "";
    $DontWrite = 0;
    $NegPosZA[0]=0;
    clear $NegPosZA;
    $CountN = 1;

    while ( !`feof $fileId` ) {
    $nextLine = `fgetline $fileId`;
    $nextLineN = $nextLine;



    $MatchPartA=match( ".*[^\t\r\n]", $nextLineN );

    // if(`sizeBytes $MatchPartA`>0){
    $WhenZero = BracketFindPosNegRuleE($CountN,$NewLineXA,$nextLineN, $NegPosZA);

    if($WhenZero!=0){
    $CountN+=$WhenZero;
    }
    if($WhenZero==3){
    $CountN*=-1;
    print $CountN;
    }

    if(($CountN==2)||($WhenZero==3)){
    $nextLineN=$NewLineXA;
    }


    if(($CountN<=2)||($WhenZero==3)){

    if(($CountN<0)&&($WhenZero!=3)){
    // do nothing
    }else{

    $nextLineN=RemoveEscapedLine($nextLineN);
    $MatchPartA=match( ".*[^\r\n]", $nextLineN );
    $nextLineN=( $MatchPartA +"\r"+"\n");
    fprint $fileIdW $nextLineN;
    }

    }

    if($CountN<0){
    clear $NegPosZA;
    $CountN=1;
    }

    //}

    }

    fclose $fileIdW;
    fclose $fileId;
    -13-24-100-11-19-194-160-534-262-22-38-20-12-876-70-18-800-74-74-118-34-12-10-100-1982-404-1100-10-40-240-840-10-16-60-2534-610-44-126-498-36-2018-1106-118
    -12-23-90-10-18-182-138-456-256-18-36-16-6-746-58-14-646-46-54-102-28-6-6-88-1794-364-982-6-34-208-808-6-6-50-2330-548-38-120-428-34-1654-990-104
    -12-23-90-10-18-180-136-454-254-16-34-14-6-746-58-14-646-46-54-102-28-6-6-88-1794-364-982-6-34-208-808-6-6-50-2330-548-38-120-428-34-1654-990-104fclose $fileIdW;





    $PathW = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
    $exampleFileNameW = ( $PathW );

    $Path = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEW.TXT";
    $exampleFileName = ( $Path );

    //clears the file i think
    $fileIdW = `fopen $exampleFileNameW "w"`;
    fclose $fileIdW;


    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $CountX = 0;
    $fileIdW = `fopen $exampleFileNameW "w"`;
    $fileId = `fopen $exampleFileName "r"`;
    $nextLine = "";
    $nextLineN = "";
    $TriggerLineFound = 0;
    $START = 0;
    $MatchPartA = "";
    $MatchPartB = "";
    $NewLineXA = "";
    $DontWrite = 0;

    while ( !`feof $fileId` ) {
    $nextLine = `fgetline $fileId`;
    $nextLineN = $nextLine;

    $nextLineN=RemoveEscapedLine($nextLineN);

    $MatchPartA=match( ".*[\n]", $nextLineN );
    if(`sizeBytes $MatchPartA`>0){


    $MatchPartB=match( "/", $nextLineN );
    if(`sizeBytes $MatchPartB`>0){

    $WhenZero = BracketFindPosNegRuleE($NewLineXA,$nextLineN, $NegPosZA);
    $nextLineN=$NewLineXA;


    if(($WhenZero==1)||($WhenZero==0)){

    if($DontWrite==0){
    $nextLineN=($nextLineN +"\r"+"\n");
    fprint $fileIdW $nextLineN;
    }

    }

    if(`size($NegPosZA)`>0){
    $DontWrite=1;
    }
    if(($WhenZero==0)&&(`size($NegPosZA)`>0)){
    if($DontWrite==1){
    $WhenZero=2;
    clear $NegPosZA;
    $DontWrite=0;
    }
    }
    }
    ////////////

    if(`size($NegPosZA)`==0){
    if($DontWrite==0){
    $nextLineN=($nextLineN +"\r"+"\n");
    fprint $fileIdW $nextLineN;
    }
    }

    }

    }

    fclose $fileIdW;
    fclose $fileId;







    $Path = "C:\\Users/johnny/Documents/maya/scripts/STEREOCURVESPROC2011.TXT";
    $exampleFileName = ( $Path );

    //string $Path = "C:\\Users/johnny/Documents/maya/scripts/ArrayRotationIterative.TXT";
    //string $exampleFileName = ( $Path );


    $ScriptNAME = ("proc[^\\n]*");
    $FindItem = "proc";
    $GlobalSNAME = ("global[^\\n]*");



    clear $CollectAllLines;
    $LineN = "";
    clear $LineNumber;
    $CountNL = 1;
    $CountFindNL = 0;
    $CountMasterInDex = 0;

    $fileId = `fopen $exampleFileName "r"`;

    while ( !`feof $fileId` ) {

    $nextLine = `fgetline $fileId `;
    $stringN = match( "^[^(\r\n)]*", $nextLine );


    //$stringN = $nextLine;
    $LineN =  $stringN;

    //$LineN =match( "[/(proc)]*", $stringN  );
    if(`FindSCRIPTNAME($LineN )` == 1){

    //if(`gmatch $FindItem $LineN` == 1){
    //$LineN =match( $ScriptNAME, $nextLine);

    $CollectAllLines[`size($CollectAllLines)`]=  $LineN ;
    $LineNumber[$CountFindNL] = $CountNL;
    $CountFindNL++;
    }
    $CountNL++;
    $CountMasterInDex++;
    }

    fclose $fileId;
    print $CollectAllLines[0];

    print $LineNumber


    //////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////

    // FIND LAST DUPLICATES

    proc int[] SortIntIndexTrack(int $AllFloatToSort[]){
    for($ii=0; $ii<`size($AllFloatToSort)`; $ii++){
    $aF[$ii]= ($AllFloatToSort[$ii]);
    }
    $sIze = `size($aF)`-1;
    $IndexTrack = CreateIntIndex(`size($aF)`);
    quickSort($aF, $IndexTrack, 0, $sIze);
    $IndexTrack = ReverseIntArray($IndexTrack);
    return $IndexTrack;
    }



    $SizeL = `size($CollectAllLines)`;
    clear $JustNames;
    for($iL=0; $iL<$SizeL; $iL++){
    $TempN = FindStringVarZ($CollectAllLines[$iL]);
    $JustNames[$iL]=$TempN[`size($TempN)`-1];
    }
    size($JustNames);
    size($CollectAllLines);

    $CollectAllLines = $JustNames;


    clear $tempLineNumber;
    $tempLineNumber = $LineNumber;
    clear $foundNA;
    // line number is an extraction...... //
    clear $tempCollectAllLines;
    $tempCollectAllLines = $CollectAllLines;
    clear $CollectAllDuplicates;

    /////////////////////////////string $tempCollectAllLines[] = stringArrayStrip($CollectAllLines);

    $CollectAllDuplicates = stringArrayFindDupIndexSPair($tempCollectAllLines,$foundNA, $tempLineNumber);


    $intIDXSort = SortIntIndexTrack($foundNA);

    for($ii=0; $ii<`size($intIDXSort)`; $ii++){
    $newCollectDupString[$ii]= $CollectAllDuplicates[$intIDXSort[$ii]];
    }
    print $newCollectDupString;



    //print  $foundNA;
    //print $CollectAllDuplicates

    //string $shouldBEZero[];
    //$shouldBEZero= stringArrayFindDuplicates($CollectAllDuplicates);



    // IMPORTANT SORT

    $foundNA =`sort $foundNA`;


    //int $foundNA[];
    //$foundNA =$MasterLineN;


    $Path = "C:\\Users/johnny/Documents/maya/scripts/STEREOCURVESPROC2011.TXT";
    $exampleFileName = ( $Path );


    $PathW = "C:\\Users/johnny/Documents/maya/scripts/NewPlaceHere.TXT";
    $exampleFileNameW = ( $PathW );

    //clears the file i think
    $fileIdW = `fopen $exampleFileNameW "w"`;
    fclose $fileIdW;


    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $CountX = 0;
    $fileIdW = `fopen $exampleFileNameW "w"`;
    $fileId = `fopen $exampleFileName "r"`;
    $nextLine = "";
    $nextLineN = "";
    $TriggerLineFound = 0;
    $START = 0;
    $InputLine = ("///THIS IS A DUPLICATE ///"+"\r"+"\n");

    while ( !`feof $fileId` ) {
    $nextLine = `fgetline $fileId`;
    $nextLineN = $nextLine;
    $nextLineR = match( ".*[^(\n)]", $nextLine );

    if($foundNA[$CountFindNL] == $CountNL){
    fprint $fileIdW ("\r"+"\n");
    $CountFindNL++;
    $TriggerLineFound=1;
    }

    if($TriggerLineFound==1){
    $WhenZero = BracketFindPosNeg($nextLine, $NegPosZA);
    $START++;
    $nextLineN=($nextLineR +"\r"+"\n");

    fprint $fileIdW $nextLineN;


    if((`size($NegPosZA)`>0)&&($START>1)){
    if($WhenZero==0){
    $START=$TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
    fprint $fileIdW ("\r"+"\n");
    }
    }

    }
    $CountNL++;
    }

    fclose $fileIdW;
    fclose $fileId;



    //////////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////////
    //small addOn




    $Path = "C:\\Users/johnny/Documents/maya/scripts/PlaceHere.TXT";
    $exampleFileName = ( $Path );
    clear $IndeXCN;
    $IndeXCN
    clear $IndexR;
    $SizeCD = `size($newCollectDupString)`-1;

    $fileId = `fopen $exampleFileName "r"`;

    while ( !`feof $fileId` ) {

    $nextLine = `fgetline $fileId `;
    $nextLineR = match( ".*[^(\n)]", $nextLine );
    //$nextLineRN = match( ".*[^(\n)]", $nextLine );

    $Size =  `sizeBytes  $nextLineR`;
    if($Size>0){
    RuleBasedMatchM($IndexR,$newCollectDupString, {$nextLineR});
    for($ii=0; $ii<`size($IndexR)`; $ii++){
    $IndeXCN[$IndexR[$ii]]+=1;
    }
    clear $IndexR;
    }
    }

    fclose $fileId;



    for($ii=0; $ii<`size($newCollectDupString)`; $ii++){
    $StringINDEXCN=$IndeXCN[$ii];
    $PRINTPRoc_andNumber[$ii]=($newCollectDupString[$ii]+" "+$StringINDEXCN);

    }
    print $PRINTPRoc_andNumber;
    size($IndeXCN);
    size($PRINTPRoc_andNumber);
    print $IndeXCN;


    $IndeXCN = RemoveIntAtIndex($IndeXCN,{(`size($IndeXCN)`-1)});


    $intIDXSortX = SortIntIndexTrack($IndeXCN);

    for($ii=0; $ii<`size($intIDXSort)`; $ii++){
    $SortCountProcUse[$ii]= $newCollectDupString[$intIDXSortX[$ii]];
    }
    print $SortCountProcUse;



    clear $newfoundNA;
    for($ii=0; $ii<`size($IndeXCN)`; $ii++){

    if($IndeXCN[$ii]!=1){
    $newfoundNA[`size($newfoundNA)`]= $foundNA[$ii];
    }
    }


    print $newfoundNA;

    size($newfoundNA);

    size($newCollectDupString);
    size($IndexR);
    size($IndeXCN);
    size($foundNA);
    size($CollectAllDuplicates);
    size($intIDXSort);
    size($newCollectDupString);


    $newfoundNA =`sort ($newfoundNA)`;



    $Path = "C:\\Users/johnny/Documents/maya/scripts/STEREOCURVESPROC2011.TXT";
    $exampleFileName = ( $Path );


    $PathW = "C:\\Users/johnny/Documents/maya/scripts/NewPlaceHere.TXT";
    $exampleFileNameW = ( $PathW );

    //clears the file i think
    $fileIdW = `fopen $exampleFileNameW "w"`;
    fclose $fileIdW;


    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $CountX = 0;
    $fileIdW = `fopen $exampleFileNameW "w"`;
    $fileId = `fopen $exampleFileName "r"`;
    $nextLine = "";
    $nextLineN = "";
    $TriggerLineFound = 0;
    $START = 0;
    $InputLine = ("///THIS IS A DUPLICATE ///"+"\r"+"\n");

    while ( !`feof $fileId` ) {
    $nextLine = `fgetline $fileId`;
    $nextLineN = $nextLine;
    $nextLineR = match( ".*[^(\n)]", $nextLine );

    if($newfoundNA[$CountFindNL] == $CountNL){
    fprint $fileIdW ("\r"+"\n");
    $CountFindNL++;
    $TriggerLineFound=1;
    }

    if($TriggerLineFound==1){
    $WhenZero = BracketFindPosNeg($nextLine, $NegPosZA);
    $START++;
    $nextLineN=($nextLineR +"\r"+"\n");

    fprint $fileIdW $nextLineN;


    if((`size($NegPosZA)`>0)&&($START>1)){
    if($WhenZero==0){
    $START=$TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
    fprint $fileIdW ("\r"+"\n");
    }
    }

    }
    $CountNL++;
    }

    fclose $fileIdW;
    fclose $fileId;








    ////////////////////

    //START X




    $Path = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
    $exampleFileName = ( $Path );


    $FindItem = "proc";
    //string $FindItem = "print";
    //string $FindItem = "//";


    clear $CollectAllLines;
    $LineN = "";
    clear $LineNumber;
    $CountNL = 1;
    $CountFindNL = 0;
    $CountMasterInDex = 0;

    $fileId = `fopen $exampleFileName "r"`;
    //string $nextLine = `fgetline $fileId`;
    while ( !`feof $fileId` ) {


    $nextLine = `fgetline $fileId`;
    $stringN = match( "^[^(\r\n)]*", $nextLine );
    $LineN = $stringN;

    if(`FindSCRIPTNAME($LineN )` == 1){
    $CollectAllLines[`size($CollectAllLines)`]=  $LineN ;
    $LineNumber[$CountFindNL] = $CountNL;
    $CountFindNL++;
    }

    $CountNL++;
    $CountMasterInDex++;
    }

    fclose $fileId;


    size($CollectAllLines);
    size($LineNumber);

    print $CollectAllLines[0];
    FindStringVarZ($CollectAllLines[0]);


    //////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////

    // FIND LAST DUPLICATES

    $SizeL = `size($CollectAllLines)`;
    clear $JustNames;
    for($iL=0; $iL<$SizeL; $iL++){
    $TempN = FindStringVarZ($CollectAllLines[$iL]);
    $JustNames[$iL]=$TempN[`size($TempN)`-1];
    }




    size($JustNames);
    size($CollectAllLines);
    size($LineNumber);

    $TempSaveLine=$LineNumber;
    $CollectAllLines = $JustNames;

    //TempERROR hack

    $CurrentProc[0] ="proc";

    $i = 0;
    clear $IndexX;
    clear $FoundProc;
    clear $CurrentLineN;
    $FoundProc =RuleBasedMatchM($IndexX,$CollectAllLines, $CurrentProc);
    //print $IndexX;
    for($i=0; $i<`size($IndexX)`; $i++){
    $CurrentLineNF[$i] =$LineNumber[$IndexX[$i]];
    }
    print $CurrentLineNF;

    $CollectAllLines=RemoveStringAtIndex($CollectAllLines,$IndexX);
    $LineNumber = RemoveIntAtIndex($LineNumber,$IndexX);

    //!!!Super Crazy Error!!! A String call "proc" was gathered as a function proc!
    /*
    print $CollectAllLines[$IndexX[0]];
    $CollectAllLines=RemoveStringAtIndex($CollectAllLines,$IndexX);
    $LineNumber = RemoveIntAtIndex($LineNumber,$IndexX);
    */
    /// End of error hack




    //start of normal script



    $TempSaveLine=$LineNumber;
    $CollectAllLines = $JustNames;



    $CurrentProc[0] ="AutoCurveScriptsTwoCurve";
    $CurrentProc[1] ="RUNMoveZCURVEM";
    $CurrentProc[2] ="EvalAllCurvesToolZ";
    $CurrentProc[3] ="CreateCAMforIntCurveScript";
    $CurrentProc[4] ="createStageOneForRetopo";



    clear $CurrentProc;
    $CurrentProc[0] ="CreateCAMforIntCurveScript";
    $CurrentProc[1] ="createStageOneForRetopo";







    $TempSaveLine=$LineNumber;
    $CollectAllLines = $JustNames;



    clear $CurrentProc;
    $CurrentProc[0] ="AutoCurveScriptsTwoCurve";




    $TempSaveLine=$LineNumber;
    $CollectAllLines = $JustNames;



    $CurrentProc[0] ="AutoCurveScriptsTwoCurve";
    $CurrentProc[1] ="RUNMoveZCURVEM";
    $CurrentProc[2] ="EvalAllCurvesToolZ";
    $CurrentProc[3] ="CreateCAMforIntCurveScript";
    $CurrentProc[4] ="createStageOneForRetopo";




    clear $CurrentLineNF;

    $i = 0;
    clear $IndexX;
    clear $FoundProc;

    $FoundProc =RuleBasedMatchM($IndexX,$CollectAllLines, $CurrentProc);
    //print $IndexX;
    for($i=0; $i<`size($IndexX)`; $i++){
    $CurrentLineNF[$i] =$LineNumber[$IndexX[$i]];
    }
    print $CurrentLineNF;






    $CurrentProc[0] ="AutoCurveScriptsTwoCurve";


    $i = 0;
    clear $IndexX;
    clear $FoundProc;
    clear $CurrentLineN;
    $FoundProc =RuleBasedMatchM($IndexX,$CollectAllLines, $CurrentProc);
    //print $IndexX;
    for($i=0; $i<`size($IndexX)`; $i++){
    $CurrentLineNF[$i] =$LineNumber[$IndexX[$i]];
    }
    print $CurrentLineNF;



    ////////////////  run both ONCE
    ////////////////  run both ONCE




    $Path = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
    $exampleFileName = ( $Path );

    // search AutoCurveScriptsTwoCurve	 find procs then within those procs find more procs until
    // $MasterLineN

    clear $MasterLineN;


    $CurrentLineN = $CurrentLineNF;
    $CurrentLineN = sort ($CurrentLineN);
    clear $CollectL;
    clear $CAL_temp;
    clear $LN_temp;


    $CAL_temp =$CollectAllLines;
    $LN_temp =$LineNumber;
    $IndexX = sort ($IndexX);
    $CAL_temp=RemoveStringAtIndex($CAL_temp,$IndexX);
    $LN_temp = RemoveIntAtIndex($LN_temp,$IndexX);


    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $START = 0;
    $TriggerLineFound = 0;
    clear $CurrentLineNX;
    clear $tempCollectProc;
    clear $IndexX;

    $Aint = size($CollectAllLines);
    $Bint = size($AllFoundProcs);
    $Cint = size($CAL_temp);
    $CHECK = $Aint-$Cint ;

    //int $fileId =`fopen $exampleFileName "r"`;
    //string $nextLine = `fgetline $fileId`;
    //int $eachInt = $CurrentLineN[0];
    clear $tempCollectProc;
    clear $AllFoundProcs;

    clear $WholeProc;
    $TRIGGEREND = 2;

    clear $DebugS;

    $fileId = `fopen $exampleFileName "r"`;


    while($TRIGGEREND>1){



    ///////////////////////////
    ///////////////////////////



    for($eachInt in $CurrentLineN){


    //this is the number that is the first line of a group of lines that are a proc


    $WhenZero=2;
    $CountNL = 1;
    $CountFindNL = 0;
    $START = 0;
    $TriggerLineFound=0;



    ///////////////////////////////////////////////////////////////////

    while ( !`feof $fileId` ) {


    $nextLine = `fgetline $fileId`;
    $nextLineN = match( "^[^(\r\n)]*", $nextLine );
    $nextLineR = match( ".*[^(\n)]", $nextLine );

    //FOUND LINE NUMBER
    //CHANGE HERE

    if($CurrentLineN[$CountFindNL] == $CountNL){
    print $nextLineR;
    clear $NegPosZA;
    $CountFindNL++;
    $TriggerLineFound=1;
    }



    if($TriggerLineFound==1){

    $WhenZero = BracketFindPosNeg($nextLineR, $NegPosZA);
    $START++;
    $CollectL[`size($CollectL)`]= $nextLineR;
    //$DebugS[`size($DebugS)`]= $nextLineR;



    /// WHEN PROC IS FULLY SCANNED HERE BELOW

    if(($WhenZero==0)&&($START>1)){
    clear $IndexX;
    clear $FoundProcTemp;

    $START=$TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
    // $CAL_temp IS $CollectAllLines;  MATCH NAMES//
    if(`size($CAL_temp)`==0){break;}

    $FoundProcTemp =RuleBasedMatchM($IndexX,$CAL_temp, $CollectL);
    clear $CollectL;
    // $LN_temp =$LineNumber;
    if(`size($IndexX)`>0){

    $IndexX=intArrayRemoveDuplicates($IndexX);
    if(`size($IndexX)`>0){
    $IndexX = sort($IndexX);

    for($i=0; $i<`size($IndexX)`; $i++){
    if($LN_temp[$IndexX[$i]]!=0){
    $CurrentLineNX[`size($CurrentLineNX)`] =$LN_temp[$IndexX[$i]];
    }
    }



    $CAL_temp=RemoveStringAtIndex($CAL_temp,$IndexX);
    $LN_temp = RemoveIntAtIndex($LN_temp,$IndexX);
    }
    clear $IndexX;
    /////////////

    }

    $tempCollectProc =AppendArrayZ($tempCollectProc, $FoundProcTemp);

    clear $FoundProcTemp;
    /////////////////////




    }
    }
    //LINE NUMBER
    $CountNL++;

    }

    ///////////////////////////////////////////////////////////////////

    clear $DebugS;
    //print $tempCollectProc;

    }
    frewind $fileId;

    ///////////////////////////
    ///////////////////////////




    $tempCollectProc= stringArrayRemoveDuplicates($tempCollectProc);
    AppendArrayZ($AllFoundProcs,$tempCollectProc);

    $TempStringP = "";
    $TempStringP = stringArrayToString($tempCollectProc, ", ");
    //print ($TempStringP+"\n");
    $WholeProc[`size($WholeProc)`]=$TempStringP;


    clear $tempCollectProc;

    //////////////////////

    $list = IntArrayToStringArray($CurrentLineNX);
    $list= stringArrayRemoveDuplicates($list);

    clear $CurrentLineN;
    $CurrentLineN=StringArrayToIntArray($list);
    $CurrentLineN =sort ($CurrentLineN);


    clear $CurrentLineNX;
    //////////////////////

    clear $tempCollectProc;
    //////////////////////

    if(`size($CurrentLineN)`>0){
    for($i=0; $i<`size($CurrentLineN)`; $i++){
    $MasterLineN[`size($MasterLineN)`] =$CurrentLineN[$i];
    }
    $MasterLineN=sort($MasterLineN);
    $MasterLineN=intArrayRemoveDuplicates($MasterLineN);

    }


    //print ($TempStringP+"\n");
    print $CurrentLineN[0];





    if($CurrentLineN[0]==0){
    print "STOPSTOP";
    $TRIGGEREND =0;
    break;
    }

    if(`size($CurrentLineN)`==0){
    print "STOPSTOP";
    $TRIGGEREND =0;
    break;
    }



    }

    print $WholeProc;

    fclose $fileId;

    print $MasterLineN





    proc int [] intArrayRemoveEqual(int $list[],int $listB[]){
    $index = 0;
    $i = 0;
    $S = `size($listB)`-1;
    for ($item in $list) {
    if ($listB[$i]== $item) {

    $i++;
    if($i>$S){break;}
    }else{$result[$index++] = $item;}
    }

    return $result;
    }



    print $MasterLineN[0]
    $MasterLineN=sort($MasterLineN);
    $MasterLineN=intArrayRemoveDuplicates($MasterLineN);




    /*
    print $CollectL;
    $TEMPNAMES =RuleBasedMatchM($IndexX,$CAL_temp, $DebugS);
    print $TEMPNAMES
    print $IndexX;
    clear$IndexX;
    clear$TEMPNAMES;

    $TEMPNAMES=RuleBasedMatchMM($IndexX,$CAL_temp, $DebugS);


    print $DebugS;
    size($DebugS)
    print $CollectL


    $FindN = $DebugS[22];

    $match0N = `match "([\$]+)([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
    $stringRN = `substitute "([\$]+)([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN ""`;

    print $tempCollectProc
    print $CurrentLineNX


    */











    $CurrentLineN = $CurrentLineNF;
    clear $CollectL;
    clear $CAL_temp;
    clear $LN_temp;
    $CAL_temp =$CollectAllLines;
    $LN_temp =$LineNumber;
    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $START = 0;
    $TriggerLineFound = 0;
    clear $AllFoundProcs;
    clear $FoundProcTemp;
    clear $CurrentLineNX;
    clear $tempCollectProc;

    $Aint = size($CollectAllLines);
    $Bint = size($AllFoundProcs);
    $Cint = size($CAL_temp);
    $CHECK = $Aint-$Cint ;

    //int $fileId =`fopen $exampleFileName "r"`;
    //string $nextLine = `fgetline $fileId`;
    $eachInt = $CurrentLineN[0];
    clear $tempCollectProc;
    clear $AllFoundProcs;

    clear $WholeProc;
    $TRIGGEREND = 2;

    //while($TRIGGEREND>1){

    //$eachInt=$CurrentLineN[0];

    for($eachInt in $CurrentLineN){


    //this is the number that is the first line of a group of lines that are a proc
    clear $LN_temp;
    clear $CollectL;
    clear $NegPosZA;
    clear $IndexX;
    //clear $FoundProcTemp;
    $WhenZero=2;
    $CountNL = 1;
    $CountFindNL = 0;
    $START = 0;
    $TriggerLineFound=0;

    $fileId = `fopen $exampleFileName "r"`;

    while ( !`feof $fileId` ) {



    $nextLine = `fgetline $fileId`;
    $nextLineN = match( "^[^(\r\n)]*", $nextLine );
    if($eachInt == $CountNL){
    clear $NegPosZA;
    $CountFindNL++;
    $TriggerLineFound=1;
    }

    if($TriggerLineFound==1){
    $WhenZero = BracketFindPosNeg($nextLine, $NegPosZA);
    $START++;

    $CollectL[`size($CollectL)`]= $nextLineN;

    if(($WhenZero==0)&&($START>1)){$START=$TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
    clear $IndexX;

    //clear $FoundProcTemp;
    $FoundProcTemp =RuleBasedMatchM($IndexX,$CAL_temp, $CollectL);

    //print $FoundProcTemp;

    if(`size($IndexX)`>0){
    IndexX=intArrayRemoveDuplicates(IndexX);
    $IndexX = sort($IndexX);


    for($i=0; $i<`size($IndexX)`; $i++){
    $CurrentLineNX[`size($CurrentLineNX)`] =$LN_temp[$IndexX[$i]];
    }

    $CAL_temp=RemoveStringAtIndex($CAL_temp,$IndexX);
    $LN_temp = RemoveIntAtIndex($LN_temp,$IndexX);
    clear $IndexX;
    }

    $FoundProcTemp= stringArrayRemoveDuplicates($FoundProcTemp);
    $tempCollectProc =AppendArrayZ($tempCollectProc, $FoundProcTemp);
    $tempCollectProc= stringArrayRemoveDuplicates($tempCollectProc);
    break;

    }
    }

    $CountNL++;
    }


    //print $FoundProcTemp
    //$tempCollectProc
    //print $tempCollectProc
    //$AllFoundProcs=stringArrayRemoveDuplicates($AllFoundProcs);
    frewind $fileId;
    //fclose $fileId;

    }

    AppendArrayZ($AllFoundProcs,$tempCollectProc);

    $TempStringP = "";
    $TempStringP = stringArrayToString($tempCollectProc, ", ");
    //clear $tempCollectProc;

    $list = IntArrayToStringArray($CurrentLineNX);
    $list= stringArrayRemoveDuplicates($list);

    clear $CurrentLineN;
    $CurrentLineN=StringArrayToIntArray($list);

    $CurrentLineN =sort ($CurrentLineN);
    if(`size($CurrentLineN)`>0){
    for($i=0; $i<`size($CurrentLineN)`-1; $i++){
    $MasterLineN[`size($MasterLineN)`] =$CurrentLineN[$i];
    }
    }
    //clear $tempCollectProc;
    clear $CurrentLineNX;
    // print $CurrentLineN[0];


    $WholeProc[`size($WholeProc)`]=$TempStringP;
    //clear $TempStringP;

    if(`size($CurrentLineN)`==0){
    print "STOPSTOP";
    }

    if(`size($TempStringP)`==0){
    print "STOP SEARCH FINISHED END ";
    $TRIGGEREND =0;
    //break;
    }
    if(`size($CurrentLineN)`==1){
    if($CurrentLineN[0]==0){
    print "STOPSTOP";
    $TRIGGEREND =0;
    //break;
    }
    }

    print $WholeProc;


    //}

    print $WholeProc;

    //clear $AllFoundProcs
    //size($MasterLineN);
    //size($AllFoundProcs);
    // string $shouldBEZero[];
    // $shouldBEZero= stringArrayFindDuplicates($AllFoundProcs);
    //size($CollectAllLines);
    //size($LineNumber);
    //size($CollectAllLines);
    //size($MasterLineN);
    ///// now write each proc to a single file..
    //print $MasterLineN;

    $list = IntArrayToStringArray($MasterLineN);
    $list= stringArrayRemoveDuplicates($list);
    $list=sort($list);
    if($list[0]==0){
    $list=RemoveStringAtIndex($list,{0});}
    $NewMasterLineN=StringArrayToIntArray($list);
    $NewMasterLineN=sort($NewMasterLineN);

    clear $list;
    $list= stringArrayRemoveDuplicates($AllFoundProcs);

    //size($list);
    //size($NewMasterLineN);
    //size($AllFoundProcs);
    /////////////////////////////GOT IT
    //$TempSaveLine
    //$JustNames

    clear $XIndexN;
    clear $FINDX;
    $FINDX =RuleBasedMatchM($XIndexN,$JustNames,$list);

    $SortedList=sort($XIndexN);
    clear $LINEplace;
    for($eachINT in $SortedList){
    $LINEplace[`size($LINEplace)`]=$TempSaveLine[$eachINT];
    }




    clear $foundNA;
    $foundNA= $LINEplace ;
    $foundNA=sort($foundNA);


    $Path = "C:\\Users/johnny/Documents/maya/scripts/PlaceHere.TXT";
    $PathW = "C:\\Users/johnny/Documents/maya/scripts/NEWAllStereoRelated.TXT";
    $exampleFileName = ( $Path);
    $exampleFileNameW = ( $PathW );
    //clears the file i think
    $fileIdW = `fopen $exampleFileNameW "w"`;
    fclose $fileIdW;
    clear $Xall;
    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $CountX = 0;
    $fileIdW = `fopen $exampleFileNameW "w"`;
    $fileId = `fopen $exampleFileName "r"`;
    $nextLine = "";
    $nextLineN = "";
    $TriggerLineFound = 0;
    $START = 0;
    $STARTN = 0;
    $InputLine = ("///THIS IS A DUPLICATE ///"+"\r"+"\n");

    while ( !`feof $fileId` ) {
    $nextLine = `fgetline $fileId`;


    $nextLineN =$nextLine;
    if($foundNA[$CountFindNL] == $CountNL){
    clear $NegPosZA;
    $WhenZero=2;
    print ($nextLine+"\n");
    fprint $fileIdW ("\r"+"\n");
    $CountFindNL++;
    $TriggerLineFound=1;
    }

    if($TriggerLineFound==1){
    $Xall[`size($Xall)`]=$nextLine;
    $WhenZero = BracketFindPosNeg($nextLine, $NegPosZA);
    $nextLineN=($nextLineN +"\r"+"\n");
    fprint $fileIdW $nextLineN;

    if(($WhenZero==0)&&(`size($NegPosZA)`>0)){
    $TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
    fprint $fileIdW ("\r"+"\n");
    }
    }

    $CountNL++;
    }

    fclose $fileIdW;
    fclose $fileId;











    //////////
    /////////////////////////NEW





    proc Matrix3D(){
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $xx = 1.0;
    $yy = 1.0;
    $zz = 1.0;
    }

    proc scaleMATRIX_A(float $f) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $xx *= $f;
    $xy *= $f;
    $xz *= $f;
    $xo *= $f;
    $yx *= $f;
    $yy *= $f;
    $yz *= $f;
    $yo *= $f;
    $zx *= $f;
    $zy *= $f;
    $zz *= $f;
    $zo *= $f;
    }
    proc scaleMATRIX_B(float $xf, float $yf, float $zf) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $xx *= $xf;
    $xy *= $xf;
    $xz *= $xf;
    $xo *= $xf;
    $yx *= $yf;
    $yy *= $yf;
    $yz *= $yf;
    $yo *= $yf;
    $zx *= $zf;
    $zy *= $zf;
    $zz *= $zf;
    $zo *= $zf;
    }
    proc translateMATRIX_float(float $x, float $y, float $z) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $xo += $x;
    $yo += $y;
    $zo += $z;
    }
    ///////////////////////////////////////////
    proc translateMATRIX_VEC(vector $t) {
    translateMATRIX_float((VecCom($t,0)),(VecCom($t,1)),(VecCom($t,2)));
    }

    proc yrotMATRIX(float $thetaX) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static;
    $theta=$thetaX;
    $theta *= ($PI_Static / 180.0);
    $ct = cos($theta);
    $st = sin($theta);
    $Nxx = (float) ($xx * $ct + $zx * $st);
    $Nxy = (float) ($xy * $ct + $zy * $st);
    $Nxz = (float) ($xz * $ct + $zz * $st);
    $Nxo = (float) ($xo * $ct + $zo * $st);
    $Nzx = (float) ($zx * $ct - $xx * $st);
    $Nzy = (float) ($zy * $ct - $xy * $st);
    $Nzz = (float) ($zz * $ct - $xz * $st);
    $Nzo = (float) ($zo * $ct - $xo * $st);
    $xo = $Nxo;
    $xx = $Nxx;
    $xy = $Nxy;
    $xz = $Nxz;
    $zo = $Nzo;
    $zx = $Nzx;
    $zy = $Nzy;
    $zz = $Nzz;
    }
    proc xrotMATRIX(float $thetaX) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static;
    $theta=$thetaX;
    $theta *= ($PI_Static / 180.0);
    $ct = cos($theta);
    $st = sin($theta);
    $Nyx = (float) ($yx * $ct + $zx * $st);
    $Nyy = (float) ($yy * $ct + $zy * $st);
    $Nyz = (float) ($yz * $ct + $zz * $st);
    $Nyo = (float) ($yo * $ct + $zo * $st);
    $Nzx = (float) ($zx * $ct - $yx * $st);
    $Nzy = (float) ($zy * $ct - $yy * $st);
    $Nzz = (float) ($zz * $ct - $yz * $st);
    $Nzo = (float) ($zo * $ct - $yo * $st);
    $yo = $Nyo;
    $yx = $Nyx;
    $yy = $Nyy;
    $yz = $Nyz;
    $zo = $Nzo;
    $zx = $Nzx;
    $zy = $Nzy;
    $zz = $Nzz;
    }
    proc zrotMATRIX(float $thetaX) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static;
    $theta=$thetaX;
    $theta *= ($PI_Static / 180.0);
    $ct = cos($theta);
    $st = sin($theta);
    $Nyx = (float) ($yx * $ct + $xx * $st);
    $Nyy = (float) ($yy * $ct + $xy * $st);
    $Nyz = (float) ($yz * $ct + $xz * $st);
    $Nyo = (float) ($yo * $ct + $xo * $st);
    $Nxx = (float) ($xx * $ct - $yx * $st);
    $Nxy = (float) ($xy * $ct - $yy * $st);
    $Nxz = (float) ($xz * $ct - $yz * $st);
    $Nxo = (float) ($xo * $ct - $yo * $st);
    $yo = $Nyo;
    $yx = $Nyx;
    $yy = $Nyy;
    $yz = $Nyz;
    $xo = $Nxo;
    $xx = $Nxx;
    $xy = $Nxy;
    $xz = $Nxz;
    }
    /*
    $xx $yx $zx D
    $xy $yy $zy H
    $xz $yz $zz L
    $xo $yo $zo P

    [0][0] [0][1] C D
    [1][0] [1][1] G H
    [2][0] [2][1] K L
    [3][0] [3][1] O P

    A B C D
    E F G H
    I J K L
    M N O P
    */

    proc MultMATRIX(matrix $rhs[][]) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;

    $lxx = $xx * $rhs[0][0] + $yx * $rhs[1][0] + $zx * $rhs[2][0];
    $lxy = $xy * $rhs[0][0] + $yy * $rhs[1][0] + $zy * $rhs[2][0];
    $lxz = $xz * $rhs[0][0] + $yz * $rhs[1][0] + $zz * $rhs[2][0];
    $lxo = $xo * $rhs[0][0] + $yo * $rhs[1][0] + $zo * $rhs[2][0] + $rhs[3][0];
    $lyx = $xx * $rhs[0][1] + $yx * $rhs[1][1] + $zx * $rhs[2][1];
    $lyy = $xy * $rhs[0][1] + $yy * $rhs[1][1] + $zy * $rhs[2][1];
    $lyz = $xz * $rhs[0][1] + $yz * $rhs[1][1] + $zz * $rhs[2][1];
    $lyo = $xo * $rhs[0][1] + $yo * $rhs[1][1] + $zo * $rhs[2][1] + $rhs[3][1];
    $lzx = $xx * $rhs[0][2] + $yx * $rhs[1][2] + $zx * $rhs[2][2];
    $lzy = $xy * $rhs[0][2] + $yy * $rhs[1][2] + $zy * $rhs[2][2];
    $lzz = $xz * $rhs[0][2] + $yz * $rhs[1][2] + $zz * $rhs[2][2];
    $lzo = $xo * $rhs[0][2] + $yo * $rhs[1][2] + $zo * $rhs[2][2] + $rhs[3][2];
    $xx = $lxx;
    $xy = $lxy;
    $xz = $lxz;
    $xo = $lxo;
    $yx = $lyx;
    $yy = $lyy;
    $yz = $lyz;
    $yo = $lyo;
    $zx = $lzx;
    $zy = $lzy;
    $zz = $lzz;
    $zo = $lzo;
    }

    proc transformMATRIX_A(float $v[], int $tv[], int $nvert) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
    $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
    $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
    for ($i = $nvert * 3; ($i -= 3) >= 0;) {
    $x = $v[$i];
    $y = $v[$i + 1];
    $z = $v[$i + 2];
    $tv[$i    ] = (int) ($x * $lxx + $y * $lxy + $z * $lxz + $lxo);
    $tv[$i + 1] = (int) ($x * $lyx + $y * $lyy + $z * $lyz + $lyo);
    $tv[$i + 2] = (int) ($x * $lzx + $y * $lzy + $z * $lzz + $lzo);
    }
    }
    proc transformMATRIX_B(vector $v[]) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
    $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
    $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
    for ( $i = 0; $i < `size($v)`; $i++) {
    $x = VecCom($v[$i],0);
    $y = VecCom($v[$i],1);
    $z = VecCom($v[$i],2);
    VecEqual($v[$i], 0 , ($x * $lxx + $y * $lxy + $z * $lxz + $lxo));
    VecEqual($v[$i], 0 , ($x * $lyx + $y * $lyy + $z * $lyz + $lyo));
    VecEqual($v[$i], 0 , ($x * $lzx + $y * $lzy + $z * $lzz + $lzo));
    }
    }
    proc transformMATRIX_Vec(vector $p) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
    $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
    $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
    $x = VecCom($p,0);
    $y = VecCom($p,1);
    $z = VecCom($p,2);
    VecEqual($p,0,($x * $lxx + $y * $lxy + $z * $lxz + $lxo));
    VecEqual($p,1,($x * $lyx + $y * $lyy + $z * $lyz + $lyo));
    VecEqual($p,2,($x * $lzx + $y * $lzy + $z * $lzz + $lzo));
    }
    proc string StringtoStringMATRIX() {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    return ("[" + $xx + "," + $xy + "," + $xz + "," + $xo + "\n "
    + $yx + "," + $yy + "," + $yz + "," + $yo + "\n "
    + $zx + "," + $zy + "," + $zz + "," + $zo + "]");
    }




    /*
    global matrix $matrixA_GlobalX[4][4];
    $matrixA_GlobalX  = << $xx, $yx, $zx, 0.0;
    $xy, $yy, $zy, 0.0;
    $xz, $yz, $zz, 0.0;
    $xo, $yo, $zo, 1.0 >>;
    */


    //////////New


    proc SetGMATRIX() {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $Sx, $Sy, $Sz, $So;
    $Mn[0] =$xx;
    $Mn[4] =$xy;
    $Mn[8] =$xz;
    $Mn[12] =$xo;

    $Mn[1] =$yx;
    $Mn[5] =$yy;
    $Mn[9] =$yz;
    $Mn[13]=$yo;

    $Mn[2] =$zx;
    $Mn[6] =$zy;
    $Mn[10]=$zz;
    $Mn[14]=$zo;

    $Mn[3] =$Sx;
    $Mn[7] =$Sy;
    $Mn[11]=$Sz;
    $Mn[15]=$So;
    global matrix $MatrixGlobalA[4][4];
    $MatrixGlobalA=<<$Mn[0], $Mn[1], $Mn[2], $Mn[3];
    $Mn[4], $Mn[5], $Mn[6], $Mn[7];
    $Mn[8], $Mn[9], $Mn[10], $Mn[11];
    $Mn[12], $Mn[13], $Mn[14], $Mn[15]>>;
    }

    proc UnitMATRIX() {

    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $Sx, $Sy, $Sz, $So;
    global matrix $MatrixGlobalA[4][4];
    $MatrixGlobalA=<< 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $Mn  = MatrixToFloat($MatrixGlobalA);

    $xx=$Mn[0];
    $xy=$Mn[4];
    $xz=$Mn[8];
    $xo=$Mn[12];
    $yx=$Mn[1];
    $yy=$Mn[5];
    $yz=$Mn[9];
    $yo=$Mn[13];
    $zx=$Mn[2];
    $zy=$Mn[6];
    $zz=$Mn[10];
    $zo=$Mn[14];

    $Sx=$Mn[3];
    $Sy=$Mn[7];
    $Sz=$Mn[11];
    $So=$Mn[15];

    }


    global matrix $MatrixGlobalA[4][4];
    $MatrixGlobalA =  << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;

    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static = 3.14159265;

    UnitMATRIX;
    $Mng  = MatrixToFloat($MatrixGlobalA);
    PrintMatrix($MatrixGlobalA , 4);

    UnitMATRIX;
    SetGMATRIX;
    $Mn  = MatrixToFloat($MatrixGlobalA);
    ShowMatrixAXIS($Mn);

    UnitMATRIX;
    SetGMATRIX;
    $MatrixC= $MatrixGlobalA;
    $MatrixD= $MatrixGlobalA;

    $item = `ls -sl`;
    select -r $item[0];
    $PositionsZ_A = VecCurveEps($item[0]);
    $Pts_CRV=$PositionsZ_A;
    $theta = 45;

    UnitMATRIX;
    SetGMATRIX;
    $MatrixC= $MatrixGlobalA;
    PrintMatrix($MatrixC , 4);
    $MatrixD= $MatrixGlobalA;
    $MatrixE=$MatrixGlobalA;


    for($Inx = 0; $Inx <= (360/45); $Inx++){
    //$MatrixC= $MatrixGlobalA;
    yrotMATRIX(($theta));
    SetGMATRIX;
    $MatrixD= $MatrixGlobalA;
    $Pts_CRV=MultPointMatrixArray($PositionsZ_A, $MatrixC,$MatrixD);
    $ThefirstCurve = VecArrayToCurve($Pts_CRV);
    $Mn  = MatrixToFloat($MatrixGlobalA);
    ShowMatrixAXIS($Mn);
    $MatrixE=$MatrixD;
    for($Inxi = 0; $Inxi <= (360/45); $Inxi++){
    xrotMATRIX(($theta));
    SetGMATRIX;
    $MatrixD= $MatrixGlobalA;
    $Pts_CRV=MultPointMatrixArray($Pts_CRV, $MatrixE,$MatrixD);
    $ThefirstCurve = VecArrayToCurve($Pts_CRV);
    }
    $MatrixGlobalA=$MatrixE;
    SetGMATRIX;
    }




    PrintMatrix($MatrixC , 4);
    PrintMatrix($MatrixD , 4);

    $item = `ls -sl`;
    $MatrixC= GetMatrix($item[0]);
    PrintMatrix($MatrixC , 4);

    $item = `ls -sl`;
    $MatrixD= GetMatrix($item[0]);
    PrintMatrix($MatrixD , 4);

    $item = `ls -sl`;
    $MatrixE= GetMatrix($item[0]);
    PrintMatrix($MatrixE , 4);

    PrintMatrix($MatrixC , 4);
    PrintMatrix($MatrixD , 4);
    PrintMatrix($MatrixE , 4);









    proc matrix GetMatrix(string $object){
    $attr = $object +".matrix";
    $v = `getAttr $attr`;
    matrix $mat[4][4]= `FloatToMatrix($v)`;
    return $mat;
    }

    proc  PrintMatrix(matrix $MatriXM[][] , int $MatrixN){

    $MatrixNi = $MatrixN-1;
    $FLoatMatrixA = MatrixToFloat($MatriXM);
    $FLoatMatrixA = MakeCleanFloatsZ($FLoatMatrixA);
    $stringFloat = FloatArrayToStringArray($FLoatMatrixA);
    clear $BytNum;
    for ($eachFloatz in $stringFloat){
    $BytNum[`size($BytNum)`] = (`sizeBytes $eachFloatz`)+2;
    }
    $BytNumSort = $BytNum;
    $BytNumSort = `sort $BytNumSort`;
    $BytNumLarg = $BytNumSort[`size($BytNumSort)`-1];
    $BytNumSmall = $BytNumSort[0];
    clear $BytNumDiff;
    for ($eachBytNum in $BytNum){
    $BytNumDiff[`size($BytNumDiff)`] = (`abs ($eachBytNum - $BytNumLarg)`)+2;
    }

    $IndXeF = 0;
    $IndXeFi = 0;
    $Syb = " ";
    $printcommand = "";
    for ($eachItemF in $stringFloat){
    $AddedSPaces = AddItemString($BytNumDiff[$IndXeF], $Syb);
    if($IndXeFi==$MatrixNi){ $printcommand += $AddedSPaces + $eachItemF + "|"+ "\n" ;
    $IndXeFi= -1; }else{ if($IndXeFi==0){$printcommand += "|"+$AddedSPaces + $eachItemF;}else{ $printcommand += $AddedSPaces + $eachItemF;}}
    $IndXeFi++;
    $IndXeF++;
    }
    print $printcommand;
    }

    proc float[] MatrixToFloat(matrix $FourByFour_matrix[][]){
    $FLOATindex = 0;
    $Inx = 0;
    $Inxb = 0;
    for($Inx = 0; $Inx <= 3; $Inx++){
    for($Inxb = 0; $Inxb <= 3; $Inxb++){
    $matrixFloat[$FLOATindex] = $FourByFour_matrix[$Inx][$Inxb];
    $FLOATindex++;
    }
    }
    return $matrixFloat;
    }

    proc string makeCurvePointDirectionLength(float $Length, float $Direction[], float $posA[]){
    $MultDir = multiplyFloat($Length,  $Direction);
    $FloatDirectionNormalA = AddFloats($posA, $MultDir);
    $CurveBetween = curve2points($posA,  $FloatDirectionNormalA);
    return $CurveBetween;
    }

    proc ShowMatrixAXIS(float $Mn[]){
    $curveAxisS[0]= makeCurvePointDirectionLength((6), <<$Mn[0], $Mn[1], $Mn[2]>>, <<$Mn[12], $Mn[13], $Mn[14]>>); //
    $curveAxisS[1]= makeCurvePointDirectionLength((6), <<$Mn[4], $Mn[5], $Mn[6]>>, <<$Mn[12], $Mn[13], $Mn[14]>>); //
    $curveAxisS[2]= makeCurvePointDirectionLength((6), <<$Mn[8], $Mn[9], $Mn[10]>>, <<$Mn[12], $Mn[13], $Mn[14]>>); //
    SetItemColorString ($curveAxisS[0], 13);
    SetItemColorString ($curveAxisS[1], 14);
    SetItemColorString ($curveAxisS[2], 6);
    select -cl  ;
    }

    ///////////////////////////NEW
    /*

    ///////////OLD
    proc UnitMATRIX() {

    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $tx, $ty, $tz, $to;
    global matrix $MatrixGlobalA[4][4];
    $MatrixGlobalA=<< 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $Mn  = MatrixToFloat($MatrixGlobalA);
    $xx =$Mn[0];
    $xy =$Mn[1];
    $xz =$Mn[2];
    $xo =$Mn[3];
    $yx =$Mn[4];
    $yy =$Mn[5];
    $yz =$Mn[6];
    $yo =$Mn[7];
    $zx =$Mn[8];
    $zy =$Mn[9];
    $zz =$Mn[10];
    $zo =$Mn[11];
    $tx =$Mn[12];
    $ty =$Mn[13];
    $tz =$Mn[14];
    $to =$Mn[15];
    }

    proc SetGMATRIX() {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $tx, $ty, $tz, $to;
    $Mn[0]=$xx;
    $Mn[1]=$xy;
    $Mn[2]=$xz;
    $Mn[3]=$xo;
    $Mn[4]=$yx;
    $Mn[5]=$yy;
    $Mn[6]=$yz;
    $Mn[7]=$yo;
    $Mn[8]=$zx;
    $Mn[9]=$zy;
    $Mn[10]=$zz;
    $Mn[11]=$zo;
    $Mn[12]=$tx;
    $Mn[13]=$ty;
    $Mn[14]=$tz;
    $Mn[15]=$to;
    global matrix $MatrixGlobalA[4][4];
    $MatrixGlobalA=<<$Mn[0], $Mn[1], $Mn[2], $Mn[3];
    $Mn[4], $Mn[5], $Mn[6], $Mn[7];
    $Mn[8], $Mn[9], $Mn[10], $Mn[11];
    $Mn[12], $Mn[13], $Mn[14], $Mn[15]>>;
    }


    ////////////////////////////////////////

    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static = 3.14159265;

    proc Matrix3D(){
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $xx = 1.0;
    $yy = 1.0;
    $zz = 1.0;
    }

    proc scaleMATRIX_A(float $f) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $xx *= $f;
    $xy *= $f;
    $xz *= $f;
    $xo *= $f;
    $yx *= $f;
    $yy *= $f;
    $yz *= $f;
    $yo *= $f;
    $zx *= $f;
    $zy *= $f;
    $zz *= $f;
    $zo *= $f;
    }
    proc scaleMATRIX_B(float $xf, float $yf, float $zf) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $xx *= $xf;
    $xy *= $xf;
    $xz *= $xf;
    $xo *= $xf;
    $yx *= $yf;
    $yy *= $yf;
    $yz *= $yf;
    $yo *= $yf;
    $zx *= $zf;
    $zy *= $zf;
    $zz *= $zf;
    $zo *= $zf;
    }
    proc translateMATRIX_float(float $x, float $y, float $z) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $xo += $x;
    $yo += $y;
    $zo += $z;
    }
    ///////////////////////////////////////////
    proc translateMATRIX_VEC(vector $t) {
    translateMATRIX_float((VecCom($t,0)),(VecCom($t,1)),(VecCom($t,2)));
    }

    proc yrotMATRIX(float $theta) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static;

    $theta *= ($PI_Static / 180.0);
    $ct = cos($theta);
    $st = sin($theta);
    $Nxx = (float) ($xx * $ct + $zx * $st);
    $Nxy = (float) ($xy * $ct + $zy * $st);
    $Nxz = (float) ($xz * $ct + $zz * $st);
    $Nxo = (float) ($xo * $ct + $zo * $st);
    $Nzx = (float) ($zx * $ct - $xx * $st);
    $Nzy = (float) ($zy * $ct - $xy * $st);
    $Nzz = (float) ($zz * $ct - $xz * $st);
    $Nzo = (float) ($zo * $ct - $xo * $st);
    $xo = $Nxo;
    $xx = $Nxx;
    $xy = $Nxy;
    $xz = $Nxz;
    $zo = $Nzo;
    $zx = $Nzx;
    $zy = $Nzy;
    $zz = $Nzz;
    }
    proc xrotMATRIX(float $theta) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static;
    $theta *= ($PI_Static / 180.0);
    $ct = cos($theta);
    $st = sin($theta);
    $Nyx = (float) ($yx * $ct + $zx * $st);
    $Nyy = (float) ($yy * $ct + $zy * $st);
    $Nyz = (float) ($yz * $ct + $zz * $st);
    $Nyo = (float) ($yo * $ct + $zo * $st);
    $Nzx = (float) ($zx * $ct - $yx * $st);
    $Nzy = (float) ($zy * $ct - $yy * $st);
    $Nzz = (float) ($zz * $ct - $yz * $st);
    $Nzo = (float) ($zo * $ct - $yo * $st);
    $yo = $Nyo;
    $yx = $Nyx;
    $yy = $Nyy;
    $yz = $Nyz;
    $zo = $Nzo;
    $zx = $Nzx;
    $zy = $Nzy;
    $zz = $Nzz;
    }
    proc zrotMATRIX(float $theta) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    global float $PI_Static;
    $theta *= ($PI_Static / 180.0);
    $ct = cos($theta);
    $st = sin($theta);
    $Nyx = (float) ($yx * $ct + $xx * $st);
    $Nyy = (float) ($yy * $ct + $xy * $st);
    $Nyz = (float) ($yz * $ct + $xz * $st);
    $Nyo = (float) ($yo * $ct + $xo * $st);
    $Nxx = (float) ($xx * $ct - $yx * $st);
    $Nxy = (float) ($xy * $ct - $yy * $st);
    $Nxz = (float) ($xz * $ct - $yz * $st);
    $Nxo = (float) ($xo * $ct - $yo * $st);
    $yo = $Nyo;
    $yx = $Nyx;
    $yy = $Nyy;
    $yz = $Nyz;
    $xo = $Nxo;
    $xx = $Nxx;
    $xy = $Nxy;
    $xz = $Nxz;
    }
    /*
    $xx $yx $zx D
    $xy $yy $zy H
    $xz $yz $zz L
    $xo $yo $zo P

    [0][0] [0][1] C D
    [1][0] [1][1] G H
    [2][0] [2][1] K L
    [3][0] [3][1] O P

    A B C D
    E F G H
    I J K L
    M N O P
    */

    proc MultMATRIX(matrix $rhs[][]) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;

    $lxx = $xx * $rhs[0][0] + $yx * $rhs[1][0] + $zx * $rhs[2][0];
    $lxy = $xy * $rhs[0][0] + $yy * $rhs[1][0] + $zy * $rhs[2][0];
    $lxz = $xz * $rhs[0][0] + $yz * $rhs[1][0] + $zz * $rhs[2][0];
    $lxo = $xo * $rhs[0][0] + $yo * $rhs[1][0] + $zo * $rhs[2][0] + $rhs[3][0];
    $lyx = $xx * $rhs[0][1] + $yx * $rhs[1][1] + $zx * $rhs[2][1];
    $lyy = $xy * $rhs[0][1] + $yy * $rhs[1][1] + $zy * $rhs[2][1];
    $lyz = $xz * $rhs[0][1] + $yz * $rhs[1][1] + $zz * $rhs[2][1];
    $lyo = $xo * $rhs[0][1] + $yo * $rhs[1][1] + $zo * $rhs[2][1] + $rhs[3][1];
    $lzx = $xx * $rhs[0][2] + $yx * $rhs[1][2] + $zx * $rhs[2][2];
    $lzy = $xy * $rhs[0][2] + $yy * $rhs[1][2] + $zy * $rhs[2][2];
    $lzz = $xz * $rhs[0][2] + $yz * $rhs[1][2] + $zz * $rhs[2][2];
    $lzo = $xo * $rhs[0][2] + $yo * $rhs[1][2] + $zo * $rhs[2][2] + $rhs[3][2];
    $xx = $lxx;
    $xy = $lxy;
    $xz = $lxz;
    $xo = $lxo;
    $yx = $lyx;
    $yy = $lyy;
    $yz = $lyz;
    $yo = $lyo;
    $zx = $lzx;
    $zy = $lzy;
    $zz = $lzz;
    $zo = $lzo;
    }
    proc UnitMATRIX() {

    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;

    $xo = 0;
    $xx = 1;
    $xy = 0;
    $xz = 0;
    $yo = 0;
    $yx = 0;
    $yy = 1;
    $yz = 0;
    $zo = 0;
    $zx = 0;
    $zy = 0;
    $zz = 1;
    }
    proc transformMATRIX_A(float $v[], int $tv[], int $nvert) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
    $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
    $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
    for ($i = $nvert * 3; ($i -= 3) >= 0;) {
    $x = $v[$i];
    $y = $v[$i + 1];
    $z = $v[$i + 2];
    $tv[$i    ] = (int) ($x * $lxx + $y * $lxy + $z * $lxz + $lxo);
    $tv[$i + 1] = (int) ($x * $lyx + $y * $lyy + $z * $lyz + $lyo);
    $tv[$i + 2] = (int) ($x * $lzx + $y * $lzy + $z * $lzz + $lzo);
    }
    }
    proc transformMATRIX_B(vector $v[]) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
    $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
    $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
    for ( $i = 0; $i < `size($v)`; $i++) {
    $x = VecCom($v[$i],0);
    $y = VecCom($v[$i],1);
    $z = VecCom($v[$i],2);
    VecEqual($v[$i], 0 , ($x * $lxx + $y * $lxy + $z * $lxz + $lxo));
    VecEqual($v[$i], 0 , ($x * $lyx + $y * $lyy + $z * $lyz + $lyo));
    VecEqual($v[$i], 0 , ($x * $lzx + $y * $lzy + $z * $lzz + $lzo));
    }
    }
    proc transformMATRIX_Vec(vector $p) {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
    $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
    $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
    $x = VecCom($p,0);
    $y = VecCom($p,1);
    $z = VecCom($p,2);
    VecEqual($p,0,($x * $lxx + $y * $lxy + $z * $lxz + $lxo));
    VecEqual($p,1,($x * $lyx + $y * $lyy + $z * $lyz + $lyo));
    VecEqual($p,2,($x * $lzx + $y * $lzy + $z * $lzz + $lzo));
    }
    proc string StringtoStringMATRIX() {
    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    return ("[" + $xx + "," + $xy + "," + $xz + "," + $xo + "\n "
    + $yx + "," + $yy + "," + $yz + "," + $yo + "\n "
    + $zx + "," + $zy + "," + $zz + "," + $zo + "]");
    }



    UnitMATRIX;
    global matrix $matrixA_GlobalX[4][4];
    $matrixA_GlobalX  = << $xx, $yx, $zx, 0.0;
    $xy, $yy, $zy, 0.0;
    $xz, $yz, $zz, 0.0;
    $xo, $yo, $zo, 1.0 >>;
    */
    ///////////////////

    /*

    $selItemzCi = `ls-sl`;
    $PtsVecAi = PointArrayT($selItemzCi);

    $MatrixNewB = GetMatrix($selItemz[1]);
    $MtxF  = MatrixToFloat($MatrixNewB);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};



    print $MatrixNewB;
    $MatrixNewC = GetMatrix($selItemz[2]);

    $NewAXis = MultPointMatrixPlusRel( $PtsVecAi[1], $MatrixNewB,$MatrixNewC);
    Loc $NewAXis;
    */

    proc vector MultPointMatrixPlusRel( vector $PtsVec, matrix $mIA[][],matrix $mIB[][]){
    /*
    Given an input vector (a, b, c) and an input matrix:
    A B C D
    E F G H
    I J K L
    M N O P
    Then Vector Matrix Product is defined as follows:
    x = (a*A) - (b*B) - (c*C)
    y = (a*E) - (b*F) - (c*G)
    z = (a*I) - (b*J) - (c*K)
    And the Point Matrix Product is defined as follows:
    x = (a*A) - (b*B) - (c*C) - D
    y = (a*E) - (b*F) - (c*G) - H
    z = (a*I) - (b*J) - (c*K) - L
    */


    $MtxF  = MatrixToFloat($mIA);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};

    $Pts = $PtsVec;


    // cent of matrix
    $AxisO = $Tran = << $mIA[3][0], $mIA[3][1], $mIA[3][2]>>;
    ////////////////////////////////////////

    $MtxFB  = MatrixToFloat($mIB);
    $RowAi = {$MtxFB[0], $MtxFB[1], $MtxFB[2]};
    $RowBi = {$MtxFB[4], $MtxFB[5], $MtxFB[6]};
    $RowCi = {$MtxFB[8], $MtxFB[9], $MtxFB[10]};

    ////////////////////////////////////////

    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]))*$MtxFB[15];
    $PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]))*$MtxFB[15];
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]))*$MtxFB[15];

    ////////////////////////////////////// YOU GOT IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



    $PtZT[0] = (($RowAi[0])*($PtZ[0])) + (($RowBi[0])*$PtZ[1]) + (($RowCi[0])*$PtZ[2])+$MtxF[3];
    $PtZT[1] = (($RowAi[1])*($PtZ[0])) + (($RowBi[1])*$PtZ[1]) + (($RowCi[1])*$PtZ[2])+$MtxF[7];
    $PtZT[2] = (($RowAi[2])*($PtZ[0])) + (($RowBi[2])*$PtZ[1]) + (($RowCi[2])*$PtZ[2])+$MtxF[11];


    $ReturnValVec = << $PtZT[0], $PtZT[1], $PtZT[2]>>;
    $TranB = << $mIB[3][0], $mIB[3][1], $mIB[3][2]>>;
    $ReturnValVec += $TranB;

    return $ReturnValVec;
    }


    proc vector [] MultPointMatrixArray( vector $Vec_Array[], matrix $mIA[][],matrix $mIB[][]){
    /*
    Given an input vector (a, b, c) and an input matrix:
    A B C D
    E F G H
    I J K L
    M N O P
    Then Vector Matrix Product is defined as follows:
    x = (a*A) - (b*B) - (c*C)
    y = (a*E) - (b*F) - (c*G)
    z = (a*I) - (b*J) - (c*K)
    And the Point Matrix Product is defined as follows:
    x = (a*A) - (b*B) - (c*C) - D
    y = (a*E) - (b*F) - (c*G) - H
    z = (a*I) - (b*J) - (c*K) - L
    */


    $MtxF  = MatrixToFloat($mIA);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};

    // cent of matrix
    $AxisO = $Tran = << $mIA[3][0], $mIA[3][1], $mIA[3][2]>>;
    ////////////////////////////////////////

    $MtxFB  = MatrixToFloat($mIB);
    $RowAi = {$MtxFB[0], $MtxFB[1], $MtxFB[2]};
    $RowBi = {$MtxFB[4], $MtxFB[5], $MtxFB[6]};
    $RowCi = {$MtxFB[8], $MtxFB[9], $MtxFB[10]};
    for ( $ii = 0; $ii < (`size($Vec_Array)` ); $ii++ ){
    $Pts = $Vec_Array[$ii];
    ////////////////////////////////////////
    $PtZ[0] = (($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    $PtZ[1] = (($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    $PtZ[2] = (($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    ////////////////////////////////////// YOU GOT IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    $PtZT[0] = (($RowAi[0])*($PtZ[0])) + (($RowBi[0])*$PtZ[1]) + (($RowCi[0])*$PtZ[2])+$MtxF[3];
    $PtZT[1] = (($RowAi[1])*($PtZ[0])) + (($RowBi[1])*$PtZ[1]) + (($RowCi[1])*$PtZ[2])+$MtxF[7];
    $PtZT[2] = (($RowAi[2])*($PtZ[0])) + (($RowBi[2])*$PtZ[1]) + (($RowCi[2])*$PtZ[2])+$MtxF[11];
    $ReturnValVec = << $PtZT[0], $PtZT[1], $PtZT[2]>>;
    $TranB = << $mIB[3][0], $mIB[3][1], $mIB[3][2]>>;
    $ReturnValVec += $TranB;
    $newVecs[$ii]=$ReturnValVec;
    }
    return $newVecs;
    }


    ///////////////////////////////////////////////////////////////////////////


    proc matrix FloatToMatrixThree(vector $vi[]){
    $v = $vi[0]; float $vb[]= $vi[1]; float $vc[]= $vi[2];
    matrix $mat[3][3]=<<$v[0], $v[1], $v[2];
    $vb[0], $vb[1], $vb[2];
    $vc[0], $vc[1], $vc[2]>>;
    return $mat;
    }

    proc matrix SetRotationVectorsMatrix(matrix $mAtRiX[][], float $MfloatRot[]){
    $MatrizFloatiA = MatrixToFloat($mAtRiX);
    $MatrizFloatiA[0]=$MfloatRot[0];
    $MatrizFloatiA[1]=$MfloatRot[1];
    $MatrizFloatiA[2]=$MfloatRot[2];
    $MatrizFloatiA[4]=$MfloatRot[3];
    $MatrizFloatiA[5]=$MfloatRot[4];
    $MatrizFloatiA[6]=$MfloatRot[5];
    $MatrizFloatiA[8]=$MfloatRot[6];
    $MatrizFloatiA[9]=$MfloatRot[7];
    $MatrizFloatiA[10]=$MfloatRot[8];
    $newRotM = FloatToMatrix($MatrizFloatiA);
    return $newRotM;
    }

    proc float[] MatrixToFloatNN(matrix $FourByFour_matrix[][], int $N){
    $FLOATindex = 0;
    $Inx = 0;
    $Inxb = 0;
    for($Inx = 0; $Inx <= $N; $Inx++){
    for($Inxb = 0; $Inxb <= $N; $Inxb++){
    $matrixFloat[$FLOATindex] = $FourByFour_matrix[$Inx][$Inxb];
    $FLOATindex++;
    }
    }
    return $matrixFloat;
    }

    proc matrix MatrixToFloatN(vector $Vec_matrix[]){

    //eval("\matrix $N_matrix["+$X+"\]["+$X+"\]");
    $FLOATindex = 0;
    $Inx = 0;
    $Inxb = 0;
    $Xi = 3-1;
    for($Inx = 0; $Inx <= $Xi; $Inx++){
    for($Inxb = 0; $Inxb <= $Xi; $Inxb++){
    $N_matrix[$Inx][$Inxb]=$Vec_matrix[$FLOATindex];
    $FLOATindex++;
    }
    }
    return $N_matrix;
    }



    $CurveItemZ = `ls -sl`;
    PointCurvesToPlaneCurve($CurveItemZ);

    $LocZ_Pts = `ls -sl`;
    $VPos_MC = PointArrayT(`ls -sl`);
    $PlaneLocZ = VecPointsToCameraPlane($VPos_MC);
    for($EachVec in  $PlaneLocZ){
    $planeLocs[`size($planeLocs)`] = `Loc $EachVec`;

    }

    $CurveItemZ = `ls -sl`;
    PointCurvesToPlaneCurveB($CurveItemZ);

    //select cam and points



    $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM`;
    $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM`;



    ////////////////////////////////////////////////////////START


    $PtsVecA = PointArrayT(`ls -sl`);

    $PtsVecAX = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[1], $PtsVecA[2], $PtsVecA[3]));
    //Loc $PtsVecAX;
    $PtsVecAY = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[3], $PtsVecA[1], $PtsVecA[2]));
    //Loc $PtsVecAY;
    $PtsVecCross = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[2], $PtsVecA[1], $PtsVecA[3]));
    //Loc $PtsVecCross;
    $Xcross = $PtsVecCross;
    Loc $Xcross;
    $XcrossP = {$Xcross[0],$Xcross[1],1.0};
    $Normal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);



    $DirLineCamXepip = DirectionFN( $PtsVecAX,$Cam_Trans);
    $Nvec = ($DirLineCamXepip*2.0)+$PtsVecAX;
    Loc $Nvec;
    $Line[0]=$Nvec;
    $Line[1]=$DirLineCamXepip;
    $PtsM_A = VecPointsMirrorVecPlaneN($PtsVecA,$Line);
    $CamM_B = VecPointsMirrorVecPlaneN({$Cam_Trans},$Line);


    $SQuarePts[0] = FloatToVec (lineIntersectionF($Cam_Trans, $PtsVecA[0], $CamM_B[0], $PtsM_A[1]));
    $SQuarePts[1] = FloatToVec (lineIntersectionF($Cam_Trans, $PtsVecA[1], $CamM_B[0], $PtsM_A[0]));
    $SQuarePts[2] = FloatToVec (lineIntersectionF($Cam_Trans, $PtsVecA[2], $CamM_B[0], $PtsM_A[3]));
    $SQuarePts[3] = FloatToVec (lineIntersectionF($Cam_Trans, $PtsVecA[3], $CamM_B[0], $PtsM_A[2]));
    $pointMakeS[0] = ClosestPoint2LineVec(DirectionFN($SQuarePts[2],$SQuarePts[3]), $SQuarePts[2], $SQuarePts[0]);
    $pointMakeS[1] = ClosestPoint2LineVec(DirectionFN($SQuarePts[2],$SQuarePts[3]), $SQuarePts[2], $SQuarePts[1]);
    Loc  $pointMakeS[0];
    Loc  $pointMakeS[1];
    Loc $SQuarePts[1];

    $DirNorA = Normal3Points($SQuarePts[0],  $pointMakeS[0], $pointMakeS[1]);
    $PtsFCrossBB = (lineIntersectionF($SQuarePts[0], $pointMakeS[1], $SQuarePts[1], $pointMakeS[0]));

    //PositiveDirectionLine

    Loc $PtsVecCrossBB;

    $Yaxis = PositiveDirectionLine($SQuarePts[1],$pointMakeS[1]);
    $Xaxis = crossProduct( $Yaxis, $DirNorA, 0, 0 );

    $NormZ = $DirNorA ;
    $DirVector[0]= << $Xaxis[0], $Xaxis[1], $Xaxis[2]>>;
    $DirVector[1]= << $Yaxis[0], $Yaxis[1], $Yaxis[2]>>;
    $DirVector[2]= << $NormZ[0], $NormZ[1], $NormZ[2]>>;

    $matrixIMAGE  = << $Xaxis[0], $Xaxis[1], $Xaxis[2], 0.0;
    $Yaxis[0], $Yaxis[1], $Yaxis[2], 0.0;
    $NormZ[0], $NormZ[1], $NormZ[2], 0.0;
    $PtsFCrossBB[0], $PtsFCrossBB[0], $PtsFCrossBB[0], 1.0 >>;





    MakeMatrixAxis($DirVector,FloatToVec($PtsFCrossBB));

    matrix $mIA[4][4] = $matrixIMAGE;
    $PtsVec = $Cam_Trans;
    matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    matrix $mIB[4][4] = $mI;

    $PtsVecTemp = PointArrayT(`ls -sl`);

    for($eachVec in $PtsVecTemp){
    $CrvN[`size($CrvN)`] = MultPointMatrixPlusRel( $eachVec, $matrixIMAGE ,$mI);
    }
    $ThefirstCurve = VecArrayToCurve($CrvN);



    proc vector MultPointMatrixPlusRel( vector $PtsVec, matrix $mIA[][],matrix $mIB[][]){


    $MtxF  = MatrixToFloat($mIA);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};

    $Pts = $PtsVec;

    // cent of matrix
    $AxisO = $Tran = << $mIA[3][0], $mIA[3][1], $mIA[3][2]>>;
    ////////////////////////////////////////

    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));

    //Loc $PtZ;

    ////////////////////////////////////// YOU GOT IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    $MtxFB  = MatrixToFloat($mIB);
    $RowAi = {$MtxFB[0], $MtxFB[1], $MtxFB[2]};
    $RowBi = {$MtxFB[4], $MtxFB[5], $MtxFB[6]};
    $RowCi = {$MtxFB[8], $MtxFB[9], $MtxFB[10]};

    $PtZT[0] = (($RowAi[0])*($PtZ[0])) + (($RowBi[0])*$PtZ[1]) + (($RowCi[0])*$PtZ[2])+$MtxF[3];
    $PtZT[1] = (($RowAi[1])*($PtZ[0])) + (($RowBi[1])*$PtZ[1]) + (($RowCi[1])*$PtZ[2])+$MtxF[7];
    $PtZT[2] = (($RowAi[2])*($PtZ[0])) + (($RowBi[2])*$PtZ[1]) + (($RowCi[2])*$PtZ[2])+$MtxF[11];

    $ReturnValVec = << $PtZT[0], $PtZT[1], $PtZT[2]>>;
    $TranB = << $mIB[3][0], $mIB[3][1], $mIB[3][2]>>;
    $ReturnValVec += $TranB;

    //Loc $PtZT;

    return $ReturnValVec;
    }






    proc MakeMatrixAxis(vector $DirectionVector[],vector $MidPt){
    $norm = $DirectionVector[0];
    $bi = $DirectionVector[1];
    $tan = $DirectionVector[2];

    // "Xn", "X", "Y", "Yn", "Zn", "Z"

    $colori[`size($colori)`] = 13;
    $colori[`size($colori)`] = 14;
    $colori[`size($colori)`] = 6;

    $curveAxis = "";
    $curveAxis += makeCurvePointDirectionLength((6), $norm, $MidPt); //
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[0]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    $curveAxis += makeCurvePointDirectionLength((6), $bi, $MidPt); //
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[1]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    $curveAxis += makeCurvePointDirectionLength((6), $tan, $MidPt); //
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[2]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    }




    proc float VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){
    $p = $VecN[0];
    $n1 = $VecN[1];
    $F = $n1;
    $e = $V;
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    return $D1;
    }

    $CRV_Item = `ls -sl`;
    $AllLocPositionsZi = VecCurveCvs( $CRV_Item[0]);

    $AXIS_XZY[0]=<<0,0,1>>;
    $AXIS_XZY[1]=<<1,0,0>>;

    $COUNT = 0;
    clear $Find;
    clear $AllF;
    for($EachV in $AllLocPositionsZi){

    $AllF[$COUNT]=VecPointsMirrorVecPlaneN({$EachV},$AXIS_XZY);
    //print ($AllF[$COUNT]+"\n");
    if($AllF[$COUNT]<0.25){
    //print ("  #######HERE###### "+"\n");
    $Find[`size($Find)`]=$COUNT;
    }

    $COUNT++;
    }

    for($EachINT in $Find){
    Loc ($AllLocPositionsZi[$EachINT]);
    }



    proc float VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){
    $p = $VecN[0];
    $n1 = $VecN[1];
    $F = $n1;
    $e = $V[0];
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    return $D1;
    }





    proc vector [] VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){
    $p = $VecN[0];
    $n1 = $VecN[1];
    $F = $n1;
    $C1=0;
    for($e in $V){
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    print $D1;
    $F4 = $e+(($D1*2.0)*$F3);
    $O[$C1] = $F4;
    $C1++;
    }
    VecArrayToCurveB($O);
    ResetTransEachSL;

    return $O;
    }

    $AXIS_XZY[0]=<<0,0,0>>;
    $AXIS_XZY[1]=<<1,0,0>>;
    $MMVEC = VecPointsMirrorVecPlaneN($PtsVec,$AXIS_XZY);
    Loc $MMVEC[0];
    $CURVE[0]= curve2points( $MMVEC[0], $PtsVec[0]);

    print $PtsVec;





    $PtsVec = PointArrayT(`ls -sl`);

    $AXIS_XZY[0]=<<1,0,0>>;
    $AXIS_XZY[1]=<<0,1,0>>;
    $AXIS_XZY[2]=<<0,0,1>>;

    PointDistance_Plane( $PtsVec[0], $AXIS_XZY,<<1,0,9>>);


    proc float PointDistance_Plane( vector $Vec_Array, vector $AXIS_XZY[],vector $midpoint){

    $RowA = $AXIS_XZY[0];
    $RowB = $AXIS_XZY[1];
    $RowC = $AXIS_XZY[2];
    // cent of matrix
    $AxisO = $Tran = $midpoint;
    ////////////////////////////////////////
    $Pts = $Vec_Array;
    ////////////////////////////////////////
    $PtZ[0] = (($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2])));
    $PtZ[1] = (($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2])));
    $PtZ[2] = (($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2])));

    $PlaneP = <<$PtZ[0],$PtZ[1],$PtZ[2]>>;
    $DISTANCE = distance2Pts($Vec_Array, $PlaneP);

    $CURVE[0]= curve2points($Vec_Array, $PlaneP);
    $ARCL = `arclen $CURVE[0] `;
    print $ARCL;

    return  $DISTANCE;
    }





    $DirLineN = << 0.0, 0.0 , 1.0 >>;
    $DirLineX = << 1.0, 0.0 , 0.0 >>;
    $DirLineY = << 0.0, 1.0 , 0.0 >>;


    $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM`;
    $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM`;

    $DirLineCamTOx = DirectionFN($XcrossP,$PtsVecAX);
    $DirLineCamTOy = DirectionFN($XcrossP,$PtsVecAY);

    //vector $DirLineCamTOx = DirectionFN($PtsVecAX, $Cam_Trans);
    //vector $DirLineCamTOy = DirectionFN($PtsVecAY, $Cam_Trans);


    $AngleA = `angle $DirLineX $DirLineCamTOx`;
    $AngleADegreeX = `rad_to_deg $AngleA`;

    $AngleB = `angle $DirLineN $DirLineCamTOy`;
    $AngleADegreeY = (`rad_to_deg $AngleB`-90.0);

    // Result: 45 //
    // Result: -33.778758 //








    $PtsVecA = PointArrayT(`ls -sl`);

    $PtsVecAX = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[1], $PtsVecA[2], $PtsVecA[3]));
    //Loc $PtsVecAX;
    $PtsVecAY = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[3], $PtsVecA[1], $PtsVecA[2]));
    //Loc $PtsVecAY;
    $PtsVecCross = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[2], $PtsVecA[1], $PtsVecA[3]));
    Loc $PtsVecCross;
    $Xcross = $PtsVecCross;
    $XcrossP = {$Xcross[0],$Xcross[1],1.0};
    $Normal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM1", 0);

    $DirLineN = << 0.0, 0.0 , 1.0 >>;
    $DirLineX = << 1.0, 0.0 , 0.0 >>;
    $DirLineY = << 0.0, 1.0 , 0.0 >>;



    $DirLineCamTOx = DirectionFN($Xcross,$PtsVecAX);
    $DirLineCamTOy = DirectionFN($Xcross,$PtsVecAY);

    //vector $DirLineCamTOx = DirectionFN($PtsVecAX, $Cam_Trans);
    //vector $DirLineCamTOy = DirectionFN($PtsVecAY, $Cam_Trans);


    $AngleA = `angle $DirLineX $DirLineCamTOx`;
    $AngleADegreeX = `rad_to_deg $AngleA`;

    $AngleB = `angle $DirLineN $DirLineCamTOy`;
    $AngleADegreeY = (`rad_to_deg $AngleB`-90.0);

    $FOUNDZ = 135.000001 -45.0;



    $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM1`;
    $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM1`;


    /*


    $DirLineCamTOy = DirectionFN($PtsVecAY, $Cam_Trans);
    // Result: <<5.16314e-010, -0.831191, -0.555988>>  //
    $AngleA = `angle $DirLineX $DirLineCamTOx`;
    $AngleADegreeX = `rad_to_deg $AngleA`;
    // Result: 135.000001 //
    $AngleB = `angle $DirLineN $DirLineCamTOy`;
    $AngleADegreeY = (`rad_to_deg $AngleB`-90.0);
    // Result: 33.77876 //
    $FOUNDZ = 135.000001 -45.0;
    // Result: 90.000001 //

    */










    setAttr "ZCURVEModelingCAM.rotate" $AngleADegreeY $AngleADegreeX 0;

    print $AngleADegreeX $AngleADegreeX



    $CamMatrixX = GetMatrix("ZCURVEModelingCAM");
    // Result: << 0.372095 0 -0.928195 0;  -0.492072 0.847911 -0.197262 0;  0.787026 0.530139 0.315504 0;  0 0 1 1 >> //


    $CamMfloatZ[0] = $CamMatrixX[0][0];
    $CamMfloatZ[1] = $CamMatrixX[0][1];
    $CamMfloatZ[2] = $CamMatrixX[0][2];

    $PtsVecAX = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[1], $PtsVecA[2], $PtsVecA[3]));
    Loc $PtsVecAX;
    $PtsVecAY = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[3], $PtsVecA[1], $PtsVecA[2]));
    Loc $PtsVecAY;
    $PtsVecCross = FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[2], $PtsVecA[1], $PtsVecA[3]));
    Loc $PtsVecCross;
    $Xcross = $PtsVecCross;
    $XcrossP = {$Xcross[0],$Xcross[1],1.0};
    $Normal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);

    $DirLineCamTOx = DirectionFN($XcrossP,$PtsVecAX);

    $DirLineN = << 0.0, 0.0 , 1.0 >>;
    $DirLineX = << 1.0, 0.0 , 0.0 >>;
    $DirLineY = << 0.0, 1.0 , 0.0 >>;


    $DirLineCamTOx = DirectionFN($XcrossP,$PtsVecAX);
    $DirLineCamTOy = DirectionFN($XcrossP,$PtsVecAY);



    $CamMatrixXt = GetMatrix("ZCURVEModelingCAM3");

    -32.014843
    68.15511
    0

    yrotMATRIX(68.15511);
    xrotMATRIX(-32.014843);


    PrintMatrix($CamMatrixXt,4);
    |  1  0  0  0|
    |  0  1  0  0|
    |  0  0  1  0|
    |  0  0  1  1|
    PrintMatrix($CamMatrixX,4);
    |   0.3720951716              0  -0.9281945826              0|
    |  -0.4920720897   0.8479107896  -0.1972621389              0|
    |   0.7870262015   0.5301389373   0.3155035108              0|
    |              0              0              1              1|

    StringtoStringMATRIX;

    MultMATRIX($CamMatrixX);

    vector [] GetRotationVectorsMatrix(


    TransformRelByMatrixXform($CamMatrixX, "ZCURVEModelingCAM3");


    //TransformItemByMatrixXform($CamMatrixX, "ZCURVEModelingCAM3");


    $matrixA_GlobalX  = << $xx, $yx, $zx, 0.0;
    $xy, $yy, $zy, 0.0;
    $xz, $yz, $zz, 0.0;
    $xo, $yo, $zo, 1.0 >>;
    PrintMatrix($matrixA_GlobalX,4);

    UnitMATRIX;



    TransformRelByMatrixXform( $matrixA_GlobalX, "ZCURVEModelingCAM3");




    $FirstTrans = $VrotatsFIRST;
    $FirstRot = $VrotatsFIRST;
    setAttr "ZCURVEModelingCAM.translate" $FirstTrans[0] $FirstTrans[1] $FirstTrans[2];
    setAttr "ZCURVEModelingCAM.rotate" 0 $FirstRot 0;




    $DirLineAX = DirectionFN($PtsVecAX, $PtsVecCross);
    $DirLineAY = DirectionFN($PtsVecAY, $PtsVecCross);
    $Zero = << 0.0, 0.0 , 0.0 >>;
    $DirLineX = << -1.0, 0.0 , 0.0 >>;
    $DirLineY = << 0.0, -1.0 , 0.0 >>;
    $DirLineYp = << 0.0, 1.0 , 0.0 >>;
    $AngleAX = `angle  $DirLineAX $DirLineX`;
    $AngleADegreeX = `rad_to_deg $AngleAX`;

    $AngleAY = `angle  $DirLineAY $DirLineY`;
    $AngleADegreeY = `rad_to_deg $AngleAY`;

    $FirstTrans = $VrotatsFIRST;
    $FirstRot = $VrotatsFIRST;
    setAttr "ZCURVEModelingCAM.translate" $FirstTrans[0] $FirstTrans[1] $FirstTrans[2];
    setAttr "ZCURVEModelingCAM.rotate" 0 $FirstRot 0;

    $DirLineN = << 0.0, 0.0 , 1.0 >>;
    $DirLineX = << 1.0, 0.0 , 0.0 >>;
    $DirLineY = << 0.0, 1.0 , 0.0 >>;



    $VPos_MC[0]= $VecCurEndsa[0];  $VPos_MC[1]= $VecCurEndsa[1];
    $VPos_MC[2]= $VecCurEndsb[0];  $VPos_MC[3]= $VecCurEndsb[1];
    $DirLineY = DirectionFN($VPos_MC[0], $VPos_MC[1]);
    $DirLineYR = DirectionFN($VPos_MC[2], $VPos_MC[3]);
    $AngleA = `angle $DirLineY $DirLineYR`;
    $AngleADegree = `rad_to_deg $AngleA`;




    proc vector [] VecPointsToCameraPlaneB(vector $V[]){
    $p = `xform -q -ws -t "LiveSurfaceB1"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM1`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM1", 0);
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+($D1*$F3);
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    return $O;
    }
    proc string [] PointCurvesToPlaneCurveB(string $CurveItemZ[]){
    $CN = 0;
    for ($eachCurve in $CurveItemZ){
    clear $AllLocPositionsZ;
    $AllLocPositionsZ = VecCurveEps( $eachCurve );
    $AllPlaneLocPositionZ = VecPointsToCameraPlaneB($AllLocPositionsZ);
    $newPlaneCurve[$CN] = VecArrayToCurve($AllPlaneLocPositionZ);
    ResetTranslation({$newPlaneCurve[$CN]});
    $CN++;
    }
    return $newPlaneCurve;

    }





    vector [] GetRotationVectorsMatrix(


    TransformRelByMatrixXform(matrix $m[][], string $item)
    TransformItemByMatrixXform(matrix $m[][], string $item)



    matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;

    global matrix $matrixA_GlobalX[4][4];
    $matrixA_GlobalX = << $xx, $yx, $zx, 0.0;
    $xy, $yy, $zy, 0.0;
    $xz, $yz, $zz, 0.0;
    $xo, $yo, $zo, 1.0 >>;







    //geneticEngine.mel by Martin Hemberg 2004

    //This is a genetic engine, ie a simple genetic algorithm for
    //evolutionary search implemented in MEL. In order to make it useful,
    //one must define a fitness function.

    //Some global variables. Unfortunately, matrix sizes can not be set
    //dynamically in MEL. Moreover, one can't declare constants. Thus I'm
    //using this method, I think it's marginally better than not having
    //them. Thus, we are stuck with a fixed size, if you want to change pop
    //size or length, change these numbers and do a search and replace on
    //the rest of the file



    global int $gGenomeLength = 100;
    global int $gPopulationSize = 50;
    global int $gMaxGeneValue = 42; //For a limit when generating random numbers, you may need to adjust this depending on your problem.

    evolve(125, 19, 55, 25.9);

    $ABCs = "abcdefghijklmnopqrstuvwxyz";
    $LETTERS = ArrayFromAllinString($ABCs);
    $Find = "hellojohn";
    $SizeF = `sizeBytes  $Find `;
    $SizeABCs = `sizeBytes  $ABCs `;

    global int $gGenomeLength = 9;
    global int $gPopulationSize = 50;
    global int $gMaxGeneValue =26;
    global matrix $genomes[50][9];
    $genomes = `initializePopulation`;

    print $genomes

    $GENOME_LETTERS = "";
    $j=1;
    for($i=0; $i<$gGenomeLength; $i++){
    $GENOME_LETTERS+= $LETTERS[int($genomes[$j][$i])];
    gmatch $GENOME_LETTERS  $Find;
    print ($GENOME_LETTERS+"\n");
    }

    gmatch "zza" "abc";


    $Find = "hellojohn";

    $FindN = "012";
    sizeBytes(` match "[l-l]" "hellojohn"`)

    match "[a-d]+" "acbdefg" "


    //This function creates a population of individuals with random gene values.


    proc matrix initializePopulation()
    {
    global int $gPopulationSize;
    global int $gGenomeLength;
    global int $gMaxGeneValue;
    global matrix $genomes[50][9];
    //Set each gene to a random value
    for($i=0; $i<$gPopulationSize; $i++){
    for($j=0; $j<$gGenomeLength; $j++)
    $genomes[$i][$j] = int(rand ($gMaxGeneValue));
    }
    return $genomes;
    }



    //This function is used to evaluate the fitness of the population. It
    //contains a large gap - you'll have to insert your own fitness function
    //that maps the array of doubles (the genome) to a scalar value (the
    //fitness). The fitness should be set so that a low value indicates a fit
    //individual.
    proc float[] evaluate(matrix $genomes)
    {
    global int $gPopulationSize;
    for($i=0; $i<$gPopulationSize; $i++){
    //Here each individual should be evaluated

    $fitness[$i] =
    }
    return $fitness;
    }



    proc evolve(int $generations, int $elites, int $tournamentSize, float $mutationRate)
    {
    //Call this function in order to do an evolutionary run for a
    //fixed number of generations. Unfortunately, there is no way to
    //continue running with the same population. However, that should not be
    //to hard to fix. It's just a matter of saving the variables in the
    //scene adn writing a function for reading them again at re-start.
    global matrix $genomes[50][9];
    matrix $genomes[50][9] = initializePopulation(); //[popsize][geneomelength] Each row represents an individual
    //Iterate through the generations
    for($i=0; $i<$generations; $i++){
    $fitness = evaluate($genomes); //Find out who's best
    $genomes = breed($genomes, $fitness, $elites, $tournamentSize, $mutationRate); //Create the population for the next generation
    }
    }




    //This function is used to create the population for the next generation
    proc matrix breed(matrix $genomes, float $fitness[], int $elites, int $tournamentSize, float $mutationRate)
    {
    global int $gPopulationSize;
    global int $gGenomeLength;
    $lowest = -1;
    //Copy the elites to the new generation, they will automatically be the first individuals in the new generation.
    for($i=0; $i<$elites; $i++){
    $lowest = findLowestFitness($fitness, $lowest);
    for($j=0; $j<$gGenomeLength; $j++)
    $newGenomes[$i][$j] = $genomes[$lowest][$j];
    }
    //Create the rest through tournament selection
    for($i=$elites; $i<$gPopulationSize; $i++){
    $father = tournamentSelect($fitness, $tournamentSize);
    $mother = tournamentSelect($fitness, $tournamentSize);
    $newGenomes = crossover($genomes, $newGenomes, $father, $mother, $i);
    }
    return mutate($newGenomes, $elites, $mutationRate);
    }

    //Returns the index of the individual with the lowest fitness above the one indicated by the argument $lowest.
    //If $lowest==-1, return the global minimum
    proc int findLowestFitness(float $fitness[], int $lowest)
    {
    $indexFitness = 100000;
    $lowestFitness = $fitness[$lowest];
    for($i=0; $i<size($fitness); $i++){
    if($fitness[$i]<$indexFitness && $fitness[$i]>=$lowestFitness && $i>$lowest){
    $index = $i;
    $indexFitness = $fitness[$i];
    }
    }
    return $index;
    }

    //Choose a parent using tournament selection. $tournamentSize
    //individuals are randomly chosen from the population. The best one of
    //these is then used as one of the parents for a member of the next
    //generation. A high value of $tournamentSize (compared to the pop size)
    //means that there will be less variation since the fittest individuals
    //are more likely to be picked in every tournament.

    proc int tournamentSelect(float $fitness[], int $tournamentSize) {
    global int $gPopulationSize;
    $parent = (int)rand ($gPopulationSize), $i, $tmp;
    for($i=1; $i<$tournamentSize; $i++){
    $tmp = (int)rand ($gPopulationSize);
    if($fitness[$tmp]<$fitness[$parent]) //Fitness minimization
    $parent = $tmp;
    }
    return $parent;
    }


    //Combine to individuals to produce a new one for the next generation.
    proc matrix crossover(matrix $genomes, matrix $newGenomes, int $father, int $mother, int $child)
    {
    global int $gGenomeLength;
    $i = (int)rand ($gGenomeLength);
    for($i=0; $i<$crossoverPoint; $i++)
    $newGenomes[$child][$i] = $genomes[$father][$i];
    for($i=$crossoverPoint; $i<$gGenomeLength; $i++)
    $newGenomes[$child][$i] = $genomes[$mother][$i];
    return $newGenomes;
    }

    //Random mutation
    proc matrix mutate(matrix $newGenomes, int $elites, float $mutationRate)
    {
    global int $gPopulationSize;
    global int $gGenomeLength;
    for($i=$elites; $i<$gPopulationSize; $i++){ //Don't mutate the elites
    for($j=0; $j<$gGenomeLength; $j++){
    if($mutationRate>`rand 100.0`){ //Mutate
    if(`rand 2.0`>1.0)
    $newGenomes[$i][$j] = $newGenomes[$i][$j] + 1;
    else
    $newGenomes[$i][$j] = $newGenomes[$i][$j] - 1;
    }
    }
    }
    return $newGenomes;
    }




    proc float roundoff( float $f, int $n )
    {
    // we divide if n < 0 to avoid numeric
    // precision problems
    if( $n > 0 )
    {
    $roundScale = pow(10,$n);
    if( $f > 0 )
    return( ((float)(int)($f * $roundScale + 0.5)) /$roundScale );
    else
    return( ((float)(int)($f * $roundScale - 0.5)) /$roundScale );
    }
    else
    {
    $roundScale = pow(10,-$n);
    if( $f > 0 )
    return( ((float)(int)($f/$roundScale + 0.5)) *$roundScale );
    else
    return( ((float)(int)($f/$roundScale - 0.5)) *$roundScale );

    }
    }
















    //////////








    clear $MasterLineN;


    $CurrentLineN = $CurrentLineNF;
    clear $CollectL;
    clear $CAL_temp;
    clear $LN_temp;
    $CAL_temp =$CollectAllLines;
    $LN_temp =$LineNumber;
    clear $NegPosZA;
    $WhenZero = 2;
    $CountNL = 1;
    $CountFindNL = 0;
    $START = 0;
    $TriggerLineFound = 0;
    clear $CurrentLineNX;
    clear $tempCollectProc;

    $Aint = size($CollectAllLines);
    $Bint = size($AllFoundProcs);
    $Cint = size($CAL_temp);
    $CHECK = $Aint-$Cint ;

    //int $fileId =`fopen $exampleFileName "r"`;
    //string $nextLine = `fgetline $fileId`;
    //int $eachInt = $CurrentLineN[0];
    clear $tempCollectProc;
    clear $AllFoundProcs;

    $TRIGGEREND = 2;

    $fileId = `fopen $exampleFileName "r"`;


    while($TRIGGEREND>1){



    ///////////////////////////
    ///////////////////////////




    for($eachInt in $CurrentLineN){


    //this is the number that is the first line of a group of lines that are a proc


    $WhenZero=2;
    $CountNL = 1;
    $CountFindNL = 0;
    $START = 0;
    $TriggerLineFound=0;



    ///////////////////////////////////////////////////////////////////

    while ( !`feof $fileId` ) {


    $nextLine = `fgetline $fileId`;
    $nextLineN = match( "^[^(\r\n)]*", $nextLine );

    //FOUND LINE NUMBER
    //CHANGE HERE

    if($CurrentLineN[$CountFindNL] == $CountNL){
    clear $NegPosZA;
    $CountFindNL++;
    $TriggerLineFound=1;
    }



    if($TriggerLineFound==1){
    $WhenZero = BracketFindPosNeg($nextLine, $NegPosZA);
    $START++;
    $CollectL[`size($CollectL)`]= $nextLineN;



    /// WHEN PROC IS FULLY SCANNED HERE BELOW

    if(($WhenZero==0)&&($START>1)){



    $START=$TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
    // $CAL_temp IS $CollectAllLines;  MATCH NAMES//
    if(`size($CAL_temp)`==0){break;}
    $FoundProcTemp =RuleBasedMatchM($IndexX,$CAL_temp, $CollectL);
    // $LN_temp =$LineNumber;
    if(`size($IndexX)`>0){

    $IndexX = sort($IndexX);
    for($i=0; $i<`size($IndexX)`; $i++){
    $CurrentLineNX[`size($CurrentLineNX)`] =$LN_temp[$IndexX[$i]];
    }



    $CAL_temp=RemoveStringAtIndex($CAL_temp,$IndexX);
    $LN_temp = RemoveIntAtIndex($LN_temp,$IndexX);

    clear $IndexX;
    /////////////

    }

    $tempCollectProc =AppendArrayZ($tempCollectProc, $FoundProcTemp);

    clear $FoundProcTemp;
    /////////////////////




    }
    }
    //LINE NUMBER
    $CountNL++;

    }

    ///////////////////////////////////////////////////////////////////


    frewind $fileId;



    }


    ///////////////////////////
    ///////////////////////////


    $tempCollectProc= stringArrayRemoveDuplicates($tempCollectProc);
    AppendArrayZ($AllFoundProcs,$tempCollectProc);

    $TempStringP = "";
    $TempStringP = stringArrayToString($tempCollectProc, ", ");
    print ($TempStringP+"\n");
    $WholeProc[`size($WholeProc)`]=$TempStringP;

    clear $tempCollectProc;
    //////////////////////


    $list = IntArrayToStringArray($CurrentLineNX);
    $list= stringArrayRemoveDuplicates($list);

    clear $CurrentLineN;
    $CurrentLineN=StringArrayToIntArray($list);
    $CurrentLineN =sort ($CurrentLineN);

    clear $CurrentLineNX;
    //////////////////////

    clear $tempCollectProc;
    //////////////////////

    if(`size($CurrentLineN)`>0){
    for($i=0; $i<`size($CurrentLineN)`; $i++){
    $MasterLineN[`size($MasterLineN)`] =$CurrentLineN[$i];
    }
    }


    if($CurrentLineN[0]==0){
    print "STOPSTOP";
    $TRIGGEREND =0;
    break;
    }

    if(`size($CurrentLineN)`==0){
    print "STOPSTOP";
    $TRIGGEREND =0;
    break;
    }



    }

    print $WholeProc;




    ////////
    /////////////START OF AUTOMATIC SCENE SETUP for STEREOSCRIPTS######################################
    /////////////START OF AUTOMATIC SCENE SETUP for STEREOSCRIPTS######################################
    /*




    global vector $ObjCurv[];
    //print  $GlobalObjListA[46];
    global vector $ObjVec[];
    global string $GlobalObjListA[];
    global string $GlobalObjOne[];
    $ConnectionSet1 = `sets -name ExistingCurveZSet`;
    $ConnectionSet2 = `sets -name CurveZSetOne`;
    clear $ObjCurv;
    clear $GlobalObjListA;
    clear $GlobalObjOne;
    clear $ObjVec;

    global int $ifSingleCurve;
    $ifSingleCurve =0;
    createDisplayLayer -name "VanishingPointsLines"  -empty;
    setAttr VanishingPointsLines.visibility 1; setAttr VanishingPointsLines.displayType 0; setAttr VanishingPointsLines.color 0;


    if ( `objExists NurbsPlanes` == 0  ) {
    createDisplayLayer -name "NurbsPlanes" - number 1 -empty;
    setAttr NurbsPlanes.color 30;
    }
    if ( `objExists IntersectFormLayer` == 0  ) {
    createDisplayLayer -name "IntersectFormLayer" - number 1 -empty;
    setAttr IntersectFormLayer.color 30;
    }
    if ( `objExists IntersectFormLayerOutofRange` ==  0  ) {
    createDisplayLayer -name  "IntersectFormLayerOutofRange" -number 1 -empty;
    setAttr IntersectFormLayerOutofRange.color 2;
    }
    if ( `objExists IntersectFormLayerINRange` == 0   ) {
    createDisplayLayer -name  "IntersectFormLayerINRange" -number 1 -empty;
    setAttr IntersectFormLayerINRange.color 3;
    }
    if ( `objExists layerYZYXPlains` == 0  ) {
    createDisplayLayer -name "layerYZYXPlains" - number 1 -empty;
    }
    if ( `objExists layerAllCurves1` == 0  ) {
    createDisplayLayer -name "layerAllCurves1" - number 1 -empty;
    }
    if ( `objExists layerEdgeCurveZ1` == 0  ) {
    createDisplayLayer -name "layerEdgeCurveZ1" - number 1 -empty;
    }
    if ( `objExists layerCurvesOutofRange1` == 0  ) {
    createDisplayLayer -name "layerCurvesOutofRange1"  -number 1 -empty;
    setAttr layerCurvesOutofRange1.color 12;
    }
    if ( `objExists layerCurvesINRange1` == 0  ) {
    createDisplayLayer -name "layerCurvesINRange1" - number 1 -empty;
    setAttr layerCurvesINRange1.color 6;
    }
    if ( `objExists TheLastCurvesSet` == 0  ) {
    $newSet3 = `sets -name TheLastCurvesSet`;
    }
    if ( `objExists ZEdgeCurvesSet` == 0  ) {
    $newSet1 = `sets -name ZEdgeCurvesSet`;
    }
    if ( `objExists ZPlaneCurvesSet` == 0  ) {
    $newSet2 = `sets -name ZPlaneCurvesSet`;
    }
    global int $xii;
    global int $xii = 0;
    $script_jobToolChangedNum1 = 505;
    $script_jobToolChangedNum2 = 606;
    $addNumbersA = 0;
    global int $script_jobNumIdle_MoveZCURVEM;
    global string $dialogBoxWin;
    global string $EdgeCurveZ2[];
    global int $plainNum;
    clear $EdgeCurveZ2;
    global int $plainNum = 0;
    global string $CamConeLocator[];


    if ( `objExists ZCURVEModelingCAM` == 0  ) {
    handleScriptEditorAction "toggleSuppressInfos";
    handleScriptEditorAction  "toggleSuppressWarnings";
    handleScriptEditorAction "toggleSuppressErrors";
    setWireframeOnShadedOption 1 modelPanel4;
    $CamConeLocator = `CreateCAMforIntCurveScript`;
    if ( `objExists CamConeLocatorSet` == 0  ) {
    $newCAMSet1 = `sets -name CamConeLocatorSet`;
    sets -include CamConeLocatorSet $CamConeLocator;
    }
    createStageOneForRetopo;
    select -r $CamConeLocator;
    HideSelectedObjects;
    shadingNode -asShader lambert;
    $material = `shadingNode -asShader lambert -name  LIVEsurfaceslambert`;
    $sg = `sets -renderable true - noSurfaceShader true -empty -name ($material +  "SG")`;
    setAttr "LIVEsurfaceslambert.transparency" -type  double3 1 1 1 ;
    defaultNavigation -source LIVEsurfaceslambert - destination  |LiveSurfaceB|LiveSurfaceBShape.instObjGroups[0]  - connectToExisting;
    connectNodeToAttrOverride("LIVEsurfaceslambert",  "LiveSurfaceBShape.instObjGroups[0]");
    defaultNavigation -source LIVEsurfaceslambert - destination |Zplane|ZplaneShape.instObjGroups[0]  -connectToExisting;
    connectNodeToAttrOverride("LIVEsurfaceslambert",  "ZplaneShape.instObjGroups[0]");
    defaultNavigation -source LIVEsurfaceslambert - destination |Xplane|XplaneShape.instObjGroups[0]  -connectToExisting;
    connectNodeToAttrOverride("LIVEsurfaceslambert",  "XplaneShape.instObjGroups[0]");
    }
    if (( `objExists ZCURVEModelingCAM` == 1  )&& (  `objExists layerCurvesINRange1` == 1 )) {
    setAttr "ZCURVEModelingCAM.centerOfInterest"  75;
    //select -r ZCURVEModelingCAM ;
    //select -tgl LiveSurfaceB ;
    //scale -r 10 10 10 ; // SEt Camera Scale

    if ( `objExists CamConeLocatorSet` == 1  ) {
    eval( "global string $CamConeLocator[];");
    eval( "$CamConeLocator= `sets -q  CamConeLocatorSet`;");
    }
    }
    //

    if ( `objExists LocOnLivePlaneB` == 0  ) {
    createDisplayLayer -name "LocOnLivePlaneB" - number 1 -empty;
    setAttr LocOnLivePlaneB.color 9;
    }
    if ( `objExists LocCurveEnds` == 0  ) {
    createDisplayLayer -name "LocCurveEnds" - number 1 -empty;
    setAttr LocCurveEnds.color 13;
    }

    if ( `objExists layerMidPoint` == 0  ) {
    createDisplayLayer -name "layerMidPoint" - number 1 -empty;
    setAttr layerMidPoint.color 14;
    }


    ////////

    EvalAllCurvesToolZ;
    $scriptt_jobNumConnectionChanged = `scriptJob -conditionChange delete evalVectorIndexAdditionSubtract`;
    eval(" $jobNumtranslateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.translate  RUNMoveZCURVEM`;");
    eval(" $jobNumrotateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.rotate  RUNMoveZCURVEM`;");

    select -r LiveSurfaceB ;
    MakeLive;
    PencilCurveTool;



    ////////



    */
    /////////////START OF AUTOMATIC SCENE SETUP for STEREOSCRIPTS######################################
    /////////////START OF AUTOMATIC SCENE SETUP for STEREOSCRIPTS######################################

    proc EvalAllCurvesToolZ(){
    eval("int $scriptt_jobAllCurvesToolsNumAZ =  `scriptJob -event DagObjectCreated  AutoCurveScriptsTwoCurve -compressUndo true -protected  `;");
    }

    proc RUNMoveZCURVEM(){
    $script_jobNumIdle_MoveZCURVEM = `scriptJob   -runOnce 1 -event idle EVALCamScripts`;
    }

    proc createStageOneForRetopo(){
    nurbsPlane -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u  1 -v 1 -ch 1 -n Zplane;
    rotate -r -os 0 0 -90 ;
    setAttr "Zplane.scaleX" 3000;
    setAttr "Zplane.scaleY" 3000;
    setAttr "Zplane.scaleZ" 3000;
    nurbsPlane -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u  1 -v 1 -ch 1 -n Xplane;
    setAttr "Xplane.scaleX" 3000;
    setAttr "Xplane.scaleY" 3000;
    setAttr "Xplane.scaleZ" 3000;
    editDisplayLayerMembers -noRecurse  NurbsPlanes "Zplane";
    editDisplayLayerMembers -noRecurse  NurbsPlanes "Xplane";
    layerEditorLayerButtonVisibilityChange NurbsPlanes;
    curve -d 3 -p 0 0 0 -p 0 0 4 -p 0 0 8 -p 0 0 12  -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -n Zcurvez;
    curve -d 3 -p 0 0 0 -p 4 0 0 -p 8 0 0 -p 12 0 0  -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -n Xcurvez;
    if ( `objExists layerZcurvez` == 0  ) {
    createDisplayLayer -name "layerZcurvez" -number 1  -empty;
    setAttr layerZcurvez.color 6;
    editDisplayLayerMembers -noRecurse layerZcurvez  Zcurvez;
    }
    if ( `objExists layerXcurvez` == 0  ) {
    createDisplayLayer -name "layerXcurvez" -number 1  -empty;
    setAttr layerXcurvez.color 13;
    editDisplayLayerMembers -noRecurse layerXcurvez  "Xcurvez";
    }
    }

    proc int[] SortNumbersIntIndex(float $allFloatToSort[]){
    $aF = $allFloatToSort;
    $sIze = `size($aF)`-1;
    $IndexTrack = CreateIntIndex(`size($aF)`);
    quickSort($aF, $IndexTrack, 0, $sIze);
    $IndexTrack = ReverseIntArray($IndexTrack);
    return $IndexTrack;
    }
    proc quickFix(){
    global vector $ObjVec[];
    global string $GlobalObjListA[];
    $quickFix = `sets -q ExistingCurveZSet`;
    $FixVec = PointArrayT($quickFix);
    $GlobalObjListA=$quickFix;
    $ObjVec=$FixVec;
    }
    proc evalVectorIndexAdditionSubtract(){
    global vector $ObjVec[];
    global string $GlobalObjListA[];
    $objVecMain  = $ObjVec;
    $intIndexCurveZ = CreateIntIndex(`size($objVecMain)`) ;
    clear $firstReduction;
    $GetObjList = `sets -q ExistingCurveZSet`;
    $KnowObjList = $GlobalObjListA;
    $diffAZ = stringArrayRemoveExact($GetObjList,$KnowObjList);
    $diffCZ = stringArrayRemoveExact($KnowObjList, $GetObjList);
    if((`size($diffCZ)`>0)||(`size($diffAZ)`>0)){
    if(`size($diffAZ)`>0){
    $diffBZ = stringArrayRemoveExact($diffAZ,$KnowObjList);
    $NewObjList= $diffBZ;
    $indexNumberZ = stringArrayGmatchArrayIndex($diffBZ, $KnowObjList);
    $indexX = 0;
    for ($eachVec in $indexNumberZ){
    $firstReduction[`size($firstReduction)`]= $objVecMain[$eachVec];
    }
    }
    if(`size($diffCZ)`>0){
    $newAddedVec = PointArrayT($diffCZ);
    $iXn = 0;
    for ($eachVecB in $newAddedVec){
    $firstReduction[`size($firstReduction)`]=  $eachVecB ;
    stringArrayInsertAtIndex(`size($NewObjList)`, $NewObjList, $diffCZ[$iXn]);
    $iXn++;
    }
    }
    $GlobalObjListA = $NewObjList;
    clear $ObjVec;
    $ObjVec= $firstReduction;
    }
    }
    proc string[] MoveZCURVEModelingCAM2010(string $EdgeCurves[], string $CamConeLocator[], vector $ObjVecX[]){
    RemoveNoLongerExistingFromArray($EdgeCurves);
    $listofallcurves = $EdgeCurves;
    layerEditorRemoveObjects layerCurvesINRange1 ;
    editDisplayLayerMembers -noRecurse "defaultLayer"  $ObjectsINcamLightCone;
    layerEditorRemoveObjects layerCurvesOutofRange1 ;
    editDisplayLayerMembers -noRecurse "defaultLayer"  $OutofRange;
    clear $ObjectsINcamLightCone;
    if ( `objExists LocOnLivePlaneB` == 0  ) {
    createDisplayLayer -name "LocOnLivePlaneB" - number 1 -empty;
    setAttr LocOnLivePlaneB.color 9;
    }
    queryLocOnLivePlaneBLayerDelete;
    queryLocCurveEndsLayerDelete;
    querylayerMidPointLayerDelete;
    catch ( $shortnameL = "PlaneLOC*");
    if ( `objExists $shortnameL` == 1  ) {
    catch (`delete $shortnameL`);
    }
    $CurveItem = $listofallcurves;
    ResetTransEachSL;
    $NurbplaneB = "LiveSurfaceBShape";
    $ObjectsInFrontZ = GetObjectsInFrontOfPlane2($CurveItem, $ObjVecX, $VecArrayRemainsZ);
    if(`size($ObjectsInFrontZ)`>0){
    clear $AllLocPositionsZ;
    $AllPlaneLocPositionZ = VecPointsToCameraPlane($VecArrayRemainsZ);
    $LocPointinPlane = PointInNurbPlane($AllPlaneLocPositionZ, $ObjectsInFrontZ, $newOrderA, 0);
    }
    if(`size($LocPointinPlane)`>0){
    $indexLoc = 0;
    for ($each in $LocPointinPlane){
    stringArrayInsertAtIndex(0,  $ObjectsINcamLightCone, $each);
    $LocCurveEnds = LocCurveEnds({$each},$AllCurveLocArrayVec);
    appendStringArray($AllLocCurveEnds, $LocCurveEnds, size($LocCurveEnds));
    }
    clear $AllCurvePlaneLocZ;
    $AllCurvePlaneLocZ = VecPointsToCameraPlane($AllCurveLocArrayVec);
    select -cl  ;
    $CurveLocPlanePoints = PointInNurbPlane($AllCurvePlaneLocZ, $AllLocCurveEnds, $newOrderB, 1);
    }
    $shorterList = stringArrayRemoveDuplicates ($ObjectsINcamLightCone);
    $ObjectsINcamLightCone = $shorterList;
    $OutofRange = stringArrayRemoveExact ($ObjectsINcamLightCone, $listofallcurves);
    editDisplayLayerMembers -noRecurse  layerCurvesOutofRange1 $OutofRange;
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ObjectsINcamLightCone;
    return $ObjectsINcamLightCone;
    }
    proc CatchMoveZCURVECAM2010(string $EdgeCurveZa[], string $CamConeLocator[], vector $ObjVecX[]){
    global string $StereoCurveZ[];
    global string $VanishingPointsLinesTempGuides[];
    global int $addNumbersA;
    quickFix;
    if ( catchQuiet(MoveZCURVEModelingCAM2010 ($EdgeCurveZa, $CamConeLocator, $ObjVecX ))) {
    evalVectorIndexAdditionSubtract;
    MoveZCURVEModelingCAM2010($EdgeCurveZa, $CamConeLocator, $ObjVecX );
    clear $StereoCurveZ;
    clear $VanishingPointsLinesTempGuides;
    $addNumbersA =0;
    quickFix;
    } else {
    clear $StereoCurveZ;
    $addNumbersA =0;
    quickFix;
    }
    }
    proc string[] queryLocOnLivePlaneBLayer(){
    $queryLocB = `editDisplayLayerMembers  -q LocOnLivePlaneB`;
    $IfemptyIsTrue = 0;
    if (`size( $queryLocB)` > 0){
    $IfemptyIsTrue = 0;
    }
    if (`size( $queryLocB)`== 0){
    $IfemptyIsTrue = 1;
    }
    return $queryLocB;
    }
    proc queryLocOnLivePlaneBLayerDelete(){
    $queryLocOnLivePlaneB = `editDisplayLayerMembers  -q LocOnLivePlaneB`;
    if (`size( $queryLocOnLivePlaneB)` > 0){
    delete  $queryLocOnLivePlaneB;
    }
    }
    proc queryLocCurveEndsLayerDelete(){
    $queryLocCurveEnds = `editDisplayLayerMembers  -q LocCurveEnds`;
    if (`size($queryLocCurveEnds)` > 0){
    delete $queryLocCurveEnds;
    }
    }
    proc querylayerMidPointLayerDelete(){
    $querylayerMidPoint = `editDisplayLayerMembers  -q layerMidPoint`;
    if (`size($querylayerMidPoint)` > 0){
    delete $querylayerMidPoint;
    }
    }
    proc string[] LocCurveEnds(string $CurveItem[], vector $CurveLocArrayVec[]){
    $numCVs = `getAttr -size ($CurveItem[0]+".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
    $EACHCVposAZ = 0; string $MakeXBetweenB[];
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ($eachZA)`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){$EACHCVposAZ = $eachCVpos;}
    if ( $numIntZB == 2 ){$EACHCVposBZ = $eachCVpos;}
    }
    $NameStart = ("LOC"+$CurveItem[0]+"START");
    $NameEnd = ("LOC"+$CurveItem[0]+"END");
    $LocSTART = `spaceLocator -p 0 0 0 -n $NameStart`;
    MoveObject2($EACHCVposAZ);
    $LocEND = `spaceLocator -p 0 0 0 -n $NameEnd`;
    MoveObject2($EACHCVposBZ);
    $STARTENDcurveLocs = { $LocSTART[0], $LocEND[0]};
    setAttr ($LocSTART[0]+".scaleX") 0.5;
    setAttr ($LocSTART[0]+".scaleY") 0.5;
    setAttr ($LocSTART[0]+".scaleZ") 0.5;
    setAttr ($LocEND[0]+".scaleX") 0.5;
    setAttr ($LocEND[0]+".scaleY") 0.5;
    setAttr ($LocEND[0]+".scaleZ") 0.5;
    $CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    $CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    editDisplayLayerMembers -noRecurse LocCurveEnds $STARTENDcurveLocs;
    select -cl  ;
    return $STARTENDcurveLocs;
    }
    proc vector [] VecCurveEps(string $CurveItem ){
    $CurveSelection = `ls -fl ($CurveItem+".ep[0:*]")`;
    for ($eachZA in $CurveSelection) {
    $EACHCVposAZ = `pointPosition -w ($eachZA)`;
    $CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    }
    return $CurveLocArrayVec;
    }
    proc vector [] VecCurveCvs(string $CurveItem ){
    $CurveSelection = `ls -fl ($CurveItem+".cv[*]")`;
    for ($eachZA in $CurveSelection) {
    $EACHCVposAZ = `pointPosition -w ($eachZA)`;
    $CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    }
    return $CurveLocArrayVec;
    }
    proc vector[] PointArrayT(string $ObjectList[]){
    $XiV = 0;
    for ($each in $ObjectList){
    if (catch($pointAZ1 = `xform -q -ws -t ($each)`)){
    $pointAZ1 = `pointPosition -w ($each)`;
    }
    $VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
    $XiV++;
    }
    return $VecArray;
    }
    proc vector[] PointArray(string $ObjectList[]){
    $XiV = 0;
    for ($each in $ObjectList){
    if (catch($pointAZ1 = `pointPosition -w ($each)`)){
    $pointAZ1 = `xform -q -ws -rp ($each)`;
    }
    $VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
    $XiV++;
    }
    return $VecArray;
    }
    proc string [] GetObjectsInFrontOfPlane2(string $Loc[], vector $VecArray[], vector $VecArrayRemainsB[] ){
    $CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $IndexVec = 0;
    $IndexVecRemain = 0;
    clear $ObjectsInFrontOfPlane;
    for ($eachPoint in $VecArray){
    $ObjectToCam = distance2Pts( $CamPlane1, $VecArray[$IndexVec]);
    $ObjectToCamShiftA = ($CamerasDirectionVectorNormal* 10.5)+$VecArray[$IndexVec];
    $ObjToCamdistShiftDiff = distance2Pts( $CamPlane1, $ObjectToCamShiftA);
    if($ObjToCamdistShiftDiff<$ObjectToCam){
    stringArrayInsertAtIndex(`size($ObjectsInFrontOfPlane)`, $ObjectsInFrontOfPlane, $Loc[$IndexVec]);
    $VecArrayRemains[$IndexVecRemain]= $VecArray[$IndexVec];
    $IndexVecRemain++;
    }
    $IndexVec++;
    }
    $VecArrayRemainsB = $VecArrayRemains;
    return $ObjectsInFrontOfPlane;
    }
    proc string [] PointInNurbPlane(vector $AllPlaneLocPosition[], string $ObjectsInFront[], int $Newindex[], int $Locint ){
    clear $EdgesSurface;
    $EdgesSurface[0] = "LiveSurfaceBShape.cv[0][0]" ;
    $EdgesSurface[1] = "LiveSurfaceBShape.cv[0][3]" ;
    $EdgesSurface[2] = "LiveSurfaceBShape.cv[3][3]" ;
    $EdgesSurface[3] = "LiveSurfaceBShape.cv[3][0]" ;
    $SurfEnds = PointArray($EdgesSurface);
    $MiddlePointA[0] = FloatToVec(MidPoint($SurfEnds[0], $SurfEnds[1]));
    $MiddlePointA[1] = FloatToVec(MidPoint($SurfEnds[1], $SurfEnds[2]));
    $MiddlePointA[2] = FloatToVec(MidPoint($SurfEnds[2], $SurfEnds[3]));
    $MiddlePointA[3] = FloatToVec(MidPoint($SurfEnds[3], $SurfEnds[0]));
    $AveragePoints = `xform -q -ws -t LiveSurfaceB`;
    clear $DirectionsToCent;
    for ($each in $MiddlePointA){
    $Direct = DirectionF( $each, $AveragePoints);
    $DirectionsToCent[size($DirectionsToCent)] = <<$Direct[0], $Direct[1], $Direct[2]>>;
    }
    $PlaneDimentionsV = distance2Pts( $SurfEnds[0], $SurfEnds[1]);
    $PlaneDimentionsH = distance2Pts( $SurfEnds[1],$SurfEnds[3]);
    $IndexV = CreateIntIndex(`size($AllPlaneLocPosition)`);
    $RadiusMax = distance2Pts( $AveragePoints, $SurfEnds[0]);
    $indexRecord = 0;
    for ($eachVec in $AllPlaneLocPosition){
    $FoundDistance = distance2Pts( $AveragePoints, $eachVec);
    if($FoundDistance<=$RadiusMax){
    $IndexReduced[`size($IndexReduced)`] = $IndexV[$indexRecord];
    $firstReduction[`size($firstReduction)`]= $eachVec;
    }
    $indexRecord++;
    }
    $PlaneDimentionsVH = $PlaneDimentionsV/100;
    $PlaneDimentionsHH = $PlaneDimentionsH/100;
    $indexPoints = 0;
    $PointsZ = $firstReduction;
    $Lastindex = 0;
    $indexM = 0;
    $FourDiections = 0;
    for ($eachPoint in $firstReduction){
    $LocPoint = $eachPoint;
    $indexM = 0;
    $FourDiections = 0;
    for ($each in  $DirectionsToCent){
    $DistanceA = distance2Pts( $MiddlePointA[$indexM],  $LocPoint);
    if(($indexM==0)||($indexM==2)){
    $MultDirAV= multiplyFloat($PlaneDimentionsVH, $each);
    }
    if(($indexM==1)||($indexM==3)){
    $MultDirAV= multiplyFloat($PlaneDimentionsHH, $each);
    }
    $FloatDirectionPointz = AddFloats($MultDirAV, $LocPoint);
    $DistanceB = distance2Pts( $MiddlePointA[$indexM],  $FloatDirectionPointz);
    if( $DistanceB > $DistanceA){
    $FourDiections++;
    }
    $indexM++;
    }
    if( $FourDiections == 4 ){
    $AllPointsInplane[`size($AllPointsInplane)`]= $eachPoint;
    $lastIntIndex[$Lastindex]=  $IndexReduced[$indexPoints];
    $Lastindex++;
    }
    $indexPoints++;
    }
    for ($eachNumber in $lastIntIndex){
    stringArrayInsertAtIndex(`size($allObjectsInPlane)`, $allObjectsInPlane, $ObjectsInFront[$eachNumber]);
    }
    $Newindex = $lastIntIndex;
    for ($eachNumber in $lastIntIndex){
    $NewVecArray[`size($NewVecArray)`] =$AllPlaneLocPosition[$eachNumber];
    }
    $AllPlaneLocPosition=$NewVecArray;
    if($Locint==1){
    $inDexName = 0;
    for ($each in $AllPointsInplane){
    $stringName = ("Plane"+ $allObjectsInPlane[$inDexName]);
    spaceLocator -p 0 0 0 -n $stringName;
    MoveObject2($each);
    scale -r 0.01 0.01 0.01;
    editDisplayLayerMembers -noRecurse LocOnLivePlaneB $stringName;
    $inDexName++;
    }
    }
    return $allObjectsInPlane;
    }
    proc float[] MirrorFloatXYZ(int $XYZ, float $ThreeFLoatArrays[]){
    $Zx = $ThreeFLoatArrays;
    $Zx[$XYZ] *= -1.0;
    return $Zx;
    }
    proc float[] nurbsViewDirectionVectorCam( string $cameraName , int $onlyOrtho )
    {
    $isitYup = `upAxis -q -ax $cameraName`;
    if( "y" == $isitYup ) {
    $result[0] = 0.0 ;
    $result[1] = 1.0 ;
    $result[2] = 0.0 ;
    }
    else {
    $result[0] = 0.0 ;
    $result[1] = 0.0 ;
    $result[2] = 1.0 ;
    }
    "  Using the default (" + $result[0] + "," +
    $result[1] + "," + $result[2] + ")";
    if( $onlyOrtho && !`camera -q -o $cameraName` ) {
    return $result;
    }
    $coiDistance = 0.0 ;
    if( catch( $coiDistance = `camera -q -coi $cameraName` )) {
    warning $forTheWarning;
    return $result ;
    }
    $selectionList = `ls -sl`;
    if( catch($ppm = `createNode pointMatrixMult`) ) {
    warning $forTheWarning;
    select -r $selectionList;
    return $result ;
    }
    select -r $selectionList;
    setAttr ($ppm +".inPoint") -type double3 0.0 0.0 (-$coiDistance) ;
    setAttr ($ppm +".vectorMultiply") true ;
    connectAttr ($cameraName+".worldMatrix[0]") ($ppm+".inMatrix") ;
    $coi = `getAttr ($ppm+".output")` ;
    delete $ppm ;
    $sum = 0;
    for( $i = 0 ; $i < 3 ; $i++ ) {
    $sum += ($coi[$i] * $coi[$i]);
    $result[$i] = $coi[$i];
    }
    if( $sum > 0 ) {
    $sum = -1.0/sqrt($sum);
    for( $i = 0 ; $i < 3 ; $i++ ) {
    $result[$i] = $result[$i] * $sum;
    }
    }
    return $result ;
    }
    proc string Loc(float $Points[]){
    $LocObjects = `spaceLocator -p 0 0 0`;
    setAttr ($LocObjects[0]+".translate")  $Points[0] $Points[1] $Points[2];
    return $LocObjects[0];
    }
    proc string getTypeItemString(string $selectionFindType[]){
    $selectionFindType= `ls -fl $selectionFindType`;
    if(`size($selectionFindType)`>0){
    $Relativesselection = `listRelatives $selectionFindType[0]`;
    if (`size($Relativesselection)` == 0){ string $idnodeType3[] = `nodeType -inherited $selectionFindType[0]`;
    $Value = stringArrayGmatchFind($idnodeType3, "controlPoint");
    if($Value == 1){ $idnodeType2="controlPoint";}else{ $idnodeType2=$idnodeType3[(`size($idnodeType3)`)-1];}
    }else{ $idnodeType2 = `nodeType $Relativesselection[0]`;}
    }else{ $idnodeType2 = "EMPTY";}
    return $idnodeType2;
    }
    proc int [] stringArrayGmatchArrayIndex(string  $itemA[], string $list[]){
    $sizeitem = `size($itemA)`;
    $result = false;
    $Index = 0;
    $BreakTrigger = 0;
    for ($EachlistItem in $list) {
    for ($EachlistA in $itemA) {
    if ( $EachlistItem == $EachlistA ){
    $result = true; $ResultIndex[`size($ResultIndex)`] =  $Index;
    $BreakTrigger++;
    if ( $BreakTrigger == $sizeitem ){	break;	}
    }
    }
    $Index++;
    }
    return $ResultIndex;
    }
    proc int stringArrayGmatchFind(string $itemsA[], string $Item){
    $result = false;
    for ($EachlistA in $itemsA) {
    if ( $EachlistA == $Item ){
    $result = true;
    break;	}
    }	return $result;
    }
    proc float [] ArrayDistancesVecTofloat(vector $allVec[], float $point[]){
    for ($each in $allVec){
    $AllDistances[`size($AllDistances)`] = distance2Pts( $each, $point);
    }
    return $AllDistances;
    }
    proc float [] MovePointDirectionAndDistance( float $Direction[], float $Distance, float $PointA[]){
    $MultDirDist = multiplyFloat($Distance ,$Direction);
    $FloatPointLoc = AddFloats($PointA, $MultDirDist);
    return $FloatPointLoc;
    }
    proc SetItemColorString( string $isSelectedZz, int $Color ){
    if ( `objExists $isSelectedZz` == 1  ) {
    $ColorN = $Color;
    if ( $Color > 31  ) { $ColorN = $ColorN -31;}
    $isSelectedZx = `listRelatives $isSelectedZz`;
    setAttr ($isSelectedZx[0]+".overrideEnabled ") 1;
    if (catch (`setAttr ($isSelectedZx[0]+".overrideColor ") $ColorN `)){
    setAttr ($isSelectedZx[0]+".overrideColor ") 1;}
    }
    }
    proc MoveObject2(float $FloatPos[]){
    move -ws $FloatPos[0] $FloatPos[1] $FloatPos[2] ;
    }
    proc float[] AverageVectorPoint(vector $worldPosZ[]) {
    $vectorSize = `size($worldPosZ)`;
    $vecCount = `size($worldPosZ)`;
    $Added_floats = { 0.0, 0.0, 0.0};
    $Vii = 0;
    while ($Vii < $vecCount){
    $FloatFromVecA = $worldPosZ[$Vii];
    $VposA = $FloatFromVecA[0];
    $VposB =  $FloatFromVecA[1];
    $VposC =  $FloatFromVecA[2];
    $Added_floats = {($FloatFromVecA[0]+$Added_floats[0]), ($FloatFromVecA[1]+$Added_floats[1]), ($FloatFromVecA[2]+$Added_floats[2])} ;
    $Vii++;
    }
    $a = ($Added_floats[0])/float($vectorSize);
    $b = ($Added_floats[1])/float($vectorSize);
    $c = ($Added_floats[2])/float($vectorSize);
    $PointsAverage = {$a , $b , $c};
    return $PointsAverage;
    }
    global proc int[] ArrayToIntList(string  $singleStringItemB[]){
    $triggerendsB = 0;
    $newlistSize = size($singleStringItemB);
    $ci = 0;
    while ( $triggerendsB < $newlistSize ) {
    $Numberlist[$ci] = $singleStringItemB[$ci];
    $ci++;
    $triggerendsB = $triggerendsB + 1;
    }
    return $Numberlist;
    }
    proc int[] ReverseIntArray(int $array[]){
    for($i=0;$i<size($array);$i++){
    $arrayOut[$i]=$array[(size($array)-1-$i)];}
    return $arrayOut;
    }
    proc string[] ReverseStringArray(string $array[]){
    for($i=0;$i<size($array);$i++){
    $arrayOut[$i]=$array[(size($array)-1-$i)];}
    return $arrayOut;
    }
    proc vector[] ReverseVectorArray(vector $array[]){
    for($i=0;$i<size($array);$i++){
    $arrayOut[$i]=$array[(size($array)-1-$i)];}
    return $arrayOut;
    }
    proc vector[] MagTimesUnitVecs(vector  $vectorZFlatYHigher, vector $vectorZFlatYLower){
    $MagVectorZYHigher = mag ($vectorZFlatYHigher);
    $MagVectorZYLower = mag ($vectorZFlatYLower);
    $unitVectormagZYHL[0] = $MagVectorZYHigher *  unit($vectorZFlatYHigher);
    $unitVectormagZYHL[1] = $MagVectorZYLower * unit ($vectorZFlatYLower);
    return $unitVectormagZYHL;
    }
    proc float[] AddFloats(float $posA[], float  $posB[]){
    $AddposA_AND_posB_float = {($posA[0] + $posB[0]),  ($posA[1] + $posB[1]), ($posA[2] + $posB[2])} ;
    return $AddposA_AND_posB_float;
    }
    proc float[] SubtractFloats(float $posA[], float  $posB[]){
    $SubtractposA_AND_posB_float = {($posA[0] -  $posB[0]), ($posA[1] - $posB[1]), ($posA[2] -  $posB[2])} ;
    return $SubtractposA_AND_posB_float;
    }
    proc float[] multiplyFloatArray(float  $posA, float $posB[]){
    for($eachF in $posB){
    $Timespos[`size($Timespos)`] = $eachF*$posA;
    }
    return $Timespos;
    }
    proc vector FloatToVec(float $posA[]){
    $xvex = << $posA[0], $posA[1], $posA[2] >>  ;
    return $xvex;
    }
    proc float[] MakeCleanFloats(float $FloatZ[]){
    $POSAe = $FloatZ[0]; string $POSBe =  $FloatZ[1];
    $POSCe = $FloatZ[2];
    $nameAe = `match "e" $POSAe`;
    $nameBe = `match "e" $POSBe`;
    $nameCe = `match "e" $POSCe`;
    $zeroORZe1 = `gmatch "e" $nameAe`;
    $zeroORZe2 = `gmatch "e" $nameBe`;
    $zeroORZe3 = `gmatch "e" $nameCe`;
    if ( $zeroORZe1 == 1){ $FloatZ[0] = 0.0; }
    if ( $zeroORZe2 == 1){ $FloatZ[1] = 0.0; }
    if ( $zeroORZe3 == 1){ $FloatZ[2] = 0.0; }
    return $FloatZ;
    }
    proc float[] MakeCleanFloatsZ(float $FloatZ[]){
    $POSAe = FloatArrayToStringArray( $FloatZ);
    $index = 0;
    for ($eachS in $POSAe){
    $POSAe = $eachS;
    $nameAe = `match "e" $POSAe`;
    $zeroORZe1 = `gmatch "e" $nameAe`;
    if (( $zeroORZe1 == 1)||( $eachS == -0)){ $FloatZi[$index] = 0.0;
    }else{$FloatZi[$index] = $FloatZ[$index];}
    $index++;
    }
    return $FloatZi;
    }
    proc float[] MidPoint(float $loc1[],  float $loc2[]) {
    $a = ($loc2[0] + $loc1[0]) * (0.5);
    $b = ($loc2[1] + $loc1[1]) * (0.5);
    $c = ($loc2[2] + $loc1[2]) * (0.5);
    $vPoint = {$a , $b , $c};
    return $vPoint;
    }
    proc PAUSE(){
    playButtonStepForward;
    }
    proc averagingNode(string $firstObjectz, string  $averageObjectz, string $LastObjectz){
    $averaging[0] = `shadingNode -asUtility  plusMinusAverage`;
    setAttr ($averaging[0] + ".operation") 3;
    connectAttr -force ( $firstObjectz +  ".translate")($averaging[0] + ".input3D[1]");
    connectAttr -force ($averaging[0] + ".output3D") ("|" + $averageObjectz + ".translate");
    connectAttr -force ( $LastObjectz +  ".translate")($averaging[0] + ".input3D[0]");
    }
    proc ResetTranslation(string $oneItemz[]){
    xform -cp $oneItemz[0];
    $worldPos = `xform -q -ws -rp  $oneItemz[0]`;
    move -rpr 0 0 0  $oneItemz[0];
    makeIdentity -apply true  -t 1 -r 0 -s 0 $oneItemz[0];
    xform -t ($worldPos.x)  ($worldPos.y) ($worldPos.z) $oneItemz[0];
    }
    proc string[] RemoveNoLongerExistingFromArray (string $EdgeCurveZ1[]){
    $SizeOfArrayA = size($EdgeCurveZ1);
    if ( $SizeOfArrayA > 0){
    $SizeOfArray = size($EdgeCurveZ1) -1;
    $i = -1;
    $E = -1;
    while( $E < $SizeOfArray ){
    $i++;
    $E++;
    if ( `objExists $EdgeCurveZ1[$i]` == 0  ) {
    stringArrayRemoveAtIndex($i, $EdgeCurveZ1);
    if ($i == 0) { $i = -1;} else { $i = $i -1;}
    }
    }
    $SizeOfArrayB = size($EdgeCurveZ1);
    }
    return $EdgeCurveZ1;
    }
    proc int ISobjectSelectedTypeCurve(){
    $C = `ls -sl`;
    $nametypeZ = `ls -showType $C`;
    $nameA = `match "[a-zA-Z]+" $nametypeZ[0]`;
    $zeroOR1Z = `gmatch "Curve" $nameA`;
    return $zeroOR1Z;
    }
    proc int addNumbers(){
    $CreatedObjectCurve = `ISobjectSelectedTypeCurve`;
    return $CreatedObjectCurve;
    }
    proc int  PtsEquivalentF( float $posA[],  float $posB[], float $TRange){
    $pX = equivalentTol($posA[0], $posB[0], $TRange);
    $pY = equivalentTol($posA[1], $posB[1], $TRange);
    $pZ = equivalentTol($posA[2], $posB[2], $TRange);
    $addedResults = $pX + $pY + $pZ;
    if ($addedResults == 3 ){return 1;
    }else{
    return 0;}
    }
    proc CurveIndexVecTracking(string $OBJ[]){
    $OBJall = `sets -q CurveZSetOne` ;
    if(`size($OBJall)`>0){
    sets -remove CurveZSetOne $OBJall;
    }
    global string $GlobalObjOne[];
    global vector $ObjCurv[];
    sets -include CurveZSetOne $OBJ;
    eval("$GlobalObjOne= `sets -q CurveZSetOne`");
    eval("appendStringArray($GlobalObjListA,$GlobalObjOne, 1)");
    eval("vector $ObjCurv[] = PointArrayT($GlobalObjOne);");
    eval("$ObjVec[`size($ObjVec)`] =  $ObjCurv[0]");
    eval("sets -include ExistingCurveZSet $GlobalObjOne");
    sets -remove CurveZSetOne $OBJ;
    }
    proc EVALCamScripts(){
    $runit = "CatchMoveZCURVECAM2010($GlobalObjListA, $CamConeLocator, $ObjVec );";
    eval($runit); }
    proc string [] IntArrayToStringArray(int $IntArray[]){
    for($each in $IntArray){
    $Intnumbers += $each+" ";
    }
    $array = stringToStringArray($Intnumbers, " ");
    return $array;
    }
    proc string [] FloatArrayToStringArray(float $FloatArray[]){
    for($each in $FloatArray){
    $floatnumbers += $each+" ";
    }
    $array = stringToStringArray($floatnumbers, " ");
    return $array;
    }
    proc int [] CreateIntIndex(int $ArraySize){
    $iNdex = 0;
    while($iNdex < $ArraySize){
    $IntArrayInex[$iNdex] = $iNdex;
    $iNdex++;
    }
    return $IntArrayInex;
    }
    proc string curve2points(float $TanEnd1[], float $intersectposD1[]){
    $FixVec[0]  = << $TanEnd1[0], $TanEnd1[1], $TanEnd1[2]>>;
    $FixVec[1]  = <<$intersectposD1[0], $intersectposD1[1], $intersectposD1[2]>>;
    $sIZes = 2;
    $NUmers = CreateIntIndex($sIZes);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $curve = "curve -d 1";
    for ($eachVeCx in $FixVec){
    $valuesBi = $eachVeCx;
    $curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    }
    $curve += " "+ $K;
    $Newcurvez = `eval($curve)`;
    return $Newcurvez;
    }
    proc float[] multiplyFloat(float  $posA, float $posB[]){
    $TimesposA_AND_posB_float = {($posA * $posB[0]),  ($posA * $posB[1]), ($posA * $posB[2])} ;
    return $TimesposA_AND_posB_float;
    }
    proc int ArrayInsertAtEnd( string $INarray[],  string $NewItem){
    $SizeOfArray = size($INarray);
    $INarray[$SizeOfArray] = ( $NewItem );
    return $SizeOfArray;
    }
    proc ResetTransEachSL(){
    $oneItemz = `ls -sl`;
    for ($each in $oneItemz){
    xform -cp $each;
    $worldPos = `xform -q -ws -rp   $each`;
    move -rpr 0 0 0 $each;
    makeIdentity -apply true   -t 1 -r 0 -s 0 $each;
    xform -t ($worldPos.x)   ($worldPos.y) ($worldPos.z) $each;
    }
    }
    proc string [] NewArrayOrderWithIndexKey(string $stringIndexTrack[], string $ObjsCurve[]){
    for($each in $stringIndexTrack){
    $iNew = $each;
    stringArrayInsertAtIndex(`size($newOrderArray)`, $newOrderArray, $ObjsCurve[$iNew]);
    }
    return $newOrderArray;
    }
    proc float [] SortFloatArrayAndString( float $allFloatToSort[], string $ObjsCurve[], string $EmptyStringNewOrder[]){
    $Floatlist = $allFloatToSort;
    $sIze = `size($allFloatToSort)`-1;
    $aF = $allFloatToSort;
    $IndexTrack = CreateIntIndex(`size($aF)`);
    quickSort($aF, $IndexTrack, 0, $sIze);
    $stringIndexTrack = IntArrayToStringArray($IndexTrack);
    $newOrderArray = NewArrayOrderWithIndexKey($stringIndexTrack, $ObjsCurve);
    $EmptyStringNewOrder = $newOrderArray;
    return $aF;
    }
    proc string Circles_Direction(float $Point[], float $FloatDir[], float $FloatNum){
    -nr $FloatDir[0] $FloatDir[1] $FloatDir[2]
    -sw 360
    -r $FloatNum
    -d 3 -ut 0 -tol 0.001 -s 8 -ch 1`;
    return $circleItem[0];
    }
    proc  creatStereoCurve(){
    global string $VanishingPointsLinesTempGuides[];
    global int $addNumbersA;
    global string $StereoCurveZ[];
    global int $ifSingleCurve;
    global int $ForceOrthoOFFON;
    if(size($StereoCurveZ)>0){
    RemoveNoLongerExistingFromArray($StereoCurveZ);
    }
    if( $ForceOrthoOFFON == 1){
    $addNumbersA=-3;
    ForceOrtho($StereoCurveZ);
    }
    if( $ForceOrthoOFFON == 0){
    $x = $addNumbersA;
    print ($addNumbersA + "\n");
    if ($x == 1){
    $VanishingPointsLinesTempGuides = VanishingCurves($StereoCurveZ);
    if( $ifSingleCurve==1){
    delete $VanishingPointsLinesTempGuides;
    clear $VanishingPointsLinesTempGuides;
    clear $StereoCurveZ;
    $addNumbersA =0;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    $ifSingleCurve=0;
    }
    }
    if ($x == 2){
    StereoCurveZ($StereoCurveZ[0], $StereoCurveZ[1]);
    $addNumbersA =0;
    }
    }
    }
    proc vector[] NewVecOrderWithINTKey(int $IntIndexTrack[], vector $ObjsCurve[]){
    for($eachVi in $IntIndexTrack){
    $newOrderVec[`size($newOrderVec)`] = $ObjsCurve[$eachVi];
    }
    return $newOrderVec;
    }
    proc float [] MultLenToDirAddToPoint(float $Length, float $Dir[], float $Pos[]){
    $MultLengthDir = multiplyFloat($Length, $Dir);
    $AddMultDirPos = AddFloats($Pos, $MultLengthDir);
    return $AddMultDirPos;
    }
    proc int [] CreatePairIntIndex(int $AS){
    $Ai = 0;
    $Bi = 0;
    $N = 0;
    $Times = $AS*2;
    while($Bi < $Times){
    if($Ai == 0){$IntA[$Bi] = $N;}
    if($Ai == 1){ $Ai = -1; $IntA[$Bi] = $N;
    $N++; }
    $Ai++;
    $Bi++;
    }
    return $IntA;
    }
    proc vector [] GetRotationVectorsMatrix(matrix $mAtRiX[][]){
    $MatrizFloatiA = MatrixToFloat($mAtRiX);
    $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
    $VecR[0] = $VecAii;
    $VecAii = << $MatrizFloatiA[4], $MatrizFloatiA[5], $MatrizFloatiA[6]>>;
    $VecR[1] =$VecAii;
    $VecAii = << $MatrizFloatiA[8], $MatrizFloatiA[9], $MatrizFloatiA[10]>>;
    $VecR[2] = $VecAii;
    return $VecR;
    }
    proc vector MultPointMatrix( vector $PtsVec, matrix $mIA[][]){

    $MatrizFloatiA = MatrixToFloat($mIA);
    $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
    $VecR[0] = $VecAii;
    $VecAii = << $MatrizFloatiA[4], $MatrizFloatiA[5], $MatrizFloatiA[6]>>;
    $VecR[1] =$VecAii;
    $VecAii = << $MatrizFloatiA[8], $MatrizFloatiA[9], $MatrizFloatiA[10]>>;
    $VecR[2] = $VecAii;
    $RowA = $VecR[0];
    $RowB = $VecR[1];
    $RowC = $VecR[2];
    $GivenPoint = $PtsVec;
    $NewPoint = multiplyFloat($GivenPoint[0], $RowA);
    $NewPointa = multiplyFloat($GivenPoint[1], $RowB);
    $NewPointb = multiplyFloat($GivenPoint[2], $RowC);
    $NewPtMatrixMult = AddFloats($NewPoint, $NewPointa);
    $NewPtMatrixMult = AddFloats($NewPtMatrixMult, $NewPointb);
    $NewPoint[0] = (($RowA[0])*($GivenPoint[0])) + (($RowB[0])*$GivenPoint[1]) + (($RowC[0])*$GivenPoint[2]);
    $NewPoint[1] = (($RowA[1])*($GivenPoint[0])) + (($RowB[1])*$GivenPoint[1]) + (($RowC[1])*$GivenPoint[2]);
    $NewPoint[2] = (($RowA[2])*($GivenPoint[0])) + (($RowB[2])*$GivenPoint[1]) + (($RowC[2])*$GivenPoint[2]);
    $ReturnValVec = FloatToVec($NewPoint);
    return $ReturnValVec;
    }
    proc matrix FloatToMatrix(float $v[]){
    matrix $mat[4][4]=<<$v[0], $v[1], $v[2], $v[3];
    $v[4], $v[5], $v[6], $v[7];
    $v[8], $v[9], $v[10], $v[11];
    $v[12], $v[13], $v[14], $v[15]>>;
    return $mat;
    }
    proc float[] MatrixToFloat(matrix $FourByFour_matrix[][]){
    $FLOATindex = 0;
    $Inx = 0;
    $Inxb = 0;
    for($Inx = 0; $Inx <= 3; $Inx++){
    for($Inxb = 0; $Inxb <= 3; $Inxb++){
    $matrixFloat[$FLOATindex] = $FourByFour_matrix[$Inx][$Inxb];
    $FLOATindex++;
    }
    }
    return $matrixFloat;
    }
    proc vector PointToPlaneN( vector $Veciiv, vector $Vec[]){
    $pAv = AverageVectorPoint($Vec);
    $n = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    $DistanceLoc = distance2Pts(  $Veciiv, $pAv);
    $MultDirCam = multiplyFloat($DistanceLoc, $n);
    $FloatDirectionCamNormalA = AddFloats($pAv, $MultDirCam);
    $PointN = ClosestPoint2LineVec($n, $pAv, $Veciiv);
    $CombA = PointsEquivalentTol ($PointN, $pAv);
    if($CombA != 3){
    $FloatDirectionAi = DirectionFN($pAv,$PointN);
    $DistanceLoc = distance2Pts( $PointN, $pAv );
    $MultDirPC1 = multiplyFloat($DistanceLoc, $FloatDirectionAi);
    $AddMultMiiF = AddFloats($Veciiv, $MultDirPC1);
    $planePointN = << $AddMultMiiF[0], $AddMultMiiF[1], $AddMultMiiF[2]>>;
    }else{ $planePointN = $Veciiv;
    }
    return $planePointN;
    }
    proc string VecArrayToCurve(vector $FixVec[]){
    $sIZes = `size $FixVec `;
    $NUmers = CreateIntIndex($sIZes);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $curve = "curve -d 1";
    for ($eachVeCx in $FixVec){
    $valuesBi = $eachVeCx;
    $curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    }
    $curve += " "+ $K;
    $Newcurvez = `eval($curve)`;
    return $Newcurvez;
    }
    proc float [] EulerAngB(float $pointB1[], float $pointB2[]){
    $EulerAngleA = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
    return $EulerAngleA;
    }
    proc vector [] VecPtsToZMirrorPts(vector $AllLocPositionsZ[]){
    clear  $AllPlaneLocs;
    for ($eachVecEp in $AllLocPositionsZ){
    $Zx = $eachVecEp;
    $Zx[0] *= -1.0;
    $AllPlaneLocs[`size($AllPlaneLocs)`] = `FloatToVec ($Zx)`;
    }
    return $AllPlaneLocs;
    }
    proc int ISSelectedTypeCurve(){
    $C = `ls -sl`;
    $nametypeZi= `getTypeItemString $C`;
    $nameA = `match "[a-zA-Z]+" $nametypeZi`;
    $nameB = `match ".urve" $nameA`;
    $zeroOR1Z = `gmatch $nameB "*[C-c]urve*"`;
    return $zeroOR1Z;
    }
    proc int addCurveNumbers(int $addNumbersiA){
    $addNumbersiA++;
    if($addNumbersiA>2){$addNumbersiA=0;}
    return $addNumbersiA;
    }
    proc EvalAddingCurves(){
    global int $addNumbersA;
    $addNumbersA = addCurveNumbers($addNumbersA);
    print $addNumbersA;
    }
    proc float [] FloatPointsToCamPlane(float $LocPos1[]){
    $Pi = 3.1415926535;
    $pi = 3.1415926535;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $LivePlanePos = `xform -q -ws -t LiveSurfaceB`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $CamerasDirectionVector = $CamerasDirectionVectorNormal;
    $FloatDirectionA = DirectionFN($CamPos1, $LocPos1);
    $DistanceLoc = distance2Pts( $LocPos1, $CamPos1 );
    $DistanceLocA = $DistanceLoc;
    $DistanceLoc = $DistanceLoc * -1;
    $MultDirPC1 = multiplyFloat($DistanceLoc, $CamerasDirectionVector);
    $FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1);
    $CamerasDirectionVectorA = DirectionFN($FloatDirectionCamNormal, $CamPos1);
    $MultDirPC1A = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
    $FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1A);
    $p1 = $CamPos1;
    $p2 = $LocPos1;
    $p3 = $FloatDirectionCamNormal;
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );
    $FloatPosZero = {0, 0, 0};
    $FloatDirection = DirectionFN($FloatPosZero, $normal);
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $mid3 = midPoint2Pts( $p2, $p3 );
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    $FloatDirPerpCenterC = DirectionFN($center,$mid2);
    $FloatDirPointAC = DirectionFN($p1, $p3);
    $center8 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
    $FloatDirLocToPerpIntersect = DirectionFN($center8,$p2);
    $OnPlane = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );
    return $OnPlane;
    }
    proc float[] DirectionF(float $EACHCVposAZ[], float $EACHCVposBZ[]){
    $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]);


    $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
    $UnitDirection = $vectorUnit;
    return $UnitDirection;
    }
    proc float [] lineIntersectionF(float $PosA[], float $PosB[], float $PosC[], float $PosD[]){
    $DirAB = DirectionF ($PosA, $PosB);
    $DirCD = DirectionF ($PosC, $PosD);
    $locsA = lineIntersection($PosA, $DirAB, $PosC, $DirCD);
    return $locsA;
    }
    proc float[] pointMatrixMult( float $point[], float $matrix[] ){
    $result[0] = 0.0;
    $result[1] = 0.0;
    $result[2] = 0.0;
    if ( size($point) != 3 || size($matrix) != 16 )
    {
    warning (uiRes("m_pointMatrixMult.kPointArray"));
    return $result;
    }
    if ( catch($multNode = `createNode pointMatrixMult`) )
    {
    warning (uiRes("m_pointMatrixMult.kCouldNotCreateNode"));
    return $result;
    }
    setAttr ($multNode+".vectorMultiply") true;
    setAttr ($multNode+".inPoint") -type "double3" $point[0] $point[1] $point[2];
    setAttr ($multNode+".inMatrix") -type "matrix" $matrix[0] $matrix[1] $matrix[2] $matrix[3] $matrix[4] $matrix[5] $matrix[6] $matrix[7] $matrix[8] $matrix[9] $matrix[10] $matrix[11] $matrix[12] $matrix[13] $matrix[14] $matrix[15];
    $result = `getAttr ($multNode+".output")`;
    delete $multNode;
    return $result;
    }
    proc matrix MatrixCleanNegZero(matrix $m[][]){
    $MatrixA = `MatrixToFloat($m)`;
    $iX = 0;
    for ($eachFloat in $MatrixA){
    if(($eachFloat == 0)||($eachFloat == -0)){
    $CleanFLoats[`size($CleanFLoats)`] = 0.0;
    }else{$CleanFLoats[`size($CleanFLoats)`] = $eachFloat;}
    $iX++;
    }
    $CleanFLoats = MakeCleanFloatsZ($CleanFLoats);
    matrix $MatrixClean[4][4]= FloatToMatrix($CleanFLoats);
    return $MatrixClean;
    }
    proc int  PointsEquivalentTol( float $posA[],  float $posB[]){
    $pX = equivalentTol($posA[0], $posB[0],  0.001);
    $pY = equivalentTol($posA[1], $posB[1],  0.001);
    $pZ = equivalentTol($posA[2], $posB[2],  0.001);
    $addedResults = $pX + $pY + $pZ;
    return $addedResults;
    }
    proc string IteratCurve(float $step, string $paramlocatorpointOnCurvex, float $curveMin, int $FindSteps){
    $MasterCount = 0;
    $curve = "curve -d 3";
    while ($FindSteps < 4){
    $curve = "curve -d 3";
    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    if ( $CurvatureRadi <=  $curveMin){
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    $CountSteps++;
    }
    }
    $FindSteps = $CountSteps;
    if($FindSteps < 10){$curveMin += 18.0; $curve = "curve -d 3";  }
    if($MasterCount== 4){break;}
    $MasterCount++;
    }
    return $curve;
    }
    proc string VecArrayToCurveB(vector $FixVec[]){
    $sIZes = `size $FixVec `;
    $NUmers = CreateIntIndex($sIZes);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $K += "\-k"+" "+ $sIZes+" ";
    $sIZes++;
    $K += "\-k"+" "+ $sIZes+" ";
    $curve = "curve -d 3";
    for ($eachVeCx in $FixVec){
    $valuesBi = $eachVeCx;
    $curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    }
    $Newcurvez = `eval($curve)`;
    return $Newcurvez;
    }
    proc vector TwoVecsOrFloats(float $p1p2[], float $p1p3[]){
    $Ui = FloatToVec($p1p2);
    $Vi = FloatToVec($p1p3);
    $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;
    return $VEcLine;
    }
    proc int MostRightClockWiseInt ( vector $Vecs[], int $Two[]){
    $ThreePoints = { "0", "1", "2"};
    $point1 = FloatToVec($Vecs[0]);
    $point2 = FloatToVec($Vecs[1]);
    $point3 = FloatToVec($Vecs[2]);
    $U1 = TwoVecsOrFloats($point2, $point1);
    $V1 = TwoVecsOrFloats($point3, $point1);
    $U2 = TwoVecsOrFloats($point3, $point1);
    $V2 = TwoVecsOrFloats($point2, $point1);
    $U3 = TwoVecsOrFloats($point1, $point3);
    $V3 = TwoVecsOrFloats($point2, $point3);
    clear $normalV;
    $normalV[0] = FloatToVec( crossProduct( $U1, $V1, 0, 1 ) );
    $normalV[1] = FloatToVec( crossProduct( $U2, $V2, 0, 1 ) );
    $normalA = `unit ($normalV[0])`;
    $normalB = `unit ($normalV[1])`;
    $normalAAdd = $normalA[0] + $normalA[1];
    $normalAAdd2 = $normalB[0] + $normalB[1];
    if( $normalAAdd< $normalAAdd2){
    $TwoNew ={$Two[1], $Two[0]};
    }else{
    $TwoNew ={$Two[0], $Two[1]};
    }
    return $TwoNew[0];
    }
    proc float [] CreateIntIndexF(int $ArraySize, float $Fstep){
    $iNdex = 0;
    $AddF = 0;
    while($iNdex < $ArraySize){
    $AddF+= $Fstep;
    $FArrayInex[$iNdex] = $AddF;
    $iNdex++;
    }
    return $FArrayInex;
    }
    proc float AverageFloats(float $FloatArray[]){
    $Ix = 0;
    $AddAll = 0;
    for($eachF in $FloatArray){
    $AddAll+= $eachF;
    $Ix++;
    }
    $Divide = $AddAll/$Ix;
    return $Divide;
    }
    proc float [] GatherDataRR(float $Xt[], float $Av){
    $count = 0;
    for ($eachF in $Xt){
    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= -1;}
    if($count>0){
    if($PastF<$eachF){
    if($PastF<$Av){
    if(($PastF+$eachF/2.0)<$Av){
    $Vt[$count]= 1; }
    }
    }
    }
    $PastF = $eachF;
    $count++;
    }
    return $Vt;
    }
    proc string [] VecArrayToSplitCurve(vector $FixVec[]){
    $sIZes = `size $FixVec `;
    $evenOdd = fmod($sIZes, 2);
    $sIZesHalf = (($sIZes)/2)+1;
    $NUmers = CreateIntIndex($sIZesHalf);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $countN = 0;
    $curveA = "curve -d 1";
    for ($eachVeCx in $NUmers){
    $valuesBi  = $FixVec[$countN];
    $curveA += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    $countN++;
    }
    $curveA += " "+ $K;
    $curveB = "curve -d 1";
    $countN--;
    for ($eachVeCx in $NUmers){
    $valuesBi  = $FixVec[$countN];
    $curveB += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    $countN++;
    }
    $curveB += " "+ $K;
    $NewcurvezA = `eval($curveA)`;
    $NewcurvezB = `eval($curveB)`;
    $NewcurvezAB = {$NewcurvezA , $NewcurvezB};
    return $NewcurvezAB;
    }
    proc vector [] LineIntersectPlaneCam( vector $Vecii[], float $CamP[], vector $Vec[]){
    $pAv = AverageVectorPoint($Vec);
    $n = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    $CountVV = 0;
    for($eachVecLine in $Vecii){
    $FloatDirA  = DirectionF($eachVecLine, $CamP);
    $FloatDirNormalA = multiplyFloat(2, $FloatDirA);
    $MultDirA = AddFloats( $FloatDirNormalA, $eachVecLine);
    $DistanceLocA = distance2Pts(  $eachVecLine, $pAv);
    $MultDirCam  = multiplyFloat($DistanceLocA, $n);
    $FloatDirectionCamNormalA  = AddFloats($pAv, $MultDirCam);
    $PointN  = ClosestPoint2Line($n, $pAv, $eachVecLine);
    $FloatDirectionAi  = DirectionF($PointN, $pAv);
    $DistanceLoc = distance2Pts( $PointN, $pAv );
    $MultDirPC1  = multiplyFloat($DistanceLoc, $FloatDirectionAi);
    $FloatDirNormalDist  = AddFloats($eachVecLine, $MultDirPC1);
    $PointNii  = ClosestPoint2Line(DirectionF($PointN, $pAv), $eachVecLine, $MultDirA);
    $FloatDirectionAii  = DirectionF($PointNii, $MultDirA);
    $OnPlane[$CountVV] = FloatToVec (lineIntersection( $FloatDirNormalDist, $FloatDirectionAii, $eachVecLine, $FloatDirA));
    $CountVV++;
    }
    return $OnPlane;
    }
    proc vector FindIfCurveIsOrthoEpipol(vector $EpipolD[], vector $CRV_ENDS[], float $DistEnds, vector $LineMid){
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;
    if(`size($EpipolD)` == 3){
    $Xdirect = $EpipolD[0];
    $Ydirect = $EpipolD[1];
    $Zdirect = $EpipolD[2];
    }else{
    $Xdirect = << 1,0,0>>;
    $Ydirect = << 0,1,0>>;
    $Zdirect = << 0,0,1>>;
    }
    $XYZdirect[0] = $Xdirect;
    $XYZdirect[1] = $Ydirect;
    $XYZdirect[2] = $Zdirect;
    $LineAMain = PositiveDirectionLine($CRV_ENDS[0], $CRV_ENDS[1]);
    $EulerAngleA  = EulerAngB($Xdirect,$LineAMain);
    $EulerAngleB  = EulerAngB($Ydirect,$LineAMain);
    $EulerAngleC  = EulerAngB($Zdirect,$LineAMain);
    $EulerABCi[0]= $EulerAngleA[3];
    $EulerABCi[1]= $EulerAngleB[3];
    $EulerABCi[2]= $EulerAngleC[3];
    $stringF = FloatArrayToStringArray($EulerABCi);
    clear $EmptyIndx;
    $index = CreateIntIndex(3);
    $stringIndTr = IntArrayToStringArray($index);
    SortFloatArrayAndString( $EulerABCi, $stringIndTr, $EmptyIndx);
    $EmptyIndx = ReverseStringArray($EmptyIndx);
    $xyz = $EmptyIndx[0];
    $AxisOrthoLine = $xyz;
    $Anglei = $EulerABCi[$xyz];
    $NewDirectionZ = $XYZdirect[$xyz];
    $DistEnds= distance2Pts($CRV_ENDS[0], $CRV_ENDS[1]);
    $LineMid = ($CRV_ENDS[0] + $CRV_ENDS[1])/2.0;
    $AngleEpiPole = $Anglei;
    $isOrthoTrueZi = 0;
    if($Anglei < 8.55){
    $isOrthoTrueZi = 1;  print ("IsOrthoLineTrue :Anglei "+$Anglei+"\n");
    }
    print ("IsOrthoLineTrue :Anglei "+$Anglei+"\n");
    $IsOrthoLineTrue = $isOrthoTrueZi;
    return $NewDirectionZ;
    }
    proc int isCurveEndAtZY(vector $EndVectors[]){
    $Number = 0;
    for($eachVec in $EndVectors){
    $ThreeFs = $eachVec;
    if($ThreeFs[0] == 0){
    $Number++;
    }}
    return $Number;
    }
    proc string [] ForceOrtho(string  $CurveItemAX[]){
    global string $StereoCurveZ[];
    global int $addNumbersA;
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemAX[0];
    $Positions = VecCurveEps($CurveItemAX[0]);
    $TempCrv = VecArrayToCurve($Positions);
    delete $CurveItemAX[0];
    $VecCurEnds = VecCurveEnds({$TempCrv});
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEndsOLD = $queryLocCurveEnds;
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    if(`size($queryLocCurveEnds)` >= 2){
    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $distancesEachToCurveB = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    $ReducedIndexA = floatArrayCountDuplicates($distancesEachToCurve);
    $ReducedIndexB = floatArrayCountDuplicates($distancesEachToCurveB);
    for($eachInt in $ReducedIndexA){
    $distAz[`size($distAz)`]= $distancesEachToCurve[$eachInt];
    }
    for($eachInt in $ReducedIndexB){
    $distBz[`size($distBz)`]= $distancesEachToCurveB[$eachInt];
    }
    $NearestInt = SortNumbersIntIndex($distAz);
    $NearestIntB = SortNumbersIntIndex($distBz);
    $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$ReducedIndexA[$NearestInt[0]]];
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$ReducedIndexB[$NearestIntB[0]]];
    $NearestInt[0] =  $NewIntIndexAA;
    $NearestIntB[0] = $NewIntIndexBB;
    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];
    $LocA = $queryLocCurveEnds[$NearestInt[0]];
    $LocB = $queryLocCurveEnds[$NearestIntB[0]];
    clear $EndSnapAndEndProject;
    $Loc_AorB = "";
    if($NdistA<$NdistB){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    $Loc_AorB="B";
    }else{
    $Loc_AorB="A";
    $LocName =$LocB;
    $NearestIndex=$NearestIntB[0];
    $NearEndZ = $VecCurEnds[1];
    $endNotNearZ[0] = $VecCurEnds[0];}
    if($NdistA==$NdistB){
    $Loc_AorB="A";
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    }
    if($NearestInt[0]==$NearestIntB[0]){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    }
    $newNames = stringArrayToString($queryLocCurveEnds, " ");
    $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    $AllarrayCurvesNear = stringToStringArray($newNamesResultAX, " ");
    $NewFoundLocs[0]  = $AllarrayCurvesNear[$NearestIndex];
    $arrayCurvesNear[0] = $queryLocCurveEnds[$NearestIndex];

    $LocOnPlaneVec = PointArray($arrayCurvesNear );
    $Loc3D_Vec = PointArray($NewFoundLocs );
    $ALLLoc3D_VecAB = PointArray($AllarrayCurvesNear);
    if($Loc_AorB == "A"){
    $ReducedIndexXAB = $ReducedIndexA;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexA,$ALLLoc3D_VecAB);
    }
    if($Loc_AorB == "B"){
    $ReducedIndexXAB = $ReducedIndexB;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexB,$ALLLoc3D_VecAB);
    }
    $ALLLoc3D_Vec = $ReducedVecAB;
    $MovedEndPointPlane = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    $CRV_ENDSi[0]= $LocOnPlaneVec[0];
    $CRV_ENDSi[1]= $MovedEndPointPlane[0];
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);
    $MidCurveA = MidPoint($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
    $EpipolD = $DDirEpipolXYZ;
    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);
    $XYZdirectL[0] = << 1,0,0>>;
    $XYZdirectL[1] = << 0,1,0>>;
    $XYZdirectL[2] = << 0,0,1>>;
    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    $AxisOrthoLineA = $AxisOrthoLine;
    $Dir_CamRay =  DirectionFN($MovedEndPointPlane[0],$CamPos_A);
    $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);
    $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);
    $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    $XYZi  = $PointN_LineC;
    $XYZadd  = $PointN_LineC;
    $XYZi[0] = $XYZadd[0]+$XYZadd[1];
    $XYZi[1] = $XYZadd[1]+$XYZadd[2];
    $XYZi[2] = $XYZadd[0]+$XYZadd[2];
    $iVc = 0;
    clear $TrackFoundN;
    if($AxisOrthoLineA ==2){
    $TwoPointsi[0] = 0;
    }
    if($AxisOrthoLineA ==1){
    $TwoPointsi[0] = 2;
    }
    if($AxisOrthoLineA ==0){
    $TwoPointsi[0] = 1;
    }
    $AXIS = $AxisOrthoLineA;
    clear $ALLlikeness;
    $i = 0;
    $Dist_3DNear = (($Dist_3D/3.0)*2.0);
    for ($each in $ALLLoc3D_Vec){
    $One = $ALLLoc3D_Vec[$i];
    $XY[0] = $Xx  = $One.x;
    $XY[1] = $Yy  = $One.y;
    $XY[2] = $Zz  = $One.z;
    if( $ReducedIndexXAB[$iVc]!= $NearestIndex ){
    $TriggerPoints=0;
    if( (equivalentTol($XYZadd[0], $Xx,  0.01) )==1){
    $All_X[$i] = $Xx;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[1], $Yy,  0.01) )==1){
    $All_Y[$i] = $Yy;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[2], $Zz,  0.01) )==1){
    $All_Z[$i] = $Zz;
    $TriggerPoints++;
    }
    if( $TriggerPoints<2){
    $diffXYZ = `abs ($XY[$AXIS] - $XYZadd[$AXIS])`;
    if(($diffXYZ< $Dist_3DNear)&&($diffXYZ!=0)){
    $All_ZYX[`size($All_ZYX)`] =$XY[$AXIS];
    $All_ZYXDiff[`size($All_ZYXDiff)`] = $diffXYZ;
    }
    }
    if( $TriggerPoints==2){
    $ALLlikeness[`size($ALLlikeness)`] = $ReducedIndexXAB[$i];
    }
    }
    $i++;
    $iVc++;
    }
    if(`size($All_ZYXDiff)`> 0){
    $SortedForce = SortNumbersIntIndex($All_ZYXDiff);
    $newOrderFloat = $All_ZYX[$SortedForce[0]];
    }
    if(`size($ALLlikeness)`> 0){
    select -cl;
    for($eachIn in $ALLlikeness){
    select -add $AllarrayCurvesNear[$eachIn];
    PAUSE;
    }
    clear $NearPointsXYZ;
    $iVc =0;
    for($eachIn in $ALLlikeness){
    if( $iVc!= $NearestIndex ){
    $NearPointsXYZ[`size($NearPointsXYZ )`] =  $ALLLoc3D_VecAB[$eachIn];
    }
    $iVc++;
    }
    $distTo3DCurveEnd = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    $Sorted = SortNumbersIntIndex($distTo3DCurveEnd);
    $NearPointsXYZ = NewVecOrderWithINTKey($Sorted,$NearPointsXYZ);
    clear $SdistTo3DCurveEnd;
    for($eachIn in $Sorted){
    $SdistTo3DCurveEnd[`size($SdistTo3DCurveEnd)`] = $distTo3DCurveEnd[$eachIn];
    }
    $ReducedIndex = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    $ReducedVec = NewVecOrderWithINTKey($ReducedIndex,$NearPointsXYZ);
    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    $OntheSameLine = 0;
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $OntheSameLine =1;
    }
    $CountN = 0;
    for($eachVec in $ReducedVec){
    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $eachVec);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $PointN_LineXYZ = $eachVec;
    print " on same Line ";
    }else{
    $PointN_LineXYZ  = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $eachVec);
    }
    if( (distance2Pts($PointN_LineXYZ, $PointN_LineC))>0.001){
    $LocsV[`size($LocsV)`] = `Loc $PointN_LineXYZ`;
    $CurvesV[`size($CurvesV)`] = curve2points($eachVec, $PointN_LineXYZ);
    PAUSE;
    }
    if($CountN==0){
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapN = $eachVec;
    $SnapPlaceN = $PointN_LineXYZ;
    }
    if($CountN!=0){
    print  $DistSnap;
    if((distance2Pts($PointN_LineXYZ, $PointN_LineC))<  $DistSnap){
    $SnapN = $eachVec;
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapPlaceN = $PointN_LineXYZ;
    }
    }
    $CountN++;
    }
    $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);
    delete $CurvesV;
    delete $LocsV;
    if(($EulerAngleA[3] >85)&&($EulerAngleA[3]<95)){
    $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    if($Dist_3DSnap<($Dist_3D/2.0)){
    cycleBackgroundColor;
    PAUSE;
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    $AddInt = $AdditR;
    if($AddInt == 0){
    $PointN_LineC = $SnapPlaceN;
    PAUSE; PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }else{
    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $FPointN_LineC =  $PointN_LineC;
    $FPointN_LineC[$AXIS] = $newOrderFloat;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }
    }else{
    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }
    $Points3DPair_And_2DPair[0]= $Loc3D_Vec[0];
    $Points3DPair_And_2DPair[1]= $PointN_LineC;
    $Points3DPair_And_2DPair[2]= $LocOnPlaneVec[0];
    $Points3DPair_And_2DPair[3]= $NewPlanePoint;
    delete $TempCrv;
    $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 10 -d 3 -tol 0.05 $CurvesVi;
    $Crv_Pts = VecCurveEps($CurvesVi );
    $MirrorAcrossPlaneVecs = VecMultMatrixMirror($Crv_Pts);
    $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    clear $StereoCurveZ;
    $BothCurves[0] = $CurvesVi;
    $BothCurves[1] = $TheSecondCurve;
    $StereoCurveZ = $BothCurves;
    $addNumbersA =-3;
    ResetTranslation($BothCurves);
    CurveIndexVecTracking($BothCurves);
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $BothCurves;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    clear $StereoCurveZ;
    }
    return $BothCurves;
    }
    proc int [] floatArrayCountDuplicates(float $listX[]){
    $list = $listX;
    $index = 0;
    $X = 0;
    $Xi = 0;
    $C = 0;
    $result = $list;
    for ($item in $list) {
    $NumberE[$X] = floatArrayCount($item, $result);
    if (1 == $NumberE[$X]) {
    $NoneDup[`size($NoneDup)`] = $Xi;
    }else{
    if (1 < $NumberE[$X]) {
    floatArrayRemoveAtIndex($X, $result);
    $X--;
    }
    }
    $Xi++;
    $X++;	}
    return $NoneDup;
    }
    proc int floatArrayCount(float $item, float $list[]){
    $result = 0;
    for ($listItem in $list) {
    if ($item == $listItem) $result++;	}
    return $result;
    }
    proc int floatArrayRemoveAtIndex( int $index, float $list[] ){
    $len = size( $list );
    if( $index > $len  || $index < 0 ){
    return( false );
    }
    for( $i = 0; $i < $index; $i++ ){
    $result[$i] = $list[$i];
    }
    for( ; $i < $len - 1; $i++ ){
    $result[$i] = $list[$i + 1];
    }
    $list = $result;
    return( true );
    }
    proc vector [] VecMultMatrixMirror(vector $pointZ[]){
    matrix $m2[4][4]= <<	-1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0>>;
    $MatrixB = `MatrixToFloat($m2)`;
    for($eachVec in $pointZ){
    $FLoatPointA[`size($FLoatPointA)`] = FloatToVec(pointMatrixMult( $eachVec, $MatrixB ));
    }
    return $FLoatPointA;
    }
    proc vector [] MoveVectors(vector $Pos_A, vector $VecLoc, vector $Crv_Pts[]){
    $DirLine = DirectionFN( $VecLoc, $Pos_A);
    $DistToPoint = distance2Pts($Pos_A, $VecLoc);
    clear $TranstatedVecs;
    for($eachVector in $Crv_Pts){
    $TranstatedVecs[`size($TranstatedVecs)`] = ($eachVector+($DistToPoint*$DirLine));
    }
    return $TranstatedVecs;
    }
    proc string [] VanishingCurves( string  $CurveItemA[]){
    global string $VanishingPointsLinesTempGuides[];
    global int $ifSingleCurve;
    $SnapD = 0.003;
    global vector $TempVectorsCrv[];
    if(size($TempVectorsCrv)>0){
    clear $TempVectorsCrv;}
    $Positions = VecCurveEps($CurveItemA[0]);
    $TempCrv = VecArrayToCurve($Positions);
    delete $CurveItemA[0];
    $CurveItemA[0] = VecArrayToCurve($Positions);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 3 -tol 0.05 $CurveItemA[0];
    SetItemColorString ($CurveItemA[0], 9);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $TempCrv;
    $PositionsZ_Ax = VecCurveEps($TempCrv);
    $ZYplaneMatrix[0] = <<0, 0, 0>>;
    $ZYplaneMatrix[1] = <<0, 1, 0>>;
    $ZYplaneMatrix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $TempVectorsCrv  = LineIntersectPlaneCam( $PositionsZ_Ax, $CamPos1, $ZYplaneMatrix);
    delete $TempCrv;
    $Pi = 3.1415926535;
    $pi = 3.1415926535;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $CamerasDirectionVector = $CamerasDirectionVectorNormal;
    $MultDirForWard = multiplyFloat(-1, $CamerasDirectionVector);
    $MultDirCam = multiplyFloat(-3, $CamerasDirectionVector);
    $FloatDirectionCamNormalA = AddFloats($CamPos1, $MultDirCam);
    $DirectionVectorXn = {-2,0,0};
    $DirectionVectorX = {2,0,0};
    $DirectionVectorY = {0,-2,0};
    $DirectionVectorYn = {0,2,0};
    $DirectionVectorZn = {0,0,-2};
    $DirectionVectorZ = {0,0,2};
    $VecDirection_A_XYZ[0] = <<-2,0,0>>;
    $VecDirection_A_XYZ[1] = <<2,0,0>>;
    $VecDirection_A_XYZ[2] = <<0,2,0>>;
    $VecDirection_A_XYZ[3] = <<0,-2,0>>;
    $VecDirection_A_XYZ[4] = <<0,0,-2>>;
    $VecDirection_A_XYZ[5] = <<0,0,2>>;
    $VecDirectionXYZ[0] = <<-1,0,0>>;
    $VecDirectionXYZ[1] = <<1,0,0>>;
    $VecDirectionXYZ[2] = <<0,1,0>>;
    $VecDirectionXYZ[3] = <<0,-1,0>>;
    $VecDirectionXYZ[4] = <<0,0,-1>>;
    $VecDirectionXYZ[5] = <<0,0,1>>;
    $FloatPointDirectionXn = AddFloats($CamPos1, $DirectionVectorXn);
    $FloatPointDirectionX = AddFloats($CamPos1, $DirectionVectorX);
    $FloatPointDirectionY = AddFloats($CamPos1, $DirectionVectorY);
    $FloatPointDirectionYn = AddFloats($CamPos1, $DirectionVectorYn);
    $FloatPointDirectionZn = AddFloats($CamPos1, $DirectionVectorZn);
    $FloatPointDirectionZ = AddFloats($CamPos1, $DirectionVectorZ);
    clear $VecXYZs;
    $VecXYZs[0] = FloatToVec($FloatPointDirectionXn);
    $VecXYZs[1] = FloatToVec($FloatPointDirectionX);
    $VecXYZs[2] = FloatToVec($FloatPointDirectionY);
    $VecXYZs[3] = FloatToVec($FloatPointDirectionYn);
    $VecXYZs[4] = FloatToVec($FloatPointDirectionZn);
    $VecXYZs[5] = FloatToVec($FloatPointDirectionZ);
    $VecXYZsOnPlane = VecPointsToCameraPlane($VecXYZs);
    $AverageVecXYZsOnP = AverageVectorPoint($VecXYZsOnPlane);
    $DirectionsZ = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    $FloatDirxyz[0] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[0]));
    $FloatDirxyz[1] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[1]));
    $FloatDirxyz[2] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[3]));
    $FloatDirxyz[3] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[2]));
    $FloatDirxyz[4] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[4]));
    $FloatDirxyz[5] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[5]));
    $Alll = "";
    clear $AllStrings $AnglesAll ;
    for ($eachOrthD in $VecDirectionXYZ){
    $EulerAngleA = EulerAngB($eachOrthD, $CamerasDirectionVector);
    $AnglesAll[`size($AnglesAll)`]= $EulerAngleA[3];
    $stringFloat = FloatArrayToStringArray($EulerAngleA);
    $Alll  = stringArrayToString($stringFloat, " ");
    $AllStrings[`size($AllStrings)`]= $Alll;
    }
    clear $EmptyIndxNewOrder;
    $indexAx = CreateIntIndex(6);
    $stringIndTr = IntArrayToStringArray($indexAx);
    $ANgnew = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
    $EmptyIndxNewOrder = ReverseStringArray($EmptyIndxNewOrder);
    $BestThree = {$EmptyIndxNewOrder[0], $EmptyIndxNewOrder[1], $EmptyIndxNewOrder[2]};
    $BestThree = ReverseStringArray($BestThree);
    $BestThree = stringArrayRemoveDuplicates ($BestThree);
    $indexAxNew = ArrayToIntList( $BestThree);
    $VecCurEnds = VecCurveEnds($CurveItemA);
    $LengCRV_a = `arclen $CurveItemA`;
    $DistEndsi = distance2Pts($VecCurEnds[0], $VecCurEnds[1]);
    $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
    $AverageVecCurEndsP = AverageVectorPoint($VecCurEnds);
    $Count = 0;
    $CurvePsD = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
    size($EmptyIndxNewOrder);
    $DirectionsZ = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    clear $colori;
    $iiX = 0;
    for($eachDirection in $indexAxNew){
    if($eachDirection ==0 || $eachDirection ==1){$colori[`size($colori)`] = 13;}
    if($eachDirection ==3 || $eachDirection ==2){$colori[`size($colori)`] = 14;}
    if($eachDirection ==4 || $eachDirection ==5){$colori[`size($colori)`] = 6;}
    }
    clear $CurvesV;
    $Cindex = 0;
    for ($eachDii in $indexAxNew){
    $IndexZ = $indexAxNew[$Count];
    $FloatPointDirectionZniY  = AddFloats( $VecCurEnds[1], $VecDirection_A_XYZ[$IndexZ]);
    $VecXYZsOnPlaneiY = VecPointsToCameraPlane($FloatPointDirectionZniY);
    $CurveDirectionZiY =  DirectionF($VecCurEnds[1],  $VecXYZsOnPlaneiY[0]);
    $FloatPointDirectionZniiY = AddFloats( $VecCurEnds[0], $VecDirection_A_XYZ[$IndexZ]);
    $VecXYZsOnPlaneiiY = VecPointsToCameraPlane($FloatPointDirectionZniiY);
    $CurveDirectionZiiY =  DirectionF($VecCurEnds[0],  $VecXYZsOnPlaneiiY[0]);
    $locsAi = lineIntersection($VecCurEnds[1], $CurveDirectionZiY, $VecCurEnds[0],  $CurveDirectionZiiY);
    $EpipLolar[$Count] = FloatToVec($locsAi);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[0], $locsAi);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], $colori[$Cindex]);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[1], $locsAi);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], $colori[$Cindex]);
    editDisplayLayerMembers -noRecurse VanishingPointsLines $CurvesV;
    $Cindex++;
    $Count++;
    }
    $ifSingleCurve = 0;
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);
    $HighCurvePoints = CurvatureUtilityCurvature($CurveItemA[0], 60);
    $Cindex = 0;
    if(`size($HighCurvePoints)`>0){
    for ($eachVec in $HighCurvePoints){
    $CurvesV[`size($CurvesV)`] = curve2points($eachVec, $MidEpipolPosFCam);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 11);
    }
    }
    $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
    $Dir_VecA =   PositiveDirectionLine($VecCurEnds[0],$VecCurEnds[1]);
    $VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    $INTERSECTIONLA = lineIntersectionF($VecCurEnds[0], $EpipLolar[0], $VecCurEnds[1],  $EpipLolar[1]);
    $INTERSECTIONLB = lineIntersectionF($VecCurEnds[1], $EpipLolar[0], $VecCurEnds[0],  $EpipLolar[1]);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[0],$INTERSECTIONLA);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 14);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[1],$INTERSECTIONLB);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 14);
    $CurvesV[`size($CurvesV)`] = curve2points($EpipLolar[2],$INTERSECTIONLA);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 4);
    $CurvesV[`size($CurvesV)`] = curve2points($EpipLolar[2],$INTERSECTIONLB);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 4);
    $VecPtsMirrorEnds_A= VecPtsToZMirrorPts( $VecCurEnds);
    $triggerMiddle = 0;
    $VIntersectEnds_A[0] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[1], $CamPos_M, $VecPtsMirrorEnds_A[0]));
    $VIntersectEnds_A[1] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[0], $CamPos_M, $VecPtsMirrorEnds_A[1]));
    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
    $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
    $IntersectEnds_Ai =  FloatPointsToCamPlane($VIntersectEnds_A[0]);
    $IntersectEnds_Bi = FloatPointsToCamPlane($VIntersectEnds_A[1]);
    $CurveItemAa[0] = $CurveItemA[0];
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEndsOLD = queryLocOnLivePlaneBLayer();
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    if(`size($queryLocCurveEnds)` > 2){
    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $NearestInt = SortNumbersIntIndex($distancesEachToCurve);
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[0]];
    $distancesEachToCurveB = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    $NearestIntB = SortNumbersIntIndex($distancesEachToCurveB);
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$NearestIntB[0]];
    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];
    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    $iv = -1;
    $distsA = $NdistA;
    $distsB = $NdistB;
    for (  $i = 1; $i < 5; $i++) {
    if( $distsA < $distsB){
    $NdistA = $distancesEachToCurve[$NearestInt[$i]];
    if($iv==-1){
    $iv++;
    $StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[0]];}
    if (equivalentTol($NdistA, $distsA, 0.001) == 1){
    $StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[$i]];
    }
    }
    }
    $newNames = stringArrayToString( $StringAllNearA, " ");
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    $arrayCurvesNearA = stringToStringArray($newNamesResultC, " ");
    $CRV_index_number = 0;
    $CRc = 0;
    $CRcT = 0;
    for($eachCurve in $arrayCurvesNearA){
    if(`sets -im ZEdgeCurvesSet $eachCurve` ==1){
    $CRV_index_number = $CRc;
    $CRcT++;
    break;
    }
    $CRc++;
    }
    if($CRcT ==1){
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[$CRc]];
    }
    }
    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];
    $newNames = stringArrayToString($EmptyStringNewOrderA, " ");
    $newNamesResultAx = substituteAllString($newNames, "Plane", "");
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    $arrayCurvesNear = stringToStringArray($newNamesResultC, " ");
    $NearCurvesEnds[0] = $arrayCurvesNear[0];
    $NearCurvesEnds[1] = $arrayCurvesNear[1];
    $arrayCurvesNearA1 = stringToStringArray($newNamesResultAx, " ");
    $LocCurveEndsVec_3D = PointArray($arrayCurvesNearA1);
    $LoCz_3D = $LocCurveEndsVec_3D;
    $TXI = << -1.0 , 1.0, 1.0>>;
    $LoCz_3D[2] = MultVec($LoCz_3D[0],$TXI);
    $LoCz_3D[3] = MultVec($LoCz_3D[1], $TXI);
    $countS = 0;
    for($eachItemVEC in $LoCz_3D){
    $VanishingLOC[ size($VanishingLOC) ] = Loc($eachItemVEC);
    if(($countS==0)||($countS==2)){
    SetItemColorString ($VanishingLOC[ size($VanishingLOC) -1], 19);
    setAttr ( $VanishingLOC[ size($VanishingLOC) -1]+".scale") 4.0 4.0 4.0;
    }else{SetItemColorString ($VanishingLOC[size($VanishingLOC)-1], 18);
    setAttr ( $VanishingLOC[ size($VanishingLOC) -1]+".scale") 9.0 9.0 9.0;
    }
    $countS++;
    }
    $PtsM_Ai = FloatPointsToCamPlane($LoCz_3D[2]);
    $PtsM_Bi = FloatPointsToCamPlane($LoCz_3D[3]);
    $INTERSECTIONLC = lineIntersectionF($EpipLolar[0], $PtsM_Ai, $INTERSECTIONLA, $EpipLolar[2]);
    $CurvesV[`size($CurvesV)`] = curve2points($PtsM_Ai,$INTERSECTIONLC);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 14);
    $INTERSECTIONL2C = lineIntersectionF($EpipLolar[0], $VecCurEnds[0], $INTERSECTIONLC, $EpipLolar[2]);
    $CurvesV[`size($CurvesV)`] = curve2points($INTERSECTIONLC,$INTERSECTIONL2C);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 4);
    $INTERSECTIONL2D = lineIntersectionF($EpipLolar[1],$INTERSECTIONLC, $VecCurEnds[1],  $EpipLolar[2]);
    $INTERSECTIONL3D = lineIntersectionF($EpipLolar[0],$INTERSECTIONL2D,$PtsM_Ai,  $EpipLolar[1]);
    $CurvesV[`size($CurvesV)`] = curve2points($INTERSECTIONL2D,$INTERSECTIONL3D);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 14);
    $CurvesV[`size($CurvesV)`] = curve2points($PtsM_Ai,$INTERSECTIONL3D);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 6);
    $CurvesV[`size($CurvesV)`] = curve2points($INTERSECTIONLC,$INTERSECTIONL2D);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 6);
    $CurvesV[`size($CurvesV)`] = curve2points($INTERSECTIONL2C,$VecCurEnds[1]);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 6);
    appendStringArray($CurvesV, $VanishingLOC, size($VanishingLOC));
    $edgeZsetA = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[0]`;
    $edgeZsetB = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[1]`;
    $COuntN = 0;
    for($eachVec in $LocCurveEndsVec_3D){
    $ThreepointVecs = $eachVec;
    if (equivalentTol($ThreepointVecs[0], 0.00, 0.001) == 1){
    $EDGEpoints[$COuntN]= 1;
    }else{$EDGEpoints[$COuntN]= 0;}
    $COuntN++;
    }
    $edgeZsetA =$EDGEpoints[0];
    $edgeZsetB =$EDGEpoints[1];
    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    if(($NearCurvesEnds[0] == $NearCurvesEnds[1])&&( ($edgeZsetA+$edgeZsetB) ==2)){
    if($NdistA<$NdistB){
    $edgeZsetA =1;
    $edgeZsetB =0;
    }
    if($NdistA>$NdistB){
    $edgeZsetA =0;
    $edgeZsetB =1;
    }
    if($edgeZsetA==0){$NdistA=100;}
    if($edgeZsetB==0){$NdistB=100;}
    }
    }
    if(($NdistA>$SnapD)&&($NdistB>$SnapD)){
    $edgeZsetA =0;
    $edgeZsetB =0;
    }
    }
    if(($edgeZsetA==1)&&($NdistA<$SnapD)){
    $pointNearEdgeCurve[0]= 1;
    }
    if(($edgeZsetA==1)&&($NdistA>$SnapD)){
    $pointNearEdgeCurve[0]= 0;
    }
    if(($edgeZsetA==0)&&($NdistA>$SnapD)){
    $pointNearEdgeCurve[0]= 0;
    }
    if(($edgeZsetA==0)&&($NdistA<$SnapD)){
    $pointNearEdgeCurve[0]= 2;
    }
    if(($edgeZsetB==1)&&($NdistB<$SnapD)){
    $pointNearEdgeCurve[1]= 1;
    }
    if(($edgeZsetB==1)&&($NdistB>$SnapD)){
    $pointNearEdgeCurve[1]= 0;
    }
    if(($edgeZsetB==0)&&($NdistB>$SnapD)){
    $pointNearEdgeCurve[1]= 0;
    }
    if(($edgeZsetB==0)&&($NdistB<$SnapD)){
    $pointNearEdgeCurve[1]= 2;
    }
    if($edgeZsetA==1){
    $EdgeDist =$NdistA;
    }else{$EdgeDist=$NdistB;}
    $SnappingVector = 0;
    if($NdistA<$NdistB){
    $SnappingVector=0;
    }else{$SnappingVector=1;}
    if($NdistA>$SnapD){
    $edgeZsetA = 0;
    }
    if($NdistB>$SnapD){
    $edgeZsetB = 0;
    }
    $OneIsNotNearThePlane = 0;
    if(($NdistA>$SnapD)||($NdistB<$SnapD)){
    if(($NdistA<$SnapD)||($NdistB>$SnapD)){
    $OneIsNotNearThePlane =1;
    }
    }
    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    if(($edgeZsetA==1)||($edgeZsetB==1)){
    $EdgeDist =0.001;
    }
    }
    if($pointNearEdgeCurve[0]+$pointNearEdgeCurve[1]== 1){
    $newNamesResultA1 = substituteAllString($newNames, "Plane", "");
    $ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
    $ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
    $A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
    $A= `MakeCleanFloats($A)`;
    $B= `MakeCleanFloats($B)`;
    if(($A[0] ==0)||($B[0] ==0)){
    $triggerMiddle =2;
    $ifSingleCurve=1;
    if($edgeZsetA==1){
    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
    $NearVecPts[1]= $VecCurEnds[1];
    }else{
    $NearVecPts[0]= $VecCurEnds[0];
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
    }
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    if($EdgeDist<2.5){
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    $PositionsZ_Aii = $PositionsZ_Ai;
    }
    $PositionsZ_Aiix[0] = <<0, 0, 0>>;
    $PositionsZ_Aiix[1] = <<0, 1, 0>>;
    $PositionsZ_Aiix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    if($EdgeDist<2.5){
    $VecTest  = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
    }else{$VecTest  = LineIntersectPlaneCam($PositionsZ_A, $CamPos1, $PositionsZ_Aiix);
    }
    $CurveAv[0] = VecArrayToCurveB($VecTest);
    }
    }
    if( $pointNearEdgeCurve[1]==1){
    $newNamesResultA1 = substituteAllString($newNames, "Plane", "");
    $ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
    $ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
    $A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
    $A = MakeCleanFloatsZ($A);
    $B = MakeCleanFloatsZ($B);
    if(($A[0] ==0)&&($B[0] ==0)){
    $triggerMiddle =2;
    $ifSingleCurve=1;
    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    delete $CurveItemA;
    $CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);
    $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    if($DiffMathA >97.0){
    $PositionsZ_Aii[0] = $NearVecPts[0];
    $PositionsZ_Aii[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
    $PositionsZ_Aii[2]= $NearVecPts[1];
    } else{
    $PositionsZ_Aii = $PositionsZ_Ai;}
    $PositionsZ_Aiix[0] = <<0, 0, 0>>;
    $PositionsZ_Aiix[1] = <<0, 1, 0>>;
    $PositionsZ_Aiix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $VecTest = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
    if($DiffMathA >95.0){	$CurveAv[0] = VecArrayToCurve($VecTest);}else{
    $CurveAv[0] = VecArrayToCurve($VecTest);}
    }
    }
    if($triggerMiddle==0){
    if($GetSizeOfCRV_ends>0){
    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);
    $distancesTo3DCurveEnd = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
    $Sorted = SortNumbersIntIndex($distancesTo3DCurveEnd);
    $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
    $distancesTo3DCurveEndi = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
    $Sortedi = SortNumbersIntIndex($distancesTo3DCurveEndi);
    $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
    $FistAndSecond[0]=$LocCurveEndsVec3D[$Sorted[0]];
    $FistAndSecond[1]=$LocCurveEndsVec3D[$Sortedi[0]];
    $LocNames[0]=$queryLocCurveEnds3D[$Sorted[0]];
    $LocNames[1]=$queryLocCurveEnds3D[$Sortedi[0]];
    $LocNames[2]=$queryLocCurveEnds3D[$Sorted[1]];
    $LocNames[3]=$queryLocCurveEnds3D[$Sortedi[1]];
    $VecA = $FistAndSecond[0];
    $VecB = $FistAndSecond[1];
    $XX = $VecA.x;
    $XXX = $VecB.x;
    if( ($XX*-1)==$XXX){
    if($NptsDist<2.5){
    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($VecA));
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($VecB));
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    delete $CurveItemA;
    $CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);
    $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    clear $PositionsZ_A;
    if($DiffMathA >97.0){
    $PositionsZ_Ai[0] = $NearVecPts[0];
    $PositionsZ_Ai[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
    $PositionsZ_Ai[2]= $NearVecPts[1];
    }else{
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    }
    $ReversePositionsZ_Ai = ReverseVectorArray($PositionsZ_Ai);
    clear $PtsMirrorAi;
    $PtsMirrorAi= VecPtsToZMirrorPts($ReversePositionsZ_Ai);
    $iiz = 0;
    clear $XIntersect_Ax;
    for ($eachVecx in  $ReversePositionsZ_Ai){
    $XIntersect_Ax[`size($XIntersect_Ax)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_Ai[$iiz], $CamPos_M, $PtsMirrorAi[$iiz]));
    $iiz++;
    }
    if($DiffMathA >97.0){
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    }
    $CurveAv =  VecArrayToSplitCurve($XIntersect_Ax);
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
    $evalSmoothi += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmoothi);
    $ifSingleCurve=1;
    }
    }
    }
    }
    if(( $ifSingleCurve == 1)&&($triggerMiddle ==0)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[1];
    sets -include ZEdgeCurvesSet $CurveAv;
    }else{
    if(( $ifSingleCurve == 1)&&($triggerMiddle ==1)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    }
    }
    if( ($ifSingleCurve == 1)&&($triggerMiddle ==2)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv;
    $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    sets -include ZEdgeCurvesSet $CurveAv;
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    }
    $VanishingPointsLinesTempGuides = $CurvesV;
    editDisplayLayerMembers -noRecurse VanishingPointsLines $CurvesV;
    select -cl  ;
    return $CurvesV;
    }
    proc vector [] VecPointsToCameraPlane(vector $V[]){
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+($D1*$F3);
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    return $O;
    }
    proc vector [] CurvatureUtilityCurvature(string $curvesZ, int $NumberofSteps){
    $myCurve = $curvesZ;
    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum2 = (( $numEPs -1 ) * 2 );
    $numEPrealNum2 = $NumberofSteps;
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    $step = $numEPrealNum2;
    $StepCycle = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi[$ii] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    $CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
    $ii++;
    }
    $CurvatureRadi = AverageCurveFloat( $CurvatureRadi);
    $AverageC = AverageFloats($CurvatureRadi);
    $AboveOrBelow = GatherDataRR($CurvatureRadi, ($AverageC-(($AverageC/6.0)*5.0)));
    $COuntNN = 0;
    for($eachFloat in $AboveOrBelow){
    if($eachFloat ==1){
    $ReturnVec[`size($ReturnVec)`] = $CurveVectors[$COuntNN];
    }
    $COuntNN++;
    }
    delete $paramlocatorpointOnCurvex;
    return $ReturnVec;
    }
    proc float [] AverageCurveFloat( float $newVec[]){
    $range = 3;
    $TotalS = `size($newVec)`;
    $indexState = 0;
    while($indexState<$TotalS){
    $countS=1;
    $Xs=0;
    while($countS<$range){
    $indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
    $indexRight = fmod(($indexState + $countS),$TotalS);
    $indexLeftS[$Xs] = $indexLeft;
    $indexRightS[$Xs]= $indexRight;
    $countS++;
    $Xs++;
    }
    $Aver = ((($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0) + ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec [$indexState])/4.0;
    $AVvects[$indexState] = $Aver;
    clear $indexLeftS;
    clear $indexRightS;
    $indexState++;
    }
    return $AVvects;
    }
    proc vector [] VecCurveEnds(string $CurveItem[]){
    $numCVsL = `getAttr -size ($CurveItem[0]+".controlPoints")`-1;
    $numCVsSL = $numCVsL-1;
    $CRVendPts[0] = ($CurveItem[0] + ".cv[0]") ;
    $CRVendPts[1] = ($CurveItem[0] + ".cv[" +  $numCVsL + "]") ;
    for($i = 0; $i < 2;$i++){
    $CRV_EndsVec[$i]= `pointPosition -w ($CRVendPts[$i])`;
    }
    return $CRV_EndsVec;
    }
    proc vector ClosestPoint2LineVecX(float $DirectionLineF[], float $PointOnLine[], float  $PointN[]){
    $VecLineDiri = DirectionFN($PointOnLine, $PointN);
    $VecLineDir = $VecLineDiri;
    $MultDirOne = multiplyFloat(1.0, $DirectionLineF);
    $AddMultF = AddFloats($PointOnLine, $MultDirOne);
    $FDirNorA = Normal3Points($PointOnLine, $AddMultF, $PointN);
    $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    $MultDirMx = multiplyFloat($DistToLineSTart, $FDirNorA);
    $AddMultMiiFx = AddFloats($PointOnLine, $MultDirMx);
    $FDirNorB = Normal3Points($PointOnLine, $AddMultMiiFx,  $AddMultF);
    $MultDirMxz = multiplyFloat($DistToLineSTart,  $FDirNorB);
    $AddMultMiiFxz = AddFloats($PointOnLine, $MultDirMxz);
    $locsA = lineIntersection($PointN, $FDirNorB, $PointOnLine,  $DirectionLineF);
    $VlocA = <<$locsA[0],$locsA[1],$locsA[2]>>;
    return $VlocA;
    }
    proc vector [] CRVEndNormals( string $CurveItem ){
    $numCVsL = `getAttr -size ($CurveItem+".controlPoints")`-1;
    $numCVsSL = $numCVsL-1;
    $CRVendPts[0] = ($CurveItem + ".cv[0]") ;
    $CRVendPts[1] = ($CurveItem + ".cv[1]") ;
    $CRVendPts[2] = ($CurveItem + ".cv[" +  $numCVsSL + "]") ;
    $CRVendPts[3] = ($CurveItem + ".cv[" +  $numCVsL + "]") ;
    $In = {1,0,2,3};
    for($i = 0; $i < 4;$i++){
    $CRV_EndsVec[$i]= `pointPosition -w ($CRVendPts[$i])`;
    }
    for($i = 0; $i < 2;$i++){
    $CRV_PlaneNorm[$i]= unit( FloatToVec(DirectionFN($CRV_EndsVec[$In[(($i*2)+1)]],$CRV_EndsVec[$In[($i*2)]])));
    }
    return $CRV_PlaneNorm;
    }
    proc float[ ] BBoxInfo2D(string $i)
    {
    select $i;
    PolySelectConvert 3;
    $test = `xform -query -ws -t`;
    $sizeTest = ((`size $test`) / 3);
    for ($a=1, $bbInfo[0] = $test[0], $bbInfo[3] = $test[0], $x=3, $bbInfo[1] = $test[1], $bbInfo[4] = $test[1], $y=4, $bbInfo[2] = $test[2], $bbInfo[5] = $test[2], $z=5; $a < $sizeTest; $a++)
    {
    $tempX = $test[$x];
    $x = $x + 3;
    $bbInfo[0] = `min $bbInfo[0] $tempX`;
    $bbInfo[3] = `max $bbInfo[3] $tempX`;
    $tempY = $test[$y];
    $y = $y + 3;
    $bbInfo[1] = `min $bbInfo[1] $tempY`;
    $bbInfo[4] = `max $bbInfo[4] $tempY`;
    $tempZ = $test[$z];
    $z = $z + 3;
    $bbInfo[2] = `min $bbInfo[2] $tempZ`;
    $bbInfo[5] = `max $bbInfo[5] $tempZ`;
    }
    return $bbInfo;
    }
    proc vector [] ProjectCrv2PlaneNormal(vector $vecRs[],vector $AvN,vector $Midp){
    $RowC = $AvN;
    $AxisO = $Tran = $Midp;
    $SizeVp = `size($vecRs)`;
    for($Ind=0; $Ind<$SizeVp; $Ind++){
    $PtsVec=$vecRs[$Ind];
    $Pts = $PtsVec;
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    }
    return $NewPtsP;
    }
    proc float  VAnglesofThreeVec(vector $VecA, vector $VecB, vector $VecC){
    $SideA = distance2Pts( $VecA, $VecB);
    $SideB = distance2Pts( $VecB, $VecC);
    $SideC = distance2Pts( $VecC, $VecA);
    $Pi = 3.1415926535;
    $ArcangleB = acos((((`pow $SideA 2.000`) + (`pow $SideC 2.000`) - (`pow $SideB 2.000`) )/(2.000*$SideA*$SideC)));
    $AngleNPiB = ($ArcangleB*180)/$Pi;
    $AngleNB = $AngleNPiB;
    return $AngleNB;
    }
    proc vector [] MultPointMatrixArray( vector $Vec_Array[], matrix $mIA[][],matrix $mIB[][]){
    $MtxF  = MatrixToFloat($mIA);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};
    $AxisO = $Tran = << $mIA[3][0], $mIA[3][1], $mIA[3][2]>>;
    $MtxFB  = MatrixToFloat($mIB);
    $RowAi = {$MtxFB[0], $MtxFB[1], $MtxFB[2]};
    $RowBi = {$MtxFB[4], $MtxFB[5], $MtxFB[6]};
    $RowCi = {$MtxFB[8], $MtxFB[9], $MtxFB[10]};
    for ( $ii = 0; $ii < (`size($Vec_Array)` ); $ii++ ){
    $Pts = $Vec_Array[$ii];
    $PtZ[0] = (($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    $PtZ[1] = (($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    $PtZ[2] = (($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    $PtZT[0] = (($RowAi[0])*($PtZ[0])) + (($RowBi[0])*$PtZ[1]) + (($RowCi[0])*$PtZ[2])+$MtxF[3];
    $PtZT[1] = (($RowAi[1])*($PtZ[0])) + (($RowBi[1])*$PtZ[1]) + (($RowCi[1])*$PtZ[2])+$MtxF[7];
    $PtZT[2] = (($RowAi[2])*($PtZ[0])) + (($RowBi[2])*$PtZ[1]) + (($RowCi[2])*$PtZ[2])+$MtxF[11];
    $ReturnValVec = << $PtZT[0], $PtZT[1], $PtZT[2]>>;
    $TranB = << $mIB[3][0], $mIB[3][1], $mIB[3][2]>>;
    $ReturnValVec += $TranB;
    $newVecs[$ii]=$ReturnValVec;
    }
    return $newVecs;
    }
    proc vector [] Matrix_Curve_TranslationCC(vector $VecPairA[],vector $VecPairB[], vector $CurveVecPointZ[]){
    matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    matrix $matrixB[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $matrixA = TwoPointMatrixPlusAxisWorld($VecPairA, $EmptyVecA, 1);
    $matrixB = TwoPointMatrixPlusAxisWorld($VecPairB, $EmptyVecB, 1);
    $LengthA = distance2Pts ($VecPairA[0], $VecPairA[1]);
    $LengthB = distance2Pts ($VecPairB[0], $VecPairB[1]);
    if($LengthA<$LengthB){$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}else{$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}
    $LengthAB *= $Sign_F;
    $matrixB[3][3] =$LengthAB;
    $NVecPointZ = MultPointMatrixArray($CurveVecPointZ, $matrixA,$matrixB);
    return $NVecPointZ;
    }
    proc vector MatrixAxisTranlation(vector $SVeci, matrix $mIA, matrix $mIB){
    $TransL[0] = $mIA[3][0];
    $TransL[1] = $mIA[3][1];
    $TransL[2] = $mIA[3][2];
    $VecROne = GetRotationVectorsMatrix($mIA );
    $tranSVec = << $TransL[0], $TransL[1], $TransL[2]>>;
    $tranSVecA = $VecROne[0]+$tranSVec ;	vector $tranSVecB = $VecROne [1]+$tranSVec ;
    $tranSVecC = $VecROne[2]+$tranSVec ;
    clear $SVecii;
    $SVecii[0] = $tranSVecB;	$SVecii[1] = $tranSVecC;
    $SVecii[2] = $tranSVec;
    $SVecPoint = $SVeci ;
    $YZvec = PointToPlaneN($SVecPoint, $SVecii);
    clear $SVecii;
    $SVecii[0] = $tranSVecC;	$SVecii[1] = $tranSVecA;
    $SVecii[2] = $tranSVec;
    $ZXvec = PointToPlaneN($SVecPoint, $SVecii);
    clear $SVecii;
    $SVecii[0] = $tranSVecA;	$SVecii[1] = $tranSVecB;
    $SVecii[2] = $tranSVec;
    $XYvec = PointToPlaneN($SVecPoint, $SVecii);
    $VecPlanes[0] = $YZvec; $VecPlanes[1] = $ZXvec; $VecPlanes[2] = $XYvec;
    for($EachVec in $VecPlanes){
    $VecLineDirM_All[`size($VecLineDirM_All)`] = FloatToVec(DirectionFN($EachVec,$SVeci));
    }
    $SIgnA = GetVectorFloatSign( $VecLineDirM_All);
    $SIgnB = GetVectorFloatSign($VecROne);
    $CombA = 0;
    $CountN = 0;
    for($EachVec in $VecPlanes){
    $CombA = PtsEquivalentF ($EachVec,  $SVeci, 0.001);
    if($CombA != 3){
    $DistToPlane[$CountN]= distance2Pts($SVeci,$EachVec);
    }else{$DistToPlane[$CountN]= 0.0;}
    $CountN++;
    }
    $CombA = 0;
    $CountN = 0;
    for($EachFloatA in $DistToPlane){
    if($EachFloatA != 0){
    $EachVecT = $SIgnA[$CountN] * $SIgnB[$CountN];
    $Subs =$EachVecT;
    $AddF = $Subs[0]+$Subs[1]+$Subs[2];
    if($AddF==3){
    $DistToPlane[$CountN]*= 1.0;
    }
    if($AddF==-9){
    $DistToPlane[$CountN]*= -1.0;
    }
    }
    $CountN++;
    }
    $SCale = $mIB[3][3];
    $SCale *= -1.0;
    $DistToPlane = multiplyFloat($SCale, $DistToPlane);
    $NewAXis = MultPointMatrix($DistToPlane, $mIB);
    $TransLb[0] = $mIB[3][0];
    $TransLb[1] = $mIB[3][1];
    $TransLb[2] = $mIB[3][2];
    $NewPos = AddFloats($TransLb, $NewAXis);
    $NewPosVec = <<$NewPos[0], $NewPos[1], $NewPos[2]>>;
    return $NewPosVec;
    }
    proc vector [] GetVectorFloatSign(vector $VecLineDirM_All[]){
    clear $VecSIGNDirM;
    $CountIntA = 0;
    $CountInt = 0;
    for($EachVeci in $VecLineDirM_All){
    $XYZsAxis = $EachVeci;
    for($EachFloat in $XYZsAxis){
    $SignPN[$CountInt] = `sign $EachFloat`;
    if($SignPN[$CountInt]==0){
    $SignPN[$CountInt] = 1;
    }
    $CountInt++;
    }
    $CountInt=0;
    $VecSIGNDirM[$CountIntA] =FloatToVec($SignPN);
    clear $XYZsAxis;
    $CountIntA++;
    }
    return $VecSIGNDirM;
    }
    proc matrix TwoPointMatrixPlusAxisWorld(vector $PtsVecii[], vector $EmptyDirVector[],  int $ZeroOne){
    $PtsVec = $PtsVecii;
    $MidPt = MidPoint($PtsVec[0], $PtsVec[1]);
    $Line_Y_zeroMain = PositiveDirectionLine($PtsVec[0], $PtsVec[1]);
    $CombA = 0;
    $CountIndexV = 0;
    for ($eachPointVd in $PtsVec){
    $Dir_VecA = FloatToVec (DirectionFN($eachPointVd, $MidPt));
    $VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    if($AdditR != 0.0){break;}else{
    $CountIndexV++;}
    }
    if($CountIndexV == 1){
    $PtsVec = ReverseVectorArray($PtsVec);
    }
    $CamDirVecNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM",  0);
    $CamDirVecNormal= multiplyFloat(-1.0, $CamDirVecNormal);
    $DirLine = PositiveDirectionLine($PtsVec[0], $PtsVec[1]);
    $Vperp = crossProduct( $DirLine, $CamDirVecNormal, 0, 0 );
    $BInomalV = FloatToVec(MultLenToDirAddToPoint(2, $Vperp, $PtsVec[0]));
    $BInomalVDirLine = PositiveDirectionLine($PtsVec[0], $BInomalV);
    $BInomalV = FloatToVec(MultLenToDirAddToPoint(4, $BInomalVDirLine, $PtsVec [0]));
    $TangentV = FloatToVec(MultLenToDirAddToPoint(4,$CamDirVecNormal,  $PtsVec[0]));
    $norm = FloatToVec($CamDirVecNormal);
    $bi = $BInomalVDirLine;
    $tan = $DirLine;
    matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $DirectionVector[0] =  $norm;
    $DirectionVector[1] =  $bi;
    $DirectionVector[2] =  $tan;
    $EmptyDirVector = $DirectionVector;

    $bi_two = `cross $tan $norm`;
    if($ZeroOne== 0){
    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;
    ($bi.x), ($bi.y), ($bi.z),  0.0;
    ($tan.x), ($tan.y), ($tan.z), 0.0;
    0.0, 0.0, 0.0, 1.0  >>;
    }
    if($ZeroOne== 1){
    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;
    ($bi.x), ($bi.y), ($bi.z),  0.0;
    ($tan.x), ($tan.y), ($tan.z), 0.0;
    $MidPt[0], $MidPt[1], $MidPt[2], 1.0  >>;
    }
    $MatrizFloati = MatrixToFloat($mI);
    return $mI;
    }
    proc matrix TwoPointMatrix(vector $FixVecii[]){
    $FixVeci = $FixVecii;
    $LineAMain =FloatToVec (DirectionFN($FixVeci[0], $FixVeci[1]));
    $MidPt = MidPoint($FixVeci[0], $FixVeci[1]);
    $LineAMain = PositiveDirectionLine($FixVeci[0], $FixVeci[1]);
    $CombA = 0;
    $CountIndexV = 0;
    for ($eachPointVd in $FixVeci){
    $DirMTestVec = FloatToVec (DirectionFN($eachPointVd, $MidPt));
    $VecLineDirM = ( $DirMTestVec+$LineAMain );
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    if($AdditR != 0.0){break;}else{
    $CountIndexV++;}
    }
    if($CountIndexV == 1){
    $FixVeci= ReverseVectorArray($FixVeci);
    }
    $ZeroA = <<0.0, 0.0, 0.0>>;
    $Va = $FixVeci[0];
    $Vb = $FixVeci[1];
    $FixVecB[0]= << $Va[0], 0.0, $Va[2] >>;
    $FixVecB[1]= << $Vb[0], 0.0, $Vb[2] >>;
    $LineA = PositiveDirectionLine($FixVecB[0], $FixVecB[1]);
    $pointYVec = ClosestPoint2LineVec($LineA, $FixVecB[0], $ZeroA);
    $LineDirYT = PositiveDirectionLine($pointYVec, $ZeroA);
    $DirLine = PositiveDirectionLine($FixVeci[0], $FixVeci[1]);
    $Vperp = crossProduct( $DirLine, $LineDirYT, 0, 0 );
    $BInomalV = FloatToVec(MultLenToDirAddToPoint(2, $Vperp, $FixVeci[0]));
    $BInomalVDirLine = PositiveDirectionLine($FixVeci[0], $BInomalV);
    $BInomalV = FloatToVec(MultLenToDirAddToPoint(4, $BInomalVDirLine, $FixVeci [0]));
    $TangentV = FloatToVec(MultLenToDirAddToPoint(4, $LineDirYT, $FixVeci[0]));
    $FloatDirMajor = $DirLine;
    $FDirNorAi = $LineDirYT;
    $DirNormi = $LineDirYT;
    $normal = $BInomalVDirLine;
    matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $norm = $LineDirYT;
    $bi = $BInomalVDirLine;
    $tan = $DirLine;
    $tan  = `unit << ($tan.x), ($tan.y), ($tan.z) >>`;
    $norm = `unit << ($norm.x), ($norm.y), ($norm.z) >>`;
    $bi = `unit $bi`;

    $tan = FloatToVec(MakeCleanFloatsZ($tan));
    $norm = FloatToVec(MakeCleanFloatsZ($norm));
    $bi = FloatToVec(MakeCleanFloatsZ($bi));
    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;
    ($bi.x), ($bi.y), ($bi.z),  0.0;
    ($tan.x), ($tan.y), ($tan.z), 0.0;
    $MidPt[0], $MidPt[1], $MidPt[2], 1.0  >>;
    $mI = MatrixCleanNegZero($mI);
    $MatrizFloati = MatrixToFloat($mI);
    return $mI;
    }
    proc float [] ClosestPoint2Line(float $DirectionLineF[], float $PointOnLine[], float  $PointN[]){
    $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    $VecLineDir = PositiveDir($DirectionLineF);
    $VecLineDirM = $VecLineDiri-$VecLineDir;
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    if($AdditR != 0.0){
    $MultDirOne = multiplyFloat(1.0, $DirectionLineF);
    $AddMultF = AddFloats($PointOnLine, $MultDirOne);
    $FDirNorA = Normal3Points($PointOnLine, $AddMultF, $PointN);
    $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    $MultDirMx = multiplyFloat($DistToLineSTart, $FDirNorA);
    $AddMultMiiFx = AddFloats($PointOnLine, $MultDirMx);
    $FDirNorB = Normal3Points($PointOnLine, $AddMultMiiFx,  $AddMultF);
    $MultDirMxz = multiplyFloat($DistToLineSTart,  $FDirNorB);
    $AddMultMiiFxz = AddFloats($PointOnLine, $MultDirMxz);
    $locsA = lineIntersection($PointN, $FDirNorB, $PointOnLine,  $DirectionLineF);
    }else{$locsA =  $PointN ;}
    return $locsA;
    }
    proc vector ClosestPoint2LineVec(float $DirectionLineF[], float $PointOnLine[], float  $PointN[]){
    $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    $VecLineDir = PositiveDir($DirectionLineF);
    $VecLineDirM = $VecLineDiri-$VecLineDir;
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    if($AdditR != 0.0){
    $MultDirOne = multiplyFloat(1.0, $DirectionLineF);
    $AddMultF = AddFloats($PointOnLine, $MultDirOne);
    $FDirNorA = Normal3Points($PointOnLine, $AddMultF, $PointN);
    $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    $MultDirMx = multiplyFloat($DistToLineSTart, $FDirNorA);
    $AddMultMiiFx = AddFloats($PointOnLine, $MultDirMx);
    $FDirNorB = Normal3Points($PointOnLine, $AddMultMiiFx,  $AddMultF);
    $MultDirMxz = multiplyFloat($DistToLineSTart,  $FDirNorB);
    $AddMultMiiFxz = AddFloats($PointOnLine, $MultDirMxz);
    $locsA = lineIntersection($PointN, $FDirNorB, $PointOnLine,  $DirectionLineF);
    $VlocA = <<$locsA[0],$locsA[1],$locsA[2]>>;
    }else{$VlocA = FloatToVec($PointN);}
    return $VlocA;
    }
    proc int Partition(float $a[], int $Index[], int $p, int $r) {
    $x = $a[$r];
    $xIndex = $Index[$r];
    $j = $p - 1;
    for (  $i = $p; $i < $r; $i++) {
    if ($x <= $a[$i]) {
    $j = $j + 1;
    $temp = $a[$j];
    $tempIndex = $Index[$j];
    $a[$j] = $a[$i];
    $Index[$j] = $Index[$i];
    $a[$i] = $temp;
    $Index[$i] = $tempIndex;
    }
    }
    $a[$r] = $a[$j + 1];
    $Index[$r] = $Index[$j + 1];
    $a[$j + 1] = $x;
    $Index[$j + 1] = $xIndex;
    return ($j + 1);
    }
    proc  quickSort(float $a[], int $Index[], int $p, int $r) {
    if ($p < $r) {
    $q = Partition($a, $Index, $p, $r);
    quickSort($a, $Index, $p, $q - 1);
    quickSort($a, $Index, $q + 1, $r);
    }
    }
    proc float [] Normal3Points(float $p1[],float $p2[],float $p3[]){
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		 $p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		 $p1p3[2]= $p3[2]-$p1[2];
    $normalV = crossProduct( $p1p2, $p1p3, 0, 0 );
    $normal = `unit $normalV[0]`;
    return $normal;
    }
    proc int FindLineCross( vector $Vecbv[], vector $Vecbvi[]){
    $DirecA = FloatToVec(DirectionFN($Vecbv[0],$Vecbvi[1]));
    $DirecB = FloatToVec(DirectionFN($Vecbv[1],$Vecbvi[0]));
    $centerCross = lineIntersection( $Vecbv[0], $DirecA, $Vecbv[1], $DirecB);
    $trueOrFalse = IsPointInLine ($Vecbv[0], $Vecbv[1], $centerCross);
    return $trueOrFalse;
    }
    proc int IsPointInLine (float $a[], float $b[], float $c[]){
    $VecC[0] = FloatToVec($a);
    $VecC[1] = FloatToVec($b);
    $VecC[2] = FloatToVec($c);
    $DPi = (distance2Pts($VecC[0], $VecC[1]))/2.0;
    $MidPoint = FloatToVec (MidPoint($VecC[0], $VecC[1]));
    $DPiMid = distance2Pts($VecC[0], $MidPoint);
    $DPa = distance2Pts( $MidPoint, $VecC[2]);
    $returnVal = 0;
    if($DPa<=$DPiMid){
    $returnVal=1;}
    print $returnVal;
    return $returnVal;
    }
    proc float[] DirectionFN(float $posAZ[], float $posBZ[]){
    $Vai = << $posAZ[0], $posAZ[1], $posAZ[2] >> ;
    $Vbi = << $posBZ[0],  $posBZ[1], $posBZ[2] >> ;
    $xi = $Vai.x;
    $yi = $Vai.y;
    $zi = $Vai.z;
    $x = $Vbi.x;
    $y = $Vbi.y;
    $z = $Vbi.z;
    $u = $xi - $x;
    $v = $yi - $y;
    $w = $zi - $z;
    $VbiUnit = << $u, $v, $w >> ;
    $VbiUnitA = `unit $VbiUnit`;

    $UnitDirection = $VbiUnitA;
    return $UnitDirection;
    }
    proc vector PositiveDir(float $VecOrFloatA[]){
    $VecA = FloatToVec($VecOrFloatA);
    $Va = $VecA;
    $xi = $Va.x;
    $yi = $Va.y;
    $zi = $Va.z;
    $e = 1;
    if(`sign $xi` == -1){
    $e = -1.0;
    }
    if((`sign $xi` == -1)&&(`sign $yi` == -1)){
    $e = -1.0;
    }
    if((`sign $xi` == -1)&&(`sign $zi` == -1)){
    $e = -1.0;
    }
    $Y = ($e*$xi);
    $U = ($e*$yi);
    $V = ($e*$zi);
    $YUV = << $Y, $U, $V>>;
    return $YUV;
    }
    proc vector PositiveDirectionLine(vector $VecA, vector $VecB){
    $Va = $VecA;
    $Vb = $VecB;
    $xi = $Va.x;
    $yi = $Va.y;
    $zi = $Va.z;
    $x = $Vb.x;
    $y = $Vb.y;
    $z = $Vb.z;
    $u = $xi - $x;
    $v = $yi - $y;
    $w = $zi - $z;
    $e = 1.0;
    if(`sign $v` == -1){
    $e = -1.0;
    }
    if((`sign $v` == -1)&&(`sign $u` == -1)){
    $e = -1.0;
    }
    if((`sign $v` == -1)&&(`sign $w` == -1)){
    $e = -1.0;
    }
    $Y = $u/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $U = $v/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $V = $w/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $YUV = << $Y, $U, $V>>;
    return $YUV;
    }
    proc PAUSEn(int $n){
    $i = 0;
    while($i < $n){
    eval("playButtonStepForward");
    $i++;
    }
    }
    proc  float [] Circle3PtsM(float $p1[], float $p2[], float $p3[]){
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );
    $FloatPosZero = {0, 0, 0};
    $FloatDirection = DirectionF($FloatPosZero, $normal);
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    $radiusZ = distance2Pts( $p1, $center );
    $CenterRadius = $center;
    $CenterRadius[`size($CenterRadius)`]= $radiusZ;
    return $CenterRadius;
    }
    proc  float [] Circle3PtZFloats(float $p1[], float $p2[], float $p3[]){
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    $radiusZ = distance2Pts( $p1, $center );
    $CenterRadius = $center;
    $CenterRadius[`size($CenterRadius)`]= $radiusZ;
    return $CenterRadius;
    }
    proc float [] Circle3PtZFloatsI(float $p1[], float $p2[], float $p3[]){
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $p1p4[0] = $p2[0]-$p3[0]; 		$p1p4[1] = $p2[1]-$p3[1]; 		$p1p4[2]= $p2[2]-$p3[2];
    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );
    $FloatPosZero = {0, 0, 0};
    $FloatDirection = DirectionF($FloatPosZero, $normal);
    $MultDirP = multiplyFloat(2, $FloatDirection);
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $mid3 = midPoint2Pts( $p2, $p3 );
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $perp_p1p4 = crossProduct( $normal, $p1p4, 0, 1 );
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    $FloatDirPerpCenter = DirectionF($center, $mid3);
    $FloatDirPerpCenterB = DirectionF($center,$mid1);
    $FloatDirPerpCenterC = DirectionF($center,$mid2);
    $FloatDirPointAB = DirectionF($p1, $p2);
    $FloatDirPointBC = DirectionF($p2, $p3);
    $FloatDirPointAC = DirectionF($p1, $p3);
    $center6 = lineIntersection( $p1, $FloatDirPerpCenter, $p2, $FloatDirPointBC );
    $center7 = lineIntersection( $p3,  $FloatDirPerpCenterB, $p1, $FloatDirPointAB );
    $center8 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    curve2points($center, $mid1);
    curve2points($center,$mid2);
    curve2points($center,$mid3);
    $center9 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPerpCenter );
    $OrthoCenterCir = midPoint2Pts( $center9, $center );
    $Radius2HalfTimes2 = (distance2Pts( $center9, $center ))*2;
    $Radius2BHalf = (distance2Pts( $center9, $center ));
    $radiusZ = distance2Pts( $p1, $center );
    $Radius3Half = $radiusZ/2;
    $circlesItemA[0] = Circles_Direction($OrthoCenterCir, $FloatDirection, $Radius3Half);
    $circlesItem[0] = Circles_Direction($center, $FloatDirection, $radiusZ);
    $radiusZ = distance2Pts( $p1, $center );
    $CenterRadius = $center;
    $CenterRadius[`size($CenterRadius)`]= $radiusZ;
    return $CenterRadius;
    }
    proc vector [] VecArrayDiff(int $IndeXxz[]){
    global vector $AllVecsG[];
    global vector $WorkingAllVecsG[];
    $VecS = $AllVecsG;
    $Ixx = 0;
    $EIndex = $IndeXxz;
    $EIndex = `sort $EIndex`;
    $Ii = 0;
    for ($eachVc in $VecS){
    $one =$EIndex[$Ii];
    if(!($Ixx==$one)){
    $newVec[`size($newVec)`] = $VecS[$Ixx];
    }else{$Ii++;}
    $Ixx++;
    }
    $WorkingAllVecsG = $newVec;
    return $newVec;
    }
    proc vector [] VecArrayInclude(int $IndeXxz[]){
    global vector $AllVecsG[];
    global vector $WorkingAllVecsG[];
    $VecS = $AllVecsG;
    $Ixx = 0;
    $EIndex = $IndeXxz;
    $EIndex = `sort $EIndex`;
    $Ii = 0;
    for ($eachVc in $VecS){
    $one =$EIndex[$Ii];
    if(($Ixx==$one)){
    $newVec[`size($newVec)`] = $VecS[$Ixx];
    }else{$Ii++;}
    $Ixx++;
    }
    $WorkingAllVecsG = $newVec;
    return $newVec;
    }
    proc string AddItemString(int $iN, string $NumLetorSy){
    $Xz = 0;
    $AddItem = "";
    while($iN > $Xz){
    $AddItem+= $NumLetorSy;
    $Xz++;
    }
    return $AddItem;
    }
    proc StereoCurveZ(string $CurveItemZai, string $CurveItemZbi){
    global string $StereoCurveZ[];
    global string $VanishingPointsLinesTempGuides[];
    global int $addNumbersA;
    global float $VanishingPointGlobal[];
    global string $PlaneCurveS[];
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;
    $IsOrthoLineTrue =0;
    $SnapR = 2.59;
    $Smooth = 398;
    $DiffSumTol = 97.95;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 1 -tol 0.05 $CurveItemZai;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 1 -tol 0.05 $CurveItemZbi;
    clear $AllLocPositionsZi;
    $AllLocPositionsZi = VecCurveCvs( $CurveItemZai);
    $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    ResetTranslation({$newPlaneCurveA});
    delete $CurveItemZai;
    $CurveItemZai = $newPlaneCurveA;
    clear $AllLocPositionsZi;
    $AllLocPositionsZi = VecCurveCvs( $CurveItemZbi);
    $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    ResetTranslation({$newPlaneCurveA});
    delete $CurveItemZbi;
    $CurveItemZbi = $newPlaneCurveA;
    $VecCurEndsa = VecCurveEnds({$CurveItemZai});
    $VecCurEndsb = VecCurveEnds({$CurveItemZbi});
    $StereoCurveZ[0]= $CurveItemZai;
    $StereoCurveZ[1]= $CurveItemZbi;
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveCvs($CurveItemZai );
    clear $PositionsZ_B;
    $PositionsZ_B = VecCurveCvs($CurveItemZbi );
    clear $VecPtsMirrorA;
    clear $VecPtsMirrorB;
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
    $CamDirVecNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $MultDirCam = multiplyFloat(-1, $CamDirVecNormal);
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    clear $VecPtsMirrorEnds_A;
    clear $VecPtsMirrorEnds_B;
    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);
    $EpipolPosCamM = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;
    $MidPosFCam = $CamPlane1;
    $FloatDirEpipol = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    $FloatDirEpipolB = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
    $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
    $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);
    $DistTOEpipol_CurEndA = distance2Pts($PointN_Epi, $VecCurEndsb[0]);
    $DistTOEpipol_CurEndB = distance2Pts($PointN_EpiB, $VecCurEndsb[0]);
    $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
    $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
    $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;
    $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
    $BCDiff = abs($BCurEndB - $BCurEndBNN);
    $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd ;
    $BCDiffi = abs($BCurEndB - $BCurEndBNNi);
    $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);
    $FloatDirEndPtsA = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
    $EulerAngleA = EulerAngB($FloatDirEndPtsA, $FloatDirEpipol);
    $EulerAngle_A = $EulerAngleA[3];
    $FloatDirEndPtsB = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
    $EulerAngleB = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);
    $EulerAngle_B = $EulerAngleB[3];
    $FloatDirEndPtsAi = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
    $EulerAngleAi = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);
    $EulerAngle_Ai = $EulerAngleAi[3];
    $FloatDirEndPtsBi = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
    $EulerAngleBi = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);
    $EulerAngle_Bi = $EulerAngleBi[3];
    $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
    $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;
    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);

    $Vecbv  = $VecCurEndsa;
    $Vecbvi = $VecCurEndsb;
    $IfTrue = FindLineCross( $Vecbv , $Vecbvi );
    $weighedtFindings = 0;
    $weighedtFindingsZ = 0;
    $weighedtFindingsN = 0;
    if($IfTrue=1){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;
    }
    if($IntIfNearZero==1){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}
    if($EulerAngle_AB<$EulerAngle_AiBi){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}

    $LengCRV_a = `arclen $CurveItemZai`;
    $CRV_ENDSi = $VecCurEndsa;
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
    //float $DiffMathA = ($LengCRV_a-$DistEndsi) / ($DistEndsi/100.0);

    $LengCRV_b = `arclen $CurveItemZbi`;
    $CRV_ENDSii = $VecCurEndsb;
    $DistEndsii = distance2Pts($CRV_ENDSii[0], $CRV_ENDSii[1]);
    $DiffMathB = $DistEndsii / ($LengCRV_b/100.0);

    $PerDiffSum = ($DiffMathA+$DiffMathB)/2.0;

    //print (" DiffMathA " +$DiffMathA + " DiffMathB " +$DiffMathB +"\n");
    //if(($DiffMathA> 96.5) && ($DiffMathB > 96.5)){
    //$PerDiffSum =99;
    //}else{$PerDiffSum =1;}

    $triggerStraitCRV = 0;
    $triggerNoTransENDA = 0;
    $triggerNoTransENDB = 0;
    $First_Second_Both_None = 0;
    //print ("START FindIfCurveIsOrthoEpipol" +"\n");
    $XYZdirectL[0] = << 1,0,0>>;
    $XYZdirectL[1] = << 0,1,0>>;
    $XYZdirectL[2] = << 0,0,1>>;
    $trigger_straitC = 0;
    if( $PerDiffSum>$DiffSumTol){
    print ("FIRST IF : ENGAGED PerDiffSum" +$PerDiffSum +"\n");
    print ("ENGAGED FindIfCurveIsOrthoEpipol" +"\n");
    $triggerStraitCRV=1;
    $DDirEpipol = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
    $MidCurveA  = MidPoint($VecCurEndsa[0], $VecCurEndsa[1]);
    $MidCurveB  = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);
    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);

    $EpipolD = $DDirEpipolXYZ;
    $Trueii = 0;

    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];

    }
    print ("IsOrthoLineTrue = "+$IsOrthoLineTrue+"\n");

    if($weighedtFindingsZ<$weighedtFindingsN){
    /////////////////////////////REMOVED

    /////////////////////////////
    //if(($DistB<$DistA)||($weighedtFindingsZ<$weighedtFindingsN)){
    if( ($weighedtFindingsZ<$weighedtFindingsN)){

    cycleBackgroundColor;
    $PositionsZ_B = ReverseVectorArray($PositionsZ_B);
    $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);
    $VecCurEndsb = ReverseVectorArray($VecCurEndsb);
    $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
    }
    }

    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
    $queryLocCurveEnds3D = `sort $queryLocCurveEnds3D`;
    $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
    $TrackAllExisting3DCrv = CreatePairIntIndex($SizeCrvi);
    $LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;
    $SizeCrvR = `size($LayerCurvesRangeA)` ;
    $triggerNoTrans = 0;
    $triggerNoTransA = 0;
    $triggerNoTransB = 0;
    $triggerNoTrans = 0;
    clear $IntersectEnds_Ax;
    $iia = 0;

    if(!(`size($queryLocCurveEnds3D)` > 2)){

    if($PerDiffSum >$DiffSumTol){
    print ("ENGAGED PerDiffSum " +$PerDiffSum +"\n");
    print (" MAKING STRAIT  " +"\n");
    $iis = 0;
    for ($eachVecx in  $VecCurEndsb){
    $XIntersect_Ax[$iis] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsb[$iis], $CamPos_M, $VecPtsMirrorEnds_A[$iis]));
    $iis++;
    }
    $XIntersect_Ax[2] =  $XIntersect_Ax[1];
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    $XIntersect_Ax[0] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[0]);
    $XIntersect_Ax[2] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[2]);
    $PositionsZ_Bii= $XIntersect_Ax;
    $PositionsZ_Aii= VecPtsToZMirrorPts($PositionsZ_Bii);
    $ThefirstCurve = VecArrayToCurve($XIntersect_Ax);
    $PtsMirrorAi= VecPtsToZMirrorPts($XIntersect_Ax);
    $ThefirstCurvei = VecArrayToCurve($PtsMirrorAi);

    $trigger_straitC =1;
    }
    }

    ////////////
    if(`size( $queryLocCurveEnds3D)`>2){

    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);
    for ($eachVecx in  $VecCurEndsa)
    {
    $IntersectEnds_Ax[$iia] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsa[$iia], $CamPos_M, $VecPtsMirrorEnds_B[$iia]));
    $iia++;
    }

    $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[0]);
    $AllLocsi = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    $AllLocs_String = IntArrayToStringArray($AllLocsi);
    $newOrdersZA = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    $EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
    $New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
    $Near_index_A = $New_AllLocs_A[0];
    $Distance_A = $distToCurveE_A[$Near_index_A];
    $Found_pt_A = $LocCurveEndsVec3D[$Near_index_A];
    $newOrdersZAM = $Found_pt_A;
    $newOrdersZAM[0] = $Found_pt_A[0] *-1;
    $distToCurveE_B = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[1]);
    $newOrdersZB = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    $EmptyStringNewOrderB = ReverseStringArray($EmptyStringNewOrderB);
    $New_AllLocs_B = ArrayToIntList($EmptyStringNewOrderB);
    $Near_index_B = $New_AllLocs_B[0];
    $Distance_B = $distToCurveE_B[$Near_index_B];
    $Found_pt_B = $LocCurveEndsVec3D[$Near_index_B];
    $newOrdersZBM = $Found_pt_B;
    $newOrdersZBM[0] = $Found_pt_B[0] *-1;

    $PointsA[0] = FloatToVec($Found_pt_A);
    $PointsA[1] = FloatToVec($Found_pt_B);
    $PointsB[0] = FloatToVec($newOrdersZAM); // negative mirror of first endpoint of first curve
    $PointsB[1] = FloatToVec($newOrdersZBM);

    $VecOnPlaneA = VecPointsToCameraPlane($PointsA);
    $VecOnPlaneB = VecPointsToCameraPlane($PointsB);

    $NewFoundLocs[0] = $queryLocCurveEnds3D[$Near_index_A];
    $NewFoundLocs[1] = $queryLocCurveEnds3D[$Near_index_B];

    print($NewFoundLocs[0]+"\n");
    print($NewFoundLocs[1]+"\n");
    // string $XLocsA = "LOCcurve259START";
    // string $XLocsB = "LOCcurve200START";

    $XLocsA = $NewFoundLocs[0];
    $XLocsB = $NewFoundLocs[1];

    $START_END[0] = gmatch ((match("END",$XLocsA)),"END");
    $START_END[1] = gmatch ((match("END",$XLocsB)),"END");
    $CrvNA[0] =$CrvNA[1]="curve";
    $Na = (match ("[0-9]+", $XLocsA));
    $Nb = (match ("[0-9]+", $XLocsB));
    $CrvNA[0] = $CrvNA[0]+$Na;
    $CrvNA[1] = $CrvNA[1]+$Nb;

    select -r $CrvNA;
    PAUSEn(1);





    $arrayCurvesNear[0] = ("Plane"+$NewFoundLocs[0]);
    $arrayCurvesNear[1] = ("Plane"+$NewFoundLocs[1]);



    $NewFoundLocs = $arrayCurvesNear;
    $LocOnPlaneVec = PointArray($NewFoundLocs);
    $distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocOnPlaneVec[0]);
    $distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocOnPlaneVec[1]);
    $TXI = << -1.0 , 1.0, 1.0>>;
    $LoCz_3D[0] = MultVec($IntersectEnds_Ax[0],$TXI);
    $LoCz_3D[1] = MultVec($IntersectEnds_Ax[1], $TXI);

    ////////////////////////
    $DistToIntersectTOnear[0] = distance2Pts($IntersectEnds_Ax[0], $PointsA[0]);
    $DistToIntersectTOnear[1] = distance2Pts($IntersectEnds_Ax[1], $PointsA[1]);
    $DistToIntersectTOnear[2] = distance2Pts($LoCz_3D[0], $PointsB[0]);
    $DistToIntersectTOnear[3] = distance2Pts($LoCz_3D[1], $PointsB[1]);

    $distToPlaneLoc3D[0] = distance2Pts($VecCurEndsa[0], $PointsA[0]);
    $distToPlaneLoc3D[1] = distance2Pts($VecCurEndsa[1], $PointsA[1]);
    $distToPlaneLoc3D[2] = distance2Pts($VecCurEndsb[0], $PointsB[0]);
    $distToPlaneLoc3D[3] = distance2Pts($VecCurEndsb[1], $PointsB[1]);
    //////////////////////////

    $DiffMathA = $DistToIntersectTOnear[0]/ ($distToPlaneLoc3D[0]/100.0);
    $DiffMathB = $DistToIntersectTOnear[1] / ($distToPlaneLoc3D[1]/100.0);
    $DiffMathAm = $DistToIntersectTOnear[2]/ ($distToPlaneLoc3D[2]/100.0);
    $DiffMathBm = $DistToIntersectTOnear[3] / ($distToPlaneLoc3D[3]/100.0);

    $relativeDistanceA = ($DiffMathA+$DiffMathAm)/2.0;
    $relativeDistanceB = ( $DiffMathB+$DiffMathBm)/2.0;
    //////////////
    //REMOVED AND PLACE BELOW
    /////////////

    //print ("relativeDistanceA" + $relativeDistanceA+"\n");
    //print ("relativeDistanceB" + $relativeDistanceB+"\n");

    if($relativeDistanceA<$SnapR){
    $triggerNoTransA++;
    }
    if($relativeDistanceB <$SnapR){
    $triggerNoTransB++;
    }

    if(!($relativeDistanceA<$SnapR)){
    $VecOnPlaneA[0] = $VecCurEndsa[0];
    $VecOnPlaneB[0] = $VecCurEndsb[0];
    $triggerNoTransENDA=1;
    }else{$triggerNoTrans++;
    $First_Second_Both_None =0;
    }

    if(!($relativeDistanceB<$SnapR)){
    $VecOnPlaneA[1] = $VecCurEndsa[1];
    $VecOnPlaneB[1] = $VecCurEndsb[1];
    $triggerNoTransENDB=1;
    }else{$triggerNoTrans++;
    $First_Second_Both_None =1;

    if($triggerNoTransENDA==0){ $First_Second_Both_None =-2;}

    }


    if($triggerNoTrans==0){
    $First_Second_Both_None =-1;}

    //if(($triggerNoTransENDA +$triggerNoTransENDB)== 2){
    //}

    //if(($triggerNoTransENDA +$triggerNoTransENDB)== 0){
    //}

    $ConnectedEnds = $triggerNoTransENDA + $triggerNoTransENDB;
    if($triggerNoTransENDA==1){
    $UnconnectedEnds[0]= $VecOnPlaneA[0];
    $UnconnectedEnds[1]= $VecOnPlaneB[0];
    }else{$UnconnectedEnds[0]= $VecOnPlaneA[1];
    $UnconnectedEnds[1]= $VecOnPlaneB[1];}

    clear $arrayCurvesNearA;
    clear $arrayCurvesNearA;
    $AddAB = $triggerNoTransA+$triggerNoTransB;

    if($triggerNoTrans!=0){

    $PositionsZ_A = VecCurveCvs($CurveItemZai );
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEndsa,$VecOnPlaneA, $PositionsZ_A);
    $PositionsZ_Bi = Matrix_Curve_TranslationCC($VecCurEndsb, $VecOnPlaneB, $PositionsZ_B);
    clear $VecPtsMirrorA;
    $VecPtsMirrorA= VecPtsToZMirrorPts( $PositionsZ_Ai);
    clear $VecPtsMirrorB;
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_Bi);
    $PositionsZ_A = $PositionsZ_Ai;
    $PositionsZ_B = $PositionsZ_Bi;
    cycleBackgroundColor;
    }

    }

    //print (" IsOrthoTrueZi Eq  "+$IsOrthoLineTrue +"\n");

    if(($triggerNoTrans==0)&&($PerDiffSum >$DiffSumTol)){


    $iis = 0;
    for ($eachVecx in  $VecCurEndsb){
    $XIntersect_Ax[$iis] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsb[$iis], $CamPos_M, $VecPtsMirrorEnds_A[$iis]));
    $iis++;
    }
    $XIntersect_Ax[2] =  $XIntersect_Ax[1];
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    $XIntersect_Ax[0] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[0]);
    $XIntersect_Ax[2] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[2]);

    $PositionsZ_Bii= $XIntersect_Ax;
    $PositionsZ_Aii= VecPtsToZMirrorPts($PositionsZ_Bii);

    $ThefirstCurve = VecArrayToCurve($XIntersect_Ax);
    $PtsMirrorAi= VecPtsToZMirrorPts($XIntersect_Ax);
    $ThefirstCurvei = VecArrayToCurve($PtsMirrorAi);

    $trigger_straitC =1;

    }

    if($triggerNoTrans!=0){
    print ("triggerNoTrans Doesnt not Eq ZERO" +"\n");
    if($IsOrthoLineTrue==1){
    print ("IsOrthoLineTrue Eq ONE" +"\n");

    //############HERE

    if($AxisOrthoLine!=0){

    if($First_Second_Both_None>=0){

    $FloatDirEpipol = DirectionFN($VecOnPlaneA[$First_Second_Both_None], $FoundEpipol);
    $FloatDirEpipolB= DirectionFN($VecOnPlaneB[$First_Second_Both_None], $FoundEpipol);
    }

    }

    if($AxisOrthoLine==0){
    print ("HERE IS THE SPOT" +"\n");

    $lineEPointA = MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);
    $Xdirection = << 1.0,0.0,0.0>>;
    $Intersect_LineB_a = FloatToVec (lineIntersection($PointsA[$First_Second_Both_None], $Xdirection, $lineEPointA,(DirectionFN( $CamPos_A,$lineEPointA)) ));
    Loc $Intersect_LineB_a;
    $Point3DA = $Intersect_LineB_a;
    $Point3DAM = {($Point3DA[0]*-1), $Point3DA[1],$Point3DA[2]};

    }
    if($AxisOrthoLine!=0){
    print ("AxisOrthoLine Doesnt not Eq ZERO" +"\n");
    if($First_Second_Both_None>=0){
    if($First_Second_Both_None==1){
    print ("First_Second_Both_None Eq ONE! " +"\n");
    $PairInt={0,1};
    }else{ $PairInt={2,3};
    print ("First_Second_Both_None NOT Eq ONEZZZ! " +"\n");
    }
    }
    }


    //PROBLEM HERE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if($First_Second_Both_None>=0){
    if($AxisOrthoLine!=0){

    $Intersect_BX= VecPtsToZMirrorPts($IntersectEnds_Ax);

    $PairVectors[0]=FloatToVec(FloatPointsToCamPlane($IntersectEnds_Ax[0]));
    $PairVectors[1]= FloatToVec(FloatPointsToCamPlane($Intersect_BX[0]));
    $PairVectors[2]=FloatToVec(FloatPointsToCamPlane($IntersectEnds_Ax[1]));
    $PairVectors[3]= FloatToVec(FloatPointsToCamPlane($Intersect_BX[1]));
    $EpipolXLine = DirectionFN( $MidEpipolPosFCam, $PairVectors[$PairInt[0]]) ;
    print ("HERE IS THE SPOT AAAAAA" +"\n");
    }else{


    $PairVectors[0]=FloatToVec(FloatPointsToCamPlane($Point3DA));
    $PairVectors[1]= FloatToVec(FloatPointsToCamPlane($Point3DAM));
    $PairVectors[2]=FloatToVec(FloatPointsToCamPlane($Point3DA));
    $PairVectors[3]= FloatToVec(FloatPointsToCamPlane($Point3DAM));
    $EpipolXLine = DirectionFN( $MidEpipolPosFCam, $PairVectors[$PairInt[0]]) ;
    print ("HERE IS THE SPOT BBBBBB" +"\n");
    }


    $Intersect_LineB_a = FloatToVec (lineIntersection($VecOnPlaneA[$First_Second_Both_None], $FloatDirEpipol, $MidEpipolPosFCam,$EpipolXLine));
    $Intersect_LineB_b = FloatToVec (lineIntersection($VecOnPlaneB[$First_Second_Both_None], $FloatDirEpipolB, $MidEpipolPosFCam,$EpipolXLine));

    // Loc $Intersect_LineB_a;
    // Loc $Intersect_LineB_b;

    clear $PositionsZ_A;
    clear $PositionsZ_B;
    clear $VecPtsMirrorEnds_A;
    clear $VecPtsMirrorEnds_B;
    clear $VecPtsMirrorA;
    clear $VecPtsMirrorB;


    $PositionsZ_A[0] = $VecOnPlaneA[$First_Second_Both_None];
    $PositionsZ_A[1] = FloatToVec (MidPoint($VecOnPlaneA[$First_Second_Both_None],$Intersect_LineB_a));
    $PositionsZ_A[2] = $Intersect_LineB_a;
    $PositionsZ_B[0] = $VecOnPlaneB[$First_Second_Both_None];
    $PositionsZ_B[1] = FloatToVec (MidPoint($VecOnPlaneB[$First_Second_Both_None], $Intersect_LineB_b));
    $PositionsZ_B[2] = $Intersect_LineB_b;

    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);

    }





    }
    }

    if($trigger_straitC!=1){
    $iiz = 0;

    for ($eachVecx in  $VecPtsMirrorA)
    {
    $Intersect_A[`size($Intersect_A)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_B[$iiz], $CamPos_M, $VecPtsMirrorA[$iiz]));
    $iiz++;
    }

    if($triggerNoTrans==2){

    $CrvNormalA = CRVEndNormals( $CrvNA[0] );
    $CrvNormalB = CRVEndNormals( $CrvNA[1] );
    $aveNorm = unit(($CrvNormalA[$START_END[0]]+$CrvNormalB[$START_END[1]])/2.0);
    $MidPointC = ($Intersect_A[0]+$Intersect_A[`size($Intersect_A)`-1])/2.0;
    $DirectC = DirectionFN($Intersect_A[0], $MidPointC);

    //$Intersect_A= VecPointsToPlaneX($Intersect_A,$aveNorm,$MidPointC);
    $NormPts = (($aveNorm*2.5)+$MidPointC);
    $P1 = ClosestPoint2LineVecX($DirectC, $MidPointC, $NormPts);
    $NewNormal = (DirectionFN($NormPts, $P1));
    $Intersect_A=ProjectCrv2PlaneNormal($Intersect_A,$NewNormal,$MidPointC);
    }

    if(($triggerNoTransA+$triggerNoTransB)==1){
    /*
    $AB_endPts[$triggerNoTransA] =$Intersect_A[0] ;
    $AB_endPts[$triggerNoTransB] =$Intersect_A[`size($Intersect_A)`-1] ;
    //print ("HERE IS THE SPOT XXXX" +"\n");
    //print ("HERE IS THE SPOT XXXXHERE" +"\n");
    $NewFvec = VecEndsOrthoEqual($Intersect_A, $AB_endPts[1],  $AB_endPts[0], 8.5);
    if(`size($NewFvec)`!=0){
    $Intersect_A = $NewFvec;
    }
    */

    }

    $ThefirstCurve = VecArrayToCurve($Intersect_A);
    modifySelectedCurves smooth $Smooth 0;
    //float $arcL3 = (`arclen $ThefirstCurve`)*10.0;
    //SmoothCurvatureB3($arcL3);
    //vector $Intersect_ACD[];
    //$Intersect_ACD = VecCurveEps( $ThefirstCurve);
    $Intersect_B= VecPtsToZMirrorPts($Intersect_A);
    $ThefirstCurvei = VecArrayToCurve($Intersect_B);
    modifySelectedCurves smooth $Smooth 0;
    $EndrEndsa  = VecCurveEnds({$ThefirstCurvei});
    $EndsAtZero= isCurveEndAtZY($EndrEndsa);

    $EndsAtZero= isCurveEndAtZY($EndrEndsa);
    if($EndsAtZero>0){
    sets -include ZEdgeCurvesSet ({$ThefirstCurvei,$ThefirstCurve});
    }

    }
    $EndrEndsa = VecCurveEnds({$ThefirstCurvei});
    $EndsAtZero = isCurveEndAtZY($EndrEndsa);
    if($EndsAtZero>0){
    sets -include ZEdgeCurvesSet ({$ThefirstCurvei,$ThefirstCurve});
    }

    delete $VanishingPointsLinesTempGuides;
    delete $CurveItemZai $CurveItemZbi;
    clear $VanishingPointsLinesTempGuides;
    clear $StereoCurveZ;
    $addNumbersA =0;
    clear $VanishingPointGlobal;

    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $ThefirstCurve;
    smoothCurve -ch 0 -rpo 1 -s 95.60 ($ThefirstCurve +".cv [*]");
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $ThefirstCurvei;
    smoothCurve -ch 0 -rpo 1 -s 95.60 ($ThefirstCurvei +".cv [*]");
    //string $NewCircDX[];
    //string $NewCircD[] = {$ThefirstCurve,$ThefirstCurvei};
    //$NewCircDX = SphereDeform($NewCircD);
    //$ThefirstCurve = $NewCircDX[0];
    //$ThefirstCurvei = $NewCircDX[1];

    //$ThefirstCurve = Strait_ARC_or_FreeFormSS($ThefirstCurve, 5.5, 2.5 );


    //$ThefirstCurvei = Strait_ARC_or_FreeFormSS($ThefirstCurvei, 5.5, 2.5 );

    ResetTranslation({$ThefirstCurve});
    CurveIndexVecTracking({$ThefirstCurve});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ThefirstCurve;

    ResetTranslation({$ThefirstCurvei});
    CurveIndexVecTracking({$ThefirstCurvei});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ThefirstCurvei;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;

    }
    proc vector [] FlattenSnap(vector $Vec_A[], int $XYZvec ,float $Val){
    for($i=0;  $i < `size($Vec_A)`; $i++){
    $Vi= $Vec_A[$i];
    $xyz[0] = $Vi.x;
    $xyz[1] = $Vi.y;
    $xyz[2] = $Vi.z;
    $xyz[$XYZvec]= $Val;
    $ViNew[$i] = <<$xyz[0], $xyz[1], $xyz[2]>>;
    }
    return $ViNew;
    }
    proc vector MultVec(float $Va[],float $Vb[]){
    $PtsC[0]= $Va[0] * $Vb[0];
    $PtsC[1]= $Va[1] * $Vb[1];
    $PtsC[2]= $Va[2] * $Vb[2];
    $VecMult = << $PtsC[0],  $PtsC[1],  $PtsC[2] >>;
    return $VecMult;
    }
    proc AutoCurveScriptsTwoCurve(){
    global string $StereoCurveZ[];
    $itemAll = `ls -sl`;
    $ifCond_is_True = `ISSelectedTypeCurve`;
    if ($ifCond_is_True == 1){
    //   This is just the curve script you need this  to be where the switch is
    $item = `ls -sl`;
    $StereoCurveZ[`size($StereoCurveZ)`]= $item[0];
    EvalAddingCurves;
    creatStereoCurve;
    }
    }

    proc string[] CreateCAMforIntCurveScript(){
    CreateCameraOnly;
    rename ZCURVEModelingCAM;
    lookThroughModelPanelClipped ZCURVEModelingCAM  modelPanel4 0.001 1000;
    nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr  1 -n "LiveSurfaceB";
    editDisplayLayerMembers -noRecurse  layerYZYXPlains "LiveSurfaceB";
    clear $CamConeLocator;
    curve -d 3 -p 0 0 0 -p 0 0 -4 -p 0 0 -8 -p 0 0 - 12 -k 0 -k 0 -k 0 -k 12 -k 12 -k 12 -n  Deletethiscurve ;
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    $objectZcurv = `ls -sl`;
    $numCVs = `getAttr -size ($objectZcurv[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectZcurv[0] + ".cv[0]")  ;
    $CurveSelection[1] = ($objectZcurv[0] + ".cv[" +  $numCVrealNum + "]") ;
    for ($each in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $each  )`;
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n LocatorA`;
    ArrayInsertAtEnd($CamConeLocator,  $MakespaceLocator[0]);
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakespaceLocator[0];
    }
    $LocatorLoop = 0; int $LocatorLoopA = -1;
    while ($LocatorLoop++ < 7) {
    $LocatorLoopA = $LocatorLoopA +1;
    if ($LocatorLoopA == 0){
    clear $objectZ;
    stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
    stringArrayInsertAtIndex(1, $objectZ,  "LocatorA1");
    }
    if ($LocatorLoopA > 0){
    clear $objectZ;
    stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
    stringArrayInsertAtIndex(1, $objectZ,  $MakespaceLocator[0]);
    }
    if ($LocatorLoopA < 7){
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n  LocatorMiddleDistance`;
    ArrayInsertAtEnd($CamConeLocator,  $MakespaceLocator[0]);
    averagingNode($objectZ[0], $MakespaceLocator[0],  $objectZ[1]);
    }
    }
    ArrayInsertAtEnd( $CamConeLocator,  $CamConeLocator[0]);
    stringArrayRemoveAtIndex(0, $CamConeLocator);
    parentConstraint -mo -weight 1 ZCURVEModelingCAM  LocatorA1 ;
    parentConstraint -mo -weight 1 ZCURVEModelingCAM  LocatorA;
    delete  Deletethiscurve;
    align -atl -x Mid -y Mid -z Mid LiveSurfaceB  ZCURVEModelingCAM;
    move -r -os -wd 0 5 5 ZCURVEModelingCAM ;
    setAttr "ZCURVEModelingCAM.rotateX" -45;
    setAttr "LiveSurfaceB.rotateX" (`getAttr  ("ZCURVEModelingCAM" + ".rotateX")`+90);
    setAttr "LiveSurfaceB.rotateY" `getAttr  ("ZCURVEModelingCAM" + ".rotateY")`;
    setAttr "LiveSurfaceB.rotateZ" `getAttr  ("ZCURVEModelingCAM" + ".rotateZ")`;
    align -atl -x Mid -y Mid -z Mid LiveSurfaceB  ZCURVEModelingCAM;
    move -r -os -wd 0 -0.7 0 LiveSurfaceB ;
    move -r -os -wd 0 0 0.210031 LiveSurfaceB ;
    parentConstraint -mo -weight 1 ZCURVEModelingCAM  LiveSurfaceB;
    setAttr "ZCURVEModelingCAM.translateX" 48 ;
    setAttr "ZCURVEModelingCAM.translateY" 41 ;
    setAttr "ZCURVEModelingCAM.translateZ" 48 ;
    setAttr "ZCURVEModelingCAM.rotateX" -25 ;
    setAttr "ZCURVEModelingCAM.rotateY" 45;
    setAttr "ZCURVEModelingCAM.rotateZ" 0;
    return $CamConeLocator;
    }



}


/******************************************************************************
 * @procedure    VecPointsToCameraPlane
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $V : vector[]
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecPointsToCameraPlane(vector $V[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $C1;
    vector $V[];
    vector $p = `xform -q -ws -t "LiveSurfaceB"`;
    vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
    vector $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    print $PtsVec;
    6.513704 -1.022943 4.744769
    // Result: <<65.077678, 30.853927, 35.481502>>  //
    // Result: <<71.591382, 29.830984, 40.226271>>  //

    $V= $vecRs;

    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $C1=0;
    for($e in $V){

    $e=$V[0];

    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    ///both maybe redundant

    $P1 = ClosestPoint2LineVec($n1, $p, $e);


    $F4 = $e+($D1*$F3);

    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);


    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));

    $C1++;
    }
    return $O;

}


/******************************************************************************
 * @procedure    FloatPointsToCamPlane
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $LocPos1 : float[]
 *
 * @returns      float []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] FloatPointsToCamPlane(float $LocPos1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $C1;
    float $R[] = $O;
    vector $p = `xform -q -ws -t "LiveSurfaceB"`;
    vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
    vector $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $C1=0;
    $e=FloatToVec( $LocPos1);
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+($D1*$F3);
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;

    $R = $O;
    return $R;

}


/******************************************************************************
 * @procedure    screenSpaceGetMatrix
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $attr : string
 *
 * @returns      matrix
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix screenSpaceGetMatrix(string $attr)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $v[] = `getAttr $attr`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $v = `getAttr $attr`;
    matrix $mat[4][4]=<<$v[0], $v[1], $v[2], $v[3];
    $v[4], $v[5], $v[6], $v[7];
    $v[8], $v[9], $v[10], $v[11];
    $v[12], $v[13], $v[14], $v[15]>>;
    return $mat;

}


/******************************************************************************
 * @procedure    screenSpaceVecMult
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $v : vector
 *   $m : matrix
 *
 * @returns      vector
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector screenSpaceVecMult(vector $v, matrix $m)
{

    matrix $v1[1][4]=<<$v.x, $v.y, $v.z, 1>>;
    matrix $v2[1][4]=$v1*$m;
    return <<$v2[0][0], $v2[0][1],  $v2[0][2]>>;

}


/******************************************************************************
 * @procedure    AddItemsFromIndexAtoB
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Ai : int
 *   $Bi : int
 *   $numberArrayi : int[]
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int AddItemsFromIndexAtoB(int $Ai, int $Bi, int $numberArrayi[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $AddUp = 0;
    int $NumerinArray = `size($numberArrayi)`-1;
    int $Ni = $Ai;
    int $Nii = $Bi;
    int $range = abs ($Ai-$Bi);
    int $ixNa = $iC+$Ai;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    // float $numberArrayi[]= {0.2, 1.2, 3.2, 1.2, 6.2, 6.2, 9.3, -1.2};
    //int $Ai = 2;
    //int $Bi = 5;
    $AddUp = 0;
    $NumerinArray = `size($numberArrayi)`-1;
    if($NumerinArray!=-1){
    $Ni = $Ai;
    $Nii = $Bi;
    if($Nii< $Ni){
    $Ai=$Nii; $Bi=$Ni;
    }
    $range = abs ($Ai-$Bi);
    for ($iC=0;$iC<$range+1; $iC++){
    $ixNa = $iC+$Ai;
    $ixNa = `clamp 0 $NumerinArray $ixNa`;
    $AddUp+=$numberArrayi[$ixNa];
    if($ixNa ==$NumerinArray){break;}
    }
    }
    return $AddUp;

}


/******************************************************************************
 * @procedure    AddItemsFromIndexAtoBFindZero
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Ai : int
 *   $Bi : int
 *   $numberArrayi : int[]
 *
 * @returns      int[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int[] AddItemsFromIndexAtoBFindZero(int $Ai, int $Bi, int $numberArrayi[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $AddUp = 0;
    int $NumerinArray = `size($numberArrayi)`-1;
    int $Ni = $Ai;
    int $Nii = $Bi;
    int $range = abs ($Ai-$Bi);
    int $ixNa = $iC+$Ai;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    // float $numberArrayi[]= {0.2, 1.2, 3.2, 1.2, 6.2, 6.2, 9.3, -1.2};
    //int $Ai = 2;
    //int $Bi = 5;
    $AddUp = 0;
    $NumerinArray = `size($numberArrayi)`-1;
    $catchIndex[0]= 1;
    if($NumerinArray!=-1){
    $Ni = $Ai;
    $Nii = $Bi;
    if($Nii< $Ni){
    $Ai=$Nii; $Bi=$Ni;
    }
    $range = abs ($Ai-$Bi);
    for ($iC=0;$iC<$range+1; $iC++){
    $ixNa = $iC+$Ai;
    $ixNa = `clamp 0 $NumerinArray $ixNa`;
    $AddUp+=$numberArrayi[$ixNa];
    if($AddUp ==0){$catchIndex[1] = $ixNa; $catchIndex[0]=0;break;}
    }
    }
    return $catchIndex;

}


/******************************************************************************
 * @procedure    StringArrayItemsFromIndexAtoB
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Ai : int
 *   $Bi : int
 *   $StringArrayi : string[]
 *
 * @returns      string
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string StringArrayItemsFromIndexAtoB(int $Ai, int $Bi, string $StringArrayi[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $NumerinArray = `size($StringArrayi)`;
    int $ixNa = $iC+$Ai;
    float $Ni = $Ai;
    float $Nii = $Bi;
    float $range = abs ($Ai-$Bi);
    string $sAddUp = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $sAddUp = 0;
    $NumerinArray = `size($StringArrayi)`;
    if($NumerinArray!=0){
    $Ni = $Ai;
    $Nii = $Bi;
    if($Nii< $Ni){
    $Ai=$Nii; $Bi=$Ni;
    }
    $range = abs ($Ai-$Bi);
    for ($iC=0;$iC<$range+1; $iC++){
    $ixNa = $iC+$Ai;
    $sAddUp+=$StringArrayi[$ixNa];
    if($ixNa ==$NumerinArray){break;}
    }
    }
    return $sAddUp;

}


/******************************************************************************
 * @procedure    StringArrayStartOfStringinArray
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Array : string[]
 *
 * @returns      string[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] StringArrayStartOfStringinArray(string $Array[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $StartOfEach[];
    string $findEachstart = "";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $findEachstart = "";
    for ($eachString in $Array){
    $StartOfEach[`size($StartOfEach)`]= startString($eachString, 1);
    $findEachstart+= startString($eachString, 1);
    $findEachstart+= " ";
    }

    return $StartOfEach;

}


/******************************************************************************
 * @procedure    ReturnArrayFromNestedStringAtIndex
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $StringData : string[]
 *   $ind : int
 *
 * @returns      string[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] ReturnArrayFromNestedStringAtIndex(string $StringData[], int $ind)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $KnownMatchi[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $KnownMatchi = stringToStringArray($StringData[$ind], ",");
    return $KnownMatchi;

}


/******************************************************************************
 * @procedure    TFArrayContains
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      int[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int[] TFArrayContains(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Count = 0;
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════
    $TF[0] = false;
    $Count = 0;
    for ($listItem in $list) {
    if ($item == $listItem) {
    $TF[0] = true;
    $TF[1] = $Count;
    break;
    } $Count++;
    }
    return $TF;

}


/******************************************************************************
 * @procedure    AddItemString
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $iN : int
 *   $NumLetorSy : string
 *
 * @returns      string
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string AddItemString(int $iN, string $NumLetorSy)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Xz = 0;
    string $AddItem = "";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Xz = 0;
    $AddItem = "";
    while($iN > $Xz){
    $AddItem+= $NumLetorSy;
    $Xz++;
    }
    return $AddItem;

}


/******************************************************************************
 * @procedure    FindNameOfVariables
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Find : string
 *   $sortN : int
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] FindNameOfVariables(string $Find, int $sortN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IndexLetters[] = CreateIntIndex(`size($ArrayLetter)`);
    int $BytNumi;
    int $StringIndex[];
    int $countIndex = 0;
    int $indexStart[];
    int $indexFirstCharItems[];
    int $BytNx = 0;
    int $freezeTrigger = 0;
    int $eachInt = 0;
    int $iixI = 0;
    int $TFandIndex[];
    int $TFandIndexii[];
    int $FirstLFindIndex;
    int $Tri = 0;
    int $Trii = 2;
    int $CountFoundletters = 0;
    int $SizeItem = `size $matchTemp`;
    string $resultVar = "string float vector matrix int proc";
    string $resulti = "sin cos tan tand atan asin acos atand asind acosd";
    string $result = "abs angle bessel ceil clamp constrainValue cos cross crossProduct deg_to_rad delrandstr dot dotProduct equivalent  equivalentTol erf exp floatEq floor fmod gamma gauss getLastError getProcArguments hermite hsv_to_rgb hypot linstep log mag max min noise  normalize pointMatrixMult pow rad_to_deg rand randstate rgb_to_hsv rot seed sign sin smoothstep sphrand sqrt tan trunc unitprint ";
    string $AllMathfunction = "abs ,angle ,bessel ,ceil ,clamp ,constrainValue ,cos ,cross ,crossProduct ,deg_to_rad ,delrandstr ,dot  ,dotProduct ,equivalent ,equivalentTol ,erf ,exp ,floatEq ,floor ,fmod ,gamma ,gauss ,getLastError ,getProcArguments ,hermite ,hsv_to_rgb  ,hypot ,linstep ,log ,mag ,max ,min ,noise ,normalize ,pointMatrixMult ,pow ,rad_to_deg ,rand ,randstate ,rgb_to_hsv ,rot ,seed ,sign ,sin  ,smoothstep ,sphrand ,sqrt ,tan ,trunc ,unit";
    string $MathFuncClassData = $result+" "+ $resulti + " " + $resultVar;
    string $KnownMathTermsMEL[] = stringToStringArray($MathFuncClassData, " ");
    string $KnownMathTermsMELSorted[] = `sort $KnownMathTermsMEL`;
    string $startingChar[] = StringArrayStartOfStringinArray($KnownMathTermsMELSorted);
    string $shorterListstartingChar[] = stringArrayRemoveDuplicates ($startingChar);
    string $KnownMatch[] = $KnownMathTermsMELSorted;
    string $ArrayLetter[] = $shorterListstartingChar;
    string $Arraytemp[] = $KnownMathTermsMELSorted;
    string $StartOfEachS;
    string $findEachstart = "";
    string $gatherItems = "";
    string $eachStringL;
    string $eachString;
    string $all[];
    string $tempFind = $Find;
    string $tempFindwrite = $Find;
    string $StartS;
    string $LetterItem = "";
    string $FoundVariableItems[];
    string $FoundOtherItems[];
    string $StringFromReducedArray = "";
    string $reducedArray[];
    string $allTemp[];
    string $dontUse = "";
    string $matchingDontuse = "";
    string $matching = "";
    string $match;
    string $match0;
    string $matchMiddleDiff;
    string $matchi;
    string $MatchStage2;
    string $MatchStage3;
    string $addBracktoMatch3;
    string $addBracktoMatchD;
    string $matchTemp;
    string $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    string $ArrayFind[];
    string $StartOfEachSi = "";
    string $FOUND = "";
    string $printneat = stringArrayToString($FoundVariableItems, ",");
    string $printneati = stringArrayToString($FoundOtherItems, ",");
    string $FoundTerms[] = stringToStringArray($printneat, ",");
    vector $indexStartEnd[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $resultVar = "string float vector matrix int proc";
    $resulti = "sin cos tan tand atan asin acos atand asind acosd";
    $result = "abs angle bessel ceil clamp constrainValue cos cross crossProduct deg_to_rad delrandstr dot dotProduct equivalent  equivalentTol erf exp floatEq floor fmod gamma gauss getLastError getProcArguments hermite hsv_to_rgb hypot linstep log mag max min noise  normalize pointMatrixMult pow rad_to_deg rand randstate rgb_to_hsv rot seed sign sin smoothstep sphrand sqrt tan trunc unitprint ";
    $AllMathfunction = "abs ,angle ,bessel ,ceil ,clamp ,constrainValue ,cos ,cross ,crossProduct ,deg_to_rad ,delrandstr ,dot  ,dotProduct ,equivalent ,equivalentTol ,erf ,exp ,floatEq ,floor ,fmod ,gamma ,gauss ,getLastError ,getProcArguments ,hermite ,hsv_to_rgb  ,hypot ,linstep ,log ,mag ,max ,min ,noise ,normalize ,pointMatrixMult ,pow ,rad_to_deg ,rand ,randstate ,rgb_to_hsv ,rot ,seed ,sign ,sin  ,smoothstep ,sphrand ,sqrt ,tan ,trunc ,unit";
    $MathFuncClassData = $result+" "+ $resulti + " " + $resultVar ;
    //string  $KnownMathTermsMELAtomizes[] = ArrayFromAllinString($MathFuncClassData);
    $KnownMathTermsMEL = stringToStringArray($MathFuncClassData, " ");
    $KnownMathTermsMELSorted = `sort $KnownMathTermsMEL`;



    $startingChar = StringArrayStartOfStringinArray($KnownMathTermsMELSorted);
    $shorterListstartingChar = stringArrayRemoveDuplicates ($startingChar);
    $KnownMatch = $KnownMathTermsMELSorted;
    $ArrayLetter = $shorterListstartingChar;
    $Arraytemp = $KnownMathTermsMELSorted;
    $findEachstart = "";
    clear $StartOfEachSTable $itemBackUp;
    $itemBackUp = $ArrayLetter;
    $gatherItems = "";

    for ($eachStringL in $ArrayLetter){
    for ($eachString in $KnownMathTermsMELSorted){
    $StartOfEachS = startString($Arraytemp[0], 1);
    if ($StartOfEachS==$eachStringL){
    $gatherItems += ($Arraytemp[0]+",");
    $Arraytemp = stringArrayRemoveExact({$Arraytemp[0]}, $Arraytemp);
    }
    //else{	$gatherItems="";}	//
    }
    if(`size($gatherItems)`>0){
    $StartOfEachSTable[`size($StartOfEachSTable)`]= $gatherItems;
    }
    $gatherItems="";
    }

    //////////////////////////////////////////////////////////////


    $IndexLetters = CreateIntIndex(`size($ArrayLetter)`);
    $BytNumi = `sizeBytes $Find`;
    clear $all;
    clear $StringIndex;
    $all = ArrayFromAllinString($Find);
    $StringIndex = CreateIntIndex( `size($all)` );
    //map string

    $tempFind = $Find;
    $tempFindwrite = $Find;
    $countIndex = 0;
    clear $indexStart;
    $LetterItem = "";
    clear $FoundVariableItems $FoundOtherItems;
    clear $indexFirstCharItems;
    $BytNx = 0;
    $StringFromReducedArray = "";
    clear $reducedArray;
    clear $allTemp;
    $allTemp = $all;
    $dontUse = "";
    $matchingDontuse = "";
    $freezeTrigger = 0;
    $matching = "";
    $eachInt = 0;
    $iixI = 0;


    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $Find`;
    $match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $Find`;
    $matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $Find`;
    $matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $Find`;
    $MatchStage2 = endString($match, 3);

    $MatchStage3 = startString($match, `sizeBytes $match`-2);
    $MatchStage3i = startString($match, `sizeBytes $matchii`-2);
    $addBracktoMatch3 = ("\["+$MatchStage3+"\]");

    $matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;
    if($matchMiddleDiff=="\."){

    $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    if($matchMaybeVec2!=""){
    $MatchStage4 = startString($match, `sizeBytes $match`-1);
    $match = $MatchStage4;
    }else{ $dontUse = $matchi; $match=$matchi; }
    }else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//
    }

    $matchTemp = $match;
    $BytNx =`sizeBytes $match`;

    $IndexLetters = CreateIntIndex(`size($ArrayLetter)`);
    $StartOfEachSi = "";
    $FOUND = "";
    clear $ArrayFind $TFandIndex $TFandIndexii;
    $Tri = 0;
    $Trii = 2;
    $CountFoundletters = 0;
    clear $indexStartEnd;


    for ($eachItemArray in $StringIndex){
    $eachInt = $StringIndex[$iixI];

    if( `gmatch $allTemp[$eachInt] "[a-zA-Z0-9_\.]*"` == 1){
    if($Trii==2){$Trii=1; $Tri=2;}
    if(!($CountFoundletters>=1)){
    $FirstLFindIndex=$iixI+1;

    }
    $CountFoundletters++;
    if($Tri==2){

    $Tri=0;
    }
    $LetterItem+= $allTemp[$eachInt];
    $BytNx = `sizeBytes $LetterItem`;
    if(`gmatch $matchTemp $LetterItem`==1){
    $BytNx = `sizeBytes $LetterItem`;

    //$LetterItem ="pow";
    $StartOfEachSi = startString($LetterItem, 1);
    $TFandIndex = TFArrayContains($StartOfEachSi, $ArrayLetter);
    if($TFandIndex[0]==1){
    $ArrayFind = ReturnArrayFromNestedStringAtIndex($StartOfEachSTable, $TFandIndex[1]);
    $TFandIndexii = TFArrayContains($LetterItem, $ArrayFind);

    if($TFandIndexii[0]==1){
    $FOUND = $ArrayFind[$TFandIndexii[1]];
    if(`gmatch $FOUND $LetterItem`==1){

    $FoundOtherItems[`size($FoundOtherItems)`]= $FOUND;
    }
    }
    }
    if(`gmatch $FOUND $LetterItem`!=1){
    if($matchTemp!=$dontUse){
    $FoundVariableItems[`size($FoundVariableItems)`]= $LetterItem;
    $SizeItem = `size $matchTemp`;
    $indexStartEnd[`size($indexStartEnd)`] = <<$FirstLFindIndex, $iixI, ($iixI-$SizeItem+3)>> ;
    $indexStart[`size($indexStart)`]= $FirstLFindIndex;
    }
    } else{$CountFoundletters=0;          }
    clear $TFandIndex $ArrayFind $TFandIndexii;
    $FOUND="";
    $reducedArray = $allTemp;
    stringArrayRemoveToIndex($eachInt+1, $reducedArray);
    $StringFromReducedArray = stringArrayToString($reducedArray, "");

    /////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////
    $LetterItem ="";
    if($matchTemp==$dontUse){ $freezeTrigger = 1; }
    if( `gmatch $allTemp[$eachInt] $match` != 1){$Trii=2; $CountFoundletters=0;}

    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;

    //if(`size($StringFromReducedArray)`>4){
    $match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $StringFromReducedArray`;
    $matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $StringFromReducedArray`;
    $matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $StringFromReducedArray`;
    $MatchStage2 = endString($match, 3);
    $MatchStage3 = startString($match, `sizeBytes $match`-2);
    $MatchStage3i = startString($match, `sizeBytes $matchii`-2);
    $addBracktoMatch3 = ("\["+$MatchStage3+"\]");
    //$addBracktoMatchD = ("\(["+"\"+$matchi+"\])+([a-zA-Z]+)([a-zA-Z0-9_])");
    $matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;

    if($matchMiddleDiff=="\."){

    $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    if($matchMaybeVec2!=""){
    $MatchStage4 = startString($match, `sizeBytes $match`-1);
    $match = $MatchStage4;
    }else{ $dontUse = $matchi; $match=$matchi; }
    }else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//
    }
    }
    }else{$LetterItem ="";  }
    ///}else{$match = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;}
    $matchTemp = $match;

    $iixI++;
    }

    ///////////////

    $printneat = stringArrayToString($FoundVariableItems, ",");
    $printneati = stringArrayToString($FoundOtherItems, ",");
    $FoundTerms = stringToStringArray($printneat, ",");

    if($sortN== 1){$FoundTerms = `sort $FoundTerms`;}

    return $FoundTerms;


}


/******************************************************************************
 * @procedure    BracketFindPosNeg
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Find : string
 *   $NegPosZ : int[]
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int BracketFindPosNeg(string $Find, int $NegPosZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $BytNumi;
    int $iX = 0;
    int $AddAll;
    string $BracketF;
    string $BracketL;
    string $Fb = "{";
    string $Lb = "}";
    string $all[];
    string $NewSt = "";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $Fb = "{";
    $Lb = "}";
    $BracketF = `match "[\{]" $Find`;
    $BracketL = `match "[\}]" $Find`;
    $NewSt = "";
    if(($BracketF != "")||($BracketL != "")){
    $BytNumi = `sizeBytes $Find`;
    $all = ArrayFromAllinString($Find);
    $iX = 0;
    for($i=0;$i<$BytNumi;$i++){
    if(( $all[$i] == $Fb ) || ( $all[$i] == $Lb )){
    $NewSt = $all[$i];
    if($NewSt == $Fb){
    $NegPosZ[`size($NegPosZ)`] = 1;
    }else if($NewSt == $Lb){
    $NegPosZ[`size($NegPosZ)`] = -1;
    }
    $iX++;
    }
    }
    }
    for($eachInt in $NegPosZ){
    $AddAll+= $eachInt;
    }
    return $AddAll;

}


/******************************************************************************
 * @procedure    stringArrayFindDupIndexSPair
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $listA : string[]
 *   $foundN : int[]
 *   $LineNumberB : int[]
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] stringArrayFindDupIndexSPair(string $listA[], int $foundN[], int $LineNumberB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $FindNum = 0;
    int $FindIndexN[];
    int $LineNumberA[];
    string $listTemp[];
    string $list[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $FindNum = 0;
    clear $foundN;
    $LineNumberA = $LineNumberB;
    $list = $listA;
    $listTemp  = $list;
    for ($item in $list) {
    clear $FindIndexN;
    $FindNum = stringArrayCountIndex($item,  $listTemp, $FindIndexN);
    if ($FindNum>1){
    $foundN[`size($foundN)`] = $LineNumberA[$FindIndexN[`size($FindIndexN)`-1]];
    $result[`size($result)`] =  $listTemp[$FindIndexN[`size($FindIndexN)`-1]];
    $LineNumberA = IntRemoveIndexN( $LineNumberA, $FindIndexN);
    $listTemp = RemoveStringAtIndex( $listTemp, $FindIndexN);
    }else{
    if ($FindNum==1){
    $foundN[`size($foundN)`] = $LineNumberA[$FindIndexN[0]];
    $result[`size($result)`] =  $listTemp[$FindIndexN[0]];
    }
    }
    }
    return $result;

}


/******************************************************************************
 * @procedure    stringArrayCountIndexOne
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $item : string
 *   $list : string[]
 *   $FindIndexN : int[]
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int stringArrayCountIndexOne(string $item, string $list[], int $FindIndexN[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = 0;
    int $CountN = 0;
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = 0;
    $CountN = 0;
    clear $FindIndexN;

    for ($listItem in $list) {
    if ($item == $listItem){
    $FindIndexN[$result]=$CountN;
    $result++;
    }
    $CountN++;
    }
    return $result;

}


/******************************************************************************
 * @procedure    stringArrayRemoveAtIndexZ
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $indexA : int
 *   $list : int[]
 *
 * @returns      int []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] stringArrayRemoveAtIndexZ(int $indexA, int $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $result[];
    int $indexS = `size($indexA)`;
    int $len = size( $list );
    int $Xi = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $indexS = `size($indexA)`;
    $len = size( $list );
    $Xi = 0;
    while($Xi< $indexS){
    for ( $i = 0; $i < $Xi; $i++ ) {
    $result[$i] = $list[$i];
    }
    $Xi++;
    }
    //$list = $result;
    return $result;

}


/******************************************************************************
 * @procedure    RemoveINTAtIndex
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $VecS : int[]
 *   $IndeXxI : int[]
 *
 * @returns      int []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] RemoveINTAtIndex(int $VecS[], int $IndeXxI[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $newInt[];
    int $Ix = 0;
    int $ii = 0;
    int $Ixi = 0;
    int $IndeXxz[];
    int $size = `size($IndeXxI)`-1;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Ix = 0;
    $ii = 0;
    $Ixi = 0;
    $IndeXxz = `sort $IndeXxI`;
    $size = `size($IndeXxI)`-1;
    for ($eachVc in $VecS){
    if($VecS[$ii]>$IndeXxz[$Ixi]){
    if($size==$Ixi){$Ixi=0;}
    $Ixi++;
    }
    if(!($eachVc== $IndeXxz[$Ixi])){
    $newInt[`size($newInt)`] = $eachVc;
    $ii=$Ix;
    }else{$Ixi++;
    if( $Ixi> `size($IndeXxI)`){break;}
    }
    $Ix++;
    }
    return $newInt;

}


/******************************************************************************
 * @procedure    IntArrayRemoveAtIndex
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $index : int
 *   $IntArray : int[]
 *
 * @returns      int []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IntArrayRemoveAtIndex(int $index, int $IntArray[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $len = `size( $list )`;
    string $list[] = IntArrayToStringArray( $IntArray );
    string $result[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $list = IntArrayToStringArray( $IntArray );
    $len = `size( $list )`;
    for ( $i = 0; $i < $index; $i++ ) {
    $result[$i] = $list[$i];
    }
    for ( ; $i < $len - 1; $i++ ) {
    $result[$i] = $list[$i + 1];
    }
    $list = $result;
    $IntArray = StringArrayToIntArray($list);
    //string [] IntArrayToStringArray(int $IntArray[])
    return $IntArray;

}


/******************************************************************************
 * @procedure    stringArrayCountIndex
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $item : string
 *   $list : string[]
 *   $FindIndexN : int[]
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int stringArrayCountIndex(string $item, string $list[], int $FindIndexN[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = 0;
    int $CountN = 0;
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = 0;
    $CountN = 0;
    clear $FindIndexN;
    for ($listItem in $list) {
    if ($item == $listItem){
    $FindIndexN[$result]=$CountN;
    $result++;
    }
    $CountN++;
    }
    return $result;

}


/******************************************************************************
 * @procedure    stringArrayStrip
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $list : string[]
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] stringArrayStrip(string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $index = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $index = 0;
    for ($item in $list) {
    $result[$index++] = substituteAllString($item, " ", "");
    }
    return $result;

}


/******************************************************************************
 * @procedure    stringArrayFindDuplicates
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $list : string[]
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] stringArrayFindDuplicates(string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $index = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $index = 0;
    for ($item in $list) {
    if (1 < stringArrayCount($item, $list)) {
    $result[$index++] = $item;
    }
    }
    return $result;

}


/******************************************************************************
 * @procedure    FindStringVarZ
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $FindZ : string
 *
 * @returns      string[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] FindStringVarZ(string $FindZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Size;
    string $FindN = $FindZ;
    string $stringRN;
    string $match0;
    string $match0N;
    string $CollectFinds[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $FindN = $FindZ;
    $Size =  `sizeBytes  $FindN`;
    while($Size>0){

    $match0N = `match "([\$]+)([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
    if(`sizeBytes $match0N`>0){
    $stringRN = `substitute $match0N $FindN ""`;
    $FindN = $stringRN;
    }

    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
    $Size =  `sizeBytes  $match0`;
    if($Size>0){
    $CollectFinds[`size($CollectFinds)`]= $match0;
    $stringRN = `substitute $match0 $FindN""`;
    $FindN = $stringRN;
    }
    }
    return $CollectFinds;

}


/******************************************************************************
 * @procedure    FindTrueStringVarZ
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $FindZ : string
 *
 * @returns      string[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] FindTrueStringVarZ(string $FindZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Size;
    string $FindN = $FindZ;
    string $stringRN;
    string $match0;
    string $CollectFinds[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $FindN = $FindZ;
    $Size =  `sizeBytes  $FindN`;
    while($Size>0){
    $match0 = `match "([\$]+)([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
    // $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;

    $Size =  `sizeBytes  $match0`;
    if($Size>0){
    $CollectFinds[`size($CollectFinds)`]= $match0;
    $stringRN = `substitute $match0 $FindN""`;
    $FindN = $stringRN;
    }
    }
    return $CollectFinds;

}


/******************************************************************************
 * @procedure    RemoveStringAtIndex
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $VecS : string[]
 *   $IndeXz : int[]
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] RemoveStringAtIndex(string $VecS[], int $IndeXz[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IndeXxiz[] = sort($IndeXz);
    int $SizA = `size($IndeXz)`;
    int $Ixx = 0;
    int $Ixi = 0;
    string $newVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $IndeXxiz = sort($IndeXz);
    $SizA = `size($IndeXz)`;
    $Ixx = 0;
    $Ixi = 0;
    for ($eachVc in $VecS){
    if(!($Ixx== $IndeXxiz[$Ixi])){
    $newVec[`size($newVec)`] = $eachVc;
    }else{$Ixi++;}
    $Ixx++;
    }
    return $newVec;

}


/******************************************************************************
 * @procedure    RemoveIntAtIndex
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $VecS : int[]
 *   $IndeXz : int[]
 *
 * @returns      int []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] RemoveIntAtIndex(int $VecS[], int $IndeXz[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $newVec[];
    int $IndeXxiz[] = sort($IndeXz);
    int $SizA = `size($IndeXz)`;
    int $Ixx = 0;
    int $Ixi = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $IndeXxiz = sort($IndeXz);
    $SizA = `size($IndeXz)`;
    $Ixx = 0;
    $Ixi = 0;
    for ($eachVc in $VecS){
    if(!($Ixx== $IndeXxiz[$Ixi])){
    $newVec[`size($newVec)`] = $eachVc;
    }else{$Ixi++;}
    $Ixx++;
    }
    return $newVec;

}


/******************************************************************************
 * @procedure    StringArrayToIntArray
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $listA : string[]
 *
 * @returns      int []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] StringArrayToIntArray(string $listA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IntA[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($eachString in $listA){
    $IntA[`size($IntA)`]=$eachString;
    }
    return $IntA;

}


/******************************************************************************
 * @procedure    FindSCRIPTNAME
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $LineNA : string
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindSCRIPTNAME(string $LineNA)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Trigger = 0;
    string $Parts[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Trigger = 0;
    $Parts =FindStringVarZ($LineNA);
    if(`size($Parts)`>0){
    for($eachP in $Parts){
    if(`gmatch "proc" $eachP` == 1){$Trigger=1;}
    }
    }
    return $Trigger;

}


/******************************************************************************
 * @procedure    RuleBasedMatchM
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $IndexN : int[]
 *   $FindItemAllCase : string[]
 *   $LineNA : string[]
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] RuleBasedMatchM(int $IndexN[], string $FindItemAllCase[], string $LineNA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CountCase = 0;
    int $returnCaseN[];
    int $Trigger = 0;
    string $FoundP[];
    string $matchString;
    string $Parts[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $CountCase = 0;
    $Trigger = 0;

    if(`size($IndexN)`>0){
    clear $IndexN;
    }

    for($LineN in $LineNA){
    $CountCase =0;
    for($eachFindItem in $FindItemAllCase){

    //$matchString = `match $eachFindItem $LineN`;
    $Parts =FindStringVarZ($LineN);

    if(`size($Parts)`>0){
    for($eachP in $Parts){
    if(`gmatch $eachFindItem $eachP` == 1){
    $FoundP[`size($FoundP)`]= $eachFindItem;
    $Trigger=1;
    clear $Parts;
    break;
    }
    }
    }

    $matchString="";
    if($Trigger==1){break;}
    $CountCase++;
    }

    if(($CountCase>0)||($Trigger==1)){
    $returnCaseN[`size($returnCaseN)`] = $CountCase;
    $IndexN =$returnCaseN;
    }
    $Trigger=0;
    }

    return $FoundP;

}


/******************************************************************************
 * @procedure    RuleBasedMatchMM
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $IndexN : int[]
 *   $FindItemAllCase : string[]
 *   $LineNA : string[]
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] RuleBasedMatchMM(int $IndexN[], string $FindItemAllCase[], string $LineNA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CountCase = 0;
    int $returnCaseN[];
    int $Trigger = 0;
    int $Number;
    string $FoundP[];
    string $matchString;
    string $Parts[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CountCase = 0;
    $Trigger = 0;
    for($LineN in $LineNA){
    $CountCase =1;
    $Number=-1;
    $Parts =FindStringVarZ($LineN);
    print $Parts;
    if(`size($Parts)`>0){

    for($eachP in $Parts){
    $Number = RuleBasedMatch($FindItemAllCase, $eachP);
    if($Number != -1){
    $FoundP[`size($FoundP)`]= $FindItemAllCase[$Number];
    $Trigger=1;
    }

    if($Trigger==1){break;}
    }
    clear $Parts;
    }

    if($Trigger==1){$returnCaseN[`size($returnCaseN)`] = $Number;}
    $Trigger=0;
    }
    $IndexN =$returnCaseN;
    return $FoundP;

}


/******************************************************************************
 * @procedure    RuleBasedMatch
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $FindItemAllCase : string[]
 *   $LineN : string
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int RuleBasedMatch(string $FindItemAllCase[], string $LineN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CountCase = 0;
    int $returnCaseN = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CountCase = 0;
    $returnCaseN = 0;
    for($eachFindItem in $FindItemAllCase){
    //$matchString = `match $eachFindItem $LineN`;
    if(`gmatch $eachFindItem $LineN` == 1){
    $returnCaseN = $CountCase;
    break;
    }
    $CountCase++;
    }
    return $returnCaseN;

}


/******************************************************************************
 * @procedure    AppendArrayZ
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $A : string[]
 *   $B : string[]
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] AppendArrayZ(string $A[], string $B[])
{

    for($eachF in $B){
    $A[`size($A)`]= $eachF;
    }
    return $A;

}


/******************************************************************************
 * @procedure    intArrayRemoveDuplicates
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $list : int[]
 *
 * @returns      int []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] intArrayRemoveDuplicates(int $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $index = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $index = 0;
    for ($item in $list) {
    if (0 == intArrayCount($item, $result)) {
    $result[$index++] = $item;
    }
    }
    return $result;

}


/******************************************************************************
 * @procedure    intArrayCount
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $item : int
 *   $list : int[]
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int intArrayCount(int $item, int $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = 0;
    int $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = 0;
    for ($listItem in $list) {
    if ($item == $listItem) $result++;
    }
    return $result;

}


/******************************************************************************
 * @procedure    RemoveEscapedLine
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $TEXTA : string
 *
 * @returns      string
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string RemoveEscapedLine(string $TEXTA)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $MatchPart = "";
    string $stringNX = "";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MatchPart = "";
    $stringNX = "";
    $MatchPart=match( "//", $TEXTA );
    if(`sizeBytes $MatchPart`>0){
    $MatchPart="";
    $MatchPart=match( "//[^\n]*", $TEXTA  );
    $stringNX = `substitute $MatchPart $TEXTA ""`;
    }else{$stringNX =$TEXTA;}
    return $stringNX;

}


/******************************************************************************
 * @procedure    BracketFind
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Find : string
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] BracketFind(string $Find)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $BytNumi;
    string $AllFOUND[];
    string $FirstBracket;
    string $text = $Find;
    string $result = substituteAllString($text, $FirstBracket, "#");

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $BytNumi = `sizeBytes $Find`;
    for($i=0;$i<$BytNumi;$i++){
    if($i==100){
    break;}
    $FirstBracket = `match "[\(][^\(]*[^.]*[^\(]*[\)]" $Find`;
    if($FirstBracket != ""){
    $AllFOUND[`size($AllFOUND)`] = $FirstBracket;
    $text = $Find;
    $result = substituteAllString($text, $FirstBracket, "#");
    $Find =  $result;
    }else if($FirstBracket == ""){
    print "found nothing";
    print $AllFOUND;
    $i = $BytNumi +2;
    break;
    }
    }
    return $AllFOUND;

}


/******************************************************************************
 * @procedure    BracketFindPosNegRuleE
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $CN : int
 *   $NewLineX : string
 *   $TEXTA : string
 *   $NegPosZ : int[]
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int BracketFindPosNegRuleE(int $CN, string $NewLineX, string $TEXTA, int $NegPosZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $AddAll = 0;
    int $TRUEA = 0;
    string $BracketF = `match "[\/]+[\*]"$TEXTA`;
    string $BracketL = `match "[\*]+[\/]" $TEXTA`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $AddAll = 0;
    $NewLineX="";
    $BracketF = `match "[\/]+[\*]"$TEXTA`;
    $BracketL = `match "[\*]+[\/]" $TEXTA`;
    $TRUEA = 0; int $TRUEB=0;

    if(`sizeBytes $BracketF`>0){$TRUEA=1;}
    if(`sizeBytes $BracketL`>0){$TRUEB=1;}

    if($TRUEA+$TRUEB!=2){
    if($TRUEA==1){
    $NegPosZ[`size($NegPosZ)`] = 1;
    $NewLineX=`substitute "//\*[^\n]*" $TEXTA ""`;
    }
    if($TRUEB==1){
    $NegPosZ[`size($NegPosZ)`] = 2;
    $NewLineX= `substitute ".*\*/" $TEXTA ""`;
    }
    for($eachInt in $NegPosZ){
    $CN++;
    $AddAll+= $eachInt;
    }
    }else{

    if($TRUEA+$TRUEB==3){
    $MatchPartA=`substitute "//\*[^\n]*" $TEXTA ""`;
    $MatchPartB=`substitute ".*\*/" $TEXTA ""`;
    $NewLineX=($MatchPartA+" "+$MatchPartB);
    $AddAll=0;
    }
    }


    return $AddAll;

}


/******************************************************************************
 * @procedure    RStringArrayStartOfStringinArray
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Array : string[]
 *
 * @returns      string[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] RStringArrayStartOfStringinArray(string $Array[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $StartOfEach[];
    string $stringRN;
    string $SS;
    string $S;
    string $findEachstart = "";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $findEachstart = "";
    for ($eachString in $Array){

    $stringRN = `substitute "[/$]" $eachString ""`;
    $S=startString($eachString, 3);

    $findEachstart= $S;
    $findEachstart+= "";
    $StartOfEach[`size($StartOfEach)`]= $findEachstart;
    }

    return $StartOfEach;

}


/******************************************************************************
 * @procedure    stringArrayCountDuplicatesAUGMENT
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $listX : string[]
 *   $AddtoEnd : string
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] stringArrayCountDuplicatesAUGMENT(string $listX[], string $AddtoEnd)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $index = 0;
    int $X = 0;
    int $C = 0;
    int $NumberE[];
    string $list[] = $listX;
    string $Expr = "\\$";
    string $ExprA = "";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $list = $listX;
    $list = ReverseStringArray($list);
    $index = 0;
    $X = 0;
    $C = 0;
    $result = $list;
    $Expr = "\\$";
    $ExprA = "";

    for ($item in $list) {
    $NumberE[$X] = stringArrayCount($item, $result);
    if (1 == $NumberE[$X]) {
    if(startString($item, 1)!= "$"){
    $CollectR[$X] = $ExprA+$item+$AddtoEnd;
    }
    if(startString($item, 1)== "$"){
    $CollectR[$X] = $item+$AddtoEnd;}
    }else{
    if (1 < $NumberE[$X]) {
    $C = $NumberE[$X]-1;
    if(startString($item, 1)!= "$"){
    $CollectR[$X] = $ExprA+$item+$C+$AddtoEnd;
    }
    if(startString($item, 1)== "$"){
    $CollectR[$X] = $item+$C+$AddtoEnd;
    }
    }
    }
    stringArrayRemoveToIndex(1, $result);
    $X++;	}
    $CollectR = ReverseStringArray($CollectR);
    return $CollectR;

}


/******************************************************************************
 * @procedure    ReverseStringArray
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $array : string[]
 *
 * @returns      string[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] ReverseStringArray(string $array[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $arrayOut[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($i=0;$i<size($array);$i++){
    $arrayOut[$i]=$array[(size($array)-1-$i)];}
    return $arrayOut;

}


/******************************************************************************
 * @procedure    RuleBasedMatchReplaceLine
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $FindItemAllCase : string[]
 *   $ReplaceCase : string[]
 *   $LineN : string
 *
 * @returns      string
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string RuleBasedMatchReplaceLine(string $FindItemAllCase[], string $ReplaceCase[], string $LineN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CC = 0;
    int $returnCaseN = 0;
    string $matchString;
    string $CHANGE;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CC = 0;
    $returnCaseN = 0;
    $CHANGE=$LineN;
    for($eachFindItem in $FindItemAllCase){
    $matchString = `match $eachFindItem $CHANGE`;
    $Size =  `sizeBytes  $matchString`;
    if($Size>0){
    $CHANGE = substituteAllString($CHANGE, $matchString,  $ReplaceCase[$CC]);
    }
    $CC++;
    }
    return $CHANGE;

}


/******************************************************************************
 * @procedure    SortIntIndexTrack
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $AllFloatToSort : int[]
 *
 * @returns      int[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int[] SortIntIndexTrack(int $AllFloatToSort[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IndexTrack[];
    int $ii;
    int $sIze = `size($aF)`-1;
    float $aF[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($ii=0; $ii<`size($AllFloatToSort)`; $ii++){
    $aF[$ii]= ($AllFloatToSort[$ii]);
    }
    $sIze = `size($aF)`-1;
    $IndexTrack = CreateIntIndex(`size($aF)`);
    quickSort($aF, $IndexTrack, 0, $sIze);
    $IndexTrack = ReverseIntArray($IndexTrack);
    return $IndexTrack;

}


/******************************************************************************
 * @procedure    intArrayRemoveEqual
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $list : int[]
 *   $listB : int[]
 *
 * @returns      int []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] intArrayRemoveEqual(int $list[], int $listB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $index = 0;
    int $i = 0;
    int $S = `size($listB)`-1;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $index = 0;
    $i = 0;
    $S = `size($listB)`-1;
    for ($item in $list) {
    if ($listB[$i]== $item) {

    $i++;
    if($i>$S){break;}
    }else{$result[$index++] = $item;}
    }

    return $result;

}


/******************************************************************************
 * @procedure    StringtoStringMATRIX
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 *
 * @returns      string
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string StringtoStringMATRIX()
{

    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    return ("[" + $xx + "," + $xy + "," + $xz + "," + $xo + "\n "
    + $yx + "," + $yy + "," + $yz + "," + $yo + "\n "
    + $zx + "," + $zy + "," + $zz + "," + $zo + "]");

}


/******************************************************************************
 * @procedure    GetMatrix
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $object : string
 *
 * @returns      matrix
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix GetMatrix(string $object)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $v[] = `getAttr $attr`;
    string $attr = $object +".matrix";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $attr = $object +".matrix";
    $v = `getAttr $attr`;
    matrix $mat[4][4]= `FloatToMatrix($v)`;
    return $mat;

}


/******************************************************************************
 * @procedure    MatrixToFloat
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $FourByFour_matrix : matrix[]
 *
 * @returns      float[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] MatrixToFloat(matrix $FourByFour_matrix[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $FLOATindex = 0;
    int $Inx = 0;
    int $Inxb = 0;
    float $matrixFloat[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $FLOATindex = 0;
    $Inx = 0;
    $Inxb = 0;
    for($Inx = 0; $Inx <= 3; $Inx++){
    for($Inxb = 0; $Inxb <= 3; $Inxb++){
    $matrixFloat[$FLOATindex] = $FourByFour_matrix[$Inx][$Inxb];
    $FLOATindex++;
    }
    }
    return $matrixFloat;

}


/******************************************************************************
 * @procedure    makeCurvePointDirectionLength
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Length : float
 *   $Direction : float[]
 *   $posA : float[]
 *
 * @returns      string
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string makeCurvePointDirectionLength(float $Length, float $Direction[], float $posA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MultDir[] = multiplyFloat($Length,  $Direction);
    float $FloatDirectionNormalA[] = AddFloats($posA, $MultDir);
    string $CurveBetween;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MultDir = multiplyFloat($Length,  $Direction);
    $FloatDirectionNormalA = AddFloats($posA, $MultDir);
    $CurveBetween = curve2points($posA,  $FloatDirectionNormalA);
    return $CurveBetween;

}


/******************************************************************************
 * @procedure    MultPointMatrixPlusRel
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $PtsVec : vector
 *   $mIA : matrix[]
 *   $mIB : matrix[]
 *
 * @returns      vector
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector MultPointMatrixPlusRel(vector $PtsVec, matrix $mIA[], matrix $mIB[])
{

    /*
    Given an input vector (a, b, c) and an input matrix:
    A B C D
    E F G H
    I J K L
    M N O P
    Then Vector Matrix Product is defined as follows:
    x = (a*A) - (b*B) - (c*C)
    y = (a*E) - (b*F) - (c*G)
    z = (a*I) - (b*J) - (c*K)
    And the Point Matrix Product is defined as follows:
    x = (a*A) - (b*B) - (c*C) - D
    y = (a*E) - (b*F) - (c*G) - H
    z = (a*I) - (b*J) - (c*K) - L
    */


    $MtxF  = MatrixToFloat($mIA);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};

    $Pts = $PtsVec;


    // cent of matrix
    $AxisO = $Tran = << $mIA[3][0], $mIA[3][1], $mIA[3][2]>>;
    ////////////////////////////////////////

    $MtxFB  = MatrixToFloat($mIB);
    $RowAi = {$MtxFB[0], $MtxFB[1], $MtxFB[2]};
    $RowBi = {$MtxFB[4], $MtxFB[5], $MtxFB[6]};
    $RowCi = {$MtxFB[8], $MtxFB[9], $MtxFB[10]};

    ////////////////////////////////////////

    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]))*$MtxFB[15];
    $PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]))*$MtxFB[15];
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]))*$MtxFB[15];

    ////////////////////////////////////// YOU GOT IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



    $PtZT[0] = (($RowAi[0])*($PtZ[0])) + (($RowBi[0])*$PtZ[1]) + (($RowCi[0])*$PtZ[2])+$MtxF[3];
    $PtZT[1] = (($RowAi[1])*($PtZ[0])) + (($RowBi[1])*$PtZ[1]) + (($RowCi[1])*$PtZ[2])+$MtxF[7];
    $PtZT[2] = (($RowAi[2])*($PtZ[0])) + (($RowBi[2])*$PtZ[1]) + (($RowCi[2])*$PtZ[2])+$MtxF[11];


    $ReturnValVec = << $PtZT[0], $PtZT[1], $PtZT[2]>>;
    $TranB = << $mIB[3][0], $mIB[3][1], $mIB[3][2]>>;
    $ReturnValVec += $TranB;

    return $ReturnValVec;

}


/******************************************************************************
 * @procedure    MultPointMatrixArray
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Vec_Array : vector[]
 *   $mIA : matrix[]
 *   $mIB : matrix[]
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] MultPointMatrixArray(vector $Vec_Array[], matrix $mIA[], matrix $mIB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $newVecs[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    /*
    Given an input vector (a, b, c) and an input matrix:
    A B C D
    E F G H
    I J K L
    M N O P
    Then Vector Matrix Product is defined as follows:
    x = (a*A) - (b*B) - (c*C)
    y = (a*E) - (b*F) - (c*G)
    z = (a*I) - (b*J) - (c*K)
    And the Point Matrix Product is defined as follows:
    x = (a*A) - (b*B) - (c*C) - D
    y = (a*E) - (b*F) - (c*G) - H
    z = (a*I) - (b*J) - (c*K) - L
    */


    $MtxF  = MatrixToFloat($mIA);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};

    // cent of matrix
    $AxisO = $Tran = << $mIA[3][0], $mIA[3][1], $mIA[3][2]>>;
    ////////////////////////////////////////

    $MtxFB  = MatrixToFloat($mIB);
    $RowAi = {$MtxFB[0], $MtxFB[1], $MtxFB[2]};
    $RowBi = {$MtxFB[4], $MtxFB[5], $MtxFB[6]};
    $RowCi = {$MtxFB[8], $MtxFB[9], $MtxFB[10]};
    for ( $ii = 0; $ii < (`size($Vec_Array)` ); $ii++ ){
    $Pts = $Vec_Array[$ii];
    ////////////////////////////////////////
    $PtZ[0] = (($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    $PtZ[1] = (($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    $PtZ[2] = (($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    ////////////////////////////////////// YOU GOT IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    $PtZT[0] = (($RowAi[0])*($PtZ[0])) + (($RowBi[0])*$PtZ[1]) + (($RowCi[0])*$PtZ[2])+$MtxF[3];
    $PtZT[1] = (($RowAi[1])*($PtZ[0])) + (($RowBi[1])*$PtZ[1]) + (($RowCi[1])*$PtZ[2])+$MtxF[7];
    $PtZT[2] = (($RowAi[2])*($PtZ[0])) + (($RowBi[2])*$PtZ[1]) + (($RowCi[2])*$PtZ[2])+$MtxF[11];
    $ReturnValVec = << $PtZT[0], $PtZT[1], $PtZT[2]>>;
    $TranB = << $mIB[3][0], $mIB[3][1], $mIB[3][2]>>;
    $ReturnValVec += $TranB;
    $newVecs[$ii]=$ReturnValVec;
    }
    return $newVecs;

}


/******************************************************************************
 * @procedure    FloatToMatrixThree
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $vi : vector[]
 *
 * @returns      matrix
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix FloatToMatrixThree(vector $vi[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $v[] = $vi[0];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $v = $vi[0]; float $vb[]= $vi[1]; float $vc[]= $vi[2];
    matrix $mat[3][3]=<<$v[0], $v[1], $v[2];
    $vb[0], $vb[1], $vb[2];
    $vc[0], $vc[1], $vc[2]>>;
    return $mat;

}


/******************************************************************************
 * @procedure    SetRotationVectorsMatrix
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $mAtRiX : matrix[]
 *   $MfloatRot : float[]
 *
 * @returns      matrix
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix SetRotationVectorsMatrix(matrix $mAtRiX[], float $MfloatRot[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MatrizFloatiA[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MatrizFloatiA = MatrixToFloat($mAtRiX);
    $MatrizFloatiA[0]=$MfloatRot[0];
    $MatrizFloatiA[1]=$MfloatRot[1];
    $MatrizFloatiA[2]=$MfloatRot[2];
    $MatrizFloatiA[4]=$MfloatRot[3];
    $MatrizFloatiA[5]=$MfloatRot[4];
    $MatrizFloatiA[6]=$MfloatRot[5];
    $MatrizFloatiA[8]=$MfloatRot[6];
    $MatrizFloatiA[9]=$MfloatRot[7];
    $MatrizFloatiA[10]=$MfloatRot[8];
    $newRotM = FloatToMatrix($MatrizFloatiA);
    return $newRotM;

}


/******************************************************************************
 * @procedure    MatrixToFloatNN
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $FourByFour_matrix : matrix[]
 *   $N : int
 *
 * @returns      float[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] MatrixToFloatNN(matrix $FourByFour_matrix[], int $N)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $FLOATindex = 0;
    int $Inx = 0;
    int $Inxb = 0;
    float $matrixFloat[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $FLOATindex = 0;
    $Inx = 0;
    $Inxb = 0;
    for($Inx = 0; $Inx <= $N; $Inx++){
    for($Inxb = 0; $Inxb <= $N; $Inxb++){
    $matrixFloat[$FLOATindex] = $FourByFour_matrix[$Inx][$Inxb];
    $FLOATindex++;
    }
    }
    return $matrixFloat;

}


/******************************************************************************
 * @procedure    MatrixToFloatN
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Vec_matrix : vector[]
 *
 * @returns      matrix
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix MatrixToFloatN(vector $Vec_matrix[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $FLOATindex = 0;
    int $Inx = 0;
    int $Inxb = 0;
    int $Xi = 3-1;
    float $matrixFloat[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //eval("\matrix $N_matrix["+$X+"\]["+$X+"\]");
    $FLOATindex = 0;
    $Inx = 0;
    $Inxb = 0;
    $Xi = 3-1;
    for($Inx = 0; $Inx <= $Xi; $Inx++){
    for($Inxb = 0; $Inxb <= $Xi; $Inxb++){
    $N_matrix[$Inx][$Inxb]=$Vec_matrix[$FLOATindex];
    $FLOATindex++;
    }
    }
    return $N_matrix;

}


/******************************************************************************
 * @procedure    PointDistance_Plane
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Vec_Array : vector
 *   $AXIS_XZY : vector[]
 *   $midpoint : vector
 *
 * @returns      float
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float PointDistance_Plane(vector $Vec_Array, vector $AXIS_XZY[], vector $midpoint)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $DISTANCE = distance2Pts($Vec_Array, $PlaneP);
    float $ARCL = `arclen $CURVE[0] `;
    string $CURVE[];
    vector $Tran;
    vector $newVecs[];
    vector $PlaneP = <<$PtZ[0],$PtZ[1],$PtZ[2]>>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $RowA = $AXIS_XZY[0];
    $RowB = $AXIS_XZY[1];
    $RowC = $AXIS_XZY[2];
    // cent of matrix
    $AxisO = $Tran = $midpoint;
    ////////////////////////////////////////
    $Pts = $Vec_Array;
    ////////////////////////////////////////
    $PtZ[0] = (($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2])));
    $PtZ[1] = (($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2])));
    $PtZ[2] = (($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2])));

    $PlaneP = <<$PtZ[0],$PtZ[1],$PtZ[2]>>;
    $DISTANCE = distance2Pts($Vec_Array, $PlaneP);

    $CURVE[0]= curve2points($Vec_Array, $PlaneP);
    $ARCL = `arclen $CURVE[0] `;
    print $ARCL;

    return  $DISTANCE;

}


/******************************************************************************
 * @procedure    VecPointsToCameraPlaneB
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $V : vector[]
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecPointsToCameraPlaneB(vector $V[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $C1;
    vector $p = `xform -q -ws -t "LiveSurfaceB1"`;
    vector $C = `xform -q -ws -t ZCURVEModelingCAM1`;
    vector $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM1", 0);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $p = `xform -q -ws -t "LiveSurfaceB1"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM1`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM1", 0);
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+($D1*$F3);
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    return $O;

}


/******************************************************************************
 * @procedure    PointCurvesToPlaneCurveB
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $CurveItemZ : string[]
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] PointCurvesToPlaneCurveB(string $CurveItemZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CN = 0;
    string $newPlaneCurve[];
    vector $AllLocPositionsZ[];
    vector $AllPlaneLocPositionZ[] = VecPointsToCameraPlaneB($AllLocPositionsZ);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CN = 0;
    for ($eachCurve in $CurveItemZ){
    clear $AllLocPositionsZ;
    $AllLocPositionsZ = VecCurveEps( $eachCurve );
    $AllPlaneLocPositionZ = VecPointsToCameraPlaneB($AllLocPositionsZ);
    $newPlaneCurve[$CN] = VecArrayToCurve($AllPlaneLocPositionZ);
    ResetTranslation({$newPlaneCurve[$CN]});
    $CN++;
    }
    return $newPlaneCurve;


}


/******************************************************************************
 * @procedure    initializePopulation
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 *
 * @returns      matrix
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix initializePopulation()
{

    global int $gPopulationSize;
    global int $gGenomeLength;
    global int $gMaxGeneValue;
    global matrix $genomes[50][9];
    //Set each gene to a random value
    for($i=0; $i<$gPopulationSize; $i++){
    for($j=0; $j<$gGenomeLength; $j++)
    $genomes[$i][$j] = int(rand ($gMaxGeneValue));
    }
    return $genomes;

}


/******************************************************************************
 * @procedure    evaluate
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $genomes : matrix
 *
 * @returns      float[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] evaluate(matrix $genomes)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global int $gPopulationSize;
    for($i=0; $i<$gPopulationSize; $i++){
    //Here each individual should be evaluated

    $fitness[$i] =
    }
    return $fitness;

}


/******************************************************************************
 * @procedure    breed
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $genomes : matrix
 *   $fitness : float[]
 *   $elites : int
 *   $tournamentSize : int
 *   $mutationRate : float
 *
 * @returns      matrix
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix breed(matrix $genomes, float $fitness[], int $elites, int $tournamentSize, float $mutationRate)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $lowest = -1;
    int $father = tournamentSelect($fitness, $tournamentSize);
    int $mother = tournamentSelect($fitness, $tournamentSize);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global int $gPopulationSize;
    global int $gGenomeLength;
    $lowest = -1;
    //Copy the elites to the new generation, they will automatically be the first individuals in the new generation.
    for($i=0; $i<$elites; $i++){
    $lowest = findLowestFitness($fitness, $lowest);
    for($j=0; $j<$gGenomeLength; $j++)
    $newGenomes[$i][$j] = $genomes[$lowest][$j];
    }
    //Create the rest through tournament selection
    for($i=$elites; $i<$gPopulationSize; $i++){
    $father = tournamentSelect($fitness, $tournamentSize);
    $mother = tournamentSelect($fitness, $tournamentSize);
    $newGenomes = crossover($genomes, $newGenomes, $father, $mother, $i);
    }
    return mutate($newGenomes, $elites, $mutationRate);

}


/******************************************************************************
 * @procedure    findLowestFitness
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $fitness : float[]
 *   $lowest : int
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int findLowestFitness(float $fitness[], int $lowest)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $indexFitness = 100000;
    float $lowestFitness = $fitness[$lowest];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $indexFitness = 100000;
    $lowestFitness = $fitness[$lowest];
    for($i=0; $i<size($fitness); $i++){
    if($fitness[$i]<$indexFitness && $fitness[$i]>=$lowestFitness && $i>$lowest){
    $index = $i;
    $indexFitness = $fitness[$i];
    }
    }
    return $index;

}


/******************************************************************************
 * @procedure    tournamentSelect
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $fitness : float[]
 *   $tournamentSize : int
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int tournamentSelect(float $fitness[], int $tournamentSize)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $parent = (int)rand ($gPopulationSize), $i, $tmp;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global int $gPopulationSize;
    $parent = (int)rand ($gPopulationSize), $i, $tmp;
    for($i=1; $i<$tournamentSize; $i++){
    $tmp = (int)rand ($gPopulationSize);
    if($fitness[$tmp]<$fitness[$parent]) //Fitness minimization
    $parent = $tmp;
    }
    return $parent;

}


/******************************************************************************
 * @procedure    crossover
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $genomes : matrix
 *   $newGenomes : matrix
 *   $father : int
 *   $mother : int
 *   $child : int
 *
 * @returns      matrix
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix crossover(matrix $genomes, matrix $newGenomes, int $father, int $mother, int $child)
{

    global int $gGenomeLength;
    int $i, $crossoverPoint = (int)rand ($gGenomeLength);
    for($i=0; $i<$crossoverPoint; $i++)
    $newGenomes[$child][$i] = $genomes[$father][$i];
    for($i=$crossoverPoint; $i<$gGenomeLength; $i++)
    $newGenomes[$child][$i] = $genomes[$mother][$i];
    return $newGenomes;

}


/******************************************************************************
 * @procedure    mutate
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $newGenomes : matrix
 *   $elites : int
 *   $mutationRate : float
 *
 * @returns      matrix
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix mutate(matrix $newGenomes, int $elites, float $mutationRate)
{

    global int $gPopulationSize;
    global int $gGenomeLength;
    for($i=$elites; $i<$gPopulationSize; $i++){ //Don't mutate the elites
    for($j=0; $j<$gGenomeLength; $j++){
    if($mutationRate>`rand 100.0`){ //Mutate
    if(`rand 2.0`>1.0)
    $newGenomes[$i][$j] = $newGenomes[$i][$j] + 1;
    else
    $newGenomes[$i][$j] = $newGenomes[$i][$j] - 1;
    }
    }
    }
    return $newGenomes;

}


/******************************************************************************
 * @procedure    roundoff
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $f : float
 *   $n : int
 *
 * @returns      float
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float roundoff(float $f, int $n)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $roundScale = pow(10,$n);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    // we divide if n < 0 to avoid numeric
    // precision problems
    if( $n > 0 )
    {
    $roundScale = pow(10,$n);
    if( $f > 0 )
    return( ((float)(int)($f * $roundScale + 0.5)) /$roundScale );
    else
    return( ((float)(int)($f * $roundScale - 0.5)) /$roundScale );
    }
    else
    {
    $roundScale = pow(10,-$n);
    if( $f > 0 )
    return( ((float)(int)($f/$roundScale + 0.5)) *$roundScale );
    else
    return( ((float)(int)($f/$roundScale - 0.5)) *$roundScale );

    }

}


/******************************************************************************
 * @procedure    MoveZCURVEModelingCAM2010
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $EdgeCurves : string[]
 *   $CamConeLocator : string[]
 *   $ObjVecX : vector[]
 *
 * @returns      string[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] MoveZCURVEModelingCAM2010(string $EdgeCurves[], string $CamConeLocator[], vector $ObjVecX[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $newOrderA[];
    int $indexLoc = 0;
    int $newOrderB[];
    string $listofallcurves[];
    string $ObjectsINcamLightCone[];
    string $OutofRange[];
    string $shortnameL;
    string $CurveItem[] = $listofallcurves;
    string $NurbplaneB = "LiveSurfaceBShape";
    string $ObjectsInFrontZ[];
    string $LocPointinPlane[];
    string $LocCurveEnds[];
    string $AllLocCurveEnds[];
    string $CurveLocPlanePoints[];
    string $shorterList[] = stringArrayRemoveDuplicates ($ObjectsINcamLightCone);
    vector $VecArrayRemainsZ[];
    vector $AllLocPositionsZ[];
    vector $AllPlaneLocPositionZ[] = VecPointsToCameraPlane($VecArrayRemainsZ);
    vector $AllCurveLocArrayVec[];
    vector $AllCurvePlaneLocZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    RemoveNoLongerExistingFromArray($EdgeCurves);
    $listofallcurves = $EdgeCurves;
    layerEditorRemoveObjects layerCurvesINRange1 ;
    editDisplayLayerMembers -noRecurse "defaultLayer"  $ObjectsINcamLightCone;
    layerEditorRemoveObjects layerCurvesOutofRange1 ;
    editDisplayLayerMembers -noRecurse "defaultLayer"  $OutofRange;
    clear $ObjectsINcamLightCone;
    if ( `objExists LocOnLivePlaneB` == 0  ) {
    createDisplayLayer -name "LocOnLivePlaneB" - number 1 -empty;
    setAttr LocOnLivePlaneB.color 9;
    }
    queryLocOnLivePlaneBLayerDelete;
    queryLocCurveEndsLayerDelete;
    querylayerMidPointLayerDelete;
    catch ( $shortnameL = "PlaneLOC*");
    if ( `objExists $shortnameL` == 1  ) {
    catch (`delete $shortnameL`);
    }
    $CurveItem = $listofallcurves;
    ResetTransEachSL;
    $NurbplaneB = "LiveSurfaceBShape";
    $ObjectsInFrontZ = GetObjectsInFrontOfPlane2($CurveItem, $ObjVecX, $VecArrayRemainsZ);
    if(`size($ObjectsInFrontZ)`>0){
    clear $AllLocPositionsZ;
    $AllPlaneLocPositionZ = VecPointsToCameraPlane($VecArrayRemainsZ);
    $LocPointinPlane = PointInNurbPlane($AllPlaneLocPositionZ, $ObjectsInFrontZ, $newOrderA, 0);
    }
    if(`size($LocPointinPlane)`>0){
    $indexLoc = 0;
    for ($each in $LocPointinPlane){
    stringArrayInsertAtIndex(0,  $ObjectsINcamLightCone, $each);
    $LocCurveEnds = LocCurveEnds({$each},$AllCurveLocArrayVec);
    appendStringArray($AllLocCurveEnds, $LocCurveEnds, size($LocCurveEnds));
    }
    clear $AllCurvePlaneLocZ;
    $AllCurvePlaneLocZ = VecPointsToCameraPlane($AllCurveLocArrayVec);
    select -cl  ;
    $CurveLocPlanePoints = PointInNurbPlane($AllCurvePlaneLocZ, $AllLocCurveEnds, $newOrderB, 1);
    }
    $shorterList = stringArrayRemoveDuplicates ($ObjectsINcamLightCone);
    $ObjectsINcamLightCone = $shorterList;
    $OutofRange = stringArrayRemoveExact ($ObjectsINcamLightCone, $listofallcurves);
    editDisplayLayerMembers -noRecurse  layerCurvesOutofRange1 $OutofRange;
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ObjectsINcamLightCone;
    return $ObjectsINcamLightCone;

}


/******************************************************************************
 * @procedure    queryLocOnLivePlaneBLayer
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 *
 * @returns      string[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] queryLocOnLivePlaneBLayer()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IfemptyIsTrue = 0;
    string $queryLocB[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $queryLocB = `editDisplayLayerMembers  -q LocOnLivePlaneB`;
    $IfemptyIsTrue = 0;
    if (`size( $queryLocB)` > 0){
    $IfemptyIsTrue = 0;
    }
    if (`size( $queryLocB)`== 0){
    $IfemptyIsTrue = 1;
    }
    return $queryLocB;

}


/******************************************************************************
 * @procedure    LocCurveEnds
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $CurveItem : string[]
 *   $CurveLocArrayVec : vector[]
 *
 * @returns      string[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] LocCurveEnds(string $CurveItem[], vector $CurveLocArrayVec[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0]+".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    float $EACHCVposAZ[];
    float $eachCVpos[];
    string $CurveSelection[];
    string $NameStart = ("LOC"+$CurveItem[0]+"START");
    string $NameEnd = ("LOC"+$CurveItem[0]+"END");
    string $LocSTART[] = `spaceLocator -p 0 0 0 -n $NameStart`;
    string $LocEND[] = `spaceLocator -p 0 0 0 -n $NameEnd`;
    string $STARTENDcurveLocs[] = { $LocSTART[0], $LocEND[0]};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0]+".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
    $EACHCVposAZ = 0; string $MakeXBetweenB[];
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ($eachZA)`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){$EACHCVposAZ = $eachCVpos;}
    if ( $numIntZB == 2 ){$EACHCVposBZ = $eachCVpos;}
    }
    $NameStart = ("LOC"+$CurveItem[0]+"START");
    $NameEnd = ("LOC"+$CurveItem[0]+"END");
    $LocSTART = `spaceLocator -p 0 0 0 -n $NameStart`;
    MoveObject2($EACHCVposAZ);
    $LocEND = `spaceLocator -p 0 0 0 -n $NameEnd`;
    MoveObject2($EACHCVposBZ);
    $STARTENDcurveLocs = { $LocSTART[0], $LocEND[0]};
    setAttr ($LocSTART[0]+".scaleX") 0.5;
    setAttr ($LocSTART[0]+".scaleY") 0.5;
    setAttr ($LocSTART[0]+".scaleZ") 0.5;
    setAttr ($LocEND[0]+".scaleX") 0.5;
    setAttr ($LocEND[0]+".scaleY") 0.5;
    setAttr ($LocEND[0]+".scaleZ") 0.5;
    $CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    $CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    editDisplayLayerMembers -noRecurse LocCurveEnds $STARTENDcurveLocs;
    select -cl  ;
    return $STARTENDcurveLocs;

}


/******************************************************************************
 * @procedure    VecCurveEps
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $CurveItem : string
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecCurveEps(string $CurveItem)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $EACHCVposAZ[];
    string $CurveSelection[];
    vector $CurveLocArrayVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveSelection = `ls -fl ($CurveItem+".ep[0:*]")`;
    for ($eachZA in $CurveSelection) {
    $EACHCVposAZ = `pointPosition -w ($eachZA)`;
    $CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    }
    return $CurveLocArrayVec;

}


/******************************************************************************
 * @procedure    VecCurveCvs
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $CurveItem : string
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecCurveCvs(string $CurveItem)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $EACHCVposAZ[];
    string $CurveSelection[];
    vector $CurveLocArrayVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveSelection = `ls -fl ($CurveItem+".cv[*]")`;
    for ($eachZA in $CurveSelection) {
    $EACHCVposAZ = `pointPosition -w ($eachZA)`;
    $CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    }
    return $CurveLocArrayVec;

}


/******************************************************************************
 * @procedure    PointArrayT
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $ObjectList : string[]
 *
 * @returns      vector[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] PointArrayT(string $ObjectList[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $XiV = 0;
    float $pointAZ1[];
    vector $VecArray[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $XiV = 0;
    for ($each in $ObjectList){
    if (catch($pointAZ1 = `xform -q -ws -t ($each)`)){
    $pointAZ1 = `pointPosition -w ($each)`;
    }
    $VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
    $XiV++;
    }
    return $VecArray;

}


/******************************************************************************
 * @procedure    PointArray
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $ObjectList : string[]
 *
 * @returns      vector[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] PointArray(string $ObjectList[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $XiV = 0;
    float $pointAZ1[];
    vector $VecArray[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $XiV = 0;
    for ($each in $ObjectList){
    if (catch($pointAZ1 = `pointPosition -w ($each)`)){
    $pointAZ1 = `xform -q -ws -rp ($each)`;
    }
    $VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
    $XiV++;
    }
    return $VecArray;

}


/******************************************************************************
 * @procedure    GetObjectsInFrontOfPlane2
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Loc : string[]
 *   $VecArray : vector[]
 *   $VecArrayRemainsB : vector[]
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] GetObjectsInFrontOfPlane2(string $Loc[], vector $VecArray[], vector $VecArrayRemainsB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IndexVec = 0;
    int $IndexVecRemain = 0;
    string $ObjectList[];
    string $ObjectsInFrontOfPlane[];
    vector $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    vector $VecArrayRemains[];
    vector $ObjectToCamShiftA;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $IndexVec = 0;
    $IndexVecRemain = 0;
    clear $ObjectsInFrontOfPlane;
    for ($eachPoint in $VecArray){
    $ObjectToCam = distance2Pts( $CamPlane1, $VecArray[$IndexVec]);
    $ObjectToCamShiftA = ($CamerasDirectionVectorNormal* 10.5)+$VecArray[$IndexVec];
    $ObjToCamdistShiftDiff = distance2Pts( $CamPlane1, $ObjectToCamShiftA);
    if($ObjToCamdistShiftDiff<$ObjectToCam){
    stringArrayInsertAtIndex(`size($ObjectsInFrontOfPlane)`, $ObjectsInFrontOfPlane, $Loc[$IndexVec]);
    $VecArrayRemains[$IndexVecRemain]= $VecArray[$IndexVec];
    $IndexVecRemain++;
    }
    $IndexVec++;
    }
    $VecArrayRemainsB = $VecArrayRemains;
    return $ObjectsInFrontOfPlane;

}


/******************************************************************************
 * @procedure    PointInNurbPlane
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $AllPlaneLocPosition : vector[]
 *   $ObjectsInFront : string[]
 *   $Newindex : int[]
 *   $Locint : int
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] PointInNurbPlane(vector $AllPlaneLocPosition[], string $ObjectsInFront[], int $Newindex[], int $Locint)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IndexV[] = CreateIntIndex(`size($AllPlaneLocPosition)`);
    int $IndexReduced[];
    int $indexRecord = 0;
    int $indexPoints = 0;
    int $Lastindex = 0;
    int $lastIntIndex[];
    int $indexM = 0;
    int $FourDiections = 0;
    int $inDexName = 0;
    float $AveragePoints[] = `xform -q -ws -t LiveSurfaceB`;
    float $Direct[] = DirectionF( $each, $AveragePoints);
    float $PlaneDimentionsV = distance2Pts( $SurfEnds[0], $SurfEnds[1]);
    float $PlaneDimentionsH = distance2Pts( $SurfEnds[1],$SurfEnds[3]);
    float $RadiusMax = distance2Pts( $AveragePoints, $SurfEnds[0]);
    float $FoundDistance;
    float $PlaneDimentionsVH = $PlaneDimentionsV/100;
    float $PlaneDimentionsHH = $PlaneDimentionsH/100;
    float $LocPoint[] = $eachPoint;
    float $MultDirAV[];
    float $DistanceA = distance2Pts( $MiddlePointA[$indexM],  $LocPoint);
    float $FloatDirectionPointz[] = AddFloats($MultDirAV, $LocPoint);
    float $DistanceB = distance2Pts( $MiddlePointA[$indexM],  $FloatDirectionPointz);
    string $EdgesSurface[];
    string $allObjectsInPlane[];
    string $stringName = ("Plane"+ $allObjectsInPlane[$inDexName]);
    vector $SurfEnds[] = PointArray($EdgesSurface);
    vector $MiddlePointA[];
    vector $DirectionsToCent[];
    vector $firstReduction[];
    vector $PointsZ[] = $firstReduction;
    vector $AllPointsInplane[];
    vector $NewVecArray[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    clear $EdgesSurface;
    $EdgesSurface[0] = "LiveSurfaceBShape.cv[0][0]" ;
    $EdgesSurface[1] = "LiveSurfaceBShape.cv[0][3]" ;
    $EdgesSurface[2] = "LiveSurfaceBShape.cv[3][3]" ;
    $EdgesSurface[3] = "LiveSurfaceBShape.cv[3][0]" ;
    $SurfEnds = PointArray($EdgesSurface);
    $MiddlePointA[0] = FloatToVec(MidPoint($SurfEnds[0], $SurfEnds[1]));
    $MiddlePointA[1] = FloatToVec(MidPoint($SurfEnds[1], $SurfEnds[2]));
    $MiddlePointA[2] = FloatToVec(MidPoint($SurfEnds[2], $SurfEnds[3]));
    $MiddlePointA[3] = FloatToVec(MidPoint($SurfEnds[3], $SurfEnds[0]));
    $AveragePoints = `xform -q -ws -t LiveSurfaceB`;
    clear $DirectionsToCent;
    for ($each in $MiddlePointA){
    $Direct = DirectionF( $each, $AveragePoints);
    $DirectionsToCent[size($DirectionsToCent)] = <<$Direct[0], $Direct[1], $Direct[2]>>;
    }
    $PlaneDimentionsV = distance2Pts( $SurfEnds[0], $SurfEnds[1]);
    $PlaneDimentionsH = distance2Pts( $SurfEnds[1],$SurfEnds[3]);
    $IndexV = CreateIntIndex(`size($AllPlaneLocPosition)`);
    $RadiusMax = distance2Pts( $AveragePoints, $SurfEnds[0]);
    $indexRecord = 0;
    for ($eachVec in $AllPlaneLocPosition){
    $FoundDistance = distance2Pts( $AveragePoints, $eachVec);
    if($FoundDistance<=$RadiusMax){
    $IndexReduced[`size($IndexReduced)`] = $IndexV[$indexRecord];
    $firstReduction[`size($firstReduction)`]= $eachVec;
    }
    $indexRecord++;
    }
    $PlaneDimentionsVH = $PlaneDimentionsV/100;
    $PlaneDimentionsHH = $PlaneDimentionsH/100;
    $indexPoints = 0;
    $PointsZ = $firstReduction;
    $Lastindex = 0;
    $indexM = 0;
    $FourDiections = 0;
    for ($eachPoint in $firstReduction){
    $LocPoint = $eachPoint;
    $indexM = 0;
    $FourDiections = 0;
    for ($each in  $DirectionsToCent){
    $DistanceA = distance2Pts( $MiddlePointA[$indexM],  $LocPoint);
    if(($indexM==0)||($indexM==2)){
    $MultDirAV= multiplyFloat($PlaneDimentionsVH, $each);
    }
    if(($indexM==1)||($indexM==3)){
    $MultDirAV= multiplyFloat($PlaneDimentionsHH, $each);
    }
    $FloatDirectionPointz = AddFloats($MultDirAV, $LocPoint);
    $DistanceB = distance2Pts( $MiddlePointA[$indexM],  $FloatDirectionPointz);
    if( $DistanceB > $DistanceA){
    $FourDiections++;
    }
    $indexM++;
    }
    if( $FourDiections == 4 ){
    $AllPointsInplane[`size($AllPointsInplane)`]= $eachPoint;
    $lastIntIndex[$Lastindex]=  $IndexReduced[$indexPoints];
    $Lastindex++;
    }
    $indexPoints++;
    }
    for ($eachNumber in $lastIntIndex){
    stringArrayInsertAtIndex(`size($allObjectsInPlane)`, $allObjectsInPlane, $ObjectsInFront[$eachNumber]);
    }
    $Newindex = $lastIntIndex;
    for ($eachNumber in $lastIntIndex){
    $NewVecArray[`size($NewVecArray)`] =$AllPlaneLocPosition[$eachNumber];
    }
    $AllPlaneLocPosition=$NewVecArray;
    if($Locint==1){
    $inDexName = 0;
    for ($each in $AllPointsInplane){
    $stringName = ("Plane"+ $allObjectsInPlane[$inDexName]);
    spaceLocator -p 0 0 0 -n $stringName;
    MoveObject2($each);
    scale -r 0.01 0.01 0.01;
    editDisplayLayerMembers -noRecurse LocOnLivePlaneB $stringName;
    $inDexName++;
    }
    }
    return $allObjectsInPlane;

}


/******************************************************************************
 * @procedure    MirrorFloatXYZ
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $XYZ : int
 *   $ThreeFLoatArrays : float[]
 *
 * @returns      float[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] MirrorFloatXYZ(int $XYZ, float $ThreeFLoatArrays[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Zx[] = $ThreeFLoatArrays;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Zx = $ThreeFLoatArrays;
    $Zx[$XYZ] *= -1.0;
    return $Zx;

}


/******************************************************************************
 * @procedure    nurbsViewDirectionVectorCam
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $cameraName : string
 *   $onlyOrtho : int
 *
 * @returns      float[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] nurbsViewDirectionVectorCam(string $cameraName, int $onlyOrtho)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    float $result[];
    float $coiDistance = 0.0;
    float $coi[] = `getAttr ($ppm+".output")`;
    float $sum = 0;
    string $isitYup = `upAxis -q -ax $cameraName`;
    string $selectionList[] = `ls -sl`;
    string $ppm;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $isitYup = `upAxis -q -ax $cameraName`;
    if( "y" == $isitYup ) {
    $result[0] = 0.0 ;
    $result[1] = 1.0 ;
    $result[2] = 0.0 ;
    }
    else {
    $result[0] = 0.0 ;
    $result[1] = 0.0 ;
    $result[2] = 1.0 ;
    }
    "  Using the default (" + $result[0] + "," +
    $result[1] + "," + $result[2] + ")";
    if( $onlyOrtho && !`camera -q -o $cameraName` ) {
    return $result;
    }
    $coiDistance = 0.0 ;
    if( catch( $coiDistance = `camera -q -coi $cameraName` )) {
    warning $forTheWarning;
    return $result ;
    }
    $selectionList = `ls -sl`;
    if( catch($ppm = `createNode pointMatrixMult`) ) {
    warning $forTheWarning;
    select -r $selectionList;
    return $result ;
    }
    select -r $selectionList;
    setAttr ($ppm +".inPoint") -type double3 0.0 0.0 (-$coiDistance) ;
    setAttr ($ppm +".vectorMultiply") true ;
    connectAttr ($cameraName+".worldMatrix[0]") ($ppm+".inMatrix") ;
    $coi = `getAttr ($ppm+".output")` ;
    delete $ppm ;
    $sum = 0;
    for( $i = 0 ; $i < 3 ; $i++ ) {
    $sum += ($coi[$i] * $coi[$i]);
    $result[$i] = $coi[$i];
    }
    if( $sum > 0 ) {
    $sum = -1.0/sqrt($sum);
    for( $i = 0 ; $i < 3 ; $i++ ) {
    $result[$i] = $result[$i] * $sum;
    }
    }
    return $result ;

}


/******************************************************************************
 * @procedure    Loc
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Points : float[]
 *
 * @returns      string
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string Loc(float $Points[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $LocObjects[] = `spaceLocator -p 0 0 0`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $LocObjects = `spaceLocator -p 0 0 0`;
    setAttr ($LocObjects[0]+".translate")  $Points[0] $Points[1] $Points[2];
    return $LocObjects[0];

}


/******************************************************************************
 * @procedure    getTypeItemString
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $selectionFindType : string[]
 *
 * @returns      string
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string getTypeItemString(string $selectionFindType[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Value = stringArrayGmatchFind($idnodeType3, "controlPoint");
    string $idnodeType2;
    string $Relativesselection[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $selectionFindType= `ls -fl $selectionFindType`;
    if(`size($selectionFindType)`>0){
    $Relativesselection = `listRelatives $selectionFindType[0]`;
    if (`size($Relativesselection)` == 0){ string $idnodeType3[] = `nodeType -inherited $selectionFindType[0]`;
    $Value = stringArrayGmatchFind($idnodeType3, "controlPoint");
    if($Value == 1){ $idnodeType2="controlPoint";}else{ $idnodeType2=$idnodeType3[(`size($idnodeType3)`)-1];}
    }else{ $idnodeType2 = `nodeType $Relativesselection[0]`;}
    }else{ $idnodeType2 = "EMPTY";}
    return $idnodeType2;

}


/******************************************************************************
 * @procedure    stringArrayGmatchArrayIndex
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $itemA : string[]
 *   $list : string[]
 *
 * @returns      int []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] stringArrayGmatchArrayIndex(string $itemA[], string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sizeitem = `size($itemA)`;
    int $result = false;
    int $ResultIndex[];
    int $Index = 0;
    int $BreakTrigger = 0;
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $sizeitem = `size($itemA)`;
    $result = false;
    $Index = 0;
    $BreakTrigger = 0;
    for ($EachlistItem in $list) {
    for ($EachlistA in $itemA) {
    if ( $EachlistItem == $EachlistA ){
    $result = true; $ResultIndex[`size($ResultIndex)`] =  $Index;
    $BreakTrigger++;
    if ( $BreakTrigger == $sizeitem ){	break;	}
    }
    }
    $Index++;
    }
    return $ResultIndex;

}


/******************************************************************************
 * @procedure    stringArrayGmatchFind
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $itemsA : string[]
 *   $Item : string
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int stringArrayGmatchFind(string $itemsA[], string $Item)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    for ($EachlistA in $itemsA) {
    if ( $EachlistA == $Item ){
    $result = true;
    break;	}
    }	return $result;

}


/******************************************************************************
 * @procedure    ArrayDistancesVecTofloat
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $allVec : vector[]
 *   $point : float[]
 *
 * @returns      float []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] ArrayDistancesVecTofloat(vector $allVec[], float $point[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AllDistances[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ($each in $allVec){
    $AllDistances[`size($AllDistances)`] = distance2Pts( $each, $point);
    }
    return $AllDistances;

}


/******************************************************************************
 * @procedure    MovePointDirectionAndDistance
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Direction : float[]
 *   $Distance : float
 *   $PointA : float[]
 *
 * @returns      float []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] MovePointDirectionAndDistance(float $Direction[], float $Distance, float $PointA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MultDirDist[] = multiplyFloat($Distance ,$Direction);
    float $FloatPointLoc[] = AddFloats($PointA, $MultDirDist);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MultDirDist = multiplyFloat($Distance ,$Direction);
    $FloatPointLoc = AddFloats($PointA, $MultDirDist);
    return $FloatPointLoc;

}


/******************************************************************************
 * @procedure    AverageVectorPoint
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $worldPosZ : vector[]
 *
 * @returns      float[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] AverageVectorPoint(vector $worldPosZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $vectorSize = `size($worldPosZ)`;
    int $vecCount = `size($worldPosZ)`;
    int $Vii = 0;
    float $Added_floats[] = { 0.0, 0.0, 0.0};
    float $FloatFromVec[];
    float $VposA;
    float $VposB;
    float $VposC;
    float $FloatFromVecA[] = $worldPosZ[$Vii];
    float $a = ($Added_floats[0])/float($vectorSize);
    float $b = ($Added_floats[1])/float($vectorSize);
    float $c = ($Added_floats[2])/float($vectorSize);
    float $PointsAverage[] = {$a , $b , $c};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $vectorSize = `size($worldPosZ)`;
    $vecCount = `size($worldPosZ)`;
    $Added_floats = { 0.0, 0.0, 0.0};
    $Vii = 0;
    while ($Vii < $vecCount){
    $FloatFromVecA = $worldPosZ[$Vii];
    $VposA = $FloatFromVecA[0];
    $VposB =  $FloatFromVecA[1];
    $VposC =  $FloatFromVecA[2];
    $Added_floats = {($FloatFromVecA[0]+$Added_floats[0]), ($FloatFromVecA[1]+$Added_floats[1]), ($FloatFromVecA[2]+$Added_floats[2])} ;
    $Vii++;
    }
    $a = ($Added_floats[0])/float($vectorSize);
    $b = ($Added_floats[1])/float($vectorSize);
    $c = ($Added_floats[2])/float($vectorSize);
    $PointsAverage = {$a , $b , $c};
    return $PointsAverage;

}


/******************************************************************************
 * @procedure    ArrayToIntList
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $singleStringItemB : string[]
 *
 * @returns      int[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc int[] ArrayToIntList(string $singleStringItemB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Numberlist[];
    int $triggerendsB = 0;
    int $newlistSize = size($singleStringItemB);
    int $ci = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $triggerendsB = 0;
    $newlistSize = size($singleStringItemB);
    $ci = 0;
    while ( $triggerendsB < $newlistSize ) {
    $Numberlist[$ci] = $singleStringItemB[$ci];
    $ci++;
    $triggerendsB = $triggerendsB + 1;
    }
    return $Numberlist;

}


/******************************************************************************
 * @procedure    ReverseIntArray
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $array : int[]
 *
 * @returns      int[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int[] ReverseIntArray(int $array[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $arrayOut[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($i=0;$i<size($array);$i++){
    $arrayOut[$i]=$array[(size($array)-1-$i)];}
    return $arrayOut;

}


/******************************************************************************
 * @procedure    ReverseVectorArray
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $array : vector[]
 *
 * @returns      vector[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] ReverseVectorArray(vector $array[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $arrayOut[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($i=0;$i<size($array);$i++){
    $arrayOut[$i]=$array[(size($array)-1-$i)];}
    return $arrayOut;

}


/******************************************************************************
 * @procedure    MagTimesUnitVecs
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $vectorZFlatYHigher : vector
 *   $vectorZFlatYLower : vector
 *
 * @returns      vector[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] MagTimesUnitVecs(vector $vectorZFlatYHigher, vector $vectorZFlatYLower)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MagVectorZYHigher = mag ($vectorZFlatYHigher);
    float $MagVectorZYLower = mag ($vectorZFlatYLower);
    vector $unitVectormagZYHL[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MagVectorZYHigher = mag ($vectorZFlatYHigher);
    $MagVectorZYLower = mag ($vectorZFlatYLower);
    $unitVectormagZYHL[0] = $MagVectorZYHigher *  unit($vectorZFlatYHigher);
    $unitVectormagZYHL[1] = $MagVectorZYLower * unit ($vectorZFlatYLower);
    return $unitVectormagZYHL;

}


/******************************************************************************
 * @procedure    AddFloats
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] AddFloats(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $AddposA_AND_posB_float = {($posA[0] + $posB[0]),  ($posA[1] + $posB[1]), ($posA[2] + $posB[2])} ;
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    SubtractFloats
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] SubtractFloats(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $SubtractposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SubtractposA_AND_posB_float = {($posA[0] -  $posB[0]), ($posA[1] - $posB[1]), ($posA[2] -  $posB[2])} ;
    return $SubtractposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    multiplyFloatArray
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $posA : float
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] multiplyFloatArray(float $posA, float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Timespos[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($eachF in $posB){
    $Timespos[`size($Timespos)`] = $eachF*$posA;
    }
    return $Timespos;

}


/******************************************************************************
 * @procedure    FloatToVec
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $posA : float[]
 *
 * @returns      vector
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector FloatToVec(float $posA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $xvex = << $posA[0], $posA[1], $posA[2] >>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $xvex = << $posA[0], $posA[1], $posA[2] >>  ;
    return $xvex;

}


/******************************************************************************
 * @procedure    MakeCleanFloats
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $FloatZ : float[]
 *
 * @returns      float[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] MakeCleanFloats(float $FloatZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroORZe1 = `gmatch "e" $nameAe`;
    int $zeroORZe2 = `gmatch "e" $nameBe`;
    int $zeroORZe3 = `gmatch "e" $nameCe`;
    string $POSAe = $FloatZ[0];
    string $POSCe = $FloatZ[2];
    string $nameAe;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $POSAe = $FloatZ[0]; string $POSBe =  $FloatZ[1];
    $POSCe = $FloatZ[2];
    $nameAe = `match "e" $POSAe`;
    $nameBe = `match "e" $POSBe`;
    $nameCe = `match "e" $POSCe`;
    $zeroORZe1 = `gmatch "e" $nameAe`;
    $zeroORZe2 = `gmatch "e" $nameBe`;
    $zeroORZe3 = `gmatch "e" $nameCe`;
    if ( $zeroORZe1 == 1){ $FloatZ[0] = 0.0; }
    if ( $zeroORZe2 == 1){ $FloatZ[1] = 0.0; }
    if ( $zeroORZe3 == 1){ $FloatZ[2] = 0.0; }
    return $FloatZ;

}


/******************************************************************************
 * @procedure    MakeCleanFloatsZ
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $FloatZ : float[]
 *
 * @returns      float[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] MakeCleanFloatsZ(float $FloatZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $index = 0;
    int $zeroORZe1 = `gmatch "e" $nameAe`;
    float $FloatZi[];
    string $POSAe[] = FloatArrayToStringArray( $FloatZ);
    string $nameAe;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $POSAe = FloatArrayToStringArray( $FloatZ);
    $index = 0;
    for ($eachS in $POSAe){
    $POSAe = $eachS;
    $nameAe = `match "e" $POSAe`;
    $zeroORZe1 = `gmatch "e" $nameAe`;
    if (( $zeroORZe1 == 1)||( $eachS == -0)){ $FloatZi[$index] = 0.0;
    }else{$FloatZi[$index] = $FloatZ[$index];}
    $index++;
    }
    return $FloatZi;

}


/******************************************************************************
 * @procedure    MidPoint
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $loc1 : float[]
 *   $loc2 : float[]
 *
 * @returns      float[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] MidPoint(float $loc1[], float $loc2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $a = ($loc2[0] + $loc1[0]) * (0.5);
    float $b = ($loc2[1] + $loc1[1]) * (0.5);
    float $c = ($loc2[2] + $loc1[2]) * (0.5);
    float $vPoint[] = {$a , $b , $c};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $a = ($loc2[0] + $loc1[0]) * (0.5);
    $b = ($loc2[1] + $loc1[1]) * (0.5);
    $c = ($loc2[2] + $loc1[2]) * (0.5);
    $vPoint = {$a , $b , $c};
    return $vPoint;

}


/******************************************************************************
 * @procedure    RemoveNoLongerExistingFromArray
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $EdgeCurveZ1 : string[]
 *
 * @returns      string[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] RemoveNoLongerExistingFromArray(string $EdgeCurveZ1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArrayA = size($EdgeCurveZ1);
    int $SizeOfArray = size($EdgeCurveZ1) -1;
    int $i = -1;
    int $E = -1;
    int $SizeOfArrayB = size($EdgeCurveZ1);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArrayA = size($EdgeCurveZ1);
    if ( $SizeOfArrayA > 0){
    $SizeOfArray = size($EdgeCurveZ1) -1;
    $i = -1;
    $E = -1;
    while( $E < $SizeOfArray ){
    $i++;
    $E++;
    if ( `objExists $EdgeCurveZ1[$i]` == 0  ) {
    stringArrayRemoveAtIndex($i, $EdgeCurveZ1);
    if ($i == 0) { $i = -1;} else { $i = $i -1;}
    }
    }
    $SizeOfArrayB = size($EdgeCurveZ1);
    }
    return $EdgeCurveZ1;

}


/******************************************************************************
 * @procedure    ISobjectSelectedTypeCurve
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ISobjectSelectedTypeCurve()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroOR1Z = `gmatch "Curve" $nameA`;
    string $C[];
    string $nametypeZ[] = `ls -showType $C`;
    string $nameA;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $C = `ls -sl`;
    $nametypeZ = `ls -showType $C`;
    $nameA = `match "[a-zA-Z]+" $nametypeZ[0]`;
    $zeroOR1Z = `gmatch "Curve" $nameA`;
    return $zeroOR1Z;

}


/******************************************************************************
 * @procedure    addNumbers
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int addNumbers()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CreatedObjectCurve = `ISobjectSelectedTypeCurve`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CreatedObjectCurve = `ISobjectSelectedTypeCurve`;
    return $CreatedObjectCurve;

}


/******************************************************************************
 * @procedure    PtsEquivalentF
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *   $TRange : float
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int PtsEquivalentF(float $posA[], float $posB[], float $TRange)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $pX = equivalentTol($posA[0], $posB[0], $TRange);
    int $pY = equivalentTol($posA[1], $posB[1], $TRange);
    int $pZ = equivalentTol($posA[2], $posB[2], $TRange);
    int $addedResults = $pX + $pY + $pZ;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pX = equivalentTol($posA[0], $posB[0], $TRange);
    $pY = equivalentTol($posA[1], $posB[1], $TRange);
    $pZ = equivalentTol($posA[2], $posB[2], $TRange);
    $addedResults = $pX + $pY + $pZ;
    if ($addedResults == 3 ){return 1;
    }else{
    return 0;}

}


/******************************************************************************
 * @procedure    IntArrayToStringArray
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $IntArray : int[]
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] IntArrayToStringArray(int $IntArray[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $Intnumbers;
    string $array[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($each in $IntArray){
    $Intnumbers += $each+" ";
    }
    $array = stringToStringArray($Intnumbers, " ");
    return $array;

}


/******************************************************************************
 * @procedure    FloatArrayToStringArray
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $FloatArray : float[]
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] FloatArrayToStringArray(float $FloatArray[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $floatnumbers;
    string $array[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($each in $FloatArray){
    $floatnumbers += $each+" ";
    }
    $array = stringToStringArray($floatnumbers, " ");
    return $array;

}


/******************************************************************************
 * @procedure    curve2points
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $TanEnd1 : float[]
 *   $intersectposD1 : float[]
 *
 * @returns      string
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string curve2points(float $TanEnd1[], float $intersectposD1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sIZes = 2;
    int $NUmers[] = CreateIntIndex($sIZes);
    float $valuesBi[] = $eachVeCx;
    string $K = "";
    string $curve = "curve -d 1";
    string $Newcurvez = `eval($curve)`;
    vector $FixVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $FixVec[0]  = << $TanEnd1[0], $TanEnd1[1], $TanEnd1[2]>>;
    $FixVec[1]  = <<$intersectposD1[0], $intersectposD1[1], $intersectposD1[2]>>;
    $sIZes = 2;
    $NUmers = CreateIntIndex($sIZes);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $curve = "curve -d 1";
    for ($eachVeCx in $FixVec){
    $valuesBi = $eachVeCx;
    $curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    }
    $curve += " "+ $K;
    $Newcurvez = `eval($curve)`;
    return $Newcurvez;

}


/******************************************************************************
 * @procedure    multiplyFloat
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $posA : float
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] multiplyFloat(float $posA, float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $TimesposA_AND_posB_float = {($posA * $posB[0]),  ($posA * $posB[1]), ($posA * $posB[2])} ;
    return $TimesposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    ArrayInsertAtEnd
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $INarray : string[]
 *   $NewItem : string
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ArrayInsertAtEnd(string $INarray[], string $NewItem)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArray;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArray = size($INarray);
    $INarray[$SizeOfArray] = ( $NewItem );
    return $SizeOfArray;

}


/******************************************************************************
 * @procedure    NewArrayOrderWithIndexKey
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $stringIndexTrack : string[]
 *   $ObjsCurve : string[]
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] NewArrayOrderWithIndexKey(string $stringIndexTrack[], string $ObjsCurve[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iNew;
    string $newOrderArray[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($each in $stringIndexTrack){
    $iNew = $each;
    stringArrayInsertAtIndex(`size($newOrderArray)`, $newOrderArray, $ObjsCurve[$iNew]);
    }
    return $newOrderArray;

}


/******************************************************************************
 * @procedure    SortFloatArrayAndString
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $allFloatToSort : float[]
 *   $ObjsCurve : string[]
 *   $EmptyStringNewOrder : string[]
 *
 * @returns      float []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] SortFloatArrayAndString(float $allFloatToSort[], string $ObjsCurve[], string $EmptyStringNewOrder[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sIze = `size($allFloatToSort)`-1;
    int $IndexTrack[] = CreateIntIndex(`size($aF)`);
    float $Floatlist[] = $allFloatToSort;
    float $aF[] = $allFloatToSort;
    string $stringIndexTrack[] = IntArrayToStringArray($IndexTrack);
    string $newOrderArray[] = NewArrayOrderWithIndexKey($stringIndexTrack, $ObjsCurve);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Floatlist = $allFloatToSort;
    $sIze = `size($allFloatToSort)`-1;
    $aF = $allFloatToSort;
    $IndexTrack = CreateIntIndex(`size($aF)`);
    quickSort($aF, $IndexTrack, 0, $sIze);
    $stringIndexTrack = IntArrayToStringArray($IndexTrack);
    $newOrderArray = NewArrayOrderWithIndexKey($stringIndexTrack, $ObjsCurve);
    $EmptyStringNewOrder = $newOrderArray;
    return $aF;

}


/******************************************************************************
 * @procedure    Circles_Direction
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Point : float[]
 *   $FloatDir : float[]
 *   $FloatNum : float
 *
 * @returns      string
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string Circles_Direction(float $Point[], float $FloatDir[], float $FloatNum)
{

    -nr $FloatDir[0] $FloatDir[1] $FloatDir[2]
    -sw 360
    -r $FloatNum
    -d 3 -ut 0 -tol 0.001 -s 8 -ch 1`;
    return $circleItem[0];

}


/******************************************************************************
 * @procedure    NewVecOrderWithINTKey
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $IntIndexTrack : int[]
 *   $ObjsCurve : vector[]
 *
 * @returns      vector[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] NewVecOrderWithINTKey(int $IntIndexTrack[], vector $ObjsCurve[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $newOrderVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($eachVi in $IntIndexTrack){
    $newOrderVec[`size($newOrderVec)`] = $ObjsCurve[$eachVi];
    }
    return $newOrderVec;

}


/******************************************************************************
 * @procedure    MultLenToDirAddToPoint
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Length : float
 *   $Dir : float[]
 *   $Pos : float[]
 *
 * @returns      float []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] MultLenToDirAddToPoint(float $Length, float $Dir[], float $Pos[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MultLengthDir[] = multiplyFloat($Length, $Dir);
    float $AddMultDirPos[] = AddFloats($Pos, $MultLengthDir);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MultLengthDir = multiplyFloat($Length, $Dir);
    $AddMultDirPos = AddFloats($Pos, $MultLengthDir);
    return $AddMultDirPos;

}


/******************************************************************************
 * @procedure    CreatePairIntIndex
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $AS : int
 *
 * @returns      int []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] CreatePairIntIndex(int $AS)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Ai = 0;
    int $Bi = 0;
    int $N = 0;
    int $store;
    int $IntA[];
    int $Times = $AS*2;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Ai = 0;
    $Bi = 0;
    $N = 0;
    $Times = $AS*2;
    while($Bi < $Times){
    if($Ai == 0){$IntA[$Bi] = $N;}
    if($Ai == 1){ $Ai = -1; $IntA[$Bi] = $N;
    $N++; }
    $Ai++;
    $Bi++;
    }
    return $IntA;

}


/******************************************************************************
 * @procedure    GetRotationVectorsMatrix
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $mAtRiX : matrix[]
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] GetRotationVectorsMatrix(matrix $mAtRiX[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MatrizFloatiA[];
    vector $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
    vector $VecR[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MatrizFloatiA = MatrixToFloat($mAtRiX);
    $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
    $VecR[0] = $VecAii;
    $VecAii = << $MatrizFloatiA[4], $MatrizFloatiA[5], $MatrizFloatiA[6]>>;
    $VecR[1] =$VecAii;
    $VecAii = << $MatrizFloatiA[8], $MatrizFloatiA[9], $MatrizFloatiA[10]>>;
    $VecR[2] = $VecAii;
    return $VecR;

}


/******************************************************************************
 * @procedure    MultPointMatrix
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $PtsVec : vector
 *   $mIA : matrix[]
 *
 * @returns      vector
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector MultPointMatrix(vector $PtsVec, matrix $mIA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MatrizFloatiA[] = MatrixToFloat($mIA);
    float $RowA[] = $VecR[0];
    float $RowB[] = $VecR[1];
    float $RowC[] = $VecR[2];
    float $GivenPoint[] = $PtsVec;
    float $NewPoint[];
    float $NewPointa[];
    float $NewPointb[];
    float $NewPtMatrixMult[];
    vector $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
    vector $VecR[];
    vector $ReturnValVec = FloatToVec($NewPoint);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $MatrizFloatiA = MatrixToFloat($mIA);
    $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
    $VecR[0] = $VecAii;
    $VecAii = << $MatrizFloatiA[4], $MatrizFloatiA[5], $MatrizFloatiA[6]>>;
    $VecR[1] =$VecAii;
    $VecAii = << $MatrizFloatiA[8], $MatrizFloatiA[9], $MatrizFloatiA[10]>>;
    $VecR[2] = $VecAii;
    $RowA = $VecR[0];
    $RowB = $VecR[1];
    $RowC = $VecR[2];
    $GivenPoint = $PtsVec;
    $NewPoint = multiplyFloat($GivenPoint[0], $RowA);
    $NewPointa = multiplyFloat($GivenPoint[1], $RowB);
    $NewPointb = multiplyFloat($GivenPoint[2], $RowC);
    $NewPtMatrixMult = AddFloats($NewPoint, $NewPointa);
    $NewPtMatrixMult = AddFloats($NewPtMatrixMult, $NewPointb);
    $NewPoint[0] = (($RowA[0])*($GivenPoint[0])) + (($RowB[0])*$GivenPoint[1]) + (($RowC[0])*$GivenPoint[2]);
    $NewPoint[1] = (($RowA[1])*($GivenPoint[0])) + (($RowB[1])*$GivenPoint[1]) + (($RowC[1])*$GivenPoint[2]);
    $NewPoint[2] = (($RowA[2])*($GivenPoint[0])) + (($RowB[2])*$GivenPoint[1]) + (($RowC[2])*$GivenPoint[2]);
    $ReturnValVec = FloatToVec($NewPoint);
    return $ReturnValVec;

}


/******************************************************************************
 * @procedure    FloatToMatrix
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $v : float[]
 *
 * @returns      matrix
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix FloatToMatrix(float $v[])
{

    matrix $mat[4][4]=<<$v[0], $v[1], $v[2], $v[3];
    $v[4], $v[5], $v[6], $v[7];
    $v[8], $v[9], $v[10], $v[11];
    $v[12], $v[13], $v[14], $v[15]>>;
    return $mat;

}


/******************************************************************************
 * @procedure    PointToPlaneN
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Veciiv : vector
 *   $Vec : vector[]
 *
 * @returns      vector
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector PointToPlaneN(vector $Veciiv, vector $Vec[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CombA = PointsEquivalentTol ($PointN, $pAv);
    float $pAv[] = AverageVectorPoint($Vec);
    float $n[] = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    float $DistanceLoc = distance2Pts(  $Veciiv, $pAv);
    float $MultDirCam[] = multiplyFloat($DistanceLoc, $n);
    float $FloatDirectionCamNormalA[] = AddFloats($pAv, $MultDirCam);
    float $PointN[] = ClosestPoint2LineVec($n, $pAv, $Veciiv);
    float $FloatDirectionAi[] = DirectionFN($pAv,$PointN);
    float $MultDirPC1[] = multiplyFloat($DistanceLoc, $FloatDirectionAi);
    float $AddMultMiiF[] = AddFloats($Veciiv, $MultDirPC1);
    vector $planePointN;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pAv = AverageVectorPoint($Vec);
    $n = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    $DistanceLoc = distance2Pts(  $Veciiv, $pAv);
    $MultDirCam = multiplyFloat($DistanceLoc, $n);
    $FloatDirectionCamNormalA = AddFloats($pAv, $MultDirCam);
    $PointN = ClosestPoint2LineVec($n, $pAv, $Veciiv);
    $CombA = PointsEquivalentTol ($PointN, $pAv);
    if($CombA != 3){
    $FloatDirectionAi = DirectionFN($pAv,$PointN);
    $DistanceLoc = distance2Pts( $PointN, $pAv );
    $MultDirPC1 = multiplyFloat($DistanceLoc, $FloatDirectionAi);
    $AddMultMiiF = AddFloats($Veciiv, $MultDirPC1);
    $planePointN = << $AddMultMiiF[0], $AddMultMiiF[1], $AddMultMiiF[2]>>;
    }else{ $planePointN = $Veciiv;
    }
    return $planePointN;

}


/******************************************************************************
 * @procedure    VecArrayToCurve
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $FixVec : vector[]
 *
 * @returns      string
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string VecArrayToCurve(vector $FixVec[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sIZes = `size $FixVec `;
    int $NUmers[] = CreateIntIndex($sIZes);
    float $valuesBi[] = $eachVeCx;
    string $K = "";
    string $curve = "curve -d 1";
    string $Newcurvez = `eval($curve)`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $sIZes = `size $FixVec `;
    $NUmers = CreateIntIndex($sIZes);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $curve = "curve -d 1";
    for ($eachVeCx in $FixVec){
    $valuesBi = $eachVeCx;
    $curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    }
    $curve += " "+ $K;
    $Newcurvez = `eval($curve)`;
    return $Newcurvez;

}


/******************************************************************************
 * @procedure    EulerAngB
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $pointB1 : float[]
 *   $pointB2 : float[]
 *
 * @returns      float []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] EulerAngB(float $pointB1[], float $pointB2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $EulerAngleA[] = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $EulerAngleA = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
    return $EulerAngleA;

}


/******************************************************************************
 * @procedure    VecPtsToZMirrorPts
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $AllLocPositionsZ : vector[]
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecPtsToZMirrorPts(vector $AllLocPositionsZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Zx[] = $eachVecEp;
    vector $AllPlaneLocs[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    clear  $AllPlaneLocs;
    for ($eachVecEp in $AllLocPositionsZ){
    $Zx = $eachVecEp;
    $Zx[0] *= -1.0;
    $AllPlaneLocs[`size($AllPlaneLocs)`] = `FloatToVec ($Zx)`;
    }
    return $AllPlaneLocs;

}


/******************************************************************************
 * @procedure    ISSelectedTypeCurve
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ISSelectedTypeCurve()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroOR1Z = `gmatch $nameB "*[C-c]urve*"`;
    string $C[];
    string $nametypeZi;
    string $nameA;
    string $nameB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $C = `ls -sl`;
    $nametypeZi= `getTypeItemString $C`;
    $nameA = `match "[a-zA-Z]+" $nametypeZi`;
    $nameB = `match ".urve" $nameA`;
    $zeroOR1Z = `gmatch $nameB "*[C-c]urve*"`;
    return $zeroOR1Z;

}


/******************************************************************************
 * @procedure    addCurveNumbers
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $addNumbersiA : int
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int addCurveNumbers(int $addNumbersiA)
{

    $addNumbersiA++;
    if($addNumbersiA>2){$addNumbersiA=0;}
    return $addNumbersiA;

}


/******************************************************************************
 * @procedure    DirectionF
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $EACHCVposAZ : float[]
 *   $EACHCVposBZ : float[]
 *
 * @returns      float[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] DirectionF(float $EACHCVposAZ[], float $EACHCVposBZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $vector_SubUnitMagVec1[];
    float $UnitDirection[] = $vectorUnit;
    vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]);


    $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
    $UnitDirection = $vectorUnit;
    return $UnitDirection;

}


/******************************************************************************
 * @procedure    lineIntersectionF
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $PosA : float[]
 *   $PosB : float[]
 *   $PosC : float[]
 *   $PosD : float[]
 *
 * @returns      float []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] lineIntersectionF(float $PosA[], float $PosB[], float $PosC[], float $PosD[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $DirAB[] = DirectionF ($PosA, $PosB);
    float $DirCD[] = DirectionF ($PosC, $PosD);
    float $locsA[] = lineIntersection($PosA, $DirAB, $PosC, $DirCD);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $DirAB = DirectionF ($PosA, $PosB);
    $DirCD = DirectionF ($PosC, $PosD);
    $locsA = lineIntersection($PosA, $DirAB, $PosC, $DirCD);
    return $locsA;

}


/******************************************************************************
 * @procedure    pointMatrixMult
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $point : float[]
 *   $matrix : float[]
 *
 * @returns      float[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] pointMatrixMult(float $point[], float $matrix[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $result[];
    string $multNode;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result[0] = 0.0;
    $result[1] = 0.0;
    $result[2] = 0.0;
    if ( size($point) != 3 || size($matrix) != 16 )
    {
    warning (uiRes("m_pointMatrixMult.kPointArray"));
    return $result;
    }
    if ( catch($multNode = `createNode pointMatrixMult`) )
    {
    warning (uiRes("m_pointMatrixMult.kCouldNotCreateNode"));
    return $result;
    }
    setAttr ($multNode+".vectorMultiply") true;
    setAttr ($multNode+".inPoint") -type "double3" $point[0] $point[1] $point[2];
    setAttr ($multNode+".inMatrix") -type "matrix" $matrix[0] $matrix[1] $matrix[2] $matrix[3] $matrix[4] $matrix[5] $matrix[6] $matrix[7] $matrix[8] $matrix[9] $matrix[10] $matrix[11] $matrix[12] $matrix[13] $matrix[14] $matrix[15];
    $result = `getAttr ($multNode+".output")`;
    delete $multNode;
    return $result;

}


/******************************************************************************
 * @procedure    MatrixCleanNegZero
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $m : matrix[]
 *
 * @returns      matrix
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix MatrixCleanNegZero(matrix $m[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iX = 0;
    float $MatrixA[] = `MatrixToFloat($m)`;
    float $CleanFLoats[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MatrixA = `MatrixToFloat($m)`;
    $iX = 0;
    for ($eachFloat in $MatrixA){
    if(($eachFloat == 0)||($eachFloat == -0)){
    $CleanFLoats[`size($CleanFLoats)`] = 0.0;
    }else{$CleanFLoats[`size($CleanFLoats)`] = $eachFloat;}
    $iX++;
    }
    $CleanFLoats = MakeCleanFloatsZ($CleanFLoats);
    matrix $MatrixClean[4][4]= FloatToMatrix($CleanFLoats);
    return $MatrixClean;

}


/******************************************************************************
 * @procedure    IteratCurve
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $step : float
 *   $paramlocatorpointOnCurvex : string
 *   $curveMin : float
 *   $FindSteps : int
 *
 * @returns      string
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string IteratCurve(float $step, string $paramlocatorpointOnCurvex, float $curveMin, int $FindSteps)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $MasterCount = 0;
    int $Par = 0;
    int $a;
    int $ii = 0;
    int $CountSteps;
    float $values[];
    float $CurvatureRadi;
    vector $tan;
    vector $norm;
    vector $bi;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MasterCount = 0;
    $curve = "curve -d 3";
    while ($FindSteps < 4){
    $curve = "curve -d 3";
    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    if ( $CurvatureRadi <=  $curveMin){
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    $CountSteps++;
    }
    }
    $FindSteps = $CountSteps;
    if($FindSteps < 10){$curveMin += 18.0; $curve = "curve -d 3";  }
    if($MasterCount== 4){break;}
    $MasterCount++;
    }
    return $curve;

}


/******************************************************************************
 * @procedure    VecArrayToCurveB
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $FixVec : vector[]
 *
 * @returns      string
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string VecArrayToCurveB(vector $FixVec[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sIZes = `size $FixVec `;
    int $NUmers[] = CreateIntIndex($sIZes);
    float $valuesBi[] = $eachVeCx;
    string $K = "";
    string $curve = "curve -d 3";
    string $Newcurvez = `eval($curve)`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $sIZes = `size $FixVec `;
    $NUmers = CreateIntIndex($sIZes);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $K += "\-k"+" "+ $sIZes+" ";
    $sIZes++;
    $K += "\-k"+" "+ $sIZes+" ";
    $curve = "curve -d 3";
    for ($eachVeCx in $FixVec){
    $valuesBi = $eachVeCx;
    $curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    }
    $Newcurvez = `eval($curve)`;
    return $Newcurvez;

}


/******************************************************************************
 * @procedure    TwoVecsOrFloats
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $p1p2 : float[]
 *   $p1p3 : float[]
 *
 * @returns      vector
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector TwoVecsOrFloats(float $p1p2[], float $p1p3[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $Ui = FloatToVec($p1p2);
    vector $Vi = FloatToVec($p1p3);
    vector $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Ui = FloatToVec($p1p2);
    $Vi = FloatToVec($p1p3);
    $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;
    return $VEcLine;

}


/******************************************************************************
 * @procedure    MostRightClockWiseInt
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Vecs : vector[]
 *   $Two : int[]
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int MostRightClockWiseInt(vector $Vecs[], int $Two[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $TwoNew[];
    float $point1[] = FloatToVec($Vecs[0]);
    float $point2[] = FloatToVec($Vecs[1]);
    float $point3[] = FloatToVec($Vecs[2]);
    float $normalA[] = `unit ($normalV[0])`;
    float $normalB[] = `unit ($normalV[1])`;
    float $normalAAdd = $normalA[0] + $normalA[1];
    float $normalAAdd2 = $normalB[0] + $normalB[1];
    string $ThreePoints[] = { "0", "1", "2"};
    vector $U1 = TwoVecsOrFloats($point2, $point1);
    vector $V1 = TwoVecsOrFloats($point3, $point1);
    vector $U2 = TwoVecsOrFloats($point3, $point1);
    vector $V2 = TwoVecsOrFloats($point2, $point1);
    vector $U3 = TwoVecsOrFloats($point1, $point3);
    vector $V3 = TwoVecsOrFloats($point2, $point3);
    vector $normalV[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $ThreePoints = { "0", "1", "2"};
    $point1 = FloatToVec($Vecs[0]);
    $point2 = FloatToVec($Vecs[1]);
    $point3 = FloatToVec($Vecs[2]);
    $U1 = TwoVecsOrFloats($point2, $point1);
    $V1 = TwoVecsOrFloats($point3, $point1);
    $U2 = TwoVecsOrFloats($point3, $point1);
    $V2 = TwoVecsOrFloats($point2, $point1);
    $U3 = TwoVecsOrFloats($point1, $point3);
    $V3 = TwoVecsOrFloats($point2, $point3);
    clear $normalV;
    $normalV[0] = FloatToVec( crossProduct( $U1, $V1, 0, 1 ) );
    $normalV[1] = FloatToVec( crossProduct( $U2, $V2, 0, 1 ) );
    $normalA = `unit ($normalV[0])`;
    $normalB = `unit ($normalV[1])`;
    $normalAAdd = $normalA[0] + $normalA[1];
    $normalAAdd2 = $normalB[0] + $normalB[1];
    if( $normalAAdd< $normalAAdd2){
    $TwoNew ={$Two[1], $Two[0]};
    }else{
    $TwoNew ={$Two[0], $Two[1]};
    }
    return $TwoNew[0];

}


/******************************************************************************
 * @procedure    CreateIntIndexF
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $ArraySize : int
 *   $Fstep : float
 *
 * @returns      float []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] CreateIntIndexF(int $ArraySize, float $Fstep)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iNdex = 0;
    float $FArrayInex[];
    float $AddF = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $iNdex = 0;
    $AddF = 0;
    while($iNdex < $ArraySize){
    $AddF+= $Fstep;
    $FArrayInex[$iNdex] = $AddF;
    $iNdex++;
    }
    return $FArrayInex;

}


/******************************************************************************
 * @procedure    AverageFloats
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $FloatArray : float[]
 *
 * @returns      float
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float AverageFloats(float $FloatArray[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Ix = 0;
    float $AddAll = 0;
    float $Divide = $AddAll/$Ix;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Ix = 0;
    $AddAll = 0;
    for($eachF in $FloatArray){
    $AddAll+= $eachF;
    $Ix++;
    }
    $Divide = $AddAll/$Ix;
    return $Divide;

}


/******************************************************************************
 * @procedure    GatherDataRR
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Xt : float[]
 *   $Av : float
 *
 * @returns      float []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] GatherDataRR(float $Xt[], float $Av)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $count = 0;
    float $Vt[];
    float $PastF;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $count = 0;
    for ($eachF in $Xt){
    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= -1;}
    if($count>0){
    if($PastF<$eachF){
    if($PastF<$Av){
    if(($PastF+$eachF/2.0)<$Av){
    $Vt[$count]= 1; }
    }
    }
    }
    $PastF = $eachF;
    $count++;
    }
    return $Vt;

}


/******************************************************************************
 * @procedure    VecArrayToSplitCurve
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $FixVec : vector[]
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] VecArrayToSplitCurve(vector $FixVec[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sIZes = `size $FixVec `;
    int $evenOdd = fmod($sIZes, 2);
    int $sIZesHalf = (($sIZes)/2)+1;
    int $NUmers[] = CreateIntIndex($sIZesHalf);
    int $countN = 0;
    float $valuesBi[];
    string $K = "";
    string $curveA = "curve -d 1";
    string $curveB = "curve -d 1";
    string $NewcurvezA = `eval($curveA)`;
    string $NewcurvezB = `eval($curveB)`;
    string $NewcurvezAB[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $sIZes = `size $FixVec `;
    $evenOdd = fmod($sIZes, 2);
    $sIZesHalf = (($sIZes)/2)+1;
    $NUmers = CreateIntIndex($sIZesHalf);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $countN = 0;
    $curveA = "curve -d 1";
    for ($eachVeCx in $NUmers){
    $valuesBi  = $FixVec[$countN];
    $curveA += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    $countN++;
    }
    $curveA += " "+ $K;
    $curveB = "curve -d 1";
    $countN--;
    for ($eachVeCx in $NUmers){
    $valuesBi  = $FixVec[$countN];
    $curveB += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    $countN++;
    }
    $curveB += " "+ $K;
    $NewcurvezA = `eval($curveA)`;
    $NewcurvezB = `eval($curveB)`;
    $NewcurvezAB = {$NewcurvezA , $NewcurvezB};
    return $NewcurvezAB;

}


/******************************************************************************
 * @procedure    LineIntersectPlaneCam
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Vecii : vector[]
 *   $CamP : float[]
 *   $Vec : vector[]
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] LineIntersectPlaneCam(vector $Vecii[], float $CamP[], vector $Vec[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CountVV = 0;
    float $pAv[] = AverageVectorPoint($Vec);
    float $n[] = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    float $FloatDirA[];
    vector $OnPlane[];
    vector $eachVecLine;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pAv = AverageVectorPoint($Vec);
    $n = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    $CountVV = 0;
    for($eachVecLine in $Vecii){
    $FloatDirA  = DirectionF($eachVecLine, $CamP);
    $FloatDirNormalA = multiplyFloat(2, $FloatDirA);
    $MultDirA = AddFloats( $FloatDirNormalA, $eachVecLine);
    $DistanceLocA = distance2Pts(  $eachVecLine, $pAv);
    $MultDirCam  = multiplyFloat($DistanceLocA, $n);
    $FloatDirectionCamNormalA  = AddFloats($pAv, $MultDirCam);
    $PointN  = ClosestPoint2Line($n, $pAv, $eachVecLine);
    $FloatDirectionAi  = DirectionF($PointN, $pAv);
    $DistanceLoc = distance2Pts( $PointN, $pAv );
    $MultDirPC1  = multiplyFloat($DistanceLoc, $FloatDirectionAi);
    $FloatDirNormalDist  = AddFloats($eachVecLine, $MultDirPC1);
    $PointNii  = ClosestPoint2Line(DirectionF($PointN, $pAv), $eachVecLine, $MultDirA);
    $FloatDirectionAii  = DirectionF($PointNii, $MultDirA);
    $OnPlane[$CountVV] = FloatToVec (lineIntersection( $FloatDirNormalDist, $FloatDirectionAii, $eachVecLine, $FloatDirA));
    $CountVV++;
    }
    return $OnPlane;

}


/******************************************************************************
 * @procedure    FindIfCurveIsOrthoEpipol
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $EpipolD : vector[]
 *   $CRV_ENDS : vector[]
 *   $DistEnds : float
 *   $LineMid : vector
 *
 * @returns      vector
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector FindIfCurveIsOrthoEpipol(vector $EpipolD[], vector $CRV_ENDS[], float $DistEnds, vector $LineMid)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $index[] = CreateIntIndex(3);
    int $xyz = $EmptyIndx[0];
    int $isOrthoTrueZi = 0;
    float $Anglei;
    string $stringF[];
    string $EmptyIndx[];
    string $stringIndTr[] = IntArrayToStringArray($index);
    vector $Xdirect;
    vector $Ydirect;
    vector $Zdirect;
    vector $XYZdirect[];
    vector $NewDirectionZ;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;
    if(`size($EpipolD)` == 3){
    $Xdirect = $EpipolD[0];
    $Ydirect = $EpipolD[1];
    $Zdirect = $EpipolD[2];
    }else{
    $Xdirect = << 1,0,0>>;
    $Ydirect = << 0,1,0>>;
    $Zdirect = << 0,0,1>>;
    }
    $XYZdirect[0] = $Xdirect;
    $XYZdirect[1] = $Ydirect;
    $XYZdirect[2] = $Zdirect;
    $LineAMain = PositiveDirectionLine($CRV_ENDS[0], $CRV_ENDS[1]);
    $EulerAngleA  = EulerAngB($Xdirect,$LineAMain);
    $EulerAngleB  = EulerAngB($Ydirect,$LineAMain);
    $EulerAngleC  = EulerAngB($Zdirect,$LineAMain);
    $EulerABCi[0]= $EulerAngleA[3];
    $EulerABCi[1]= $EulerAngleB[3];
    $EulerABCi[2]= $EulerAngleC[3];
    $stringF = FloatArrayToStringArray($EulerABCi);
    clear $EmptyIndx;
    $index = CreateIntIndex(3);
    $stringIndTr = IntArrayToStringArray($index);
    SortFloatArrayAndString( $EulerABCi, $stringIndTr, $EmptyIndx);
    $EmptyIndx = ReverseStringArray($EmptyIndx);
    $xyz = $EmptyIndx[0];
    $AxisOrthoLine = $xyz;
    $Anglei = $EulerABCi[$xyz];
    $NewDirectionZ = $XYZdirect[$xyz];
    $DistEnds= distance2Pts($CRV_ENDS[0], $CRV_ENDS[1]);
    $LineMid = ($CRV_ENDS[0] + $CRV_ENDS[1])/2.0;
    $AngleEpiPole = $Anglei;
    $isOrthoTrueZi = 0;
    if($Anglei < 8.55){
    $isOrthoTrueZi = 1;  print ("IsOrthoLineTrue :Anglei "+$Anglei+"\n");
    }
    print ("IsOrthoLineTrue :Anglei "+$Anglei+"\n");
    $IsOrthoLineTrue = $isOrthoTrueZi;
    return $NewDirectionZ;

}


/******************************************************************************
 * @procedure    isCurveEndAtZY
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $EndVectors : vector[]
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int isCurveEndAtZY(vector $EndVectors[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Number = 0;
    float $ThreeFs[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Number = 0;
    for($eachVec in $EndVectors){
    $ThreeFs = $eachVec;
    if($ThreeFs[0] == 0){
    $Number++;
    }}
    return $Number;

}


/******************************************************************************
 * @procedure    ForceOrtho
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $CurveItemAX : string[]
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] ForceOrtho(string $CurveItemAX[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $edgeZsetA;
    int $edgeZsetB;
    int $ReducedIndexA[] = floatArrayCountDuplicates($distancesEachToCurve);
    int $ReducedIndexB[] = floatArrayCountDuplicates($distancesEachToCurveB);
    int $NearestInt[] = SortNumbersIntIndex($distAz);
    int $NearestIntB[] = SortNumbersIntIndex($distBz);
    int $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    int $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];
    int $NearestIndex;
    int $NearestIndexEach;
    int $ReducedIndexXAB[];
    int $AxisOrthoLineA = $AxisOrthoLine;
    int $iVc = 0;
    int $TrackFoundN[];
    int $TrackN[];
    int $TwoPointsi[];
    int $AXIS = $AxisOrthoLineA;
    int $ALLlikeness[];
    int $ALLlikenessForce[];
    int $i = 0;
    int $TriggerPoints;
    int $SortedForce[];
    int $Sorted[] = SortNumbersIntIndex($distTo3DCurveEnd);
    int $ReducedIndex[] = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    int $OntheSameLine = 0;
    int $CountN = 0;
    int $AddInt = $AdditR;
    float $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    float $distancesEachToCurve[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    float $distancesEachToCurveB[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    float $distAz[];
    float $distBz[];
    float $CamPos_A[];
    float $EpipolXx[] = {0.0,$CamPos_A[1],$CamPos_A[2]};
    float $PlaneEpipolXx[] = FloatPointsToCamPlane( $EpipolXx);
    float $EpipolYx[] = {$CamPos_A[0],0.0,$CamPos_A[2]};
    float $PlaneEpipolYx[] = FloatPointsToCamPlane( $EpipolYx);
    float $EpipolZx[] = {$CamPos_A[0],$CamPos_A[1],0.0};
    float $PlaneEpipolZx[] = FloatPointsToCamPlane( $EpipolZx);
    float $MidCurveA[] = MidPoint($CRV_ENDSi[0], $CRV_ENDSi[1]);
    float $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    float $FPointN_LineC[];
    float $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);
    float $XY[];
    float $XYZi[];
    float $XYZadd[];
    float $Xd;
    float $Yd;
    float $Zd;
    float $All_X[];
    float $All_Y[];
    float $All_Z[];
    float $All_ZYX[];
    float $All_ZYXDiff[];
    float $diffXYZ;
    float $Dist_3DNear = (($Dist_3D/3.0)*2.0);
    float $newOrderFloat;
    float $distTo3DCurveEnd[] = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    float $SdistTo3DCurveEnd[];
    float $Additi[];
    float $AdditiB[];
    float $AdditRi;
    float $AdditRiX;
    float $DistSnap;
    float $EulerAngleA[];
    float $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    float $Addit[];
    float $AdditR;
    string $queryLocCurveEnds[] = queryLocOnLivePlaneBLayer();
    string $queryLocCurveEndsOLD[] = $queryLocCurveEnds;
    string $newNames;
    string $NearCurvesEnds[];
    string $BothCurves[];
    string $EmptyStringNewOrderA[];
    string $LocA = $queryLocCurveEnds[$NearestInt[0]];
    string $LocB = $queryLocCurveEnds[$NearestIntB[0]];
    string $LocName;
    string $Loc_AorB = "";
    string $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    string $AllarrayCurvesNear[];
    string $NewFoundLocs[];
    string $arrayCurvesNear[];
    string $CurvesV[];
    string $LocsV[];
    string $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    string $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    vector $Positions[];
    vector $VecCurEnds[] = VecCurveEnds({$TempCrv});
    vector $LocCurveEndsVec[] = PointArray($queryLocCurveEnds);
    vector $EndSnapAndEndProject[];
    vector $endNotNearZ[];
    vector $NearEndZ;
    vector $LocOnPlaneVec[] = PointArray($arrayCurvesNear );
    vector $Loc3D_Vec[] = PointArray($NewFoundLocs );
    vector $ALLLoc3D_VecAB[] = PointArray($AllarrayCurvesNear);
    vector $ReducedVecAB[];
    vector $ALLLoc3D_Vec[];
    vector $MovedEndPointPlane[] = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    vector $CRV_ENDSi[];
    vector $DDirEpipolXYZ[];
    vector $EpipolD[];
    vector $AllEpipolXYZ[];
    vector $XYZdirectL[];
    vector $LineMidi;
    vector $NewDirZi;
    vector $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    vector $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    vector $Dir_CamRay;
    vector $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    vector $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);
    vector $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    vector $One;
    vector $each;
    vector $NearPointsXYZ[];
    vector $ReducedVec[];
    vector $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    vector $VecLineDirMi;
    vector $PointN_LineXYZ;
    vector $SnapN;
    vector $SnapPlaceN;
    vector $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);
    vector $VecLineDirM;
    vector $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    vector $Points3DPair_And_2DPair[];
    vector $Crv_Pts[];
    vector $MirrorAcrossPlaneVecs[] = VecMultMatrixMirror($Crv_Pts);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global string $StereoCurveZ[];
    global int $addNumbersA;
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemAX[0];
    $Positions = VecCurveEps($CurveItemAX[0]);
    $TempCrv = VecArrayToCurve($Positions);
    delete $CurveItemAX[0];
    $VecCurEnds = VecCurveEnds({$TempCrv});
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEndsOLD = $queryLocCurveEnds;
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    if(`size($queryLocCurveEnds)` >= 2){
    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $distancesEachToCurveB = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    $ReducedIndexA = floatArrayCountDuplicates($distancesEachToCurve);
    $ReducedIndexB = floatArrayCountDuplicates($distancesEachToCurveB);
    for($eachInt in $ReducedIndexA){
    $distAz[`size($distAz)`]= $distancesEachToCurve[$eachInt];
    }
    for($eachInt in $ReducedIndexB){
    $distBz[`size($distBz)`]= $distancesEachToCurveB[$eachInt];
    }
    $NearestInt = SortNumbersIntIndex($distAz);
    $NearestIntB = SortNumbersIntIndex($distBz);
    $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$ReducedIndexA[$NearestInt[0]]];
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$ReducedIndexB[$NearestIntB[0]]];
    $NearestInt[0] =  $NewIntIndexAA;
    $NearestIntB[0] = $NewIntIndexBB;
    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];
    $LocA = $queryLocCurveEnds[$NearestInt[0]];
    $LocB = $queryLocCurveEnds[$NearestIntB[0]];
    clear $EndSnapAndEndProject;
    $Loc_AorB = "";
    if($NdistA<$NdistB){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    $Loc_AorB="B";
    }else{
    $Loc_AorB="A";
    $LocName =$LocB;
    $NearestIndex=$NearestIntB[0];
    $NearEndZ = $VecCurEnds[1];
    $endNotNearZ[0] = $VecCurEnds[0];}
    if($NdistA==$NdistB){
    $Loc_AorB="A";
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    }
    if($NearestInt[0]==$NearestIntB[0]){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    }
    $newNames = stringArrayToString($queryLocCurveEnds, " ");
    $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    $AllarrayCurvesNear = stringToStringArray($newNamesResultAX, " ");
    $NewFoundLocs[0]  = $AllarrayCurvesNear[$NearestIndex];
    $arrayCurvesNear[0] = $queryLocCurveEnds[$NearestIndex];

    $LocOnPlaneVec = PointArray($arrayCurvesNear );
    $Loc3D_Vec = PointArray($NewFoundLocs );
    $ALLLoc3D_VecAB = PointArray($AllarrayCurvesNear);
    if($Loc_AorB == "A"){
    $ReducedIndexXAB = $ReducedIndexA;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexA,$ALLLoc3D_VecAB);
    }
    if($Loc_AorB == "B"){
    $ReducedIndexXAB = $ReducedIndexB;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexB,$ALLLoc3D_VecAB);
    }
    $ALLLoc3D_Vec = $ReducedVecAB;
    $MovedEndPointPlane = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    $CRV_ENDSi[0]= $LocOnPlaneVec[0];
    $CRV_ENDSi[1]= $MovedEndPointPlane[0];
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);
    $MidCurveA = MidPoint($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
    $EpipolD = $DDirEpipolXYZ;
    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);
    $XYZdirectL[0] = << 1,0,0>>;
    $XYZdirectL[1] = << 0,1,0>>;
    $XYZdirectL[2] = << 0,0,1>>;
    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    $AxisOrthoLineA = $AxisOrthoLine;
    $Dir_CamRay =  DirectionFN($MovedEndPointPlane[0],$CamPos_A);
    $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);
    $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);
    $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    $XYZi  = $PointN_LineC;
    $XYZadd  = $PointN_LineC;
    $XYZi[0] = $XYZadd[0]+$XYZadd[1];
    $XYZi[1] = $XYZadd[1]+$XYZadd[2];
    $XYZi[2] = $XYZadd[0]+$XYZadd[2];
    $iVc = 0;
    clear $TrackFoundN;
    if($AxisOrthoLineA ==2){
    $TwoPointsi[0] = 0;
    }
    if($AxisOrthoLineA ==1){
    $TwoPointsi[0] = 2;
    }
    if($AxisOrthoLineA ==0){
    $TwoPointsi[0] = 1;
    }
    $AXIS = $AxisOrthoLineA;
    clear $ALLlikeness;
    $i = 0;
    $Dist_3DNear = (($Dist_3D/3.0)*2.0);
    for ($each in $ALLLoc3D_Vec){
    $One = $ALLLoc3D_Vec[$i];
    $XY[0] = $Xx  = $One.x;
    $XY[1] = $Yy  = $One.y;
    $XY[2] = $Zz  = $One.z;
    if( $ReducedIndexXAB[$iVc]!= $NearestIndex ){
    $TriggerPoints=0;
    if( (equivalentTol($XYZadd[0], $Xx,  0.01) )==1){
    $All_X[$i] = $Xx;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[1], $Yy,  0.01) )==1){
    $All_Y[$i] = $Yy;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[2], $Zz,  0.01) )==1){
    $All_Z[$i] = $Zz;
    $TriggerPoints++;
    }
    if( $TriggerPoints<2){
    $diffXYZ = `abs ($XY[$AXIS] - $XYZadd[$AXIS])`;
    if(($diffXYZ< $Dist_3DNear)&&($diffXYZ!=0)){
    $All_ZYX[`size($All_ZYX)`] =$XY[$AXIS];
    $All_ZYXDiff[`size($All_ZYXDiff)`] = $diffXYZ;
    }
    }
    if( $TriggerPoints==2){
    $ALLlikeness[`size($ALLlikeness)`] = $ReducedIndexXAB[$i];
    }
    }
    $i++;
    $iVc++;
    }
    if(`size($All_ZYXDiff)`> 0){
    $SortedForce = SortNumbersIntIndex($All_ZYXDiff);
    $newOrderFloat = $All_ZYX[$SortedForce[0]];
    }
    if(`size($ALLlikeness)`> 0){
    select -cl;
    for($eachIn in $ALLlikeness){
    select -add $AllarrayCurvesNear[$eachIn];
    PAUSE;
    }
    clear $NearPointsXYZ;
    $iVc =0;
    for($eachIn in $ALLlikeness){
    if( $iVc!= $NearestIndex ){
    $NearPointsXYZ[`size($NearPointsXYZ )`] =  $ALLLoc3D_VecAB[$eachIn];
    }
    $iVc++;
    }
    $distTo3DCurveEnd = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    $Sorted = SortNumbersIntIndex($distTo3DCurveEnd);
    $NearPointsXYZ = NewVecOrderWithINTKey($Sorted,$NearPointsXYZ);
    clear $SdistTo3DCurveEnd;
    for($eachIn in $Sorted){
    $SdistTo3DCurveEnd[`size($SdistTo3DCurveEnd)`] = $distTo3DCurveEnd[$eachIn];
    }
    $ReducedIndex = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    $ReducedVec = NewVecOrderWithINTKey($ReducedIndex,$NearPointsXYZ);
    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    $OntheSameLine = 0;
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $OntheSameLine =1;
    }
    $CountN = 0;
    for($eachVec in $ReducedVec){
    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $eachVec);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $PointN_LineXYZ = $eachVec;
    print " on same Line ";
    }else{
    $PointN_LineXYZ  = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $eachVec);
    }
    if( (distance2Pts($PointN_LineXYZ, $PointN_LineC))>0.001){
    $LocsV[`size($LocsV)`] = `Loc $PointN_LineXYZ`;
    $CurvesV[`size($CurvesV)`] = curve2points($eachVec, $PointN_LineXYZ);
    PAUSE;
    }
    if($CountN==0){
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapN = $eachVec;
    $SnapPlaceN = $PointN_LineXYZ;
    }
    if($CountN!=0){
    print  $DistSnap;
    if((distance2Pts($PointN_LineXYZ, $PointN_LineC))<  $DistSnap){
    $SnapN = $eachVec;
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapPlaceN = $PointN_LineXYZ;
    }
    }
    $CountN++;
    }
    $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);
    delete $CurvesV;
    delete $LocsV;
    if(($EulerAngleA[3] >85)&&($EulerAngleA[3]<95)){
    $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    if($Dist_3DSnap<($Dist_3D/2.0)){
    cycleBackgroundColor;
    PAUSE;
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    $AddInt = $AdditR;
    if($AddInt == 0){
    $PointN_LineC = $SnapPlaceN;
    PAUSE; PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }else{
    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $FPointN_LineC =  $PointN_LineC;
    $FPointN_LineC[$AXIS] = $newOrderFloat;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }
    }else{
    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }
    $Points3DPair_And_2DPair[0]= $Loc3D_Vec[0];
    $Points3DPair_And_2DPair[1]= $PointN_LineC;
    $Points3DPair_And_2DPair[2]= $LocOnPlaneVec[0];
    $Points3DPair_And_2DPair[3]= $NewPlanePoint;
    delete $TempCrv;
    $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 10 -d 3 -tol 0.05 $CurvesVi;
    $Crv_Pts = VecCurveEps($CurvesVi );
    $MirrorAcrossPlaneVecs = VecMultMatrixMirror($Crv_Pts);
    $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    clear $StereoCurveZ;
    $BothCurves[0] = $CurvesVi;
    $BothCurves[1] = $TheSecondCurve;
    $StereoCurveZ = $BothCurves;
    $addNumbersA =-3;
    ResetTranslation($BothCurves);
    CurveIndexVecTracking($BothCurves);
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $BothCurves;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    clear $StereoCurveZ;
    }
    return $BothCurves;

}


/******************************************************************************
 * @procedure    floatArrayCountDuplicates
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $listX : float[]
 *
 * @returns      int []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] floatArrayCountDuplicates(float $listX[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $index = 0;
    int $X = 0;
    int $Xi = 0;
    int $C = 0;
    int $NumberE[];
    int $NoneDup[];
    float $list[] = $listX;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $list = $listX;
    $index = 0;
    $X = 0;
    $Xi = 0;
    $C = 0;
    $result = $list;
    for ($item in $list) {
    $NumberE[$X] = floatArrayCount($item, $result);
    if (1 == $NumberE[$X]) {
    $NoneDup[`size($NoneDup)`] = $Xi;
    }else{
    if (1 < $NumberE[$X]) {
    floatArrayRemoveAtIndex($X, $result);
    $X--;
    }
    }
    $Xi++;
    $X++;	}
    return $NoneDup;

}


/******************************************************************************
 * @procedure    floatArrayCount
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $item : float
 *   $list : float[]
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int floatArrayCount(float $item, float $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = 0;
    float $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = 0;
    for ($listItem in $list) {
    if ($item == $listItem) $result++;	}
    return $result;

}


/******************************************************************************
 * @procedure    floatArrayRemoveAtIndex
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $index : int
 *   $list : float[]
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int floatArrayRemoveAtIndex(int $index, float $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $len = size( $list );
    float $result[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $len = size( $list );
    if( $index > $len  || $index < 0 ){
    return( false );
    }
    for( $i = 0; $i < $index; $i++ ){
    $result[$i] = $list[$i];
    }
    for( ; $i < $len - 1; $i++ ){
    $result[$i] = $list[$i + 1];
    }
    $list = $result;
    return( true );

}


/******************************************************************************
 * @procedure    VecMultMatrixMirror
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $pointZ : vector[]
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecMultMatrixMirror(vector $pointZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MatrixB[] = `MatrixToFloat($m2)`;
    vector $FLoatPointA[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    matrix $m2[4][4]= <<	-1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0>>;
    $MatrixB = `MatrixToFloat($m2)`;
    for($eachVec in $pointZ){
    $FLoatPointA[`size($FLoatPointA)`] = FloatToVec(pointMatrixMult( $eachVec, $MatrixB ));
    }
    return $FLoatPointA;

}


/******************************************************************************
 * @procedure    MoveVectors
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Pos_A : vector
 *   $VecLoc : vector
 *   $Crv_Pts : vector[]
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] MoveVectors(vector $Pos_A, vector $VecLoc, vector $Crv_Pts[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $DistToPoint = distance2Pts($Pos_A, $VecLoc);
    vector $DirLine = DirectionFN( $VecLoc, $Pos_A);
    vector $TranstatedVecs[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $DirLine = DirectionFN( $VecLoc, $Pos_A);
    $DistToPoint = distance2Pts($Pos_A, $VecLoc);
    clear $TranstatedVecs;
    for($eachVector in $Crv_Pts){
    $TranstatedVecs[`size($TranstatedVecs)`] = ($eachVector+($DistToPoint*$DirLine));
    }
    return $TranstatedVecs;

}


/******************************************************************************
 * @procedure    VanishingCurves
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $CurveItemA : string[]
 *
 * @returns      string []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] VanishingCurves(string $CurveItemA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $indexAx[] = CreateIntIndex(6);
    int $indexAxNew[] = ArrayToIntList( $BestThree);
    int $Count = 0;
    int $color;
    int $colori[];
    int $iiX = 0;
    int $Cindex = 0;
    int $IndexZ = $indexAxNew[$Count];
    int $triggerMiddle = 0;
    int $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
    int $edgeZsetA;
    int $edgeZsetB;
    int $NearestInt[] = SortNumbersIntIndex($distancesEachToCurve);
    int $NearestIntB[] = SortNumbersIntIndex($distancesEachToCurveB);
    int $i;
    int $iv = -1;
    int $CRV_index_number = 0;
    int $CRc = 0;
    int $CRcT = 0;
    int $countS = 0;
    int $COuntN = 0;
    int $EDGEpoints[];
    int $pointNearEdgeCurve[];
    int $SnappingVector = 0;
    int $OneIsNotNearThePlane = 0;
    int $Sorted[] = SortNumbersIntIndex($distancesTo3DCurveEnd);
    int $Sortedi[] = SortNumbersIntIndex($distancesTo3DCurveEndi);
    int $iiz = 0;
    float $SnapD = 0.003;
    float $CamPos1[];
    float $Pi = 3.1415926535;
    float $pi = 3.1415926535;
    float $CamerasDirectionVectorNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
    float $MultDirForWard[] = multiplyFloat(-1, $CamerasDirectionVector);
    float $MultDirCam[] = multiplyFloat(-3, $CamerasDirectionVector);
    float $FloatDirectionCamNormalA[] = AddFloats($CamPos1, $MultDirCam);
    float $DirectionVectorXn[] = {-2,0,0};
    float $DirectionVectorX[] = {2,0,0};
    float $DirectionVectorY[] = {0,-2,0};
    float $DirectionVectorYn[] = {0,2,0};
    float $DirectionVectorZn[] = {0,0,-2};
    float $DirectionVectorZ[] = {0,0,2};
    float $FloatPointDirectionXn[] = AddFloats($CamPos1, $DirectionVectorXn);
    float $FloatPointDirectionX[] = AddFloats($CamPos1, $DirectionVectorX);
    float $FloatPointDirectionY[] = AddFloats($CamPos1, $DirectionVectorY);
    float $FloatPointDirectionYn[] = AddFloats($CamPos1, $DirectionVectorYn);
    float $FloatPointDirectionZn[] = AddFloats($CamPos1, $DirectionVectorZn);
    float $FloatPointDirectionZ[] = AddFloats($CamPos1, $DirectionVectorZ);
    float $AverageVecXYZsOnP[] = AverageVectorPoint($VecXYZsOnPlane);
    float $AnglesAll[];
    float $EulerAngleA[] = EulerAngB($eachOrthD, $CamerasDirectionVector);
    float $ANgnew[] = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
    float $LengCRV_a = `arclen $CurveItemA`;
    float $DistEndsi;
    float $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
    float $AverageVecCurEndsP[] = AverageVectorPoint($VecCurEnds);
    float $FloatPointDirectionZniY[];
    float $CurveDirectionZiY[];
    float $FloatPointDirectionZniiY[];
    float $CurveDirectionZiiY[];
    float $CurvePsD[] = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
    float $FloatPointDirectVpoint[];
    float $CurveDirectionVpoint[];
    float $locsAi[];
    float $CamPos_A[];
    float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;
    float $CamNormM[] = ` MirrorFloatXYZ 0 $MultDirCam`;
    float $MidEpipolZx[] = MidPoint($CamPos_M, $CamPos_A);
    float $MidEpipolPosFCam[] = FloatPointsToCamPlane($MidEpipolZx);
    float $Addit[];
    float $AdditR;
    float $INTERSECTIONLA[] = lineIntersectionF($VecCurEnds[0], $EpipLolar[0], $VecCurEnds[1],  $EpipLolar[1]);
    float $INTERSECTIONLB[] = lineIntersectionF($VecCurEnds[1], $EpipLolar[0], $VecCurEnds[0],  $EpipLolar[1]);
    float $IntersectEnds_Ai[];
    float $IntersectEnds_Bi[];
    float $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    float $distancesEachToCurve[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    float $distancesEachToCurveB[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    float $distsA = $NdistA;
    float $distsB = $NdistB;
    float $PtsM_Ai[];
    float $PtsM_Bi[];
    float $INTERSECTIONLC[] = lineIntersectionF($EpipLolar[0], $PtsM_Ai, $INTERSECTIONLA, $EpipLolar[2]);
    float $INTERSECTIONL2C[] = lineIntersectionF($EpipLolar[0], $VecCurEnds[0], $INTERSECTIONLC, $EpipLolar[2]);
    float $INTERSECTIONL2D[] = lineIntersectionF($EpipLolar[1],$INTERSECTIONLC, $VecCurEnds[1],  $EpipLolar[2]);
    float $INTERSECTIONL3D[] = lineIntersectionF($EpipLolar[0],$INTERSECTIONL2D,$PtsM_Ai,  $EpipLolar[1]);
    float $ThreepointVecs[];
    float $EdgeDist;
    float $smallestDistance;
    float $distancesTo3DCurveEnd[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
    float $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
    float $distancesTo3DCurveEndi[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
    float $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
    float $XX = $VecA.x;
    float $XXX = $VecB.x;
    string $VanishingLOC[];
    string $DirectionsZ[] = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    string $Alll = "";
    string $AllStrings[];
    string $stringFloat[] = FloatArrayToStringArray($EulerAngleA);
    string $EmptyIndxNewOrder[];
    string $stringIndTr[] = IntArrayToStringArray($indexAx);
    string $BestThree[];
    string $CurvesV[];
    string $CirTemp[];
    string $CirTempi[];
    string $newCurveii;
    string $CurveAv[];
    string $newNamesResultA1;
    string $ThreeDCurvesNear[];
    string $queryLocCurveEnds3D[];
    string $CurveItemAa[];
    string $queryLocCurveEnds[] = queryLocOnLivePlaneBLayer();
    string $queryLocCurveEndsOLD[] = queryLocOnLivePlaneBLayer();
    string $newNames;
    string $NearCurvesEnds[];
    string $EmptyStringNewOrderA[];
    string $StringAllNearA[];
    string $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    string $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    string $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    string $arrayCurvesNearA[];
    string $newNamesResultAx = substituteAllString($newNames, "Plane", "");
    string $arrayCurvesNear[];
    string $arrayCurvesNearA1[];
    string $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    string $LocNames[];
    string $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
    vector $Positions[];
    vector $PositionsZ_Ax[];
    vector $ZYplaneMatrix[];
    vector $VecDirection_A_XYZ[];
    vector $VecDirectionXYZ[];
    vector $VecXYZsOnPlane[] = VecPointsToCameraPlane($VecXYZs);
    vector $VecCurEnds[] = VecCurveEnds($CurveItemA);
    vector $VecXYZsOnPlaneiY[];
    vector $VecXYZsOnPlaneiiY[];
    vector $VecXYZsOnPlaneVpoint[];
    vector $EpipLolar[];
    vector $PositionsZ_A[];
    vector $PositionsZ_Aii[];
    vector $HighCurvePoints[];
    vector $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
    vector $Dir_VecA;
    vector $VecPtsMirrorEnds_A[];
    vector $VIntersectEnds_A[];
    vector $ObjLoc3DCurv[];
    vector $LocCurveEndsVec[] = PointArray($queryLocCurveEnds);
    vector $LocCurveEndsVec_3D[] = PointArray($arrayCurvesNearA1);
    vector $LoCz_3D[];
    vector $TXI = << -1.0 , 1.0, 1.0>>;
    vector $NearVecPts[];
    vector $PositionsZ_Aiix[];
    vector $VecTest[];
    vector $LocCurveEndsVec3D[] = PointArray($queryLocCurveEnds3D);
    vector $FistAndSecond[];
    vector $VecA = $FistAndSecond[0];
    vector $VecB = $FistAndSecond[1];
    vector $PositionsZ_Ai[];
    vector $ReversePositionsZ_Ai[] = ReverseVectorArray($PositionsZ_Ai);
    vector $PtsMirrorAi[];
    vector $XIntersect_Ax[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global string $VanishingPointsLinesTempGuides[];
    global int $ifSingleCurve;
    $SnapD = 0.003;
    global vector $TempVectorsCrv[];
    if(size($TempVectorsCrv)>0){
    clear $TempVectorsCrv;}
    $Positions = VecCurveEps($CurveItemA[0]);
    $TempCrv = VecArrayToCurve($Positions);
    delete $CurveItemA[0];
    $CurveItemA[0] = VecArrayToCurve($Positions);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 3 -tol 0.05 $CurveItemA[0];
    SetItemColorString ($CurveItemA[0], 9);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $TempCrv;
    $PositionsZ_Ax = VecCurveEps($TempCrv);
    $ZYplaneMatrix[0] = <<0, 0, 0>>;
    $ZYplaneMatrix[1] = <<0, 1, 0>>;
    $ZYplaneMatrix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $TempVectorsCrv  = LineIntersectPlaneCam( $PositionsZ_Ax, $CamPos1, $ZYplaneMatrix);
    delete $TempCrv;
    $Pi = 3.1415926535;
    $pi = 3.1415926535;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $CamerasDirectionVector = $CamerasDirectionVectorNormal;
    $MultDirForWard = multiplyFloat(-1, $CamerasDirectionVector);
    $MultDirCam = multiplyFloat(-3, $CamerasDirectionVector);
    $FloatDirectionCamNormalA = AddFloats($CamPos1, $MultDirCam);
    $DirectionVectorXn = {-2,0,0};
    $DirectionVectorX = {2,0,0};
    $DirectionVectorY = {0,-2,0};
    $DirectionVectorYn = {0,2,0};
    $DirectionVectorZn = {0,0,-2};
    $DirectionVectorZ = {0,0,2};
    $VecDirection_A_XYZ[0] = <<-2,0,0>>;
    $VecDirection_A_XYZ[1] = <<2,0,0>>;
    $VecDirection_A_XYZ[2] = <<0,2,0>>;
    $VecDirection_A_XYZ[3] = <<0,-2,0>>;
    $VecDirection_A_XYZ[4] = <<0,0,-2>>;
    $VecDirection_A_XYZ[5] = <<0,0,2>>;
    $VecDirectionXYZ[0] = <<-1,0,0>>;
    $VecDirectionXYZ[1] = <<1,0,0>>;
    $VecDirectionXYZ[2] = <<0,1,0>>;
    $VecDirectionXYZ[3] = <<0,-1,0>>;
    $VecDirectionXYZ[4] = <<0,0,-1>>;
    $VecDirectionXYZ[5] = <<0,0,1>>;
    $FloatPointDirectionXn = AddFloats($CamPos1, $DirectionVectorXn);
    $FloatPointDirectionX = AddFloats($CamPos1, $DirectionVectorX);
    $FloatPointDirectionY = AddFloats($CamPos1, $DirectionVectorY);
    $FloatPointDirectionYn = AddFloats($CamPos1, $DirectionVectorYn);
    $FloatPointDirectionZn = AddFloats($CamPos1, $DirectionVectorZn);
    $FloatPointDirectionZ = AddFloats($CamPos1, $DirectionVectorZ);
    clear $VecXYZs;
    $VecXYZs[0] = FloatToVec($FloatPointDirectionXn);
    $VecXYZs[1] = FloatToVec($FloatPointDirectionX);
    $VecXYZs[2] = FloatToVec($FloatPointDirectionY);
    $VecXYZs[3] = FloatToVec($FloatPointDirectionYn);
    $VecXYZs[4] = FloatToVec($FloatPointDirectionZn);
    $VecXYZs[5] = FloatToVec($FloatPointDirectionZ);
    $VecXYZsOnPlane = VecPointsToCameraPlane($VecXYZs);
    $AverageVecXYZsOnP = AverageVectorPoint($VecXYZsOnPlane);
    $DirectionsZ = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    $FloatDirxyz[0] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[0]));
    $FloatDirxyz[1] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[1]));
    $FloatDirxyz[2] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[3]));
    $FloatDirxyz[3] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[2]));
    $FloatDirxyz[4] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[4]));
    $FloatDirxyz[5] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[5]));
    $Alll = "";
    clear $AllStrings $AnglesAll ;
    for ($eachOrthD in $VecDirectionXYZ){
    $EulerAngleA = EulerAngB($eachOrthD, $CamerasDirectionVector);
    $AnglesAll[`size($AnglesAll)`]= $EulerAngleA[3];
    $stringFloat = FloatArrayToStringArray($EulerAngleA);
    $Alll  = stringArrayToString($stringFloat, " ");
    $AllStrings[`size($AllStrings)`]= $Alll;
    }
    clear $EmptyIndxNewOrder;
    $indexAx = CreateIntIndex(6);
    $stringIndTr = IntArrayToStringArray($indexAx);
    $ANgnew = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
    $EmptyIndxNewOrder = ReverseStringArray($EmptyIndxNewOrder);
    $BestThree = {$EmptyIndxNewOrder[0], $EmptyIndxNewOrder[1], $EmptyIndxNewOrder[2]};
    $BestThree = ReverseStringArray($BestThree);
    $BestThree = stringArrayRemoveDuplicates ($BestThree);
    $indexAxNew = ArrayToIntList( $BestThree);
    $VecCurEnds = VecCurveEnds($CurveItemA);
    $LengCRV_a = `arclen $CurveItemA`;
    $DistEndsi = distance2Pts($VecCurEnds[0], $VecCurEnds[1]);
    $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
    $AverageVecCurEndsP = AverageVectorPoint($VecCurEnds);
    $Count = 0;
    $CurvePsD = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
    size($EmptyIndxNewOrder);
    $DirectionsZ = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    clear $colori;
    $iiX = 0;
    for($eachDirection in $indexAxNew){
    if($eachDirection ==0 || $eachDirection ==1){$colori[`size($colori)`] = 13;}
    if($eachDirection ==3 || $eachDirection ==2){$colori[`size($colori)`] = 14;}
    if($eachDirection ==4 || $eachDirection ==5){$colori[`size($colori)`] = 6;}
    }
    clear $CurvesV;
    $Cindex = 0;
    for ($eachDii in $indexAxNew){
    $IndexZ = $indexAxNew[$Count];
    $FloatPointDirectionZniY  = AddFloats( $VecCurEnds[1], $VecDirection_A_XYZ[$IndexZ]);
    $VecXYZsOnPlaneiY = VecPointsToCameraPlane($FloatPointDirectionZniY);
    $CurveDirectionZiY =  DirectionF($VecCurEnds[1],  $VecXYZsOnPlaneiY[0]);
    $FloatPointDirectionZniiY = AddFloats( $VecCurEnds[0], $VecDirection_A_XYZ[$IndexZ]);
    $VecXYZsOnPlaneiiY = VecPointsToCameraPlane($FloatPointDirectionZniiY);
    $CurveDirectionZiiY =  DirectionF($VecCurEnds[0],  $VecXYZsOnPlaneiiY[0]);
    $locsAi = lineIntersection($VecCurEnds[1], $CurveDirectionZiY, $VecCurEnds[0],  $CurveDirectionZiiY);
    $EpipLolar[$Count] = FloatToVec($locsAi);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[0], $locsAi);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], $colori[$Cindex]);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[1], $locsAi);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], $colori[$Cindex]);
    editDisplayLayerMembers -noRecurse VanishingPointsLines $CurvesV;
    $Cindex++;
    $Count++;
    }
    $ifSingleCurve = 0;
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);
    $HighCurvePoints = CurvatureUtilityCurvature($CurveItemA[0], 60);
    $Cindex = 0;
    if(`size($HighCurvePoints)`>0){
    for ($eachVec in $HighCurvePoints){
    $CurvesV[`size($CurvesV)`] = curve2points($eachVec, $MidEpipolPosFCam);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 11);
    }
    }
    $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
    $Dir_VecA =   PositiveDirectionLine($VecCurEnds[0],$VecCurEnds[1]);
    $VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    $INTERSECTIONLA = lineIntersectionF($VecCurEnds[0], $EpipLolar[0], $VecCurEnds[1],  $EpipLolar[1]);
    $INTERSECTIONLB = lineIntersectionF($VecCurEnds[1], $EpipLolar[0], $VecCurEnds[0],  $EpipLolar[1]);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[0],$INTERSECTIONLA);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 14);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[1],$INTERSECTIONLB);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 14);
    $CurvesV[`size($CurvesV)`] = curve2points($EpipLolar[2],$INTERSECTIONLA);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 4);
    $CurvesV[`size($CurvesV)`] = curve2points($EpipLolar[2],$INTERSECTIONLB);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 4);
    $VecPtsMirrorEnds_A= VecPtsToZMirrorPts( $VecCurEnds);
    $triggerMiddle = 0;
    $VIntersectEnds_A[0] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[1], $CamPos_M, $VecPtsMirrorEnds_A[0]));
    $VIntersectEnds_A[1] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[0], $CamPos_M, $VecPtsMirrorEnds_A[1]));
    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
    $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
    $IntersectEnds_Ai =  FloatPointsToCamPlane($VIntersectEnds_A[0]);
    $IntersectEnds_Bi = FloatPointsToCamPlane($VIntersectEnds_A[1]);
    $CurveItemAa[0] = $CurveItemA[0];
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEndsOLD = queryLocOnLivePlaneBLayer();
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    if(`size($queryLocCurveEnds)` > 2){
    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $NearestInt = SortNumbersIntIndex($distancesEachToCurve);
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[0]];
    $distancesEachToCurveB = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    $NearestIntB = SortNumbersIntIndex($distancesEachToCurveB);
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$NearestIntB[0]];
    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];
    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    $iv = -1;
    $distsA = $NdistA;
    $distsB = $NdistB;
    for (  $i = 1; $i < 5; $i++) {
    if( $distsA < $distsB){
    $NdistA = $distancesEachToCurve[$NearestInt[$i]];
    if($iv==-1){
    $iv++;
    $StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[0]];}
    if (equivalentTol($NdistA, $distsA, 0.001) == 1){
    $StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[$i]];
    }
    }
    }
    $newNames = stringArrayToString( $StringAllNearA, " ");
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    $arrayCurvesNearA = stringToStringArray($newNamesResultC, " ");
    $CRV_index_number = 0;
    $CRc = 0;
    $CRcT = 0;
    for($eachCurve in $arrayCurvesNearA){
    if(`sets -im ZEdgeCurvesSet $eachCurve` ==1){
    $CRV_index_number = $CRc;
    $CRcT++;
    break;
    }
    $CRc++;
    }
    if($CRcT ==1){
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[$CRc]];
    }
    }
    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];
    $newNames = stringArrayToString($EmptyStringNewOrderA, " ");
    $newNamesResultAx = substituteAllString($newNames, "Plane", "");
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    $arrayCurvesNear = stringToStringArray($newNamesResultC, " ");
    $NearCurvesEnds[0] = $arrayCurvesNear[0];
    $NearCurvesEnds[1] = $arrayCurvesNear[1];
    $arrayCurvesNearA1 = stringToStringArray($newNamesResultAx, " ");
    $LocCurveEndsVec_3D = PointArray($arrayCurvesNearA1);
    $LoCz_3D = $LocCurveEndsVec_3D;
    $TXI = << -1.0 , 1.0, 1.0>>;
    $LoCz_3D[2] = MultVec($LoCz_3D[0],$TXI);
    $LoCz_3D[3] = MultVec($LoCz_3D[1], $TXI);
    $countS = 0;
    for($eachItemVEC in $LoCz_3D){
    $VanishingLOC[ size($VanishingLOC) ] = Loc($eachItemVEC);
    if(($countS==0)||($countS==2)){
    SetItemColorString ($VanishingLOC[ size($VanishingLOC) -1], 19);
    setAttr ( $VanishingLOC[ size($VanishingLOC) -1]+".scale") 4.0 4.0 4.0;
    }else{SetItemColorString ($VanishingLOC[size($VanishingLOC)-1], 18);
    setAttr ( $VanishingLOC[ size($VanishingLOC) -1]+".scale") 9.0 9.0 9.0;
    }
    $countS++;
    }
    $PtsM_Ai = FloatPointsToCamPlane($LoCz_3D[2]);
    $PtsM_Bi = FloatPointsToCamPlane($LoCz_3D[3]);
    $INTERSECTIONLC = lineIntersectionF($EpipLolar[0], $PtsM_Ai, $INTERSECTIONLA, $EpipLolar[2]);
    $CurvesV[`size($CurvesV)`] = curve2points($PtsM_Ai,$INTERSECTIONLC);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 14);
    $INTERSECTIONL2C = lineIntersectionF($EpipLolar[0], $VecCurEnds[0], $INTERSECTIONLC, $EpipLolar[2]);
    $CurvesV[`size($CurvesV)`] = curve2points($INTERSECTIONLC,$INTERSECTIONL2C);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 4);
    $INTERSECTIONL2D = lineIntersectionF($EpipLolar[1],$INTERSECTIONLC, $VecCurEnds[1],  $EpipLolar[2]);
    $INTERSECTIONL3D = lineIntersectionF($EpipLolar[0],$INTERSECTIONL2D,$PtsM_Ai,  $EpipLolar[1]);
    $CurvesV[`size($CurvesV)`] = curve2points($INTERSECTIONL2D,$INTERSECTIONL3D);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 14);
    $CurvesV[`size($CurvesV)`] = curve2points($PtsM_Ai,$INTERSECTIONL3D);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 6);
    $CurvesV[`size($CurvesV)`] = curve2points($INTERSECTIONLC,$INTERSECTIONL2D);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 6);
    $CurvesV[`size($CurvesV)`] = curve2points($INTERSECTIONL2C,$VecCurEnds[1]);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], 6);
    appendStringArray($CurvesV, $VanishingLOC, size($VanishingLOC));
    $edgeZsetA = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[0]`;
    $edgeZsetB = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[1]`;
    $COuntN = 0;
    for($eachVec in $LocCurveEndsVec_3D){
    $ThreepointVecs = $eachVec;
    if (equivalentTol($ThreepointVecs[0], 0.00, 0.001) == 1){
    $EDGEpoints[$COuntN]= 1;
    }else{$EDGEpoints[$COuntN]= 0;}
    $COuntN++;
    }
    $edgeZsetA =$EDGEpoints[0];
    $edgeZsetB =$EDGEpoints[1];
    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    if(($NearCurvesEnds[0] == $NearCurvesEnds[1])&&( ($edgeZsetA+$edgeZsetB) ==2)){
    if($NdistA<$NdistB){
    $edgeZsetA =1;
    $edgeZsetB =0;
    }
    if($NdistA>$NdistB){
    $edgeZsetA =0;
    $edgeZsetB =1;
    }
    if($edgeZsetA==0){$NdistA=100;}
    if($edgeZsetB==0){$NdistB=100;}
    }
    }
    if(($NdistA>$SnapD)&&($NdistB>$SnapD)){
    $edgeZsetA =0;
    $edgeZsetB =0;
    }
    }
    if(($edgeZsetA==1)&&($NdistA<$SnapD)){
    $pointNearEdgeCurve[0]= 1;
    }
    if(($edgeZsetA==1)&&($NdistA>$SnapD)){
    $pointNearEdgeCurve[0]= 0;
    }
    if(($edgeZsetA==0)&&($NdistA>$SnapD)){
    $pointNearEdgeCurve[0]= 0;
    }
    if(($edgeZsetA==0)&&($NdistA<$SnapD)){
    $pointNearEdgeCurve[0]= 2;
    }
    if(($edgeZsetB==1)&&($NdistB<$SnapD)){
    $pointNearEdgeCurve[1]= 1;
    }
    if(($edgeZsetB==1)&&($NdistB>$SnapD)){
    $pointNearEdgeCurve[1]= 0;
    }
    if(($edgeZsetB==0)&&($NdistB>$SnapD)){
    $pointNearEdgeCurve[1]= 0;
    }
    if(($edgeZsetB==0)&&($NdistB<$SnapD)){
    $pointNearEdgeCurve[1]= 2;
    }
    if($edgeZsetA==1){
    $EdgeDist =$NdistA;
    }else{$EdgeDist=$NdistB;}
    $SnappingVector = 0;
    if($NdistA<$NdistB){
    $SnappingVector=0;
    }else{$SnappingVector=1;}
    if($NdistA>$SnapD){
    $edgeZsetA = 0;
    }
    if($NdistB>$SnapD){
    $edgeZsetB = 0;
    }
    $OneIsNotNearThePlane = 0;
    if(($NdistA>$SnapD)||($NdistB<$SnapD)){
    if(($NdistA<$SnapD)||($NdistB>$SnapD)){
    $OneIsNotNearThePlane =1;
    }
    }
    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    if(($edgeZsetA==1)||($edgeZsetB==1)){
    $EdgeDist =0.001;
    }
    }
    if($pointNearEdgeCurve[0]+$pointNearEdgeCurve[1]== 1){
    $newNamesResultA1 = substituteAllString($newNames, "Plane", "");
    $ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
    $ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
    $A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
    $A= `MakeCleanFloats($A)`;
    $B= `MakeCleanFloats($B)`;
    if(($A[0] ==0)||($B[0] ==0)){
    $triggerMiddle =2;
    $ifSingleCurve=1;
    if($edgeZsetA==1){
    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
    $NearVecPts[1]= $VecCurEnds[1];
    }else{
    $NearVecPts[0]= $VecCurEnds[0];
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
    }
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    if($EdgeDist<2.5){
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    $PositionsZ_Aii = $PositionsZ_Ai;
    }
    $PositionsZ_Aiix[0] = <<0, 0, 0>>;
    $PositionsZ_Aiix[1] = <<0, 1, 0>>;
    $PositionsZ_Aiix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    if($EdgeDist<2.5){
    $VecTest  = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
    }else{$VecTest  = LineIntersectPlaneCam($PositionsZ_A, $CamPos1, $PositionsZ_Aiix);
    }
    $CurveAv[0] = VecArrayToCurveB($VecTest);
    }
    }
    if( $pointNearEdgeCurve[1]==1){
    $newNamesResultA1 = substituteAllString($newNames, "Plane", "");
    $ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
    $ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
    $A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
    $A = MakeCleanFloatsZ($A);
    $B = MakeCleanFloatsZ($B);
    if(($A[0] ==0)&&($B[0] ==0)){
    $triggerMiddle =2;
    $ifSingleCurve=1;
    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    delete $CurveItemA;
    $CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);
    $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    if($DiffMathA >97.0){
    $PositionsZ_Aii[0] = $NearVecPts[0];
    $PositionsZ_Aii[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
    $PositionsZ_Aii[2]= $NearVecPts[1];
    } else{
    $PositionsZ_Aii = $PositionsZ_Ai;}
    $PositionsZ_Aiix[0] = <<0, 0, 0>>;
    $PositionsZ_Aiix[1] = <<0, 1, 0>>;
    $PositionsZ_Aiix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $VecTest = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
    if($DiffMathA >95.0){	$CurveAv[0] = VecArrayToCurve($VecTest);}else{
    $CurveAv[0] = VecArrayToCurve($VecTest);}
    }
    }
    if($triggerMiddle==0){
    if($GetSizeOfCRV_ends>0){
    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);
    $distancesTo3DCurveEnd = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
    $Sorted = SortNumbersIntIndex($distancesTo3DCurveEnd);
    $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
    $distancesTo3DCurveEndi = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
    $Sortedi = SortNumbersIntIndex($distancesTo3DCurveEndi);
    $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
    $FistAndSecond[0]=$LocCurveEndsVec3D[$Sorted[0]];
    $FistAndSecond[1]=$LocCurveEndsVec3D[$Sortedi[0]];
    $LocNames[0]=$queryLocCurveEnds3D[$Sorted[0]];
    $LocNames[1]=$queryLocCurveEnds3D[$Sortedi[0]];
    $LocNames[2]=$queryLocCurveEnds3D[$Sorted[1]];
    $LocNames[3]=$queryLocCurveEnds3D[$Sortedi[1]];
    $VecA = $FistAndSecond[0];
    $VecB = $FistAndSecond[1];
    $XX = $VecA.x;
    $XXX = $VecB.x;
    if( ($XX*-1)==$XXX){
    if($NptsDist<2.5){
    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($VecA));
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($VecB));
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    delete $CurveItemA;
    $CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);
    $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    clear $PositionsZ_A;
    if($DiffMathA >97.0){
    $PositionsZ_Ai[0] = $NearVecPts[0];
    $PositionsZ_Ai[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
    $PositionsZ_Ai[2]= $NearVecPts[1];
    }else{
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    }
    $ReversePositionsZ_Ai = ReverseVectorArray($PositionsZ_Ai);
    clear $PtsMirrorAi;
    $PtsMirrorAi= VecPtsToZMirrorPts($ReversePositionsZ_Ai);
    $iiz = 0;
    clear $XIntersect_Ax;
    for ($eachVecx in  $ReversePositionsZ_Ai){
    $XIntersect_Ax[`size($XIntersect_Ax)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_Ai[$iiz], $CamPos_M, $PtsMirrorAi[$iiz]));
    $iiz++;
    }
    if($DiffMathA >97.0){
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    }
    $CurveAv =  VecArrayToSplitCurve($XIntersect_Ax);
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
    $evalSmoothi += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmoothi);
    $ifSingleCurve=1;
    }
    }
    }
    }
    if(( $ifSingleCurve == 1)&&($triggerMiddle ==0)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[1];
    sets -include ZEdgeCurvesSet $CurveAv;
    }else{
    if(( $ifSingleCurve == 1)&&($triggerMiddle ==1)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    }
    }
    if( ($ifSingleCurve == 1)&&($triggerMiddle ==2)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv;
    $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    sets -include ZEdgeCurvesSet $CurveAv;
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    }
    $VanishingPointsLinesTempGuides = $CurvesV;
    editDisplayLayerMembers -noRecurse VanishingPointsLines $CurvesV;
    select -cl  ;
    return $CurvesV;

}


/******************************************************************************
 * @procedure    CurvatureUtilityCurvature
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $curvesZ : string
 *   $NumberofSteps : int
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] CurvatureUtilityCurvature(string $curvesZ, int $NumberofSteps)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum2 = (( $numEPs -1 ) * 2 );
    int $a;
    int $ii = 0;
    int $COuntNN = 0;
    float $step = $numEPrealNum2;
    float $StepCycle = 0;
    float $CurvatureRadi[];
    float $values[];
    float $AverageC = AverageFloats($CurvatureRadi);
    float $AboveOrBelow[] = GatherDataRR($CurvatureRadi, ($AverageC-(($AverageC/6.0)*5.0)));
    string $myCurve = $curvesZ;
    string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size  ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    vector $CurveVectors[];
    vector $ReturnVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $myCurve = $curvesZ;
    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum2 = (( $numEPs -1 ) * 2 );
    $numEPrealNum2 = $NumberofSteps;
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    $step = $numEPrealNum2;
    $StepCycle = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi[$ii] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    $CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
    $ii++;
    }
    $CurvatureRadi = AverageCurveFloat( $CurvatureRadi);
    $AverageC = AverageFloats($CurvatureRadi);
    $AboveOrBelow = GatherDataRR($CurvatureRadi, ($AverageC-(($AverageC/6.0)*5.0)));
    $COuntNN = 0;
    for($eachFloat in $AboveOrBelow){
    if($eachFloat ==1){
    $ReturnVec[`size($ReturnVec)`] = $CurveVectors[$COuntNN];
    }
    $COuntNN++;
    }
    delete $paramlocatorpointOnCurvex;
    return $ReturnVec;

}


/******************************************************************************
 * @procedure    AverageCurveFloat
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $newVec : float[]
 *
 * @returns      float []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] AverageCurveFloat(float $newVec[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AVvects[];
    float $Aver;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $range = 3;
    $TotalS = `size($newVec)`;
    $indexState = 0;
    while($indexState<$TotalS){
    $countS=1;
    $Xs=0;
    while($countS<$range){
    $indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
    $indexRight = fmod(($indexState + $countS),$TotalS);
    $indexLeftS[$Xs] = $indexLeft;
    $indexRightS[$Xs]= $indexRight;
    $countS++;
    $Xs++;
    }
    $Aver = ((($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0) + ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec [$indexState])/4.0;
    $AVvects[$indexState] = $Aver;
    clear $indexLeftS;
    clear $indexRightS;
    $indexState++;
    }
    return $AVvects;

}


/******************************************************************************
 * @procedure    VecCurveEnds
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $CurveItem : string[]
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecCurveEnds(string $CurveItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $CRVendPts[];
    vector $CRV_EndsVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVsL = `getAttr -size ($CurveItem[0]+".controlPoints")`-1;
    $numCVsSL = $numCVsL-1;
    $CRVendPts[0] = ($CurveItem[0] + ".cv[0]") ;
    $CRVendPts[1] = ($CurveItem[0] + ".cv[" +  $numCVsL + "]") ;
    for($i = 0; $i < 2;$i++){
    $CRV_EndsVec[$i]= `pointPosition -w ($CRVendPts[$i])`;
    }
    return $CRV_EndsVec;

}


/******************************************************************************
 * @procedure    ClosestPoint2LineVecX
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $DirectionLineF : float[]
 *   $PointOnLine : float[]
 *   $PointN : float[]
 *
 * @returns      vector
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector ClosestPoint2LineVecX(float $DirectionLineF[], float $PointOnLine[], float $PointN[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $locsA[];
    float $MultDirOne[] = multiplyFloat(1.0, $DirectionLineF);
    float $AddMultF[] = AddFloats($PointOnLine, $MultDirOne);
    float $FDirNorA[] = Normal3Points($PointOnLine, $AddMultF, $PointN);
    float $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    float $MultDirMx[] = multiplyFloat($DistToLineSTart, $FDirNorA);
    float $AddMultMiiFx[] = AddFloats($PointOnLine, $MultDirMx);
    float $FDirNorB[] = Normal3Points($PointOnLine, $AddMultMiiFx,  $AddMultF);
    float $MultDirMxz[] = multiplyFloat($DistToLineSTart,  $FDirNorB);
    float $AddMultMiiFxz[] = AddFloats($PointOnLine, $MultDirMxz);
    vector $VlocA;
    vector $VecLineDiri = DirectionFN($PointOnLine, $PointN);
    vector $VecLineDir = $VecLineDiri;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $VecLineDiri = DirectionFN($PointOnLine, $PointN);
    $VecLineDir = $VecLineDiri;
    $MultDirOne = multiplyFloat(1.0, $DirectionLineF);
    $AddMultF = AddFloats($PointOnLine, $MultDirOne);
    $FDirNorA = Normal3Points($PointOnLine, $AddMultF, $PointN);
    $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    $MultDirMx = multiplyFloat($DistToLineSTart, $FDirNorA);
    $AddMultMiiFx = AddFloats($PointOnLine, $MultDirMx);
    $FDirNorB = Normal3Points($PointOnLine, $AddMultMiiFx,  $AddMultF);
    $MultDirMxz = multiplyFloat($DistToLineSTart,  $FDirNorB);
    $AddMultMiiFxz = AddFloats($PointOnLine, $MultDirMxz);
    $locsA = lineIntersection($PointN, $FDirNorB, $PointOnLine,  $DirectionLineF);
    $VlocA = <<$locsA[0],$locsA[1],$locsA[2]>>;
    return $VlocA;

}


/******************************************************************************
 * @procedure    CRVEndNormals
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $CurveItem : string
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] CRVEndNormals(string $CurveItem)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $In[] = {1,0,2,3};
    string $CRVendPts[];
    vector $CRV_EndsVec[];
    vector $CRV_PlaneNorm[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVsL = `getAttr -size ($CurveItem+".controlPoints")`-1;
    $numCVsSL = $numCVsL-1;
    $CRVendPts[0] = ($CurveItem + ".cv[0]") ;
    $CRVendPts[1] = ($CurveItem + ".cv[1]") ;
    $CRVendPts[2] = ($CurveItem + ".cv[" +  $numCVsSL + "]") ;
    $CRVendPts[3] = ($CurveItem + ".cv[" +  $numCVsL + "]") ;
    $In = {1,0,2,3};
    for($i = 0; $i < 4;$i++){
    $CRV_EndsVec[$i]= `pointPosition -w ($CRVendPts[$i])`;
    }
    for($i = 0; $i < 2;$i++){
    $CRV_PlaneNorm[$i]= unit( FloatToVec(DirectionFN($CRV_EndsVec[$In[(($i*2)+1)]],$CRV_EndsVec[$In[($i*2)]])));
    }
    return $CRV_PlaneNorm;

}


/******************************************************************************
 * @procedure    BBoxInfo2D
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $i : string
 *
 * @returns      float[ ]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[ ] BBoxInfo2D(string $i)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $test[] = `xform -query -ws -t`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    select $i;
    PolySelectConvert 3;
    $test = `xform -query -ws -t`;
    $sizeTest = ((`size $test`) / 3);
    for ($a=1, $bbInfo[0] = $test[0], $bbInfo[3] = $test[0], $x=3, $bbInfo[1] = $test[1], $bbInfo[4] = $test[1], $y=4, $bbInfo[2] = $test[2], $bbInfo[5] = $test[2], $z=5; $a < $sizeTest; $a++)
    {
    $tempX = $test[$x];
    $x = $x + 3;
    $bbInfo[0] = `min $bbInfo[0] $tempX`;
    $bbInfo[3] = `max $bbInfo[3] $tempX`;
    $tempY = $test[$y];
    $y = $y + 3;
    $bbInfo[1] = `min $bbInfo[1] $tempY`;
    $bbInfo[4] = `max $bbInfo[4] $tempY`;
    $tempZ = $test[$z];
    $z = $z + 3;
    $bbInfo[2] = `min $bbInfo[2] $tempZ`;
    $bbInfo[5] = `max $bbInfo[5] $tempZ`;
    }
    return $bbInfo;

}


/******************************************************************************
 * @procedure    ProjectCrv2PlaneNormal
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $vecRs : vector[]
 *   $AvN : vector
 *   $Midp : vector
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] ProjectCrv2PlaneNormal(vector $vecRs[], vector $AvN, vector $Midp)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeVp = `size($vecRs)`;
    vector $NewPtsP[];
    vector $PtsVec;
    vector $Tran;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $RowC = $AvN;
    $AxisO = $Tran = $Midp;
    $SizeVp = `size($vecRs)`;
    for($Ind=0; $Ind<$SizeVp; $Ind++){
    $PtsVec=$vecRs[$Ind];
    $Pts = $PtsVec;
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    }
    return $NewPtsP;

}


/******************************************************************************
 * @procedure    VAnglesofThreeVec
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $VecA : vector
 *   $VecB : vector
 *   $VecC : vector
 *
 * @returns      float
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float VAnglesofThreeVec(vector $VecA, vector $VecB, vector $VecC)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $SideA = distance2Pts( $VecA, $VecB);
    float $SideB = distance2Pts( $VecB, $VecC);
    float $SideC = distance2Pts( $VecC, $VecA);
    float $Pi = 3.1415926535;
    float $ArcangleB = acos((((`pow $SideA 2.000`) + (`pow $SideC 2.000`) - (`pow $SideB 2.000`) )/(2.000*$SideA*$SideC)));
    float $AngleNPiB = ($ArcangleB*180)/$Pi;
    float $AngleNB = $AngleNPiB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SideA = distance2Pts( $VecA, $VecB);
    $SideB = distance2Pts( $VecB, $VecC);
    $SideC = distance2Pts( $VecC, $VecA);
    $Pi = 3.1415926535;
    $ArcangleB = acos((((`pow $SideA 2.000`) + (`pow $SideC 2.000`) - (`pow $SideB 2.000`) )/(2.000*$SideA*$SideC)));
    $AngleNPiB = ($ArcangleB*180)/$Pi;
    $AngleNB = $AngleNPiB;
    return $AngleNB;

}


/******************************************************************************
 * @procedure    Matrix_Curve_TranslationCC
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $VecPairA : vector[]
 *   $VecPairB : vector[]
 *   $CurveVecPointZ : vector[]
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] Matrix_Curve_TranslationCC(vector $VecPairA[], vector $VecPairB[], vector $CurveVecPointZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $LengthA = distance2Pts ($VecPairA[0], $VecPairA[1]);
    float $LengthB = distance2Pts ($VecPairB[0], $VecPairB[1]);
    float $LengthAB;
    float $Sign_F;
    vector $EmptyVecA[];
    vector $EmptyVecB[];
    vector $NVecPointZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    matrix $matrixB[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $matrixA = TwoPointMatrixPlusAxisWorld($VecPairA, $EmptyVecA, 1);
    $matrixB = TwoPointMatrixPlusAxisWorld($VecPairB, $EmptyVecB, 1);
    $LengthA = distance2Pts ($VecPairA[0], $VecPairA[1]);
    $LengthB = distance2Pts ($VecPairB[0], $VecPairB[1]);
    if($LengthA<$LengthB){$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}else{$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}
    $LengthAB *= $Sign_F;
    $matrixB[3][3] =$LengthAB;
    $NVecPointZ = MultPointMatrixArray($CurveVecPointZ, $matrixA,$matrixB);
    return $NVecPointZ;

}


/******************************************************************************
 * @procedure    MatrixAxisTranlation
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $SVeci : vector
 *   $mIA : matrix
 *   $mIB : matrix
 *
 * @returns      vector
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector MatrixAxisTranlation(vector $SVeci, matrix $mIA, matrix $mIB)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CombA = 0;
    int $CountN = 0;
    float $TransL[];
    float $DistToPlane[];
    float $EachFloatA;
    float $Subs[];
    float $AddF;
    float $SCale = $mIB[3][3];
    float $TransLb[];
    float $NewPos[] = AddFloats($TransLb, $NewAXis);
    vector $VecROne[] = GetRotationVectorsMatrix($mIA );
    vector $tranSVec = << $TransL[0], $TransL[1], $TransL[2]>>;
    vector $tranSVecA = $VecROne[0]+$tranSVec;
    vector $tranSVecC = $VecROne[2]+$tranSVec;
    vector $SVecii[];
    vector $SVecPoint = $SVeci;
    vector $YZvec = PointToPlaneN($SVecPoint, $SVecii);
    vector $ZXvec = PointToPlaneN($SVecPoint, $SVecii);
    vector $XYvec = PointToPlaneN($SVecPoint, $SVecii);
    vector $VecPlanes[];
    vector $VecLineDirM_All[];
    vector $SIgnA[] = GetVectorFloatSign( $VecLineDirM_All);
    vector $SIgnB[] = GetVectorFloatSign($VecROne);
    vector $EachVec;
    vector $EachVecT;
    vector $NewAXis;
    vector $NewPosVec = <<$NewPos[0], $NewPos[1], $NewPos[2]>>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $TransL[0] = $mIA[3][0];
    $TransL[1] = $mIA[3][1];
    $TransL[2] = $mIA[3][2];
    $VecROne = GetRotationVectorsMatrix($mIA );
    $tranSVec = << $TransL[0], $TransL[1], $TransL[2]>>;
    $tranSVecA = $VecROne[0]+$tranSVec ;	vector $tranSVecB = $VecROne [1]+$tranSVec ;
    $tranSVecC = $VecROne[2]+$tranSVec ;
    clear $SVecii;
    $SVecii[0] = $tranSVecB;	$SVecii[1] = $tranSVecC;
    $SVecii[2] = $tranSVec;
    $SVecPoint = $SVeci ;
    $YZvec = PointToPlaneN($SVecPoint, $SVecii);
    clear $SVecii;
    $SVecii[0] = $tranSVecC;	$SVecii[1] = $tranSVecA;
    $SVecii[2] = $tranSVec;
    $ZXvec = PointToPlaneN($SVecPoint, $SVecii);
    clear $SVecii;
    $SVecii[0] = $tranSVecA;	$SVecii[1] = $tranSVecB;
    $SVecii[2] = $tranSVec;
    $XYvec = PointToPlaneN($SVecPoint, $SVecii);
    $VecPlanes[0] = $YZvec; $VecPlanes[1] = $ZXvec; $VecPlanes[2] = $XYvec;
    for($EachVec in $VecPlanes){
    $VecLineDirM_All[`size($VecLineDirM_All)`] = FloatToVec(DirectionFN($EachVec,$SVeci));
    }
    $SIgnA = GetVectorFloatSign( $VecLineDirM_All);
    $SIgnB = GetVectorFloatSign($VecROne);
    $CombA = 0;
    $CountN = 0;
    for($EachVec in $VecPlanes){
    $CombA = PtsEquivalentF ($EachVec,  $SVeci, 0.001);
    if($CombA != 3){
    $DistToPlane[$CountN]= distance2Pts($SVeci,$EachVec);
    }else{$DistToPlane[$CountN]= 0.0;}
    $CountN++;
    }
    $CombA = 0;
    $CountN = 0;
    for($EachFloatA in $DistToPlane){
    if($EachFloatA != 0){
    $EachVecT = $SIgnA[$CountN] * $SIgnB[$CountN];
    $Subs =$EachVecT;
    $AddF = $Subs[0]+$Subs[1]+$Subs[2];
    if($AddF==3){
    $DistToPlane[$CountN]*= 1.0;
    }
    if($AddF==-9){
    $DistToPlane[$CountN]*= -1.0;
    }
    }
    $CountN++;
    }
    $SCale = $mIB[3][3];
    $SCale *= -1.0;
    $DistToPlane = multiplyFloat($SCale, $DistToPlane);
    $NewAXis = MultPointMatrix($DistToPlane, $mIB);
    $TransLb[0] = $mIB[3][0];
    $TransLb[1] = $mIB[3][1];
    $TransLb[2] = $mIB[3][2];
    $NewPos = AddFloats($TransLb, $NewAXis);
    $NewPosVec = <<$NewPos[0], $NewPos[1], $NewPos[2]>>;
    return $NewPosVec;

}


/******************************************************************************
 * @procedure    GetVectorFloatSign
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $VecLineDirM_All : vector[]
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] GetVectorFloatSign(vector $VecLineDirM_All[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CountIntA = 0;
    int $CountInt = 0;
    float $XYZsAxis[];
    float $EachFloat;
    float $SignPN[];
    vector $VecSIGNDirM[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    clear $VecSIGNDirM;
    $CountIntA = 0;
    $CountInt = 0;
    for($EachVeci in $VecLineDirM_All){
    $XYZsAxis = $EachVeci;
    for($EachFloat in $XYZsAxis){
    $SignPN[$CountInt] = `sign $EachFloat`;
    if($SignPN[$CountInt]==0){
    $SignPN[$CountInt] = 1;
    }
    $CountInt++;
    }
    $CountInt=0;
    $VecSIGNDirM[$CountIntA] =FloatToVec($SignPN);
    clear $XYZsAxis;
    $CountIntA++;
    }
    return $VecSIGNDirM;

}


/******************************************************************************
 * @procedure    TwoPointMatrixPlusAxisWorld
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $PtsVecii : vector[]
 *   $EmptyDirVector : vector[]
 *   $ZeroOne : int
 *
 * @returns      matrix
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix TwoPointMatrixPlusAxisWorld(vector $PtsVecii[], vector $EmptyDirVector[], int $ZeroOne)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CombA = 0;
    int $CountIndexV = 0;
    float $MidPt[];
    float $Addit[];
    float $AdditR;
    float $CamDirVecNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM",  0);
    float $MatrizFloati[] = MatrixToFloat($mI);
    vector $PtsVec[];
    vector $Line_Y_zeroMain;
    vector $Dir_VecA;
    vector $eachPointVd;
    vector $VecLineDirM;
    vector $DirLine = PositiveDirectionLine($PtsVec[0], $PtsVec[1]);
    vector $Vperp = crossProduct( $DirLine, $CamDirVecNormal, 0, 0 );
    vector $BInomalV = FloatToVec(MultLenToDirAddToPoint(2, $Vperp, $PtsVec[0]));
    vector $BInomalVDirLine = PositiveDirectionLine($PtsVec[0], $BInomalV);
    vector $TangentV = FloatToVec(MultLenToDirAddToPoint(4,$CamDirVecNormal,  $PtsVec[0]));
    vector $norm = FloatToVec($CamDirVecNormal);
    vector $bi = $BInomalVDirLine;
    vector $tan = $DirLine;
    vector $bi_two = `cross $tan $norm`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PtsVec = $PtsVecii;
    $MidPt = MidPoint($PtsVec[0], $PtsVec[1]);
    $Line_Y_zeroMain = PositiveDirectionLine($PtsVec[0], $PtsVec[1]);
    $CombA = 0;
    $CountIndexV = 0;
    for ($eachPointVd in $PtsVec){
    $Dir_VecA = FloatToVec (DirectionFN($eachPointVd, $MidPt));
    $VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    if($AdditR != 0.0){break;}else{
    $CountIndexV++;}
    }
    if($CountIndexV == 1){
    $PtsVec = ReverseVectorArray($PtsVec);
    }
    $CamDirVecNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM",  0);
    $CamDirVecNormal= multiplyFloat(-1.0, $CamDirVecNormal);
    $DirLine = PositiveDirectionLine($PtsVec[0], $PtsVec[1]);
    $Vperp = crossProduct( $DirLine, $CamDirVecNormal, 0, 0 );
    $BInomalV = FloatToVec(MultLenToDirAddToPoint(2, $Vperp, $PtsVec[0]));
    $BInomalVDirLine = PositiveDirectionLine($PtsVec[0], $BInomalV);
    $BInomalV = FloatToVec(MultLenToDirAddToPoint(4, $BInomalVDirLine, $PtsVec [0]));
    $TangentV = FloatToVec(MultLenToDirAddToPoint(4,$CamDirVecNormal,  $PtsVec[0]));
    $norm = FloatToVec($CamDirVecNormal);
    $bi = $BInomalVDirLine;
    $tan = $DirLine;
    matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $DirectionVector[0] =  $norm;
    $DirectionVector[1] =  $bi;
    $DirectionVector[2] =  $tan;
    $EmptyDirVector = $DirectionVector;

    $bi_two = `cross $tan $norm`;
    if($ZeroOne== 0){
    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;
    ($bi.x), ($bi.y), ($bi.z),  0.0;
    ($tan.x), ($tan.y), ($tan.z), 0.0;
    0.0, 0.0, 0.0, 1.0  >>;
    }
    if($ZeroOne== 1){
    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;
    ($bi.x), ($bi.y), ($bi.z),  0.0;
    ($tan.x), ($tan.y), ($tan.z), 0.0;
    $MidPt[0], $MidPt[1], $MidPt[2], 1.0  >>;
    }
    $MatrizFloati = MatrixToFloat($mI);
    return $mI;

}


/******************************************************************************
 * @procedure    TwoPointMatrix
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $FixVecii : vector[]
 *
 * @returns      matrix
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix TwoPointMatrix(vector $FixVecii[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CombA = 0;
    int $CountIndexV = 0;
    float $MidPt[];
    float $Addit[];
    float $AdditR;
    float $Va[] = $FixVeci[0];
    float $Vb[] = $FixVeci[1];
    float $FloatDirMajor[] = $DirLine;
    float $FDirNorAi[] = $LineDirYT;
    float $MatrizFloati[] = MatrixToFloat($mI);
    vector $FixVeci[];
    vector $LineAMain;
    vector $DirMTestVec;
    vector $eachPointVd;
    vector $VecLineDirM;
    vector $ZeroA = <<0.0, 0.0, 0.0>>;
    vector $LineA = PositiveDirectionLine($FixVecB[0], $FixVecB[1]);
    vector $pointYVec = ClosestPoint2LineVec($LineA, $FixVecB[0], $ZeroA);
    vector $LineDirYT = PositiveDirectionLine($pointYVec, $ZeroA);
    vector $DirLine = PositiveDirectionLine($FixVeci[0], $FixVeci[1]);
    vector $Vperp = crossProduct( $DirLine, $LineDirYT, 0, 0 );
    vector $BInomalV = FloatToVec(MultLenToDirAddToPoint(2, $Vperp, $FixVeci[0]));
    vector $BInomalVDirLine = PositiveDirectionLine($FixVeci[0], $BInomalV);
    vector $TangentV = FloatToVec(MultLenToDirAddToPoint(4, $LineDirYT, $FixVeci[0]));
    vector $DirNormi = $LineDirYT;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $FixVeci = $FixVecii;
    $LineAMain =FloatToVec (DirectionFN($FixVeci[0], $FixVeci[1]));
    $MidPt = MidPoint($FixVeci[0], $FixVeci[1]);
    $LineAMain = PositiveDirectionLine($FixVeci[0], $FixVeci[1]);
    $CombA = 0;
    $CountIndexV = 0;
    for ($eachPointVd in $FixVeci){
    $DirMTestVec = FloatToVec (DirectionFN($eachPointVd, $MidPt));
    $VecLineDirM = ( $DirMTestVec+$LineAMain );
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    if($AdditR != 0.0){break;}else{
    $CountIndexV++;}
    }
    if($CountIndexV == 1){
    $FixVeci= ReverseVectorArray($FixVeci);
    }
    $ZeroA = <<0.0, 0.0, 0.0>>;
    $Va = $FixVeci[0];
    $Vb = $FixVeci[1];
    $FixVecB[0]= << $Va[0], 0.0, $Va[2] >>;
    $FixVecB[1]= << $Vb[0], 0.0, $Vb[2] >>;
    $LineA = PositiveDirectionLine($FixVecB[0], $FixVecB[1]);
    $pointYVec = ClosestPoint2LineVec($LineA, $FixVecB[0], $ZeroA);
    $LineDirYT = PositiveDirectionLine($pointYVec, $ZeroA);
    $DirLine = PositiveDirectionLine($FixVeci[0], $FixVeci[1]);
    $Vperp = crossProduct( $DirLine, $LineDirYT, 0, 0 );
    $BInomalV = FloatToVec(MultLenToDirAddToPoint(2, $Vperp, $FixVeci[0]));
    $BInomalVDirLine = PositiveDirectionLine($FixVeci[0], $BInomalV);
    $BInomalV = FloatToVec(MultLenToDirAddToPoint(4, $BInomalVDirLine, $FixVeci [0]));
    $TangentV = FloatToVec(MultLenToDirAddToPoint(4, $LineDirYT, $FixVeci[0]));
    $FloatDirMajor = $DirLine;
    $FDirNorAi = $LineDirYT;
    $DirNormi = $LineDirYT;
    $normal = $BInomalVDirLine;
    matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $norm = $LineDirYT;
    $bi = $BInomalVDirLine;
    $tan = $DirLine;
    $tan  = `unit << ($tan.x), ($tan.y), ($tan.z) >>`;
    $norm = `unit << ($norm.x), ($norm.y), ($norm.z) >>`;
    $bi = `unit $bi`;

    $tan = FloatToVec(MakeCleanFloatsZ($tan));
    $norm = FloatToVec(MakeCleanFloatsZ($norm));
    $bi = FloatToVec(MakeCleanFloatsZ($bi));
    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;
    ($bi.x), ($bi.y), ($bi.z),  0.0;
    ($tan.x), ($tan.y), ($tan.z), 0.0;
    $MidPt[0], $MidPt[1], $MidPt[2], 1.0  >>;
    $mI = MatrixCleanNegZero($mI);
    $MatrizFloati = MatrixToFloat($mI);
    return $mI;

}


/******************************************************************************
 * @procedure    Partition
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $a : float[]
 *   $Index : int[]
 *   $p : int
 *   $r : int
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int Partition(float $a[], int $Index[], int $p, int $r)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $xIndex = $Index[$r];
    int $j = $p - 1;
    int $i;
    float $x = $a[$r];
    float $temp = $a[$j];
    float $tempIndex = $Index[$j];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $x = $a[$r];
    $xIndex = $Index[$r];
    $j = $p - 1;
    for (  $i = $p; $i < $r; $i++) {
    if ($x <= $a[$i]) {
    $j = $j + 1;
    $temp = $a[$j];
    $tempIndex = $Index[$j];
    $a[$j] = $a[$i];
    $Index[$j] = $Index[$i];
    $a[$i] = $temp;
    $Index[$i] = $tempIndex;
    }
    }
    $a[$r] = $a[$j + 1];
    $Index[$r] = $Index[$j + 1];
    $a[$j + 1] = $x;
    $Index[$j + 1] = $xIndex;
    return ($j + 1);

}


/******************************************************************************
 * @procedure    Normal3Points
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $p1 : float[]
 *   $p2 : float[]
 *   $p3 : float[]
 *
 * @returns      float []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] Normal3Points(float $p1[], float $p2[], float $p3[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $center[];
    float $normal[];
    vector $normalV[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		 $p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		 $p1p3[2]= $p3[2]-$p1[2];
    $normalV = crossProduct( $p1p2, $p1p3, 0, 0 );
    $normal = `unit $normalV[0]`;
    return $normal;

}


/******************************************************************************
 * @procedure    FindLineCross
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Vecbv : vector[]
 *   $Vecbvi : vector[]
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindLineCross(vector $Vecbv[], vector $Vecbvi[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $trueOrFalse = IsPointInLine ($Vecbv[0], $Vecbv[1], $centerCross);
    float $centerCross[] = lineIntersection( $Vecbv[0], $DirecA, $Vecbv[1], $DirecB);
    vector $DirecA = FloatToVec(DirectionFN($Vecbv[0],$Vecbvi[1]));
    vector $DirecB = FloatToVec(DirectionFN($Vecbv[1],$Vecbvi[0]));

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $DirecA = FloatToVec(DirectionFN($Vecbv[0],$Vecbvi[1]));
    $DirecB = FloatToVec(DirectionFN($Vecbv[1],$Vecbvi[0]));
    $centerCross = lineIntersection( $Vecbv[0], $DirecA, $Vecbv[1], $DirecB);
    $trueOrFalse = IsPointInLine ($Vecbv[0], $Vecbv[1], $centerCross);
    return $trueOrFalse;

}


/******************************************************************************
 * @procedure    IsPointInLine
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $a : float[]
 *   $b : float[]
 *   $c : float[]
 *
 * @returns      int
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int IsPointInLine(float $a[], float $b[], float $c[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $returnVal = 0;
    float $DPi = (distance2Pts($VecC[0], $VecC[1]))/2.0;
    float $DPiMid = distance2Pts($VecC[0], $MidPoint);
    float $DPa = distance2Pts( $MidPoint, $VecC[2]);
    vector $VecC[];
    vector $MidPoint = FloatToVec (MidPoint($VecC[0], $VecC[1]));

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $VecC[0] = FloatToVec($a);
    $VecC[1] = FloatToVec($b);
    $VecC[2] = FloatToVec($c);
    $DPi = (distance2Pts($VecC[0], $VecC[1]))/2.0;
    $MidPoint = FloatToVec (MidPoint($VecC[0], $VecC[1]));
    $DPiMid = distance2Pts($VecC[0], $MidPoint);
    $DPa = distance2Pts( $MidPoint, $VecC[2]);
    $returnVal = 0;
    if($DPa<=$DPiMid){
    $returnVal=1;}
    print $returnVal;
    return $returnVal;

}


/******************************************************************************
 * @procedure    DirectionFN
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $posAZ : float[]
 *   $posBZ : float[]
 *
 * @returns      float[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] DirectionFN(float $posAZ[], float $posBZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $u = $xi - $x;
    float $v = $yi - $y;
    float $w = $zi - $z;
    float $UnitDirection[];
    vector $Vai = << $posAZ[0], $posAZ[1], $posAZ[2] >>;
    vector $Vbi = << $posBZ[0],  $posBZ[1], $posBZ[2] >>;
    vector $VbiUnit = << $u, $v, $w >>;
    vector $VbiUnitA = `unit $VbiUnit`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Vai = << $posAZ[0], $posAZ[1], $posAZ[2] >> ;
    $Vbi = << $posBZ[0],  $posBZ[1], $posBZ[2] >> ;
    $xi = $Vai.x;
    $yi = $Vai.y;
    $zi = $Vai.z;
    $x = $Vbi.x;
    $y = $Vbi.y;
    $z = $Vbi.z;
    $u = $xi - $x;
    $v = $yi - $y;
    $w = $zi - $z;
    $VbiUnit = << $u, $v, $w >> ;
    $VbiUnitA = `unit $VbiUnit`;

    $UnitDirection = $VbiUnitA;
    return $UnitDirection;

}


/******************************************************************************
 * @procedure    PositiveDir
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $VecOrFloatA : float[]
 *
 * @returns      vector
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector PositiveDir(float $VecOrFloatA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $e = 1;
    float $Y = ($e*$xi);
    float $U = ($e*$yi);
    float $V = ($e*$zi);
    vector $VecA = FloatToVec($VecOrFloatA);
    vector $Va = $VecA;
    vector $YUV = << $Y, $U, $V>>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $VecA = FloatToVec($VecOrFloatA);
    $Va = $VecA;
    $xi = $Va.x;
    $yi = $Va.y;
    $zi = $Va.z;
    $e = 1;
    if(`sign $xi` == -1){
    $e = -1.0;
    }
    if((`sign $xi` == -1)&&(`sign $yi` == -1)){
    $e = -1.0;
    }
    if((`sign $xi` == -1)&&(`sign $zi` == -1)){
    $e = -1.0;
    }
    $Y = ($e*$xi);
    $U = ($e*$yi);
    $V = ($e*$zi);
    $YUV = << $Y, $U, $V>>;
    return $YUV;

}


/******************************************************************************
 * @procedure    PositiveDirectionLine
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $VecA : vector
 *   $VecB : vector
 *
 * @returns      vector
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector PositiveDirectionLine(vector $VecA, vector $VecB)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $u = $xi - $x;
    float $v = $yi - $y;
    float $w = $zi - $z;
    float $e = 1.0;
    float $Y = $u/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    float $U = $v/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    float $V = $w/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    vector $Va = $VecA;
    vector $Vb = $VecB;
    vector $YUV = << $Y, $U, $V>>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Va = $VecA;
    $Vb = $VecB;
    $xi = $Va.x;
    $yi = $Va.y;
    $zi = $Va.z;
    $x = $Vb.x;
    $y = $Vb.y;
    $z = $Vb.z;
    $u = $xi - $x;
    $v = $yi - $y;
    $w = $zi - $z;
    $e = 1.0;
    if(`sign $v` == -1){
    $e = -1.0;
    }
    if((`sign $v` == -1)&&(`sign $u` == -1)){
    $e = -1.0;
    }
    if((`sign $v` == -1)&&(`sign $w` == -1)){
    $e = -1.0;
    }
    $Y = $u/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $U = $v/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $V = $w/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $YUV = << $Y, $U, $V>>;
    return $YUV;

}


/******************************************************************************
 * @procedure    Circle3PtsM
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $p1 : float[]
 *   $p2 : float[]
 *   $p3 : float[]
 *
 * @returns      float []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] Circle3PtsM(float $p1[], float $p2[], float $p3[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $center[];
    float $normal[];
    float $FloatPosZero[] = {0, 0, 0};
    float $FloatDirection[] = DirectionF($FloatPosZero, $normal);
    float $radiusZ = distance2Pts( $p1, $center );
    float $CenterRadius[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );
    $FloatPosZero = {0, 0, 0};
    $FloatDirection = DirectionF($FloatPosZero, $normal);
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    $radiusZ = distance2Pts( $p1, $center );
    $CenterRadius = $center;
    $CenterRadius[`size($CenterRadius)`]= $radiusZ;
    return $CenterRadius;

}


/******************************************************************************
 * @procedure    Circle3PtZFloats
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $p1 : float[]
 *   $p2 : float[]
 *   $p3 : float[]
 *
 * @returns      float []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] Circle3PtZFloats(float $p1[], float $p2[], float $p3[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $center[];
    float $radiusZ = distance2Pts( $p1, $center );
    float $CenterRadius[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    $radiusZ = distance2Pts( $p1, $center );
    $CenterRadius = $center;
    $CenterRadius[`size($CenterRadius)`]= $radiusZ;
    return $CenterRadius;

}


/******************************************************************************
 * @procedure    Circle3PtZFloatsI
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $p1 : float[]
 *   $p2 : float[]
 *   $p3 : float[]
 *
 * @returns      float []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] Circle3PtZFloatsI(float $p1[], float $p2[], float $p3[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $center[];
    float $normal[];
    float $FloatPosZero[] = {0, 0, 0};
    float $FloatDirection[] = DirectionF($FloatPosZero, $normal);
    float $MultDirP[] = multiplyFloat(2, $FloatDirection);
    float $FloatDirPerpCenter[] = DirectionF($center, $mid3);
    float $FloatDirPerpCenterB[] = DirectionF($center,$mid1);
    float $FloatDirPerpCenterC[] = DirectionF($center,$mid2);
    float $FloatDirPointAB[] = DirectionF($p1, $p2);
    float $FloatDirPointBC[] = DirectionF($p2, $p3);
    float $FloatDirPointAC[] = DirectionF($p1, $p3);
    float $center6[] = lineIntersection( $p1, $FloatDirPerpCenter, $p2, $FloatDirPointBC );
    float $center7[] = lineIntersection( $p3,  $FloatDirPerpCenterB, $p1, $FloatDirPointAB );
    float $center8[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    float $center9[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPerpCenter );
    float $OrthoCenterCir[] = midPoint2Pts( $center9, $center );
    float $Radius2HalfTimes2 = (distance2Pts( $center9, $center ))*2;
    float $Radius2BHalf = (distance2Pts( $center9, $center ));
    float $radiusZ = distance2Pts( $p1, $center );
    float $Radius3Half = $radiusZ/2;
    float $CenterRadius[];
    string $circlesItemA[];
    string $circlesItem[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $p1p4[0] = $p2[0]-$p3[0]; 		$p1p4[1] = $p2[1]-$p3[1]; 		$p1p4[2]= $p2[2]-$p3[2];
    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );
    $FloatPosZero = {0, 0, 0};
    $FloatDirection = DirectionF($FloatPosZero, $normal);
    $MultDirP = multiplyFloat(2, $FloatDirection);
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $mid3 = midPoint2Pts( $p2, $p3 );
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $perp_p1p4 = crossProduct( $normal, $p1p4, 0, 1 );
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    $FloatDirPerpCenter = DirectionF($center, $mid3);
    $FloatDirPerpCenterB = DirectionF($center,$mid1);
    $FloatDirPerpCenterC = DirectionF($center,$mid2);
    $FloatDirPointAB = DirectionF($p1, $p2);
    $FloatDirPointBC = DirectionF($p2, $p3);
    $FloatDirPointAC = DirectionF($p1, $p3);
    $center6 = lineIntersection( $p1, $FloatDirPerpCenter, $p2, $FloatDirPointBC );
    $center7 = lineIntersection( $p3,  $FloatDirPerpCenterB, $p1, $FloatDirPointAB );
    $center8 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    curve2points($center, $mid1);
    curve2points($center,$mid2);
    curve2points($center,$mid3);
    $center9 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPerpCenter );
    $OrthoCenterCir = midPoint2Pts( $center9, $center );
    $Radius2HalfTimes2 = (distance2Pts( $center9, $center ))*2;
    $Radius2BHalf = (distance2Pts( $center9, $center ));
    $radiusZ = distance2Pts( $p1, $center );
    $Radius3Half = $radiusZ/2;
    $circlesItemA[0] = Circles_Direction($OrthoCenterCir, $FloatDirection, $Radius3Half);
    $circlesItem[0] = Circles_Direction($center, $FloatDirection, $radiusZ);
    $radiusZ = distance2Pts( $p1, $center );
    $CenterRadius = $center;
    $CenterRadius[`size($CenterRadius)`]= $radiusZ;
    return $CenterRadius;

}


/******************************************************************************
 * @procedure    VecArrayDiff
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $IndeXxz : int[]
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecArrayDiff(int $IndeXxz[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Ixx = 0;
    int $EIndex[];
    int $Ii = 0;
    int $one;
    vector $VecS[] = $AllVecsG;
    vector $newVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global vector $AllVecsG[];
    global vector $WorkingAllVecsG[];
    $VecS = $AllVecsG;
    $Ixx = 0;
    $EIndex = $IndeXxz;
    $EIndex = `sort $EIndex`;
    $Ii = 0;
    for ($eachVc in $VecS){
    $one =$EIndex[$Ii];
    if(!($Ixx==$one)){
    $newVec[`size($newVec)`] = $VecS[$Ixx];
    }else{$Ii++;}
    $Ixx++;
    }
    $WorkingAllVecsG = $newVec;
    return $newVec;

}


/******************************************************************************
 * @procedure    VecArrayInclude
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $IndeXxz : int[]
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecArrayInclude(int $IndeXxz[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Ixx = 0;
    int $EIndex[];
    int $Ii = 0;
    int $one;
    vector $VecS[] = $AllVecsG;
    vector $newVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global vector $AllVecsG[];
    global vector $WorkingAllVecsG[];
    $VecS = $AllVecsG;
    $Ixx = 0;
    $EIndex = $IndeXxz;
    $EIndex = `sort $EIndex`;
    $Ii = 0;
    for ($eachVc in $VecS){
    $one =$EIndex[$Ii];
    if(($Ixx==$one)){
    $newVec[`size($newVec)`] = $VecS[$Ixx];
    }else{$Ii++;}
    $Ixx++;
    }
    $WorkingAllVecsG = $newVec;
    return $newVec;

}


/******************************************************************************
 * @procedure    FlattenSnap
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Vec_A : vector[]
 *   $XYZvec : int
 *   $Val : float
 *
 * @returns      vector []
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] FlattenSnap(vector $Vec_A[], int $XYZvec, float $Val)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $xyz[];
    vector $Vi;
    vector $ViNew[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($i=0;  $i < `size($Vec_A)`; $i++){
    $Vi= $Vec_A[$i];
    $xyz[0] = $Vi.x;
    $xyz[1] = $Vi.y;
    $xyz[2] = $Vi.z;
    $xyz[$XYZvec]= $Val;
    $ViNew[$i] = <<$xyz[0], $xyz[1], $xyz[2]>>;
    }
    return $ViNew;

}


/******************************************************************************
 * @procedure    MultVec
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Va : float[]
 *   $Vb : float[]
 *
 * @returns      vector
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector MultVec(float $Va[], float $Vb[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $PtsC[];
    vector $VecMult;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PtsC[0]= $Va[0] * $Vb[0];
    $PtsC[1]= $Va[1] * $Vb[1];
    $PtsC[2]= $Va[2] * $Vb[2];
    $VecMult = << $PtsC[0],  $PtsC[1],  $PtsC[2] >>;
    return $VecMult;

}


/******************************************************************************
 * @procedure    CreateCAMforIntCurveScript
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 *
 * @returns      string[]
 * @source       RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CreateCAMforIntCurveScript()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectZcurv[0] +  ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $LocatorLoop = 0;
    float $eachCVpos[];
    string $CamConeLocator[];
    string $CurveSelection[];
    string $each;
    string $MakespaceLocator[];
    string $objectZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    CreateCameraOnly;
    rename ZCURVEModelingCAM;
    lookThroughModelPanelClipped ZCURVEModelingCAM  modelPanel4 0.001 1000;
    nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr  1 -n "LiveSurfaceB";
    editDisplayLayerMembers -noRecurse  layerYZYXPlains "LiveSurfaceB";
    clear $CamConeLocator;
    curve -d 3 -p 0 0 0 -p 0 0 -4 -p 0 0 -8 -p 0 0 - 12 -k 0 -k 0 -k 0 -k 12 -k 12 -k 12 -n  Deletethiscurve ;
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    $objectZcurv = `ls -sl`;
    $numCVs = `getAttr -size ($objectZcurv[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectZcurv[0] + ".cv[0]")  ;
    $CurveSelection[1] = ($objectZcurv[0] + ".cv[" +  $numCVrealNum + "]") ;
    for ($each in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $each  )`;
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n LocatorA`;
    ArrayInsertAtEnd($CamConeLocator,  $MakespaceLocator[0]);
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakespaceLocator[0];
    }
    $LocatorLoop = 0; int $LocatorLoopA = -1;
    while ($LocatorLoop++ < 7) {
    $LocatorLoopA = $LocatorLoopA +1;
    if ($LocatorLoopA == 0){
    clear $objectZ;
    stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
    stringArrayInsertAtIndex(1, $objectZ,  "LocatorA1");
    }
    if ($LocatorLoopA > 0){
    clear $objectZ;
    stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
    stringArrayInsertAtIndex(1, $objectZ,  $MakespaceLocator[0]);
    }
    if ($LocatorLoopA < 7){
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n  LocatorMiddleDistance`;
    ArrayInsertAtEnd($CamConeLocator,  $MakespaceLocator[0]);
    averagingNode($objectZ[0], $MakespaceLocator[0],  $objectZ[1]);
    }
    }
    ArrayInsertAtEnd( $CamConeLocator,  $CamConeLocator[0]);
    stringArrayRemoveAtIndex(0, $CamConeLocator);
    parentConstraint -mo -weight 1 ZCURVEModelingCAM  LocatorA1 ;
    parentConstraint -mo -weight 1 ZCURVEModelingCAM  LocatorA;
    delete  Deletethiscurve;
    align -atl -x Mid -y Mid -z Mid LiveSurfaceB  ZCURVEModelingCAM;
    move -r -os -wd 0 5 5 ZCURVEModelingCAM ;
    setAttr "ZCURVEModelingCAM.rotateX" -45;
    setAttr "LiveSurfaceB.rotateX" (`getAttr  ("ZCURVEModelingCAM" + ".rotateX")`+90);
    setAttr "LiveSurfaceB.rotateY" `getAttr  ("ZCURVEModelingCAM" + ".rotateY")`;
    setAttr "LiveSurfaceB.rotateZ" `getAttr  ("ZCURVEModelingCAM" + ".rotateZ")`;
    align -atl -x Mid -y Mid -z Mid LiveSurfaceB  ZCURVEModelingCAM;
    move -r -os -wd 0 -0.7 0 LiveSurfaceB ;
    move -r -os -wd 0 0 0.210031 LiveSurfaceB ;
    parentConstraint -mo -weight 1 ZCURVEModelingCAM  LiveSurfaceB;
    setAttr "ZCURVEModelingCAM.translateX" 48 ;
    setAttr "ZCURVEModelingCAM.translateY" 41 ;
    setAttr "ZCURVEModelingCAM.translateZ" 48 ;
    setAttr "ZCURVEModelingCAM.rotateX" -25 ;
    setAttr "ZCURVEModelingCAM.rotateY" 45;
    setAttr "ZCURVEModelingCAM.rotateZ" 0;
    return $CamConeLocator;

}


/******************************************************************************
 * @procedure    AnglesofTriangle
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $SideA : float
 *   $SideB : float
 *   $SideC : float
 *
 * @returns      float []
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] AnglesofTriangle(float $SideA, float $SideB, float $SideC)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Pi = 3.1415926535;
    float $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
    float $AngleNPi = ($Arcangle*180)/$Pi;
    float $AngleNA = $AngleNPi;
    float $ArcangleB = acos((((`pow $SideA 2.000`) + (`pow $SideC 2.000`) - (`pow $SideB 2.000`) )/(2.000*$SideA*$SideC)));
    float $AngleNPiB = ($ArcangleB*180)/$Pi;
    float $AngleNB = $AngleNPiB;
    float $ArcangleC = acos((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
    float $AngleNPiC = ($ArcangleC*180)/$Pi;
    float $AngleNC = $AngleNPiC;
    float $Angle_a = $AngleNA;
    float $Angle_b = $AngleNB;
    float $Angle_c = $AngleNC;
    float $Add = $Angle_a + $Angle_b + $Angle_c;
    float $Angle_ABC[] = {$Angle_a, $Angle_b, $Angle_c};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $Pi = 3.1415926535;
    $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
    $AngleNPi = ($Arcangle*180)/$Pi;
    $AngleNA = $AngleNPi;

    $ArcangleB = acos((((`pow $SideA 2.000`) + (`pow $SideC 2.000`) - (`pow $SideB 2.000`) )/(2.000*$SideA*$SideC)));
    $AngleNPiB = ($ArcangleB*180)/$Pi;
    $AngleNB = $AngleNPiB;

    $ArcangleC = acos((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
    $AngleNPiC = ($ArcangleC*180)/$Pi;
    $AngleNC = $AngleNPiC;

    // acos is the Arc Cos which is sometime called cos pow-1 which does not mean cos raised to the Neg One power but
    // is the opposite angle called acos if you move cos to the other side of the equal sign when solving an equation.
    //simple ass hell.. but wont find these answers any place but from me since reality is fucked. Luck has it the internet exists.
    //and knowledge WANTS to grow.
    // acos atan asin same thing

    $Angle_a = $AngleNA;
    $Angle_b = $AngleNB;
    $Angle_c = $AngleNC;
    $Add = $Angle_a + $Angle_b + $Angle_c;
    $Angle_ABC = {$Angle_a, $Angle_b, $Angle_c} ;
    return $Angle_ABC;

}


/******************************************************************************
 * @procedure    RotMultLenToDirAddToPoint
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $PosA : float[]
 *   $PosB : float[]
 *   $PosOrNegOne : int
 *   $Length : float
 *   $DirNormAx : float[]
 *   $Radian : float
 *
 * @returns      float []
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] RotMultLenToDirAddToPoint(float $PosA[], float $PosB[], int $PosOrNegOne, float $Length, float $DirNormAx[], float $Radian)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $rotatsA[] = `rot $DirecOfPointAB $DirNorm $Radian`;
    float $MultLengthDir[] = multiplyFloat($Length, $rotatsA);
    float $AddMultDirPos[] = AddFloats($PosA, $MultLengthDir);
    vector $DirecOfPointAB = FloatToVec ( DirectionF($PosA, $PosB));
    vector $DirNorm = FloatToVec ($DirNormAx);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $DirecOfPointAB = FloatToVec ( DirectionF($PosA, $PosB));
    $DirecOfPointAB = FloatToVec ( multiplyFloat($PosOrNegOne, $DirecOfPointAB));
    $DirNorm = FloatToVec ($DirNormAx);
    $rotatsA = `rot $DirecOfPointAB $DirNorm $Radian`;
    $MultLengthDir = multiplyFloat($Length, $rotatsA);
    $AddMultDirPos = AddFloats($PosA, $MultLengthDir);
    return $AddMultDirPos;

}


/******************************************************************************
 * @procedure    RotDirToPoint
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $PosA : float[]
 *   $PosB : float[]
 *   $PosOrNegOne : int
 *   $DirNormAx : float[]
 *   $Radian : float
 *
 * @returns      float []
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] RotDirToPoint(float $PosA[], float $PosB[], int $PosOrNegOne, float $DirNormAx[], float $Radian)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Length = distance2Pts ($PosA, $PosB);
    float $rotatsA[] = `rot $DirecOfPointAB $DirNorm $Radian`;
    float $MultLengthDir[] = multiplyFloat($Length, $rotatsA);
    float $AddMultDirPos[] = AddFloats($PosA, $MultLengthDir);
    vector $DirecOfPointAB = FloatToVec ( DirectionF($PosA, $PosB));
    vector $DirNorm = FloatToVec ($DirNormAx);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $DirecOfPointAB = FloatToVec ( DirectionF($PosA, $PosB));
    $Length = distance2Pts ($PosA, $PosB);
    $DirecOfPointAB = FloatToVec ( multiplyFloat($PosOrNegOne, $DirecOfPointAB));
    $DirNorm = FloatToVec ($DirNormAx);
    $rotatsA = `rot $DirecOfPointAB $DirNorm $Radian`;
    $MultLengthDir = multiplyFloat($Length, $rotatsA);
    $AddMultDirPos = AddFloats($PosA, $MultLengthDir);
    return $AddMultDirPos;

}


/******************************************************************************
 * @procedure    ArcLengthArray
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Objs : string[]
 *
 * @returns      float []
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] ArcLengthArray(string $Objs[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $ArcLengths[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($each in $Objs){
    $ArcLengths[`size($ArcLengths)`]= `arclen $each`;
    }
    return $ArcLengths;

}


/******************************************************************************
 * @procedure    EulerAng
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $pointB1 : float[]
 *   $pointB2 : float[]
 *
 * @returns      float []
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] EulerAng(float $pointB1[], float $pointB2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $EulerAngleA[] = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $EulerAngleA = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
    return $EulerAngleA;

}


/******************************************************************************
 * @procedure    GetNearestINDEX
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Nn : int
 *   $index : string[]
 *   $pointA1 : float[]
 *   $objectListV : vector[]
 *
 * @returns      string []
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] GetNearestINDEX(int $Nn, string $index[], float $pointA1[], vector $objectListV[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iX = 0;
    float $distanceA[];
    float $NewfloatsX[];
    float $NewfloatsXi[] = ReverseFloatArray($NewfloatsX);
    string $EmptyStringX[];
    string $returnZi[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ($eachVecs in $objectListV){
    $distanceA[`size($distanceA)`] = distance2Pts( $pointA1 , $eachVecs);
    }
    clear $EmptyStringX;
    $NewfloatsX = SortFloatArrayAndString($distanceA, $index, $EmptyStringX);
    $EmptyStringX = ReverseStringArray($EmptyStringX);
    $NewfloatsXi = ReverseFloatArray($NewfloatsX);
    $iX = 0;
    while ($Nn > $iX){
    $returnZi[`size($returnZi)`] = $EmptyStringX[$iX];
    $iX++;
    }
    return $returnZi;

}


/******************************************************************************
 * @procedure    GetNearest
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $Nn : int
 *   $OneObject : string
 *   $diff : string[]
 *
 * @returns      string []
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] GetNearest(int $Nn, string $OneObject, string $diff[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Indx = 0;
    int $iX = 0;
    float $pointA1[];
    float $distanceA[];
    float $pointA2[];
    float $NewfloatsX[];
    float $NewfloatsXi[] = ReverseFloatArray($NewfloatsX);
    string $objectList[] = $diff;
    string $EmptyStringX[];
    string $returnZi[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $objectList = $diff;
    $pointA1 = `xform -query -worldSpace - translation ($OneObject)`;
    clear  $distanceA;
    $Indx = 0;
    for ($eachZx in $objectList){
    if (catch($pointA2 = `xform -q -ws -t $objectList[$Indx]`)){
    $pointA2 = `pointPosition -w $objectList[$Indx]`;
    }

    $Indx++;
    $dAx = $pointA1[0] - $pointA2[0];
    $dAy = $pointA1[1] - $pointA2[1];
    $dAz = $pointA1[2] - $pointA2[2];
    $distanceA[`size($distanceA)`] = `sqrt( ($dAx * $dAx) + ($dAy * $dAy)  + ($dAz * $dAz) )`;
    }


    clear $EmptyStringX;
    $NewfloatsX = SortFloatArrayAndString($distanceA, $objectList, $EmptyStringX);
    $EmptyStringX = ReverseStringArray($EmptyStringX);
    $NewfloatsXi = ReverseFloatArray($NewfloatsX);

    $iX = 0;
    while ($Nn > $iX){
    $returnZi[`size($returnZi)`] = $EmptyStringX[$iX];
    $iX++;
    }

    return $returnZi;

}


/******************************************************************************
 * @procedure    MostRightClockWise
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $ObjectList : string[]
 *   $Vecs : vector[]
 *   $Two : int[]
 *
 * @returns      string []
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] MostRightClockWise(string $ObjectList[], vector $Vecs[], int $Two[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $TwoNew[];
    float $point1[] = FloatToVec($Vecs[0]);
    float $point2[] = FloatToVec($Vecs[1]);
    float $point3[] = FloatToVec($Vecs[2]);
    float $normalA[] = `unit ($normalV[0])`;
    float $normalB[] = `unit ($normalV[1])`;
    float $normalAAdd = $normalA[0] + $normalA[1];
    float $normalAAdd2 = $normalB[0] + $normalB[1];
    string $ThreePoints[] = { "0", "1", "2"};
    string $ReturnObj[];
    vector $U1 = TwoVecsOrFloats($point2, $point1);
    vector $V1 = TwoVecsOrFloats($point3, $point1);
    vector $U2 = TwoVecsOrFloats($point3, $point1);
    vector $V2 = TwoVecsOrFloats($point2, $point1);
    vector $U3 = TwoVecsOrFloats($point1, $point3);
    vector $V3 = TwoVecsOrFloats($point2, $point3);
    vector $normalV[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $ThreePoints = { "0", "1", "2"};

    // Get the vector p1-p2, p3-p4
    // Get the vector  p3-p4
    //THREE POINTS get angel that is point 2 & 3 to point 1 (the V shape joining at first point)

    ///////////////////////////////////////////////////////////
    $point1 = FloatToVec($Vecs[0]);
    $point2 = FloatToVec($Vecs[1]);
    $point3 = FloatToVec($Vecs[2]);

    $U1 = TwoVecsOrFloats($point2, $point1);
    $V1 = TwoVecsOrFloats($point3, $point1);
    $U2 = TwoVecsOrFloats($point3, $point1);
    $V2 = TwoVecsOrFloats($point2, $point1);

    //vector $U2 = TwoVecsOrFloats($point3, $point2);
    //vector $V2 = TwoVecsOrFloats($point1, $point2);

    $U3 = TwoVecsOrFloats($point1, $point3);
    $V3 = TwoVecsOrFloats($point2, $point3);


    clear $normalV;
    $normalV[0] = FloatToVec( crossProduct( $U1, $V1, 0, 1 ) );
    $normalV[1] = FloatToVec( crossProduct( $U2, $V2, 0, 1 ) );

    //float $normal[] = `unit ($normalV[0])`;

    $normalA = `unit ($normalV[0])`;
    $normalB = `unit ($normalV[1])`;

    $normalAAdd = $normalA[0] + $normalA[1];
    $normalAAdd2 = $normalB[0] + $normalB[1];
    if( $normalAAdd< $normalAAdd2){
    //select -r $ObjectList[2];
    $TwoNew ={$Two[1], $Two[0]};
    $ReturnObj ={ $ObjectList[1], $ObjectList[0]};

    }else{
    //select -r $ObjectList[1];
    $TwoNew ={$Two[0], $Two[1]};
    $ReturnObj ={ $ObjectList[0], $ObjectList[1]};
    }

    $Two = $TwoNew;

    return $ReturnObj;

}


/******************************************************************************
 * @procedure    CirclesRadius
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $selectedObjects : string[]
 *
 * @returns      float
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float CirclesRadius(string $selectedObjects[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $FloatPointA[] = `pointPosition -w  $CurveSelectionA[0]`;
    float $worldPosA[];
    float $CircleRadiusA = getDistance($FloatPointA, $worldPosA);
    string $CurveSelectionA[] = `ls -fl ($selectedObjects[0]+".ep[0]")`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveSelectionA = `ls -fl ($selectedObjects[0]+".ep[0]")`;
    $FloatPointA = `pointPosition -w  $CurveSelectionA[0]`;
    $worldPosA = `xform -q -ws -a -rp $selectedObjects[0]`;
    $CircleRadiusA = getDistance($FloatPointA, $worldPosA);
    return $CircleRadiusA;

}


/******************************************************************************
 * @procedure    CirclesRadiusDirection
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $directionAB : vector[]
 *   $PosAB : vector[]
 *
 * @returns      float []
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] CirclesRadiusDirection(vector $directionAB[], vector $PosAB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $FloatPointa2[] = `pointPosition -w  $CurveSelection_a2[0]`;
    float $FloatPointb2[] = `pointPosition -w  $CurveSelection_b2[0]`;
    float $FloatPointA[] = `pointPosition -w  $CurveSelectionA[0]`;
    float $FloatPointB[] = `pointPosition -w  $CurveSelectionB[0]`;
    float $worldPosA[];
    float $CircleRadiusA = getDistance($FloatPointA, $worldPosA);
    float $worldPosB[];
    float $CirclesDistance = getDistance ($worldPosA, $worldPosB);
    float $FloatDirNormalCurveA[] = Normal3Points($worldPosA,$FloatPointa2,$FloatPointA);
    float $CircleRadiusB = getDistance ($FloatPointB, $worldPosB);
    float $RadiusAB[] = {$CircleRadiusA, $CircleRadiusB,$CirclesDistance};
    string $selectedObjects[];
    string $CurveSelectionA[] = `ls -fl ($selectedObjects[0]+".ep[0]")`;
    string $CurveSelection_a2[] = `ls -fl ($selectedObjects[0]+".ep[3]")`;
    string $CurveSelectionB[] = `ls -fl ($selectedObjects[1]+".ep[0]")`;
    string $CurveSelection_b2[] = `ls -fl ($selectedObjects[1]+".ep[3]")`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    clear $selectedObjects;
    $selectedObjects = `ls -sl`;
    $CurveSelectionA = `ls -fl ($selectedObjects[0]+".ep[0]")`;
    $CurveSelection_a2 = `ls -fl ($selectedObjects[0]+".ep[3]")`;

    $CurveSelectionB = `ls -fl ($selectedObjects[1]+".ep[0]")`;
    $CurveSelection_b2 = `ls -fl ($selectedObjects[1]+".ep[3]")`;

    $FloatPointa2 = `pointPosition -w  $CurveSelection_a2[0]`;

    $FloatPointb2 = `pointPosition -w  $CurveSelection_b2[0]`;
    $FloatPointA = `pointPosition -w  $CurveSelectionA[0]`;
    $FloatPointB = `pointPosition -w  $CurveSelectionB[0]`;

    $worldPosA = `xform -q -ws -a -rp $selectedObjects[0]`;
    $CircleRadiusA = getDistance($FloatPointA, $worldPosA);
    $worldPosB= `xform -q -ws -a -rp $selectedObjects[1]`;

    $directionAB[0] = FloatToVec (DirectionF($worldPosA,$worldPosB));
    $directionAB[1] = FloatToVec (DirectionF($worldPosB,$worldPosA));
    $PosAB[0] = FloatToVec ($worldPosA);
    $PosAB[1] = FloatToVec ($worldPosB);
    $CirclesDistance = getDistance ($worldPosA, $worldPosB);

    $FloatDirNormalCurveA = Normal3Points($worldPosA,$FloatPointa2,$FloatPointA);
    $directionAB[2] = FloatToVec ($FloatDirNormalCurveA);

    $CircleRadiusB = getDistance ($FloatPointB, $worldPosB);
    $RadiusAB = {$CircleRadiusA, $CircleRadiusB,$CirclesDistance};
    return $RadiusAB;

}


/******************************************************************************
 * @procedure    PointToCircleTangents
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $CircleRadiusA : float
 *   $worldPosA : float[]
 *   $worldPosB : float[]
 *   $FloatDirNormal : float[]
 *
 * @returns      vector []
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] PointToCircleTangents(float $CircleRadiusA, float $worldPosA[], float $worldPosB[], float $FloatDirNormal[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $R1 = $CircleRadiusA;
    float $P = distance2Pts ($worldPosA, $worldPosB);
    float $r1 = $R1;
    float $r1Z = $R1*2;
    float $Pi = 3.1415926535;
    float $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1Z 2.000`) - (`pow $P 2.000`) )/(2.000*$P*$r1Z)));
    float $AngleNPi = ($Arcangle*180)/$Pi;
    float $AngleN = $AngleNPi;
    float $MultDirPC1[] = multiplyFloat($r1, $directionABs[0]);
    float $AddMultDirPCA1[] = AddFloats($worldPosA, $MultDirPC1);
    float $tsDAR = ( $AngleN)*-1;
    float $tsDBR = ( $AngleN)*1;
    float $rotatsA[] = `rot $directionABs[0] $FloatDirNormal $tsDAR`;
    float $rotatsB[] = `rot $directionABs[0] $FloatDirNormal $tsDBR`;
    float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
    float $AddMultDirPCA2[] = AddFloats($worldPosA, $MultDirPC2);
    vector $directionABs[];
    vector $pointsT[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $R1 = $CircleRadiusA;

    $directionABs[0] = FloatToVec (DirectionF($worldPosA,$worldPosB));
    $directionABs[1] = FloatToVec (DirectionF($worldPosB,$worldPosA));

    // P is the distance between 2 circles
    $P = distance2Pts ($worldPosA, $worldPosB);
    $r1 = $R1;
    $r1Z = $R1*2;
    //HightsOfIsoscelesTriangle($P, $r1Z, $P);
    $Pi = 3.1415926535;
    $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1Z 2.000`) - (`pow $P 2.000`) )/(2.000*$P*$r1Z)));
    $AngleNPi = ($Arcangle*180)/$Pi;
    $AngleN = $AngleNPi;
    //float $ts = atand( (`abs ($r1 - $r2)`) /$P);
    $MultDirPC1 = multiplyFloat($r1, $directionABs[0]);
    $AddMultDirPCA1 = AddFloats($worldPosA, $MultDirPC1);

    $AngleN = $Arcangle;
    $tsDAR = ( $AngleN)*-1;
    $tsDBR = ( $AngleN)*1;
    //The first argument represents a point, the second an axis and the third an angle in radians
    $rotatsA = `rot $directionABs[0] $FloatDirNormal $tsDAR`;
    $MultDirPC1 = multiplyFloat($r1, $rotatsA);
    $AddMultDirPCA1 = AddFloats($worldPosA, $MultDirPC1);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA1);
    $rotatsB = `rot $directionABs[0] $FloatDirNormal $tsDBR`;
    $MultDirPC2 = multiplyFloat($r1, $rotatsB);
    $AddMultDirPCA2 = AddFloats($worldPosA, $MultDirPC2);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA2);

    $pointsT[0] = FloatToVec ($AddMultDirPCA1);
    $pointsT[1] = FloatToVec ($AddMultDirPCA2);
    return $pointsT;

}


/******************************************************************************
 * @procedure    TangentPointCirVectors
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $ObjsCirclesRad : float[]
 *   $PosABs : vector[]
 *   $directionABs2 : vector[]
 *
 * @returns      vector []
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] TangentPointCirVectors(float $ObjsCirclesRad[], vector $PosABs[], vector $directionABs2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $R1 = $ObjsCirclesRad[0];
    float $R2 = $ObjsCirclesRad[1];
    float $P = distance2Pts ($PosABs[0], $PosABs[1]);
    float $r1 = $R1;
    float $r2 = $R2;
    float $Pi = 3.1415926535;
    float $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1)));
    float $AngleNPi = ($Arcangle*180)/$Pi;
    float $AngleN = $AngleNPi;
    float $Lengths[] = HightsOfIsoscelesTriangle($P, $r1, $r2);
    float $MultDirPCR1[] = multiplyFloat($r1, $directionABs[0]);
    float $AddMultDirPCR1[] = AddFloats($PosABs[0], $MultDirPCR1);
    float $MultDirPCR2[] = multiplyFloat($r2, $directionABs[1]);
    float $AddMultDirPCR2[] = AddFloats($PosABs[1], $MultDirPCR2);
    float $MidPointsA[];
    float $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
    float $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
    float $tsDAR = ( $AngleN)*-1;
    float $tsDBR = ( $AngleN)*1;
    float $rotatsA[] = `rot $directionABs[0] $directionABs2[0] $tsDAR`;
    float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
    float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
    float $rotatsB[] = `rot $directionABs[0] $directionABs2[0] $tsDBR`;
    float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
    float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
    vector $CircIntersectABs[];
    vector $directionABs[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $R1 = $ObjsCirclesRad[0];
    $R2 = $ObjsCirclesRad[1];
    // P is the distance between 2 circles
    $P = distance2Pts ($PosABs[0], $PosABs[1]);
    $directionABs[0] = FloatToVec (DirectionF($PosABs[0],$PosABs[1]));
    $directionABs[1] = FloatToVec (DirectionF($PosABs[1],$PosABs[0]));
    $r1 = $R1;
    $r2 = $R2;
    $Pi = 3.1415926535;
    $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1)));
    $AngleNPi = ($Arcangle*180)/$Pi;
    $AngleN = $AngleNPi;
    $Lengths = HightsOfIsoscelesTriangle($P, $r1, $r2);
    $MultDirPCR1 = multiplyFloat($r1, $directionABs[0]);
    $AddMultDirPCR1 = AddFloats($PosABs[0], $MultDirPCR1);
    $MultDirPCR2 = multiplyFloat($r2, $directionABs[1]);
    $AddMultDirPCR2 = AddFloats($PosABs[1], $MultDirPCR2);
    $MidPointsA = MidPoint($AddMultDirPCR1, $AddMultDirPCR2);
    $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
    $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
    ////////////////////////////////////////////////
    ////////////////////////////////////////////////
    $AngleN = $Arcangle;
    $tsDAR = ( $AngleN)*-1;
    $tsDBR = ( $AngleN)*1;
    //The first argument represents a point, the second an axis and the third an angle in radians
    //the normal $directionABs[2]
    $rotatsA = `rot $directionABs[0] $directionABs2[0] $tsDAR`;
    $MultDirPC1 = multiplyFloat($r1, $rotatsA);
    $AddMultDirPCA1 = AddFloats($PosABs[0], $MultDirPC1);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA1);
    $rotatsB = `rot $directionABs[0] $directionABs2[0] $tsDBR`;
    $MultDirPC2 = multiplyFloat($r1, $rotatsB);
    $AddMultDirPCA2 = AddFloats($PosABs[0], $MultDirPC2);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA2);

    $CircIntersectABs[0] = << $AddMultDirPCA1[0], $AddMultDirPCA1[1], $AddMultDirPCA1[2] >>;
    $CircIntersectABs[1] = << $AddMultDirPCA2[0], $AddMultDirPCA2[1], $AddMultDirPCA2[2] >>;
    return $CircIntersectABs;

}


/******************************************************************************
 * @procedure    TangentPointCirclesVec2
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 *
 * @returns      vector []
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] TangentPointCirclesVec2()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
    float $R1 = $ObjsCircles[0];
    float $R2 = $ObjsCircles[1];
    float $P = distance2Pts ($PosABs[0], $PosABs[1]);
    float $r1 = $R1;
    float $r2 = $R2;
    float $Pi = 3.1415926535;
    float $Arcangle = acos ((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1)));
    float $AngleNPi = ($Arcangle*180)/$Pi;
    float $AngleN = $AngleNPi;
    float $Lengths[] = HightsOfIsoscelesTriangle($P, $r1, $r2);
    float $MultDirPCR1[] = multiplyFloat($r1, $directionABs[0]);
    float $AddMultDirPCR1[] = AddFloats($PosABs[0], $MultDirPCR1);
    float $MultDirPCR2[] = multiplyFloat($r2, $directionABs[1]);
    float $AddMultDirPCR2[] = AddFloats($PosABs[1], $MultDirPCR2);
    float $MidPointsA[];
    float $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
    float $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
    float $tsDAR = ( $AngleN)*-1;
    float $tsDBR = ( $AngleN)*1;
    float $rotatsA[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
    float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
    float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
    float $rotatsB[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
    float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
    float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
    vector $CircIntersectABs[];
    vector $directionABs[];
    vector $PosABs[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    ResetTransEachSL;
    $ObjsCircles = CirclesRadiusDirection($directionABs, $PosABs);
    $R1 = $ObjsCircles[0];
    $R2 = $ObjsCircles[1];
    // P is the distance between 2 circles

    $P = distance2Pts ($PosABs[0], $PosABs[1]);
    $r1 = $R1;
    $r2 = $R2;
    $Pi = 3.1415926535;
    $Arcangle = acos ((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1))) ;
    $AngleNPi = ($Arcangle*180)/$Pi;
    $AngleN = $AngleNPi;
    $Lengths = HightsOfIsoscelesTriangle($P, $r1, $r2);
    $MultDirPCR1 = multiplyFloat($r1, $directionABs[0]);
    $AddMultDirPCR1 = AddFloats($PosABs[0], $MultDirPCR1);
    $MultDirPCR2 = multiplyFloat($r2, $directionABs[1]);
    $AddMultDirPCR2 = AddFloats($PosABs[1], $MultDirPCR2);
    $MidPointsA = MidPoint($AddMultDirPCR1, $AddMultDirPCR2);
    $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
    $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
    ////////////////////////////////////////////////
    ////////////////////////////////////////////////
    $AngleN = $Arcangle;
    $tsDAR = ( $AngleN)*-1;
    $tsDBR = ( $AngleN)*1;
    //The first argument represents a point, the second an axis and the third an angle in radians
    //the normal $directionABs[2]
    $rotatsA = `rot $directionABs[0] $directionABs[2] $tsDAR`;
    $MultDirPC1 = multiplyFloat($r1, $rotatsA);
    $AddMultDirPCA1 = AddFloats($PosABs[0], $MultDirPC1);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA1);
    $rotatsB = `rot $directionABs[0] $directionABs[2] $tsDBR`;
    $MultDirPC2 = multiplyFloat($r1, $rotatsB);
    $AddMultDirPCA2 = AddFloats($PosABs[0], $MultDirPC2);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA2);

    $CircIntersectABs[0] = << $AddMultDirPCA1[0], $AddMultDirPCA1[1], $AddMultDirPCA1[2] >>;
    $CircIntersectABs[1] = << $AddMultDirPCA2[0], $AddMultDirPCA2[1], $AddMultDirPCA2[2] >>;
    return $CircIntersectABs;

}


/******************************************************************************
 * @procedure    EulerAngleofCurve
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 *
 * @returns      float[]
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] EulerAngleofCurve()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    int $Z = FindclosetTOcurveENDz($pointB1,  $pointB2, $vector_SubUnitMagVec2);
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $pointCVAB_MidPoint[] = MidPointBetween ($EACHCVposHigher, $EACHCVposLower);
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $curveArclenZ = `arclen $CurveItem`;
    float $DivideIt = $curveArclenZ / 2.0;
    float $DivideIt2 = $DivideIt * -1;
    float $pointB1[] = {0.0 , 0.0 , $DivideIt};
    float $pointB2[] = {0.0 , 0.0 , $DivideIt2};
    float $EulerAngleA[] = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2   $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2 [1] $vector_SubUnitMagVec2[2]`;
    float $EulerAngleB[] = `angleBetween -euler -v1  $pointB2[0] $pointB2[1] $pointB2[2] -v2  $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1 [1] $vector_SubUnitMagVec1[2]`;
    string $CurveItem[];
    string $CurveSelection[];
    vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher,  $pointCVAB_MidPoint);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposLower,  $pointCVAB_MidPoint);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveItem = `ls -sl`;
    $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA   )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    if ( $MagVectorZ1 > $MagVectorZ2 ){
    print (" posA is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposAZ;
    $EACHCVposLower = $EACHCVposBZ;
    }
    if ( $MagVectorZ1 < $MagVectorZ2  ){
    print (" posB is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    }
    $pointCVAB_MidPoint = MidPointBetween ($EACHCVposHigher, $EACHCVposLower);
    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher,  $pointCVAB_MidPoint);
    $vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]);
    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposLower,  $pointCVAB_MidPoint);
    $vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]);
    ///////////////////////////////////////////////// ////
    $curveArclenZ = `arclen $CurveItem`;
    $DivideIt = $curveArclenZ / 2.0;
    $DivideIt2 = $DivideIt * -1;
    $pointB1 = {0.0 , 0.0 , $DivideIt} ;
    $pointB2 = {0.0 , 0.0 , $DivideIt2} ;
    /// NOTE curve ENds will not allways Line up and  may be inverted
    //let $F1 be the first CV $F2 the last .. $F3  third point
    $Z = FindclosetTOcurveENDz($pointB1,  $pointB2, $vector_SubUnitMagVec2);
    if ($Z == 1){ print "new floats"; $pointB1 =  $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
    $EulerAngleA = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2   $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2 [1] $vector_SubUnitMagVec2[2]`;
    $EulerAngleB = `angleBetween -euler -v1  $pointB2[0] $pointB2[1] $pointB2[2] -v2  $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1 [1] $vector_SubUnitMagVec1[2]`;

    return $EulerAngleA;

}


/******************************************************************************
 * @procedure    dist3D_Line_to_Line
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $L1 : Line
 *   $L2 : Line
 *
 * @returns      float
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float dist3D_Line_to_Line(Line $L1, Line $L2)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $SMALL_NUM = 0.00000001;
    float $a = dot($u,$u);
    float $b = dot($u,$v);
    float $c = dot($v,$v);
    float $d = dot($u,$w);
    float $e = dot($v,$w);
    float $D = $a*$c - $b*$b;
    float $XX = ($sc)-($tc);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $SMALL_NUM = 0.00000001;

    Vector   $u = L1.P1 - L1.P0;
    Vector   $v = L2.P1 - L2.P0;
    Vector   $w = L1.P0 - L2.P0;

    $a = dot($u,$u);
    $b = dot($u,$v);
    $c = dot($v,$v);
    $d = dot($u,$w);
    $e = dot($v,$w);
    $D = $a*$c - $b*$b;

    // compute the line parameters of the two closest points
    if ($D < $SMALL_NUM) {         // the lines are almost parallel
    $sc = 0.0;
    $tc = ($b>$c ? $d/$b : $e/$c);   // use the largest denominator
    }
    else {
    $sc = ($b*$e - $c*$d) / $D;
    $tc = ($a*$e - $b*$d) / $D;
    }

    // get the difference of the two closest points
    = $w + ($sc * $u) - ($tc * $v);  // = $L1($sc) - $L2($tc)

    sqrt(`dot $u $u` )

    $XX = ($sc)-($tc);


    return norm($dP);   // return the closest distance

}


/******************************************************************************
 * @procedure    CirclesRadiiPos
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $CirObjects : string[]
 *   $PosAB : vector[]
 *
 * @returns      float []
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] CirclesRadiiPos(string $CirObjects[], vector $PosAB[])
{



    for ($each in $CirObjects){
    $PointA= `ls -fl ($each+".ep[0]")`;
    $PointB = `ls -fl ($each+".ep[3]")`;
    $FloatPointA = `pointPosition -w  $PointA`;
    $FloatPointB = `pointPosition -w  $PointB`;
    $worldPosA = `xform -q -ws -a -rp $each`;
    $CircleRadii[`size($CircleRadii)`] = distance2Pts ($FloatPointA,$worldPosA) ;
    $PosAB[`size($PosAB)`]= FloatToVec ($worldPosA);
    }
    return $CircleRadii;

}


/******************************************************************************
 * @procedure    CircNormal
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $eachCirV : string
 *
 * @returns      float []
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] CircNormal(string $eachCirV)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $FloatDirNormalCurveA[] = Normal3Points($worldPosA, $FloatPointA, $FloatPointB);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $PointA = `ls -fl ($eachCirV+".ep[0]")`;
    $PointB = `ls -fl ($eachCirV+".ep[3]")`;
    $FloatPointA = `pointPosition -w  $PointA `;
    $FloatPointB = `pointPosition -w  $PointB`;
    $worldPosA = `xform -q -ws -a -rp $eachCirV`;
    $FloatDirNormalCurveA = Normal3Points($worldPosA, $FloatPointA, $FloatPointB);
    return $FloatDirNormalCurveA;

}


/******************************************************************************
 * @procedure    TotalArcLength
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 *
 * @returns      float
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float TotalArcLength()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $ArcLengths = 0.0;
    string $Objs[] = `ls -sl`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Objs = `ls -sl`;
    $ArcLengths = 0.0;
    for($each in $Objs){
    $ArcLengths += `arclen $each`;
    }
    return $ArcLengths;

}


/******************************************************************************
 * @procedure    HightsOfIsoscelesTriangle
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $SideA : float
 *   $SideB : float
 *   $SideC : float
 *
 * @returns      float []
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] HightsOfIsoscelesTriangle(float $SideA, float $SideB, float $SideC)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Pi = 3.1415926535;
    float $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
    float $AngleNPi = ($Arcangle*180)/$Pi;
    float $AngleN = $AngleNPi;
    float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
    float $ArcangleC2 = $ArcangleC*2.0;
    float $AngleNB = 180.00 -($ArcangleC2 + $AngleNPi);
    float $Angle_a = $ArcangleC2;
    float $Angle_b = $AngleN;
    float $Angle_c = $AngleNB;
    float $AngleN2 = 180.0 -($Angle_b + $Angle_c);
    float $Angle_A = $AngleN2;
    float $Angle_B = $AngleN;
    float $Angle_C = $AngleN;
    float $AngleOfRightAndA = (180.000 -($AngleN2 +90.000));
    float $AngleOfRightA = ($AngleOfRightAndA/180.000)*$Pi;
    float $AngleN2R = ($AngleN2/180.0000)*$Pi;
    float $HightfromB = sqrt ( ((`pow $SideA 2.000`) + (`pow $SideC 2.000`)) - ((2.000*$SideA*$SideC)*(`cos($AngleN2R+$AngleN2R )`)) )/2.000;
    float $HightfromC = sqrt ( ((`pow $SideA 2.000`) + (`pow $SideC 2.000`)) - ((2.000*$SideA*$SideC)*(`cos ($AngleOfRightA*2.000 )`)) )/2.000;
    float $HightsCandB[] = { $HightfromC, $HightfromB};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $Pi = 3.1415926535;
    $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
    $AngleNPi = ($Arcangle*180)/$Pi;
    $AngleN = $AngleNPi;
    print $AngleN;
    print "//";

    $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
    $ArcangleC2 = $ArcangleC*2.0;
    print $ArcangleC2;
    $AngleNB = 180.00 -($ArcangleC2 + $AngleNPi) ;
    $Angle_a = $ArcangleC2;
    $Angle_b = $AngleN;
    $Angle_c = $AngleNB;

    $AngleN2 = 180.0 -($Angle_b + $Angle_c) ;
    //Two are the same//
    $Angle_A = $AngleN2;
    $Angle_B = $AngleN;
    $Angle_C = $AngleN;
    //Angle of Right Tri in Isoceles
    $AngleOfRightAndA = (180.000 -($AngleN2 +90.000));
    $AngleOfRightA = ($AngleOfRightAndA/180.000)*$Pi;
    $AngleN2R = ($AngleN2/180.0000)*$Pi;
    $HightfromB = sqrt ( ((`pow $SideA 2.000`) + (`pow $SideC 2.000`)) - ((2.000*$SideA*$SideC)*(`cos($AngleN2R+$AngleN2R )`)) )/2.000 ;
    $AngleOfRightA = ($AngleOfRightAndA/180.0000)*$Pi;
    $HightfromC = sqrt ( ((`pow $SideA 2.000`) + (`pow $SideC 2.000`)) - ((2.000*$SideA*$SideC)*(`cos ($AngleOfRightA*2.000 )`)) )/2.000 ;
    $HightsCandB = { $HightfromC, $HightfromB};
    return $HightsCandB;


}


/******************************************************************************
 * @procedure    SteinerChain
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $RAa : float
 *   $RBb : float
 *
 * @returns      string []
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] SteinerChain(float $RAa, float $RBb)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $NumberCs = $number3;
    int $n = $NumberCs;
    int $i;
    float $pi = 3.1415926535;
    float $Pi = 3.1415926535;
    float $RA;
    float $RB;
    float $R2 = $RA;
    float $R1 = $RB;
    float $DCircle = (($R2 - $R1)/2.0) + $R1;
    float $Rii = (($R2 - $R1)/2.0);
    float $SideA = $RB + $Rii;
    float $SideB = $Rii*2;
    float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    float $ArcangleC2 = $ArcangleC*2.0;
    float $Aii = (`asin ($RB/($RB + $Rii))`);
    float $number3 = 360.0/$ArcangleC2;
    float $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
    float $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    float $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    float $NofCirclesa = (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
    float $NofCirclesb = ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
    float $NofCirclesc = ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);
    float $dec = 1;
    float $val = $subtract*0.1;
    float $len = $DCircle;
    float $r = $DCircle;
    float $x[] = createRegularPolygonX( $n, $r );
    float $y[] = createRegularPolygonY( $n, $r );
    float $z = 0.0;
    string $circleA[];
    string $circleB[];
    string $circles[];
    string $circlesC[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //
    //float $RA = 22.0;
    //float $RB = 15.680;

    $pi = 3.1415926535;
    $Pi = 3.1415926535;



    if(!( $RAa==$RBb)){
    if( $RAa<$RBb){
    $RA = $RBb;
    $RB = $RAa;}else{ $RA = $RAa; $RB =  $RBb;}

    //float $RA = 22.0;
    //float $RB = 15.68;



    $circleA = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RA -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $circleB = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RB -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $R2 = $RA;
    $R1 = $RB;
    $DCircle = (($R2 - $R1)/2.0) + $R1 ;
    $Rii = (($R2 - $R1)/2.0);

    $SideA = $RB + $Rii;
    $SideB = $Rii*2;

    //GOT it for SURE
    //HightsOfIsoscelesTriangle($SideA, $SideB, $SideA)
    $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    $ArcangleC2 = $ArcangleC*2.0;

    $Aii = (`asin ($RB/($RB + $Rii))`);
    //float $Ni = $pi/$Aii;
    //  $Ni = (rad_to_deg($Aii)) ;


    $number3 = 360.0/$ArcangleC2;

    $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
    $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );

    $NofCirclesa = (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
    $NofCirclesb = ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
    $NofCirclesc = ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);

    //float $subtract = ($NofCirclesa -($NofCirclesb + $NofCirclesc))*4;
    //float $subtract = $NofCirclesB - $NofCirclesA;
    //float $subtract = ($subtract + $NofCirclesC)/2;
    //float $subtractA = (($NofCirclesB - $NofCirclesA)+ $NofCirclesC)/2;
    //float $subtractB = ($NofCirclesA - $NofCirclesC+$NofCirclesB)/2;
    //float $number3 = 360/$NofCirclesC;
    //
    //float $Ni = (rad_to_deg($subtract)) ;
    //float $Ni = $pi/ $subtract;
    //float $number3 = 360/$Ni;
    //$number3 = $subtract;

    //float $subtract = ($NofCirclesA - $NofCirclesC+$NofCirclesB)/2;
    /*
    $dec = 1;
    $val = $subtract*0.1;
    $sign = `sign $val`;
    $dec = `pow 10 $dec`;
    $val = (int) (($val + $sign*5/($dec*10))  * $dec);
    $val = ($val / $dec);
    $val = $val*10;
    $subtract = $val;
    //float $subtract = ($NofCirclesA - $NofCirclesC+$NofCirclesB)/2;
    */
    $NumberCs = $number3;
    $n = $NumberCs;
    $len = $DCircle;
    $r = $DCircle;
    $x = createRegularPolygonX( $n, $r ) ;
    $y = createRegularPolygonY( $n, $r ) ;
    // create the n-sided polygon.
    $z = 0.0 ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $circlesC = `circle -c $x[$i] $y[$i] $z -nr 0 0 1 -sw 360 -r $Rii -d 3 -ut 0 -tol 0.001 -s 16 -ch 1`;

    $circles[`size($circles)`] = $circlesC[0];
    makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $circles[0];
    xform -cp $circles[0];
    //rotate -r -os 0 0 45 $circles[0];
    //aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "scene" $circleB[0] $circles[0];

    }


    //$circles[`size($circles)`] = $circleA[0];
    //$circles[`size($circles)`] = $circleB[0];

    select -r $circleA $circleB $circles ;
    //select -r $circles ;
    return $circles;
    }

}


/******************************************************************************
 * @procedure    CycleNumberString
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $singleStringItemC : string[]
 *
 * @returns      string[]
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CycleNumberString(string $singleStringItemC[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArray;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArray = size($singleStringItemC) -1;
    string $last[0] = {$singleStringItemC [$SizeOfArray]};
    string $first[0] = {$singleStringItemC[0]};
    stringArrayRemoveAtIndex(0,  $singleStringItemC);
    appendStringArray($singleStringItemC, $first,  1);
    return $singleStringItemC;

}


/******************************************************************************
 * @procedure    round
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $val : float
 *   $dec : float
 *
 * @returns      float
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float round(float $val, float $dec)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Xn = 5;
    int $Dn = $dec;
    int $Dn2 = $dec;
    float $divideAs = $val/2;
    float $divideA = $val/5;
    float $divideB = $val/10;
    float $divideC = $val/100;
    float $divideD = $val/1000;
    float $dec = `pow 10 $dec`;
    float $divide = $val/$Xn;
    float $val2 = $divide;
    float $dec2 = $Dn2;
    float $times = $val2 * $Xn;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Xn = 5;
    //float $dec = 0;
    //float $val = 42.02;
    $Dn = $dec;
    $Dn2 = $dec;
    $divideAs = $val/2;
    $divideA = $val/5;
    $divideB = $val/10;
    $divideC = $val/100;
    $divideD = $val/1000;
    if ($divideAs < 1) { $Xn = 1; $Dn = 2; $Dn2 = 1; }
    if (($divideAs > 1) && ($divideA < 1)) { $Xn = 1; $Dn = 2; $Dn2 = 1;}
    if (($divideA > 1) && ($divideB < 1)) { $Xn = 5; }
    if (($divideB > 1) && ($divideC < 1)) { $Xn = 10; }
    if (($divideC > 1) && ($divideD < 1)) { $Xn = 50; }
    //print ($Xn + "\n");
    $dec = $Dn;
    $sign = `sign $val`;
    $dec = `pow 10 $dec`;
    $val = (int) (($val + $sign*5/($dec*10)) * $dec);
    $val = ($val / $dec);

    $divide = $val/$Xn;
    $val2 = $divide;
    $dec2 = $Dn2;
    $sign2 = `sign $val2`;
    $dec2 = `pow 10 $dec2`;
    $val2 = (int) (($val2 + $sign*5/($dec2*10)) * $dec2);
    $val2 = ($val2 / $dec2);
    $times = $val2 * $Xn;

    return $times;

}


/******************************************************************************
 * @procedure    createRegularPolygonY
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $n : int
 *   $r : float
 *
 * @returns      float[]
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] createRegularPolygonY(int $n, float $r)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    float $x[];
    float $angle = 360.0 / $n;
    float $a = $i * $angle;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $angle = 360.0 / $n ;

    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * cos(deg_to_rad($a)) ;
    }
    return $x ;

}


/******************************************************************************
 * @procedure    createRegularPolygonX
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $n : int
 *   $r : float
 *
 * @returns      float[]
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] createRegularPolygonX(int $n, float $r)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    float $x[];
    float $angle = 360.0 / $n;
    float $a = $i * $angle;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * sin(deg_to_rad($a)) ;
    }
    return $x ;

}


/******************************************************************************
 * @procedure    stringArrayGmatchToArray
 * @category     linear-algebra
 * @layer        affine (GL(4,R))
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      string[]
 * @source       working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] stringArrayGmatchToArray(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $listItem;
    string $MatchedItem[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    for ($listItem in $list) {
    if ( `gmatch $listItem $item` == 1){
    $result = true;
    if ($result == true ){ $MatchedItem = {$listItem};}
    break;	}
    }
    return $MatchedItem;

}

