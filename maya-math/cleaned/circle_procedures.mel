/******************************************************************************
 * CIRCLE PROCEDURES - CLEANED MEL PROCEDURES
 *
 * Category:    circle-procedures
 * Layer:       utility (General)
 * Description: General Maya utilities and helpers
 * Procedures:  176
 *
 * All variable declarations moved to procedure start.
 * Generated by cleanup_mel_v2.py
 ******************************************************************************/


/******************************************************************************
 * @procedure    curve2points
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $TanEnd1 : float[]
 *   $intersectposD1 : float[]
 *
 * @returns      string
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string curve2points(float $TanEnd1[], float $intersectposD1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $RDistAB = RoundFloat($CircleDistanceAB, 0.0);
    int $RDistM1 = RoundFloat($CircleDistanceAM1, 0.0);
    float $CircleDistanceAB = `getDistance $TanEnd1 $intersectposD1`;
    float $MiddlePoint1[] = MidPoint($TanEnd1, $intersectposD1);
    float $CircleDistanceAM1 = `getDistance $TanEnd1 $MiddlePoint1`;
    float $MiddlePointA1[] = MidPoint($TanEnd1, $MiddlePoint1);
    float $MiddlePointB1[] = MidPoint($MiddlePoint1, $intersectposD1);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $CircleDistanceAB = `getDistance $TanEnd1 $intersectposD1`;
    $RDistAB = RoundFloat($CircleDistanceAB, 0.0);

    $MiddlePoint1 = MidPoint($TanEnd1, $intersectposD1);
    $CircleDistanceAM1 = `getDistance $TanEnd1 $MiddlePoint1`;
    $RDistM1 = RoundFloat($CircleDistanceAM1, 0.0);

    $MiddlePointA1 = MidPoint($TanEnd1, $MiddlePoint1);
    $MiddlePointB1 = MidPoint($MiddlePoint1, $intersectposD1);

    -p $TanEnd1[0] $TanEnd1[1] $TanEnd1[2]
    -p $MiddlePointA1[0] $MiddlePointA1[1] $MiddlePointA1[2]
    -p $MiddlePoint1[0] $MiddlePoint1[1] $MiddlePoint1[2]
    -p $MiddlePointB1[0] $MiddlePointB1[1] $MiddlePointB1[2]
    -p $intersectposD1[0] $intersectposD1[1] $intersectposD1[2]  -k 0 -k 0 -k 0 -k $RDistM1 -k $RDistAB -k $RDistAB -k $RDistAB` ;
    return $CurveMade;

}


/******************************************************************************
 * @procedure    ClosestPOS
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $mySurf : string
 *   $toObject : string
 *
 * @returns      string
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string ClosestPOS(string $mySurf, string $toObject)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $Locator[] = `spaceLocator`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $myCPOC = `createNode closestPointOnMesh`;
    makeIdentity -apply true -t 0 -r 0 -s 1 -n 0 $mySurf;
    connectAttr ($mySurf+".worldMesh") ($myCPOC+".inMesh");
    $Locator = `spaceLocator`;
    connectAttr ($myCPOC+".position") ($Locator[0]+".translate");
    connectAttr ($toObject+".translate") ($myCPOC+".inPosition");
    select -r $toObject;
    return $myCPOC;

}


/******************************************************************************
 * @procedure    ClosestPOC
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $myCurve : string
 *   $toObject : string
 *
 * @returns      string
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string ClosestPOC(string $myCurve, string $toObject)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $Locator[] = `spaceLocator`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $myCPOC = `createNode closestPointOnCurve`;
    connectAttr ($myCurve+".worldSpace") ($myCPOC+".inCurve");
    $Locator = `spaceLocator`;
    connectAttr ($myCPOC+".position") ($Locator[0]+".translate");
    connectAttr ($toObject+".translate") ($myCPOC+".inPosition");
    return $Locator[0];

}


/******************************************************************************
 * @procedure    DirectionF
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $EACHCVposAZ : float[]
 *   $EACHCVposBZ : float[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] DirectionF(float $EACHCVposAZ[], float $EACHCVposBZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $UnitDirection[] = $vectorUnit;
    vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;

    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]);

    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]);

    $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
    $UnitDirection = $vectorUnit;
    ///////////////////////////////////////////////// ////
    return $UnitDirection;

}


/******************************************************************************
 * @procedure    DirectionFString
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $twoItem : string[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] DirectionFString(string $twoItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numIntZB = 0;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $UnitDirection[] = $vectorUnit;
    string $twoItem[];
    vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numIntZB = 0;
    for ($eachZA in $twoItem) {
    $eachCVpos = `pointPosition -w ( $eachZA   )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;

    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]);
    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]);
    $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
    $UnitDirection = $vectorUnit;
    ///////////////////////////////////////////////// ////
    return $UnitDirection;

}


/******************************************************************************
 * @procedure    DirectionTwoPoints
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $EACHCVposAZ : float[]
 *   $EACHCVposBZ : float[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] DirectionTwoPoints(float $EACHCVposAZ[], float $EACHCVposBZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $UnitDirection[] = $vectorUnit;
    string $CurveItem[];
    vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]);
    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]);
    $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
    $UnitDirection = $vectorUnit;
    ///////////////////////////////////////////////// ////
    return $UnitDirection;

}


/******************************************************************************
 * @procedure    DirectionFromFirst2SecondPoint
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] DirectionFromFirst2SecondPoint()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numIntZB = 0;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $UnitDirection[] = $vectorUnit;
    string $CurveItem[];
    vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $twoItem = `ls -sl -fl`;

    $numIntZB = 0;
    for ($eachZA in $twoItem) {
    $eachCVpos = `pointPosition -w ( $eachZA   )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }

    $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;

    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]);

    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]);

    $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
    $UnitDirection = $vectorUnit;
    ///////////////////////////////////////////////// ////
    return $UnitDirection;

}


/******************************************************************************
 * @procedure    getCurveLength
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $curve : string
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float getCurveLength(string $curve)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $curveLength = `getAttr ( $arcLenNode + ".arcLength" )`;
    string $arcLenNode = `createNode arcLengthDimension`;
    string $parent[] = `listRelatives -p $arcLenNode`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $arcLenNode = `createNode arcLengthDimension`;
    connectAttr -f ( $curve + ".worldSpace[0]" ) ( $arcLenNode + ".nurbsGeometry" );
    setAttr ( $arcLenNode + ".uParamValue" ) `getAttr ( $curve + ".maxValue" )`;
    $curveLength = `getAttr ( $arcLenNode + ".arcLength" )`;
    $parent = `listRelatives -p $arcLenNode`;
    //delete $parent;
    return $curveLength;

}


/******************************************************************************
 * @procedure    getpositions
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $objectlist : string[]
 *
 * @returns      vector[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] getpositions(string $objectlist[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iX = 0;
    string $objectlistF[] = `ls -fl $objectlist`;
    vector $pointsV[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $objectlistF = `ls -fl $objectlist`;
    $iX = 0;
    for ($each in $objectlistF){
    if (catch($pointsV[$iX] = `pointPosition -w  $each`)){
    $pointsV[$iX] = `xform -q -ws - rp $each`;
    }
    $iX++;
    }
    return $pointsV;

}


/******************************************************************************
 * @procedure    Matrix4ToFloat
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $m : matrix[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] Matrix4ToFloat(matrix $m[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MatrixPoints[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MatrixPoints = {($m[0][0]), ($m[0][1]), ($m[0][2]), ($m[0][3]),
    ($m[1][0]), ($m[1][1]), ($m[1][2]), ($m[1][3]),
    ($m[2][0]), ($m[2][1]), ($m[2][2]), ($m[2][3]),
    ($m[3][0]), ($m[3][1]), ($m[3][2]), ($m[3][3])};
    return $MatrixPoints;

}


/******************************************************************************
 * @procedure    linearToInternal
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $linear : float
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float linearToInternal(float $linear)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $factor = 1.0;
    string $pref = `currentUnit -q -l`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $factor = 1.0;
    $pref = `currentUnit -q -l`;
    if ( "mm" == $pref ) $factor = 0.1;
    if ( "m" == $pref ) $factor = 100.0;
    if ( "inch" == $pref ) $factor = 2.54;
    if ( "ft" == $pref ) $factor = 30.48;
    if ( "yard" == $pref ) $factor = 91.44;

    return ( $linear * $factor );

}


/******************************************************************************
 * @procedure    linear_to_internal
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $linear : float
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float linear_to_internal(float $linear)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $factor = 1.0;
    string $pref = `currentUnit -q -l`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $factor = 1.0;
    $pref = `currentUnit -q -l`;
    if ( "mm" == $pref ) $factor = 0.1;
    if ( "m" == $pref ) $factor = 100.0;
    if ( "inch" == $pref ) $factor = 2.54;
    if ( "ft" == $pref ) $factor = 30.48;
    if ( "yard" == $pref ) $factor = 91.44;

    return ( $linear * $factor );

}


/******************************************************************************
 * @procedure    linear_to_ui
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $linear : float
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float linear_to_ui(float $linear)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $factor = 1.0;
    string $pref = `currentUnit -q -l`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $factor = 1.0;
    $pref = `currentUnit -q -l`;
    if ( "mm" == $pref ) $factor = 10.0;
    if ( "m" == $pref ) $factor = 0.01;
    if ( "inch" == $pref ) $factor = 0.3937007874;
    if ( "ft" == $pref ) $factor = 0.03280839895;
    if ( "yard" == $pref ) $factor = 0.01093613298;

    return ( $linear * $factor );

}


/******************************************************************************
 * @procedure    angle_to_internal
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $angle : float
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float angle_to_internal(float $angle)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $pref = `currentUnit -q -a`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pref = `currentUnit -q -a`;
    if ( "deg" == $pref )
    {
    $angle = $angle * 0.0174532925;
    }

    return $angle;

}


/******************************************************************************
 * @procedure    facenormal
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $selObj : string[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] facenormal(string $selObj[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numTokens;
    int $numTokens2;
    float $TheNormal[] = stringtofloat($buffer2);
    string $stringFaceNormalZ[] = `polyInfo -faceNormals $selObj[0]`;
    string $buffer[];
    string $stringFaceNormalZ2[] = {$buffer[1]};
    string $stringFaceNor = $buffer[1];
    string $buffer2[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $stringFaceNormalZ = `polyInfo -faceNormals $selObj[0]`;
    $numTokens = `tokenize $stringFaceNormalZ[0] ":" $buffer`;
    $stringFaceNormalZ2 = {$buffer[1]};
    $stringFaceNor = $buffer[1];
    $numTokens2 = `tokenize $stringFaceNor " " $buffer2`;
    $TheNormal = stringtofloat($buffer2);
    return $TheNormal;

}


/******************************************************************************
 * @procedure    stringtofloat
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $bufferA : string[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] stringtofloat(string $bufferA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $TheNormalX = $buffer1;
    float $TheNormalY = $buffer2;
    float $TheNormalZ = $buffer3;
    float $TheNormalAll[] = { $TheNormalX, $TheNormalY, $TheNormalZ };
    string $buffer1 = $bufferA[0];
    string $buffer2 = $bufferA[1];
    string $buffer3 = $bufferA[2];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $buffer1 = $bufferA[0];
    $buffer2 = $bufferA[1];
    $buffer3 = $bufferA[2];
    $TheNormalX = $buffer1;
    $TheNormalY = $buffer2;
    $TheNormalZ = $buffer3;
    $TheNormalAll = { $TheNormalX, $TheNormalY, $TheNormalZ };
    return $TheNormalAll;

}


/******************************************************************************
 * @procedure    CurveEPnumber
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $myCurve : string
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int CurveEPnumber(string $myCurve)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size  ($CurveSelection);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    return $numEPrealNum;

}


/******************************************************************************
 * @procedure    StartofCurveScriptRetopo2
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $captureCurveName : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] StartofCurveScriptRetopo2(string $captureCurveName[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $curveTypeSwitchC = `IsCircle`;
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPRebuildNum = ($numEPrealNum * 2 );
    int $curveEPsZ = CurveEPnumber($myCurve);
    int $curveEPsZ2 = CurveEPnumber($myCurve);
    float $arcL1 = `arclen $myCurve`;
    float $arcL2 = `arclen $myCurve`;
    float $percentDIffZ = PercentDiff_Curve_to_Arc($arcL2,$arcL1);
    float $arcL3 = `arclen $myCurve`;
    float $percentDIffZ2 = PercentDiff_Curve_to_Arc($arcL3,$arcL1);
    float $EACHCVposA[];
    float $EACHCVposB[];
    float $eachCVpos[];
    string $objectcurv[];
    string $myCurve = $objectcurv[0];
    string $newCircle[] = `CIRCLESCRIPTZ ($objectcurv)`;
    string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size  ($CurveSelection);
    string $DupicateZ[] = `duplicate -rr $myCurve`;
    string $digitalSkeleton[];
    string $CurveItemA = $objectcurv[0];
    string $AllIntersectCurveZ[];
    string $IntersectCurves[];
    string $MakeExtrudeSurface[];
    string $MakeBirailSurface[];
    string $MakeXBetween[];
    string $MakeIntersectCurvez[];
    string $MakespaceLocator[];
    string $each;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    Removefromsurface;
    $objectcurv = `ls -sl`;
    $myCurve = $objectcurv[0];

    $curveTypeSwitchC = `IsCircle`;

    if ( $curveTypeSwitchC == 1 ){
    $newCircle = `CIRCLESCRIPTZ ($objectcurv)`;
    rotate -r -os 90 0 0 ;
    }

    $arcL1 = `arclen $myCurve`;

    //float $arcL2 = ( $arcL1 / 1.5 );
    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPRebuildNum = ($numEPrealNum * 2 );
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s $numEPRebuildNum -d 3 -tol  0.001 $myCurve;

    //CopySelected;  DUPLICATE IT
    $DupicateZ = `duplicate -rr $myCurve`;
    select -r $myCurve;
    SmoothCurvatureB3(0.1);
    $arcL2 = `arclen $myCurve`;
    print $arcL1;
    print $arcL2;
    print $myCurve;
    print $DupicateZ;
    select -r $DupicateZ;

    $percentDIffZ = PercentDiff_Curve_to_Arc($arcL2,$arcL1);
    $curveEPsZ = CurveEPnumber($myCurve);

    if (($percentDIffZ < 98.0)||($curveEPsZ < 5)) {  delete $myCurve;
    rename $DupicateZ[0] $myCurve;
    $DupicateZ = `duplicate -rr $myCurve`;
    select -r $myCurve;
    SmoothCurvatureB3($arcL1);
    $arcL3 = `arclen $myCurve`;
    $curveEPsZ2 = CurveEPnumber($myCurve);
    $percentDIffZ2 = PercentDiff_Curve_to_Arc($arcL3,$arcL1);
    //ERROR here
    if ($percentDIffZ2 > 98.0){ delete $DupicateZ[0];
    select -r $myCurve;} else {
    delete $myCurve;
    rename $DupicateZ[0] $myCurve;
    select -r $myCurve;
    }
    }else{  delete $DupicateZ[0];
    select -r $myCurve;}

    $numInts = size($digitalSkeleton);
    if ( $numInts > 0 ){
    clear $digitalSkeleton;
    }

    $CurveItemA = $objectcurv[0];
    $CurveSelection = `ls -fl  ($CurveItemA+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    //float $arcL4 = `arclen $myCurve`;


    ///////////////GATHER ALL BUILDING  STRUCTURE/////////##
    appendStringArray($digitalSkeleton, $objectcurv,  1);
    ///////////////////////////////////////////////// ////##
    $numInts = size($AllIntersectCurveZ);
    if ( $numInts > 0 ){
    clear $AllIntersectCurveZ;
    }
    for ($each in $CurveSelection) {
    $eachCVpos = `pointPosition -w  $each`;
    $MakeIntersectCurvez[0] = `curve -d 1 -p 0 0 0 -p  12 0 0 -k 0 -k 1 -n IntersectCurve` ;
    appendStringArray($AllIntersectCurveZ,  $MakeIntersectCurvez, 1);
    $numInts = size($AllIntersectCurveZ);
    extendCurvePresetArgList( "2", {"0",  "0","0","0","100","0","0","0","0","1","1","1"} );

    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 2 -kcp  0 -kep 1 -kt 0 -s 22 -d 3 -tol 0.001 ;
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakeIntersectCurvez[0];
    //PAUSE;
    aimConstraint -offset 0 0 0 -weight 0.5 - aimVector -1 0 0 -upVector 0 0 -1 -worldUpType  "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM    $MakeIntersectCurvez[0];
    //PAUSE;
    }
    print $AllIntersectCurveZ;
    $captureCurveName = $objectcurv;
    select -r $captureCurveName;
    delete $objectcurv;
    return $AllIntersectCurveZ;

}


/******************************************************************************
 * @procedure    SmoothCurvatureB3
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $curveM : float
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvatureB3(float $curveM)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 2 );
    int $Par = 0;
    int $a;
    int $ii = 0;
    float $step = $numEPrealNum2;
    float $curveMin = $curveM;
    float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size  ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = {$Newcurvez};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $myCurve = $curves[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 2 );
    //Above was Times * 4

    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0  -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
    $step = $numEPrealNum2;
    $curve = "curve -d 3";
    $curveMin = $curveM;
    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    if ( $CurvatureRadi <=  $curveMin){ PAUSE;
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
    }

    if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    }


    if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    }

    }

    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    rename $Newcurve $myCurve;
    $Newcurve = {$myCurve};

    return $Newcurve;

}


/******************************************************************************
 * @procedure    PercentDiff_Curve_to_Arc
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $arclenghtzARC : float
 *   $arclenghtzDRAWN : float
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float PercentDiff_Curve_to_Arc(float $arclenghtzARC, float $arclenghtzDRAWN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $FLOAT1;
    float $FLOAT2;
    float $PercentA;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    if($arclenghtzARC < $arclenghtzDRAWN){
    $FLOAT1 = $arclenghtzARC; $FLOAT2 = $arclenghtzDRAWN;}
    if($arclenghtzARC > $arclenghtzDRAWN){
    $FLOAT1 = $arclenghtzDRAWN; $FLOAT2 = $arclenghtzARC; }

    if($arclenghtzARC == $arclenghtzDRAWN){
    $PercentA = 0;}else{
    $PercentA = ((float($FLOAT1) / $FLOAT2) * (100) ); }
    return $PercentA;

}


/******************************************************************************
 * @procedure    AddorSubtract
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Number : int
 *   $AorS : int
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int AddorSubtract(int $Number, int $AorS)
{

    if ($AorS == 1){ $Number++; return $Number; }
    if ($AorS == 0){ $Number--; return $Number; }
    if ($AorS == 2){ $Number = 0; return $Number; }

}


/******************************************************************************
 * @procedure    StartofCurveScriptRetopo3
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $PolygonShapeZ : string[]
 *   $ProjectionCurves : string[]
 *   $CurveName : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] StartofCurveScriptRetopo3(string $PolygonShapeZ[], string $ProjectionCurves[], string $CurveName[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $KillScript = 1;
    int $curvesNumber = size($Allcurves) -1;
    int $iY = -1;
    int $switchN = 0;
    int $Xi = 1;
    int $a = 1;
    int $ADDSUB = 1;
    int $ADDSUB2 = 2;
    int $XiX = 0;
    int $triggerA = 0;
    int $RDivideTotalWithUnit;
    int $A2;
    int $Gate2 = 0;
    int $Gate1 = 0;
    int $a3 = 1;
    int $Demo = 0;
    int $PassedTargetNum = 0;
    int $IFequivalent = equivalentTol($DistanceAB,  $ZeroDistanceAB, 0.1);
    float $ZeroDistanceAB = 0.0;
    float $step = 1;
    float $arclenghtOne = `arclen $Allcurves[0]`;
    float $DistanceFourth;
    float $UnitDistance;
    float $DivideTotalWithUnit;
    float $UnitDistanceA;
    float $UnitDistanceFourth;
    float $UnitDistanceHalf;
    float $valuesC[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    float $valuesD[] = `getAttr  ($myCPOM+".position")`;
    float $DistanceCD = PointsGetDistanceFLOAT ($valuesC, $valuesD);
    float $valuesA[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    float $valuesB[] = `getAttr  ($myCPOM+".position")`;
    float $DistanceAB = PointsGetDistanceFLOAT ($valuesA, $valuesB);
    string $PolygonShape[];
    string $AllIntersectCurveZA[] = $ProjectionCurves;
    string $curve = "curve -d 3";
    string $Allcurves[];
    string $curvePoints = "";
    string $crShape[];
    string $myCurve;
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = $CurveName;
    string $NewcurveA[] = `ls -sl`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $PolygonShape[0] = $PolygonShapeZ[0];
    $AllIntersectCurveZA = $ProjectionCurves;
    //$PolygonShape[0] = $PolygonShapeZA[0];
    //string $AllIntersectCurveZA[] =  $retopoProjectionCurves;
    //print $retopoProjectionCurves;
    makeIdentity -apply true -t 0 -r 0 -s 1 -n 0  $PolygonShape;
    $KillScript = 1;
    $curve = "curve -d 3";
    $Allcurves = $AllIntersectCurveZA;
    $curvesNumber = size($Allcurves) -1;
    $iY = -1;
    $ZeroDistanceAB = 0.0;
    $switchN = 0;
    $Xi = 1;
    $curvePoints = "";
    $step = 1;
    while ($curvesNumber > $iY ){
    if ($KillScript == 0 ){$iY = 1000;}
    $iY++;
    $a = 1;
    $ADDSUB = 1;
    $ADDSUB2 = 2;
    $b = 0;
    ///////////////////
    $switchN = 0;
    //////////////////
    $Xi = 1;
    $step = 1;
    $arclenghtOne = `arclen $Allcurves[0]`;

    $myCurve =  $Allcurves[$iY];
    $cube = $PolygonShape[0];
    $myCPOM = `createNode closestPointOnMesh`;
    connectAttr ($cube+".worldMesh")  ($myCPOM+".inMesh");
    $LocatorResultA = `spaceLocator -p 0 0 0 -n  LocA`;
    $LocA = $LocatorResultA[0];
    connectAttr ($myCPOM+".position")  ($LocA+".translate");
    $LocatorResultB = `spaceLocator -p 0 0 0 -n  LocB`;
    $LocB = $LocatorResultB[0];
    connectAttr ($LocB+".translate")  ($myCPOM+".inPosition");
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    $connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position") ($LocB  + ".translate")`;
    $crShape = `listRelatives -s $myCurve`;
    $XiX = 0;
    $triggerA = 0;
    $Gate2 = 0;
    $Gate1 = 0;
    $a3 = 1;
    $Demo = 0;

    $PassedTargetNum = 0;

    while($Xi > 0 ){


    $XiX++;
    if ($XiX == 1000){$Xi = 0; $KillScript = 0;}
    $valuesC = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $valuesD = `getAttr  ($myCPOM+".position")`;
    $DistanceCD = PointsGetDistanceFLOAT ($valuesC, $valuesD);

    ////IF triggered ----- "$step = 40; $a = $a * 40"
    // then --- $a = AddorSubtract($a ,$ADDSUB) which  adds 1 making t = 80/40 t = 81/40
    $a = AddorSubtract($a ,$ADDSUB);
    $t =  $a/$step;

    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t;
    $para = `getAttr ($paramlocatorpointOnCurvex +  ".parameter")`;
    $valuesA = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $valuesB = `getAttr  ($myCPOM+".position")`;
    $DistanceAB = PointsGetDistanceFLOAT ($valuesA, $valuesB);

    if ($XiX < 32){ $Gate1 = $XiX;}
    if ($XiX == 1){ $Gate2 = 1;
    $UnitDistanceFourth = $DistanceAB/4;
    $UnitDistanceA  = PointsGetDistanceFLOAT ($valuesC, $valuesA);
    }
    /*
    $DivideTotalWithUnit = $DistanceCD /  $UnitDistance;
    $RDivideTotalWithUnit = $DivideTotalWithUnit;
    */
    /////////////////////////////////////
    if ($XiX == $Gate2){ $Gate2 = $Gate1;
    $UnitDistance  = $UnitDistanceA;
    $UnitDistanceHalf = $UnitDistance/2;
    $DivideTotalWithUnit = ($DistanceAB/2) /  $UnitDistanceHalf;
    $A2 = ($DivideTotalWithUnit +1);
    if ($A2 >= 1){
    $a = $a + $A2;
    }else{ int $IFequivalent = equivalentTol ($DistanceAB, $ZeroDistanceAB, 0.1);
    if ($IFequivalent == 1){
    $curve += " -p "+$valuesB[0]+"  "+$valuesB[1]+" "+$valuesB[2];
    select -r $LocB $LocA;
    delete $myCPOM $LocA $LocB  $paramlocatorpointOnCurvex;
    $Xi = 0;
    }}
    }


    ///////////////////////////////////

    //if ( $DistanceAB > $DistanceCD ) { print ("0000  Passed Target Distance  0000" +  "\n"); $PassedTargetNum++;}

    //0000  Passed Target Distance  0000

    if ($switchN == 0){
    if ($triggerA == 0){
    if (( $DistanceAB <= $UnitDistanceHalf ) && (  $DistanceAB < $DistanceCD )) {$ADDSUB = 1; $step  = 40; $a = $a * 40;
    $triggerA = 1; }
    }
    if (!($XiX == $Gate2)){
    if($PassedTargetNum<1){
    if ( $DistanceAB > $DistanceCD ) { $ADDSUB = 0;  $step = 20; $a = $a * 20; $switchN = 1;
    print ("0000  Passed Target Distance  0000" +  "\n"); }
    }
    }
    }


    if ($switchN == 2){
    if ( $DistanceAB > 4){ $ADDSUB = 1;  $step = 1; $a = $a / 20; $switchN = 0; $PassedTargetNum++; print ("0000  Passed False Target  0000" +  "\n");}else{
    if ( $DistanceAB > $DistanceCD ) { $ADDSUB = 1;  $step = 40; $a = $a * 40;  $switchN = 3;
    $ADDSUB2 = 1; }
    }
    }

    if ($switchN == 1){ $switchN = 2; }
    $IFequivalent = equivalentTol($DistanceAB,  $ZeroDistanceAB, 0.1);
    if ($IFequivalent == 1){
    $curve += " -p "+$valuesB[0]+"  "+$valuesB[1]+" "+$valuesB[2];
    select -r $LocB $LocA;
    delete $myCPOM $LocA $LocB  $paramlocatorpointOnCurvex;
    $Xi = 0;
    }


    $b = AddorSubtract($b ,$ADDSUB2);
    if ( $b > 10 ){ delete $myCPOM $LocA $LocB  $paramlocatorpointOnCurvex;
    $Xi = 0; }
    //////////////////////////////////


    }
    }
    $Newcurvez = `eval($curve)`;
    rename $Newcurvez $CurveName[0];
    $Newcurve = $CurveName;
    $NewcurveA = `ls -sl`;
    delete $ProjectionCurves;
    return $Newcurve;

}


/******************************************************************************
 * @procedure    AverageVectorPoint
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $worldPosZ : vector[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] AverageVectorPoint(vector $worldPosZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $vectorSize = size($worldPosZ);
    int $vecCount = size($worldPosZ);
    int $Vii = 0;
    float $Added_floats[] = { 0.0, 0.0, 0.0};
    float $FloatFromVec[];
    float $VposA;
    float $VposB;
    float $VposC;
    float $FloatFromVecA[] = $worldPosZ[$Vii];
    float $a = ($Added_floats[0]) /  $vectorSize;
    float $b = ($Added_floats[1]) /  $vectorSize;
    float $c = ($Added_floats[2]) /  $vectorSize;
    float $PointsAverage[] = {$a , $b , $c};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $vectorSize = size($worldPosZ);
    $vecCount = size($worldPosZ) ;
    $Added_floats = { 0.0, 0.0, 0.0};
    $Vii = 0;
    while ($Vii < $vecCount){
    $FloatFromVecA = $worldPosZ[$Vii];
    $VposA = $FloatFromVecA[0];
    $VposB = $FloatFromVecA[1];
    $VposC = $FloatFromVecA[2];
    $Added_floats = {($FloatFromVecA[0] +  $Added_floats[0]), ($FloatFromVecA[1] +  $Added_floats[1]), ($FloatFromVecA[2] +  $Added_floats[2])} ;
    $Vii++;
    }
    $a = ($Added_floats[0]) /  $vectorSize;
    $b = ($Added_floats[1]) /  $vectorSize;
    $c = ($Added_floats[2]) /  $vectorSize;
    $PointsAverage = {$a , $b , $c};
    return $PointsAverage;


}


/******************************************************************************
 * @procedure    IntersectItems
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $initialArray : string[]
 *   $IntersectArrayItems : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] IntersectItems(string $initialArray[], string $IntersectArrayItems[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $myIntersector = `stringArrayIntersector`;
    string $results[] = `stringArrayIntersector - query $myIntersector`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $myIntersector = `stringArrayIntersector`;
    stringArrayIntersector -edit -intersect  $initialArray $myIntersector;
    stringArrayIntersector -edit -intersect  $IntersectArrayItems $myIntersector;
    $results = `stringArrayIntersector - query $myIntersector`;
    stringArrayIntersector -edit -reset  $myIntersector;
    return $results;

}


/******************************************************************************
 * @procedure    GetCenterPointofFace
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $CurveXYZ : float[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] GetCenterPointofFace(float $CurveXYZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Cnsize = `size $CurveXYZ`;
    int $Cnsize_p = ($Cnsize/3) -1;
    int $ix = -1;
    int $Xii = -3;
    float $FacePoint[] = AverageVectorPoint($points);
    vector $points[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $Cnsize = `size $CurveXYZ`;
    $Cnsize_p = ($Cnsize/3) -1;
    $ix = -1;
    $Xii = -3; int $Yii = -2; int $Zii = -1;
    clear $points;
    while ($ix < $Cnsize_p){
    $ix++;
    $Xii = $Xii + 3;
    $Yii = $Yii + 3;
    $Zii = $Zii + 3;
    $points[$ix] = <<$CurveXYZ[$Xii], $CurveXYZ [$Yii], $CurveXYZ[$Zii]>>;
    }
    $FacePoint = AverageVectorPoint($points);
    return $FacePoint;

}


/******************************************************************************
 * @procedure    FaceEdgeNumber
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $face : string
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FaceEdgeNumber(string $face)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $EdgeNumber = `size($PolyEg)`;
    string $PolyEg[] = `polyListComponentConversion  -fromFace -toEdge $face`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyEg = `polyListComponentConversion  -fromFace -toEdge $face`;
    $PolyEg = `ls -fl $PolyEg`;
    $EdgeNumber = `size($PolyEg)`;
    return $EdgeNumber;

}


/******************************************************************************
 * @procedure    CreateCurve
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $CurveLength : float
 *   $CurveNSpans : int
 *   $Curvename : string
 *
 * @returns      string
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string CreateCurve(float $CurveLength, int $CurveNSpans, string $Curvename)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CurveNSpansC = $CurveNSpans;
    float $CurveLengthC = $CurveLength;
    float $CurveCurvPart = $CurveLengthC/ $CurveNSpansC;
    float $Curvei = 0;
    string $CurvenextSel[] = `ls -sl`;
    string $CurvenameCobj = $Curvename;
    string $CurvecurveP = "";
    string $renamed = `rename $CurvenameCobj`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurvenextSel = `ls -sl`;
    $CurveLengthC = $CurveLength;
    $CurveNSpansC = $CurveNSpans;
    global string $CurvenameCobj;
    $CurvenameCobj = $Curvename;

    $CurveNSpansC = $CurveNSpansC - 1;
    $CurveCurvPart = $CurveLengthC/ $CurveNSpansC;
    $CurvecurveP = "";

    $Curvei = 0;
    while ($Curvei <= $CurveLengthC)
    {
    $CurvecurveP = ($CurvecurveP+"-p 0 "+$Curvei+" 0  ");
    $Curvei = $Curvei + $CurveCurvPart;
    }
    $CurvecurveP = ("curve -d 3 "+$CurvecurveP+";");
    eval $CurvecurveP;
    $renamed = `rename $CurvenameCobj`;
    //select $CurvenextSel;
    return $renamed ;

}


/******************************************************************************
 * @procedure    getSelectionType
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      string
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string getSelectionType()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $selectionFindType[] = `ls -sl`;
    string $idnodeType2;
    string $Relativesselection[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $selectionFindType = `ls -sl`;
    $Relativesselection = `listRelatives $selectionFindType[0]`;
    if (size($Relativesselection)== 0){ $idnodeType2 = `nodeType $Relativesselection[0]`;} else{
    $idnodeType2 = `nodeType $Relativesselection[0]`;}
    return $idnodeType2;

}


/******************************************************************************
 * @procedure    stringArrayMatchToArray
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] stringArrayMatchToArray(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $resultZ = false;
    int $sizeMatchedItems = `size($matchedItem)`;
    int $matchedBlankN = isValidString($matchedItem[0], "([a-zA-Z]+)([a-zA-Z0-9_])*");
    string $FoundMatchedItem[];
    string $MatchedItem[];
    string $OneiteminArrayList = $each;
    string $matchedItem[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $resultZ = false;
    for ($each in $list) {
    $OneiteminArrayList = $each;
    $matchedItem = {`match $item $OneiteminArrayList `};
    $sizeMatchedItems = `size($matchedItem)`;
    $matchedBlankN = isValidString($matchedItem[0], "([a-zA-Z]+)([a-zA-Z0-9_])*");
    if (($sizeMatchedItems >  0) && ($matchedBlankN > 0)){
    $resultZ = true;
    if ($resultZ == true ){ $FoundMatchedItem[0] = ($OneiteminArrayList); }
    break;	}
    }
    return  $FoundMatchedItem;

}


/******************************************************************************
 * @procedure    ConvertPolyFacesIntoNurbSurface
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      string
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string ConvertPolyFacesIntoNurbSurface()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sizeBorderEdges = size ($SelectedPolyBorderEdges) -1;
    int $Xi = 1;
    int $ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
    int $iix = 0;
    int $iiV = 0;
    float $valuesP[];
    float $values[];
    string $PolyFaceslist[] = `ls -sl`;
    string $NewPolyFaces[] = ` polyChipOff -ch 1 -kft  1 -dup 0 -off 0 $PolyFaceslist`;
    string $HistoryConnections[] = ` listHistory - future true -pruneDagObjects false  $NewPolyFaces`;
    string $polySep[] = `polySeparate -rs 1 -ch 0  $HistoryConnections[1]`;
    string $PolyFaces = ( $PolygonNew[0] +".f[*]");
    string $AllPolyFaces[] = `ls -fl $PolyFaces`;
    string $AllPolyFaces2[] = `ls $PolyFaces`;
    string $diffEdgeVertz[] = GetEdgeVertex ($PolygonNew);
    string $ReturnObjects = "";
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorCX`;
    string $DiffPolyBorderEdges[] = GetdiffEdgesOfBorder($PolygonNew);
    string $SelectedPolyBorderEdges[] = PolyBorderEdges($PolygonNew);
    string $NearEdges[] = GetNearEdges ($EdgeVertzStart);
    string $diffA[] = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdges);
    string $NearEdgesA[] = GetNearEdges ($NearEdgesOne);
    string $diffB[] = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdgesA);
    string $EdgesVertex[] = ls(" -fl",polyListComponentConversion(" -toVertex",$diffB[0]));
    string $bufferList[];
    string $EdgeCurves[];
    string $EdgesVertexEach[];
    string $ListA[];
    string $EdgesVertexEachOrder[] = VertLoopEdgeLoop($ListA);
    string $Newcurvez = `eval($curve)`;
    string $NewcurveX[];
    string $NurbSurfaceFromPolyFaces = `alternativeBoundry`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyFaceslist = `ls -sl`;
    $NewPolyFaces = ` polyChipOff -ch 1 -kft  1 -dup 0 -off 0 $PolyFaceslist`;
    print $NewPolyFaces;
    $HistoryConnections = ` listHistory - future true -pruneDagObjects false  $NewPolyFaces`;
    $polySep = `polySeparate -rs 1 -ch 0  $HistoryConnections[1]`;
    select -r $polySep[1];
    string $PolygonNew[0] = {$polySep[1]};
    parent -w $PolygonNew;
    $PolyFaces = ( $PolygonNew[0] +".f[*]");
    $AllPolyFaces = `ls -fl $PolyFaces`;
    $AllPolyFaces2 = `ls $PolyFaces`;

    $diffEdgeVertz = GetEdgeVertex ($PolygonNew);
    $ReturnObjects = "";

    for ($eachP in $diffEdgeVertz){
    $valuesP = `pointPosition -w ($eachP)`;
    $spaceLocatorB = `spaceLocator -p 0 0 0  -n LocatorCX`;
    move -ws $valuesP[0] $valuesP[1] $valuesP[2]  $spaceLocatorB;
    $ReturnObjects += $spaceLocatorB[0]+" ";
    }
    $DiffPolyBorderEdges = GetdiffEdgesOfBorder($PolygonNew);
    $SelectedPolyBorderEdges = PolyBorderEdges($PolygonNew);

    $sizeBorderEdges = size ($SelectedPolyBorderEdges) -1;
    string $EdgeVertzStart[0] = {$diffEdgeVertz[0]};
    stringArrayRemoveAtIndex(0, $diffEdgeVertz);
    $NearEdges = GetNearEdges ($EdgeVertzStart);
    string $NearEdgesOne[0] = {$NearEdges[0]};
    string $NearEdgesSecond[0] = {$NearEdges[1]};
    appendStringArray($DiffPolyBorderEdges,  $NearEdgesSecond, 1);
    $diffA = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdges);
    string $orderedArray[0] = {$NearEdgesOne[0]};
    $Xi = 1;
    while ($Xi < $sizeBorderEdges){
    $Xi++;
    $NearEdgesA = GetNearEdges ($NearEdgesOne);
    appendStringArray($DiffPolyBorderEdges,  $NearEdgesOne, 1);
    $diffB = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdgesA);

    $EdgesVertex = ls(" -fl",polyListComponentConversion(" -toVertex",$diffB[0]));
    $ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
    appendStringArray($orderedArray, $diffB, 1);
    $NearEdgesOne = $diffB;
    }
    appendStringArray($orderedArray,  $NearEdgesSecond, 1);

    $EdgeLists = "";
    $iix = 0;
    $iiV = 0;
    for ($each in $orderedArray){
    string $oneItem[0] = {$each};
    $EdgesVertex = ls(" -fl",polyListComponentConversion("-toVertex",  $oneItem[0]));
    if ( $iix > 0){
    $ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
    if ( $ifTrue == 1){ $iiV++; if ( $iiV == 1){
    $EdgeLists += " "+$oneItem[0]+" "+"VERT";} if (  $iiV == 2){ $EdgeLists += " "+$oneItem[0]; $iiV =  0; } }
    if ( $ifTrue == 0){ $EdgeLists += " "+$oneItem [0]; }
    }
    if ( $iix == 0){  $EdgeLists += $oneItem[0]; }
    $iix++;
    }

    $numTokens = `tokenize $EdgeLists "VERT"  $bufferList`;
    clear $EdgeCurves;
    for($eachBuffer in $bufferList){
    $ListA = `stringToStringArray  $eachBuffer " "`;
    //string $EdgesVertexEach[] = ls(" -fl",polyListComponentConversion("-toVertex",  $ListA));
    $EdgesVertexEachOrder = VertLoopEdgeLoop($ListA);
    $curve = "curve -d 1";
    for($eachVert in $EdgesVertexEachOrder){
    $values = `pointPosition -w ($eachVert)`;
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
    }
    $Newcurvez = `eval($curve)`;
    $NewcurveX = {$Newcurvez};
    appendStringArray($EdgeCurves, $NewcurveX, 1);

    }
    select -r $EdgeCurves;
    $NurbSurfaceFromPolyFaces = `alternativeBoundry`;
    delete -ch $EdgeCurves;
    delete $PolygonNew;
    $ReturnObjects += $NurbSurfaceFromPolyFaces;
    $ReturnObjects += " "+$EdgeCurves[0] +"  "+$EdgeCurves[1] +" "+$EdgeCurves[2] +"  "+$EdgeCurves[3] ;
    select -r $EdgeCurves;
    print $ReturnObjects;
    return $ReturnObjects;

}


/******************************************************************************
 * @procedure    CreatePolyFromFloats
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $BoxPointsX : float[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CreatePolyFromFloats(float $BoxPointsX[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sizeVecBox = size($BoxPointZ);
    int $ZiI = 0;
    float $bbox[] = $BoxPointsX;
    float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox [2]};
    float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox [5]};
    float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox [2]};
    float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox [5]};
    float $values[] = $BoxPointZ[$ZiI];
    string $polyZ = "polyCreateFacet";
    vector $BoxPointZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $bbox = $BoxPointsX;
    $BoxPointA = {$bbox[0], $bbox[1], $bbox [2]};
    $BoxPointB = {$bbox[3], $bbox[4], $bbox [5]};
    $BoxPointC = {$bbox[3], $bbox[1], $bbox [2]};
    $BoxPointD = {$bbox[0], $bbox[4], $bbox [5]};
    ///
    $BoxPointZ[0] = <<$bbox[0], $bbox[4], $bbox[2]>>;
    $BoxPointZ[1] = <<$bbox[3], $bbox[4], $bbox[2]>>;
    $BoxPointZ[2] = <<$bbox[3], $bbox[4], $bbox[5]>>;
    $BoxPointZ[3] = <<$bbox[0], $bbox[4], $bbox[5]>>;

    $sizeVecBox = size($BoxPointZ);
    $polyZ = "polyCreateFacet";
    $ZiI = 0;
    progressWindow -ii true -title "Working" -status  "Moving Verts" -max (size($BoxPointZ)) -progress  0;
    while ($ZiI < $sizeVecBox){
    $values = $BoxPointZ[$ZiI];
    $polyZ += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    $ZiI++;
    progressWindow -e -s 1;
    if (`progressWindow -q -ic`)
    {
    progressWindow -endProgress;
    error  "User Interupt.";
    }


    }
    print $polyZ;
    string $NewPolyZz[0] = `eval($polyZ)`;
    progressWindow -endProgress;
    select -r $NewPolyZz;
    ResetTranslation($NewPolyZz);
    return $NewPolyZz;

}


/******************************************************************************
 * @procedure    GetDistancePointPositionFLOAT
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $objectFirst : string
 *   $objectSecond : string
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc float GetDistancePointPositionFLOAT(string $objectFirst, string $objectSecond)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $pointAZ1[];
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if (catch($pointAZ1 = `pointPosition -w  ($objectFirst)`)){
    print "using Xform"; $pointAZ1 = `xform -q -ws -rp ($objectFirst)`;
    }
    if (catch($pointAZ2 = `pointPosition -w  ($objectSecond)`)){
    print "using Xform"; $pointAZ1 = `xform -q -ws -rp ($objectSecond)`;
    }
    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy =  $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    alternativeBoundry
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      string
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string alternativeBoundry()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $hist = `constructionHistory -q - tgl`;
    int $n = size($curves);
    int $i;
    string $curves[] = `filterExpand -ex true  -sm $gSelectNurbsCurvesBit -sm  $gSelectIsoparmsBit -sm  $gSelectCurvesOnSurfacesBit -sm    $gSelectSurfaceEdgeBit`;
    string $surface = "";
    string $cmd = "boundary -or 0 -ep 0 -rn 1  -po 0 -ept 0.001 -ch  " + $hist + " ";
    string $now[] = `rebuildCurve -ch  0 -rpo 1 -kcp on -d 1 -rt 0 $curves[$i]`;
    string $res[] = eval($cmd);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $hist = `constructionHistory -q - tgl`;
    global int $gSelectNurbsCurvesBit;
    global int $gSelectIsoparmsBit;
    global int $gSelectCurvesOnSurfacesBit;
    global int $gSelectSurfaceEdgeBit;
    $curves = `filterExpand -ex true  -sm $gSelectNurbsCurvesBit -sm  $gSelectIsoparmsBit -sm  $gSelectCurvesOnSurfacesBit -sm    $gSelectSurfaceEdgeBit`;
    $surface = "";
    $n = size($curves);
    if( $n < 4 ) return $surface;
    $cmd = "boundary -or 0 -ep 0 -rn 1  -po 0 -ept 0.001 -ch  " + $hist + " ";
    // Rebuild them into linears (keep cvs):
    for( $i=0; $i<$n; $i+=1 ) {
    $now = `rebuildCurve -ch  0 -rpo 1 -kcp on -d 1 -rt 0 $curves[$i]`;
    $curves[$i] = $now[0];
    $cmd = $cmd + $curves[$i] + " ";
    }

    // Convert back into cubic:
    $res = eval($cmd);
    if( size($res) > 0 ) {
    $surface = $res[0];
    rebuildSurface -ch $hist -rpo 1 -rt 0 -end 1 -kr  0 -kcp 0 -kc 0 -su 0 -du 3 -sv 0 -dv 3 -tol 0.001  -fr 0  -dir 2 $surface;
    }

    if( !$hist ) {
    for( $i=0; $i<$n; $i+=1 ) {
    delete $curves[$i];
    }
    }

    select -r $curves;
    return $surface;

}


/******************************************************************************
 * @procedure    FindifArraysContain
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $FirstList : string[]
 *   $array2 : string[]
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc int FindifArraysContain(string $FirstList[], string $array2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $found;
    int $Trigger;
    string $oneItemz = $each;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ($each in $FirstList){
    $oneItemz = $each;
    $found = stringArrayContains($oneItemz, $array2);
    if ( $found == 1 ){ $Trigger = 1; break; }
    }
    return $Trigger;

}


/******************************************************************************
 * @procedure    ConvertPolyPlaneIntoNurbSurfaceZ
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $PolygonNew : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] ConvertPolyPlaneIntoNurbSurfaceZ(string $PolygonNew[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sizeBorderEdges = size ($SelectedPolyBorderEdges) -1;
    int $Xi = 1;
    int $ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
    int $iix = 0;
    int $iiV = 0;
    float $valuesP[];
    float $values[];
    string $PolyFaces = ( $PolygonNew[0] +".f[*]");
    string $AllPolyFaces[] = `ls -fl $PolyFaces`;
    string $AllPolyFaces2[] = `ls $PolyFaces`;
    string $diffEdgeVertz[] = GetEdgeVertex ($PolygonNew);
    string $ReturnObjects = "";
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorCX`;
    string $DiffPolyBorderEdges[] = GetdiffEdgesOfBorder($PolygonNew);
    string $SelectedPolyBorderEdges[] = PolyBorderEdges($PolygonNew);
    string $NearEdges[] = GetNearEdges ($EdgeVertzStart);
    string $diffA[] = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdges);
    string $NearEdgesA[] = GetNearEdges ($NearEdgesOne);
    string $diffB[] = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdgesA);
    string $EdgesVertex[] = ls(" -fl",polyListComponentConversion("- toVertex",$diffB[0]));
    string $bufferList[];
    string $EdgeCurves[];
    string $EdgesVertexEach[];
    string $ListA[];
    string $EdgesVertexEachOrder[] = VertLoopEdgeLoop($ListA);
    string $Newcurvez = `eval($curve)`;
    string $NewcurveX[];
    string $ListofItemConvert[] = `stringToStringArray $ReturnObjects " "`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $PolyFaces = ( $PolygonNew[0] +".f[*]");
    $AllPolyFaces = `ls -fl $PolyFaces`;
    $AllPolyFaces2 = `ls $PolyFaces`;

    $diffEdgeVertz = GetEdgeVertex ($PolygonNew);
    $ReturnObjects = "";

    for ($eachP in $diffEdgeVertz){
    $valuesP = `pointPosition -w ($eachP)`;
    $spaceLocatorB = `spaceLocator -p 0 0 0  -n LocatorCX`;
    move -ws $valuesP[0] $valuesP[1] $valuesP[2]  $spaceLocatorB;
    $ReturnObjects += $spaceLocatorB[0]+" ";
    }
    $DiffPolyBorderEdges = GetdiffEdgesOfBorder($PolygonNew);
    $SelectedPolyBorderEdges = PolyBorderEdges($PolygonNew);

    $sizeBorderEdges = size ($SelectedPolyBorderEdges) -1;
    string $EdgeVertzStart[0] = {$diffEdgeVertz[0]};
    stringArrayRemoveAtIndex(0, $diffEdgeVertz);
    $NearEdges = GetNearEdges ($EdgeVertzStart);
    string $NearEdgesOne[0] = {$NearEdges[0]};
    string $NearEdgesSecond[0] = {$NearEdges[1]};
    appendStringArray($DiffPolyBorderEdges,  $NearEdgesSecond, 1);
    $diffA = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdges);
    string $orderedArray[0] = {$NearEdgesOne[0]};
    $Xi = 1;
    while ($Xi < $sizeBorderEdges){
    $Xi++;
    $NearEdgesA = GetNearEdges ($NearEdgesOne);
    select -r $NearEdgesA;
    appendStringArray($DiffPolyBorderEdges,  $NearEdgesOne, 1);
    $diffB = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdgesA);
    select -r $diffB;
    $EdgesVertex = ls(" -fl",polyListComponentConversion("- toVertex",$diffB[0]));
    $ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
    appendStringArray($orderedArray, $diffB, 1);
    $NearEdgesOne = $diffB;
    }
    appendStringArray($orderedArray,  $NearEdgesSecond, 1);

    $EdgeLists = "";

    $iix = 0;
    $iiV = 0;
    for ($each in $orderedArray){
    string $oneItem[0] = {$each};
    $EdgesVertex = ls(" -fl",polyListComponentConversion("-toVertex",  $oneItem[0]));
    playButtonStepForward;
    select -r $EdgesVertex;
    playButtonStepForward;
    if ( $iix > 0){
    $ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
    if ( $ifTrue == 1){ $iiV++; if ( $iiV == 1){
    $EdgeLists += " "+$oneItem[0]+" "+"VERT";} if (  $iiV == 2){ $EdgeLists += " "+$oneItem[0]; $iiV =  0; } }
    if ( $ifTrue == 0){ $EdgeLists += " "+$oneItem [0]; }
    }
    if ( $iix == 0){  $EdgeLists += $oneItem[0]; }
    $iix++;
    }

    $numTokens = `tokenize $EdgeLists "VERT"  $bufferList`;
    clear $EdgeCurves;
    for($eachBuffer in $bufferList){
    $ListA = `stringToStringArray  $eachBuffer " "`;
    //string $EdgesVertexEach[] = ls(" -fl",polyListComponentConversion("-toVertex",  $ListA));
    $EdgesVertexEachOrder = VertLoopEdgeLoop($ListA);
    $curve = "curve -d 1";
    for($eachVert in $EdgesVertexEachOrder){  playButtonStepForward;
    select -r $eachVert; playButtonStepForward;
    $values = `pointPosition -w ($eachVert)`;
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
    }
    $Newcurvez = `eval($curve)`;
    $NewcurveX = {$Newcurvez};
    appendStringArray($EdgeCurves, $NewcurveX, 1);

    }
    select -r $EdgeCurves;
    string $NurbSurfaceFromPolyFaces[0] =  {`alternativeBoundry`};
    delete -ch $NurbSurfaceFromPolyFaces;
    delete -ch $EdgeCurves;
    delete $PolygonNew;
    $ListofItemConvert = `stringToStringArray $ReturnObjects " "`;
    delete $ListofItemConvert;
    return $NurbSurfaceFromPolyFaces;

}


/******************************************************************************
 * @procedure    GetNearEdges
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $edgeArray : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] GetNearEdges(string $edgeArray[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $PolyVertexFromEdges[] = ls(" -fl",polyListComponentConversion("- toVertex",$edgeArray[0]));
    string $PolyEdgesFromVertex[] = ls(" -fl",polyListComponentConversion("-toEdge",  $PolyVertexFromEdges));

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyVertexFromEdges = ls(" -fl",polyListComponentConversion("- toVertex",$edgeArray[0]));
    $PolyEdgesFromVertex = ls(" -fl",polyListComponentConversion("-toEdge",  $PolyVertexFromEdges));
    return $PolyEdgesFromVertex;

}


/******************************************************************************
 * @procedure    VertLoopEdgeLoop
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $edgeZ : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] VertLoopEdgeLoop(string $edgeZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $verts[];
    string $v0[] = `polyListComponentConversion  -tv $edgeZ[0]`;
    string $v1[] = `polyListComponentConversion  -tv $edgeZ[1]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $v0 = `polyListComponentConversion  -tv $edgeZ[0]`;
    $v0=`ls -fl $v0`;
    $v1 = `polyListComponentConversion  -tv $edgeZ[1]`;
    $v1=`ls -fl $v1`;
    $v0=`stringArrayRemove $v1 $v0`;
    $verts[0]=$v0[0];

    for($i=0;$i<size($edgeZ);$i++)
    {
    $v0 = `polyListComponentConversion -tv $edgeZ[$i]`;

    $v0=`ls -fl $v0`;
    $v0=`stringArrayRemove $verts $v0`;
    $verts[size ($verts)]=$v0[0];
    }

    return	$verts;

}


/******************************************************************************
 * @procedure    IfIntersect
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $ArrayA : string[]
 *   $ArrayB : string[]
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc int IfIntersect(string $ArrayA[], string $ArrayB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sizeofItems = size($findIntersection);
    string $myIntersector = `stringArrayIntersector`;
    string $findIntersection[] = `stringArrayIntersector -query $myIntersector`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $myIntersector = `stringArrayIntersector`;
    stringArrayIntersector -edit -intersect $ArrayA  $myIntersector;
    stringArrayIntersector -edit -intersect $ArrayB  $myIntersector;
    $findIntersection = `stringArrayIntersector -query $myIntersector`;
    stringArrayIntersector -edit -reset  $myIntersector;
    $sizeofItems = size($findIntersection);
    return $sizeofItems;

}


/******************************************************************************
 * @procedure    PolyBorderEdges
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $polyZ : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] PolyBorderEdges(string $polyZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $PolyFaceZ = ( $polyZ[0] +".f[*]");
    string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
    string $PolyEdgesFromFaceZ[] = ls(" -fl",polyListComponentConversion("- toEdge",$AllPolyFaceZ));
    string $SelectedPolyBorderEdgeZ[] = `ls -sl -fl`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyFaceZ = ( $polyZ[0] +".f[*]");
    $AllPolyFaceZ = `ls -fl $PolyFaceZ`;
    $PolyEdgesFromFaceZ = ls(" -fl",polyListComponentConversion("- toEdge",$AllPolyFaceZ));
    select -r $PolyEdgesFromFaceZ;
    polyConvertToShellBorder;
    $SelectedPolyBorderEdgeZ = `ls -sl -fl`;
    return $SelectedPolyBorderEdgeZ;

}


/******************************************************************************
 * @procedure    GetdiffEdgesOfBorder
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $poly : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] GetdiffEdgesOfBorder(string $poly[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $PolyFaceZ = ( $poly[0] +".f[*]");
    string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
    string $PolyEdgesFromFaceZ[] = ls(" -fl",polyListComponentConversion("- toEdge",$AllPolyFaceZ));
    string $SelectedPolyBorderEdgeZ[] = `ls -sl -fl`;
    string $diffEdgeZ[] = stringArrayRemoveExact ($SelectedPolyBorderEdgeZ, $PolyEdgesFromFaceZ);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyFaceZ = ( $poly[0] +".f[*]");
    $AllPolyFaceZ = `ls -fl $PolyFaceZ`;
    $PolyEdgesFromFaceZ = ls(" -fl",polyListComponentConversion("- toEdge",$AllPolyFaceZ));
    select -r $PolyEdgesFromFaceZ;
    polyConvertToShellBorder;
    $SelectedPolyBorderEdgeZ = `ls -sl -fl`;
    $diffEdgeZ = stringArrayRemoveExact ($SelectedPolyBorderEdgeZ, $PolyEdgesFromFaceZ);
    select -r $diffEdgeZ;
    return $diffEdgeZ;

}


/******************************************************************************
 * @procedure    GetEdgeVertex
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $poly : string
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] GetEdgeVertex(string $poly)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $PolyFaceZ = ( $poly[0] +".f[*]");
    string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
    string $EdgePolyFaceZ[] = `ls -sl -fl`;
    string $PolyEdgelistA[] = ls(" -fl",polyListComponentConversion("-border", "- toVertex", "-fromFace", $EdgePolyFaceZ));
    string $PolyEdgelistB[] = ls(" -fl",polyListComponentConversion( "-toVertex", "- fromFace", $EdgePolyFaceZ));
    string $diffEdgeZ[] = stringArrayRemoveExact ($PolyEdgelistA, $PolyEdgelistB);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyFaceZ = ( $poly[0] +".f[*]");
    $AllPolyFaceZ = `ls -fl $PolyFaceZ`;
    select -r $AllPolyFaceZ;
    polyConvertToShellBorder;
    ConvertSelectionToContainedEdges;
    ConvertSelectionToContainedFaces;
    $EdgePolyFaceZ = `ls -sl -fl`;
    $PolyEdgelistA = ls(" -fl",polyListComponentConversion("-border", "- toVertex", "-fromFace", $EdgePolyFaceZ));
    select -r $PolyEdgelistA;
    $PolyEdgelistB = ls(" -fl",polyListComponentConversion( "-toVertex", "- fromFace", $EdgePolyFaceZ));
    select -r $PolyEdgelistB;
    $diffEdgeZ = stringArrayRemoveExact ($PolyEdgelistA, $PolyEdgelistB);
    select -r $diffEdgeZ;
    return $diffEdgeZ;

}


/******************************************************************************
 * @procedure    stringArrayGmatchIndex
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $itemA : string[]
 *   $list : string[]
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc int stringArrayGmatchIndex(string $itemA[], string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    int $ResultIndex = 0;
    int $Index = 0;
    string $item = $itemA[0];
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $item = $itemA[0];
    $result = false;
    $ResultIndex = 0;
    $Index = 0;
    for ($EachlistItem in $list) {
    if ( $EachlistItem == $item ){
    $result = true; $ResultIndex =  $Index;
    break;	}
    $Index++;
    }
    return $ResultIndex;

}


/******************************************************************************
 * @procedure    SortEvenArrays
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $ArrayItems : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] SortEvenArrays(string $ArrayItems[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $getsize = size($ArrayItems);
    int $i = 0;
    string $newItemsList[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $getsize = size($ArrayItems);
    $i = 0;
    $iX = 0;
    while($i < $getsize){
    $iX++;
    if ( $iX == 2){
    string $oneitem[0] = {$ArrayItems[$i]};
    appendStringArray($newItemsList, $oneitem, 1);
    $iX = 0;
    }
    $i++;
    }
    return $newItemsList;

}


/******************************************************************************
 * @procedure    ArrayFromAllinString
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $list : string
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] ArrayFromAllinString(string $list)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i = 0;
    int $Indexi = 0;
    int $triggerends = 0;
    string $singleStringItemB[];
    string $singleStringItemA[];
    string $listA = $list;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $i = 0;
    $Indexi = 0;
    $triggerends = 0;
    $listA = $list;
    while ( $triggerends < 1 ) {
    $i++;
    $singleStringItemA = {`substring $listA $i $i`};
    if (size($singleStringItemA[0]) == 0){
    $triggerends = 2; } else {
    appendStringArray($singleStringItemB,  $singleStringItemA, 1);
    }
    $Indexi++;
    if ($Indexi == 20){ $triggerends = 2;}
    }
    return $singleStringItemB;

}


/******************************************************************************
 * @procedure    ArrayToIntList
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $singleStringItemB : string[]
 *
 * @returns      int[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc int[] ArrayToIntList(string $singleStringItemB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Numberlist[];
    int $triggerendsB = 0;
    int $newlistSize = size($singleStringItemB);
    int $ci = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $triggerendsB = 0;
    $newlistSize = size($singleStringItemB);
    $ci = 0;
    while ( $triggerendsB < $newlistSize ) {
    $Numberlist[$ci] = $singleStringItemB[$ci];
    $ci++;
    $triggerendsB = $triggerendsB + 1;
    }
    print $Numberlist;
    return $Numberlist;

}


/******************************************************************************
 * @procedure    CycleNumberString
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $singleStringItemC : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] CycleNumberString(string $singleStringItemC[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArray;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArray = size($singleStringItemC) -1;
    string $last[0] = {$singleStringItemC [$SizeOfArray]};
    string $first[0] = {$singleStringItemC[0]};
    stringArrayRemoveAtIndex(0,  $singleStringItemC);
    appendStringArray($singleStringItemC, $first,  1);
    return $singleStringItemC;

}


/******************************************************************************
 * @procedure    SortPatternArrays
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $ArrayItems : string[]
 *   $NumberlistA : int[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SortPatternArrays(string $ArrayItems[], int $NumberlistA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $getsizeNlist = size($NumberlistA);
    int $iN = 0;
    int $getsize = size($ArrayItems);
    int $i = 0;
    string $newItemsList[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $getsizeNlist = size($NumberlistA);
    $iN = 0;
    $getsize = size($ArrayItems);
    $i = 0;
    $iX = 0;
    while($i < $getsize){
    $iX++;
    if ( $NumberlistA[$iN] == 0){
    string $oneitem[0] = {$ArrayItems[$i]};
    appendStringArray($newItemsList, $oneitem, 1);
    if ( $iN == $getsizeNlist){ $iN = -1;}
    $iX = 0;
    }

    $iN++;
    $i++;
    }
    return $newItemsList;

}


/******************************************************************************
 * @procedure    SortEvenArraysInt
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $ArrayItems : string
 *   $Num : int
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SortEvenArraysInt(string $ArrayItems, int $Num)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $getsize = size($ArrayItems);
    int $i = 0;
    string $newItemsList[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $getsize = size($ArrayItems);
    $i = 0;
    $iX = 0;
    while($i < $getsize){
    $iX++;
    if ( $Num == 2){
    if ( $iX == 2){
    string $oneitem[0] = {$ArrayItems[$i]};
    appendStringArray($newItemsList, $oneitem, 1);
    $iX = 0;
    }
    }

    if ( $Num == 1){
    if ( $iX == 1){
    string $oneitem[0] = {$ArrayItems[$i]};
    appendStringArray($newItemsList, $oneitem, 1);
    }
    if ( $iX == 2){ $iX = 0;}
    }

    $i++;
    }
    return $newItemsList;

}


/******************************************************************************
 * @procedure    CompareCurveIntersect
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $objectLoc : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersect(string $objectLoc[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectLocZ) -1;
    int $Z = size($objectLocZ);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    string $objectLocZ[];
    string $CurveintersectZ;
    string $ItemLists[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $objectLocZ = $objectLoc;
    $X = size($objectLocZ) -1;
    $Z = size($objectLocZ);
    $i = 1;
    $n = -1;
    $n2 = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){
    $CurveintersectZ = `curveIntersect -ch 0 - tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2] `;
    if (size($CurveintersectZ) > 0) {
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
    } else { print "no Intersect"; }
    $n2++;
    }
    }
    return $ItemLists;

}


/******************************************************************************
 * @procedure    CompareCurveIntersectTwoCurves
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $objectLocA : string[]
 *   $objectAll : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersectTwoCurves(string $objectLocA[], string $objectAll[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Z = size($objectLocA) -1;
    int $X = size( $objectAll) -1;
    int $ix = 0;
    int $n2 = 0;
    string $CurveintersectZA;
    string $CurveintersectZB;
    string $ItemLists[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $Z = size($objectLocA) -1;
    $X = size( $objectAll) -1;
    $ix = 0;
    $n2 = 0;

    while ($X > $ix++){
    $CurveintersectZA = `curveIntersect -ch 0 - tolerance 0.001 $objectLocA[0] $objectAll[$n2]`;
    if (size($CurveintersectZA) > 0) {
    $CurveintersectZB = `curveIntersect -ch 0 - tolerance 0.001 $objectLocA[1] $objectAll[$n2]`;
    if (size($CurveintersectZB) > 0) {
    ArrayInsertAtEnd( $ItemLists, $objectAll[$n2]);
    }
    } else { print "no Intersect"; }
    $n2++;

    }
    return $ItemLists;

}


/******************************************************************************
 * @procedure    CompareCurveIntersect4
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $objectLoc : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersect4(string $objectLoc[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectLocZ) -1;
    int $Z = size($objectLocZ);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    string $objectLocZ[];
    string $CurveintersectZ;
    string $ItemLists[];
    string $shorterList[] = stringArrayRemoveDuplicates($ItemLists);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $objectLocZ = $objectLoc;
    $X = size($objectLocZ) -1;
    $Z = size($objectLocZ);
    $i = 1;
    $n = -1;
    $n2 = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){
    $CurveintersectZ = `curveIntersect -ch 0 - tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2] `;
    if (size($CurveintersectZ) > 0) {
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
    } else { print "no Intersect"; }
    $n2++;
    }
    }

    $shorterList = stringArrayRemoveDuplicates($ItemLists);
    $ItemLists = $shorterList;
    return $ItemLists;

}


/******************************************************************************
 * @procedure    CompareCurveIntersect2
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $object : string[]
 *   $objectlist : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersect2(string $object[], string $objectlist[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectlist);
    string $ItemListsA[];
    string $CurveintersectZ = `curveIntersect -ch 0  -tolerance 0.001 $object[0] $objectlist[$ix]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $X = size($objectlist);

    $ix = 0;
    $iz = 1;
    while ($X > $ix++){

    $CurveintersectZ = `curveIntersect -ch 0  -tolerance 0.001 $object[0] $objectlist[$ix]`;
    if (size($CurveintersectZ) > 0) {
    ArrayInsertAtEnd( $ItemListsA, $objectlist[$ix]);
    }
    }
    return $ItemListsA;

}


/******************************************************************************
 * @procedure    CompareCurveIntersect5
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $objectLoc : string[]
 *   $objectLocB : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersect5(string $objectLoc[], string $objectLocB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectLocZ);
    int $Z = size($objectLocB);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    string $objectLocZ[];
    string $CurveintersectZ;
    string $ItemLists[];
    string $shorterList[] = stringArrayRemoveDuplicates($ItemLists);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $objectLocZ = $objectLoc;

    $X = size($objectLocZ) ;

    $Z = size($objectLocB);
    $i = 1;
    $n = -1;
    $n2 = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){
    $CurveintersectZ = `curveIntersect -ch 0 - tolerance 0.001 $objectLocZ[$n] $objectLocB[$n2] `;
    if (size($CurveintersectZ) > 0) {
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
    } else { print "no Intersect"; }
    $n2++;
    }
    }

    $shorterList = stringArrayRemoveDuplicates($ItemLists);
    $ItemLists = $shorterList;
    return $ItemLists;

}


/******************************************************************************
 * @procedure    MakeCIRCLE
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $ObjectCurve : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] MakeCIRCLE(string $ObjectCurve[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $squareA;
    int $squareB;
    float $rotationz[];
    float $translationz[];
    float $bbox[] = `exactWorldBoundingBox  $ObjectCurveduplicate`;
    float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox [2]};
    float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox [5]};
    float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox [2]};
    float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox [5]};
    float $BoxMPointAC[] = MidPointBetween ($BoxPointA, $BoxPointC);
    float $BoxMPointBD[] = MidPointBetween ($BoxPointB, $BoxPointD);
    float $BoxMPointAD[] = MidPointBetween ($BoxPointA, $BoxPointD);
    float $BoxMPointBC[] = MidPointBetween ($BoxPointB, $BoxPointC);
    float $CrossMPointAB[] = MidPointBetween ($BoxPointA, $BoxPointB);
    float $translationzMiddle[];
    float $distanceA = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointC);
    float $distanceB = PointsGetDistanceFLOAT ($BoxPointB, $BoxPointC);
    float $squarePercentA;
    float $squarePercentB;
    string $CIRCLEX[];
    string $ObjectCurveduplicate[] = `duplicate -rr  $ObjectCurve`;
    string $NewNameZ = `rename $CIRCLEX "$ObjectCurve[0]"`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $ObjectCurveduplicate = `duplicate -rr  $ObjectCurve`;
    setAttr ($ObjectCurveduplicate[0] + ".translate")  0 0 0;
    setAttr ($ObjectCurveduplicate[0] + ".rotate") 0 0 0;
    select -cl  ;
    $rotationz = `xform -q -rotation $ObjectCurve`;
    $translationz = `xform -q -translation  $ObjectCurve`;
    $bbox = `exactWorldBoundingBox  $ObjectCurveduplicate`;
    //print("Bounding box ranges from: " +
    //      $bbox[0] + "," + $bbox[1] + "," + $bbox [2] + ", to " +
    //      $bbox[3] + "," + $bbox[4] + "," + $bbox [5] + ".\n");
    spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
    move -ws $bbox[0] $bbox[1] $bbox[2]  BoxspaceLocatorA;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
    move -ws $bbox[3] $bbox[4] $bbox[5]  BoxspaceLocatorB;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
    move -ws $bbox[3] $bbox[1] $bbox[2]  BoxspaceLocatorC;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
    move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;
    // xform -query -worldSpace -translation;
    /////////////////////////////////////////
    $BoxPointA = {$bbox[0], $bbox[1], $bbox [2]};
    $BoxPointB = {$bbox[3], $bbox[4], $bbox [5]};
    $BoxPointC = {$bbox[3], $bbox[1], $bbox [2]};
    $BoxPointD = {$bbox[0], $bbox[4], $bbox [5]};

    $BoxPointA = `MakeCleanFloats($BoxPointA)`;
    $BoxPointB = `MakeCleanFloats($BoxPointB)`;
    $BoxPointC = `MakeCleanFloats($BoxPointC)`;
    $BoxPointD = `MakeCleanFloats($BoxPointD)`;

    $BoxMPointAC = MidPointBetween ($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween ($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween ($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween ($BoxPointB, $BoxPointC);
    //   MoveObjectSelection($BoxMPointAC);

    $BoxMPointAC = MidPointBetween ($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween ($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween ($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween ($BoxPointB, $BoxPointC);

    $CrossMPointAB = MidPointBetween ($BoxPointA, $BoxPointB);
    move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
    $translationzMiddle = `xform -q -translation  BoxspaceLocatorMiddle`;

    $distanceA = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointC);
    $distanceB = PointsGetDistanceFLOAT ($BoxPointB, $BoxPointC);
    $distanceAverage =  (($distanceA + $distanceB) *  (0.5)) ;
    $radiusX = ( $distanceAverage / 2);
    //if / then
    if ( $distanceA > $distanceAverage) {
    $squarePercentA = (( $distanceAverage /  $distanceA ) * (100));
    }
    if ( $distanceA < $distanceAverage) {
    $squarePercentA = (( $distanceA /  $distanceAverage ) * (100));
    }
    if ( $distanceB > $distanceAverage) {
    $squarePercentB = (( $distanceAverage /  $distanceB ) * (100));
    }
    if ( $distanceB < $distanceAverage) {
    $squarePercentB = (( $distanceB /  $distanceAverage ) * (100));
    }
    /////////////////////
    $squareA = 0;
    $squareB = 0;
    print $squarePercentA ;
    if ( $squarePercentA > 55)  {
    $squareA = (0 + 1);
    } else {
    $squareA = 0;
    }
    print $squareA;
    print $squarePercentB ;
    if ( $squarePercentB > 55)  {
    $squareB = ($squareB + 1);
    } else {
    $squareB = 0;
    }
    $addSquareResults = ($squareA + $squareB);

    circle -nr 0 1 0 -c $translationzMiddle[0]  $translationzMiddle[1] $translationzMiddle[2] -r  $radiusX;
    $CIRCLEX = `ls -sl`;
    $rotationz = `xform -q -rotation $ObjectCurve`;
    setAttr ($CIRCLEX[0] + ".rotateX") $rotationz[0];
    setAttr ($CIRCLEX[0] + ".rotateY") $rotationz[1];
    setAttr ($CIRCLEX[0] + ".rotateZ") $rotationz[2];
    $translationz = `xform -q -translation  $ObjectCurve[0]`;
    setAttr ($CIRCLEX[0] + ".translateX")  $translationz[0];
    setAttr ($CIRCLEX[0] + ".translateY")  $translationz[1];
    setAttr ($CIRCLEX[0] + ".translateZ")  $translationz[2];

    delete $ObjectCurveduplicate  BoxspaceLocatorA BoxspaceLocatorB  BoxspaceLocatorC BoxspaceLocatorD  BoxspaceLocatorMiddle;

    $NewNameZ = `rename $CIRCLEX "$ObjectCurve[0]"`;
    delete $ObjectCurve;
    $CIRCLEX = {$NewNameZ};
    return $CIRCLEX;


}


/******************************************************************************
 * @procedure    CIRCLESCRIPTZ
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $ObjectCurve : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CIRCLESCRIPTZ(string $ObjectCurve[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $squareA;
    int $squareB;
    float $rotationz[];
    float $translationz[];
    float $bbox[] = `exactWorldBoundingBox  $ObjectCurveduplicate`;
    float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox [2]};
    float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox [5]};
    float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox [2]};
    float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox [5]};
    float $BoxMPointAC[] = MidPointBetween ($BoxPointA, $BoxPointC);
    float $BoxMPointBD[] = MidPointBetween ($BoxPointB, $BoxPointD);
    float $BoxMPointAD[] = MidPointBetween ($BoxPointA, $BoxPointD);
    float $BoxMPointBC[] = MidPointBetween ($BoxPointB, $BoxPointC);
    float $CrossMPointAB[] = MidPointBetween ($BoxPointA, $BoxPointB);
    float $translationzMiddle[];
    float $distanceA = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointC);
    float $distanceB = PointsGetDistanceFLOAT ($BoxPointB, $BoxPointC);
    float $squarePercentA;
    float $squarePercentB;
    string $CIRCLEX[];
    string $ObjectCurveduplicate[] = `duplicate -rr  $ObjectCurve`;
    string $NewNameZ = `rename $CIRCLEX "Curve"`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //CIRCLE SCRIPT


    //string $newCircle[] = `CIRCLESCRIPTZ ($drawcurve)`;
    //string $ObjectCurve[] = $drawcurve;

    $ObjectCurveduplicate = `duplicate -rr  $ObjectCurve`;
    setAttr ($ObjectCurveduplicate[0] + ".translate")  0 0 0;
    setAttr ($ObjectCurveduplicate[0] + ".rotate") 0  0 0;
    select -cl  ;
    $rotationz = `xform -q -rotation $ObjectCurve`;
    $translationz = `xform -q -translation  $ObjectCurve`;
    $bbox = `exactWorldBoundingBox  $ObjectCurveduplicate`;
    //print("Bounding box ranges from: " +
    //      $bbox[0] + "," + $bbox[1] + "," + $bbox [2] + ", to " +
    //      $bbox[3] + "," + $bbox[4] + "," + $bbox [5] + ".\n");
    spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
    move -ws $bbox[0] $bbox[1] $bbox[2]  BoxspaceLocatorA;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
    move -ws $bbox[3] $bbox[4] $bbox[5]  BoxspaceLocatorB;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
    move -ws $bbox[3] $bbox[1] $bbox[2]  BoxspaceLocatorC;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
    move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;
    // xform -query -worldSpace -translation;
    /////////////////////////////////////////
    $BoxPointA = {$bbox[0], $bbox[1], $bbox [2]};
    $BoxPointB = {$bbox[3], $bbox[4], $bbox [5]};
    $BoxPointC = {$bbox[3], $bbox[1], $bbox [2]};
    $BoxPointD = {$bbox[0], $bbox[4], $bbox [5]};

    $BoxPointA = `MakeCleanFloats($BoxPointA)`;
    $BoxPointB = `MakeCleanFloats($BoxPointB)`;
    $BoxPointC = `MakeCleanFloats($BoxPointC)`;
    $BoxPointD = `MakeCleanFloats($BoxPointD)`;

    $BoxMPointAC = MidPointBetween ($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween ($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween ($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween ($BoxPointB, $BoxPointC);
    //   MoveObjectSelection($BoxMPointAC);

    $BoxMPointAC = MidPointBetween ($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween ($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween ($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween ($BoxPointB, $BoxPointC);

    $CrossMPointAB = MidPointBetween ($BoxPointA, $BoxPointB);
    move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
    $translationzMiddle = `xform -q -translation  BoxspaceLocatorMiddle`;

    $distanceA = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointC);
    $distanceB = PointsGetDistanceFLOAT ($BoxPointB, $BoxPointC);
    $distanceAverage =  (($distanceA + $distanceB) *  (0.5)) ;
    $radiusX = ( $distanceAverage / 2);
    //if / then
    if ( $distanceA > $distanceAverage) {
    $squarePercentA = (( $distanceAverage /  $distanceA ) * (100));
    }
    if ( $distanceA < $distanceAverage) {
    $squarePercentA = (( $distanceA /  $distanceAverage ) * (100));
    }
    if ( $distanceB > $distanceAverage) {
    $squarePercentB = (( $distanceAverage /  $distanceB ) * (100));
    }
    if ( $distanceB < $distanceAverage) {
    $squarePercentB = (( $distanceB /  $distanceAverage ) * (100));
    }
    /////////////////////
    $squareA = 0;
    $squareB = 0;
    print $squarePercentA ;
    if ( $squarePercentA > 55)  {
    $squareA = (0 + 1);
    } else {
    $squareA = (0);
    }
    print $squareA;
    print $squarePercentB ;
    if ( $squarePercentB > 55)  {
    $squareB = ($squareB + 1);
    } else {
    $squareB = (0);
    }
    $addSquareResults = ($squareA + $squareB);
    if ( $addSquareResults == 2 ){
    circle -nr 0 1 0 -c $translationzMiddle[0]  $translationzMiddle[1] $translationzMiddle[2] -r  $radiusX;
    $CIRCLEX = `ls -sl`;
    $rotationz = `xform -q -rotation $ObjectCurve`;
    setAttr ($CIRCLEX[0] + ".rotateX") $rotationz[0];
    setAttr ($CIRCLEX[0] + ".rotateY") $rotationz[1];
    setAttr ($CIRCLEX[0] + ".rotateZ") $rotationz[2];
    $translationz = `xform -q -translation  $ObjectCurve[0]`;
    setAttr ($CIRCLEX[0] + ".translateX")  $translationz[0];
    setAttr ($CIRCLEX[0] + ".translateY")  $translationz[1];
    setAttr ($CIRCLEX[0] + ".translateZ")  $translationz[2];
    //TEMP CHANGE
    //string $currPanel = `getPanel -withFocus` ,  $camera ;
    //$camera = `modelPanel -q -camera $currPanel`;
    //setAttr ($CIRCLEX[0] + ".rotate") `getAttr  ($ObjectCurve[0] + ".rotate")`;
    delete $ObjectCurve $ObjectCurveduplicate  BoxspaceLocatorA BoxspaceLocatorB  BoxspaceLocatorC BoxspaceLocatorD  BoxspaceLocatorMiddle;
    }
    else {
    delete $ObjectCurveduplicate BoxspaceLocatorA  BoxspaceLocatorB BoxspaceLocatorC  BoxspaceLocatorD BoxspaceLocatorMiddle;
    }
    $NewNameZ = `rename $CIRCLEX "Curve"`;
    $CIRCLEX = {$NewNameZ};
    return $CIRCLEX;


}


/******************************************************************************
 * @procedure    Make_Middle_of_Curve_ParamlocatorZ
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $objectCurveSelected : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Make_Middle_of_Curve_ParamlocatorZ(string $objectCurveSelected[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size  ($objectCurveSelected[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $a = 1;
    float $arclenghtzALL = `arclen  $objectCurveSelected`;
    float $arclenghtzDivide = $arclenghtzALL / 2.0;
    float $step = 10;
    float $t = $a/$step;
    float $arclenghtzparamZ = `eval("arclen" + " " +  $paramANDCurve[0])`;
    float $divZZ = $arclenghtzDivide /  $arclenghtzparamZ;
    float $divZZ2 = $t * $divZZ;
    float $posA[];
    float $posB[];
    float $posC[];
    string $paramlocatorZARC[];
    string $paramANDCurve[] = `paramToCurvePts(  $paramlocatorZARC )`;
    string $CircularArcFromCurve[];
    string $ArcCurve[];
    string $ParentArc[];
    string $MakeArcLocator[];
    string $ArcZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $arclenghtzALL = `arclen  $objectCurveSelected`;
    $arclenghtzDivide = $arclenghtzALL / 2.0;

    $numCVs = `getAttr -size  ($objectCurveSelected[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectCurveSelected[0] +  ".cv[0]") ;
    $CurveSelection[1] = ($objectCurveSelected[0] +  ".cv[" + $numCVrealNum + "]") ;
    $paramlocatorZARC[0] = eval("paramLocator " +   $objectCurveSelected[0] + ".u[" + 0.0 + "]");

    $step = 10;
    $a = 1;
    $t = $a/$step;

    setAttr ( $paramlocatorZARC[0] +  ".localPositionX") $t;
    $paramANDCurve = `paramToCurvePts(  $paramlocatorZARC )`;
    $arclenghtzparamZ = `eval("arclen" + " " +  $paramANDCurve[0])`;

    $divZZ = $arclenghtzDivide /  $arclenghtzparamZ ;
    $divZZ2 = $t * $divZZ ;
    setAttr ( $paramlocatorZARC[0] +  ".localPositionX") $divZZ2;
    ////////////////////// Moved ParamLoc to middle

    $posA = `pointPosition -w $CurveSelection[0]`;
    $posB = `pointPosition -w $paramlocatorZARC[0]`;
    $posC = `pointPosition -w $CurveSelection[1]`;
    $CircularArcFromCurve[0] = `createNode  makeThreePointCircularArc`;
    setAttr ($CircularArcFromCurve[0] + ".pt1")  $posA[0] $posA[1] $posA[2] ;
    setAttr ($CircularArcFromCurve[0] + ".pt2")  $posB[0] $posB[1] $posB[2];
    setAttr ($CircularArcFromCurve[0] + ".pt3")  $posC[0] $posC[1] $posC[2];
    setAttr ($CircularArcFromCurve[0] + ".d") 3;
    setAttr ($CircularArcFromCurve[0] + ".s") 8;
    $ArcCurve[0] = `createNode nurbsCurve` ;
    connectAttr ($CircularArcFromCurve[0] + ".oc")  ($ArcCurve[0] +".cr");
    //delete $objectCurveSelected;
    $ParentArc = `listRelatives -parent $ArcCurve`;
    ResetTranslation($ParentArc);
    $MakeArcLocator = `spaceLocator -p 0 0 0 -n ArcLocator`;
    move -ws $posB[0] $posB[1] $posB[2]  $MakeArcLocator;
    $ConnectLocToPoint2 = `connectAttr -f  ($MakeArcLocator[0] + ".translate") (  $CircularArcFromCurve[0] + ".pt2")`;

    $ArcZ[0] = `rename $ParentArc  $objectCurveSelected`;
    delete $paramlocatorZARC;
    select -r $ArcZ;
    return $ArcZ;


}


/******************************************************************************
 * @procedure    Strait_ARC_or_FreeForm
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $renamed : string[]
 *   $ArcN : float
 *   $StraitN : float
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Strait_ARC_or_FreeForm(string $renamed[], float $ArcN, float $StraitN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $free = 0;
    int $TrueorFalseCircle = `IsCircle`;
    int $straitTrigger = 0;
    int $Cvz = $objectAcurveD01;
    int $Cvz2 = $objectAcurveD02;
    float $objectAcurve01 = arclen ($renamed);
    float $curveEndsDis01 = GetDistanceBetweenCurveEnds($renamed);
    float $PercentENDsDiffL = XpercentLess_thenY ($objectAcurve01, $curveEndsDis01);
    float $objectAcurveD01 = $objectAcurve01 / 1.5;
    float $PercentDiffS;
    float $posA[] = $VectorCurveEndZ[0];
    float $posB[] = $VectorCurveEndZ[1];
    float $objectAcurveL = arclen ($renamed);
    float $objectBcurveL = arclen ($objectB);
    float $PercentDiffL = XpercentLess_thenY ($objectBcurveL, $objectAcurveL);
    float $objectAcurve02 = arclen ($renamed);
    float $objectAcurveD02 = $objectAcurve02 / 1.5;
    string $nameString = $renamed[0];
    string $ParentArc[];
    string $newCircle[] = `MakeCIRCLE($renamed)`;
    string $objectB[];
    string $objectC[];
    string $DeleteCurveA[];
    string $DeleteCurveB[];
    string $CurveBetween[];
    vector $VectorCurveEndZ[] = VecCurveEnds ($renamed);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $free = 0;
    $nameString = $renamed[0];
    SetCurveRotation($nameString);
    //smoothCurve -ch 1 -rpo 1 -s 6.60 ($nameString  +".cv[*]");
    $objectAcurve01 = arclen ($renamed);

    select -r $nameString;
    $TrueorFalseCircle = `IsCircle`;
    if ($TrueorFalseCircle == 1){
    $newCircle = `MakeCIRCLE($renamed)`;
    $ParentArc = $newCircle;
    makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $ParentArc;
    }else{

    $curveEndsDis01 = GetDistanceBetweenCurveEnds($renamed);
    $PercentENDsDiffL = XpercentLess_thenY ($objectAcurve01, $curveEndsDis01);
    $straitTrigger = 0;

    if ( $PercentENDsDiffL < 2 ){ $straitTrigger = 1;  }

    $objectAcurveD01 = $objectAcurve01 / 1.5;
    $Cvz = $objectAcurveD01;
    if( $objectAcurve01 < 1.0){ $Cvz = 4; }
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001 $renamed;




    if ($straitTrigger == 1){
    $VectorCurveEndZ = VecCurveEnds ($renamed);
    $posA = $VectorCurveEndZ[0];
    $posB = $VectorCurveEndZ[1];
    $CurveBetween = MakeCurveBetweenFloats($posA,  $posB);
    ResetTranslation($CurveBetween);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001  $CurveBetween;
    $ParentArc = $CurveBetween; $DeleteCurveA =  $renamed; $DeleteCurveB = $objectB;
    }


    if ( $straitTrigger == 0 ){
    $objectB = Make_Middle_of_Curve_ParamlocatorZ($renamed);
    ResetTranslation($objectB);
    $objectC = {$renamed[0], $objectB[0]};
    ResetTranslationEach($objectC);
    $objectAcurveL = arclen ($renamed);
    $objectBcurveL = arclen ($objectB);
    $PercentDiffL = XpercentLess_thenY ($objectBcurveL, $objectAcurveL);
    if ($PercentDiffL  < $ArcN){

    $ParentArc = $objectB;  $DeleteCurveA = $renamed;
    }else{

    $free = 1;
    $ParentArc = $renamed; $DeleteCurveA = $objectB;  }

    }

    delete $DeleteCurveA;
    rename $ParentArc $nameString;
    $ParentArc[0] = $nameString;


    if ( $free == 1 ){ select -r $ParentArc;  EvalSmoothCurves;
    $nameString = $ParentArc[0];
    $objectAcurve02 = arclen ($renamed);
    $objectAcurveD02 = $objectAcurve02 / 1.5;
    $Cvz2 = $objectAcurveD02;
    if( $objectAcurve01 < 1.0){ $Cvz2 = 4; }
    //rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 - kcp 0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001  $renamed;
    }

    }

    return $ParentArc;


}


/******************************************************************************
 * @procedure    SmoothCurvature4
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $curveM : float
 *   $Steps : int
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvature4(float $curveM, int $Steps)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 3 );
    int $trigger = 0;
    int $Par = 0;
    int $a;
    int $ii = 0;
    int $CVpoints = 0;
    float $curveMin = $curveM;
    float $step = $numEPrealNum2;
    float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = `size  ($CurveSelection)`;
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = {$Newcurvez};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $myCurve = $curves[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = `size  ($CurveSelection)`;
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 3 );
    if ($Steps > 8 ){ $numEPrealNum2 = $Steps; }

    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0  -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
    $trigger = 0;
    $curve = "";
    $curveMin = $curveM;
    while ( $trigger < 1 ){
    $step = $numEPrealNum2;
    $curve = "curve -d 3";

    $Par = 0;
    $ii = 0;
    $CVpoints = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    if ( $CurvatureRadi <=  $curveMin){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
    }

    if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    }
    }
    if ( $CVpoints < 8 ){ $curveMin++; }
    if ( $CVpoints >= 8 ){ $trigger = 1; }

    }

    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    rename $Newcurve $myCurve;
    $Newcurve = {$myCurve};

    return $Newcurve;

}


/******************************************************************************
 * @procedure    SmoothCurvature13
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $curveM : float
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvature13(float $curveM)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 1 );
    int $trigger = 0;
    int $Par = 0;
    int $b = 0;
    int $ii = 0;
    int $a = 0;
    int $CVpoints = 0;
    float $arcL1 = `arclen $curves[0]`;
    float $arcL1B = ( $arcL1 + ((-1) * ( $arcL1 / 10  )));
    float $curveMin = $curveM;
    float $CurvatureRadi2;
    float $step = $numEPrealNum2;
    float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    float $AverageCurvatureRadi = (($CurvatureRadi +  $CurvatureRadi2) / 2);
    float $arcL2 = `arclen $Newcurve[0]`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $crShape[] = `listRelatives -s $curves[0] `;
    string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size  ($CurveSelection);
    string $Newcurve[];
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`;
    string $Newcurvez;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $arcL1 = `arclen $curves[0]`;
    $arcL1B = ( $arcL1 + ((-1) * ( $arcL1 / 10  )));
    $myCurve = $curves[0];
    $crShape = `listRelatives -s $curves[0] `;
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 1 );
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0  -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
    $trigger = 0;
    $curve = "";
    $Par = 0;
    $b = 0;
    $ii = 0;
    $a = 0;
    $curveMin = $curveM;
    while ( $trigger < 1 ){
    $step = $numEPrealNum2;
    $curve = "curve -d 3";
    $CVpoints = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = $a/$step;
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    if ( $Par > 0.0 ){ $b = $a -1; $Par2 = $b/$step;
    $CurvatureRadi2 = `pointOnCurve -top 1  -pr $Par2 -cr $crShape[0]`; }
    $values = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;

    $AverageCurvatureRadi = (($CurvatureRadi +  $CurvatureRadi2) / 2);

    if ( $AverageCurvatureRadi <=  $curveMin){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
    }

    if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    }
    }
    if ( $CVpoints < 8 ){ $curveMin++; }
    if ( $CVpoints > 2 ){
    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    $arcL2 = `arclen $Newcurve[0]`;
    if ( $arcL2 < $arcL1B ){ delete $Newcurve;  $trigger = 0; $numEPrealNum2 = $numEPrealNum2 +  3;   }
    if (( $CVpoints >= 8 )&& ( $arcL2 > $arcL1B )){  $trigger = 1; }
    }
    }

    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    rename $Newcurve $myCurve;
    $Newcurve = {$myCurve};

    return $Newcurve;

}


/******************************************************************************
 * @procedure    SmoothCurvature3
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $curveM : float
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvature3(float $curveM)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 2 );
    int $Par = 0;
    int $a;
    int $ii = 0;
    int $StepZNum = $numLength;
    float $step = $numEPrealNum2;
    float $curveMin = 8;
    float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    float $numLength = (`arclen $Newcurvez`) +1;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size  ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = {$Newcurvez};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $myCurve = $curves[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 0 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 2 );
    //Above was Times * 4

    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0  -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
    $step = $numEPrealNum2;
    $curve = "curve -d 3";
    $curveMin = 8;
    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    if ( $CurvatureRadi <=  $curveMin){
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
    }

    if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    }

    if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    }
    }

    ///////////////////////////////////////////////// ////
    $Newcurvez = `eval($curve)`;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $Newcurvez;
    $numLength = (`arclen $Newcurvez`) +1;
    $StepZNum = $numLength;
    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    ///////////////////////////////////////////////// //////
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s $StepZNum -d 3 -tol 0.001  $Newcurvez;
    $Newcurve = {$Newcurvez};
    rename $Newcurve $curves;
    $Newcurve = {$curves[0]};
    return $Newcurve;

}


/******************************************************************************
 * @procedure    SmoothCurvatureReverse6
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $curveM : float
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvatureReverse6(float $curveM)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 2 );
    int $Par = 0;
    int $a;
    int $ii = 0;
    float $step = $numEPrealNum2;
    float $curveMin = $curveM;
    float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size  ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = {$Newcurvez};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $myCurve = $curves[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 2 );
    //Above was Times * 4

    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0  -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
    $step = $numEPrealNum2;
    $curve = "curve -d 3";
    $curveMin = $curveM;
    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    if ( $CurvatureRadi >=  $curveMin){
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
    }

    if (( $CurvatureRadi < $curveMin) && ( $ii == 1  )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    }


    if (( $CurvatureRadi < $curveMin) && ( $Par ==  1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    }

    }

    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    rename $Newcurve $curves;
    $Newcurve = {$curves[0]};

    return $Newcurve;

}


/******************************************************************************
 * @procedure    XpercentLess_thenY
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Ix : float
 *   $Iy : float
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float XpercentLess_thenY(float $Ix, float $Iy)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $N;
    float $Ni;
    float $PercentA;
    float $PercentB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if ( $Ix > $Iy){
    $Ni = $Ix; $N = $Iy; } else { $N = $Ix;  $Ni =  $Iy; }
    $PercentA = ((float($N) / $Ni) * (100) );
    $PercentB = 100 - $PercentA;
    return $PercentB;

}


/******************************************************************************
 * @procedure    Strait_ARC_or_FreeFormFind
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $renamed : string[]
 *   $ArcN : float
 *   $StraitN : float
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int Strait_ARC_or_FreeFormFind(string $renamed[], float $ArcN, float $StraitN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SAF = 0;
    float $objectAcurve = GET_AREA_OF_CURVE  ($renamed);
    float $objectBcurve = GET_AREA_OF_CURVE  ($objectB);
    float $PercentDiff = XpercentLess_thenY ($objectBcurve, $objectAcurve);
    float $objectAcurveL = arclen ($renamed);
    float $objectBcurveL = arclen ($objectB);
    float $PercentDiffL = XpercentLess_thenY ($objectBcurveL, $objectAcurveL);
    float $PercentAverage = ($PercentDiff +  $PercentDiffL) /2;
    float $posA[] = $VectorCurveEndZ[0];
    float $posB[] = $VectorCurveEndZ[1];
    float $objectCcurveL = arclen ($CurveBetween);
    float $PercentDiffS = XpercentLess_thenY ($objectCcurveL, $objectAcurveL);
    string $nameString = $renamed[0];
    string $ParentArc[];
    string $objectB[] = Make_Middle_of_Curve_ParamlocatorZ($renamed);
    string $objectC[] = {$renamed[0], $objectB[0]};
    string $CurveBetween[] = MakeCurveBetweenFloats ($posA, $posB);
    string $DeleteCurveA[];
    string $DeleteCurveB[];
    vector $VectorCurveEndZ[] = VecCurveEnds ($renamed);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $SAF = 0;
    $nameString = $renamed[0];
    //rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 - kcp 0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001 $renamed;
    $objectB = Make_Middle_of_Curve_ParamlocatorZ($renamed);
    ResetTranslation($objectB);
    $objectC = {$renamed[0], $objectB[0]};
    ResetTranslationEach($objectC);
    $objectAcurve = GET_AREA_OF_CURVE  ($renamed);
    $objectBcurve = GET_AREA_OF_CURVE  ($objectB);
    /////////////////////////

    $PercentDiff = XpercentLess_thenY ($objectBcurve, $objectAcurve);

    $objectAcurveL = arclen ($renamed);
    $objectBcurveL = arclen ($objectB);
    $PercentDiffL = XpercentLess_thenY ($objectBcurveL, $objectAcurveL);
    $PercentAverage = ($PercentDiff +  $PercentDiffL) /2;

    $VectorCurveEndZ = VecCurveEnds ($renamed);
    $posA = $VectorCurveEndZ[0];
    $posB = $VectorCurveEndZ[1];
    $CurveBetween = MakeCurveBetweenFloats ($posA, $posB);
    ResetTranslation($CurveBetween);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001  $CurveBetween;
    $objectCcurveL = arclen ($CurveBetween);
    $PercentDiffS = XpercentLess_thenY ($objectCcurveL, $objectAcurveL);
    print ("PercentDiff_Curve_to_Arc AREA  "+$PercentDiff + "\n");
    print ("PercentDiff_Curve_to_Arc L  "+$PercentDiffL + "\n");
    print (" " + "\n");
    print ("PercentDiff_Curve_to_Arc Average  "+$PercentAverage + "\n");
    print (" " + "\n");
    print ("PercentDiff_Curve_to_STRAIT  "+$PercentDiffS + "\n");


    if (($PercentAverage< $ArcN) && ($PercentDiffS >  $StraitN)){
    print ("ARC Curve"+ "\n"); $SAF = 0;

    }else if ($PercentDiffS < $StraitN){
    print ("STRAIT Curve"+ "\n"); $SAF = 1;

    } else {
    print ("FREEFORM Curve"+ "\n"); $SAF = 2;
    }

    delete $CurveBetween  $objectB;

    return $SAF;


}


/******************************************************************************
 * @procedure    RoundFloat
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $val : float
 *   $dec : float
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float RoundFloat(float $val, float $dec)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $dec = `pow 10 $dec`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $sign = `sign $val`;
    $dec = `pow 10 $dec`;
    $val = (int) (($val + $sign*5/($dec*10))  * $dec);
    $val = ($val / $dec);
    return $val;

}


/******************************************************************************
 * @procedure    IsCircle
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int IsCircle()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IsCircle = 0;
    int $pA1 = PointsEquivalentTol ($CurveCVzero,$BoxPointA);
    int $pA2 = PointsEquivalentTol ($CurveCVLast,$BoxPointA);
    int $pC1 = PointsEquivalentTol ($CurveCVzero,$BoxPointC);
    int $pC2 = PointsEquivalentTol ($CurveCVLast,$BoxPointC);
    int $AorC = 0;
    int $squareA = 0;
    int $squareB = 0;
    float $rotationz[];
    float $translationz[];
    float $ArcLength = `arclen $ObjectCurve[0]`;
    float $bbox[] = `exactWorldBoundingBox  $ObjectCurveduplicate`;
    float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox [2]};
    float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox [5]};
    float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox [2]};
    float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox [5]};
    float $BoxMPointAC[] = MidPointBetween ($BoxPointA, $BoxPointC);
    float $BoxMPointBD[] = MidPointBetween ($BoxPointB, $BoxPointD);
    float $BoxMPointAD[] = MidPointBetween ($BoxPointA, $BoxPointD);
    float $BoxMPointBC[] = MidPointBetween ($BoxPointB, $BoxPointC);
    float $CrossMPointAB[] = MidPointBetween ($BoxPointA, $BoxPointB);
    float $translationzMiddle[];
    float $CurveCVzero[] = GetCurveCVposENDS ($ObjectCurveduplicate, 0);
    float $CurveCVLast[] = GetCurveCVposENDS ($ObjectCurveduplicate, 1);
    float $distanceBetween = PointsGetDistanceFLOAT ($CurveCVzero, $CurveCVLast);
    float $distanceA = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointC);
    float $distanceB = PointsGetDistanceFLOAT ($BoxPointB, $BoxPointC);
    float $distanceC = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointD);
    float $distanceAverage = (($distanceA +  $distanceB) * (0.5));
    float $radiusX = ( $distanceAverage / 2.0);
    float $distanceAverageA = $distanceC;
    float $radiusXA = (($distanceC) * (0.5));
    float $Pi = 3.141593;
    float $circleArc = (($Pi) * ($distanceC));
    float $percentLess = XpercentLess_thenY(  $circleArc, $ArcLength);
    float $squarePercentA;
    float $squarePercentB;
    string $ObjectCurve[];
    string $StraitCurve[];
    string $ObjectCurveduplicate[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //StraitCurves SCRIPT

    $IsCircle = 0;

    $ObjectCurve = `ls -selection`;
    xform -cp;
    resetPivot;
    duplicatePreset (1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1);

    $ObjectCurveduplicate = `ls -selection`;
    setAttr ($ObjectCurveduplicate[0] + ".translate")  0 0 0;
    setAttr ($ObjectCurveduplicate[0] + ".rotate") 0  0 0;
    playButtonStepForward; select -cl  ;

    $rotationz = `xform -q -rotation $ObjectCurve`;
    $translationz = `xform -q -translation  $ObjectCurve`;
    $ArcLength = `arclen $ObjectCurve[0]`;

    $bbox = `exactWorldBoundingBox  $ObjectCurveduplicate`;
    print("Bounding box ranges from: " +
    $bbox[0] + "," + $bbox[1] + "," + $bbox[2]  + ", to " +
    $bbox[3] + "," + $bbox[4] + "," + $bbox[5]  + ".\n");


    spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
    move -ws $bbox[0] $bbox[1] $bbox[2]  BoxspaceLocatorA;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
    move -ws $bbox[3] $bbox[4] $bbox[5]  BoxspaceLocatorB;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
    move -ws $bbox[3] $bbox[1] $bbox[2]  BoxspaceLocatorC;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
    move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;

    // xform -query -worldSpace -translation;


    $BoxPointA = {$bbox[0], $bbox[1], $bbox [2]};
    $BoxPointB = {$bbox[3], $bbox[4], $bbox [5]};
    $BoxPointC = {$bbox[3], $bbox[1], $bbox [2]};
    $BoxPointD = {$bbox[0], $bbox[4], $bbox [5]};

    $BoxPointA = `MakeCleanFloats($BoxPointA)`;
    $BoxPointB = `MakeCleanFloats($BoxPointB)`;
    $BoxPointC = `MakeCleanFloats($BoxPointC)`;
    $BoxPointD = `MakeCleanFloats($BoxPointD)`;

    $BoxMPointAC = MidPointBetween ($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween ($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween ($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween ($BoxPointB, $BoxPointC);
    //   MoveObjectSelection($BoxMPointAC);

    ///////////////////////////////
    ///////////////////////////////

    $CrossMPointAB = MidPointBetween ($BoxPointA, $BoxPointB);

    // BoxspaceLocatorMiddle CHANGES need here in the  future

    $translationzMiddle = $CrossMPointAB;


    $CurveCVzero = GetCurveCVposENDS ($ObjectCurveduplicate, 0);
    $CurveCVLast = GetCurveCVposENDS ($ObjectCurveduplicate, 1);
    $distanceBetween = PointsGetDistanceFLOAT ($CurveCVzero, $CurveCVLast);

    $pA1 = PointsEquivalentTol ($CurveCVzero,$BoxPointA);
    $pA2 = PointsEquivalentTol ($CurveCVLast,$BoxPointA);
    $pC1 = PointsEquivalentTol ($CurveCVzero,$BoxPointC);
    $pC2 = PointsEquivalentTol ($CurveCVLast,$BoxPointC);

    $AorC = 0;
    if (($pA1 == 3) || ($pA2 == 3)){
    $AorC = 1;
    }
    if (($pC1 == 3) || ($pC2 == 3)){
    $AorC = 2;
    }
    $distanceA = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointC);
    $distanceB = PointsGetDistanceFLOAT ($BoxPointB, $BoxPointC);

    $distanceC = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointD);

    $distanceAverage = (($distanceA +  $distanceB) * (0.5)) ;
    $radiusX = ( $distanceAverage / 2.0);

    $distanceAverageA = $distanceC ;
    $radiusXA = (($distanceC) * (0.5)) ;
    // Result: 38.390151 //

    $Pi = 3.141593;
    $circleArc = (($Pi) * ($distanceC));

    $percentLess = XpercentLess_thenY(  $circleArc, $ArcLength);


    if ( $distanceA > $distanceAverage) {
    $squarePercentA = (( $distanceAverage /  $distanceA ) * (100));
    }

    if ( $distanceA < $distanceAverage) {
    $squarePercentA = (( $distanceA /  $distanceAverage ) * (100));
    }

    if ( $distanceB > $distanceAverage) {
    $squarePercentB = (( $distanceAverage /  $distanceB ) * (100));
    }
    if ( $distanceB < $distanceAverage) {
    $squarePercentB = (( $distanceB /  $distanceAverage ) * (100));
    }
    /////////////////////


    $squareA = 0;
    $squareB = 0;
    if ( $squarePercentA > 55){
    $squareA = 1;
    }
    if ( $squarePercentB > 55){
    $squareB =  1;
    }


    $addSquareResults = ($squareA + $squareB);
    if (( $addSquareResults == 2 ) && ( $percentLess  < 12.0 )) {
    $IsCircle = 1;

    } else {
    // Not Diagonal curves
    $IsCircle = 0;
    }

    /*
    setAttr ($StraitCurve[0] + ".rotateX")  $rotationz[0];
    setAttr ($StraitCurve[0] + ".rotateY")  $rotationz[1];
    setAttr ($StraitCurve[0] + ".rotateZ")  $rotationz[2];
    setAttr ($StraitCurve[0] + ".translateX")  $translationz[0];
    setAttr ($StraitCurve[0] + ".translateY")  $translationz[1];
    setAttr ($StraitCurve[0] + ".translateZ")  $translationz[2];
    */

    select -r $ObjectCurveduplicate BoxspaceLocatorA  BoxspaceLocatorB BoxspaceLocatorC  BoxspaceLocatorD BoxspaceLocatorMiddle;
    delete;
    print ("IsCircle " + $IsCircle);
    print ("percentLess " + $percentLess);
    print ("addSquareResults " + $addSquareResults);
    return $IsCircle;


}


/******************************************************************************
 * @procedure    CurveIntersectZX
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $objectcurv : string[]
 *
 * @returns      string
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string CurveIntersectZX(string $objectcurv[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectcurv[0] +  ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    float $EACHCVposA[];
    float $EACHCVposB[];
    float $eachCVpos[];
    float $intersectPoint[] = GetSurfaceIntersectPoint($MakeIntersectCurvez[0], $surfX);
    string $plainName;
    string $digitalSkeleton[];
    string $CurveSelection[];
    string $AllIntersectCurveZ[];
    string $IntersectCurves[];
    string $MakeExtrudeSurface[];
    string $MakeBirailSurface[];
    string $MakeXBetween[];
    string $MakeIntersectCurvez[];
    string $MakespaceLocator[];
    string $surfX = "Xplane";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $numInts = size($digitalSkeleton);
    if ( $numInts > 0 ){
    clear $digitalSkeleton;
    }

    ///////////////GATHER ALL BUILDING  STRUCTURE/////////##

    ///////////////////////////////////////////////// ////##
    $numCVs = `getAttr -size ($objectcurv[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectcurv[0] + ".cv[0]")  ;
    $CurveSelection[1] = ($objectcurv[0] + ".cv[" +  $numCVrealNum + "]") ;
    $numInts = size($AllIntersectCurveZ);
    if ( $numInts > 0 ){
    clear $AllIntersectCurveZ;
    }

    $eachCVpos = `pointPosition -w ( $CurveSelection[0]  )`;
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n  IntersectZLocaterZ3D`;
    $MakeIntersectCurvez[0] = `curve -d 1 -p 0 0 0 -p  12 0 0 -k 0 -k 1 -n IntersectCurve` ;
    appendStringArray($AllIntersectCurveZ,  $MakeIntersectCurvez, 1);
    appendStringArray($digitalSkeleton,  $MakespaceLocator, 1);
    $numInts = size($AllIntersectCurveZ);
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakespaceLocator[0];
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakeIntersectCurvez[0];
    aimConstraint -offset 0 0 0 -weight 0.5 - aimVector -1 0 0 -upVector 0 0 -1 -worldUpType  "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM      $MakeIntersectCurvez[0];

    $EACHCVposA = $eachCVpos;

    $surfX = "Xplane";
    $intersectPoint = GetSurfaceIntersectPoint($MakeIntersectCurvez[0], $surfX);

    $duplicateCamPlain1 = `duplicate -rr LiveSurfaceB`;
    $plainName = $duplicateCamPlain1[0];
    xform -cp $duplicateCamPlain1;
    ResetTranslation($duplicateCamPlain1);
    Move $intersectPoint $duplicateCamPlain1[0];
    extendSurface -ch 0 -em 0 -et 0 -d 100 -jn 1 -rpo 1 -es 2 -ed 2   $duplicateCamPlain1;
    ///

    delete $digitalSkeleton;
    return $plainName;

}


/******************************************************************************
 * @procedure    GetSurfaceIntersectPoint
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Curvez : string
 *   $surf : string
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] GetSurfaceIntersectPoint(string $Curvez, string $surf)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $intersectposA[];
    string $objectCurve = $Curvez;
    string $MakeExtrudeSurface[];
    string $iSurf = $MakeExtrudeSurface[0];
    string $surf = "Xplane";
    string $paramlocatorZ[];
    string $intersectZ[];
    string $curveIntersectZ[];
    string $buffer[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $objectCurve = $Curvez;
    $MakeExtrudeSurface = `extrude -ch true -rn false -po 0 -et 0 -upn 1 -length 3.000 -rotation 0 -scale 1 -dl 3 -n CURVEZextrude $Curvez` ;
    $iSurf = $MakeExtrudeSurface[0];
    $surf = "Xplane";


    if (catchQuiet($intersectZ = `intersect -ch 0 - cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ  $iSurf $surf `)){
    print "error";
    } else {
    ///////////////GATHER ALL BUILDING  STRUCTURE/////////##
    ///////////////
    $curveIntersectZ[0] = `curveIntersect -ch 0 - tolerance 0.00001 $intersectZ $objectCurve`;
    $numTokens = `tokenize $curveIntersectZ[0] " "  $buffer`;
    $paramlocatorZ[0] = eval("paramLocator " +   $objectCurve + ".u[" + $buffer[1] + "]");

    $intersectposA = `pointPosition -w  $paramlocatorZ[0]`;
    }
    delete $intersectZ $paramlocatorZ;
    delete $MakeExtrudeSurface;
    $intersectposA = `MakeCleanFloats($intersectposA)`;
    return $intersectposA;

}


/******************************************************************************
 * @procedure    EulerAngleofTwoPoints
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $EACHCVposAZ : float[]
 *   $EACHCVposBZ : float[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] EulerAngleofTwoPoints(float $EACHCVposAZ[], float $EACHCVposBZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Z = FindclosetTOcurveENDz($pointB1,  $pointB2, $vector_SubUnitMagVec2);
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $pointCVAB_MidPoint[] = MidPointBetween ($EACHCVposHigher, $EACHCVposLower);
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $curveArclenZ = PointsGetDistanceFLOAT ($EACHCVposAZ, $EACHCVposBZ);
    float $DivideIt = $curveArclenZ / 2.0;
    float $DivideIt2 = $DivideIt * -1;
    float $pointB1[] = {0.0 , 0.0 , $DivideIt};
    float $pointB2[] = {0.0 , 0.0 , $DivideIt2};
    float $EulerAngleA[] = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2   $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2 [1]     $vector_SubUnitMagVec2[2]`;
    float $EulerAngleB[] = `angleBetween -euler -v1  $pointB2[0] $pointB2[1] $pointB2[2] -v2  $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1 [1]     $vector_SubUnitMagVec1[2]`;
    vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher,  $pointCVAB_MidPoint);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposLower,  $pointCVAB_MidPoint);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    if ( $MagVectorZ1 > $MagVectorZ2 ){
    print (" posA is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposAZ;
    $EACHCVposLower = $EACHCVposBZ;
    }
    if ( $MagVectorZ1 < $MagVectorZ2  ){
    print (" posB is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    }
    $pointCVAB_MidPoint = MidPointBetween ($EACHCVposHigher, $EACHCVposLower);
    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher,  $pointCVAB_MidPoint);
    $vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]);
    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposLower,  $pointCVAB_MidPoint);
    $vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]);
    ///////////////////////////////////////////////// ////
    $curveArclenZ = PointsGetDistanceFLOAT ($EACHCVposAZ, $EACHCVposBZ);
    $DivideIt = $curveArclenZ / 2.0;
    $DivideIt2 = $DivideIt * -1;
    $pointB1 = {0.0 , 0.0 , $DivideIt} ;
    $pointB2 = {0.0 , 0.0 , $DivideIt2} ;
    /// NOTE curve ENds will not allways Line up and  may be inverted
    //let $F1 be the first CV $F2 the last .. $F3  third point
    $Z = FindclosetTOcurveENDz($pointB1,  $pointB2, $vector_SubUnitMagVec2);
    if ($Z == 1){ print "new floats"; $pointB1 =  $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
    $EulerAngleA = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2   $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2 [1]     $vector_SubUnitMagVec2[2]`;
    $EulerAngleB = `angleBetween -euler -v1  $pointB2[0] $pointB2[1] $pointB2[2] -v2  $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1 [1]     $vector_SubUnitMagVec1[2]`;

    return $EulerAngleA;

}


/******************************************************************************
 * @procedure    getYrotationOFcam
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] getYrotationOFcam()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $CamerasDirectionVector[];
    float $CamerasPositionz[];
    float $CamLengthVector[];
    float $CP[] = $CamerasPositionz;
    float $CamEulerAngleN[] = {$CamLengthVector[0],  0.0, $CamLengthVector[2]};
    float $CamEulerAngleNi[] = {$CamerasPositionz[0],  0.0, $CamerasPositionz[2]};
    float $CamEulerAngle[] = EulerAngleofTwoPoints ($CamEulerAngleN, $CamEulerAngleNi);
    string $currPanel = `getPanel -withFocus` ,  $camera;
    string $Camera = `modelEditor -q -camera  $currPanel`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    //============================================
    $CamerasDirectionVector = nurbsViewDirectionVector(0);
    //============================================ ;)  nurbsViewDirectionVector =====
    $currPanel = `getPanel -withFocus` ,  $camera ;
    $Camera = `modelEditor -q -camera  $currPanel`;
    $CamerasPositionz = `camera -q -position  $Camera`;
    $CP = $CamerasPositionz;

    $CamLengthVector = AddFloats ($CamerasDirectionVector, $CP);

    $CamEulerAngleN = {$CamLengthVector[0],  0.0, $CamLengthVector[2]};
    $CamEulerAngleNi = {$CamerasPositionz[0],  0.0, $CamerasPositionz[2]};
    $CamEulerAngle = EulerAngleofTwoPoints ($CamEulerAngleN, $CamEulerAngleNi);

    return $CamEulerAngle;

}


/******************************************************************************
 * @procedure    getXrotationOfCam
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] getXrotationOfCam()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $CamerasDirectionVector[];
    float $CamerasPositionz[];
    float $CamLengthVector[];
    float $CP[] = $CamerasPositionz;
    float $CamEulerAngleN[] = {$CamLengthVector[0],  0.0, $CamLengthVector[2]};
    float $CamEulerAngleNi[] = {$CamerasPositionz[0],  0.0, $CamerasPositionz[2]};
    float $CamEulerAngle[] = EulerAngleofTwoPoints ($CamEulerAngleN, $CamEulerAngleNi);
    float $CamEulerAngleX[] = EulerAngleofTwoPoints ($CamLengthVector, $CP);
    string $currPanel = `getPanel -withFocus` ,  $camera;
    string $Camera = `modelEditor -q -camera  $currPanel`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    //============================================
    $CamerasDirectionVector = nurbsViewDirectionVector(0);
    //============================================ ;)  nurbsViewDirectionVector =====
    $currPanel = `getPanel -withFocus` ,  $camera ;
    $Camera = `modelEditor -q -camera  $currPanel`;
    $CamerasPositionz = `camera -q -position  $Camera`;
    $CP = $CamerasPositionz;
    $CamLengthVector = AddFloats ($CamerasDirectionVector, $CP);

    $CamEulerAngleN = {$CamLengthVector[0],  0.0, $CamLengthVector[2]};
    $CamEulerAngleNi = {$CamerasPositionz[0],  0.0, $CamerasPositionz[2]};
    $CamEulerAngle = EulerAngleofTwoPoints ($CamEulerAngleN, $CamEulerAngleNi);

    $CamEulerAngleX = EulerAngleofTwoPoints ($CamLengthVector, $CP);

    //cross is needed
    return $CamEulerAngle;

}


/******************************************************************************
 * @procedure    magF
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $AnglePointA : float[]
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float magF(float $AnglePointA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AnglePointB = mag($AngleP);
    vector $AngleP = << $AnglePointA[0], $AnglePointA[1], $AnglePointA[2] >>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $AngleP = << $AnglePointA[0], $AnglePointA[1], $AnglePointA[2] >>;
    $AnglePointB = mag($AngleP);
    return $AnglePointB;

}


/******************************************************************************
 * @procedure    multiplyFloat
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $posA : float
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] multiplyFloat(float $posA, float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $TimesposA_AND_posB_float = {($posA * $posB[0]),  ($posA * $posB[1]), ($posA * $posB[2])} ;
    return $TimesposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    unitF
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $AnglePointA : float[]
 *
 * @returns      float []
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] unitF(float $AnglePointA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AnglePointB[] = unit($AngleP);
    vector $AngleP = << $AnglePointA[0], $AnglePointA[1], $AnglePointA[2] >>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $AngleP = << $AnglePointA[0], $AnglePointA[1], $AnglePointA[2] >>;
    $AnglePointB = unit($AngleP);
    return $AnglePointB;

}


/******************************************************************************
 * @procedure    RotPoint
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $posF : float[]
 *   $Ax : float[]
 *   $Ndegrees : float
 *
 * @returns      float []
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] RotPoint(float $posF[], float $Ax[], float $Ndegrees)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Roatation[] = $rot_Vec;
    vector $myVec = << $posF[0], $posF[1], $posF[2] >>;
    vector $Axis = << $Ax[0], $Ax[1], $Ax[2] >>;
    vector $rot_Vec = rot($myVec, $Axis, $Ndegrees);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $myVec = << $posF[0], $posF[1], $posF[2] >>;
    $Axis = << $Ax[0], $Ax[1], $Ax[2] >>;
    $rot_Vec = rot($myVec, $Axis, $Ndegrees);
    $Roatation = $rot_Vec;
    return $Roatation;

}


/******************************************************************************
 * @procedure    GetAngleEulerBetween
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $pointA : float[]
 *   $pointB : float[]
 *
 * @returns      float []
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] GetAngleEulerBetween(float $pointA[], float $pointB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AngleEuler[] = `angleBetween -euler -v1 $pointA[0] $pointA[1] $pointA[2] -v2 $pointB[0] $pointB[1] $pointB[2]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $AngleEuler = `angleBetween -euler -v1 $pointA[0] $pointA[1] $pointA[2] -v2 $pointB[0] $pointB[1] $pointB[2]`;
    return $AngleEuler;

}


/******************************************************************************
 * @procedure    ZplainFlatten
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ZplainFlatten()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Y = 0;
    float $CamEulerAngle[] = `getYrotationOFcam`;
    float $CamEulerAngleY = `abs $CamEulerAngle[1]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Y = 0;
    $CamEulerAngle = `getYrotationOFcam`;
    $CamEulerAngleY = `abs $CamEulerAngle[1]`;
    if ($CamEulerAngleY < 22.0){
    $Y = 1; print "Less then 22";
    }
    return $Y;

}


/******************************************************************************
 * @procedure    EulerAngleofCurve
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] EulerAngleofCurve()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    int $Z = FindclosetTOcurveENDz($pointB1,  $pointB2, $vector_SubUnitMagVec2);
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $pointCVAB_MidPoint[] = MidPointBetween ($EACHCVposHigher, $EACHCVposLower);
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $curveArclenZ = `arclen $CurveItem`;
    float $DivideIt = $curveArclenZ / 2.0;
    float $DivideIt2 = $DivideIt * -1;
    float $pointB1[] = {0.0 , 0.0 , $DivideIt};
    float $pointB2[] = {0.0 , 0.0 , $DivideIt2};
    float $EulerAngleA[] = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2   $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2 [1]     $vector_SubUnitMagVec2[2]`;
    float $EulerAngleB[] = `angleBetween -euler -v1  $pointB2[0] $pointB2[1] $pointB2[2] -v2  $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1 [1]     $vector_SubUnitMagVec1[2]`;
    string $CurveItem[];
    string $CurveSelection[];
    vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher,  $pointCVAB_MidPoint);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposLower,  $pointCVAB_MidPoint);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveItem = `ls -sl`;
    $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA   )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    if ( $MagVectorZ1 > $MagVectorZ2 ){
    print (" posA is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposAZ;
    $EACHCVposLower = $EACHCVposBZ;
    }
    if ( $MagVectorZ1 < $MagVectorZ2  ){
    print (" posB is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    }
    $pointCVAB_MidPoint = MidPointBetween ($EACHCVposHigher, $EACHCVposLower);
    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher,  $pointCVAB_MidPoint);
    $vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]);
    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposLower,  $pointCVAB_MidPoint);
    $vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]);
    ///////////////////////////////////////////////// ////
    $curveArclenZ = `arclen $CurveItem`;
    $DivideIt = $curveArclenZ / 2.0;
    $DivideIt2 = $DivideIt * -1;
    $pointB1 = {0.0 , 0.0 , $DivideIt} ;
    $pointB2 = {0.0 , 0.0 , $DivideIt2} ;
    /// NOTE curve ENds will not allways Line up and  may be inverted
    //let $F1 be the first CV $F2 the last .. $F3  third point
    $Z = FindclosetTOcurveENDz($pointB1,  $pointB2, $vector_SubUnitMagVec2);
    if ($Z == 1){ print "new floats"; $pointB1 =  $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
    $EulerAngleA = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2   $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2 [1]     $vector_SubUnitMagVec2[2]`;
    $EulerAngleB = `angleBetween -euler -v1  $pointB2[0] $pointB2[1] $pointB2[2] -v2  $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1 [1]     $vector_SubUnitMagVec1[2]`;

    return $EulerAngleA;

}


/******************************************************************************
 * @procedure    MidPointBetween
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $loc1 : float[]
 *   $loc2 : float[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] MidPointBetween(float $loc1[], float $loc2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $a = ($loc2[0] + $loc1[0]) * (0.5);
    float $b = ($loc2[1] + $loc1[1]) * (0.5);
    float $c = ($loc2[2] + $loc1[2]) * (0.5);
    float $MidPoint[] = {$a , $b , $c};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $a = ($loc2[0] + $loc1[0]) * (0.5);
    $b = ($loc2[1] + $loc1[1]) * (0.5);
    $c = ($loc2[2] + $loc1[2]) * (0.5);

    $MidPoint = {$a , $b , $c};
    return $MidPoint;

}


/******************************************************************************
 * @procedure    PointsEquivalentTol
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int PointsEquivalentTol(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $pX = equivalentTol($posA[0], $posB[0],  0.001);
    int $pY = equivalentTol($posA[1], $posB[1],  0.001);
    int $pZ = equivalentTol($posA[2], $posB[2],  0.001);
    int $addedResults = $pX + $pY + $pZ;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pX = equivalentTol($posA[0], $posB[0],  0.001);
    $pY = equivalentTol($posA[1], $posB[1],  0.001);
    $pZ = equivalentTol($posA[2], $posB[2],  0.001);
    $addedResults = $pX + $pY + $pZ;
    if ($addedResults == 3 ){ print "Points  equivalent";
    }
    return $addedResults;

}


/******************************************************************************
 * @procedure    MagTimesUnitVecs
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $vectorZFlatYHigher : vector
 *   $vectorZFlatYLower : vector
 *
 * @returns      vector[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] MagTimesUnitVecs(vector $vectorZFlatYHigher, vector $vectorZFlatYLower)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MagVectorZYHigher = mag ($vectorZFlatYHigher);
    float $MagVectorZYLower = mag ($vectorZFlatYLower);
    vector $unitVectormagZYHL[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MagVectorZYHigher = mag ($vectorZFlatYHigher);
    $MagVectorZYLower = mag ($vectorZFlatYLower);
    $unitVectormagZYHL[0] = $MagVectorZYHigher *  unit($vectorZFlatYHigher);
    $unitVectormagZYHL[1] = $MagVectorZYLower * unit ($vectorZFlatYLower);
    print $unitVectormagZYHL;
    return $unitVectormagZYHL;

}


/******************************************************************************
 * @procedure    AppendFloatsZ
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *   $XYZ : int
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] AppendFloatsZ(float $posA[], float $posB[], int $XYZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if($XYZ == 0){ $AddposA_AND_posB_float = {$posB [0], $posA[1], $posA[2]} ; }
    if($XYZ == 1){ $AddposA_AND_posB_float = {$posA [0], $posB[1], $posA[2]} ; }
    if($XYZ == 2){ $AddposA_AND_posB_float = {$posA [0], $posA[1], $posB[2]} ; }
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    CycleFloatsZ
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *   $XYZ1 : int
 *   $XYZ2 : int
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] CycleFloatsZ(float $posA[], float $posB[], int $XYZ1, int $XYZ2)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if(($XYZ1 == 0) && ($XYZ2 == 1)){  $AddposA_AND_posB_float = {$posA[1], $posA[0],  $posA[2]} ; } //01 xy
    if(($XYZ1 == 0) && ($XYZ2 == 2)){  $AddposA_AND_posB_float = {$posA[2], $posB[1],  $posA[0]} ; } //02 xz
    if(($XYZ1 == 1) && ($XYZ2 == 2)){  $AddposA_AND_posB_float = {$posA[0], $posA[2],  $posB[1]} ; } //12 yz
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    AddFloats
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] AddFloats(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $AddposA_AND_posB_float = {($posA[0] + $posB[0]),  ($posA[1] + $posB[1]), ($posA[2] + $posB[2])} ;
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    SubtractFloats
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] SubtractFloats(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $SubtractposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SubtractposA_AND_posB_float = {($posA[0] -  $posB[0]), ($posA[1] - $posB[1]), ($posA[2] -  $posB[2])} ;
    return $SubtractposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    Add_Float_to_3PointFloats
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $posA : float
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] Add_Float_to_3PointFloats(float $posA, float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $AddposA_AND_posB_float = {($posA + $posB[0]),  ($posA + $posB[1]), ($posA + $posB[2])} ;
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    SubtractFloat_to_3PointFloats
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $posA : float
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] SubtractFloat_to_3PointFloats(float $posA, float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $SubtractposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SubtractposA_AND_posB_float = {($posA - $posB [0]), ($posA - $posB[1]), ($posA - $posB[2])} ;
    return $SubtractposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    GetDegreesFromFloat
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float GetDegreesFromFloat(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $xy_angle = angle ($xvex, $yvex);
    float $Some_degrees = `rad_to_deg $xy_angle`;
    vector $xvex = << $posA[0], $posA[1], $posA[2] >>;
    vector $yvex = << $posB[0], $posB[1], $posB[2] >>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $xvex = << $posA[0], $posA[1], $posA[2] >>  ;
    $yvex = << $posB[0], $posB[1], $posB[2] >>  ;
    $xy_angle = angle ($xvex, $yvex) ;
    $Some_degrees = `rad_to_deg $xy_angle`;
    print $Some_degrees;
    return $Some_degrees;

}


/******************************************************************************
 * @procedure    GetDistanceBetweenCurveEnds
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $CurveItem : string[]
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float GetDistanceBetweenCurveEnds(string $CurveItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
    string $CurveSelection[];
    string $MakeXBetweenB[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA   )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    $dAx = $EACHCVposAZ[0] - $EACHCVposBZ[0]; $dAy =  $EACHCVposAZ[1] - $EACHCVposBZ[1];
    $dAz = $EACHCVposAZ[2] - $EACHCVposBZ[2]; float  $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    GetDistanceFLOAT
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $objectFirst : string
 *   $objectSecond : string
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float GetDistanceFLOAT(string $objectFirst, string $objectSecond)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $pointAZ1[];
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if (catch($pointAZ1 = `pointPosition -w  ($objectFirst)`)){
    print "using Xform"; $pointAZ1 = `xform -q -ws - rp ($objectFirst)`;
    }
    if (catch($pointAZ2 = `pointPosition -w  ($objectSecond)`)){
    print "using Xform"; $pointAZ1 = `xform -q -ws - rp ($objectSecond)`;
    }
    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy =  $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    PointsGetDistanceFLOAT
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $pointAZ1 : float[]
 *   $pointAZ2 : float[]
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float PointsGetDistanceFLOAT(float $pointAZ1[], float $pointAZ2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy =  $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    getDistance
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $pointAZ1 : float[]
 *   $pointAZ2 : float[]
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float getDistance(float $pointAZ1[], float $pointAZ2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy =  $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    ZeroOrONE
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $objectLoc : string[]
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ZeroOrONE(string $objectLoc[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectLocZ) -1;
    int $Z = size($objectLocZ);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    int $Zero0rOne = 0;
    float $SubtractAB[];
    float $posA[];
    float $posB[];
    string $objectLocZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $objectLocZ = $objectLoc;
    $X = size($objectLocZ) -1;
    $Z = size($objectLocZ);
    $i = 1;
    $n = -1;
    $n2 = 0;
    $Zero0rOne = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){

    $posA = `xform -q -wd -translation  $objectLocZ[$n]`;
    $posB = `xform -q -wd -translation  $objectLocZ[$n2]`;
    $n2++;
    $SubtractAB = SubtractFloats($posA, $posB);
    if (($SubtractAB[0] == 0) && ($SubtractAB[1] ==  0) && ($SubtractAB[2] == 0 )){
    print "yes AB";
    $Zero0rOne = 1;
    }
    }
    }
    return $Zero0rOne;

}


/******************************************************************************
 * @procedure    GetCurveCVposENDS
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $CurveItem : string
 *   $ix : int
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] GetCurveCVposENDS(string $CurveItem, int $ix)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    string $CurveSelection[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA   )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    if ($ix == 0){
    return $EACHCVposAZ; }
    if ($ix == 1){
    return $EACHCVposBZ; }

}


/******************************************************************************
 * @procedure    VecCurveEnds
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $CurveItem : string[]
 *
 * @returns      vector[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] VecCurveEnds(string $CurveItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    string $CurveSelection[];
    vector $VectorCurveEnds[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA   )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    $VectorCurveEnds[0] = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $VectorCurveEnds[1] = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;

    return $VectorCurveEnds;

}


/******************************************************************************
 * @procedure    MakeCurveBetweenFloats
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] MakeCurveBetweenFloats(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $ZBetween[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $ZBetween[0] = `curve -d 1 -p $posA[0] $posA[1]  $posA[2] -p $posB[0] $posB[1] $posB[2] -k 0 -k 2  -n ZCurveBetween`;
    return $ZBetween;

}


/******************************************************************************
 * @procedure    MakeCleanFloats
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $FloatZ : float[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] MakeCleanFloats(float $FloatZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroORZe1 = `gmatch "e" $nameAe`;
    int $zeroORZe2 = `gmatch "e" $nameBe`;
    int $zeroORZe3 = `gmatch "e" $nameCe`;
    string $POSAe = $FloatZ[0];
    string $POSCe = $FloatZ[2];
    string $nameAe;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $POSAe = $FloatZ[0]; string $POSBe =  $FloatZ[1];
    $POSCe = $FloatZ[2];
    $nameAe = `match "e" $POSAe`;
    $nameBe = `match "e" $POSBe`;
    $nameCe = `match "e" $POSCe`;
    $zeroORZe1 = `gmatch "e" $nameAe`;
    $zeroORZe2 = `gmatch "e" $nameBe`;
    $zeroORZe3 = `gmatch "e" $nameCe`;
    if ( $zeroORZe1 == 1){ $FloatZ[0] = 0.0; }
    if ( $zeroORZe2 == 1){ $FloatZ[1] = 0.0; }
    if ( $zeroORZe3 == 1){ $FloatZ[2] = 0.0; }
    return $FloatZ;

}


/******************************************************************************
 * @procedure    MakeCleanFloat1
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $FloatZ : float
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float MakeCleanFloat1(float $FloatZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroORZe1 = `gmatch "e" $nameAe`;
    string $POSAe = $FloatZ;
    string $nameAe;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $POSAe = $FloatZ;
    $nameAe = `match "e" $POSAe`;
    $zeroORZe1 = `gmatch "e" $nameAe`;
    if ( $zeroORZe1 == 1){ $FloatZ = 0.0; }
    return $FloatZ;

}


/******************************************************************************
 * @procedure    paramToCurvePts3
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $locatorShapes : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] paramToCurvePts3(string $locatorShapes[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $numLocators = size($locatorShapes);
    string $curveName[];
    string $parent1[] = `listRelatives -p  $locatorShapes[$i]`;
    string $parent2[] = `listRelatives -p $parent1 [0]`;
    string $parent3[] = `listRelatives -p $parent2 [0]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numLocators = size($locatorShapes);
    for( $i = 0; $i < $numLocators; $i ++ ) {
    // Get the parent transform above the locator  shape
    $parent1 = `listRelatives -p  $locatorShapes[$i]`;
    $parent2 = `listRelatives -p $parent1 [0]`;
    $parent3 = `listRelatives -p $parent2 [0]`;
    $curveName[ size($curveName) ] = $parent3[0];
    }
    return $curveName;

}


/******************************************************************************
 * @procedure    paramToCurvePts2
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $locatorShapes : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] paramToCurvePts2(string $locatorShapes[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $numLocators = size($locatorShapes);
    float $parm;
    float $pos[] = `getAttr ($locatorShapes[$i] + ".localPosition")`;
    float $result[] = `getAttr ($pmm+".output")`;
    string $selectionList[];
    string $curveName;
    string $parent1[] = `listRelatives -p $locatorShapes[$i]`;
    string $parent2[] = `listRelatives -p $parent1[0]`;
    string $pmm;
    string $selectionItem = $curveName + ".u[" + $parm + "]";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $numLocators = size($locatorShapes);
    for( $i = 0; $i < $numLocators; $i ++ ) {
    // Get the parent transform above the locator shape
    $parent1 = `listRelatives -p $locatorShapes[$i]`;

    $parent2 = `listRelatives -p $parent1[0]`;
    $curveName = $parent2[0];
    if( `nodeType $curveName` != "nurbsCurve" ) continue;

    if( !catch($pmm = `createNode pointMatrixMult`) ) {
    $pos = `getAttr ($locatorShapes[$i] + ".localPosition")`;
    $parm = `getAttr ($parent1[0] + ".translateX")`;
    setAttr ($pmm +".inPoint") -type double3  $pos[0] $pos[1] $pos[2];
    setAttr ($pmm +".vectorMultiply") true ;
    connectAttr ($parent1[0]+".worldMatrix[0]") ($pmm+".inMatrix") ;
    $result = `getAttr ($pmm+".output")` ;
    $parm = $result[0];

    $selectionItem = $curveName + ".u[" + $parm + "]";
    $selectionList[ size($selectionList) ] = $selectionItem;

    delete $pmm;
    }
    }
    return $selectionList;

}


/******************************************************************************
 * @procedure    paramToCurvePts
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $locatorShapes : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] paramToCurvePts(string $locatorShapes[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $numLocators = size($locatorShapes);
    float $parm;
    float $pos[] = `getAttr ($locatorShapes[$i] + ".localPosition")`;
    float $result[] = `getAttr ($pmm+".output")`;
    string $selectionList[];
    string $curveName;
    string $parent1[] = `listRelatives -p $locatorShapes[$i]`;
    string $parent2[] = `listRelatives -p $parent1[0]`;
    string $pmm;
    string $selectionItem = $curveName + ".u["  + "0.0" + ":" + $parm + "]";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $numLocators = size($locatorShapes);
    for( $i = 0; $i < $numLocators; $i ++ ) {
    // Get the parent transform above the locator shape
    $parent1 = `listRelatives -p $locatorShapes[$i]`;

    $parent2 = `listRelatives -p $parent1[0]`;
    $curveName = $parent2[0];
    if( `nodeType $curveName` != "nurbsCurve" ) continue;

    if( !catch($pmm = `createNode pointMatrixMult`) ) {
    $pos = `getAttr ($locatorShapes[$i] + ".localPosition")`;
    $parm = `getAttr ($parent1[0] + ".translateX")`;
    setAttr ($pmm +".inPoint") -type double3  $pos[0] $pos[1] $pos[2];
    setAttr ($pmm +".vectorMultiply") true ;
    connectAttr ($parent1[0]+".worldMatrix[0]") ($pmm+".inMatrix") ;
    $result = `getAttr ($pmm+".output")` ;
    $parm = $result[0];

    $selectionItem = $curveName + ".u["  + "0.0" + ":" + $parm + "]";
    $selectionList[ size($selectionList) ] = $selectionItem;

    delete $pmm;
    }
    }
    return $selectionList;

}


/******************************************************************************
 * @procedure    tokenizeparam
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $paramANDCurveZ : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] tokenizeparam(string $paramANDCurveZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $num = size($paramANDCurveZ);
    string $selectionList[];
    string $bufferA[];
    string $selectionItem = $bufferA[0];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $num = size($paramANDCurveZ);
    for( $i = 0; $i < $num; $i ++ ) {
    $numTokensA = `tokenize $paramANDCurveZ[$i] "." $bufferA`;
    $selectionItem = $bufferA[0];
    $selectionList[ size($selectionList) ] = $selectionItem;
    }
    return $selectionList;

}


/******************************************************************************
 * @procedure    EvalMoveCurvesTOend
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $paramANDCurveZ : string[]
 *   $paramCurveNAMEZ : string[]
 *   $paramANDCurve3 : string[]
 *   $AllparamlocatorZ : string[]
 *   $set : string
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] EvalMoveCurvesTOend(string $paramANDCurveZ[], string $paramCurveNAMEZ[], string $paramANDCurve3[], string $AllparamlocatorZ[], string $set)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $iX;
    int $numparamANDCurveNAMEZ = size ($paramCurveNAMEZ);
    int $arclenghtzIntTIMES = ($arclenghtzIntersectZ  * 1000);
    int $arclenghtzTOTALnumTIMEZ = ($arclenghtzALL  *1000);
    int $PercentA;
    int $numCVs = `getAttr -size ($paramCurveNAMEZ [$i] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    float $arclenghtzIntersectZ = `eval("arclen" + "  " + $paramANDCurveZ[$i])`;
    float $arclenghtzALL = `arclen $paramCurveNAMEZ [$i]`;
    string $SEspaceLocSet;
    string $setName = ("SEisnotLocSESet"+$iX);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $iX = -1;
    $numparamANDCurveNAMEZ = size ($paramCurveNAMEZ);

    for( $i = 0; $i < $numparamANDCurveNAMEZ;  $i ++ ) {

    $arclenghtzIntersectZ = `eval("arclen" + "  " + $paramANDCurveZ[$i])`;
    $arclenghtzALL = `arclen $paramCurveNAMEZ [$i]`;

    $arclenghtzIntTIMES = ($arclenghtzIntersectZ  * 1000) ;
    $arclenghtzTOTALnumTIMEZ = ($arclenghtzALL  *1000) ;
    //asume there is only one curve intersect
    $PercentA = ((float($arclenghtzIntTIMES) /  $arclenghtzTOTALnumTIMEZ) * (100) );

    if (( $PercentA > 85 ) || ( $PercentA < 15 )){
    $numCVs = `getAttr -size ($paramCurveNAMEZ [$i] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($paramCurveNAMEZ[$i] +  ".cv[0]") ;
    $CurveSelection[1] = ($paramCurveNAMEZ[$i] +  ".cv[" + $numCVrealNum + "]") ;

    if ( $PercentA > 85 ) {
    // move to curve end
    $MakespaceLocatorEND = `spaceLocator -p 0 0 0 -n  SEspaceLocatorEND3DZ`;
    $eachCVposEND = `pointPosition -w  ($CurveSelection[1])`;
    move  -ws $eachCVposEND[0] $eachCVposEND[1]  $eachCVposEND[2] $MakespaceLocatorEND[0];
    appendStringArray($MakespaceLocatorSE,  $MakespaceLocatorEND, 1);
    }

    if ( $PercentA < 15 ) {
    $MakespaceLocatorSTART = `spaceLocator -p 0 0 0  -n SEspaceLocatorSTART3DZ`;
    $eachCVposSTART = `pointPosition -w  ($CurveSelection[0])`;
    move  -ws $eachCVposSTART[0] $eachCVposSTART[1]  $eachCVposSTART[2] $MakespaceLocatorSTART;
    appendStringArray($MakespaceLocatorSE,  $MakespaceLocatorSTART, 1);

    }
    }

    if (( $PercentA < 85 ) && ( $PercentA > 15 )){
    $iX = $iX +1;
    select -cl;
    print $AllparamlocatorZ[$i];
    print ("_____not near ends_____" + "\n");
    $setName = ("SEisnotLocSESet"+$iX);
    $SEspaceLocSet = `sets -name $setName`;
    sets -include $SEspaceLocSet $paramANDCurve3[$i];
    sets -include $SEspaceLocSet $AllparamlocatorZ [$i];
    sets -include $set $SEspaceLocSet;
    }
    }
    return $MakespaceLocatorSE;

}


/******************************************************************************
 * @procedure    GET_AREA_OF_CURVE
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $obj : string[]
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float GET_AREA_OF_CURVE(string $obj[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numcvs = size($numcvnames);
    float $area = 0;
    float $centroid[] = `xform -q -ws -t ($obj[0])`;
    float $pos0[] = `eval $getpos0`;
    float $pos1[] = `eval $getpos1`;
    float $aP = `distanceBetween {$centroid [0],$centroid[1],$centroid[2]} {$pos0[0],$pos0 [1],$pos0[2]}`;
    float $bP = `distanceBetween {$pos0 [0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1 [2]}`;
    float $cP = `distanceBetween {$pos1 [0],$pos1[1],$pos1[2]} {$centroid[0],$centroid [1],$centroid[2]}`;
    float $triarea = 0.25* sqrt ( ($aP+$bP+$cP)  * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP)  );
    string $CurveItemA = $obj[0];
    string $numcvnames[] = `ls -fl ($CurveItemA+".cv [*]")`;
    string $cvname0 = $obj[0] + ".cv[" + $iC +  "]";
    string $getpos0 = "pointPosition " +  $cvname0;
    string $cvname1 = $obj[0] + ".cv[" + ($iC+1)  + "]";
    string $getpos1 = "pointPosition " +  $cvname1;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $area = 0;
    $centroid = `xform -q -ws -t ($obj[0])`;
    $CurveItemA = $obj[0];
    $numcvnames = `ls -fl ($CurveItemA+".cv [*]")`;
    $numcvs = size($numcvnames);

    for ($iC=0;$iC<$numcvs;$iC++){
    if ($iC<($numcvs-1)){
    $cvname0 = $obj[0] + ".cv[" + $iC +  "]";
    $getpos0 = "pointPosition " +  $cvname0;
    $pos0 = `eval $getpos0`;
    $cvname1 = $obj[0] + ".cv[" + ($iC+1)  + "]";
    $getpos1 = "pointPosition " +  $cvname1;
    $pos1 = `eval $getpos1`;
    $pos0 = `MakeCleanFloats($pos0)`;
    $pos1 = `MakeCleanFloats($pos1)`;

    $aP = `distanceBetween {$centroid [0],$centroid[1],$centroid[2]} {$pos0[0],$pos0 [1],$pos0[2]}`;
    $bP = `distanceBetween {$pos0 [0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1 [2]}`;
    $cP = `distanceBetween {$pos1 [0],$pos1[1],$pos1[2]} {$centroid[0],$centroid [1],$centroid[2]}`;
    $triarea = 0.25* sqrt ( ($aP+$bP+$cP)  * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP)  );
    clear $pos0;
    clear $pos1;
    $area = $area + $triarea;


    } else{
    $cvname0 = $obj[0] + ".cv[" + $iC +  "]";
    $getpos0 = "pointPosition " +  $cvname0;
    $pos0 = `eval $getpos0`;
    $cvname1 = $obj[0] + ".cv[" + ($iC+1)  + "]";
    $getpos1 = "pointPosition " +  $cvname1;
    $pos1 = `eval $getpos1`;
    $pos0 = `MakeCleanFloats($pos0)`;
    $pos1 = `MakeCleanFloats($pos1)`;
    $aP = `distanceBetween {$centroid [0],$centroid[1],$centroid[2]} {$pos0[0],$pos0 [1],$pos0[2]}`;
    $bP = `distanceBetween {$pos0 [0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1 [2]}`;
    $cP = `distanceBetween {$pos1 [0],$pos1[1],$pos1[2]} {$centroid[0],$centroid [1],$centroid[2]}`;
    $triarea = 0.25* sqrt ( ($aP+$bP+$cP)  * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP)  );
    clear $pos0;
    clear $pos1;
    $area = $area + $triarea;
    }
    }
    clear $numcvnames;
    return $area;

}


/******************************************************************************
 * @procedure    Make_Middle_of_Curve_ParamlocatorZ002
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $objectCurveSelected : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Make_Middle_of_Curve_ParamlocatorZ002(string $objectCurveSelected[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size  ($objectCurveSelected[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numCVrealNumDivide = $numCVrealNum / 2;
    int $i = 1;
    float $arclenghtzALL = `arclen  $objectCurveSelected`;
    float $arclenghtzDivide = $arclenghtzALL / 2.0;
    float $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;
    float $arclenghtzHalf = `arclen  ($objectCurveSelected[0] + ".u[0.0:" +  $numCVrealNumDivide + "]")`;
    float $arclenghtzHalfROUNDED = `RoundfloatingPointoff($arclenghtzHalf)`;
    float $iz = 0.0;
    float $iX = float($numCVrealNumDivide);
    float $arclenghtzparamZ = `eval("arclen" + " " +  $paramANDCurve[0])`;
    float $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
    float $posA[];
    float $posB[];
    float $posC[];
    string $paramANDCurve[] = `paramToCurvePts(  $paramlocatorZARC )`;
    string $CircularArcFromCurve[];
    string $ArcCurve[];
    string $ParentArc[];
    string $ArcZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $arclenghtzALL = `arclen  $objectCurveSelected`;
    $arclenghtzDivide = $arclenghtzALL / 2.0;
    $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;
    $numCVs = `getAttr -size  ($objectCurveSelected[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectCurveSelected[0] +  ".cv[0]") ;
    $CurveSelection[1] = ($objectCurveSelected[0] +  ".cv[" + $numCVrealNum + "]") ;
    $numCVrealNumDivide = $numCVrealNum / 2;
    if ($numCVrealNumDivide > 2){ $numCVrealNumDivide  = $numCVrealNumDivide -1; }
    $arclenghtzHalf = `arclen  ($objectCurveSelected[0] + ".u[0.0:" +  $numCVrealNumDivide + "]")`;
    $arclenghtzHalfROUNDED = `RoundfloatingPointoff($arclenghtzHalf)`;
    $iz = 0.0; int $M;
    if ( $arclenghtzDivideROUNDED >  $arclenghtzHalfROUNDED){
    print "Greater_then"; $M = 0;  $iz = 0.01;}
    if ( $arclenghtzDivideROUNDED <  $arclenghtzHalfROUNDED){
    print "Less_then"; $M = 1; $iz = -0.01;}
    $paramlocatorZARC[0] = eval("paramLocator " +   $objectCurveSelected[0] + ".u[" +  $numCVrealNumDivide + "]");
    $iX = float($numCVrealNumDivide);
    $i = 1;
    while ($i > 0){
    $iX = $iX + $iz;
    setAttr ( $paramlocatorZARC[0] +  ".localPositionX") $iX;
    $paramANDCurve = `paramToCurvePts(  $paramlocatorZARC )`;
    $arclenghtzparamZ = `eval("arclen" + " " +  $paramANDCurve[0])`;
    $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
    if($M == 0){
    if (($arclenghtzparamZROUNDED ==  $arclenghtzDivideROUNDED) ||  ($arclenghtzparamZROUNDED >  $arclenghtzDivideROUNDED)){
    $i = 0; }
    }
    if($M == 1){
    if (($arclenghtzparamZROUNDED ==  $arclenghtzDivideROUNDED) ||  ($arclenghtzparamZROUNDED <  $arclenghtzDivideROUNDED)){
    $i = 0; }
    }
    }
    $posA = `pointPosition -w $CurveSelection[0]`;
    $posB = `pointPosition -w $paramlocatorZARC[0]`;
    $posC = `pointPosition -w $CurveSelection[1]`;
    $CircularArcFromCurve[0] = `createNode  makeThreePointCircularArc`;
    setAttr ($CircularArcFromCurve[0] + ".pt1")  $posA[0] $posA[1] $posA[2] ;
    setAttr ($CircularArcFromCurve[0] + ".pt2")  $posB[0] $posB[1] $posB[2];
    setAttr ($CircularArcFromCurve[0] + ".pt3")  $posC[0] $posC[1] $posC[2];
    setAttr ($CircularArcFromCurve[0] + ".d") 3;
    setAttr ($CircularArcFromCurve[0] + ".s") 8;
    $ArcCurve[0] = `createNode nurbsCurve` ;
    connectAttr ($CircularArcFromCurve[0] + ".oc")  ($ArcCurve[0] +".cr");
    //delete $objectCurveSelected;
    $ParentArc = `listRelatives -parent $ArcCurve`;
    ResetTranslation($ParentArc);

    $ArcZ[0] = `rename $ParentArc  $objectCurveSelected`;
    delete $paramlocatorZARC;
    select -r $ArcZ;
    return $ArcZ;


}


/******************************************************************************
 * @procedure    RoundfloatingPointoff
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $floatingPointNumZ : float
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float RoundfloatingPointoff(float $floatingPointNumZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $roundoff = $floatingPointNumZ *100;
    float $roundoff2 = float($roundoff) * 0.01;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $roundoff = $floatingPointNumZ *100;
    $roundoff2 = float($roundoff) * 0.01;
    return $roundoff2;

}


/******************************************************************************
 * @procedure    Make_Middle_of_Curve_ParamlocatorFloat
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $objectCurveSelected : string[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] Make_Middle_of_Curve_ParamlocatorFloat(string $objectCurveSelected[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i = 1;
    float $arclenghtzALL = `arclen  $objectCurveSelected`;
    float $arclenghtzDivide = $arclenghtzALL / 2.0;
    float $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;
    float $iX = 0.00;
    float $posB[];
    float $arclenghtzparamZ = `eval("arclen" + " " +  $paramANDCurve[0])`;
    float $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
    string $posALL[];
    string $paramANDCurve[] = `paramToCurvePts(  $paramlocatorZARC )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $arclenghtzALL = `arclen  $objectCurveSelected`;
    $arclenghtzDivide = $arclenghtzALL / 2.0;
    $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;
    $paramlocatorZARC[0] = eval("paramLocator " +   $objectCurveSelected[0] + ".u[" + 0.00 + "]");
    $iX = 0.00;
    $i = 1;
    while ($i > 0){
    $iX = $iX + 0.01;
    setAttr ( $paramlocatorZARC[0] +  ".localPositionX") $iX;
    $paramANDCurve = `paramToCurvePts(  $paramlocatorZARC )`;
    $arclenghtzparamZ = `eval("arclen" + " " +  $paramANDCurve[0])`;
    $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
    if (($arclenghtzparamZROUNDED ==  $arclenghtzDivideROUNDED) ||  ($arclenghtzparamZROUNDED >  $arclenghtzDivideROUNDED)){
    $i = 0;
    }
    }
    $posB = `pointPosition -w  $paramlocatorZARC[0]`;
    delete $paramlocatorZARC;
    return $posB ;

}


/******************************************************************************
 * @procedure    MidPoint
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $loc1 : float[]
 *   $loc2 : float[]
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] MidPoint(float $loc1[], float $loc2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $a = ($loc2[0] + $loc1[0]) * (0.5);
    float $b = ($loc2[1] + $loc1[1]) * (0.5);
    float $c = ($loc2[2] + $loc1[2]) * (0.5);
    float $vPoint[] = {$a , $b , $c};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $a = ($loc2[0] + $loc1[0]) * (0.5);
    $b = ($loc2[1] + $loc1[1]) * (0.5);
    $c = ($loc2[2] + $loc1[2]) * (0.5);

    $vPoint = {$a , $b , $c};
    return $vPoint;

}


/******************************************************************************
 * @procedure    distanceBetween
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $loc1 : float[]
 *   $loc2 : float[]
 *
 * @returns      float
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float distanceBetween(float $loc1[], float $loc2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $a = `pow ($loc2[0] - $loc1[0]) 2`;
    float $b = `pow ($loc2[1] - $loc1[1]) 2`;
    float $c = `pow ($loc2[2] - $loc1[2]) 2`;
    float $distance = `sqrt ( $a+$b+$c )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $a = `pow ($loc2[0] - $loc1[0]) 2`;
    $b = `pow ($loc2[1] - $loc1[1]) 2`;
    $c = `pow ($loc2[2] - $loc1[2]) 2`;
    $distance = `sqrt ( $a+$b+$c )`;
    return $distance;

}


/******************************************************************************
 * @procedure    MatchIsTrue
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int MatchIsTrue(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    int $XiN = 0;
    string $listItem;
    string $ItemA;
    string $MatchedItem[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    $XiN = 0;
    for ($Eachlist in $list) {
    $ItemA = `match "$item" $Eachlist`;
    if ( `gmatch $ItemA $Eachlist` ==  1){
    $result = true;
    if ($result == true ){ $XiN = 1; $MatchedItem =  {$Eachlist};}
    break;	}
    }


    return $XiN;

}


/******************************************************************************
 * @procedure    FindIfCurveCrossesZ
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $rebuildit : string[]
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindIfCurveCrossesZ(string $rebuildit[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $ZeroOneORTwo;
    int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $zeroOR1Z = `gmatch "-" $nameA`;
    int $zeroOR2Z = `gmatch "-" $nameB`;
    int $zeroOR1Ze = `gmatch "e" $nameAe`;
    int $zeroOR2Ze = `gmatch "e" $nameBe`;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    string $CurveSelection[];
    string $POSA = $EACHCVposAZ[0];
    string $nameA;
    string $POSB = $EACHCVposBZ[0];
    string $nameB;
    string $POSAe = `abs $EACHCVposAZ[0]`;
    string $POSBe = `abs $EACHCVposBZ[0]`;
    string $nameAe;
    string $nameBe;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;
    $CurveSelection[1] = ($rebuildit[0] + ".cv[" +  $numCVrealNum + "]") ;
    $EACHCVposAZ = `pointPosition -w (  $CurveSelection[0]  )`;
    $EACHCVposBZ = `pointPosition -w (  $CurveSelection[1]  )`;
    $POSA = $EACHCVposAZ[0];
    $nameA = `match "-" $POSA`;
    $zeroOR1Z = `gmatch "-" $nameA`;
    $POSB = $EACHCVposBZ[0];
    $nameB = `match "-" $POSB`;
    $zeroOR2Z = `gmatch "-" $nameB`;
    $ZeroOneORTwo = $zeroOR1Z + $zeroOR2Z;
    $POSAe = `abs $EACHCVposAZ[0]`;
    $POSBe = `abs $EACHCVposBZ[0]`;
    $nameAe = `match "e" $POSAe`;
    $nameBe = `match "e" $POSBe`;
    $zeroOR1Ze = `gmatch "e" $nameAe`;
    $zeroOR2Ze = `gmatch "e" $nameBe`;
    if (($zeroOR1Ze == 1 ) || ($zeroOR2Ze == 1 )){
    print "is Zero";
    $ZeroOneORTwo = 0;
    print $ZeroOneORTwo;
    }
    return $ZeroOneORTwo;

}


/******************************************************************************
 * @procedure    GetDistance
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $objectFirst : string
 *   $objectSecond : string
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int GetDistance(string $objectFirst, string $objectSecond)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $distanceA2roundoff;
    float $pointAZ1[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pointAZ1 = `xform -query -worldSpace - translation ($objectFirst)`;
    $pointAZ2 = `xform -query -worldSpace - translation ($objectSecond)`;
    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy =  $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy *  $dAy) + ($dAz * $dAz) )`;
    $distanceA2roundoff = $distanceA2;
    return $distanceA2roundoff;

}


/******************************************************************************
 * @procedure    CutCurveIFConditionTRUETransitZ
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $rebuildit : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CutCurveIFConditionTRUETransitZ(string $rebuildit[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $XiScaleTimes;
    int $XiScale;
    int $ZeroOneORTwoZ = FindIfCurveCrossesZ ($rebuildit);
    int $numTokensZa;
    int $X = 0;
    int $zeroOR1Z = `gmatch "-" $nameA`;
    int $zeroOR2Z = `gmatch "-" $nameB`;
    float $CURVEAposA[];
    float $CURVEA_AREA = `GET_AREA_OF_CURVE ($rebuildit)`;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    string $remainingCurve[];
    string $ZcutingplaneZZ[];
    string $curveIntersectZ[];
    string $intersectZZCUT[];
    string $iSurfZ[] = `extrude -ch 1 -et 0  -l 0.5 -n AxisSelectionZ ( $rebuildit )`;
    string $buffer[];
    string $paramlocatorZ[];
    string $paramANDCurve[];
    string $curvesZ[];
    string $curveZ0[];
    string $curveZ1[];
    string $POSA = $EACHCVposAZ[0];
    string $nameA;
    string $POSB = $EACHCVposBZ[0];
    string $nameB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $ZeroOneORTwoZ = FindIfCurveCrossesZ ($rebuildit);
    if ($ZeroOneORTwoZ == 1){
    $CURVEAposA = `xform -query -worldSpace  -translation $rebuildit[0]`;
    $CURVEA_AREA = `GET_AREA_OF_CURVE ($rebuildit)`;
    $ZcutingplaneZZ = `nurbsPlane -ch on -o on -po 0  -ax 0 1 0 -w 1 -lr 1 -n "ZcutingplaneZZ"`;
    setAttr "ZcutingplaneZZ.rotateZ" 90;
    $XiScale = GetDistance($rebuildit[0],  $ZcutingplaneZZ[0]);
    $XiScaleTimes = ($XiScale * 3) + $CURVEA_AREA;
    scale -r $XiScaleTimes $XiScaleTimes  $XiScaleTimes $ZcutingplaneZZ;
    $iSurfZ = `extrude -ch 1 -et 0  -l 0.5 -n AxisSelectionZ ( $rebuildit )`;
    $intersectZZCUT = `intersect -ch 0 -cos 0 -fs 1  -tol 0.001 -name IntersectSURFACZ $iSurfZ[0]  $ZcutingplaneZZ[0]`;
    select -r $intersectZZCUT;
    $curveIntersectZ[0] = `curveIntersect -ch 0 - tolerance 0.00001 $intersectZZCUT $rebuildit[0]`;
    $numTokensZa = `tokenize $curveIntersectZ[0] " "  $buffer`;
    $paramlocatorZ[0] = `eval("paramLocator " +   $rebuildit[0] + ".u[" + $buffer[1] + "]")`;
    $X = 0;
    $paramANDCurve  = `paramToCurvePts2(  $paramlocatorZ)`;
    $curvesZ = `detachCurve -ch 1 -cos on -rpo 1  $paramANDCurve`;
    $curveZ0[0] = $curvesZ[0];
    $curveZ1[0] = $curvesZ[1];
    ResetTranslation($curveZ0);
    ResetTranslation($curveZ1);
    $EACHCVposAZ = `xform -query -worldSpace  -translation ( $curvesZ[0]  )`;
    $EACHCVposBZ = `xform -query -worldSpace  -translation ( $curvesZ[1]  )`;
    $POSA = $EACHCVposAZ[0];
    $nameA = `match "-" $POSA`;
    $zeroOR1Z = `gmatch "-" $nameA`;
    $POSB = $EACHCVposBZ[0];
    $nameB = `match "-" $POSB`;
    $zeroOR2Z = `gmatch "-" $nameB`;
    if ($zeroOR1Z == 1){
    delete $curvesZ[0];
    $X = 1; }
    if ($zeroOR2Z == 1){
    delete $curvesZ[1];
    $X = 2;}
    if ($X == 2){
    select -r $curvesZ[0]; }
    if ($X == 1){
    select -r $curvesZ[1]; }
    $remainingCurve = `ls -sl`;
    delete $intersectZZCUT $ZcutingplaneZZ  AxisSelectionZ ;
    }
    $rebuildit = $remainingCurve;
    return $remainingCurve;

}


/******************************************************************************
 * @procedure    FindIfCurveISonZ
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $rebuildit : string[]
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindIfCurveISonZ(string $rebuildit[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iZ = 0;
    int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $zeroOR1Z = `gmatch "e"  $ScientNotationNameA`;
    int $zeroOR2Z = `gmatch "e"  $ScientNotationNameB`;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    string $CurveSelection[];
    string $POSA = $EACHCVposAZ[0];
    string $ScientNotationNameA;
    string $POSB = $EACHCVposBZ[0];
    string $ScientNotationNameB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $iZ = 0;
    $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;
    $CurveSelection[1] = ($rebuildit[0] + ".cv[" +  $numCVrealNum + "]") ;
    $EACHCVposAZ = `pointPosition -w (  $CurveSelection[0]  )`;
    $EACHCVposBZ = `pointPosition -w (  $CurveSelection[1]  )`;
    $POSA = $EACHCVposAZ[0];
    $ScientNotationNameA = `match "e" $POSA`;
    $zeroOR1Z = `gmatch "e"  $ScientNotationNameA`;
    if (($EACHCVposAZ[0] == 0) || ($zeroOR1Z == 1)){
    print "yes";
    $iZ = $iZ + 1;
    }
    $POSB = $EACHCVposBZ[0];
    $ScientNotationNameB = `match "e" $POSB`;
    $zeroOR2Z = `gmatch "e"  $ScientNotationNameB`;
    if (($EACHCVposBZ[0] == 0) || ($zeroOR2Z == 1)){
    print "yes";
    $iZ = $iZ + 1;
    }
    return $iZ;

}


/******************************************************************************
 * @procedure    ArrayInsertAtEnd
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $INarray : string[]
 *   $NewItem : string
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ArrayInsertAtEnd(string $INarray[], string $NewItem)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArray;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArray = size($INarray);
    $INarray[$SizeOfArray] = ( $NewItem );
    return $SizeOfArray;

}


/******************************************************************************
 * @procedure    positionOne
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $eachZA : string
 *
 * @returns      float[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] positionOne(string $eachZA)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $eachCVpos[] = `pointPosition -w $eachZA`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $eachCVpos = `pointPosition -w $eachZA`;
    return $eachCVpos;

}


/******************************************************************************
 * @procedure    stringArrayGmatch
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int stringArrayGmatch(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    for ($listItem in $list) {
    if ( `gmatch $listItem $item` ==  1){
    $result = true;
    break;	}
    }
    return $result;

}


/******************************************************************************
 * @procedure    FindclosetTOcurveENDz
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $a1 : float[]
 *   $a2 : float[]
 *   $b1 : float[]
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindclosetTOcurveENDz(float $a1[], float $a2[], float $b1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $binaryAnswer;
    float $distance1;
    float $distance2;
    float $pointA1[];
    float $pointA2[];
    float $pointB1[];
    float $dAx;
    float $dAy;
    float $dAz;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pointA1 = $a1;
    $pointA2 = $b1;
    $dAx = $pointA1[0] - $pointA2[0];
    $dAy = $pointA1[1] - $pointA2[1];
    $dAz = $pointA1[2] - $pointA2[2];
    $distanceA = `sqrt( ($dAx * $dAx) + ($dAy * $dAy)  + ($dAz * $dAz) )`;
    $distance1 = $distanceA;
    $pointB1 = $a2;
    $dAx = $pointB1[0] - $pointA2[0];
    $dAy = $pointB1[1] - $pointA2[1];
    $dAz = $pointB1[2] - $pointA2[2];
    $distanceB = `sqrt( ($dAx * $dAx) + ($dAy * $dAy)  + ($dAz * $dAz) )`;
    $distance2 = $distanceB;
    if ($distance1 < $distance2){
    $binaryAnswer = 0;
    return $binaryAnswer;
    }
    if ( $distance2 < $distance1 ){
    $binaryAnswer = 1;
    return $binaryAnswer;
    }


}


/******************************************************************************
 * @procedure    NearestObjectArray
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $n : int
 *   $ItemsSelectedinArray : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] NearestObjectArray(int $n, string $ItemsSelectedinArray[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $NearestObjectN = $n;
    int $indexN = 0;
    int $NearestObjectNumbers = $NearestObjectN;
    int $array1Number = $array1Count;
    int $curvenumbers = $CompareAllShapesCount;
    float $pointA1[];
    float $pointA2[];
    float $distanceA;
    float $pointB1[];
    float $pointB2[];
    float $distanceB;
    string $NearestCurvesZ[];
    string $array1[] = $ItemsSelectedinArray;
    string $array2[] = $ItemsSelectedinArray;
    string $arrayMainObject1[] = $ItemsSelectedinArray;
    string $array1Count = size ($array1) -1;
    string $diff[] = stringArrayRemoveExact($array1,  $arrayMainObject1);
    string $CompareAllShapesCount = size ($array1);
    string $oneitem[];
    string $arrayLast[] = stringArrayRemoveExact ($oneitem, $arrayMainObject1);
    string $return[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $NearestObjectN = $n;
    $numIntx = size($NearestCurvesZ);
    if ( $numIntx > 0 ){
    clear $NearestCurvesZ;
    }
    $array1 = $ItemsSelectedinArray;
    $array2 = $ItemsSelectedinArray;
    $arrayMainObject1 = $ItemsSelectedinArray;
    $indexN = 0;
    $NearestObjectNumbers = $NearestObjectN;
    $ObjN = -1;
    $ObjN2 = 0;
    while($ObjN++ < $NearestObjectNumbers ){
    $array1Count = size ($array1) -1;
    $array1Number = $array1Count;
    stringArrayRemoveAtIndex($array1Count, $array1);
    $diff = stringArrayRemoveExact($array1,  $arrayMainObject1);
    $CompareAllShapesCount = size ($array1);
    $curvenumbers = $CompareAllShapesCount;
    $i = 1;
    while($i++ < $curvenumbers ){
    //DISTANCE A
    $pointA1 = `xform -query -worldSpace - translation ( $diff)`;
    $pointA2 = `xform -query -worldSpace - translation ($array1[0])`;
    $dAx = $pointA1[0] - $pointA2[0];
    $dAy = $pointA1[1] - $pointA2[1];
    $dAz = $pointA1[2] - $pointA2[2];
    $distanceA = `sqrt( ($dAx * $dAx) + ($dAy * $dAy)  + ($dAz * $dAz) )`;
    //DISTANCE B
    $pointB1 = `xform -query -worldSpace - translation ( $diff)`;
    $pointB2 = `xform -query -worldSpace - translation ( $array1[1])`;
    $dBx = $pointB1[0] - $pointB2[0];
    $dBy = $pointB1[1] - $pointB2[1];
    $dBz = $pointB1[2] - $pointB2[2];
    $distanceB = `sqrt( ($dBx * $dBx) + ($dBy * $dBy)  + ($dBz * $dBz) )`;
    if( $distanceA < $distanceB ){
    stringArrayRemoveAtIndex(1, $array1);
    }
    if( $distanceA > $distanceB ){
    stringArrayRemoveAtIndex(0, $array1);
    }
    }
    appendStringArray($NearestCurvesZ, $array1, 1);
    $oneitem[0] = $array1[0];
    $arrayLast = stringArrayRemoveExact ($oneitem, $arrayMainObject1);
    $array1 = $arrayLast;
    $array2 = $arrayLast;
    $arrayMainObject1 = $arrayLast;
    $indexN++;
    stringArrayInsertAtIndex(($indexN),  $ArrayTwoObjectX, $arrayLast[0]);
    }
    clear $array1;
    clear $array2;
    clear $arrayMainObject1;
    $return = $NearestCurvesZ;
    return $return;

}


/******************************************************************************
 * @procedure    CreateCAMforIntCurveScript
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CreateCAMforIntCurveScript()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectZcurv[0] +  ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $LocatorLoop = 0;
    float $eachCVpos[];
    string $CamConeLocator[];
    string $CurveSelection[];
    string $each;
    string $MakespaceLocator[];
    string $objectZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    CreateCameraOnly;
    rename ZCURVEModelingCAM;
    lookThroughModelPanelClipped ZCURVEModelingCAM  modelPanel4 0.001 1000;
    nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr  1 -n "LiveSurfaceB";
    editDisplayLayerMembers -noRecurse  layerYZYXPlains "LiveSurfaceB";


    //////////////////
    clear $CamConeLocator;
    curve -d 3 -p 0 0 0 -p 0 0 -4 -p 0 0 -8 -p 0 0 - 12 -k 0 -k 0 -k 0 -k 12 -k 12 -k 12 -n  Deletethiscurve ;
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    $objectZcurv = `ls -sl`;
    $numCVs = `getAttr -size ($objectZcurv[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectZcurv[0] + ".cv[0]")  ;
    $CurveSelection[1] = ($objectZcurv[0] + ".cv[" +  $numCVrealNum + "]") ;
    for ($each in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $each  )`;
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n LocatorA`;
    ArrayInsertAtEnd($CamConeLocator,  $MakespaceLocator[0]);
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakespaceLocator[0];
    }
    $LocatorLoop = 0; int $LocatorLoopA = -1;
    while ($LocatorLoop++ < 7) {
    $LocatorLoopA = $LocatorLoopA +1;
    if ($LocatorLoopA == 0){
    clear $objectZ;
    stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
    stringArrayInsertAtIndex(1, $objectZ,  "LocatorA1");
    }
    if ($LocatorLoopA > 0){
    clear $objectZ;
    stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
    stringArrayInsertAtIndex(1, $objectZ,  $MakespaceLocator[0]);
    }
    if ($LocatorLoopA < 7){
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n  LocatorMiddleDistance`;
    ArrayInsertAtEnd($CamConeLocator,  $MakespaceLocator[0]);
    averagingNode($objectZ[0], $MakespaceLocator[0],  $objectZ[1]);
    }
    }
    ArrayInsertAtEnd( $CamConeLocator,  $CamConeLocator[0]);
    stringArrayRemoveAtIndex(0, $CamConeLocator);
    parentConstraint -mo -weight 1 ZCURVEModelingCAM  LocatorA1 ;
    parentConstraint -mo -weight 1 ZCURVEModelingCAM  LocatorA;
    delete  Deletethiscurve;
    align -atl -x Mid -y Mid -z Mid LiveSurfaceB  ZCURVEModelingCAM;

    move -r -os -wd 0 5 5 ZCURVEModelingCAM ;
    setAttr "ZCURVEModelingCAM.rotateX" -45;
    setAttr "LiveSurfaceB.rotateX" (`getAttr  ("ZCURVEModelingCAM" + ".rotateX")`+90);
    setAttr "LiveSurfaceB.rotateY" `getAttr  ("ZCURVEModelingCAM" + ".rotateY")`;
    setAttr "LiveSurfaceB.rotateZ" `getAttr  ("ZCURVEModelingCAM" + ".rotateZ")`;
    align -atl -x Mid -y Mid -z Mid LiveSurfaceB  ZCURVEModelingCAM;
    move -r -os -wd 0 -0.7 0 LiveSurfaceB ;
    move -r -os -wd 0 0 0.210031 LiveSurfaceB ;

    parentConstraint -mo -weight 1 ZCURVEModelingCAM  LiveSurfaceB;
    setAttr "ZCURVEModelingCAM.translateX" 48 ;
    setAttr "ZCURVEModelingCAM.translateY" 41 ;
    setAttr "ZCURVEModelingCAM.translateZ" 48 ;
    setAttr "ZCURVEModelingCAM.rotateX" -25 ;
    setAttr "ZCURVEModelingCAM.rotateY" 45;
    setAttr "ZCURVEModelingCAM.rotateZ" 0;
    return $CamConeLocator;

}


/******************************************************************************
 * @procedure    StartofCurveScriptIntersectZX
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] StartofCurveScriptIntersectZX()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectcurv[0] +  ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    float $EACHCVposA[];
    float $EACHCVposB[];
    float $eachCVpos[];
    string $digitalSkeleton[];
    string $objectcurv[];
    string $CurveSelection[];
    string $AllIntersectCurveZ[];
    string $IntersectCurves[];
    string $MakeExtrudeSurface[];
    string $MakeBirailSurface[];
    string $MakeXBetween[];
    string $MakeIntersectCurvez[];
    string $MakespaceLocator[];
    string $each;
    string $curveFromSurfaceDup[] = `duplicateCurve  -ch 1 -rn 0 -local 0  "SurfaceinterectCurves.u [1]"`;
    string $curveFromSurfaceLoft[] = `loft -ch 1 -u 1  -c 0 -ar 1 -d 3 -ss 4 -rn 1 -po 0 -rsn true -n  IntersectLoftZ $curveFromSurfaceDup[0]      $objectcurv`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    Removefromsurface;

    $numInts = size($digitalSkeleton);
    if ( $numInts > 0 ){
    clear $digitalSkeleton;
    }
    $objectcurv = `ls -sl`;
    ///////////////GATHER ALL BUILDING  STRUCTURE/////////##
    appendStringArray($digitalSkeleton, $objectcurv,  1);
    ///////////////////////////////////////////////// ////##
    $numCVs = `getAttr -size ($objectcurv[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectcurv[0] + ".cv[0]")  ;
    $CurveSelection[1] = ($objectcurv[0] + ".cv[" +  $numCVrealNum + "]") ;
    $numInts = size($AllIntersectCurveZ);
    if ( $numInts > 0 ){
    clear $AllIntersectCurveZ;
    }
    for ($each in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $each   )`;
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n  IntersectZLocaterZ3D`;
    $MakeIntersectCurvez[0] = `curve -d 1 -p 0 0 0 -p  12 0 0 -k 0 -k 1 -n IntersectCurve` ;
    appendStringArray($AllIntersectCurveZ,  $MakeIntersectCurvez, 1);
    appendStringArray($digitalSkeleton,  $MakespaceLocator, 1);
    $numInts = size($AllIntersectCurveZ);
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakespaceLocator[0];
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakeIntersectCurvez[0];
    aimConstraint -offset 0 0 0 -weight 0.5 - aimVector -1 0 0 -upVector 0 0 -1 -worldUpType  "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM      $MakeIntersectCurvez[0];
    if ( $numInts == 1 ){
    $EACHCVposA = $eachCVpos;
    }
    if ( $numInts == 2 ){
    $EACHCVposB = $eachCVpos;
    $MakeXBetween[0] = `curve -d 1 -p $EACHCVposA[0]  $EACHCVposA[1] $EACHCVposA[2] -p $EACHCVposB[0]  $EACHCVposB[1] $EACHCVposB[2] -k 0 -k 2 -n      XCurveBetween`;
    appendStringArray($digitalSkeleton,  $MakeXBetween, 1);
    }
    }
    $MakeExtrudeSurface = `extrude -ch true -rn 0 -po  0 -et 0 -upn 0 -fixedPath 1 -d 0 0 0 -length 3 - rotation 0 -scale 1 -dl 3 -n CURVEZextrude      $objectcurv` ;
    $MakeBirailSurface = `singleProfileBirailSurface  -ch 1 -po 0 -tm 1 -tp1 0 -n SurfaceinterectCurves  CURVEZextrude.v[0] $AllIntersectCurveZ[0]      $AllIntersectCurveZ[1]`;
    $curveFromSurfaceDup = `duplicateCurve  -ch 1 -rn 0 -local 0  "SurfaceinterectCurves.u [1]"` ;
    $curveFromSurfaceLoft = `loft -ch 1 -u 1  -c 0 -ar 1 -d 3 -ss 4 -rn 1 -po 0 -rsn true -n  IntersectLoftZ $curveFromSurfaceDup[0]      $objectcurv` ;
    // GATHER ALL BUILDING STRUCTURE//
    appendStringArray($digitalSkeleton,  $curveFromSurfaceDup, 1);
    appendStringArray($digitalSkeleton,  $curveFromSurfaceLoft, 1);
    appendStringArray($digitalSkeleton,  $MakeExtrudeSurface, 1);
    appendStringArray($digitalSkeleton,  $MakeBirailSurface, 1);
    appendStringArray($digitalSkeleton,  $AllIntersectCurveZ, 2);

    return $digitalSkeleton;

}


/******************************************************************************
 * @procedure    SecondArrayInsertAtEndofArray
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $INarray : string[]
 *   $NewItem : string[]
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int SecondArrayInsertAtEndofArray(string $INarray[], string $NewItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArray;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArray = size($INarray);
    $INarray[$SizeOfArray] = ( $NewItem[0] );
    return $SizeOfArray;

}


/******************************************************************************
 * @procedure    RemoveNoLongerExistingFromArray
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $EdgeCurveZ1 : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] RemoveNoLongerExistingFromArray(string $EdgeCurveZ1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArrayA = size($EdgeCurveZ1);
    int $SizeOfArray = size($EdgeCurveZ1) -1;
    int $i = -1;
    int $E = -1;
    int $SizeOfArrayB = size($EdgeCurveZ1);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArrayA = size($EdgeCurveZ1);
    if ( $SizeOfArrayA > 0){
    $SizeOfArray = size($EdgeCurveZ1) -1;
    $i = -1;
    $E = -1;
    while( $E < $SizeOfArray ){
    $i++;
    $E++;

    if ( `objExists $EdgeCurveZ1[$i]` == 0  ) {
    stringArrayRemoveAtIndex($i, $EdgeCurveZ1);
    if ($i == 0) { $i = -1;} else { $i = $i -1;}
    }

    }
    print $EdgeCurveZ1;
    $SizeOfArrayB = size($EdgeCurveZ1);
    }
    return $EdgeCurveZ1;

}


/******************************************************************************
 * @procedure    MoveZCURVEModelingCAM
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $EdgeCurves : string[]
 *   $ConeLocator : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] MoveZCURVEModelingCAM(string $EdgeCurves[], string $ConeLocator[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $radiusZ;
    int $distanceAzNUM;
    int $loopLocatorsCam = 0;
    int $loopA = -1;
    int $z = -1;
    float $pointA1[];
    float $pointA2[];
    float $distanceAz;
    float $pointAZ1[];
    float $pointAZ2[];
    float $distanceA2;
    string $listofallcurves[];
    string $ObjectsINcamLightCone[];
    string $OutofRange[];
    string $objectZ[];
    string $currentLocatorZ[];
    string $shorterList[] = stringArrayRemoveDuplicates ($ObjectsINcamLightCone);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $listofallcurves = $EdgeCurves;

    layerEditorRemoveObjects layerCurvesINRange1 ;
    editDisplayLayerMembers -noRecurse "defaultLayer"  $ObjectsINcamLightCone;
    layerEditorRemoveObjects layerCurvesOutofRange1 ;
    editDisplayLayerMembers -noRecurse "defaultLayer"  $OutofRange;
    clear $ObjectsINcamLightCone;
    if (size($objectZ) > 0){ clear $objectZ; }
    stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
    stringArrayInsertAtIndex(1, $objectZ,  "LocatorA1");
    $pointA1 = `xform -query -worldSpace - translation ( $objectZ[0])`;
    $pointA2 = `xform -query -worldSpace - translation ($objectZ[1])`;
    $dAx = $pointA1[0] - $pointA2[0];
    $dAy = $pointA1[1] - $pointA2[1];
    $dAz = $pointA1[2] - $pointA2[2];
    $distanceAz = `sqrt( ($dAx * $dAx) + ($dAy *  $dAy) + ($dAz * $dAz) )`;
    $distanceAzNUM = $distanceAz;
    $radiusZ = $distanceAzNUM /2;
    $loopLocatorsCam = 0;
    $loopA = -1;
    $z = -1;
    while ($loopLocatorsCam++ < 7){
    $loopA = $loopA +1;
    if ($loopA > 0){
    $distanceAzNUM = $radiusZ;
    }
    $radiusZ = $distanceAzNUM /2;
    $z = $z +1;
    $currentLocatorZ[0] = $ConeLocator[$z];
    //string all locators in order
    for ($each in $listofallcurves) {
    $pointAZ1 = `xform -query -worldSpace - translation ($currentLocatorZ)`;
    $pointAZ2 = `xform -query -worldSpace - translation ($each)`;
    $dAx = $pointAZ1[0] - $pointAZ2[0];
    $dAy = $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2];
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy *  $dAy) + ($dAz * $dAz) )`;

    if ( $distanceA2 < $radiusZ ){
    stringArrayInsertAtIndex(0,  $ObjectsINcamLightCone, $each);
    }
    }
    }
    $shorterList = stringArrayRemoveDuplicates ($ObjectsINcamLightCone);
    $ObjectsINcamLightCone = $shorterList;
    $OutofRange = stringArrayRemoveExact ($ObjectsINcamLightCone, $listofallcurves);
    editDisplayLayerMembers -noRecurse  layerCurvesOutofRange1 $OutofRange;
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ObjectsINcamLightCone;
    return $ObjectsINcamLightCone;

}


/******************************************************************************
 * @procedure    stringArrayMatch
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int stringArrayMatch(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $item $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ISobjectSelectedTypeCurve2
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ISobjectSelectedTypeCurve2()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    int $zeroOR1A = stringArrayMatch($names1,  $nametypeZ);
    int $zeroOR1B = stringArrayMatch($names2,  $nametypeZ);
    int $zeroOR1C = stringArrayMatch($names3,  $nametypeZ);
    int $zeroOR1D = stringArrayMatch($names4,  $nametypeZ);
    string $C[];
    string $nametypeZ[] = `ls -showType $C`;
    string $names1 = "curve";
    string $names2 = "Curve";
    string $names3 = "cv";
    string $names4 = "ep";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    $C = `ls -sl`;
    $nametypeZ = `ls -showType $C`;
    $names1 = "curve";
    $names2 = "Curve";
    $names3 = "cv";
    $names4 = "ep";
    $zeroOR1A = stringArrayMatch($names1,  $nametypeZ);
    $zeroOR1B = stringArrayMatch($names2,  $nametypeZ);
    $zeroOR1C = stringArrayMatch($names3,  $nametypeZ);
    $zeroOR1D = stringArrayMatch($names4,  $nametypeZ);
    $zeroOR1B = stringArrayMatch($names1,  $nametypeZ);
    if (( $zeroOR1A == 1) || ( $zeroOR1B == 1)){
    if (( $zeroOR1C == 1) || ( $zeroOR1D == 1)){
    $result = false;
    } else { $result = true; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ISobjectSelectedTypeCurve
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ISobjectSelectedTypeCurve()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroOR1Z = `gmatch "Curve" $nameA`;
    string $C[];
    string $nametypeZ[] = `ls -showType $C`;
    string $nameA;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $C = `ls -sl`;
    $nametypeZ = `ls -showType $C`;
    $nameA = `match "[a-zA-Z]+" $nametypeZ[0]`;
    $zeroOR1Z = `gmatch "Curve" $nameA`;
    print $zeroOR1Z;
    return $zeroOR1Z;

}


/******************************************************************************
 * @procedure    ifCurveToolsCTX1
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ifCurveToolsCTX1()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $whichCtx;
    string $list[] = { "pencilContext"};
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $whichCtx = `currentCtx`;
    $list = { "pencilContext"};
    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $whichCtx $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ifCurveToolsCTX2
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ifCurveToolsCTX2()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $whichCtx;
    string $list[] = {"curveContextEP",  "curveAddPtContext"};
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $whichCtx = `currentCtx`;
    $list = {"curveContextEP",  "curveAddPtContext"};
    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $whichCtx $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ifCurveToolsCTX3
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ifCurveToolsCTX3()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $whichCtx;
    string $list[] = {"threePointArcContext"};
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $whichCtx = `currentCtx`;
    $list = {"threePointArcContext"};
    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $whichCtx $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ifCurveToolsCTX4
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ifCurveToolsCTX4()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $whichCtx;
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $whichCtx = `currentCtx`;
    "scaleSuperContext", "xformManipContext",  "softModContext" };
    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $whichCtx $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    addNumbers
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int addNumbers()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CreatedObjectCurve = `ISobjectSelectedTypeCurve`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CreatedObjectCurve = `ISobjectSelectedTypeCurve`;
    return $CreatedObjectCurve;

}


/******************************************************************************
 * @procedure    addedNumbers
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $addNumbersA : int
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int addedNumbers(int $addNumbersA)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numerOfCreatedCurve = `addNumbers`;
    int $numerOfCreated = $numerOfCreatedCurve;
    int $addNumberZ = $addNumbersA +  $numerOfCreatedCurve;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numerOfCreatedCurve = `addNumbers`;
    $numerOfCreated = $numerOfCreatedCurve;
    if ($numerOfCreated == 1){
    $addNumberZ = $addNumbersA +  $numerOfCreatedCurve;
    $addNumbersA = $addNumberZ;
    print $addNumbersA;
    }
    return $addNumbersA;

}


/******************************************************************************
 * @procedure    queryLayerRangeMembers
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] queryLayerRangeMembers()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $query[];
    string $queryOutofRangeLayer[];
    string $queryINRangeLayer[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $queryOutofRangeLayer = `editDisplayLayerMembers  -q layerCurvesOutofRange1`;
    $queryINRangeLayer = `editDisplayLayerMembers -q  layerCurvesINRange1`;
    if (size($queryOutofRangeLayer) > 0){
    appendStringArray($query,  $queryOutofRangeLayer, size ($queryOutofRangeLayer));
    }
    if (size($queryINRangeLayer) > 0){
    appendStringArray($query, $queryINRangeLayer,  size($queryINRangeLayer));
    }
    return $query;

}


/******************************************************************************
 * @procedure    AutoBoundryScript
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $everyFirstCurveShapeset : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] AutoBoundryScript(string $everyFirstCurveShapeset[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $everycurveSize = size ($everyFirstCurveShapeset);
    int $everycurveSizeIndex = size ($everyFirstCurveShapeset) -1;
    int $numberofconnections = size($firstcurveConn);
    int $divide;
    int $switchNumber;
    int $n;
    int $n2 = $n * 2;
    int $ISTRUE0A1;
    int $numIntZZ;
    int $switchNumberA;
    int $ISTRUE0B = catchQuiet($intersectCurveZ1 =  `curveIntersect -ch 0 -ud 0 -tol 0.01  $FirstCurvesZ $eachAB`);
    int $numIntZZZ = size($intersectCurveZ1);
    int $numInts2a;
    int $numIntxZB;
    int $X = 1;
    int $ENDLOOPA;
    int $i = 1;
    int $ENDLOOP;
    int $B = 0;
    int $ISTRUE0A001;
    int $numIntZZA;
    int $numIntZZAB;
    int $ISTRUE0B002;
    int $endtrigger = 0;
    int $numsizeNearest = size($NearestCurvesZ);
    int $boundaryCurvessize = size($boundaryCurves);
    string $EdgeCurveZ[];
    string $EdgeCurveZ2[];
    string $EdgeCurveZ3[];
    string $newallCurves[];
    string $ZnewfoundEdge[];
    string $ZselectedCurve[];
    string $ZfirstcurveRelatives[];
    string $ZfirstcurveConnectionsz[];
    string $Zfirstcurveshapes[];
    string $FirstCurvesZ[];
    string $firstcurveRelatives[];
    string $firstcurveConnectionsz[];
    string $firstcurveshapes[];
    string $firstcurveConn[] = stringArrayRemove ($firstcurveRelatives, $firstcurveshapes);
    string $NearestCurvesZ[] = (NearestObjectArray($n,  $everyFirstCurveShapeset));
    string $NearestCurvesZn2[] = (NearestObjectArray($n2,  $everyFirstCurveShapeset));
    string $TEMPzCurveAAb[];
    string $diff[];
    string $NearestCurvesZA[];
    string $diffremove[];
    string $TEMPAlldiffCurveZBBBB[];
    string $diffX[];
    string $boundaryCurvesAA[];
    string $boundaryCurves[];
    string $boundaryCurves1[];
    string $removecurveAz2[];
    string $removeoneFromeveryFirstA[];
    string $Intersectboundarycurves[];
    string $myIntersector = `stringArrayIntersector`;
    string $Foundboundarycurves[];
    string $selectedCurve[];
    string $objectA[] = `ls -sl`;
    string $removecurveAz[];
    string $removeoneFromeveryFirst[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    clear $EdgeCurveZ2;
    $newallCurves = $everyFirstCurveShapeset;

    for ( $Zeachboundry in $newallCurves ) {
    clear $ZselectedCurve;
    $ZselectedCurve[0] = $Zeachboundry;
    $ZfirstcurveRelatives = `listRelatives -shapes  $ZselectedCurve`;
    $ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
    $Zfirstcurveshapes = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;

    if (size($Zfirstcurveshapes) == 1){
    appendStringArray($ZnewfoundEdge,  $ZselectedCurve, 1);
    }
    if (size($Zfirstcurveshapes) == 0){
    appendStringArray($ZnewfoundEdge,  $ZselectedCurve, 1);
    }
    }
    $everyFirstCurveShapeset = $ZnewfoundEdge;


    $everycurveSize = size ($everyFirstCurveShapeset);
    while( size($everyFirstCurveShapeset) > 3 ){

    $everycurveSizeIndex = size ($everyFirstCurveShapeset) -1;
    $FirstCurvesZ[0] = $everyFirstCurveShapeset [$everycurveSizeIndex];

    $firstcurveRelatives = `listRelatives -shapes  $FirstCurvesZ`;
    $firstcurveConnectionsz = `listConnections  $firstcurveRelatives`;
    $firstcurveshapes = `listConnections -shapes 1  $firstcurveConnectionsz`;
    $firstcurveConn = stringArrayRemove ($firstcurveRelatives, $firstcurveshapes);
    $numberofconnections = size($firstcurveConn);

    if ( $numberofconnections >= 2 ) {
    stringArrayRemoveAtIndex($everycurveSizeIndex,  $everyFirstCurveShapeset);
    $everycurveSizeIndex = size ($everyFirstCurveShapeset) -1;
    $FirstCurvesZ[0] = $everyFirstCurveShapeset [$everycurveSizeIndex];
    }

    $everycurveSize = size ($everyFirstCurveShapeset);
    if (( $everycurveSize < 1000 ) && (  $everycurveSize >= 500 )){
    $divide = $everycurveSize / 50;
    $switchNumber = 0;
    print $divide;}
    if (( $everycurveSize < 500 ) && (  $everycurveSize >= 250 )){
    $divide = $everycurveSize / 25;
    $switchNumber = 0;}
    if (( $everycurveSize < 250 ) && (  $everycurveSize >= 100 )){
    $divide = $everycurveSize / 12; }
    if (( $everycurveSize < 100 ) && (  $everycurveSize >= 50 )){
    $divide = $everycurveSize / 5;
    $switchNumber = 0;}
    if (( $everycurveSize < 50 ) && ( $everycurveSize  >= 20 )){
    $divide =$everycurveSize / 4;
    $switchNumber = 0;}
    if (( $everycurveSize < 20 ) && ( $everycurveSize  > 18 )){
    $divide = $everycurveSize / 2;
    $switchNumber = 0;
    print $divide;
    }
    if ( $everycurveSize <= 18 ){
    $switchNumber = 1;
    }


    switch($switchNumber)

    {
    case 0:
    $n = $divide;
    $NearestCurvesZ = (NearestObjectArray($n,  $everyFirstCurveShapeset));
    $n2 = $n * 2;
    $NearestCurvesZn2 = (NearestObjectArray($n2,  $everyFirstCurveShapeset));
    break;

    case 1:
    $NearestCurvesZ = $everyFirstCurveShapeset;
    $NearestCurvesZn2 = $everyFirstCurveShapeset;
    break;

    }
    print $NearestCurvesZ;
    if ( size($TEMPzCurveAAb) > 0){
    clear $TEMPzCurveAAb;
    }
    for ( $eachZ in $NearestCurvesZ ) {

    $ISTRUE0A1 = catchQuiet($intersectCurveZ0 =  `curveIntersect -ch 0 -ud 0 -tol 0.01  $FirstCurvesZ $eachZ`);
    $numIntZZ = size($intersectCurveZ0);
    if (($ISTRUE0A1 > 0) || ($numIntZZ > 0))  {
    stringArrayInsertAtIndex(0, $TEMPzCurveAAb,  $eachZ);
    }
    }
    $NearestCurvesZ = $TEMPzCurveAAb;
    $numInts2 = size($TEMPzCurveA);
    if ( $numInts2 > 0 ){
    clear $TEMPzCurveA;
    }

    if ( size($diff) > 0){
    clear $diff;
    }
    $diff = stringArrayRemove($NearestCurvesZ,  $NearestCurvesZn2);
    if( size($diff) == 0 ) {
    clear $everyFirstCurveShapeset;
    clear $NearestCurvesZ;
    $switchNumberA = 0;
    } else if( size($diff) > 0 ){
    $switchNumberA = 1;
    }

    if(( size($NearestCurvesZ) == 3 ) &&  ($everycurveSize == 3)) {
    $switchNumberA = 0; }
    switch($switchNumberA)

    {
    case 0:
    print "done";
    break;

    case 1:

    for ( $eachAB in $diff ) {
    $ISTRUE0B = catchQuiet($intersectCurveZ1 =  `curveIntersect -ch 0 -ud 0 -tol 0.01  $FirstCurvesZ $eachAB`);
    $numIntZZZ = size($intersectCurveZ1);
    if (($ISTRUE0B > 0) || ($numIntZZZ > 0))  {
    stringArrayInsertAtIndex(0, $TEMPzCurveA,  $eachAB);
    }
    }
    $numInts2a = size($NearestCurvesZA);
    if ( $numInts2a > 0 ){
    clear $NearestCurvesZA;
    }
    $NearestCurvesZA = stringArrayCatenate ($NearestCurvesZ, $TEMPzCurveA);
    $NearestCurvesZ = $NearestCurvesZA;
    $numInts2a = size($diffremove);
    if ( $numInts2a > 0 ){
    clear $diffremove;
    }
    $diffremove = stringArrayRemove($TEMPzCurveA,  $diff);
    $numInts = size($TEMPAlldiffCurveZBBBB);
    if ( $numInts > 0 ){
    clear $TEMPAlldiffCurveZBBBB;
    }
    $TEMPAlldiffCurveZBBBB = $diffremove;
    ///////////////////////////////////////////////// /////

    clear $boundaryCurves;
    clear $boundaryCurves1;
    $X = 1;
    $i = 1;
    $B = 0;
    $endtrigger = 0;

    while (size($NearestCurvesZ) > 0 ){
    if ( $endtrigger == 2 ){
    clear $NearestCurvesZ;
    size($NearestCurvesZ);
    }
    for ( $each in $NearestCurvesZ ) {
    stringArrayInsertAtIndex(0, $boundaryCurves1,  $each);
    clear $oneboundaryCurve;
    stringArrayInsertAtIndex(0, $oneboundaryCurve,  $boundaryCurves1[0]);
    $X = 1;
    $ENDLOOPA = size($TEMPAlldiffCurveZBBBB);
    for ( $eachA in $TEMPAlldiffCurveZBBBB ) {
    stringArrayInsertAtIndex(0, $boundaryCurves1,  $each);
    clear $oneboundaryCurve;
    stringArrayInsertAtIndex(0, $oneboundaryCurve,  $boundaryCurves1[0]);
    $ISTRUE0A001 = catchQuiet($intersectCurveZ0A  = `curveIntersect -ch 0 -ud 0 -tol 1.0 $each  $eachA`);
    $ENDLOOPA = size($TEMPAlldiffCurveZBBBB);
    $X++;
    $numIntZZA = size($intersectCurveZ0A);
    if ((($ISTRUE0A001 == 0) && ( $X == $ENDLOOPA))  || (($numIntZZA == 0) && ( $X == $ENDLOOPA))) {
    $removecurveAz2[0] = $each;
    $NearestCurvesZ = stringArrayRemove ($removecurveAz2, $NearestCurvesZ);
    } else if (($ISTRUE0A001 > 0) || ($numIntZZA >  0)){
    clear $diffX;
    $diffX = stringArrayRemoveExact ($oneboundaryCurve, $NearestCurvesZ);
    $ENDLOOP = size($diffX);
    for ( $eachB in $diffX ) {
    if ( $endtrigger == 2 ){
    clear $NearestCurvesZ; }
    $ISTRUE0B002 = catchQuiet ($intersectCurveZAB = `curveIntersect -ch 0 -ud 0  -tol 0.001 $eachA $eachB`);
    $numIntZZAB = size($intersectCurveZAB);
    $numsizeNearest = size($NearestCurvesZ);
    if (( $endtrigger == 0 ) && ( $numsizeNearest < 2  )){
    $removeoneFromeveryFirstA = stringArrayRemove ($FirstCurvesZ, $everyFirstCurveShapeset);
    clear $NearestCurvesZ; }
    if (($ISTRUE0B002 > 0) || ($numIntZZAB >  0)) {
    ///////
    $myIntersector = `stringArrayIntersector`;
    clear $Foundboundarycurves;
    stringArrayInsertAtIndex(0, $Foundboundarycurves,  $FirstCurvesZ[0]);
    stringArrayInsertAtIndex(0, $Foundboundarycurves,  $each);
    stringArrayInsertAtIndex(0, $Foundboundarycurves,  $eachA);
    stringArrayInsertAtIndex(0, $Foundboundarycurves,  $eachB);
    for ( $eachboundry in $Foundboundarycurves ) {

    clear $selectedCurve;
    $selectedCurve[0] = $eachboundry;
    $firstcurveRelatives = `listRelatives -shapes  $selectedCurve`;
    $firstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true $firstcurveRelatives`;
    $firstcurveshapes = `listConnections -shapes 1 - type nurbsSurface $firstcurveConnectionsz`;
    stringArrayIntersector -edit -allowDuplicates  false -intersect $firstcurveshapes  $myIntersector;
    }
    $Intersectboundarycurves =  `stringArrayIntersector -query $myIntersector`;

    stringArrayIntersector -edit -reset  $myIntersector;
    if (size($Intersectboundarycurves) == 0){
    ///////
    boundary -ch 1 -or 0 -ep 1 -rn 1 -po 0 - ept 0.1 $FirstCurvesZ $each $eachA $eachB;
    $objectA = `ls -sl`;
    MirrorANDrename($objectA);
    editDisplayLayerMembers -noRecurse  IntersectFormLayerINRange $objectA;


    }
    $endtrigger = $endtrigger +1;
    if ( $endtrigger == 1 || $endtrigger == 2 ) {
    stringArrayInsertAtIndex(0, $boundaryCurves,  $each);
    stringArrayInsertAtIndex(0, $boundaryCurves,  $eachB);
    stringArrayInsertAtIndex(0, $boundaryCurves,  $eachA);
    }
    if ( $endtrigger < 2 ){
    $removecurveAz[0] = $each;
    $removecurveBz[0] = $eachB;
    $removecurveCz[0] = $eachA;
    $NearestCurvesZ = stringArrayRemove ($removecurveAz, $NearestCurvesZ);
    $NearestCurvesZ = stringArrayRemove ($removecurveBz, $NearestCurvesZ);
    $TEMPAlldiffCurveZBBBB = stringArrayRemove($removecurveCz,  $TEMPAlldiffCurveZBBBB);
    else if ( $endtrigger == 2 ){
    clear $NearestCurvesZ; }

    }
    }
    //end of if
    }
    //end of For
    }
    }
    }

    $boundaryCurvessize = size($boundaryCurves);
    if( $boundaryCurvessize > 0 ) {

    for ( $eachboundry in $boundaryCurves ) {
    clear $selectedCurve;
    $selectedCurve[0] = $eachboundry;
    $firstcurveRelatives = `listRelatives -shapes  $selectedCurve`;
    $firstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true $firstcurveRelatives`;
    $firstcurveshapes = `listConnections -shapes 1 - type nurbsSurface $firstcurveConnectionsz`;
    $numberofconnections = size ($firstcurveshapes);
    if ( $numberofconnections == 2 ) {
    $firstcurveConn = stringArrayRemove ($selectedCurve, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset = $firstcurveConn;
    }
    }

    }
    $removeoneFromeveryFirst = stringArrayRemove ($FirstCurvesZ, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset =  $removeoneFromeveryFirst;
    clear $FirstCurvesZ;
    break;
    }

    }
    return $newallCurves;

}


/******************************************************************************
 * @procedure    Make_Middle_of_Curve_ParamlocatorZMirror
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $objectCurveSelected : string[]
 *   $MakeArcLocatorZ : string
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Make_Middle_of_Curve_ParamlocatorZMirror(string $objectCurveSelected[], string $MakeArcLocatorZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size  ($objectCurveSelected[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $a = 1;
    float $arclenghtzALL = `arclen  $objectCurveSelected`;
    float $arclenghtzDivide = $arclenghtzALL / 2.0;
    float $step = 10;
    float $t = $a/$step;
    float $arclenghtzparamZ = `eval("arclen" + " " +  $paramANDCurve[0])`;
    float $divZZ = $arclenghtzDivide /  $arclenghtzparamZ;
    float $divZZ2 = $t * $divZZ;
    float $posA[];
    float $posB[];
    float $posC[];
    string $paramlocatorZARC[];
    string $paramANDCurve[] = `paramToCurvePts(  $paramlocatorZARC )`;
    string $CircularArcFromCurve[];
    string $ArcCurve[];
    string $ParentArc[];
    string $ArcZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $arclenghtzALL = `arclen  $objectCurveSelected`;
    $arclenghtzDivide = $arclenghtzALL / 2.0;
    $numCVs = `getAttr -size  ($objectCurveSelected[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectCurveSelected[0] +  ".cv[0]") ;
    $CurveSelection[1] = ($objectCurveSelected[0] +  ".cv[" + $numCVrealNum + "]") ;
    $paramlocatorZARC[0] = eval("paramLocator " +   $objectCurveSelected[0] + ".u[" + 0.0 + "]");

    $step = 10;
    $a = 1;
    $t = $a/$step;

    setAttr ( $paramlocatorZARC[0] +  ".localPositionX") $t;
    $paramANDCurve = `paramToCurvePts(  $paramlocatorZARC )`;
    $arclenghtzparamZ = `eval("arclen" + " " +  $paramANDCurve[0])`;

    $divZZ = $arclenghtzDivide /  $arclenghtzparamZ ;
    $divZZ2 = $t * $divZZ ;
    setAttr ( $paramlocatorZARC[0] +  ".localPositionX") $divZZ2;
    ////////////////////// Moved ParamLoc to middle

    $posA = `pointPosition -w $CurveSelection[0]`;
    $posB = `pointPosition -w $paramlocatorZARC[0]`;
    $posC = `pointPosition -w $CurveSelection[1]`;
    $CircularArcFromCurve[0] = `createNode  makeThreePointCircularArc`;
    setAttr ($CircularArcFromCurve[0] + ".pt1")  $posA[0] $posA[1] $posA[2] ;
    setAttr ($CircularArcFromCurve[0] + ".pt2")  $posB[0] $posB[1] $posB[2];
    setAttr ($CircularArcFromCurve[0] + ".pt3")  $posC[0] $posC[1] $posC[2];
    setAttr ($CircularArcFromCurve[0] + ".d") 3;
    setAttr ($CircularArcFromCurve[0] + ".s") 8;
    $ArcCurve[0] = `createNode nurbsCurve` ;
    connectAttr ($CircularArcFromCurve[0] + ".oc")  ($ArcCurve[0] +".cr");
    //delete $objectCurveSelected;
    $ParentArc = `listRelatives -parent $ArcCurve`;
    ResetTranslation($ParentArc);
    $ConnectLocToPoint2 = `connectAttr -f  ($MakeArcLocatorZ[0] + ".translate") (  $CircularArcFromCurve[0] + ".pt2")`;
    $ArcZ[0] = `rename $ParentArc  $objectCurveSelected`;
    delete $paramlocatorZARC;
    delete $objectCurveSelected;

    return $ArcZ;


}


/******************************************************************************
 * @procedure    stringArrayGmatchToArray
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] stringArrayGmatchToArray(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $listItem;
    string $MatchedItem[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    for ($listItem in $list) {
    if ( `gmatch $listItem $item` ==  1){
    $result = true;
    if ($result == true ){ $MatchedItem =  {$listItem};}
    break;	}
    }
    return $MatchedItem;

}


/******************************************************************************
 * @procedure    StraitCurvesSCRIPTZ
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] StraitCurvesSCRIPTZ()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $pA1 = PointsEquivalentTol ($CurveCVzero,$BoxPointA);
    int $pA2 = PointsEquivalentTol ($CurveCVLast,$BoxPointA);
    int $pC1 = PointsEquivalentTol ($CurveCVzero,$BoxPointC);
    int $pC2 = PointsEquivalentTol ($CurveCVLast,$BoxPointC);
    int $AorC = 0;
    int $squareA = 0;
    int $squareB = 0;
    int $XZ = 0;
    float $rotationz[];
    float $translationz[];
    float $bbox[] = `exactWorldBoundingBox  $ObjectCurveduplicate`;
    float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox [2]};
    float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox [5]};
    float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox [2]};
    float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox [5]};
    float $BoxMPointAC[] = MidPointBetween ($BoxPointA, $BoxPointC);
    float $BoxMPointBD[] = MidPointBetween ($BoxPointB, $BoxPointD);
    float $BoxMPointAD[] = MidPointBetween ($BoxPointA, $BoxPointD);
    float $BoxMPointBC[] = MidPointBetween ($BoxPointB, $BoxPointC);
    float $CrossMPointAB[] = MidPointBetween ($BoxPointA, $BoxPointB);
    float $translationzMiddle[];
    float $CurveCVzero[] = GetCurveCVposENDS ($ObjectCurveduplicate, 0);
    float $CurveCVLast[] = GetCurveCVposENDS ($ObjectCurveduplicate, 1);
    float $distanceA = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointC);
    float $distanceB = PointsGetDistanceFLOAT ($BoxPointB, $BoxPointC);
    float $distanceAverage = (($distanceA +  $distanceB) * (0.5));
    float $radiusX = ( $distanceAverage / 2.0);
    float $squarePercentA;
    float $squarePercentB;
    string $ObjectCurve[];
    string $StraitCurve[];
    string $ObjectCurveduplicate[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    //StraitCurves SCRIPT 5000

    $ObjectCurve = `ls -selection`;
    xform -cp;
    resetPivot;
    duplicatePreset (1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1);

    $ObjectCurveduplicate = `ls -selection`;
    setAttr ($ObjectCurveduplicate[0] + ".translate")  0 0 0;
    setAttr ($ObjectCurveduplicate[0] + ".rotate") 0  0 0;
    playButtonStepForward; select -cl  ;

    $rotationz = `xform -q -rotation $ObjectCurve`;
    $translationz = `xform -q -translation  $ObjectCurve`;

    $bbox = `exactWorldBoundingBox  $ObjectCurveduplicate`;
    print("Bounding box ranges from: " +
    $bbox[0] + "," + $bbox[1] + "," + $bbox[2]  + ", to " +
    $bbox[3] + "," + $bbox[4] + "," + $bbox[5]  + ".\n");

    spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
    move -ws $bbox[0] $bbox[1] $bbox[2]  BoxspaceLocatorA;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
    move -ws $bbox[3] $bbox[4] $bbox[5]  BoxspaceLocatorB;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
    move -ws $bbox[3] $bbox[1] $bbox[2]  BoxspaceLocatorC;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
    move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;

    // xform -query -worldSpace -translation;


    $BoxPointA = {$bbox[0], $bbox[1], $bbox [2]};
    $BoxPointB = {$bbox[3], $bbox[4], $bbox [5]};
    $BoxPointC = {$bbox[3], $bbox[1], $bbox [2]};
    $BoxPointD = {$bbox[0], $bbox[4], $bbox [5]};

    $BoxPointA = `MakeCleanFloats($BoxPointA)`;
    $BoxPointB = `MakeCleanFloats($BoxPointB)`;
    $BoxPointC = `MakeCleanFloats($BoxPointC)`;
    $BoxPointD = `MakeCleanFloats($BoxPointD)`;

    $BoxMPointAC = MidPointBetween ($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween ($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween ($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween ($BoxPointB, $BoxPointC);
    //   MoveObjectSelection($BoxMPointAC);

    ///////////////////////////////
    ///////////////////////////////

    $CrossMPointAB = MidPointBetween ($BoxPointA, $BoxPointB);
    // BoxspaceLocatorMiddle CHANGES need here in the  future
    $translationzMiddle = $CrossMPointAB;

    $CurveCVzero = GetCurveCVposENDS ($ObjectCurveduplicate, 0);
    $CurveCVLast = GetCurveCVposENDS ($ObjectCurveduplicate, 1);

    $pA1 = PointsEquivalentTol ($CurveCVzero,$BoxPointA);
    $pA2 = PointsEquivalentTol ($CurveCVLast,$BoxPointA);
    $pC1 = PointsEquivalentTol ($CurveCVzero,$BoxPointC);
    $pC2 = PointsEquivalentTol ($CurveCVLast,$BoxPointC);

    $AorC = 0;
    if (($pA1 == 3) || ($pA2 == 3)){
    $AorC = 1;
    }
    if (($pC1 == 3) || ($pC2 == 3)){
    $AorC = 2;
    }
    $distanceA = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointC);
    $distanceB = PointsGetDistanceFLOAT ($BoxPointB, $BoxPointC);
    $distanceAverage = (($distanceA +  $distanceB) * (0.5)) ;
    $radiusX = ( $distanceAverage / 2.0);

    if ( $distanceA > $distanceAverage) {
    $squarePercentA = (( $distanceAverage /  $distanceA ) * (100));
    }
    if ( $distanceA < $distanceAverage) {
    $squarePercentA = (( $distanceA /  $distanceAverage ) * (100));
    }
    if ( $distanceB > $distanceAverage) {
    $squarePercentB = (( $distanceAverage /  $distanceB ) * (100));
    }
    if ( $distanceB < $distanceAverage) {
    $squarePercentB = (( $distanceB /  $distanceAverage ) * (100));
    }
    /////////////////////


    $squareA = 0;
    $squareB = 0;
    if ( $squarePercentA > 55){
    $squareA = 1;
    }
    if ( $squarePercentB > 55){
    $squareB =  1;
    }

    $addSquareResults = ($squareA + $squareB);
    if ( $addSquareResults == 2 ){

    //Eval Diaginal curve
    // USE $radiusX for curve points

    if ( $AorC == 1){
    $StraitCurve[0] = `curve -d 1 -p $BoxPointA[0]  $BoxPointA[1] $BoxPointA[2] -p $BoxPointB[0]  $BoxPointB[1] $BoxPointB[2]`;
    }
    if ( $AorC == 2){
    $StraitCurve[0] = `curve -d 1 -p $BoxPointC[0]  $BoxPointC[1] $BoxPointC[2] -p $BoxPointD[0]  $BoxPointD[1] $BoxPointD[2]`;
    }

    } else {

    // Not Diagonal curves

    $XZ = 0;
    if ( $distanceA > $distanceB) {
    $XZ = 1;
    }
    if ( $distanceA < $distanceB) {
    $XZ = 2;
    }
    if ($XZ == 1){
    //$BoxMPointAD  $BoxMPointBC
    $StraitCurve[0] = `curve -d 1 -p $BoxMPointAD[0]  $BoxMPointAD[1] $BoxMPointAD[2] -p $BoxMPointBC [0] $BoxMPointBC[1] $BoxMPointBC[2]`;
    }
    if ($XZ == 2){
    //$BoxMPointAC $BoxMPointBD
    $StraitCurve[0] = `curve -d 1 -p $BoxMPointAC[0]  $BoxMPointAC[1] $BoxMPointAC[2] -p $BoxMPointBD [0] $BoxMPointBD[1] $BoxMPointBD[2]`;
    }
    }
    setAttr ($StraitCurve[0] + ".rotateX")  $rotationz[0];
    setAttr ($StraitCurve[0] + ".rotateY")  $rotationz[1];
    setAttr ($StraitCurve[0] + ".rotateZ")  $rotationz[2];
    setAttr ($StraitCurve[0] + ".translateX")  $translationz[0];
    setAttr ($StraitCurve[0] + ".translateY")  $translationz[1];
    setAttr ($StraitCurve[0] + ".translateZ")  $translationz[2];

    select -r $ObjectCurve $ObjectCurveduplicate  BoxspaceLocatorA BoxspaceLocatorB  BoxspaceLocatorC BoxspaceLocatorD  BoxspaceLocatorMiddle;
    delete;
    select -r $StraitCurve;
    return $StraitCurve;


}


/******************************************************************************
 * @procedure    NumberOFSurf
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Zeachboundry : string
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int NumberOFSurf(string $Zeachboundry)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $XnumOFcurveConnections;
    int $historyShapes = `size($ZfirstcurveConnectionsz)`;
    string $ZfirstcurveRelatives[];
    string $ZfirstcurveConnectionsz[];
    string $Zfirstcurveshapes[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $ZfirstcurveRelatives = `listRelatives -shapes $Zeachboundry`;
    $ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
    $historyShapes = `size($ZfirstcurveConnectionsz)`;
    if ($historyShapes > 0){
    $ZfirstcurveshapesA = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;
    $ZfirstcurveshapesB = `listConnections -shapes 1  -type mesh $ZfirstcurveConnectionsz`;
    $XnumOFcurveConnections = (`size($ZfirstcurveshapesA)`) + (`size($ZfirstcurveshapesB)`) ;
    }else{ $XnumOFcurveConnections = 0;}

    return $XnumOFcurveConnections;

}


/******************************************************************************
 * @procedure    ForAllCurvesFindSurfaceEdges
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $newallCurves : string[]
 *
 * @returns      string[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] ForAllCurvesFindSurfaceEdges(string $newallCurves[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Zfirstcurveshapesi = `NumberOFSurf($Zeachboundry)`;
    string $ZnewfoundEdge[];
    string $ZselectedCurve[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ( $Zeachboundry in $newallCurves ) {
    $ZselectedCurve[0] = $Zeachboundry;
    $Zfirstcurveshapesi = `NumberOFSurf($Zeachboundry)`;
    if ($Zfirstcurveshapesi == 1){
    appendStringArray($ZnewfoundEdge, $ZselectedCurve, 1);
    }
    if ($Zfirstcurveshapesi == 0){
    appendStringArray($ZnewfoundEdge,  $ZselectedCurve, 1);
    }
    }
    return $ZnewfoundEdge;

}


/******************************************************************************
 * @procedure    GetVectorArrayBetweenCurveEnds
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $CurveItem : string[]
 *
 * @returns      vector[]
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] GetVectorArrayBetweenCurveEnds(string $CurveItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    float $EACHCVposAZ[];
    float $eachCVpos[];
    string $CurveSelection[];
    vector $CurveA = << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $CurveB = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $CurveAB[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
    $EACHCVposAZ = 0; string $MakeXBetweenB[];
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA   )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){$EACHCVposAZ = $eachCVpos;}
    if ( $numIntZB == 2 ){$EACHCVposBZ = $eachCVpos;}
    }
    $CurveA = << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    $CurveB = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    $CurveAB = $CurveA; $CurveAB[1] = $CurveB;
    return $CurveAB;

}


/******************************************************************************
 * @procedure    FindifCurveEndsMeet
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $CurveA1 : vector[]
 *   $CurveA2 : vector[]
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindifCurveEndsMeet(vector $CurveA1[], vector $CurveA2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CurveMeetsTrue = 0;
    int $indexN = 0;
    int $indexN2 = 0;
    int $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    int $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);
    float $firstC[];
    float $SecondCA[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveMeetsTrue = 0;
    $indexN = 0;
    $indexN2 = 0;
    while ($indexN < 2){
    $firstC = $CurveA1[$indexN];
    $SecondC = $CurveA2[0];
    $SecondCA = $CurveA2[1];
    $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);
    if (($NumberE == 3)||($NumberE2 == 3)){$CurveMeetsTrue = $CurveMeetsTrue +1; }
    if ($indexN==1){$indexN1 = 1;}
    $indexN++;
    }
    return $CurveMeetsTrue;

}


/******************************************************************************
 * @procedure    ValueOfCurveSurfInterConnections
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Zeachboundry : string[]
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ValueOfCurveSurfInterConnections(string $Zeachboundry[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $NumberofConnectionZ = 0;
    int $historyShapes = `size($ZfirstcurveConnectionsz)`;
    int $CA = `size($ZfirstcurveshapesA)`;
    int $CB = `size($ZfirstcurveshapesB)`;
    int $XnumOFcurveConnections = `size($Intersectboundarycurves)`;
    string $myIntersector = `stringArrayIntersector`;
    string $ZfirstcurveRelatives[];
    string $ZfirstcurveConnectionsz[];
    string $Zfirstcurveshapes[];
    string $Intersectboundarycurves[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $NumberofConnectionZ = 0;
    $myIntersector = `stringArrayIntersector`;
    for ( $eachboundry in $Zeachboundry ) {
    $ZfirstcurveRelatives = `listRelatives -shapes $eachboundry`;
    $ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
    $historyShapes = `size($ZfirstcurveConnectionsz)`;

    if ($historyShapes > 0){
    $ZfirstcurveshapesA = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;
    $ZfirstcurveshapesB = `listConnections -shapes 1  -type mesh $ZfirstcurveConnectionsz`;
    $CA = `size($ZfirstcurveshapesA)`;
    $CB = `size($ZfirstcurveshapesB)`;

    if (($CA > 0) || ($CB > 0)){
    if ($CA > 0){
    $NumberofConnectionZ++;
    stringArrayIntersector -edit -allowDuplicates  false -intersect $ZfirstcurveshapesA $myIntersector;
    }
    if ($CB > 0){
    $NumberofConnectionZ++;
    stringArrayIntersector -edit -allowDuplicates  false -intersect $ZfirstcurveshapesB $myIntersector;
    }
    }else{ //no shapes connections of anytype Exist ZERO
    $NumberofConnectionZ = 0;
    }
    }
    }
    $Intersectboundarycurves =  `stringArrayIntersector -query $myIntersector`;
    stringArrayIntersector -edit -reset  $myIntersector;
    $XnumOFcurveConnections = `size($Intersectboundarycurves)`;
    return $XnumOFcurveConnections;

}


/******************************************************************************
 * @procedure    IfCurvesTouch
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $curveA : string
 *   $curveB : string
 *
 * @returns      int
 * @source       Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int IfCurvesTouch(string $curveA, string $curveB)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $intIfTrue = FindifCurveEndsMeet($CurveOne, $CurveTwo);
    string $Acurve[];
    string $Bcurve[];
    vector $CurveOne[] = GetVectorArrayBetweenCurveEnds($Acurve);
    vector $CurveTwo[] = GetVectorArrayBetweenCurveEnds($Bcurve);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Acurve = {$curveA};
    $Bcurve = {$curveB};
    $CurveOne = GetVectorArrayBetweenCurveEnds($Acurve);
    $CurveTwo = GetVectorArrayBetweenCurveEnds($Bcurve);
    $intIfTrue = FindifCurveEndsMeet($CurveOne, $CurveTwo);
    return $intIfTrue;

}


/******************************************************************************
 * @procedure    zenEdgeDistance
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $vert : string
 *   $verts : string[]
 *
 * @returns      int[]
 * @source       full automation of Circle script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc int[] zenEdgeDistance(string $vert, string $verts[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $vertCount = zenReturnFirstIntegerItem(`polyEvaluate -v $obj`);
    int $distance[];
    int $found;
    string $obj = FirstStringItem(`stringToStringArray $vert "."`);
    string $vertices[] = {$vert};
    string $nextVertices[];
    string $vertEdges[];
    string $tempArray[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if(!size($verts)) return {};

    $obj = FirstStringItem(`stringToStringArray $vert "."`);
    $vertCount = zenReturnFirstIntegerItem(`polyEvaluate -v $obj`);
    $vertices = {$vert};

    progressWindow -ii 1 -progress 0 -max 25 -status "Sorting" -title "Working";

    for($i=0;$i<$vertCount;$i++)
    {
    $vertEdges=`polyListComponentConversion -te $vertices`;
    $nextVertices=`polyListComponentConversion -tv $vertEdges`;
    $nextVertices=`ls -fl $nextVertices`;

    for($n=0;$n<size($verts);$n++)
    {
    if(`stringArrayContains $verts[$n] $nextVertices`)
    {
    if($distance[$n]==0)
    {
    $found++;
    $distance[$n]=$i+1;
    }
    }
    }

    if($found==size($verts))
    {
    progressWindow -endProgress;
    return $distance;
    }

    if(size($nextVertices)==size($vertices))
    {
    progressWindow -endProgress;
    error("Vertices must be on the same mesh.");
    }

    $vertices=$nextVertices;

    progressWindow -e -s 1;
    if(`progressWindow -q -ic`)
    {
    progressWindow -endProgress;
    error "User Interupt.";
    }
    if(`progressWindow -q -progress`>=`progressWindow -q -max`)
    progressWindow -e -progress 0;
    }

    progressWindow -endProgress;


    return 	{};

}


/******************************************************************************
 * @procedure    mm_curveFromEdges
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      string[]
 * @source       full automation of Circle script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] mm_curveFromEdges()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $len = size($edges);
    int $orderedEdgesIDs[];
    int $currentEdgePos = $firstHeadPos;
    int $jump = 0, $counter = 0, $max = size($edges)*size($edges);
    int $forstOrLast = 0, $orderedVerts[], $oeLen = size($orderedEdgesIDs);
    int $ovLen = size($orderedVerts);
    float $vertPos[] = `xform -a -ws -q -t ($sel[0]+".vtx["+$orderedVerts[0]+"]")`;
    string $sel[] = `selectedNodes`;
    string $edges[] = `filterExpand -sm 32`;
    string $infoVerts[];
    string $ret[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $sel = `selectedNodes`;
    if(size($sel)!=1)
    error "Select some contiguous edges, on one poly object";
    $edges = `filterExpand -sm 32`;
    $len = size($edges);
    if(!$len)
    error "Select some contiguous edges";
    for($i=0; $i<$len; $i++)
    {
    $infoVerts = `polyInfo -ev $edges[$i]`;
    $infoVerts = `stringToStringArray $infoVerts[0] " "`;
    $fVerts[$i] = $infoVerts[2];
    $lVerts[$i] = $infoVerts[3];
    }
    for($i=0; $i<$len; $i++)
    {
    $sticks[$i] = 0;
    for($j=0; $j<$len; $j++)
    {
    if(($j!=$i))
    {
    if(($fVerts[$i]==$fVerts[$j]) || ($lVerts[$i]==$lVerts[$j]) || ($fVerts[$i]==$lVerts[$j]) || ($lVerts[$i]==$fVerts[$j]))
    $sticks[$i]+=1;
    }
    }
    if(($sticks[$i]<1) || ($sticks[$i]>2))
    error "Select some contiguous edges";
    }
    $firstHeadPos = 0;
    $headsNr = 0;
    for($i=0; $i<$len; $i++)
    {
    if($sticks[$i] == 1)
    {
    $headsNr++;
    if($headsNr>2)
    error "Select some contiguous edges";
    $firstHeadPos = $i;
    }
    }
    $orderedEdgesIDs[0] = $firstHeadPos;
    $currentEdgePos = $firstHeadPos;
    $jump = 0, $counter = 0, $max = size($edges)*size($edges);
    while(size($orderedEdgesIDs)<$len)
    {
    for($i=0; $i<$len; $i++)
    {
    for($j=0; $j<size($orderedEdgesIDs); $j++)
    if($orderedEdgesIDs[$j] == $i)
    {
    $jump = 1;
    break;
    }
    if(!$jump)
    {
    if(($fVerts[$i]==$fVerts[$currentEdgePos]) || ($lVerts[$i]==$lVerts[$currentEdgePos]) || ($fVerts[$i]==$lVerts[$currentEdgePos]) || ($lVerts[$i]==$fVerts[$currentEdgePos]))
    {
    $currentEdgePos = $i;
    $orderedEdgesIDs[size($orderedEdgesIDs)] = $i;
    }
    }
    $jump = 0;
    $counter++;
    }
    if($counter>=$max)
    break;
    }
    $forstOrLast = 0, $orderedVerts[], $oeLen = size($orderedEdgesIDs);

    if(($fVerts[$orderedEdgesIDs[0]] == $fVerts[$orderedEdgesIDs[1]]) || ($fVerts[$orderedEdgesIDs[0]] == $lVerts[$orderedEdgesIDs[1]]))
    $orderedVerts[0] = $lVerts[$orderedEdgesIDs[0]];
    else if(($lVerts[$orderedEdgesIDs[0]] == $fVerts[$orderedEdgesIDs[1]]) || ($lVerts[$orderedEdgesIDs[0]] == $lVerts[$orderedEdgesIDs[1]]))
    $orderedVerts[0] = $fVerts[$orderedEdgesIDs[0]];

    for($i=0; $i<$oeLen-1; $i++)
    {
    if(($fVerts[$orderedEdgesIDs[$i]] == $fVerts[$orderedEdgesIDs[$i+1]]) || ($fVerts[$orderedEdgesIDs[$i]] == $lVerts[$orderedEdgesIDs[$i+1]]))
    $orderedVerts[size($orderedVerts)] = $fVerts[$orderedEdgesIDs[$i]];
    else if(($lVerts[$orderedEdgesIDs[$i]] == $fVerts[$orderedEdgesIDs[$i+1]]) || ($lVerts[$orderedEdgesIDs[$i]] == $lVerts[$orderedEdgesIDs[$i+1]]))
    $orderedVerts[size($orderedVerts)] = $lVerts[$orderedEdgesIDs[$i]];
    }
    $ovLen = size($orderedVerts);
    if($fVerts[$orderedEdgesIDs[$oeLen-1]] == $orderedVerts[$ovLen-1])
    {
    $orderedVerts[$ovLen] = $lVerts[$orderedEdgesIDs[$oeLen-1]];
    $ovLen++;
    }
    else if($lVerts[$orderedEdgesIDs[$oeLen-1]] == $orderedVerts[$ovLen-1])
    {
    $orderedVerts[$ovLen] = $fVerts[$orderedEdgesIDs[$oeLen-1]];
    $ovLen++;
    }

    $vertPos = `xform -a -ws -q -t ($sel[0]+".vtx["+$orderedVerts[0]+"]")`;
    $curve = `curve -d 1 -p $vertPos[0] $vertPos[1] $vertPos[2]`;
    if($orderedVerts[0] != $orderedVerts[$ovLen-1])
    {
    for($i=1; $i<$ovLen; $i++)
    {
    $vertPos = `xform -a -ws -q -t ($sel[0]+".vtx["+$orderedVerts[$i]+"]")`;
    curve -a -p $vertPos[0] $vertPos[1] $vertPos[2] $curve;
    }
    $ret[1] = "open";
    }
    else
    {
    for($i=1; $i<$ovLen-1; $i++)
    {
    $vertPos = `xform -a -ws -q -t ($sel[0]+".vtx["+$orderedVerts[$i]+"]")`;
    curve -a -p $vertPos[0] $vertPos[1] $vertPos[2] $curve;
    }
    closeCurve -ch 0 -ps 0 -rpo 1 -bb 0.5 -bki 0 -p 0.1 $curve;
    $ret[1] = "closed";
    }
    $ret[0] = $curve;
    return $ret;

}


/******************************************************************************
 * @procedure    mm_extractCurveFromEdges
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $degree : int
 *
 * @returns      string
 * @source       full automation of Circle script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string mm_extractCurveFromEdges(int $degree)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $curve[] = `mm_curveFromEdges`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $curve = `mm_curveFromEdges`;
    if($degree == 1)
    {
    select -r $curve[0];
    return $curve[0];
    }
    else if($degree == 3)
    {
    if($curve[1] == "open")
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 1 -kep 1 -kt 0 -s 4 -d 3 -tol 0 $curve[0];
    if($curve[1] == "closed")
    {
    closeCurve -ch 1 -ps 0 -rpo 1 -bb 0.5 -bki 0 -p 0.1 $curve[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 1 -kep 1 -kt 0 -s 4 -d 3 -tol 0 $curve[0];
    closeCurve -ch 1 -ps 0 -rpo 1 -bb 0.5 -bki 0 -p 0.1 $curve[0];
    }
    select -r $curve[0];
    return $curve[0];
    }
    else
    error ("Degree not suported: "+$degree+". Use only 1 or 3.");

}


/******************************************************************************
 * @procedure    Circles_Direction
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Point : float[]
 *   $FloatDir : float[]
 *   $FloatNum : float
 *
 * @returns      string
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string Circles_Direction(float $Point[], float $FloatDir[], float $FloatNum)
{

    -nr $FloatDir[0] $FloatDir[1] $FloatDir[2]
    -sw 360
    -r $FloatNum
    -d 3 -ut 0 -tol 0.001 -s 8 -ch 1`;

    //setRotationAxisFloat(string $objectitem1[], float $rotationsA[])
    return $circleItem[0];

}


/******************************************************************************
 * @procedure    ArcLengthArray
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Objs : string[]
 *
 * @returns      float []
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] ArcLengthArray(string $Objs[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $ArcLengths[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($each in $Objs){
    $ArcLengths[`size($ArcLengths)`]= `arclen $each`;
    }
    return $ArcLengths;

}


/******************************************************************************
 * @procedure    lineIntersectionF
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $PosA : float[]
 *   $PosB : float[]
 *   $PosC : float[]
 *   $PosD : float[]
 *
 * @returns      float []
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] lineIntersectionF(float $PosA[], float $PosB[], float $PosC[], float $PosD[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $DirAB[] = DirectionF ($PosA, $PosB);
    float $DirCD[] = DirectionF ($PosC, $PosD);
    float $locsA[] = lineIntersection($PosA, $DirAB, $PosC, $DirCD);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $DirAB = DirectionF ($PosA, $PosB);
    $DirCD = DirectionF ($PosC, $PosD);
    $locsA = lineIntersection($PosA, $DirAB, $PosC, $DirCD);
    return $locsA;

}


/******************************************************************************
 * @procedure    CirclesRadius
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $selectedObjects : string[]
 *
 * @returns      float
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float CirclesRadius(string $selectedObjects[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $FloatPointA[] = `pointPosition -w  $CurveSelectionA[0]`;
    float $worldPosA[];
    float $CircleRadiusA = getDistance($FloatPointA, $worldPosA);
    string $CurveSelectionA[] = `ls -fl ($selectedObjects[0]+".ep[0]")`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveSelectionA = `ls -fl ($selectedObjects[0]+".ep[0]")`;
    $FloatPointA = `pointPosition -w  $CurveSelectionA[0]`;
    $worldPosA = `xform -q -ws -a -rp $selectedObjects[0]`;
    $CircleRadiusA = getDistance($FloatPointA, $worldPosA);
    return $CircleRadiusA;

}


/******************************************************************************
 * @procedure    CirclesRadiusDirection
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $directionAB : vector[]
 *   $PosAB : vector[]
 *
 * @returns      float []
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] CirclesRadiusDirection(vector $directionAB[], vector $PosAB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $FloatPointa2[] = `pointPosition -w  $CurveSelection_a2[0]`;
    float $FloatPointb2[] = `pointPosition -w  $CurveSelection_b2[0]`;
    float $FloatPointA[] = `pointPosition -w  $CurveSelectionA[0]`;
    float $FloatPointB[] = `pointPosition -w  $CurveSelectionB[0]`;
    float $worldPosA[];
    float $CircleRadiusA = getDistance($FloatPointA, $worldPosA);
    float $worldPosB[];
    float $CirclesDistance = getDistance ($worldPosA, $worldPosB);
    float $FloatDirNormalCurveA[] = Normal3Points($worldPosA,$FloatPointa2,$FloatPointA);
    float $CircleRadiusB = getDistance ($FloatPointB, $worldPosB);
    float $RadiusAB[] = {$CircleRadiusA, $CircleRadiusB,$CirclesDistance};
    string $selectedObjects[];
    string $CurveSelectionA[] = `ls -fl ($selectedObjects[0]+".ep[0]")`;
    string $CurveSelection_a2[] = `ls -fl ($selectedObjects[0]+".ep[3]")`;
    string $CurveSelectionB[] = `ls -fl ($selectedObjects[1]+".ep[0]")`;
    string $CurveSelection_b2[] = `ls -fl ($selectedObjects[1]+".ep[3]")`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    clear $selectedObjects;
    $selectedObjects = `ls -sl`;
    $CurveSelectionA = `ls -fl ($selectedObjects[0]+".ep[0]")`;
    $CurveSelection_a2 = `ls -fl ($selectedObjects[0]+".ep[3]")`;

    $CurveSelectionB = `ls -fl ($selectedObjects[1]+".ep[0]")`;
    $CurveSelection_b2 = `ls -fl ($selectedObjects[1]+".ep[3]")`;

    $FloatPointa2 = `pointPosition -w  $CurveSelection_a2[0]`;
    $FloatPointb2 = `pointPosition -w  $CurveSelection_b2[0]`;
    $FloatPointA = `pointPosition -w  $CurveSelectionA[0]`;
    $FloatPointB = `pointPosition -w  $CurveSelectionB[0]`;

    $worldPosA = `xform -q -ws -a -rp $selectedObjects[0]`;
    $CircleRadiusA = getDistance($FloatPointA, $worldPosA);
    $worldPosB= `xform -q -ws -a -rp $selectedObjects[1]`;

    $directionAB[0] = FloatToVec (DirectionF($worldPosA,$worldPosB));
    $directionAB[1] = FloatToVec (DirectionF($worldPosB,$worldPosA));
    $PosAB[0] = FloatToVec ($worldPosA);
    $PosAB[1] = FloatToVec ($worldPosB);
    $CirclesDistance = getDistance ($worldPosA, $worldPosB);

    $FloatDirNormalCurveA = Normal3Points($worldPosA,$FloatPointa2,$FloatPointA);
    $directionAB[2] = FloatToVec ($FloatDirNormalCurveA);

    $CircleRadiusB = getDistance ($FloatPointB, $worldPosB);
    $RadiusAB = {$CircleRadiusA, $CircleRadiusB,$CirclesDistance};
    return $RadiusAB;

}


/******************************************************************************
 * @procedure    PointToCircleTangents
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $CircleRadiusA : float
 *   $worldPosA : float[]
 *   $worldPosB : float[]
 *   $FloatDirNormal : float[]
 *
 * @returns      vector []
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] PointToCircleTangents(float $CircleRadiusA, float $worldPosA[], float $worldPosB[], float $FloatDirNormal[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $R1 = $CircleRadiusA;
    float $P = distance2Pts ($worldPosA, $worldPosB);
    float $r1 = $R1;
    float $r1Z = $R1*2;
    float $Pi = 3.1415926535;
    float $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1Z 2.000`) - (`pow $P 2.000`) )/(2.000*$P*$r1Z)));
    float $AngleNPi = ($Arcangle*180)/$Pi;
    float $AngleN = $AngleNPi;
    float $MultDirPC1[] = multiplyFloat($r1, $directionABs[0]);
    float $AddMultDirPCA1[] = AddFloats($worldPosA, $MultDirPC1);
    float $tsDAR = ( $AngleN)*-1;
    float $tsDBR = ( $AngleN)*1;
    float $rotatsA[] = `rot $directionABs[0] $FloatDirNormal $tsDAR`;
    float $rotatsB[] = `rot $directionABs[0] $FloatDirNormal $tsDBR`;
    float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
    float $AddMultDirPCA2[] = AddFloats($worldPosA, $MultDirPC2);
    vector $directionABs[];
    vector $pointsT[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $R1 = $CircleRadiusA;

    $directionABs[0] = FloatToVec (DirectionF($worldPosA,$worldPosB));
    $directionABs[1] = FloatToVec (DirectionF($worldPosB,$worldPosA));

    // P is the distance between 2 circles
    $P = distance2Pts ($worldPosA, $worldPosB);
    $r1 = $R1;
    $r1Z = $R1*2;
    //HightsOfIsoscelesTriangle($P, $r1Z, $P);
    $Pi = 3.1415926535;
    $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1Z 2.000`) - (`pow $P 2.000`) )/(2.000*$P*$r1Z)));
    $AngleNPi = ($Arcangle*180)/$Pi;
    $AngleN = $AngleNPi;
    //float $ts = atand( (`abs ($r1 - $r2)`) /$P);
    $MultDirPC1 = multiplyFloat($r1, $directionABs[0]);
    $AddMultDirPCA1 = AddFloats($worldPosA, $MultDirPC1);

    $AngleN = $Arcangle;
    $tsDAR = ( $AngleN)*-1;
    $tsDBR = ( $AngleN)*1;
    //The first argument represents a point, the second an axis and the third an angle in radians
    $rotatsA = `rot $directionABs[0] $FloatDirNormal $tsDAR`;
    $MultDirPC1 = multiplyFloat($r1, $rotatsA);
    $AddMultDirPCA1 = AddFloats($worldPosA, $MultDirPC1);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA1);
    $rotatsB = `rot $directionABs[0] $FloatDirNormal $tsDBR`;
    $MultDirPC2 = multiplyFloat($r1, $rotatsB);
    $AddMultDirPCA2 = AddFloats($worldPosA, $MultDirPC2);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA2);

    $pointsT[0] = FloatToVec ($AddMultDirPCA1);
    $pointsT[1] = FloatToVec ($AddMultDirPCA2);
    return $pointsT;

}


/******************************************************************************
 * @procedure    PointArrayT
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $ObjectList : string[]
 *
 * @returns      vector[]
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] PointArrayT(string $ObjectList[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $XiV = 0;
    float $pointAZ1[];
    vector $VecArray[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $XiV = 0;
    for ($each in $ObjectList){
    if (catch($pointAZ1 = `xform -q -ws -t ($each)`)){
    $pointAZ1 = `pointPosition -w ($each)`;
    }
    $VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
    $XiV++;
    }
    return $VecArray;

}


/******************************************************************************
 * @procedure    TangentPointCirVectors
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $ObjsCirclesRad : float[]
 *   $PosABs : vector[]
 *   $directionABs2 : vector[]
 *
 * @returns      vector []
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] TangentPointCirVectors(float $ObjsCirclesRad[], vector $PosABs[], vector $directionABs2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $R1 = $ObjsCirclesRad[0];
    float $R2 = $ObjsCirclesRad[1];
    float $P = distance2Pts ($PosABs[0], $PosABs[1]);
    float $r1 = $R1;
    float $r2 = $R2;
    float $Pi = 3.1415926535;
    float $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1)));
    float $AngleNPi = ($Arcangle*180)/$Pi;
    float $AngleN = $AngleNPi;
    float $Lengths[] = HightsOfIsoscelesTriangle($P, $r1, $r2);
    float $MultDirPCR1[] = multiplyFloat($r1, $directionABs[0]);
    float $AddMultDirPCR1[] = AddFloats($PosABs[0], $MultDirPCR1);
    float $MultDirPCR2[] = multiplyFloat($r2, $directionABs[1]);
    float $AddMultDirPCR2[] = AddFloats($PosABs[1], $MultDirPCR2);
    float $MidPointsA[];
    float $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
    float $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
    float $tsDAR = ( $AngleN)*-1;
    float $tsDBR = ( $AngleN)*1;
    float $rotatsA[] = `rot $directionABs[0] $directionABs2[0] $tsDAR`;
    float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
    float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
    float $rotatsB[] = `rot $directionABs[0] $directionABs2[0] $tsDBR`;
    float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
    float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
    vector $CircIntersectABs[];
    vector $directionABs[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $R1 = $ObjsCirclesRad[0];
    $R2 = $ObjsCirclesRad[1];
    // P is the distance between 2 circles
    $P = distance2Pts ($PosABs[0], $PosABs[1]);
    $directionABs[0] = FloatToVec (DirectionF($PosABs[0],$PosABs[1]));
    $directionABs[1] = FloatToVec (DirectionF($PosABs[1],$PosABs[0]));
    $r1 = $R1;
    $r2 = $R2;
    $Pi = 3.1415926535;
    $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1)));
    $AngleNPi = ($Arcangle*180)/$Pi;
    $AngleN = $AngleNPi;
    $Lengths = HightsOfIsoscelesTriangle($P, $r1, $r2);
    $MultDirPCR1 = multiplyFloat($r1, $directionABs[0]);
    $AddMultDirPCR1 = AddFloats($PosABs[0], $MultDirPCR1);
    $MultDirPCR2 = multiplyFloat($r2, $directionABs[1]);
    $AddMultDirPCR2 = AddFloats($PosABs[1], $MultDirPCR2);
    $MidPointsA = MidPoint($AddMultDirPCR1, $AddMultDirPCR2);
    $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
    $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
    ////////////////////////////////////////////////
    ////////////////////////////////////////////////
    $AngleN = $Arcangle;
    $tsDAR = ( $AngleN)*-1;
    $tsDBR = ( $AngleN)*1;
    //The first argument represents a point, the second an axis and the third an angle in radians
    //the normal $directionABs[2]
    $rotatsA = `rot $directionABs[0] $directionABs2[0] $tsDAR`;
    $MultDirPC1 = multiplyFloat($r1, $rotatsA);
    $AddMultDirPCA1 = AddFloats($PosABs[0], $MultDirPC1);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA1);
    $rotatsB = `rot $directionABs[0] $directionABs2[0] $tsDBR`;
    $MultDirPC2 = multiplyFloat($r1, $rotatsB);
    $AddMultDirPCA2 = AddFloats($PosABs[0], $MultDirPC2);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA2);

    $CircIntersectABs[0] = << $AddMultDirPCA1[0], $AddMultDirPCA1[1], $AddMultDirPCA1[2] >>;
    $CircIntersectABs[1] = << $AddMultDirPCA2[0], $AddMultDirPCA2[1], $AddMultDirPCA2[2] >>;
    return $CircIntersectABs;

}


/******************************************************************************
 * @procedure    TangentPointCirclesVec2
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      vector []
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] TangentPointCirclesVec2()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
    float $R1 = $ObjsCircles[0];
    float $R2 = $ObjsCircles[1];
    float $P = distance2Pts ($PosABs[0], $PosABs[1]);
    float $r1 = $R1;
    float $r2 = $R2;
    float $Pi = 3.1415926535;
    float $Arcangle = acos ((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1)));
    float $AngleNPi = ($Arcangle*180)/$Pi;
    float $AngleN = $AngleNPi;
    float $Lengths[] = HightsOfIsoscelesTriangle($P, $r1, $r2);
    float $MultDirPCR1[] = multiplyFloat($r1, $directionABs[0]);
    float $AddMultDirPCR1[] = AddFloats($PosABs[0], $MultDirPCR1);
    float $MultDirPCR2[] = multiplyFloat($r2, $directionABs[1]);
    float $AddMultDirPCR2[] = AddFloats($PosABs[1], $MultDirPCR2);
    float $MidPointsA[];
    float $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
    float $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
    float $tsDAR = ( $AngleN)*-1;
    float $tsDBR = ( $AngleN)*1;
    float $rotatsA[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
    float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
    float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
    float $rotatsB[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
    float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
    float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
    vector $CircIntersectABs[];
    vector $directionABs[];
    vector $PosABs[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    ResetTransEachSL;
    $ObjsCircles = CirclesRadiusDirection($directionABs, $PosABs);
    $R1 = $ObjsCircles[0];
    $R2 = $ObjsCircles[1];
    // P is the distance between 2 circles

    $P = distance2Pts ($PosABs[0], $PosABs[1]);
    $r1 = $R1;
    $r2 = $R2;
    $Pi = 3.1415926535;
    $Arcangle = acos ((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1))) ;
    $AngleNPi = ($Arcangle*180)/$Pi;
    $AngleN = $AngleNPi;
    $Lengths = HightsOfIsoscelesTriangle($P, $r1, $r2);
    $MultDirPCR1 = multiplyFloat($r1, $directionABs[0]);
    $AddMultDirPCR1 = AddFloats($PosABs[0], $MultDirPCR1);
    $MultDirPCR2 = multiplyFloat($r2, $directionABs[1]);
    $AddMultDirPCR2 = AddFloats($PosABs[1], $MultDirPCR2);
    $MidPointsA = MidPoint($AddMultDirPCR1, $AddMultDirPCR2);
    $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
    $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
    ////////////////////////////////////////////////
    ////////////////////////////////////////////////
    $AngleN = $Arcangle;
    $tsDAR = ( $AngleN)*-1;
    $tsDBR = ( $AngleN)*1;
    //The first argument represents a point, the second an axis and the third an angle in radians
    //the normal $directionABs[2]
    $rotatsA = `rot $directionABs[0] $directionABs[2] $tsDAR`;
    $MultDirPC1 = multiplyFloat($r1, $rotatsA);
    $AddMultDirPCA1 = AddFloats($PosABs[0], $MultDirPC1);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA1);
    $rotatsB = `rot $directionABs[0] $directionABs[2] $tsDBR`;
    $MultDirPC2 = multiplyFloat($r1, $rotatsB);
    $AddMultDirPCA2 = AddFloats($PosABs[0], $MultDirPC2);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA2);

    $CircIntersectABs[0] = << $AddMultDirPCA1[0], $AddMultDirPCA1[1], $AddMultDirPCA1[2] >>;
    $CircIntersectABs[1] = << $AddMultDirPCA2[0], $AddMultDirPCA2[1], $AddMultDirPCA2[2] >>;
    return $CircIntersectABs;

}


/******************************************************************************
 * @procedure    dist3D_Line_to_Line
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $L1 : Line
 *   $L2 : Line
 *
 * @returns      float
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float dist3D_Line_to_Line(Line $L1, Line $L2)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $SMALL_NUM = 0.00000001;
    float $a = dot($u,$u);
    float $b = dot($u,$v);
    float $c = dot($v,$v);
    float $d = dot($u,$w);
    float $e = dot($v,$w);
    float $D = $a*$c - $b*$b;
    float $XX = ($sc)-($tc);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $SMALL_NUM = 0.00000001;

    Vector   $u = L1.P1 - L1.P0;
    Vector   $v = L2.P1 - L2.P0;
    Vector   $w = L1.P0 - L2.P0;

    $a = dot($u,$u);
    $b = dot($u,$v);
    $c = dot($v,$v);
    $d = dot($u,$w);
    $e = dot($v,$w);
    $D = $a*$c - $b*$b;

    // compute the line parameters of the two closest points
    if ($D < $SMALL_NUM) {         // the lines are almost parallel
    $sc = 0.0;
    $tc = ($b>$c ? $d/$b : $e/$c);   // use the largest denominator
    }
    else {
    $sc = ($b*$e - $c*$d) / $D;
    $tc = ($a*$e - $b*$d) / $D;
    }

    // get the difference of the two closest points
    = $w + ($sc * $u) - ($tc * $v);  // = $L1($sc) - $L2($tc)

    sqrt(`dot $u $u` )

    $XX = ($sc)-($tc);


    return norm($dP);   // return the closest distance

}


/******************************************************************************
 * @procedure    MultLenToDirAddToPoint
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Length : float
 *   $Dir : float[]
 *   $Pos : float[]
 *
 * @returns      float []
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] MultLenToDirAddToPoint(float $Length, float $Dir[], float $Pos[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MultLengthDir[] = multiplyFloat($Length, $Dir);
    float $AddMultDirPos[] = AddFloats($Pos, $MultLengthDir);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MultLengthDir = multiplyFloat($Length, $Dir);
    $AddMultDirPos = AddFloats($Pos, $MultLengthDir);
    return $AddMultDirPos;

}


/******************************************************************************
 * @procedure    Normal3Points
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $p1 : float[]
 *   $p2 : float[]
 *   $p3 : float[]
 *
 * @returns      float []
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] Normal3Points(float $p1[], float $p2[], float $p3[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $center[];
    float $normal[];
    vector $normalV[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    // Get the vector p1-p2, p1-p3
    //
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    // Get the normal to the plane formed by p1, p2, p3, which is the
    // cross prod of p1-p2 and p1-p3
    $normalV = crossProduct( $p1p2, $p1p3, 0, 0 );
    $normal = `unit $normalV[0]`;
    return $normal;

}


/******************************************************************************
 * @procedure    TotalArcLength
 * @category     circle-procedures
 * @layer        utility (General)
 *
 *
 * @returns      float
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float TotalArcLength()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $ArcLengths = 0.0;
    string $Objs[] = `ls -sl`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Objs = `ls -sl`;
    $ArcLengths = 0.0;
    for($each in $Objs){
    $ArcLengths += `arclen $each`;
    }
    return $ArcLengths;

}


/******************************************************************************
 * @procedure    makeCurvePointDirectionLength
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Length : float
 *   $Direction : float[]
 *   $posA : float[]
 *
 * @returns      string
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string makeCurvePointDirectionLength(float $Length, float $Direction[], float $posA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MultDir[] = multiplyFloat($Length,  $Direction);
    float $FloatDirectionNormalA[] = AddFloats($posA, $MultDir);
    string $CurveBetween;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MultDir = multiplyFloat($Length,  $Direction);
    $FloatDirectionNormalA = AddFloats($posA, $MultDir);
    $CurveBetween = curve2points($posA,  $FloatDirectionNormalA);
    return $CurveBetween;

}


/******************************************************************************
 * @procedure    PointArray
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $ObjectList : string[]
 *
 * @returns      vector[]
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] PointArray(string $ObjectList[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $XiV = 0;
    float $pointAZ1[];
    vector $VecArray[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $XiV = 0;
    for ($each in $ObjectList){
    if (catch($pointAZ1 = `pointPosition -w ($each)`)){
    $pointAZ1 = `xform -q -ws - rp ($each)`;
    }
    $VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
    $XiV++;
    }
    return $VecArray;

}


/******************************************************************************
 * @procedure    HightsOfIsoscelesTriangle
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $SideA : float
 *   $SideB : float
 *   $SideC : float
 *
 * @returns      float []
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] HightsOfIsoscelesTriangle(float $SideA, float $SideB, float $SideC)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Pi = 3.1415926535;
    float $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
    float $AngleNPi = ($Arcangle*180)/$Pi;
    float $AngleN = $AngleNPi;
    float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
    float $ArcangleC2 = $ArcangleC*2.0;
    float $AngleNB = 180.00 -($ArcangleC2 + $AngleNPi);
    float $Angle_a = $ArcangleC2;
    float $Angle_b = $AngleN;
    float $Angle_c = $AngleNB;
    float $AngleN2 = 180.0 -($Angle_b + $Angle_c);
    float $Angle_A = $AngleN2;
    float $Angle_B = $AngleN;
    float $Angle_C = $AngleN;
    float $AngleOfRightAndA = (180.000 -($AngleN2 +90.000));
    float $AngleOfRightA = ($AngleOfRightAndA/180.000)*$Pi;
    float $AngleN2R = ($AngleN2/180.0000)*$Pi;
    float $HightfromB = sqrt ( ((`pow $SideA 2.000`) + (`pow $SideC 2.000`)) - ((2.000*$SideA*$SideC)*(`cos($AngleN2R+$AngleN2R )`)) )/2.000;
    float $HightfromC = sqrt ( ((`pow $SideA 2.000`) + (`pow $SideC 2.000`)) - ((2.000*$SideA*$SideC)*(`cos ($AngleOfRightA*2.000 )`)) )/2.000;
    float $HightsCandB[] = { $HightfromC, $HightfromB};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $Pi = 3.1415926535;
    $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
    $AngleNPi = ($Arcangle*180)/$Pi;
    $AngleN = $AngleNPi;
    print $AngleN;
    print "//";

    $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
    $ArcangleC2 = $ArcangleC*2.0;
    print $ArcangleC2;
    $AngleNB = 180.00 -($ArcangleC2 + $AngleNPi) ;
    $Angle_a = $ArcangleC2;
    $Angle_b = $AngleN;
    $Angle_c = $AngleNB;

    $AngleN2 = 180.0 -($Angle_b + $Angle_c) ;
    //Two are the same//
    $Angle_A = $AngleN2;
    $Angle_B = $AngleN;
    $Angle_C = $AngleN;
    //Angle of Right Tri in Isoceles
    $AngleOfRightAndA = (180.000 -($AngleN2 +90.000));
    $AngleOfRightA = ($AngleOfRightAndA/180.000)*$Pi;
    $AngleN2R = ($AngleN2/180.0000)*$Pi;
    $HightfromB = sqrt ( ((`pow $SideA 2.000`) + (`pow $SideC 2.000`)) - ((2.000*$SideA*$SideC)*(`cos($AngleN2R+$AngleN2R )`)) )/2.000 ;
    $AngleOfRightA = ($AngleOfRightAndA/180.0000)*$Pi;
    $HightfromC = sqrt ( ((`pow $SideA 2.000`) + (`pow $SideC 2.000`)) - ((2.000*$SideA*$SideC)*(`cos ($AngleOfRightA*2.000 )`)) )/2.000 ;
    $HightsCandB = { $HightfromC, $HightfromB};
    return $HightsCandB;


}


/******************************************************************************
 * @procedure    AnglesofTriangle
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $SideA : float
 *   $SideB : float
 *   $SideC : float
 *
 * @returns      float []
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] AnglesofTriangle(float $SideA, float $SideB, float $SideC)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Pi = 3.1415926535;
    float $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
    float $AngleNPi = ($Arcangle*180)/$Pi;
    float $AngleN = $AngleNPi;
    float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
    float $ArcangleC2 = $ArcangleC*2.0;
    float $AngleNB = 180.00 -($ArcangleC2 + $AngleNPi);
    float $Angle_a = $ArcangleC2;
    float $Angle_b = $AngleN;
    float $Angle_c = $AngleNB;
    float $Add = $Angle_a + $Angle_b + $Angle_c;
    float $Angle_ABC[] = {$Angle_a, $Angle_b, $Angle_c};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $Pi = 3.1415926535;
    $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
    $AngleNPi = ($Arcangle*180)/$Pi;
    $AngleN = $AngleNPi;

    $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
    $AngleNPi = ($Arcangle*180)/$Pi;
    $AngleN = $AngleNPi;

    $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
    $ArcangleC2 = $ArcangleC*2.0;
    $AngleNB = 180.00 -($ArcangleC2 + $AngleNPi) ;
    $Angle_a = $ArcangleC2;
    $Angle_b = $AngleN;
    $Angle_c = $AngleNB;
    $Add = $Angle_a + $Angle_b + $Angle_c;
    $Angle_ABC = {$Angle_a, $Angle_b, $Angle_c} ;
    return $Angle_ABC;

}


/******************************************************************************
 * @procedure    SteinerChain
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $RAa : float
 *   $RBb : float
 *
 * @returns      string []
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] SteinerChain(float $RAa, float $RBb)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $NumberCs = $number3;
    int $n = $NumberCs;
    int $i;
    float $pi = 3.1415926535;
    float $Pi = 3.1415926535;
    float $RA;
    float $RB;
    float $R2 = $RA;
    float $R1 = $RB;
    float $DCircle = (($R2 - $R1)/2.0) + $R1;
    float $Rii = (($R2 - $R1)/2.0);
    float $SideA = $RB + $Rii;
    float $SideB = $Rii*2;
    float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    float $ArcangleC2 = $ArcangleC*2.0;
    float $Aii = (`asin ($RB/($RB + $Rii))`);
    float $number3 = 360.0/$ArcangleC2;
    float $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
    float $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    float $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    float $NofCirclesa = (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
    float $NofCirclesb = ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
    float $NofCirclesc = ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);
    float $dec = 1;
    float $val = $subtract*0.1;
    float $len = $DCircle;
    float $r = $DCircle;
    float $x[] = createRegularPolygonX( $n, $r );
    float $y[] = createRegularPolygonY( $n, $r );
    float $z = 0.0;
    string $circleA[];
    string $circleB[];
    string $circles[];
    string $circlesC[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //
    //float $RA = 22.0;
    //float $RB = 15.680;

    $pi = 3.1415926535;
    $Pi = 3.1415926535;



    if(!( $RAa==$RBb)){
    if( $RAa<$RBb){
    $RA = $RBb;
    $RB = $RAa;}else{ $RA = $RAa; $RB =  $RBb;}

    //float $RA = 22.0;
    //float $RB = 15.68;



    $circleA = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RA -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $circleB = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RB -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $R2 = $RA;
    $R1 = $RB;
    $DCircle = (($R2 - $R1)/2.0) + $R1 ;
    $Rii = (($R2 - $R1)/2.0);

    $SideA = $RB + $Rii;
    $SideB = $Rii*2;

    //GOT it for SURE
    //HightsOfIsoscelesTriangle($SideA, $SideB, $SideA)
    $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    $ArcangleC2 = $ArcangleC*2.0;

    $Aii = (`asin ($RB/($RB + $Rii))`);
    //float $Ni = $pi/$Aii;
    //  $Ni = (rad_to_deg($Aii)) ;


    $number3 = 360.0/$ArcangleC2;

    $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
    $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );

    $NofCirclesa = (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
    $NofCirclesb = ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
    $NofCirclesc = ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);

    //float $subtract = ($NofCirclesa -($NofCirclesb + $NofCirclesc))*4;
    //float $subtract = $NofCirclesB - $NofCirclesA;
    //float $subtract = ($subtract + $NofCirclesC)/2;
    //float $subtractA = (($NofCirclesB - $NofCirclesA)+ $NofCirclesC)/2;
    //float $subtractB = ($NofCirclesA - $NofCirclesC+$NofCirclesB)/2;
    //float $number3 = 360/$NofCirclesC;
    //
    //float $Ni = (rad_to_deg($subtract)) ;
    //float $Ni = $pi/ $subtract;
    //float $number3 = 360/$Ni;
    //$number3 = $subtract;

    //float $subtract = ($NofCirclesA - $NofCirclesC+$NofCirclesB)/2;
    /*
    $dec = 1;
    $val = $subtract*0.1;
    $sign = `sign $val`;
    $dec = `pow 10 $dec`;
    $val = (int) (($val + $sign*5/($dec*10))  * $dec);
    $val = ($val / $dec);
    $val = $val*10;
    $subtract = $val;
    //float $subtract = ($NofCirclesA - $NofCirclesC+$NofCirclesB)/2;
    */
    $NumberCs = $number3;
    $n = $NumberCs;
    $len = $DCircle;
    $r = $DCircle;
    $x = createRegularPolygonX( $n, $r ) ;
    $y = createRegularPolygonY( $n, $r ) ;
    // create the n-sided polygon.
    $z = 0.0 ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $circlesC = `circle -c $x[$i] $y[$i] $z -nr 0 0 1 -sw 360 -r $Rii -d 3 -ut 0 -tol 0.001 -s 16 -ch 1`;

    $circles[`size($circles)`] = $circlesC[0];
    makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $circles[0];
    xform -cp $circles[0];
    //rotate -r -os 0 0 45 $circles[0];
    //aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "scene" $circleB[0] $circles[0];

    }


    //$circles[`size($circles)`] = $circleA[0];
    //$circles[`size($circles)`] = $circleB[0];

    select -r $circleA $circleB $circles ;
    //select -r $circles ;
    return $circles;
    }

}


/******************************************************************************
 * @procedure    round
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $val : float
 *   $dec : float
 *
 * @returns      float
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float round(float $val, float $dec)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Xn = 5;
    int $Dn = $dec;
    int $Dn2 = $dec;
    float $divideAs = $val/2;
    float $divideA = $val/5;
    float $divideB = $val/10;
    float $divideC = $val/100;
    float $divideD = $val/1000;
    float $dec = `pow 10 $dec`;
    float $divide = $val/$Xn;
    float $val2 = $divide;
    float $dec2 = $Dn2;
    float $times = $val2 * $Xn;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Xn = 5;
    //float $dec = 0;
    //float $val = 42.02;
    $Dn = $dec;
    $Dn2 = $dec;
    $divideAs = $val/2;
    $divideA = $val/5;
    $divideB = $val/10;
    $divideC = $val/100;
    $divideD = $val/1000;
    if ($divideAs < 1) { $Xn = 1; $Dn = 2; $Dn2 = 1; }
    if (($divideAs > 1) && ($divideA < 1)) { $Xn = 1; $Dn = 2; $Dn2 = 1;}
    if (($divideA > 1) && ($divideB < 1)) { $Xn = 5; }
    if (($divideB > 1) && ($divideC < 1)) { $Xn = 10; }
    if (($divideC > 1) && ($divideD < 1)) { $Xn = 50; }
    //print ($Xn + "\n");
    $dec = $Dn;
    $sign = `sign $val`;
    $dec = `pow 10 $dec`;
    $val = (int) (($val + $sign*5/($dec*10)) * $dec);
    $val = ($val / $dec);

    $divide = $val/$Xn;
    $val2 = $divide;
    $dec2 = $Dn2;
    $sign2 = `sign $val2`;
    $dec2 = `pow 10 $dec2`;
    $val2 = (int) (($val2 + $sign*5/($dec2*10)) * $dec2);
    $val2 = ($val2 / $dec2);
    $times = $val2 * $Xn;

    return $times;

}


/******************************************************************************
 * @procedure    createRegularPolygonY
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $n : int
 *   $r : float
 *
 * @returns      float[]
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] createRegularPolygonY(int $n, float $r)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    float $x[];
    float $angle = 360.0 / $n;
    float $a = $i * $angle;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $angle = 360.0 / $n ;

    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * cos(deg_to_rad($a)) ;
    }
    return $x ;

}


/******************************************************************************
 * @procedure    createRegularPolygonX
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $n : int
 *   $r : float
 *
 * @returns      float[]
 * @source       the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] createRegularPolygonX(int $n, float $r)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    float $x[];
    float $angle = 360.0 / $n;
    float $a = $i * $angle;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * sin(deg_to_rad($a)) ;
    }
    return $x ;

}


/******************************************************************************
 * @procedure    VecArrayDiff
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $IndeXxz : int[]
 *
 * @returns      vector []
 * @source       ThreePointCircle_TriangulationSTarting to work! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecArrayDiff(int $IndeXxz[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Ixx = 0;
    int $EIndex[];
    int $Ii = 0;
    int $one;
    vector $VecS[] = $AllVecsG;
    vector $newVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global vector $AllVecsG[];
    global vector $WorkingAllVecsG[];
    $VecS = $AllVecsG;
    $Ixx = 0;
    $EIndex = $IndeXxz;
    $EIndex = `sort $EIndex`;
    $Ii = 0;
    for ($eachVc in $VecS){
    $one =$EIndex[$Ii];
    if(!($Ixx==$one)){
    $newVec[`size($newVec)`] = $VecS[$Ixx];
    }else{$Ii++;}
    $Ixx++;
    }
    $WorkingAllVecsG = $newVec;
    return $newVec;

}


/******************************************************************************
 * @procedure    IntArrayDiff
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $IndeXxI : int[]
 *
 * @returns      int []
 * @source       ThreePointCircle_TriangulationSTarting to work! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IntArrayDiff(int $IndeXxI[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $VecS[];
    int $newInt[];
    int $Ix = 0;
    int $ii = 0;
    int $Ixi = 0;
    int $IndeXxz[];
    int $size = `size($IndeXxI)`-1;
    vector $VecSXX[];
    vector $newVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global int $IndexPtsG[];
    global int $WorkingIndexPtsG[];
    global vector $AllVecsG[];
    global vector $WorkingAllVecsG[];
    $VecS= $IndexPtsG;
    $VecSXX = $AllVecsG;
    $Ix = 0;
    $ii = 0;
    $Ixi = 0;
    $IndeXxz = `sort $IndeXxI`;
    $size = `size($IndeXxI)`-1;
    for ($eachVc in $VecS){
    if(($Ix != $IndeXxz[$Ixi])&&($eachVc != -2)){
    $newInt[`size($newInt)`] = $Ix;
    $newVec[`size($newVec)`] = $Ix;
    }else{$Ixi++; if( $Ix > `size($IndeXxz)`){break;}
    }
    $Ix++;
    }
    $WorkingIndexPtsG= $newInt;
    $WorkingAllVecsG = $newVec;
    return $newInt;

}


/******************************************************************************
 * @procedure    VecArrayInclude
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $IndeXxz : int[]
 *
 * @returns      vector []
 * @source       ThreePointCircle_TriangulationSTarting to work! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecArrayInclude(int $IndeXxz[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Ixx = 0;
    int $EIndex[];
    int $Ii = 0;
    int $one;
    vector $VecS[] = $AllVecsG;
    vector $newVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global vector $AllVecsG[];
    global vector $WorkingAllVecsG[];
    $VecS = $AllVecsG;
    $Ixx = 0;
    $EIndex = $IndeXxz;
    $EIndex = `sort $EIndex`;
    $Ii = 0;
    for ($eachVc in $VecS){
    $one =$EIndex[$Ii];
    if(($Ixx==$one)){
    $newVec[`size($newVec)`] = $VecS[$Ixx];
    }else{$Ii++;}
    $Ixx++;
    }
    $WorkingAllVecsG = $newVec;
    return $newVec;

}


/******************************************************************************
 * @procedure    IntArrayInc
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $VecS : int[]
 *   $IndeXxI : int[]
 *
 * @returns      int []
 * @source       ThreePointCircle_TriangulationSTarting to work! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IntArrayInc(int $VecS[], int $IndeXxI[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $newInt[];
    int $Ix = 0;
    int $ii = 0;
    int $Ixi = 0;
    int $IndeXxz[];
    int $size = `size($IndeXxI)`-1;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Ix = 0;
    $ii = 0;
    $Ixi = 0;
    $IndeXxz = `sort $IndeXxI`;
    $size = `size($IndeXxI)`-1;
    for ($eachVc in $VecS){
    if($VecS[$ii]>$IndeXxz[$Ixi]){
    if($size==$Ixi){$Ixi=0;}
    $Ixi++;
    }
    if(($eachVc== $IndeXxz[$Ixi])){
    $newInt[`size($newInt)`] = $eachVc;
    $ii=$Ix;
    }else{$Ixi++;}
    $Ix++;
    }
    return $newInt;

}


/******************************************************************************
 * @procedure    IntArrayInclude
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $IndeXxI : int[]
 *
 * @returns      int []
 * @source       ThreePointCircle_TriangulationSTarting to work! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IntArrayInclude(int $IndeXxI[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $VecS[] = $IndexPtsG;
    int $newInt[];
    int $Ix = 0;
    int $ii = 0;
    int $Ixi = 0;
    int $IndeXxz[];
    int $size = `size($IndeXxI)`-1;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global int $IndexPtsG[];
    global int $WorkingIndexPtsG[];
    $VecS = $IndexPtsG;
    $Ix = 0;
    $ii = 0;
    $Ixi = 0;
    $IndeXxz = `sort $IndeXxI`;
    $size = `size($IndeXxI)`-1;
    for ($eachVc in $VecS){
    if($VecS[$ii]>$IndeXxz[$Ixi]){
    if($size==$Ixi){$Ixi=0;}
    $Ixi++;
    }
    if(($eachVc== $IndeXxz[$Ixi])){
    $newInt[`size($newInt)`] = $eachVc;
    $ii=$Ix;
    }else{$Ixi++;}
    $Ix++;
    }
    $WorkingIndexPtsG= $newInt;
    return $newInt;

}


/******************************************************************************
 * @procedure    IsPointArray_in_ThreePointCircle_Global
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $threeIndex : int[]
 *
 * @returns      int
 * @source       ThreePointCircle_TriangulationSTarting to work! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int IsPointArray_in_ThreePointCircle_Global(int $threeIndex[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IintIi[];
    int $IfFound = 0;
    int $trueOrFalse0;
    int $trueOrFalse1;
    int $trueOrFalse2;
    float $CentR[];
    vector $VecThreePts[];
    vector $vectorRR[];
    vector $cirPos;
    vector $VecLineDiri = PositiveDirectionLine($VecThreePts[0], $VecThreePts[1]);
    vector $VecLineDir = PositiveDirectionLine($VecThreePts[0], $VecThreePts[2]);
    vector $VecLineDirM = $VecLineDiri*$VecLineDir;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    ///vector $AllVecs[]
    global int $IndexPtsG[];
    global vector $WorkingAllVecsG[];
    $VecThreePts = VecArrayInclude($threeIndex);
    $vectorRR = VecArrayDiff($threeIndex);

    $IfFound = 0;
    $trueOrFalse0 = PtsEquivalentF( $VecThreePts[0], $VecThreePts[1], 0.001);
    $trueOrFalse1 = PtsEquivalentF( $VecThreePts[1], $VecThreePts[2], 0.001);
    $trueOrFalse2 = PtsEquivalentF( $VecThreePts[0], $VecThreePts[2], 0.001);
    if($trueOrFalse0 !=1 && $trueOrFalse1 !=1 && $trueOrFalse2 !=1 ){
    $VecLineDiri = PositiveDirectionLine($VecThreePts[0], $VecThreePts[1]);
    $VecLineDir = PositiveDirectionLine($VecThreePts[0], $VecThreePts[2]);
    $VecLineDirM = $VecLineDiri*$VecLineDir;
    if($VecLineDirM.x !=1 && $VecLineDirM.y !=1 && $VecLineDirM.z !=1 ){
    $CentR = Circle3PtZFloats($VecThreePts[0], $VecThreePts[1], $VecThreePts[2]);
    $cirPos = `FloatToVec({$CentR[0],$CentR[1],$CentR[2]})`;


    $IintIi = PointInCircle( $vectorRR, $cirPos, $CentR[3]);
    if(`size($IintIi)`==0){

    $IfFound = 1;
    //$FoundTriPointIndexII= $eachpointRS;
    //$FoundAllZero[`size($FoundAllZero)`]= $eachpointRS;
    Circle3PtZFloatsI($VecThreePts[0], $VecThreePts[1], $VecThreePts[2]);
    }
    if($IfFound== 1){
    curve2points($VecThreePts[0], $VecThreePts[1]);
    ResetTransEachSL;
    curve2points($VecThreePts[1], $VecThreePts[2]);
    ResetTransEachSL;
    curve2points($VecThreePts[2], $VecThreePts[0]);
    ResetTransEachSL;
    }
    }
    }
    return $IfFound;

}


/******************************************************************************
 * @procedure    Direction_Strait_ARC_or_FreeForm
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $renamed : string[]
 *   $ArcN : float
 *   $StraitN : float
 *   $CurveDirectionZ : float[]
 *
 * @returns      string[]
 * @source       True Tangent Circles (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Direction_Strait_ARC_or_FreeForm(string $renamed[], float $ArcN, float $StraitN, float $CurveDirectionZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $free = 0;
    int $TrueorFalseCircle = `IsCircle`;
    int $straitTrigger = 0;
    int $Cvz = $objectAcurveD01;
    int $Cvz2 = $objectAcurveD02;
    float $objectAcurve01 = arclen ($renamed);
    float $curveEndsDis01 = GetDistanceBetweenCurveEnds($renamed);
    float $PercentENDsDiffL = XpercentLess_thenY ($objectAcurve01, $curveEndsDis01);
    float $objectAcurveD01 = $objectAcurve01 / 1.5;
    float $PercentDiffS;
    float $posA[] = $VectorCurveEndZ[0];
    float $posB[] = $VectorCurveEndZ[1];
    float $MultDir[] = multiplyFloat($objectAcurve01,  $CurveDirectionZ);
    float $FloatDirectionNormalA[] = AddFloats($posA, $MultDir);
    float $objectAcurveL = arclen ($renamed);
    float $objectBcurveL = arclen ($objectB);
    float $PercentDiffL = XpercentLess_thenY ($objectBcurveL, $objectAcurveL);
    float $objectAcurve02 = arclen ($renamed);
    float $objectAcurveD02 = $objectAcurve02 / 1.5;
    string $nameString = $renamed[0];
    string $ParentArc[];
    string $newCircle[] = `MakeCIRCLE($renamed)`;
    string $objectB[];
    string $objectC[];
    string $DeleteCurveA[];
    string $DeleteCurveB[];
    string $CurveBetween[];
    vector $VectorCurveEndZ[] = VecCurveEnds ($renamed);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $free = 0;
    $nameString = $renamed[0];
    SetCurveRotation($nameString);
    //smoothCurve -ch 1 -rpo 1 -s 6.60 ($nameString  +".cv[*]");
    $objectAcurve01 = arclen ($renamed);

    select -r $nameString;
    $TrueorFalseCircle = `IsCircle`;
    if ($TrueorFalseCircle == 1){
    $newCircle = `MakeCIRCLE($renamed)`;
    $ParentArc = $newCircle;
    makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $ParentArc;
    }else{

    $curveEndsDis01 = GetDistanceBetweenCurveEnds($renamed);
    $PercentENDsDiffL = XpercentLess_thenY ($objectAcurve01, $curveEndsDis01);
    $straitTrigger = 0;

    if ( $PercentENDsDiffL < 2 ){ $straitTrigger = 1;  }

    $objectAcurveD01 = $objectAcurve01 / 1.5;
    $Cvz = $objectAcurveD01;
    if( $objectAcurve01 < 1.0){ $Cvz = 4; }
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001 $renamed;




    if ($straitTrigger == 1){
    $VectorCurveEndZ = VecCurveEnds ($renamed);
    $posA = $VectorCurveEndZ[0];
    $posB = $VectorCurveEndZ[1];

    $MultDir = multiplyFloat($objectAcurve01,  $CurveDirectionZ);
    $FloatDirectionNormalA = AddFloats($posA, $MultDir);
    $CurveBetween = MakeCurveBetweenFloats($posA,  $FloatDirectionNormalA);

    ResetTranslation($CurveBetween);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001  $CurveBetween;
    $ParentArc = $CurveBetween; $DeleteCurveA =  $renamed; $DeleteCurveB = $objectB;
    }


    if ( $straitTrigger == 0 ){
    $objectB = Make_Middle_of_Curve_ParamlocatorZ($renamed);
    ResetTranslation($objectB);
    $objectC = {$renamed[0], $objectB[0]};
    ResetTranslationEach($objectC);
    $objectAcurveL = arclen ($renamed);
    $objectBcurveL = arclen ($objectB);
    $PercentDiffL = XpercentLess_thenY ($objectBcurveL, $objectAcurveL);
    if ($PercentDiffL  < $ArcN){

    $ParentArc = $objectB;  $DeleteCurveA = $renamed;
    }else{

    $free = 1;
    $ParentArc = $renamed; $DeleteCurveA = $objectB;  }

    }

    delete $DeleteCurveA;
    rename $ParentArc $nameString;
    $ParentArc[0] = $nameString;


    if ( $free == 1 ){ select -r $ParentArc;  EvalSmoothCurves;
    //modifySelectedCurves smooth 20 0;
    $nameString = $ParentArc[0];
    $objectAcurve02 = arclen ($renamed);
    $objectAcurveD02 = $objectAcurve02 / 1.5;
    $Cvz2 = $objectAcurveD02;
    if( $objectAcurve01 < 1.0){ $Cvz2 = 4; }
    //rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 - kcp 0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001  $renamed;
    }

    }
    makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $ParentArc;
    return $ParentArc;


}


/******************************************************************************
 * @procedure    createRegularPolygonXY
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $n : int
 *   $r : float
 *
 * @returns      float[]
 * @source       True Tangent Circles (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] createRegularPolygonXY(int $n, float $r)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    float $x[];
    float $angle = 360.0 / $n;
    float $a = $i * $angle;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $angle = 360.0 / $n ;

    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * cos(deg_to_rad($a)) ;
    }
    return $x ;

}


/******************************************************************************
 * @procedure    Circles
 * @category     circle-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Point : float[]
 *   $FloatNum : float
 *
 * @returns      string
 * @source       True Tangent Circles (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string Circles(float $Point[], float $FloatNum)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $circleItem[] = `circle -c $Point[0] $Point[1] $Point[2] -nr 0 1 0 -sw 360 -r $FloatNum -d 3 -ut 0 -tol 0.001 -s 8 -ch 1`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $circleItem = `circle -c $Point[0] $Point[1] $Point[2] -nr 0 1 0 -sw 360 -r $FloatNum -d 3 -ut 0 -tol 0.001 -s 8 -ch 1`;
    return $circleItem[0];

}

