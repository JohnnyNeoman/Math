/******************************************************************************
 * SKETCH MODELING - CLEANED MEL PROCEDURES
 *
 * Category:    sketch-modeling
 * Layer:       projection (Camera->World)
 * Description: Camera-centric sketch-based modeling, retopology
 * Procedures:  214
 *
 * All variable declarations moved to procedure start.
 * Generated by cleanup_mel_v2.py
 ******************************************************************************/


/******************************************************************************
 * @procedure    ConvertPolyFacesIntoNurbSurface
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      string
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string ConvertPolyFacesIntoNurbSurface()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sizeBorderEdges = size($SelectedPolyBorderEdges) -1;
    int $Xi = 1;
    int $ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
    int $iix = 0;
    int $iiV = 0;
    float $valuesP[];
    float $values[];
    string $PolyFaceslist[] = `ls -sl`;
    string $NewPolyFaces[] = ` polyChipOff -ch 1 -kft 1 -dup 0 -off 0 $PolyFaceslist`;
    string $HistoryConnections[] = ` listHistory -future true -pruneDagObjects false $NewPolyFaces`;
    string $polySep[] = `polySeparate -rs 1 -ch 0 $HistoryConnections[1]`;
    string $PolyFaces = ( $PolygonNew[0] +".f[*]");
    string $AllPolyFaces[] = `ls -fl $PolyFaces`;
    string $AllPolyFaces2[] = `ls $PolyFaces`;
    string $diffEdgeVertz[] = GetEdgeVertex($PolygonNew);
    string $ReturnObjects = "";
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorCX`;
    string $DiffPolyBorderEdges[] = GetdiffEdgesOfBorder($PolygonNew);
    string $SelectedPolyBorderEdges[] = PolyBorderEdges($PolygonNew);
    string $NearEdges[] = GetNearEdges($EdgeVertzStart);
    string $diffA[] = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdges);
    string $NearEdgesA[] = GetNearEdges($NearEdgesOne);
    string $diffB[] = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdgesA);
    string $EdgesVertex[] = ls("-fl",polyListComponentConversion("-toVertex",$diffB[0]));
    string $bufferList[];
    string $EdgeCurves[];
    string $EdgesVertexEach[];
    string $ListA[];
    string $EdgesVertexEachOrder[] = VertLoopEdgeLoop($ListA);
    string $Newcurvez = `eval($curve)`;
    string $NewcurveX[];
    string $NurbSurfaceFromPolyFaces = `alternativeBoundry`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyFaceslist = `ls -sl`;
    $NewPolyFaces = ` polyChipOff -ch 1 -kft 1 -dup 0 -off 0 $PolyFaceslist`;
    print $NewPolyFaces;
    $HistoryConnections = ` listHistory -future true -pruneDagObjects false $NewPolyFaces`;
    $polySep = `polySeparate -rs 1 -ch 0 $HistoryConnections[1]`;
    select -r $polySep[1];
    string $PolygonNew[0] = {$polySep[1]};
    parent -w $PolygonNew;
    $PolyFaces = ( $PolygonNew[0] +".f[*]");
    $AllPolyFaces = `ls -fl $PolyFaces`;
    $AllPolyFaces2 = `ls $PolyFaces`;

    $diffEdgeVertz = GetEdgeVertex($PolygonNew);
    $ReturnObjects = "";

    for ($eachP in $diffEdgeVertz){
    $valuesP = `pointPosition -w ($eachP)`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorCX`;
    move -ws $valuesP[0] $valuesP[1] $valuesP[2] $spaceLocatorB;
    $ReturnObjects += $spaceLocatorB[0]+" ";
    }
    $DiffPolyBorderEdges = GetdiffEdgesOfBorder($PolygonNew);
    $SelectedPolyBorderEdges = PolyBorderEdges($PolygonNew);

    $sizeBorderEdges = size($SelectedPolyBorderEdges) -1;
    string $EdgeVertzStart[0] = {$diffEdgeVertz[0]};
    stringArrayRemoveAtIndex(0, $diffEdgeVertz);
    $NearEdges = GetNearEdges($EdgeVertzStart);
    string $NearEdgesOne[0] = {$NearEdges[0]};
    string $NearEdgesSecond[0] = {$NearEdges[1]};
    appendStringArray($DiffPolyBorderEdges, $NearEdgesSecond, 1);
    $diffA = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdges);
    string $orderedArray[0] = {$NearEdgesOne[0]};
    $Xi = 1;
    while ($Xi < $sizeBorderEdges){
    $Xi++;
    $NearEdgesA = GetNearEdges($NearEdgesOne);
    appendStringArray($DiffPolyBorderEdges, $NearEdgesOne, 1);
    $diffB = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdgesA);

    $EdgesVertex = ls("-fl",polyListComponentConversion("-toVertex",$diffB[0]));
    $ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
    appendStringArray($orderedArray, $diffB, 1);
    $NearEdgesOne = $diffB;
    }
    appendStringArray($orderedArray, $NearEdgesSecond, 1);

    $EdgeLists = "";
    $iix = 0;
    $iiV = 0;
    for ($each in $orderedArray){
    string $oneItem[0] = {$each};
    $EdgesVertex = ls("-fl",polyListComponentConversion("-toVertex", $oneItem[0]));
    if ( $iix > 0){
    $ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
    if ( $ifTrue == 1){ $iiV++; if ( $iiV == 1){
    $EdgeLists += " "+$oneItem[0]+" "+"VERT";} if ( $iiV == 2){ $EdgeLists += " "+$oneItem[0]; $iiV = 0; } }
    if ( $ifTrue == 0){ $EdgeLists += " "+$oneItem[0]; }
    }
    if ( $iix == 0){  $EdgeLists += $oneItem[0]; }
    $iix++;
    }

    $numTokens = `tokenize $EdgeLists "VERT" $bufferList`;
    clear $EdgeCurves;
    for($eachBuffer in $bufferList){
    $ListA = `stringToStringArray $eachBuffer " "`;
    //string $EdgesVertexEach[] = ls("-fl",polyListComponentConversion("-toVertex", $ListA));
    $EdgesVertexEachOrder = VertLoopEdgeLoop($ListA);
    $curve = "curve -d 1";
    for($eachVert in $EdgesVertexEachOrder){
    $values = `pointPosition -w ($eachVert)`;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    $Newcurvez = `eval($curve)`;
    $NewcurveX = {$Newcurvez};
    appendStringArray($EdgeCurves, $NewcurveX, 1);

    }
    select -r $EdgeCurves;
    $NurbSurfaceFromPolyFaces = `alternativeBoundry`;
    delete -ch $EdgeCurves;
    delete $PolygonNew;
    $ReturnObjects += $NurbSurfaceFromPolyFaces;
    $ReturnObjects += " "+$EdgeCurves[0] +" "+$EdgeCurves[1] +" "+$EdgeCurves[2] +" "+$EdgeCurves[3] ;
    select -r $EdgeCurves;
    print $ReturnObjects;
    return $ReturnObjects;

}


/******************************************************************************
 * @procedure    CreatePolyFromFloats
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $BoxPointsX : float[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CreatePolyFromFloats(float $BoxPointsX[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sizeVecBox = size($BoxPointZ);
    int $ZiI = 0;
    float $bbox[] = $BoxPointsX;
    float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox[2]};
    float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox[5]};
    float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox[2]};
    float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox[5]};
    float $values[] = $BoxPointZ[$ZiI];
    string $polyZ = "polyCreateFacet";
    vector $BoxPointZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $bbox = $BoxPointsX;
    $BoxPointA = {$bbox[0], $bbox[1], $bbox[2]};
    $BoxPointB = {$bbox[3], $bbox[4], $bbox[5]};
    $BoxPointC = {$bbox[3], $bbox[1], $bbox[2]};
    $BoxPointD = {$bbox[0], $bbox[4], $bbox[5]};
    ///
    $BoxPointZ[0] = <<$bbox[0], $bbox[4], $bbox[2]>>;
    $BoxPointZ[1] = <<$bbox[3], $bbox[4], $bbox[2]>>;
    $BoxPointZ[2] = <<$bbox[3], $bbox[4], $bbox[5]>>;
    $BoxPointZ[3] = <<$bbox[0], $bbox[4], $bbox[5]>>;

    $sizeVecBox = size($BoxPointZ);
    $polyZ = "polyCreateFacet";
    $ZiI = 0;
    progressWindow -ii true -title "Working" -status "Moving Verts" -max (size($BoxPointZ)) -progress 0;
    while ($ZiI < $sizeVecBox){
    $values = $BoxPointZ[$ZiI];
    $polyZ += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    $ZiI++;
    progressWindow -e -s 1;
    if(`progressWindow -q -ic`)
    {
    progressWindow -endProgress;
    error "User Interupt.";
    }


    }
    print $polyZ;
    string $NewPolyZz[0] = `eval($polyZ)`;
    progressWindow -endProgress;
    select -r $NewPolyZz;
    ResetTranslation($NewPolyZz);
    return $NewPolyZz;

}


/******************************************************************************
 * @procedure    GetDistancePointPositionFLOAT
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $objectFirst : string
 *   $objectSecond : string
 *
 * @returns      float
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc float GetDistancePointPositionFLOAT(string $objectFirst, string $objectSecond)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $pointAZ1[];
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pointAZ1 = `pointPosition -w ($objectFirst)`;
    $pointAZ2 = `pointPosition -w ($objectSecond)`;
    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    alternativeBoundry
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      string
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string alternativeBoundry()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $hist = `constructionHistory -q -tgl`;
    int $n = size($curves);
    int $i;
    string $curves[] = `filterExpand -ex true -sm $gSelectNurbsCurvesBit -sm $gSelectIsoparmsBit -sm $gSelectCurvesOnSurfacesBit -sm   $gSelectSurfaceEdgeBit`;
    string $surface = "";
    string $cmd = "boundary -or 0 -ep 0 -rn 1 -po 0 -ept 0.001 -ch  " + $hist + " ";
    string $now[] = `rebuildCurve -ch 0 -rpo 1 -kcp on -d 1 -rt 0 $curves[$i]`;
    string $res[] = eval($cmd);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $hist = `constructionHistory -q -tgl`;
    global int $gSelectNurbsCurvesBit;
    global int $gSelectIsoparmsBit;
    global int $gSelectCurvesOnSurfacesBit;
    global int $gSelectSurfaceEdgeBit;
    $curves = `filterExpand -ex true -sm $gSelectNurbsCurvesBit -sm $gSelectIsoparmsBit -sm $gSelectCurvesOnSurfacesBit -sm   $gSelectSurfaceEdgeBit`;
    $surface = "";
    $n = size($curves);
    if( $n < 4 ) return $surface;
    $cmd = "boundary -or 0 -ep 0 -rn 1 -po 0 -ept 0.001 -ch  " + $hist + " ";
    // Rebuild them into linears (keep cvs):
    for( $i=0; $i<$n; $i+=1 ) {
    $now = `rebuildCurve -ch 0 -rpo 1 -kcp on -d 1 -rt 0 $curves[$i]`;
    $curves[$i] = $now[0];
    $cmd = $cmd + $curves[$i] + " ";
    }

    // Convert back into cubic:
    $res = eval($cmd);
    if( size($res) > 0 ) {
    $surface = $res[0];
    rebuildSurface -ch $hist -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kc 0 -su 0 -du 3 -sv 0 -dv 3 -tol 0.001 -fr 0  -dir 2 $surface;
    }

    if( !$hist ) {
    for( $i=0; $i<$n; $i+=1 ) {
    delete $curves[$i];
    }
    }

    select -r $curves;
    return $surface;

}


/******************************************************************************
 * @procedure    FindifArraysContain
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $FirstList : string[]
 *   $array2 : string[]
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc int FindifArraysContain(string $FirstList[], string $array2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $found;
    int $Trigger;
    string $oneItemz = $each;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ($each in $FirstList){
    $oneItemz = $each;
    $found = stringArrayContains($oneItemz, $array2);
    if ( $found == 1 ){ $Trigger = 1; break; }
    }
    return $Trigger;

}


/******************************************************************************
 * @procedure    ConvertPolyPlaneIntoNurbSurfaceZ
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $PolygonNew : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] ConvertPolyPlaneIntoNurbSurfaceZ(string $PolygonNew[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sizeBorderEdges = size($SelectedPolyBorderEdges) -1;
    int $Xi = 1;
    int $ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
    int $iix = 0;
    int $iiV = 0;
    float $valuesP[];
    float $values[];
    string $PolyFaces = ( $PolygonNew[0] +".f[*]");
    string $AllPolyFaces[] = `ls -fl $PolyFaces`;
    string $AllPolyFaces2[] = `ls $PolyFaces`;
    string $diffEdgeVertz[] = GetEdgeVertex($PolygonNew);
    string $ReturnObjects = "";
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorCX`;
    string $DiffPolyBorderEdges[] = GetdiffEdgesOfBorder($PolygonNew);
    string $SelectedPolyBorderEdges[] = PolyBorderEdges($PolygonNew);
    string $NearEdges[] = GetNearEdges($EdgeVertzStart);
    string $diffA[] = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdges);
    string $NearEdgesA[] = GetNearEdges($NearEdgesOne);
    string $diffB[] = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdgesA);
    string $EdgesVertex[] = ls("-fl",polyListComponentConversion("-toVertex",$diffB[0]));
    string $bufferList[];
    string $EdgeCurves[];
    string $EdgesVertexEach[];
    string $ListA[];
    string $EdgesVertexEachOrder[] = VertLoopEdgeLoop($ListA);
    string $Newcurvez = `eval($curve)`;
    string $NewcurveX[];
    string $ListofItemConvert[] = `stringToStringArray $ReturnObjects " "`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $PolyFaces = ( $PolygonNew[0] +".f[*]");
    $AllPolyFaces = `ls -fl $PolyFaces`;
    $AllPolyFaces2 = `ls $PolyFaces`;

    $diffEdgeVertz = GetEdgeVertex($PolygonNew);
    $ReturnObjects = "";

    for ($eachP in $diffEdgeVertz){
    $valuesP = `pointPosition -w ($eachP)`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorCX`;
    move -ws $valuesP[0] $valuesP[1] $valuesP[2] $spaceLocatorB;
    $ReturnObjects += $spaceLocatorB[0]+" ";
    }
    $DiffPolyBorderEdges = GetdiffEdgesOfBorder($PolygonNew);
    $SelectedPolyBorderEdges = PolyBorderEdges($PolygonNew);

    $sizeBorderEdges = size($SelectedPolyBorderEdges) -1;
    string $EdgeVertzStart[0] = {$diffEdgeVertz[0]};
    stringArrayRemoveAtIndex(0, $diffEdgeVertz);
    $NearEdges = GetNearEdges($EdgeVertzStart);
    string $NearEdgesOne[0] = {$NearEdges[0]};
    string $NearEdgesSecond[0] = {$NearEdges[1]};
    appendStringArray($DiffPolyBorderEdges, $NearEdgesSecond, 1);
    $diffA = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdges);
    string $orderedArray[0] = {$NearEdgesOne[0]};
    $Xi = 1;
    while ($Xi < $sizeBorderEdges){
    $Xi++;
    $NearEdgesA = GetNearEdges($NearEdgesOne);
    select -r $NearEdgesA;
    appendStringArray($DiffPolyBorderEdges, $NearEdgesOne, 1);
    $diffB = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdgesA);
    select -r $diffB;
    $EdgesVertex = ls("-fl",polyListComponentConversion("-toVertex",$diffB[0]));
    $ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
    appendStringArray($orderedArray, $diffB, 1);
    $NearEdgesOne = $diffB;
    }
    appendStringArray($orderedArray, $NearEdgesSecond, 1);

    $EdgeLists = "";

    $iix = 0;
    $iiV = 0;
    for ($each in $orderedArray){
    string $oneItem[0] = {$each};
    $EdgesVertex = ls("-fl",polyListComponentConversion("-toVertex", $oneItem[0]));
    playButtonStepForward;
    select -r $EdgesVertex;
    playButtonStepForward;
    if ( $iix > 0){
    $ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
    if ( $ifTrue == 1){ $iiV++; if ( $iiV == 1){
    $EdgeLists += " "+$oneItem[0]+" "+"VERT";} if ( $iiV == 2){ $EdgeLists += " "+$oneItem[0]; $iiV = 0; } }
    if ( $ifTrue == 0){ $EdgeLists += " "+$oneItem[0]; }
    }
    if ( $iix == 0){  $EdgeLists += $oneItem[0]; }
    $iix++;
    }

    $numTokens = `tokenize $EdgeLists "VERT" $bufferList`;
    clear $EdgeCurves;
    for($eachBuffer in $bufferList){
    $ListA = `stringToStringArray $eachBuffer " "`;
    //string $EdgesVertexEach[] = ls("-fl",polyListComponentConversion("-toVertex", $ListA));
    $EdgesVertexEachOrder = VertLoopEdgeLoop($ListA);
    $curve = "curve -d 1";
    for($eachVert in $EdgesVertexEachOrder){ playButtonStepForward;
    select -r $eachVert; playButtonStepForward;
    $values = `pointPosition -w ($eachVert)`;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    $Newcurvez = `eval($curve)`;
    $NewcurveX = {$Newcurvez};
    appendStringArray($EdgeCurves, $NewcurveX, 1);

    }
    select -r $EdgeCurves;
    string $NurbSurfaceFromPolyFaces[0] = {`alternativeBoundry`};
    delete -ch $NurbSurfaceFromPolyFaces;
    delete -ch $EdgeCurves;
    delete $PolygonNew;
    $ListofItemConvert = `stringToStringArray $ReturnObjects " "`;
    delete $ListofItemConvert;
    return $NurbSurfaceFromPolyFaces;

}


/******************************************************************************
 * @procedure    GetNearEdges
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $edgeArray : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] GetNearEdges(string $edgeArray[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $PolyVertexFromEdges[] = ls("-fl",polyListComponentConversion("-toVertex",$edgeArray[0]));
    string $PolyEdgesFromVertex[] = ls("-fl",polyListComponentConversion("-toEdge", $PolyVertexFromEdges));

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyVertexFromEdges = ls("-fl",polyListComponentConversion("-toVertex",$edgeArray[0]));
    $PolyEdgesFromVertex = ls("-fl",polyListComponentConversion("-toEdge", $PolyVertexFromEdges));
    return $PolyEdgesFromVertex;

}


/******************************************************************************
 * @procedure    VertLoopEdgeLoop
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $edgeZ : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] VertLoopEdgeLoop(string $edgeZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $verts[];
    string $v0[] = `polyListComponentConversion -tv $edgeZ[0]`;
    string $v1[] = `polyListComponentConversion -tv $edgeZ[1]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $v0 = `polyListComponentConversion -tv $edgeZ[0]`;
    $v0=`ls -fl $v0`;
    $v1 = `polyListComponentConversion -tv $edgeZ[1]`;
    $v1=`ls -fl $v1`;
    $v0=`stringArrayRemove $v1 $v0`;
    $verts[0]=$v0[0];

    for($i=0;$i<size($edgeZ);$i++)
    {
    $v0 = `polyListComponentConversion -tv $edgeZ[$i]`;

    $v0=`ls -fl $v0`;
    $v0=`stringArrayRemove $verts $v0`;
    $verts[size($verts)]=$v0[0];
    }

    return	$verts;

}


/******************************************************************************
 * @procedure    IfIntersect
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $ArrayA : string[]
 *   $ArrayB : string[]
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc int IfIntersect(string $ArrayA[], string $ArrayB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sizeofItems = size($findIntersection);
    string $myIntersector = `stringArrayIntersector`;
    string $findIntersection[] = `stringArrayIntersector -query $myIntersector`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $myIntersector = `stringArrayIntersector`;
    stringArrayIntersector -edit -intersect $ArrayA $myIntersector;
    stringArrayIntersector -edit -intersect $ArrayB $myIntersector;
    $findIntersection = `stringArrayIntersector -query $myIntersector`;
    stringArrayIntersector -edit -reset $myIntersector;
    $sizeofItems = size($findIntersection);
    return $sizeofItems;

}


/******************************************************************************
 * @procedure    PolyBorderEdges
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $polyZ : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] PolyBorderEdges(string $polyZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $PolyFaceZ = ( $polyZ[0] +".f[*]");
    string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
    string $PolyEdgesFromFaceZ[] = ls("-fl",polyListComponentConversion("-toEdge",$AllPolyFaceZ));
    string $SelectedPolyBorderEdgeZ[] = `ls -sl -fl`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyFaceZ = ( $polyZ[0] +".f[*]");
    $AllPolyFaceZ = `ls -fl $PolyFaceZ`;
    $PolyEdgesFromFaceZ = ls("-fl",polyListComponentConversion("-toEdge",$AllPolyFaceZ));
    select -r $PolyEdgesFromFaceZ;
    polyConvertToShellBorder;
    $SelectedPolyBorderEdgeZ = `ls -sl -fl`;
    return $SelectedPolyBorderEdgeZ;

}


/******************************************************************************
 * @procedure    GetdiffEdgesOfBorder
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $poly : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] GetdiffEdgesOfBorder(string $poly[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $PolyFaceZ = ( $poly[0] +".f[*]");
    string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
    string $PolyEdgesFromFaceZ[] = ls("-fl",polyListComponentConversion("-toEdge",$AllPolyFaceZ));
    string $SelectedPolyBorderEdgeZ[] = `ls -sl -fl`;
    string $diffEdgeZ[] = stringArrayRemoveExact($SelectedPolyBorderEdgeZ, $PolyEdgesFromFaceZ);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyFaceZ = ( $poly[0] +".f[*]");
    $AllPolyFaceZ = `ls -fl $PolyFaceZ`;
    $PolyEdgesFromFaceZ = ls("-fl",polyListComponentConversion("-toEdge",$AllPolyFaceZ));
    select -r $PolyEdgesFromFaceZ;
    polyConvertToShellBorder;
    $SelectedPolyBorderEdgeZ = `ls -sl -fl`;
    $diffEdgeZ = stringArrayRemoveExact($SelectedPolyBorderEdgeZ, $PolyEdgesFromFaceZ);
    select -r $diffEdgeZ;
    return $diffEdgeZ;

}


/******************************************************************************
 * @procedure    GetEdgeVertex
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $poly : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] GetEdgeVertex(string $poly[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $PolyFaceZ = ( $poly[0] +".f[*]");
    string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
    string $EdgePolyFaceZ[] = `ls -sl -fl`;
    string $PolyEdgelistA[] = ls("-fl",polyListComponentConversion("-border", "-toVertex", "-fromFace", $EdgePolyFaceZ));
    string $PolyEdgelistB[] = ls("-fl",polyListComponentConversion( "-toVertex", "-fromFace", $EdgePolyFaceZ));
    string $diffEdgeZ[] = stringArrayRemoveExact($PolyEdgelistA, $PolyEdgelistB);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyFaceZ = ( $poly[0] +".f[*]");
    $AllPolyFaceZ = `ls -fl $PolyFaceZ`;
    select -r $AllPolyFaceZ;
    polyConvertToShellBorder;
    ConvertSelectionToContainedEdges;
    ConvertSelectionToContainedFaces;
    $EdgePolyFaceZ = `ls -sl -fl`;
    $PolyEdgelistA = ls("-fl",polyListComponentConversion("-border", "-toVertex", "-fromFace", $EdgePolyFaceZ));
    select -r $PolyEdgelistA;
    $PolyEdgelistB = ls("-fl",polyListComponentConversion( "-toVertex", "-fromFace", $EdgePolyFaceZ));
    select -r $PolyEdgelistB;
    $diffEdgeZ = stringArrayRemoveExact($PolyEdgelistA, $PolyEdgelistB);
    select -r $diffEdgeZ;
    return $diffEdgeZ;

}


/******************************************************************************
 * @procedure    stringArrayGmatchIndex
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $itemA : string[]
 *   $list : string[]
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc int stringArrayGmatchIndex(string $itemA[], string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    int $ResultIndex = 0;
    int $Index = 0;
    string $item = $itemA[0];
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $item = $itemA[0];
    $result = false;
    $ResultIndex = 0;
    $Index = 0;
    for ($EachlistItem in $list) {
    if ( $EachlistItem == $item ){
    $result = true; $ResultIndex = $Index;
    break;	}
    $Index++;
    }
    return $ResultIndex;

}


/******************************************************************************
 * @procedure    SortEvenArrays
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $ArrayItems : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SortEvenArrays(string $ArrayItems[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $getsize = size($ArrayItems);
    int $i = 0;
    string $newItemsList[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $getsize = size($ArrayItems);
    $i = 0;
    $iX = 0;
    while($i < $getsize){
    $iX++;
    if ( $iX == 2){
    string $oneitem[0] = {$ArrayItems[$i]};
    appendStringArray($newItemsList, $oneitem, 1);
    $iX = 0;
    }
    $i++;
    }
    return $newItemsList;

}


/******************************************************************************
 * @procedure    ArrayFromAllinString
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $list : string
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] ArrayFromAllinString(string $list)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i = 0;
    int $Indexi = 0;
    int $triggerends = 0;
    string $singleStringItemB[];
    string $singleStringItemA[];
    string $listA = $list;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $i = 0;
    $Indexi = 0;
    $triggerends = 0;
    $listA = $list;
    while ( $triggerends < 1 ) {
    $i++;
    $singleStringItemA = {`substring $listA $i $i`};
    if (size($singleStringItemA[0]) == 0){
    $triggerends = 2; } else {
    appendStringArray($singleStringItemB, $singleStringItemA, 1);
    }
    $Indexi++;
    if ($Indexi == 20){ $triggerends = 2;}
    }
    return $singleStringItemB;

}


/******************************************************************************
 * @procedure    ArrayToIntList
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $singleStringItemB : string[]
 *
 * @returns      int[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int[] ArrayToIntList(string $singleStringItemB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Numberlist[];
    int $triggerendsB = 0;
    int $newlistSize = size($singleStringItemB);
    int $ci = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $triggerendsB = 0;
    $newlistSize = size($singleStringItemB);
    $ci = 0;
    while ( $triggerendsB < $newlistSize ) {
    $Numberlist[$ci] = $singleStringItemB[$ci];
    $ci++;
    $triggerendsB = $triggerendsB + 1;
    }
    print $Numberlist;
    return $Numberlist;

}


/******************************************************************************
 * @procedure    CycleNumberString
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $singleStringItemC : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CycleNumberString(string $singleStringItemC[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArray;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArray = size($singleStringItemC) -1;
    string $last[0] = {$singleStringItemC[$SizeOfArray]};
    string $first[0] = {$singleStringItemC[0]};
    stringArrayRemoveAtIndex(0, $singleStringItemC);
    appendStringArray($singleStringItemC, $first, 1);
    return $singleStringItemC;

}


/******************************************************************************
 * @procedure    SortPatternArrays
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $ArrayItems : string[]
 *   $NumberlistA : int[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SortPatternArrays(string $ArrayItems[], int $NumberlistA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $getsizeNlist = size($NumberlistA);
    int $iN = 0;
    int $getsize = size($ArrayItems);
    int $i = 0;
    string $newItemsList[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $getsizeNlist = size($NumberlistA);
    $iN = 0;
    $getsize = size($ArrayItems);
    $i = 0;
    $iX = 0;
    while($i < $getsize){
    $iX++;
    if ( $NumberlistA[$iN] == 0){
    string $oneitem[0] = {$ArrayItems[$i]};
    appendStringArray($newItemsList, $oneitem, 1);
    if ( $iN == $getsizeNlist){ $iN = -1;}
    $iX = 0;
    }

    $iN++;
    $i++;
    }
    return $newItemsList;

}


/******************************************************************************
 * @procedure    CompareCurveIntersect
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $objectLoc : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersect(string $objectLoc[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectLocZ) -1;
    int $Z = size($objectLocZ);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    string $objectLocZ[];
    string $CurveintersectZ;
    string $ItemLists[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $objectLocZ = $objectLoc;
    $X = size($objectLocZ) -1;
    $Z = size($objectLocZ);
    $i = 1;
    $n = -1;
    $n2 = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){
    $CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2]`;
    if (size($CurveintersectZ) > 0) {
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
    } else { print "no Intersect"; }
    $n2++;
    }
    }
    return $ItemLists;

}


/******************************************************************************
 * @procedure    CompareCurveIntersectTwoCurves
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $objectLocA : string[]
 *   $objectAll : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersectTwoCurves(string $objectLocA[], string $objectAll[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Z = size($objectLocA) -1;
    int $X = size( $objectAll) -1;
    int $ix = 0;
    int $n2 = 0;
    string $CurveintersectZA;
    string $CurveintersectZB;
    string $ItemLists[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $Z = size($objectLocA) -1;
    $X = size( $objectAll) -1;
    $ix = 0;
    $n2 = 0;

    while ($X > $ix++){
    $CurveintersectZA = `curveIntersect -ch 0 -tolerance 0.001 $objectLocA[0] $objectAll[$n2]`;
    if (size($CurveintersectZA) > 0) {
    $CurveintersectZB = `curveIntersect -ch 0 -tolerance 0.001 $objectLocA[1] $objectAll[$n2]`;
    if (size($CurveintersectZB) > 0) {
    ArrayInsertAtEnd( $ItemLists, $objectAll[$n2]);
    }
    } else { print "no Intersect"; }
    $n2++;

    }
    return $ItemLists;

}


/******************************************************************************
 * @procedure    CompareCurveIntersect4
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $objectLoc : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersect4(string $objectLoc[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectLocZ) -1;
    int $Z = size($objectLocZ);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    string $objectLocZ[];
    string $CurveintersectZ;
    string $ItemLists[];
    string $shorterList[] = stringArrayRemoveDuplicates($ItemLists);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $objectLocZ = $objectLoc;
    $X = size($objectLocZ) -1;
    $Z = size($objectLocZ);
    $i = 1;
    $n = -1;
    $n2 = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){
    $CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2]`;
    if (size($CurveintersectZ) > 0) {
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
    } else { print "no Intersect"; }
    $n2++;
    }
    }

    $shorterList = stringArrayRemoveDuplicates($ItemLists);
    $ItemLists = $shorterList;
    return $ItemLists;

}


/******************************************************************************
 * @procedure    CompareCurveIntersect2
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $object : string[]
 *   $objectlist : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersect2(string $object[], string $objectlist[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectlist);
    string $ItemListsA[];
    string $CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $object[0] $objectlist[$ix]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $X = size($objectlist);

    $ix = 0;
    $iz = 1;
    while ($X > $ix++){

    $CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $object[0] $objectlist[$ix]`;
    if (size($CurveintersectZ) > 0) {
    ArrayInsertAtEnd( $ItemListsA, $objectlist[$ix]);
    }
    }
    return $ItemListsA;

}


/******************************************************************************
 * @procedure    CompareCurveIntersect5
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $objectLoc : string[]
 *   $objectLocB : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersect5(string $objectLoc[], string $objectLocB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectLocZ);
    int $Z = size($objectLocB);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    string $objectLocZ[];
    string $CurveintersectZ;
    string $ItemLists[];
    string $shorterList[] = stringArrayRemoveDuplicates($ItemLists);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $objectLocZ = $objectLoc;

    $X = size($objectLocZ) ;

    $Z = size($objectLocB);
    $i = 1;
    $n = -1;
    $n2 = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){
    $CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $objectLocZ[$n] $objectLocB[$n2]`;
    if (size($CurveintersectZ) > 0) {
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
    } else { print "no Intersect"; }
    $n2++;
    }
    }

    $shorterList = stringArrayRemoveDuplicates($ItemLists);
    $ItemLists = $shorterList;
    return $ItemLists;

}


/******************************************************************************
 * @procedure    CIRCLESCRIPTZ
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $ObjectCurve : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CIRCLESCRIPTZ(string $ObjectCurve[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $squareA;
    int $squareB;
    float $rotationz[];
    float $translationz[];
    float $bbox[] = `exactWorldBoundingBox $ObjectCurveduplicate`;
    float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox[2]};
    float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox[5]};
    float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox[2]};
    float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox[5]};
    float $BoxMPointAC[] = MidPointBetween($BoxPointA, $BoxPointC);
    float $BoxMPointBD[] = MidPointBetween($BoxPointB, $BoxPointD);
    float $BoxMPointAD[] = MidPointBetween($BoxPointA, $BoxPointD);
    float $BoxMPointBC[] = MidPointBetween($BoxPointB, $BoxPointC);
    float $CrossMPointAB[] = MidPointBetween($BoxPointA, $BoxPointB);
    float $translationzMiddle[];
    float $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    float $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);
    float $squarePercentA;
    float $squarePercentB;
    string $CIRCLEX[];
    string $ObjectCurveduplicate[] = `duplicate -rr $ObjectCurve`;
    string $NewNameZ = `rename $CIRCLEX "Curve"`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //CIRCLE SCRIPT


    //string $newCircle[] = `CIRCLESCRIPTZ($drawcurve)`;
    //string $ObjectCurve[] = $drawcurve;

    $ObjectCurveduplicate = `duplicate -rr $ObjectCurve`;
    setAttr ($ObjectCurveduplicate[0] + ".translate") 0 0 0;
    setAttr ($ObjectCurveduplicate[0] + ".rotate") 0 0 0;
    select -cl  ;
    $rotationz = `xform -q -rotation $ObjectCurve`;
    $translationz = `xform -q -translation $ObjectCurve`;
    $bbox = `exactWorldBoundingBox $ObjectCurveduplicate`;
    //print("Bounding box ranges from: " +
    //      $bbox[0] + "," + $bbox[1] + "," + $bbox[2] + ", to " +
    //      $bbox[3] + "," + $bbox[4] + "," + $bbox[5] + ".\n");
    spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
    move -ws $bbox[0] $bbox[1] $bbox[2] BoxspaceLocatorA;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
    move -ws $bbox[3] $bbox[4] $bbox[5] BoxspaceLocatorB;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
    move -ws $bbox[3] $bbox[1] $bbox[2] BoxspaceLocatorC;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
    move -ws $bbox[0] $bbox[4] $bbox[5] BoxspaceLocatorD;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;
    // xform -query -worldSpace -translation;
    /////////////////////////////////////////
    $BoxPointA = {$bbox[0], $bbox[1], $bbox[2]};
    $BoxPointB = {$bbox[3], $bbox[4], $bbox[5]};
    $BoxPointC = {$bbox[3], $bbox[1], $bbox[2]};
    $BoxPointD = {$bbox[0], $bbox[4], $bbox[5]};

    $BoxPointA = `MakeCleanFloats($BoxPointA)`;
    $BoxPointB = `MakeCleanFloats($BoxPointB)`;
    $BoxPointC = `MakeCleanFloats($BoxPointC)`;
    $BoxPointD = `MakeCleanFloats($BoxPointD)`;

    $BoxMPointAC = MidPointBetween($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween($BoxPointB, $BoxPointC);
    //   MoveObjectSelection($BoxMPointAC);

    $BoxMPointAC = MidPointBetween($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween($BoxPointB, $BoxPointC);

    $CrossMPointAB = MidPointBetween($BoxPointA, $BoxPointB);
    move -ws $bbox[0] $bbox[4] $bbox[5] BoxspaceLocatorD;
    $translationzMiddle = `xform -q -translation BoxspaceLocatorMiddle`;

    $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);
    $distanceAverage =  (($distanceA + $distanceB) * (0.5)) ;
    $radiusX = ( $distanceAverage / 2);
    //if / then
    if ( $distanceA > $distanceAverage) {
    $squarePercentA = (( $distanceAverage / $distanceA ) * (100));
    }
    if ( $distanceA < $distanceAverage) {
    $squarePercentA = (( $distanceA / $distanceAverage ) * (100));
    }
    if ( $distanceB > $distanceAverage) {
    $squarePercentB = (( $distanceAverage / $distanceB ) * (100));
    }
    if ( $distanceB < $distanceAverage) {
    $squarePercentB = (( $distanceB / $distanceAverage ) * (100));
    }
    /////////////////////
    $squareA = 0;
    $squareB = 0;
    print $squarePercentA ;
    if ( $squarePercentA > 55)  {
    $squareA = (0 + 1);
    } else {
    $squareA = (0);
    }
    print $squareA;
    print $squarePercentB ;
    if ( $squarePercentB > 55)  {
    $squareB = ($squareB + 1);
    } else {
    $squareB = (0);
    }
    $addSquareResults = ($squareA + $squareB);
    if ( $addSquareResults == 2 ){
    circle -nr 0 1 0 -c $translationzMiddle[0] $translationzMiddle[1] $translationzMiddle[2] -r $radiusX;
    $CIRCLEX = `ls -sl`;
    $rotationz = `xform -q -rotation $ObjectCurve`;
    setAttr ($CIRCLEX[0] + ".rotateX") $rotationz[0];
    setAttr ($CIRCLEX[0] + ".rotateY") $rotationz[1];
    setAttr ($CIRCLEX[0] + ".rotateZ") $rotationz[2];
    $translationz = `xform -q -translation $ObjectCurve[0]`;
    setAttr ($CIRCLEX[0] + ".translateX") $translationz[0];
    setAttr ($CIRCLEX[0] + ".translateY") $translationz[1];
    setAttr ($CIRCLEX[0] + ".translateZ") $translationz[2];
    //TEMP CHANGE
    //string $currPanel = `getPanel -withFocus` , $camera ;
    //$camera = `modelPanel -q -camera $currPanel`;
    //setAttr ($CIRCLEX[0] + ".rotate") `getAttr ($ObjectCurve[0] + ".rotate")`;
    delete $ObjectCurve $ObjectCurveduplicate BoxspaceLocatorA BoxspaceLocatorB BoxspaceLocatorC BoxspaceLocatorD BoxspaceLocatorMiddle;
    }
    else {
    delete $ObjectCurveduplicate BoxspaceLocatorA BoxspaceLocatorB BoxspaceLocatorC BoxspaceLocatorD BoxspaceLocatorMiddle;
    }
    $NewNameZ = `rename $CIRCLEX "Curve"`;
    $CIRCLEX = {$NewNameZ};
    return $CIRCLEX;


}


/******************************************************************************
 * @procedure    Make_Middle_of_Curve_ParamlocatorZ
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $objectCurveSelected : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Make_Middle_of_Curve_ParamlocatorZ(string $objectCurveSelected[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $a = 1;
    float $arclenghtzALL = `arclen $objectCurveSelected`;
    float $arclenghtzDivide = $arclenghtzALL / 2.0;
    float $step = 10;
    float $t = $a/$step;
    float $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    float $divZZ = $arclenghtzDivide / $arclenghtzparamZ;
    float $divZZ2 = $t * $divZZ;
    float $posA[];
    float $posB[];
    float $posC[];
    string $paramlocatorZARC[];
    string $paramANDCurve[] = `paramToCurvePts( $paramlocatorZARC )`;
    string $CircularArcFromCurve[];
    string $ArcCurve[];
    string $ParentArc[];
    string $MakeArcLocator[];
    string $ArcZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $arclenghtzALL = `arclen $objectCurveSelected`;
    $arclenghtzDivide = $arclenghtzALL / 2.0;

    $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectCurveSelected[0] + ".cv[0]") ;
    $CurveSelection[1] = ($objectCurveSelected[0] + ".cv[" + $numCVrealNum + "]") ;
    $paramlocatorZARC[0] = eval("paramLocator " +  $objectCurveSelected[0] + ".u[" + 0.0 + "]");

    $step = 10;
    $a = 1;
    $t = $a/$step;

    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $t;
    $paramANDCurve = `paramToCurvePts( $paramlocatorZARC )`;
    $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;

    $divZZ = $arclenghtzDivide / $arclenghtzparamZ ;
    $divZZ2 = $t * $divZZ ;
    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $divZZ2;
    ////////////////////// Moved ParamLoc to middle

    $posA = `pointPosition -w $CurveSelection[0]`;
    $posB = `pointPosition -w $paramlocatorZARC[0]`;
    $posC = `pointPosition -w $CurveSelection[1]`;
    $CircularArcFromCurve[0] = `createNode makeThreePointCircularArc`;
    setAttr ($CircularArcFromCurve[0] + ".pt1") $posA[0] $posA[1] $posA[2] ;
    setAttr ($CircularArcFromCurve[0] + ".pt2") $posB[0] $posB[1] $posB[2];
    setAttr ($CircularArcFromCurve[0] + ".pt3") $posC[0] $posC[1] $posC[2];
    setAttr ($CircularArcFromCurve[0] + ".d") 3;
    setAttr ($CircularArcFromCurve[0] + ".s") 8;
    $ArcCurve[0] = `createNode nurbsCurve` ;
    connectAttr ($CircularArcFromCurve[0] + ".oc") ($ArcCurve[0] +".cr");
    //delete $objectCurveSelected;
    $ParentArc = `listRelatives -parent $ArcCurve`;
    ResetTranlation($ParentArc);
    $MakeArcLocator = `spaceLocator -p 0 0 0 -n ArcLocator`;
    move -ws $posB[0] $posB[1] $posB[2] $MakeArcLocator;
    $ConnectLocToPoint2 = `connectAttr -f ($MakeArcLocator[0] + ".translate") ( $CircularArcFromCurve[0] + ".pt2")`;

    $ArcZ[0] = `rename $ParentArc $objectCurveSelected`;
    delete $paramlocatorZARC;
    select -r $ArcZ;
    return $ArcZ;


}


/******************************************************************************
 * @procedure    Strait_ARC_or_FreeForm
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $renamed : string[]
 *   $ArcN : float
 *   $StraitN : float
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Strait_ARC_or_FreeForm(string $renamed[], float $ArcN, float $StraitN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $free = 0;
    int $straitTrigger = 0;
    int $Cvz = $objectAcurveD01;
    int $Cvz2 = $objectAcurveD02;
    float $objectAcurve01 = arclen ($renamed);
    float $curveEndsDis01 = GetDistanceBetweenCurveEnds($renamed);
    float $PercentENDsDiffL = XpercentLess_thenY($objectAcurve01, $curveEndsDis01);
    float $objectAcurveD01 = $objectAcurve01 / 1.5;
    float $PercentDiffS;
    float $posA[] = $VectorCurveEndZ[0];
    float $posB[] = $VectorCurveEndZ[1];
    float $objectAcurveL = arclen ($renamed);
    float $objectBcurveL = arclen ($objectB);
    float $PercentDiffL = XpercentLess_thenY($objectBcurveL, $objectAcurveL);
    float $objectAcurve02 = arclen ($renamed);
    float $objectAcurveD02 = $objectAcurve02 / 1.5;
    string $nameString = $renamed[0];
    string $ParentArc[];
    string $objectB[];
    string $objectC[];
    string $DeleteCurveA[];
    string $DeleteCurveB[];
    string $CurveBetween[];
    vector $VectorCurveEndZ[] = VecCurveEnds($renamed);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $free = 0;
    $nameString = $renamed[0];
    //smoothCurve -ch 1 -rpo 1 -s 6.60 ($nameString +".cv[*]");
    $objectAcurve01 = arclen ($renamed);

    $curveEndsDis01 = GetDistanceBetweenCurveEnds($renamed);
    $PercentENDsDiffL = XpercentLess_thenY($objectAcurve01, $curveEndsDis01);
    $straitTrigger = 0;

    if ( $PercentENDsDiffL < 2 ){ $straitTrigger = 1; }

    $objectAcurveD01 = $objectAcurve01 / 1.5;
    $Cvz = $objectAcurveD01;
    if( $objectAcurve01 < 1.0){ $Cvz = 4; }
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001 $renamed;




    if ($straitTrigger == 1){
    $VectorCurveEndZ = VecCurveEnds($renamed);
    $posA = $VectorCurveEndZ[0];
    $posB = $VectorCurveEndZ[1];
    $CurveBetween = MakeCurveBetweenFloats($posA, $posB);
    ResetTranlation($CurveBetween);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001 $CurveBetween;
    $ParentArc = $CurveBetween; $DeleteCurveA = $renamed; $DeleteCurveB = $objectB;
    }


    if ( $straitTrigger == 0 ){
    $objectB = Make_Middle_of_Curve_ParamlocatorZ($renamed);
    ResetTranlation($objectB);
    $objectC = {$renamed[0], $objectB[0]};
    ResetTranlationEach($objectC);
    $objectAcurveL = arclen ($renamed);
    $objectBcurveL = arclen ($objectB);
    $PercentDiffL = XpercentLess_thenY($objectBcurveL, $objectAcurveL);
    if ($PercentDiffL  < $ArcN){

    $ParentArc = $objectB;  $DeleteCurveA = $renamed;
    }else{

    $free = 1;
    $ParentArc = $renamed; $DeleteCurveA = $objectB; }

    }

    delete $DeleteCurveA;
    rename $ParentArc $nameString;
    $ParentArc[0] = $nameString;


    if ( $free == 1 ){ select -r $ParentArc; EvalSmoothCurves;
    $nameString = $ParentArc[0];
    $objectAcurve02 = arclen ($renamed);
    $objectAcurveD02 = $objectAcurve02 / 1.5;
    $Cvz2 = $objectAcurveD02;
    if( $objectAcurve01 < 1.0){ $Cvz2 = 4; }
    //rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001 $renamed;
    }

    return $ParentArc;


}


/******************************************************************************
 * @procedure    SmoothCurvature4
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $curveM : float
 *   $Steps : int
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvature4(float $curveM, int $Steps)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 3 );
    int $trigger = 0;
    int $Par = 0;
    int $a;
    int $ii = 0;
    int $CVpoints = 0;
    float $curveMin = $curveM;
    float $step = $numEPrealNum2;
    float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = {$Newcurvez};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $myCurve = $curves[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp 1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv[*]");
    $CurveSelection = `ls -fl ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 3 );
    if ($Steps > 8 ){ $numEPrealNum2 = $Steps; }

    $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
    $trigger = 0;
    $curve = "";
    $curveMin = $curveM;
    while ( $trigger < 1 ){
    $step = $numEPrealNum2;
    $curve = "curve -d 3";

    $Par = 0;
    $ii = 0;
    $CVpoints = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
    $values = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    if ( $CurvatureRadi <= $curveMin){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    if (( $CurvatureRadi > $curveMin) && ( $ii == 1 )){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par == 1.0 )){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    }
    if ( $CVpoints < 8 ){ $curveMin++; }
    if ( $CVpoints >= 8 ){ $trigger = 1; }

    }

    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    rename $Newcurve $myCurve;
    $Newcurve = {$myCurve};

    return $Newcurve;

}


/******************************************************************************
 * @procedure    SmoothCurvature13
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $curveM : float
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvature13(float $curveM)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 1 );
    int $trigger = 0;
    int $Par = 0;
    int $b = 0;
    int $ii = 0;
    int $a = 0;
    int $CVpoints = 0;
    float $arcL1 = `arclen $curves[0]`;
    float $arcL1B = ( $arcL1 + ((-1) * ( $arcL1 / 10 )));
    float $curveMin = $curveM;
    float $CurvatureRadi2;
    float $step = $numEPrealNum2;
    float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    float $AverageCurvatureRadi = (($CurvatureRadi + $CurvatureRadi2) / 2);
    float $arcL2 = `arclen $Newcurve[0]`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $crShape[] = `listRelatives -s $curves[0]`;
    string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size ($CurveSelection);
    string $Newcurve[];
    string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`;
    string $Newcurvez;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $arcL1 = `arclen $curves[0]`;
    $arcL1B = ( $arcL1 + ((-1) * ( $arcL1 / 10 )));
    $myCurve = $curves[0];
    $crShape = `listRelatives -s $curves[0]`;
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp 1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv[*]");
    $CurveSelection = `ls -fl ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 1 );
    $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
    $trigger = 0;
    $curve = "";
    $Par = 0;
    $b = 0;
    $ii = 0;
    $a = 0;
    $curveMin = $curveM;
    while ( $trigger < 1 ){
    $step = $numEPrealNum2;
    $curve = "curve -d 3";
    $CVpoints = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = $a/$step;
    setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
    if ( $Par > 0.0 ){ $b = $a -1; $Par2 = $b/$step;
    $CurvatureRadi2 = `pointOnCurve -top 1 -pr $Par2 -cr $crShape[0]`; }
    $values = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;

    $AverageCurvatureRadi = (($CurvatureRadi + $CurvatureRadi2) / 2);

    if ( $AverageCurvatureRadi <= $curveMin){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    if (( $CurvatureRadi > $curveMin) && ( $ii == 1 )){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par == 1.0 )){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    }
    if ( $CVpoints < 8 ){ $curveMin++; }
    if ( $CVpoints > 2 ){
    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    $arcL2 = `arclen $Newcurve[0]`;
    if ( $arcL2 < $arcL1B ){ delete $Newcurve; $trigger = 0; $numEPrealNum2 = $numEPrealNum2 + 3;   }
    if (( $CVpoints >= 8 )&& ( $arcL2 > $arcL1B )){ $trigger = 1; }
    }
    }

    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    rename $Newcurve $myCurve;
    $Newcurve = {$myCurve};

    return $Newcurve;

}


/******************************************************************************
 * @procedure    SmoothCurvature3
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $curveM : float
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvature3(float $curveM)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 2 );
    int $Par = 0;
    int $a;
    int $ii = 0;
    float $step = $numEPrealNum2;
    float $curveMin = $curveM;
    float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = {$Newcurvez};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $myCurve = $curves[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp 1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv[*]");
    $CurveSelection = `ls -fl ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 2 );
    //Above was Times * 4

    $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
    $step = $numEPrealNum2;
    $curve = "curve -d 3";
    $curveMin = $curveM;
    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
    $values = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    if ( $CurvatureRadi <= $curveMin){ PAUSE;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    if (( $CurvatureRadi > $curveMin) && ( $ii == 1 )){
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }


    if (( $CurvatureRadi > $curveMin) && ( $Par == 1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    }

    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    rename $Newcurve $myCurve;
    $Newcurve = {$myCurve};

    return $Newcurve;

}


/******************************************************************************
 * @procedure    SmoothCurvatureReverse6
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $curveM : float
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvatureReverse6(float $curveM)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 2 );
    int $Par = 0;
    int $a;
    int $ii = 0;
    float $step = $numEPrealNum2;
    float $curveMin = $curveM;
    float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = {$Newcurvez};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $myCurve = $curves[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp 1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv[*]");
    $CurveSelection = `ls -fl ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 2 );
    //Above was Times * 4

    $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
    $step = $numEPrealNum2;
    $curve = "curve -d 3";
    $curveMin = $curveM;
    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
    $values = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    if ( $CurvatureRadi >= $curveMin){
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    if (( $CurvatureRadi < $curveMin) && ( $ii == 1 )){
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }


    if (( $CurvatureRadi < $curveMin) && ( $Par == 1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    }

    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    rename $Newcurve $myCurve;
    $Newcurve = {$myCurve};

    return $Newcurve;

}


/******************************************************************************
 * @procedure    XpercentLess_thenY
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Ix : float
 *   $Iy : float
 *
 * @returns      float
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float XpercentLess_thenY(float $Ix, float $Iy)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $N;
    float $Ni;
    float $PercentA;
    float $PercentB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if ( $Ix > $Iy){
    $Ni = $Ix; $N = $Iy; } else { $N = $Ix;  $Ni = $Iy; }
    $PercentA = ((float($N) / $Ni) * (100) );
    $PercentB = 100 - $PercentA;
    return $PercentB;

}


/******************************************************************************
 * @procedure    Strait_ARC_or_FreeFormFind
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $renamed : string[]
 *   $ArcN : float
 *   $StraitN : float
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int Strait_ARC_or_FreeFormFind(string $renamed[], float $ArcN, float $StraitN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SAF = 0;
    float $objectAcurve = GET_AREA_OF_CURVE ($renamed);
    float $objectBcurve = GET_AREA_OF_CURVE ($objectB);
    float $PercentDiff = XpercentLess_thenY($objectBcurve, $objectAcurve);
    float $objectAcurveL = arclen ($renamed);
    float $objectBcurveL = arclen ($objectB);
    float $PercentDiffL = XpercentLess_thenY($objectBcurveL, $objectAcurveL);
    float $PercentAverage = ($PercentDiff + $PercentDiffL) /2;
    float $posA[] = $VectorCurveEndZ[0];
    float $posB[] = $VectorCurveEndZ[1];
    float $objectCcurveL = arclen ($CurveBetween);
    float $PercentDiffS = XpercentLess_thenY($objectCcurveL, $objectAcurveL);
    string $nameString = $renamed[0];
    string $ParentArc[];
    string $objectB[] = Make_Middle_of_Curve_ParamlocatorZ($renamed);
    string $objectC[] = {$renamed[0], $objectB[0]};
    string $CurveBetween[] = MakeCurveBetweenFloats($posA, $posB);
    string $DeleteCurveA[];
    string $DeleteCurveB[];
    vector $VectorCurveEndZ[] = VecCurveEnds($renamed);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $SAF = 0;
    $nameString = $renamed[0];
    //rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001 $renamed;
    $objectB = Make_Middle_of_Curve_ParamlocatorZ($renamed);
    ResetTranlation($objectB);
    $objectC = {$renamed[0], $objectB[0]};
    ResetTranlationEach($objectC);
    $objectAcurve = GET_AREA_OF_CURVE ($renamed);
    $objectBcurve = GET_AREA_OF_CURVE ($objectB);
    /////////////////////////

    $PercentDiff = XpercentLess_thenY($objectBcurve, $objectAcurve);

    $objectAcurveL = arclen ($renamed);
    $objectBcurveL = arclen ($objectB);
    $PercentDiffL = XpercentLess_thenY($objectBcurveL, $objectAcurveL);
    $PercentAverage = ($PercentDiff + $PercentDiffL) /2;

    $VectorCurveEndZ = VecCurveEnds($renamed);
    $posA = $VectorCurveEndZ[0];
    $posB = $VectorCurveEndZ[1];
    $CurveBetween = MakeCurveBetweenFloats($posA, $posB);
    ResetTranlation($CurveBetween);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001 $CurveBetween;
    $objectCcurveL = arclen ($CurveBetween);
    $PercentDiffS = XpercentLess_thenY($objectCcurveL, $objectAcurveL);
    print ("PercentDiff_Curve_to_Arc AREA "+$PercentDiff + "\n");
    print ("PercentDiff_Curve_to_Arc L "+$PercentDiffL + "\n");
    print (" " + "\n");
    print ("PercentDiff_Curve_to_Arc Average "+$PercentAverage + "\n");
    print (" " + "\n");
    print ("PercentDiff_Curve_to_STRAIT "+$PercentDiffS + "\n");


    if (($PercentAverage< $ArcN) && ($PercentDiffS > $StraitN)){
    print ("ARC Curve"+ "\n"); $SAF = 0;

    }else if ($PercentDiffS < $StraitN){
    print ("STRAIT Curve"+ "\n"); $SAF = 1;

    } else {
    print ("FREEFORM Curve"+ "\n"); $SAF = 2;
    }

    delete $CurveBetween  $objectB;

    return $SAF;


}


/******************************************************************************
 * @procedure    AddorSubtract
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Number : int
 *   $AorS : int
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int AddorSubtract(int $Number, int $AorS)
{


    if ($AorS == 1){ $Number++; return $Number;}
    if ($AorS == 0){ $Number--; return $Number;}
    if ($AorS == 2){ $Number = 0; return $Number;}


}


/******************************************************************************
 * @procedure    RoundFloat
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $val : float
 *   $dec : float
 *
 * @returns      float
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float RoundFloat(float $val, float $dec)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $dec = `pow 10 $dec`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $sign = `sign $val`;
    $dec = `pow 10 $dec`;
    $val = (int) (($val + $sign*5/($dec*10)) * $dec);
    $val = ($val / $dec);
    return $val;

}


/******************************************************************************
 * @procedure    IsCircle
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int IsCircle()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IsCircle = 0;
    int $pA1 = PointsEquivalentTol($CurveCVzero,$BoxPointA);
    int $pA2 = PointsEquivalentTol($CurveCVLast,$BoxPointA);
    int $pC1 = PointsEquivalentTol($CurveCVzero,$BoxPointC);
    int $pC2 = PointsEquivalentTol($CurveCVLast,$BoxPointC);
    int $AorC = 0;
    int $squareA = 0;
    int $squareB = 0;
    float $rotationz[];
    float $translationz[];
    float $ArcLength = `arclen $ObjectCurve[0]`;
    float $bbox[] = `exactWorldBoundingBox $ObjectCurveduplicate`;
    float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox[2]};
    float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox[5]};
    float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox[2]};
    float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox[5]};
    float $BoxMPointAC[] = MidPointBetween($BoxPointA, $BoxPointC);
    float $BoxMPointBD[] = MidPointBetween($BoxPointB, $BoxPointD);
    float $BoxMPointAD[] = MidPointBetween($BoxPointA, $BoxPointD);
    float $BoxMPointBC[] = MidPointBetween($BoxPointB, $BoxPointC);
    float $CrossMPointAB[] = MidPointBetween($BoxPointA, $BoxPointB);
    float $translationzMiddle[];
    float $CurveCVzero[] = GetCurveCVposENDS($ObjectCurveduplicate, 0);
    float $CurveCVLast[] = GetCurveCVposENDS($ObjectCurveduplicate, 1);
    float $distanceBetween = PointsGetDistanceFLOAT($CurveCVzero, $CurveCVLast);
    float $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    float $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);
    float $distanceC = PointsGetDistanceFLOAT($BoxPointA, $BoxPointD);
    float $distanceAverage = (($distanceA + $distanceB) * (0.5));
    float $radiusX = ( $distanceAverage / 2.0);
    float $distanceAverageA = $distanceC;
    float $radiusXA = (($distanceC) * (0.5));
    float $Pi = 3.141593;
    float $circleArc = (($Pi) * ($distanceC));
    float $percentLess = XpercentLess_thenY( $circleArc, $ArcLength);
    float $squarePercentA;
    float $squarePercentB;
    string $ObjectCurve[];
    string $StraitCurve[];
    string $ObjectCurveduplicate[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //StraitCurves SCRIPT

    $IsCircle = 0;

    $ObjectCurve = `ls -selection`;
    xform -cp;
    resetPivot;
    duplicatePreset(1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1);

    $ObjectCurveduplicate = `ls -selection`;
    setAttr ($ObjectCurveduplicate[0] + ".translate") 0 0 0;
    setAttr ($ObjectCurveduplicate[0] + ".rotate") 0 0 0;
    playButtonStepForward; select -cl  ;

    $rotationz = `xform -q -rotation $ObjectCurve`;
    $translationz = `xform -q -translation $ObjectCurve`;
    $ArcLength = `arclen $ObjectCurve[0]`;

    $bbox = `exactWorldBoundingBox $ObjectCurveduplicate`;
    print("Bounding box ranges from: " +
    $bbox[0] + "," + $bbox[1] + "," + $bbox[2] + ", to " +
    $bbox[3] + "," + $bbox[4] + "," + $bbox[5] + ".\n");


    spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
    move -ws $bbox[0] $bbox[1] $bbox[2] BoxspaceLocatorA;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
    move -ws $bbox[3] $bbox[4] $bbox[5] BoxspaceLocatorB;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
    move -ws $bbox[3] $bbox[1] $bbox[2] BoxspaceLocatorC;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
    move -ws $bbox[0] $bbox[4] $bbox[5] BoxspaceLocatorD;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;

    // xform -query -worldSpace -translation;


    $BoxPointA = {$bbox[0], $bbox[1], $bbox[2]};
    $BoxPointB = {$bbox[3], $bbox[4], $bbox[5]};
    $BoxPointC = {$bbox[3], $bbox[1], $bbox[2]};
    $BoxPointD = {$bbox[0], $bbox[4], $bbox[5]};

    $BoxPointA = `MakeCleanFloats($BoxPointA)`;
    $BoxPointB = `MakeCleanFloats($BoxPointB)`;
    $BoxPointC = `MakeCleanFloats($BoxPointC)`;
    $BoxPointD = `MakeCleanFloats($BoxPointD)`;

    $BoxMPointAC = MidPointBetween($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween($BoxPointB, $BoxPointC);
    //   MoveObjectSelection($BoxMPointAC);

    ///////////////////////////////
    ///////////////////////////////

    $CrossMPointAB = MidPointBetween($BoxPointA, $BoxPointB);

    // BoxspaceLocatorMiddle CHANGES need here in the future

    $translationzMiddle = $CrossMPointAB;


    $CurveCVzero = GetCurveCVposENDS($ObjectCurveduplicate, 0);
    $CurveCVLast = GetCurveCVposENDS($ObjectCurveduplicate, 1);
    $distanceBetween = PointsGetDistanceFLOAT($CurveCVzero, $CurveCVLast);

    $pA1 = PointsEquivalentTol($CurveCVzero,$BoxPointA);
    $pA2 = PointsEquivalentTol($CurveCVLast,$BoxPointA);
    $pC1 = PointsEquivalentTol($CurveCVzero,$BoxPointC);
    $pC2 = PointsEquivalentTol($CurveCVLast,$BoxPointC);

    $AorC = 0;
    if (($pA1 == 3) || ($pA2 == 3)){
    $AorC = 1;
    }
    if (($pC1 == 3) || ($pC2 == 3)){
    $AorC = 2;
    }
    $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);

    $distanceC = PointsGetDistanceFLOAT($BoxPointA, $BoxPointD);

    $distanceAverage = (($distanceA + $distanceB) * (0.5)) ;
    $radiusX = ( $distanceAverage / 2.0);

    $distanceAverageA = $distanceC ;
    $radiusXA = (($distanceC) * (0.5)) ;
    // Result: 38.390151 //

    $Pi = 3.141593;
    $circleArc = (($Pi) * ($distanceC));

    $percentLess = XpercentLess_thenY( $circleArc, $ArcLength);


    if ( $distanceA > $distanceAverage) {
    $squarePercentA = (( $distanceAverage / $distanceA ) * (100));
    }

    if ( $distanceA < $distanceAverage) {
    $squarePercentA = (( $distanceA / $distanceAverage ) * (100));
    }

    if ( $distanceB > $distanceAverage) {
    $squarePercentB = (( $distanceAverage / $distanceB ) * (100));
    }
    if ( $distanceB < $distanceAverage) {
    $squarePercentB = (( $distanceB / $distanceAverage ) * (100));
    }
    /////////////////////


    $squareA = 0;
    $squareB = 0;
    if ( $squarePercentA > 55){
    $squareA = 1;
    }
    if ( $squarePercentB > 55){
    $squareB =  1;
    }


    $addSquareResults = ($squareA + $squareB);
    if (( $addSquareResults == 2 ) && ( $percentLess < 12.0 )) {
    $IsCircle = 1;

    } else {
    // Not Diagonal curves
    $IsCircle = 0;
    }

    /*
    setAttr ($StraitCurve[0] + ".rotateX") $rotationz[0];
    setAttr ($StraitCurve[0] + ".rotateY") $rotationz[1];
    setAttr ($StraitCurve[0] + ".rotateZ") $rotationz[2];
    setAttr ($StraitCurve[0] + ".translateX") $translationz[0];
    setAttr ($StraitCurve[0] + ".translateY") $translationz[1];
    setAttr ($StraitCurve[0] + ".translateZ") $translationz[2];
    */

    select -r $ObjectCurveduplicate BoxspaceLocatorA BoxspaceLocatorB BoxspaceLocatorC BoxspaceLocatorD BoxspaceLocatorMiddle;
    delete;
    print ("IsCircle " + $IsCircle);
    print ("percentLess " + $percentLess);
    print ("addSquareResults " + $addSquareResults);
    return $IsCircle;


}


/******************************************************************************
 * @procedure    EulerAngleofTwoPoints
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $EACHCVposAZ : float[]
 *   $EACHCVposBZ : float[]
 *
 * @returns      float[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] EulerAngleofTwoPoints(float $EACHCVposAZ[], float $EACHCVposBZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Z = FindclosetTOcurveENDz($pointB1, $pointB2, $vector_SubUnitMagVec2);
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $pointCVAB_MidPoint[] = MidPointBetween($EACHCVposHigher, $EACHCVposLower);
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $curveArclenZ = PointsGetDistanceFLOAT($EACHCVposAZ, $EACHCVposBZ);
    float $DivideIt = $curveArclenZ / 2.0;
    float $DivideIt2 = $DivideIt * -1;
    float $pointB1[] = {0.0 , 0.0 , $DivideIt};
    float $pointB2[] = {0.0 , 0.0 , $DivideIt2};
    float $EulerAngleA[] = `angleBetween -euler -v1 $pointB1[0] $pointB1[1] $pointB1[2] -v2  $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2[1]     $vector_SubUnitMagVec2[2]`;
    float $EulerAngleB[] = `angleBetween -euler -v1 $pointB2[0] $pointB2[1] $pointB2[2] -v2 $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1[1]     $vector_SubUnitMagVec1[2]`;
    vector $vectorZ1 = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $pointCVAB_MidPoint);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposLower, $pointCVAB_MidPoint);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $vectorZ1 = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    if ( $MagVectorZ1 > $MagVectorZ2 ){
    print (" posA is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposAZ;
    $EACHCVposLower = $EACHCVposBZ;
    }
    if ( $MagVectorZ1 < $MagVectorZ2  ){
    print (" posB is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    }
    $pointCVAB_MidPoint = MidPointBetween($EACHCVposHigher, $EACHCVposLower);
    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher, $pointCVAB_MidPoint);
    $vector_SubUnitMagVec1 = SubtractFloats($EACHCVposHigher,$UnitVectorMagPosHigher[1]);
    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposLower, $pointCVAB_MidPoint);
    $vector_SubUnitMagVec2 = SubtractFloats($EACHCVposLower,$UnitVectorMagPosLower[1]);
    /////////////////////////////////////////////////////
    $curveArclenZ = PointsGetDistanceFLOAT($EACHCVposAZ, $EACHCVposBZ);
    $DivideIt = $curveArclenZ / 2.0;
    $DivideIt2 = $DivideIt * -1;
    $pointB1 = {0.0 , 0.0 , $DivideIt} ;
    $pointB2 = {0.0 , 0.0 , $DivideIt2} ;
    /// NOTE curve ENds will not allways Line up and may be inverted
    //let $F1 be the first CV $F2 the last .. $F3 third point
    $Z = FindclosetTOcurveENDz($pointB1, $pointB2, $vector_SubUnitMagVec2);
    if ($Z == 1){ print "new floats"; $pointB1 = $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
    $EulerAngleA = `angleBetween -euler -v1 $pointB1[0] $pointB1[1] $pointB1[2] -v2  $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2[1]     $vector_SubUnitMagVec2[2]`;
    $EulerAngleB = `angleBetween -euler -v1 $pointB2[0] $pointB2[1] $pointB2[2] -v2 $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1[1]     $vector_SubUnitMagVec1[2]`;

    return $EulerAngleA;

}


/******************************************************************************
 * @procedure    getYrotationOFcam
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      float[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] getYrotationOFcam()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $CamerasDirectionVector[];
    float $CamerasPositionz[];
    float $CamLengthVector[];
    float $CP[] = $CamerasPositionz;
    float $CamEulerAngleN[] = {$CamLengthVector[0], 0.0, $CamLengthVector[2]};
    float $CamEulerAngleNi[] = {$CamerasPositionz[0], 0.0, $CamerasPositionz[2]};
    float $CamEulerAngle[] = EulerAngleofTwoPoints($CamEulerAngleN, $CamEulerAngleNi);
    string $currPanel = `getPanel -withFocus` , $camera;
    string $Camera = `modelEditor -q -camera $currPanel`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    //============================================
    $CamerasDirectionVector = nurbsViewDirectionVector(0);
    //============================================ ;) nurbsViewDirectionVector =====
    $currPanel = `getPanel -withFocus` , $camera ;
    $Camera = `modelEditor -q -camera $currPanel`;
    $CamerasPositionz = `camera -q -position $Camera`;
    $CP = $CamerasPositionz;

    $CamLengthVector = AddFloats($CamerasDirectionVector, $CP);

    $CamEulerAngleN = {$CamLengthVector[0], 0.0, $CamLengthVector[2]};
    $CamEulerAngleNi = {$CamerasPositionz[0], 0.0, $CamerasPositionz[2]};
    $CamEulerAngle = EulerAngleofTwoPoints($CamEulerAngleN, $CamEulerAngleNi);

    return $CamEulerAngle;

}


/******************************************************************************
 * @procedure    ZplainFlatten
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ZplainFlatten()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Y = 0;
    float $CamEulerAngle[] = `getYrotationOFcam`;
    float $CamEulerAngleY = `abs $CamEulerAngle[1]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Y = 0;
    $CamEulerAngle = `getYrotationOFcam`;
    $CamEulerAngleY = `abs $CamEulerAngle[1]`;
    if ($CamEulerAngleY < 22.0){
    $Y = 1; print "Less then 22";
    }
    return $Y;

}


/******************************************************************************
 * @procedure    EulerAngleofCurve
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      float[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] EulerAngleofCurve()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    int $Z = FindclosetTOcurveENDz($pointB1, $pointB2, $vector_SubUnitMagVec2);
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $pointCVAB_MidPoint[] = MidPointBetween($EACHCVposHigher, $EACHCVposLower);
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $curveArclenZ = `arclen $CurveItem`;
    float $DivideIt = $curveArclenZ / 2.0;
    float $DivideIt2 = $DivideIt * -1;
    float $pointB1[] = {0.0 , 0.0 , $DivideIt};
    float $pointB2[] = {0.0 , 0.0 , $DivideIt2};
    float $EulerAngleA[] = `angleBetween -euler -v1 $pointB1[0] $pointB1[1] $pointB1[2] -v2  $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2[1]     $vector_SubUnitMagVec2[2]`;
    float $EulerAngleB[] = `angleBetween -euler -v1 $pointB2[0] $pointB2[1] $pointB2[2] -v2 $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1[1]     $vector_SubUnitMagVec1[2]`;
    string $CurveItem[];
    string $CurveSelection[];
    vector $vectorZ1 = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $pointCVAB_MidPoint);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposLower, $pointCVAB_MidPoint);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveItem = `ls -sl`;
    $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA  )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    $vectorZ1 = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    if ( $MagVectorZ1 > $MagVectorZ2 ){
    print (" posA is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposAZ;
    $EACHCVposLower = $EACHCVposBZ;
    }
    if ( $MagVectorZ1 < $MagVectorZ2  ){
    print (" posB is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    }
    $pointCVAB_MidPoint = MidPointBetween($EACHCVposHigher, $EACHCVposLower);
    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher, $pointCVAB_MidPoint);
    $vector_SubUnitMagVec1 = SubtractFloats($EACHCVposHigher,$UnitVectorMagPosHigher[1]);
    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposLower, $pointCVAB_MidPoint);
    $vector_SubUnitMagVec2 = SubtractFloats($EACHCVposLower,$UnitVectorMagPosLower[1]);
    /////////////////////////////////////////////////////
    $curveArclenZ = `arclen $CurveItem`;
    $DivideIt = $curveArclenZ / 2.0;
    $DivideIt2 = $DivideIt * -1;
    $pointB1 = {0.0 , 0.0 , $DivideIt} ;
    $pointB2 = {0.0 , 0.0 , $DivideIt2} ;
    /// NOTE curve ENds will not allways Line up and may be inverted
    //let $F1 be the first CV $F2 the last .. $F3 third point
    $Z = FindclosetTOcurveENDz($pointB1, $pointB2, $vector_SubUnitMagVec2);
    if ($Z == 1){ print "new floats"; $pointB1 = $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
    $EulerAngleA = `angleBetween -euler -v1 $pointB1[0] $pointB1[1] $pointB1[2] -v2  $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2[1]     $vector_SubUnitMagVec2[2]`;
    $EulerAngleB = `angleBetween -euler -v1 $pointB2[0] $pointB2[1] $pointB2[2] -v2 $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1[1]     $vector_SubUnitMagVec1[2]`;

    return $EulerAngleA;

}


/******************************************************************************
 * @procedure    MidPointBetween
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $loc1 : float[]
 *   $loc2 : float[]
 *
 * @returns      float []
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] MidPointBetween(float $loc1[], float $loc2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $a = ($loc2[0] + $loc1[0]) * (0.5);
    float $b = ($loc2[1] + $loc1[1]) * (0.5);
    float $c = ($loc2[2] + $loc1[2]) * (0.5);
    float $MidPoint[] = {$a , $b , $c};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $a = ($loc2[0] + $loc1[0]) * (0.5);
    $b = ($loc2[1] + $loc1[1]) * (0.5);
    $c = ($loc2[2] + $loc1[2]) * (0.5);

    $MidPoint = {$a , $b , $c};
    return $MidPoint;

}


/******************************************************************************
 * @procedure    PointsEquivalentTol
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int PointsEquivalentTol(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $pX = equivalentTol($posA[0], $posB[0], 0.001);
    int $pY = equivalentTol($posA[1], $posB[1], 0.001);
    int $pZ = equivalentTol($posA[2], $posB[2], 0.001);
    int $addedResults = $pX + $pY + $pZ;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pX = equivalentTol($posA[0], $posB[0], 0.001);
    $pY = equivalentTol($posA[1], $posB[1], 0.001);
    $pZ = equivalentTol($posA[2], $posB[2], 0.001);
    $addedResults = $pX + $pY + $pZ;
    if ($addedResults == 3 ){ print "Points equivalent";
    }
    return $addedResults;

}


/******************************************************************************
 * @procedure    MagTimesUnitVecs
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $vectorZFlatYHigher : vector
 *   $vectorZFlatYLower : vector
 *
 * @returns      vector[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] MagTimesUnitVecs(vector $vectorZFlatYHigher, vector $vectorZFlatYLower)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MagVectorZYHigher = mag($vectorZFlatYHigher);
    float $MagVectorZYLower = mag($vectorZFlatYLower);
    vector $unitVectormagZYHL[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MagVectorZYHigher = mag($vectorZFlatYHigher);
    $MagVectorZYLower = mag($vectorZFlatYLower);
    $unitVectormagZYHL[0] = $MagVectorZYHigher * unit($vectorZFlatYHigher);
    $unitVectormagZYHL[1] = $MagVectorZYLower * unit($vectorZFlatYLower);
    print $unitVectormagZYHL;
    return $unitVectormagZYHL;

}


/******************************************************************************
 * @procedure    AppendFloatsZ
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *   $XYZ : int
 *
 * @returns      float[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] AppendFloatsZ(float $posA[], float $posB[], int $XYZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if($XYZ == 0){ $AddposA_AND_posB_float = {$posB[0], $posA[1], $posA[2]} ; }
    if($XYZ == 1){ $AddposA_AND_posB_float = {$posA[0], $posB[1], $posA[2]} ; }
    if($XYZ == 2){ $AddposA_AND_posB_float = {$posA[0], $posA[1], $posB[2]} ; }
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    CycleFloatsZ
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *   $XYZ1 : int
 *   $XYZ2 : int
 *
 * @returns      float[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] CycleFloatsZ(float $posA[], float $posB[], int $XYZ1, int $XYZ2)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if(($XYZ1 == 0) && ($XYZ2 == 1)){ $AddposA_AND_posB_float = {$posA[1], $posA[0], $posA[2]} ; } //01 xy
    if(($XYZ1 == 0) && ($XYZ2 == 2)){ $AddposA_AND_posB_float = {$posA[2], $posB[1], $posA[0]} ; } //02 xz
    if(($XYZ1 == 1) && ($XYZ2 == 2)){ $AddposA_AND_posB_float = {$posA[0], $posA[2], $posB[1]} ; } //12 yz
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    AddFloats
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] AddFloats(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $AddposA_AND_posB_float = {($posA[0] + $posB[0]), ($posA[1] + $posB[1]), ($posA[2] + $posB[2])} ;
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    SubtractFloats
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] SubtractFloats(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $SubtractposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SubtractposA_AND_posB_float = {($posA[0] - $posB[0]), ($posA[1] - $posB[1]), ($posA[2] - $posB[2])} ;
    return $SubtractposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    Add_Float_to_3PointFloats
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $posA : float
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] Add_Float_to_3PointFloats(float $posA, float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $AddposA_AND_posB_float = {($posA + $posB[0]), ($posA + $posB[1]), ($posA + $posB[2])} ;
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    SubtractFloat_to_3PointFloats
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $posA : float
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] SubtractFloat_to_3PointFloats(float $posA, float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $SubtractposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SubtractposA_AND_posB_float = {($posA - $posB[0]), ($posA - $posB[1]), ($posA - $posB[2])} ;
    return $SubtractposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    GetDegreesFromFloat
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      float
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float GetDegreesFromFloat(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $xy_angle = angle ($xvex, $yvex);
    float $Some_degrees = `rad_to_deg $xy_angle`;
    vector $xvex = << $posA[0], $posA[1], $posA[2] >>;
    vector $yvex = << $posB[0], $posB[1], $posB[2] >>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $xvex = << $posA[0], $posA[1], $posA[2] >> ;
    $yvex = << $posB[0], $posB[1], $posB[2] >> ;
    $xy_angle = angle ($xvex, $yvex) ;
    $Some_degrees = `rad_to_deg $xy_angle`;
    print $Some_degrees;
    return $Some_degrees;

}


/******************************************************************************
 * @procedure    GetDistanceBetweenCurveEnds
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $CurveItem : string[]
 *
 * @returns      float
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float GetDistanceBetweenCurveEnds(string $CurveItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    string $CurveSelection[];
    string $MakeXBetweenB[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA  )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    $dAx = $EACHCVposAZ[0] - $EACHCVposBZ[0]; $dAy = $EACHCVposAZ[1] - $EACHCVposBZ[1];
    $dAz = $EACHCVposAZ[2] - $EACHCVposBZ[2]; float $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    GetDistanceFLOAT
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $objectFirst : string
 *   $objectSecond : string
 *
 * @returns      float
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float GetDistanceFLOAT(string $objectFirst, string $objectSecond)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $pointAZ1[];
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pointAZ1 = `xform -query -worldSpace -translation ($objectFirst)`;
    $pointAZ2 = `xform -query -worldSpace -translation ($objectSecond)`;
    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    PointsGetDistanceFLOAT
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $pointAZ1 : float[]
 *   $pointAZ2 : float[]
 *
 * @returns      float
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float PointsGetDistanceFLOAT(float $pointAZ1[], float $pointAZ2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    ZeroOrONE
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $objectLoc : string[]
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ZeroOrONE(string $objectLoc[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectLocZ) -1;
    int $Z = size($objectLocZ);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    int $Zero0rOne = 0;
    float $SubtractAB[];
    float $posA[];
    float $posB[];
    string $objectLocZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $objectLocZ = $objectLoc;
    $X = size($objectLocZ) -1;
    $Z = size($objectLocZ);
    $i = 1;
    $n = -1;
    $n2 = 0;
    $Zero0rOne = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){

    $posA = `xform -q -wd -translation $objectLocZ[$n]`;
    $posB = `xform -q -wd -translation $objectLocZ[$n2]`;
    $n2++;
    $SubtractAB = SubtractFloats($posA, $posB);
    if (($SubtractAB[0] == 0) && ($SubtractAB[1] == 0) && ($SubtractAB[2] == 0 )){
    print "yes AB";
    $Zero0rOne = 1;
    }
    }
    }
    return $Zero0rOne;

}


/******************************************************************************
 * @procedure    GetCurveCVposENDS
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $CurveItem : string[]
 *   $ix : int
 *
 * @returns      float[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] GetCurveCVposENDS(string $CurveItem[], int $ix)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    string $CurveSelection[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA  )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    if ($ix == 0){
    return $EACHCVposAZ; }
    if ($ix == 1){
    return $EACHCVposBZ; }

}


/******************************************************************************
 * @procedure    VecCurveEnds
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $CurveItem : string[]
 *
 * @returns      vector[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] VecCurveEnds(string $CurveItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    string $CurveSelection[];
    vector $VectorCurveEnds[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA  )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    $VectorCurveEnds[0] = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $VectorCurveEnds[1] = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;

    return $VectorCurveEnds;

}


/******************************************************************************
 * @procedure    MakeCurveBetweenFloats
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] MakeCurveBetweenFloats(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $ZBetween[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $ZBetween[0] = `curve -d 1 -p $posA[0] $posA[1] $posA[2] -p $posB[0] $posB[1] $posB[2] -k 0 -k 2 -n ZCurveBetween`;
    return $ZBetween;

}


/******************************************************************************
 * @procedure    MakeCleanFloats
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $FloatZ : float[]
 *
 * @returns      float[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] MakeCleanFloats(float $FloatZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroORZe1 = `gmatch "e" $nameAe`;
    int $zeroORZe2 = `gmatch "e" $nameBe`;
    int $zeroORZe3 = `gmatch "e" $nameCe`;
    string $POSAe = $FloatZ[0];
    string $POSCe = $FloatZ[2];
    string $nameAe;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $POSAe = $FloatZ[0]; string $POSBe = $FloatZ[1];
    $POSCe = $FloatZ[2];
    $nameAe = `match "e" $POSAe`;
    $nameBe = `match "e" $POSBe`;
    $nameCe = `match "e" $POSCe`;
    $zeroORZe1 = `gmatch "e" $nameAe`;
    $zeroORZe2 = `gmatch "e" $nameBe`;
    $zeroORZe3 = `gmatch "e" $nameCe`;
    if ( $zeroORZe1 == 1){ $FloatZ[0] = 0.0; }
    if ( $zeroORZe2 == 1){ $FloatZ[1] = 0.0; }
    if ( $zeroORZe3 == 1){ $FloatZ[2] = 0.0; }
    return $FloatZ;

}


/******************************************************************************
 * @procedure    MakeCleanFloat1
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $FloatZ : float
 *
 * @returns      float
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float MakeCleanFloat1(float $FloatZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroORZe1 = `gmatch "e" $nameAe`;
    string $POSAe = $FloatZ;
    string $nameAe;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $POSAe = $FloatZ;
    $nameAe = `match "e" $POSAe`;
    $zeroORZe1 = `gmatch "e" $nameAe`;
    if ( $zeroORZe1 == 1){ $FloatZ = 0.0; }
    return $FloatZ;

}


/******************************************************************************
 * @procedure    PercentDiff_Curve_to_Arc
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $arclenghtzARC : float
 *   $arclenghtzDRAWN : float
 *
 * @returns      float
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float PercentDiff_Curve_to_Arc(float $arclenghtzARC, float $arclenghtzDRAWN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $PercentA;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PercentA = ((float($arclenghtzARC) / $arclenghtzDRAWN) * (100) );
    return $PercentA;

}


/******************************************************************************
 * @procedure    paramToCurvePts3
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $locatorShapes : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] paramToCurvePts3(string $locatorShapes[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $numLocators = size($locatorShapes);
    string $curveName[];
    string $parent1[] = `listRelatives -p $locatorShapes[$i]`;
    string $parent2[] = `listRelatives -p $parent1[0]`;
    string $parent3[] = `listRelatives -p $parent2[0]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numLocators = size($locatorShapes);
    for( $i = 0; $i < $numLocators; $i ++ ) {
    // Get the parent transform above the locator shape
    $parent1 = `listRelatives -p $locatorShapes[$i]`;
    $parent2 = `listRelatives -p $parent1[0]`;
    $parent3 = `listRelatives -p $parent2[0]`;
    $curveName[ size($curveName) ] = $parent3[0];
    }
    return $curveName;

}


/******************************************************************************
 * @procedure    paramToCurvePts2
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $locatorShapes : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] paramToCurvePts2(string $locatorShapes[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroORZA;
    int $zeroORZB;
    int $i;
    int $numLocators = size($locatorShapes);
    float $parm;
    float $pos[] = `getAttr ($locatorShapes[$i] + ".localPosition")`;
    float $result[] = `getAttr ($pmm+".output")`;
    string $parent2A[];
    string $selectionList[];
    string $curveName;
    string $nameA;
    string $parent1[];
    string $parent2[];
    string $ObjectParZ1[];
    string $bufferCutCurveA[];
    string $numTokensZA;
    string $ObjectParZ2[];
    string $bufferCutCurveB[];
    string $numTokensZB;
    string $nameB;
    string $pmm;
    string $selectionItem = $curveName + ".u[" + $parm + "]";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════






    $numLocators = size($locatorShapes);
    for( $i = 0; $i < $numLocators; $i ++ ) {
    // Get the parent transform above the locator shape
    $parent1 = `listRelatives -p $locatorShapes[$i]`;

    $parent2 = `listRelatives -p $parent1[0]`;

    $ObjectParZ1 = `ls -tl 1 $parent2`;
    $numTokensZA = `tokenize $ObjectParZ1[0] "|" $bufferCutCurveA`;
    print $bufferCutCurveA[0];
    $ObjectParZ2 = ` ls -head 1 $parent2`;

    $numTokensZB = `tokenize $ObjectParZ2[0] "|" $bufferCutCurveB`;
    print $bufferCutCurveB[0];
    $nameA = `match "ACurve" $bufferCutCurveA[0]`;
    $zeroORZA = `gmatch "ACurve" $nameA`;
    $nameB = `match "ACurve" $bufferCutCurveB[0]`;
    $zeroORZB = `gmatch "ACurve" $nameB`;

    if ( $zeroORZA == 1){ $parent2A = {$bufferCutCurveA[0]};  }
    if ( $zeroORZB == 1){ $parent2A = {$bufferCutCurveA[0]};  }

    $curveName = $parent2A[0];
    if( `nodeType $curveName` != "nurbsCurve" ) continue;

    if( !catch($pmm = `createNode pointMatrixMult`) ) {
    $pos = `getAttr ($locatorShapes[$i] + ".localPosition")`;
    $parm = `getAttr ($parent1[0] + ".translateX")`;
    setAttr ($pmm +".inPoint") -type double3  $pos[0] $pos[1] $pos[2];
    setAttr ($pmm +".vectorMultiply") true ;
    connectAttr ($parent1[0]+".worldMatrix[0]") ($pmm+".inMatrix") ;
    $result = `getAttr ($pmm+".output")` ;
    $parm = $result[0];

    $selectionItem = $curveName + ".u[" + $parm + "]";
    $selectionList[ size($selectionList) ] = $selectionItem;

    delete $pmm;
    }
    }
    return $selectionList;

}


/******************************************************************************
 * @procedure    paramToCurvePts
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $locatorShapes : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] paramToCurvePts(string $locatorShapes[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $numLocators = size($locatorShapes);
    float $parm;
    float $pos[] = `getAttr ($locatorShapes[$i] + ".localPosition")`;
    float $result[] = `getAttr ($pmm+".output")`;
    string $selectionList[];
    string $curveName;
    string $parent1[] = `listRelatives -p $locatorShapes[$i]`;
    string $parent2[] = `listRelatives -p $parent1[0]`;
    string $pmm;
    string $selectionItem = $curveName + ".u["  + "0.0" + ":" + $parm + "]";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $numLocators = size($locatorShapes);
    for( $i = 0; $i < $numLocators; $i ++ ) {
    // Get the parent transform above the locator shape
    $parent1 = `listRelatives -p $locatorShapes[$i]`;

    $parent2 = `listRelatives -p $parent1[0]`;
    $curveName = $parent2[0];
    if( `nodeType $curveName` != "nurbsCurve" ) continue;

    if( !catch($pmm = `createNode pointMatrixMult`) ) {
    $pos = `getAttr ($locatorShapes[$i] + ".localPosition")`;
    $parm = `getAttr ($parent1[0] + ".translateX")`;
    setAttr ($pmm +".inPoint") -type double3  $pos[0] $pos[1] $pos[2];
    setAttr ($pmm +".vectorMultiply") true ;
    connectAttr ($parent1[0]+".worldMatrix[0]") ($pmm+".inMatrix") ;
    $result = `getAttr ($pmm+".output")` ;
    $parm = $result[0];

    $selectionItem = $curveName + ".u["  + "0.0" + ":" + $parm + "]";
    $selectionList[ size($selectionList) ] = $selectionItem;

    delete $pmm;
    }
    }
    return $selectionList;

}


/******************************************************************************
 * @procedure    tokenizeparam
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $paramANDCurveZ : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] tokenizeparam(string $paramANDCurveZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $num = size($paramANDCurveZ);
    string $selectionList[];
    string $bufferA[];
    string $selectionItem = $bufferA[0];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $num = size($paramANDCurveZ);
    for( $i = 0; $i < $num; $i ++ ) {
    $numTokensA = `tokenize $paramANDCurveZ[$i] "." $bufferA`;
    $selectionItem = $bufferA[0];
    $selectionList[ size($selectionList) ] = $selectionItem;
    }
    return $selectionList;

}


/******************************************************************************
 * @procedure    EvalMoveCurvesTOend
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $paramANDCurveZ : string[]
 *   $paramCurveNAMEZ : string[]
 *   $paramANDCurve3 : string[]
 *   $AllparamlocatorZ : string[]
 *   $set : string
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] EvalMoveCurvesTOend(string $paramANDCurveZ[], string $paramCurveNAMEZ[], string $paramANDCurve3[], string $AllparamlocatorZ[], string $set)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $iX;
    int $numparamANDCurveNAMEZ = size($paramCurveNAMEZ);
    int $arclenghtzIntTIMES = ($arclenghtzIntersectZ * 1000);
    int $arclenghtzTOTALnumTIMEZ = ($arclenghtzALL *1000);
    int $PercentA;
    int $numCVs = `getAttr -size ($paramCurveNAMEZ[$i] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    float $arclenghtzIntersectZ = `eval("arclen" + " " + $paramANDCurveZ[$i])`;
    float $arclenghtzALL = `arclen $paramCurveNAMEZ[$i]`;
    string $SEspaceLocSet;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $iX = -1;
    $numparamANDCurveNAMEZ = size($paramCurveNAMEZ);

    for( $i = 0; $i < $numparamANDCurveNAMEZ; $i ++ ) {

    $arclenghtzIntersectZ = `eval("arclen" + " " + $paramANDCurveZ[$i])`;
    $arclenghtzALL = `arclen $paramCurveNAMEZ[$i]`;

    $arclenghtzIntTIMES = ($arclenghtzIntersectZ * 1000) ;
    $arclenghtzTOTALnumTIMEZ = ($arclenghtzALL *1000) ;
    //asume there is only one curve intersect
    $PercentA = ((float($arclenghtzIntTIMES) / $arclenghtzTOTALnumTIMEZ) * (100) );

    if (( $PercentA > 85 ) || ( $PercentA < 15 )){
    $numCVs = `getAttr -size ($paramCurveNAMEZ[$i] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($paramCurveNAMEZ[$i] + ".cv[0]") ;
    $CurveSelection[1] = ($paramCurveNAMEZ[$i] + ".cv[" + $numCVrealNum + "]") ;

    if ( $PercentA > 85 ) {
    // move to curve end
    $MakespaceLocatorEND = `spaceLocator -p 0 0 0 -n SEspaceLocatorEND3DZ`;
    $eachCVposEND = `pointPosition -w ($CurveSelection[1])`;
    move  -ws $eachCVposEND[0] $eachCVposEND[1] $eachCVposEND[2] $MakespaceLocatorEND[0];
    appendStringArray($MakespaceLocatorSE, $MakespaceLocatorEND, 1);
    }

    if ( $PercentA < 15 ) {
    $MakespaceLocatorSTART = `spaceLocator -p 0 0 0 -n SEspaceLocatorSTART3DZ`;
    $eachCVposSTART = `pointPosition -w ($CurveSelection[0])`;
    move  -ws $eachCVposSTART[0] $eachCVposSTART[1] $eachCVposSTART[2] $MakespaceLocatorSTART;
    appendStringArray($MakespaceLocatorSE, $MakespaceLocatorSTART, 1);

    }
    }

    if (( $PercentA < 85 ) && ( $PercentA > 15 )){
    $iX = $iX +1;
    select -cl;
    print $AllparamlocatorZ[$i];
    print ("_____not near ends_____" + "\n");
    $SEspaceLocSet = `sets -name SEisnotLocSESet[$iX]`;
    sets -include $SEspaceLocSet $paramANDCurve3[$i];
    sets -include $SEspaceLocSet $AllparamlocatorZ[$i];
    sets -include $set $SEspaceLocSet;
    }
    }
    return $MakespaceLocatorSE;

}


/******************************************************************************
 * @procedure    GET_AREA_OF_CURVE
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $obj : string[]
 *
 * @returns      float
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float GET_AREA_OF_CURVE(string $obj[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numcvs = size($numcvnames);
    float $area = 0;
    float $centroid[] = `xform -q -ws -t ($obj[0])`;
    float $pos0[] = `eval $getpos0`;
    float $pos1[] = `eval $getpos1`;
    float $aP = `distanceBetween {$centroid[0],$centroid[1],$centroid[2]} {$pos0[0],$pos0[1],$pos0[2]}`;
    float $bP = `distanceBetween {$pos0[0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1[2]}`;
    float $cP = `distanceBetween {$pos1[0],$pos1[1],$pos1[2]} {$centroid[0],$centroid[1],$centroid[2]}`;
    float $triarea = 0.25* sqrt ( ($aP+$bP+$cP) * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP) );
    string $CurveItemA = $obj[0];
    string $numcvnames[] = `ls -fl ($CurveItemA+".cv[*]")`;
    string $cvname0 = $obj[0] + ".cv[" + $iC + "]";
    string $getpos0 = "pointPosition " + $cvname0;
    string $cvname1 = $obj[0] + ".cv[" + ($iC+1) + "]";
    string $getpos1 = "pointPosition " + $cvname1;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $area = 0;
    $centroid = `xform -q -ws -t ($obj[0])`;
    $CurveItemA = $obj[0];
    $numcvnames = `ls -fl ($CurveItemA+".cv[*]")`;
    $numcvs = size($numcvnames);

    for ($iC=0;$iC<$numcvs;$iC++){
    if ($iC<($numcvs-1)){
    $cvname0 = $obj[0] + ".cv[" + $iC + "]";
    $getpos0 = "pointPosition " + $cvname0;
    $pos0 = `eval $getpos0`;
    $cvname1 = $obj[0] + ".cv[" + ($iC+1) + "]";
    $getpos1 = "pointPosition " + $cvname1;
    $pos1 = `eval $getpos1`;
    $pos0 = `MakeCleanFloats($pos0)`;
    $pos1 = `MakeCleanFloats($pos1)`;

    $aP = `distanceBetween {$centroid[0],$centroid[1],$centroid[2]} {$pos0[0],$pos0[1],$pos0[2]}`;
    $bP = `distanceBetween {$pos0[0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1[2]}`;
    $cP = `distanceBetween {$pos1[0],$pos1[1],$pos1[2]} {$centroid[0],$centroid[1],$centroid[2]}`;
    $triarea = 0.25* sqrt ( ($aP+$bP+$cP) * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP) );
    clear $pos0;
    clear $pos1;
    $area = $area + $triarea;


    } else{
    $cvname0 = $obj[0] + ".cv[" + $iC + "]";
    $getpos0 = "pointPosition " + $cvname0;
    $pos0 = `eval $getpos0`;
    $cvname1 = $obj[0] + ".cv[" + ($iC+1) + "]";
    $getpos1 = "pointPosition " + $cvname1;
    $pos1 = `eval $getpos1`;
    $pos0 = `MakeCleanFloats($pos0)`;
    $pos1 = `MakeCleanFloats($pos1)`;
    $aP = `distanceBetween {$centroid[0],$centroid[1],$centroid[2]} {$pos0[0],$pos0[1],$pos0[2]}`;
    $bP = `distanceBetween {$pos0[0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1[2]}`;
    $cP = `distanceBetween {$pos1[0],$pos1[1],$pos1[2]} {$centroid[0],$centroid[1],$centroid[2]}`;
    $triarea = 0.25* sqrt ( ($aP+$bP+$cP) * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP) );
    clear $pos0;
    clear $pos1;
    $area = $area + $triarea;
    }
    }
    clear $numcvnames;
    return $area;

}


/******************************************************************************
 * @procedure    Make_Middle_of_Curve_ParamlocatorZ002
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $objectCurveSelected : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Make_Middle_of_Curve_ParamlocatorZ002(string $objectCurveSelected[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numCVrealNumDivide = $numCVrealNum / 2;
    int $i = 1;
    float $arclenghtzALL = `arclen $objectCurveSelected`;
    float $arclenghtzDivide = $arclenghtzALL / 2.0;
    float $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;
    float $arclenghtzHalf = `arclen ($objectCurveSelected[0] + ".u[0.0:" + $numCVrealNumDivide + "]")`;
    float $arclenghtzHalfROUNDED = `RoundfloatingPointoff($arclenghtzHalf)`;
    float $iz = 0.0;
    float $iX = float($numCVrealNumDivide);
    float $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    float $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
    float $posA[];
    float $posB[];
    float $posC[];
    string $paramANDCurve[] = `paramToCurvePts( $paramlocatorZARC )`;
    string $CircularArcFromCurve[];
    string $ArcCurve[];
    string $ParentArc[];
    string $ArcZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $arclenghtzALL = `arclen $objectCurveSelected`;
    $arclenghtzDivide = $arclenghtzALL / 2.0;
    $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;
    $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectCurveSelected[0] + ".cv[0]") ;
    $CurveSelection[1] = ($objectCurveSelected[0] + ".cv[" + $numCVrealNum + "]") ;
    $numCVrealNumDivide = $numCVrealNum / 2;
    if ($numCVrealNumDivide > 2){ $numCVrealNumDivide = $numCVrealNumDivide -1; }
    $arclenghtzHalf = `arclen ($objectCurveSelected[0] + ".u[0.0:" + $numCVrealNumDivide + "]")`;
    $arclenghtzHalfROUNDED = `RoundfloatingPointoff($arclenghtzHalf)`;
    $iz = 0.0; int $M;
    if ( $arclenghtzDivideROUNDED > $arclenghtzHalfROUNDED){
    print "Greater_then"; $M = 0;  $iz = 0.01;}
    if ( $arclenghtzDivideROUNDED < $arclenghtzHalfROUNDED){
    print "Less_then"; $M = 1; $iz = -0.01;}
    $paramlocatorZARC[0] = eval("paramLocator " +  $objectCurveSelected[0] + ".u[" + $numCVrealNumDivide + "]");
    $iX = float($numCVrealNumDivide);
    $i = 1;
    while ($i > 0){
    $iX = $iX + $iz;
    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $iX;
    $paramANDCurve = `paramToCurvePts( $paramlocatorZARC )`;
    $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
    if($M == 0){
    if (($arclenghtzparamZROUNDED == $arclenghtzDivideROUNDED) || ($arclenghtzparamZROUNDED > $arclenghtzDivideROUNDED)){
    $i = 0; }
    }
    if($M == 1){
    if (($arclenghtzparamZROUNDED == $arclenghtzDivideROUNDED) || ($arclenghtzparamZROUNDED < $arclenghtzDivideROUNDED)){
    $i = 0; }
    }
    }
    $posA = `pointPosition -w $CurveSelection[0]`;
    $posB = `pointPosition -w $paramlocatorZARC[0]`;
    $posC = `pointPosition -w $CurveSelection[1]`;
    $CircularArcFromCurve[0] = `createNode makeThreePointCircularArc`;
    setAttr ($CircularArcFromCurve[0] + ".pt1") $posA[0] $posA[1] $posA[2] ;
    setAttr ($CircularArcFromCurve[0] + ".pt2") $posB[0] $posB[1] $posB[2];
    setAttr ($CircularArcFromCurve[0] + ".pt3") $posC[0] $posC[1] $posC[2];
    setAttr ($CircularArcFromCurve[0] + ".d") 3;
    setAttr ($CircularArcFromCurve[0] + ".s") 8;
    $ArcCurve[0] = `createNode nurbsCurve` ;
    connectAttr ($CircularArcFromCurve[0] + ".oc") ($ArcCurve[0] +".cr");
    //delete $objectCurveSelected;
    $ParentArc = `listRelatives -parent $ArcCurve`;
    ResetTranlation($ParentArc);

    $ArcZ[0] = `rename $ParentArc $objectCurveSelected`;
    delete $paramlocatorZARC;
    select -r $ArcZ;
    return $ArcZ;


}


/******************************************************************************
 * @procedure    RoundfloatingPointoff
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $floatingPointNumZ : float
 *
 * @returns      float
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float RoundfloatingPointoff(float $floatingPointNumZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $roundoff = $floatingPointNumZ *100;
    float $roundoff2 = float($roundoff) * 0.01;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $roundoff = $floatingPointNumZ *100;
    $roundoff2 = float($roundoff) * 0.01;
    return $roundoff2;

}


/******************************************************************************
 * @procedure    Make_Middle_of_Curve_ParamlocatorFloat
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $objectCurveSelected : string[]
 *
 * @returns      float[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] Make_Middle_of_Curve_ParamlocatorFloat(string $objectCurveSelected[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i = 1;
    float $arclenghtzALL = `arclen $objectCurveSelected`;
    float $arclenghtzDivide = $arclenghtzALL / 2.0;
    float $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;
    float $iX = 0.00;
    float $posB[];
    float $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    float $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
    string $posALL[];
    string $paramANDCurve[] = `paramToCurvePts( $paramlocatorZARC )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $arclenghtzALL = `arclen $objectCurveSelected`;
    $arclenghtzDivide = $arclenghtzALL / 2.0;
    $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;
    $paramlocatorZARC[0] = eval("paramLocator " +  $objectCurveSelected[0] + ".u[" + 0.00 + "]");
    $iX = 0.00;
    $i = 1;
    while ($i > 0){
    $iX = $iX + 0.01;
    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $iX;
    $paramANDCurve = `paramToCurvePts( $paramlocatorZARC )`;
    $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
    if (($arclenghtzparamZROUNDED == $arclenghtzDivideROUNDED) || ($arclenghtzparamZROUNDED > $arclenghtzDivideROUNDED)){
    $i = 0;
    }
    }
    $posB = `pointPosition -w $paramlocatorZARC[0]`;
    delete $paramlocatorZARC;
    return $posB ;

}


/******************************************************************************
 * @procedure    distanceBetween
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $loc1 : float[]
 *   $loc2 : float[]
 *
 * @returns      float
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float distanceBetween(float $loc1[], float $loc2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $a = `pow ($loc2[0] - $loc1[0]) 2`;
    float $b = `pow ($loc2[1] - $loc1[1]) 2`;
    float $c = `pow ($loc2[2] - $loc1[2]) 2`;
    float $distance = `sqrt ( $a+$b+$c )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $a = `pow ($loc2[0] - $loc1[0]) 2`;
    $b = `pow ($loc2[1] - $loc1[1]) 2`;
    $c = `pow ($loc2[2] - $loc1[2]) 2`;
    $distance = `sqrt ( $a+$b+$c )`;
    return $distance;

}


/******************************************************************************
 * @procedure    FindIfCurveCrossesZ
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $rebuildit : string[]
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindIfCurveCrossesZ(string $rebuildit[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $ZeroOneORTwo;
    int $numCVs = `getAttr -size ($rebuildit[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $zeroOR1Z = `gmatch "-" $nameA`;
    int $zeroOR2Z = `gmatch "-" $nameB`;
    int $zeroOR1Ze = `gmatch "e" $nameAe`;
    int $zeroOR2Ze = `gmatch "e" $nameBe`;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    string $CurveSelection[];
    string $POSA = $EACHCVposAZ[0];
    string $nameA;
    string $POSB = $EACHCVposBZ[0];
    string $nameB;
    string $POSAe = `abs $EACHCVposAZ[0]`;
    string $POSBe = `abs $EACHCVposBZ[0]`;
    string $nameAe;
    string $nameBe;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($rebuildit[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;
    $CurveSelection[1] = ($rebuildit[0] + ".cv[" + $numCVrealNum + "]") ;
    $EACHCVposAZ = `pointPosition -w ( $CurveSelection[0]  )`;
    $EACHCVposBZ = `pointPosition -w ( $CurveSelection[1]  )`;
    $POSA = $EACHCVposAZ[0];
    $nameA = `match "-" $POSA`;
    $zeroOR1Z = `gmatch "-" $nameA`;
    $POSB = $EACHCVposBZ[0];
    $nameB = `match "-" $POSB`;
    $zeroOR2Z = `gmatch "-" $nameB`;
    $ZeroOneORTwo = $zeroOR1Z + $zeroOR2Z;
    $POSAe = `abs $EACHCVposAZ[0]`;
    $POSBe = `abs $EACHCVposBZ[0]`;
    $nameAe = `match "e" $POSAe`;
    $nameBe = `match "e" $POSBe`;
    $zeroOR1Ze = `gmatch "e" $nameAe`;
    $zeroOR2Ze = `gmatch "e" $nameBe`;
    if (($zeroOR1Ze == 1 ) || ($zeroOR2Ze == 1 )){
    print "is Zero";
    $ZeroOneORTwo = 0;
    print $ZeroOneORTwo;
    }
    return $ZeroOneORTwo;

}


/******************************************************************************
 * @procedure    GetDistance
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $objectFirst : string
 *   $objectSecond : string
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int GetDistance(string $objectFirst, string $objectSecond)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $distanceA2roundoff;
    float $pointAZ1[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pointAZ1 = `xform -query -worldSpace -translation ($objectFirst)`;
    $pointAZ2 = `xform -query -worldSpace -translation ($objectSecond)`;
    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    $distanceA2roundoff = $distanceA2;
    return $distanceA2roundoff;

}


/******************************************************************************
 * @procedure    CutCurveIFConditionTRUETransitZ
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $rebuildit : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CutCurveIFConditionTRUETransitZ(string $rebuildit[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $XiScaleTimes;
    int $XiScale;
    int $ZeroOneORTwoZ = FindIfCurveCrossesZ($rebuildit);
    int $numTokensZa;
    int $X = 0;
    int $zeroOR1Z = `gmatch "-" $nameA`;
    int $zeroOR2Z = `gmatch "-" $nameB`;
    float $CURVEAposA[];
    float $CURVEA_AREA = `GET_AREA_OF_CURVE($rebuildit)`;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    string $remainingCurve[];
    string $ZcutingplaneZZ[];
    string $curveIntersectZ[];
    string $intersectZZCUT[];
    string $iSurfZ[] = `extrude -ch 1 -et 0 -l 0.5 -n AxisSelectionZ ( $rebuildit )`;
    string $buffer[];
    string $paramlocatorZ[];
    string $paramANDCurve[];
    string $curvesZ[];
    string $curveZ0[];
    string $curveZ1[];
    string $POSA = $EACHCVposAZ[0];
    string $nameA;
    string $POSB = $EACHCVposBZ[0];
    string $nameB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $ZeroOneORTwoZ = FindIfCurveCrossesZ($rebuildit);
    if ($ZeroOneORTwoZ == 1){
    $CURVEAposA = `xform -query -worldSpace -translation $rebuildit[0]`;
    $CURVEA_AREA = `GET_AREA_OF_CURVE($rebuildit)`;
    $ZcutingplaneZZ = `nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr 1 -n "ZcutingplaneZZ"`;
    setAttr "ZcutingplaneZZ.rotateZ" 90;
    $XiScale = GetDistance($rebuildit[0], $ZcutingplaneZZ[0]);
    $XiScaleTimes = ($XiScale * 3) + $CURVEA_AREA;
    scale -r $XiScaleTimes $XiScaleTimes $XiScaleTimes $ZcutingplaneZZ;
    $iSurfZ = `extrude -ch 1 -et 0 -l 0.5 -n AxisSelectionZ ( $rebuildit )`;
    $intersectZZCUT = `intersect -ch 0 -cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ $iSurfZ[0] $ZcutingplaneZZ[0]`;
    select -r $intersectZZCUT;
    $curveIntersectZ[0] = `curveIntersect -ch 0 -tolerance 0.00001 $intersectZZCUT $rebuildit[0]`;
    $numTokensZa = `tokenize $curveIntersectZ[0] " " $buffer`;
    $paramlocatorZ[0] = `eval("paramLocator " +  $rebuildit[0] + ".u[" + $buffer[1] + "]")`;
    $X = 0;
    $paramANDCurve  = `paramToCurvePts2( $paramlocatorZ)`;
    $curvesZ = `detachCurve -ch 1 -cos on -rpo 1 $paramANDCurve`;
    $curveZ0[0] = $curvesZ[0];
    $curveZ1[0] = $curvesZ[1];
    ResetTranlation($curveZ0);
    ResetTranlation($curveZ1);
    $EACHCVposAZ = `xform -query -worldSpace -translation ( $curvesZ[0]  )`;
    $EACHCVposBZ = `xform -query -worldSpace -translation ( $curvesZ[1]  )`;
    $POSA = $EACHCVposAZ[0];
    $nameA = `match "-" $POSA`;
    $zeroOR1Z = `gmatch "-" $nameA`;
    $POSB = $EACHCVposBZ[0];
    $nameB = `match "-" $POSB`;
    $zeroOR2Z = `gmatch "-" $nameB`;
    if ($zeroOR1Z == 1){
    delete $curvesZ[0];
    $X = 1; }
    if ($zeroOR2Z == 1){
    delete $curvesZ[1];
    $X = 2;}
    if ($X == 2){
    select -r $curvesZ[0]; }
    if ($X == 1){
    select -r $curvesZ[1]; }
    $remainingCurve = `ls -sl`;
    delete $intersectZZCUT $ZcutingplaneZZ AxisSelectionZ ;
    }
    $rebuildit = $remainingCurve;
    return $remainingCurve;

}


/******************************************************************************
 * @procedure    FindIfCurveISonZ
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $rebuildit : string[]
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindIfCurveISonZ(string $rebuildit[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iZ = 0;
    int $numCVs = `getAttr -size ($rebuildit[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $zeroOR1Z = `gmatch "e" $ScientNotationNameA`;
    int $zeroOR2Z = `gmatch "e" $ScientNotationNameB`;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    string $CurveSelection[];
    string $POSA = $EACHCVposAZ[0];
    string $ScientNotationNameA;
    string $POSB = $EACHCVposBZ[0];
    string $ScientNotationNameB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $iZ = 0;
    $numCVs = `getAttr -size ($rebuildit[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;
    $CurveSelection[1] = ($rebuildit[0] + ".cv[" + $numCVrealNum + "]") ;
    $EACHCVposAZ = `pointPosition -w ( $CurveSelection[0]  )`;
    $EACHCVposBZ = `pointPosition -w ( $CurveSelection[1]  )`;
    $POSA = $EACHCVposAZ[0];
    $ScientNotationNameA = `match "e" $POSA`;
    $zeroOR1Z = `gmatch "e" $ScientNotationNameA`;
    if (($EACHCVposAZ[0] == 0) || ($zeroOR1Z == 1)){
    print "yes";
    $iZ = $iZ + 1;
    }
    $POSB = $EACHCVposBZ[0];
    $ScientNotationNameB = `match "e" $POSB`;
    $zeroOR2Z = `gmatch "e" $ScientNotationNameB`;
    if (($EACHCVposBZ[0] == 0) || ($zeroOR2Z == 1)){
    print "yes";
    $iZ = $iZ + 1;
    }
    return $iZ;

}


/******************************************************************************
 * @procedure    ArrayInsertAtEnd
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $INarray : string[]
 *   $NewItem : string
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ArrayInsertAtEnd(string $INarray[], string $NewItem)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArray;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArray = size($INarray);
    $INarray[$SizeOfArray] = ( $NewItem );
    return $SizeOfArray;

}


/******************************************************************************
 * @procedure    positionOne
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $eachZA : string
 *
 * @returns      float[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] positionOne(string $eachZA)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $eachCVpos[] = `pointPosition -w $eachZA`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $eachCVpos = `pointPosition -w $eachZA`;
    return $eachCVpos;

}


/******************************************************************************
 * @procedure    stringArrayGmatch
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int stringArrayGmatch(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    for ($listItem in $list) {
    if ( `gmatch $listItem $item` == 1){
    $result = true;
    break;	}
    }
    return $result;

}


/******************************************************************************
 * @procedure    FindclosetTOcurveENDz
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $a1 : float[]
 *   $a2 : float[]
 *   $b1 : float[]
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindclosetTOcurveENDz(float $a1[], float $a2[], float $b1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $binaryAnswer;
    float $distance1;
    float $distance2;
    float $pointA1[];
    float $pointA2[];
    float $pointB1[];
    float $dAx;
    float $dAy;
    float $dAz;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pointA1 = $a1;
    $pointA2 = $b1;
    $dAx = $pointA1[0] - $pointA2[0];
    $dAy = $pointA1[1] - $pointA2[1];
    $dAz = $pointA1[2] - $pointA2[2];
    $distanceA = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    $distance1 = $distanceA;
    $pointB1 = $a2;
    $dAx = $pointB1[0] - $pointA2[0];
    $dAy = $pointB1[1] - $pointA2[1];
    $dAz = $pointB1[2] - $pointA2[2];
    $distanceB = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    $distance2 = $distanceB;
    if ($distance1 < $distance2){
    $binaryAnswer = 0;
    return $binaryAnswer;
    }
    if ( $distance2 < $distance1 ){
    $binaryAnswer = 1;
    return $binaryAnswer;
    }


}


/******************************************************************************
 * @procedure    NearestObjectArray
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $n : int
 *   $ItemsSelectedinArray : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] NearestObjectArray(int $n, string $ItemsSelectedinArray[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $NearestObjectN = $n;
    int $indexN = 0;
    int $NearestObjectNumbers = $NearestObjectN;
    int $array1Number = $array1Count;
    int $curvenumbers = $CompareAllShapesCount;
    float $pointA1[];
    float $pointA2[];
    float $distanceA;
    float $pointB1[];
    float $pointB2[];
    float $distanceB;
    string $NearestCurvesZ[];
    string $array1[] = $ItemsSelectedinArray;
    string $array2[] = $ItemsSelectedinArray;
    string $arrayMainObject1[] = $ItemsSelectedinArray;
    string $array1Count = size ($array1) -1;
    string $diff[] = stringArrayRemoveExact($array1, $arrayMainObject1);
    string $CompareAllShapesCount = size ($array1);
    string $oneitem[];
    string $arrayLast[] = stringArrayRemoveExact($oneitem, $arrayMainObject1);
    string $return[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $NearestObjectN = $n;
    $numIntx = size($NearestCurvesZ);
    if ( $numIntx > 0 ){
    clear $NearestCurvesZ;
    }
    $array1 = $ItemsSelectedinArray;
    $array2 = $ItemsSelectedinArray;
    $arrayMainObject1 = $ItemsSelectedinArray;
    $indexN = 0;
    $NearestObjectNumbers = $NearestObjectN;
    $ObjN = 0;
    $ObjN2 = 0;
    while($ObjN++ < $NearestObjectNumbers ){
    $array1Count = size ($array1) -1;
    $array1Number = $array1Count;
    stringArrayRemoveAtIndex($array1Count, $array1);
    $diff = stringArrayRemoveExact($array1, $arrayMainObject1);
    $CompareAllShapesCount = size ($array1);
    $curvenumbers = $CompareAllShapesCount;
    $i = 1;
    while($i++ < $curvenumbers ){
    //DISTANCE A
    $pointA1 = `xform -query -worldSpace -translation ( $diff)`;
    $pointA2 = `xform -query -worldSpace -translation ($array1[0])`;
    $dAx = $pointA1[0] - $pointA2[0];
    $dAy = $pointA1[1] - $pointA2[1];
    $dAz = $pointA1[2] - $pointA2[2];
    $distanceA = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    //DISTANCE B
    $pointB1 = `xform -query -worldSpace -translation ( $diff)`;
    $pointB2 = `xform -query -worldSpace -translation ( $array1[1])`;
    $dBx = $pointB1[0] - $pointB2[0];
    $dBy = $pointB1[1] - $pointB2[1];
    $dBz = $pointB1[2] - $pointB2[2];
    $distanceB = `sqrt( ($dBx * $dBx) + ($dBy * $dBy) + ($dBz * $dBz) )`;
    if( $distanceA < $distanceB ){
    stringArrayRemoveAtIndex(1, $array1);
    }
    if( $distanceA > $distanceB ){
    stringArrayRemoveAtIndex(0, $array1);
    }
    }
    appendStringArray($NearestCurvesZ, $array1, 1);
    $oneitem[0] = $array1[0];
    $arrayLast = stringArrayRemoveExact($oneitem, $arrayMainObject1);
    $array1 = $arrayLast;
    $array2 = $arrayLast;
    $arrayMainObject1 = $arrayLast;
    $indexN++;
    stringArrayInsertAtIndex(($indexN), $ArrayTwoObjectX, $arrayLast[0]);
    }
    clear $array1;
    clear $array2;
    clear $arrayMainObject1;
    $return = $NearestCurvesZ;
    return $return;

}


/******************************************************************************
 * @procedure    CreateCAMforIntCurveScript
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CreateCAMforIntCurveScript()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectZcurv[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $LocatorLoop = 0;
    float $eachCVpos[];
    string $CamConeLocator[];
    string $CurveSelection[];
    string $each;
    string $MakespaceLocator[];
    string $objectZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    CreateCameraOnly;
    rename ZCURVEModelingCAM;
    lookThroughModelPanelClipped ZCURVEModelingCAM modelPanel4 0.001 1000;
    nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr 1 -n "LiveSurfaceB";
    editDisplayLayerMembers -noRecurse layerYZYXPlains "LiveSurfaceB";


    //////////////////
    clear $CamConeLocator;
    curve -d 3 -p 0 0 0 -p 0 0 -4 -p 0 0 -8 -p 0 0 -12 -k 0 -k 0 -k 0 -k 12 -k 12 -k 12 -n Deletethiscurve ;
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    $objectZcurv = `ls -sl`;
    $numCVs = `getAttr -size ($objectZcurv[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectZcurv[0] + ".cv[0]") ;
    $CurveSelection[1] = ($objectZcurv[0] + ".cv[" + $numCVrealNum + "]") ;
    for ($each in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $each  )`;
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n LocatorA`;
    ArrayInsertAtEnd($CamConeLocator, $MakespaceLocator[0]);
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos[2] $MakespaceLocator[0];
    }
    $LocatorLoop = 0; int $LocatorLoopA = -1;
    while ($LocatorLoop++ < 7) {
    $LocatorLoopA = $LocatorLoopA +1;
    if ($LocatorLoopA == 0){
    clear $objectZ;
    stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
    stringArrayInsertAtIndex(1, $objectZ, "LocatorA1");
    }
    if ($LocatorLoopA > 0){
    clear $objectZ;
    stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
    stringArrayInsertAtIndex(1, $objectZ, $MakespaceLocator[0]);
    }
    if ($LocatorLoopA < 7){
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n LocatorMiddleDistance`;
    ArrayInsertAtEnd($CamConeLocator, $MakespaceLocator[0]);
    averagingNode($objectZ[0], $MakespaceLocator[0], $objectZ[1]);
    }
    }
    ArrayInsertAtEnd( $CamConeLocator, $CamConeLocator[0]);
    stringArrayRemoveAtIndex(0, $CamConeLocator);
    parentConstraint -mo -weight 1 ZCURVEModelingCAM LocatorA1 ;
    parentConstraint -mo -weight 1 ZCURVEModelingCAM LocatorA;
    delete  Deletethiscurve;
    align -atl -x Mid -y Mid -z Mid LiveSurfaceB ZCURVEModelingCAM;

    move -r -os -wd 0 5 5 ZCURVEModelingCAM ;
    setAttr "ZCURVEModelingCAM.rotateX" -45;
    setAttr "LiveSurfaceB.rotateX" (`getAttr ("ZCURVEModelingCAM" + ".rotateX")`+90);
    setAttr "LiveSurfaceB.rotateY" `getAttr ("ZCURVEModelingCAM" + ".rotateY")`;
    setAttr "LiveSurfaceB.rotateZ" `getAttr ("ZCURVEModelingCAM" + ".rotateZ")`;
    align -atl -x Mid -y Mid -z Mid LiveSurfaceB ZCURVEModelingCAM;
    move -r -os -wd 0 -0.7 0 LiveSurfaceB ;
    move -r -os -wd 0 0 0.210031 LiveSurfaceB ;

    parentConstraint -mo -weight 1 ZCURVEModelingCAM LiveSurfaceB;
    setAttr "ZCURVEModelingCAM.translateX" 48 ;
    setAttr "ZCURVEModelingCAM.translateY" 41 ;
    setAttr "ZCURVEModelingCAM.translateZ" 48 ;
    setAttr "ZCURVEModelingCAM.rotateX" -25 ;
    setAttr "ZCURVEModelingCAM.rotateY" 45;
    setAttr "ZCURVEModelingCAM.rotateZ" 0;
    return $CamConeLocator;

}


/******************************************************************************
 * @procedure    StartofCurveScriptIntersectZX
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] StartofCurveScriptIntersectZX()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectcurv[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    float $EACHCVposA[];
    float $EACHCVposB[];
    float $eachCVpos[];
    string $digitalSkeleton[];
    string $objectcurv[];
    string $CurveSelection[];
    string $AllIntersectCurveZ[];
    string $IntersectCurves[];
    string $MakeExtrudeSurface[];
    string $MakeBirailSurface[];
    string $MakeXBetween[];
    string $MakeIntersectCurvez[];
    string $MakespaceLocator[];
    string $each;
    string $curveFromSurfaceDup[] = `duplicateCurve -ch 1 -rn 0 -local 0  "SurfaceinterectCurves.u[1]"`;
    string $curveFromSurfaceLoft[] = `loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 4 -rn 1 -po 0 -rsn true -n IntersectLoftZ $curveFromSurfaceDup[0]     $objectcurv`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    Removefromsurface;

    //
    $numInts = size($digitalSkeleton);
    if ( $numInts > 0 ){
    clear $digitalSkeleton;
    }
    $objectcurv = `ls -sl`;
    ///////////////GATHER ALL BUILDING STRUCTURE/////////##
    appendStringArray($digitalSkeleton, $objectcurv, 1);
    /////////////////////////////////////////////////////##
    $numCVs = `getAttr -size ($objectcurv[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectcurv[0] + ".cv[0]") ;
    $CurveSelection[1] = ($objectcurv[0] + ".cv[" + $numCVrealNum + "]") ;

    $numInts = size($AllIntersectCurveZ);
    if ( $numInts > 0 ){
    clear $AllIntersectCurveZ;
    }

    for ($each in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $each  )`;
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n IntersectZLocaterZ3D`;
    $MakeIntersectCurvez[0] = `curve -d 1 -p 0 0 0 -p 12 0 0 -k 0 -k 1 -n IntersectCurve` ;
    appendStringArray($AllIntersectCurveZ, $MakeIntersectCurvez, 1);
    appendStringArray($digitalSkeleton, $MakespaceLocator, 1);
    $numInts = size($AllIntersectCurveZ);
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos[2] $MakespaceLocator[0];
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos[2] $MakeIntersectCurvez[0];
    aimConstraint -offset 0 0 0 -weight 0.5 -aimVector -1 0 0 -upVector 0 0 -1 -worldUpType "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM     $MakeIntersectCurvez[0];
    if ( $numInts == 1 ){
    $EACHCVposA = $eachCVpos;
    }
    if ( $numInts == 2 ){
    $EACHCVposB = $eachCVpos;
    $MakeXBetween[0] = `curve -d 1 -p $EACHCVposA[0] $EACHCVposA[1] $EACHCVposA[2] -p $EACHCVposB[0] $EACHCVposB[1] $EACHCVposB[2] -k 0 -k 2 -n     XCurveBetween`;
    appendStringArray($digitalSkeleton, $MakeXBetween, 1);
    }
    }

    $MakeExtrudeSurface = `extrude -ch true -rn 0 -po 0 -et 0 -upn 0 -fixedPath 1 -d 0 0 0 -length 3 -rotation 0 -scale 1 -dl 3 -n CURVEZextrude     $objectcurv` ;

    $MakeBirailSurface = `singleProfileBirailSurface -ch 1 -po 0 -tm 1 -tp1 0 -n SurfaceinterectCurves CURVEZextrude.v[0] $AllIntersectCurveZ[0]     $AllIntersectCurveZ[1]`;

    $curveFromSurfaceDup = `duplicateCurve -ch 1 -rn 0 -local 0  "SurfaceinterectCurves.u[1]"` ;
    $curveFromSurfaceLoft = `loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 4 -rn 1 -po 0 -rsn true -n IntersectLoftZ $curveFromSurfaceDup[0]     $objectcurv` ;

    // Result: duplicatedCurve1 curveFromSurfaceIso2 //


    // GATHER ALL BUILDING STRUCTURE//
    appendStringArray($digitalSkeleton, $curveFromSurfaceDup, 1);
    appendStringArray($digitalSkeleton, $curveFromSurfaceLoft, 1);
    appendStringArray($digitalSkeleton, $MakeExtrudeSurface, 1);
    appendStringArray($digitalSkeleton, $MakeBirailSurface, 1);
    appendStringArray($digitalSkeleton, $AllIntersectCurveZ, 2);
    ////
    return $digitalSkeleton;

}


/******************************************************************************
 * @procedure    SecondArrayInsertAtEndofArray
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $INarray : string[]
 *   $NewItem : string[]
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int SecondArrayInsertAtEndofArray(string $INarray[], string $NewItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArray;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArray = size($INarray);
    $INarray[$SizeOfArray] = ( $NewItem[0] );
    return $SizeOfArray;

}


/******************************************************************************
 * @procedure    RemoveNoLongerExistingFromArray
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $EdgeCurveZ1 : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] RemoveNoLongerExistingFromArray(string $EdgeCurveZ1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArrayA = size($EdgeCurveZ1);
    int $SizeOfArray = size($EdgeCurveZ1) -1;
    int $i = -1;
    int $E = -1;
    int $SizeOfArrayB = size($EdgeCurveZ1);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArrayA = size($EdgeCurveZ1);
    if ( $SizeOfArrayA > 0){
    $SizeOfArray = size($EdgeCurveZ1) -1;
    $i = -1;
    $E = -1;
    while( $E < $SizeOfArray ){
    $i++;
    $E++;

    if ( `objExists $EdgeCurveZ1[$i]` == 0  ) {
    stringArrayRemoveAtIndex($i, $EdgeCurveZ1);
    if ($i == 0) { $i = -1;} else { $i = $i -1;}
    }

    }
    print $EdgeCurveZ1;
    $SizeOfArrayB = size($EdgeCurveZ1);
    }
    return $EdgeCurveZ1;

}


/******************************************************************************
 * @procedure    stringArrayMatch
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int stringArrayMatch(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $item $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ISobjectSelectedTypeCurve2
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ISobjectSelectedTypeCurve2()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    int $zeroOR1A = stringArrayMatch($names1, $nametypeZ);
    int $zeroOR1B = stringArrayMatch($names2, $nametypeZ);
    int $zeroOR1C = stringArrayMatch($names3, $nametypeZ);
    int $zeroOR1D = stringArrayMatch($names4, $nametypeZ);
    string $C[];
    string $nametypeZ[] = `ls -showType $C`;
    string $names1 = "curve";
    string $names2 = "Curve";
    string $names3 = "cv";
    string $names4 = "ep";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    $C = `ls -sl`;
    $nametypeZ = `ls -showType $C`;
    $names1 = "curve";
    $names2 = "Curve";
    $names3 = "cv";
    $names4 = "ep";
    $zeroOR1A = stringArrayMatch($names1, $nametypeZ);
    $zeroOR1B = stringArrayMatch($names2, $nametypeZ);
    $zeroOR1C = stringArrayMatch($names3, $nametypeZ);
    $zeroOR1D = stringArrayMatch($names4, $nametypeZ);
    $zeroOR1B = stringArrayMatch($names1, $nametypeZ);
    if (( $zeroOR1A == 1) || ( $zeroOR1B == 1)){
    if (( $zeroOR1C == 1) || ( $zeroOR1D == 1)){
    $result = false;
    } else { $result = true; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ISobjectSelectedTypeCurve
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ISobjectSelectedTypeCurve()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroOR1Z = `gmatch "Curve" $nameA`;
    string $C[];
    string $nametypeZ[] = `ls -showType $C`;
    string $nameA;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $C = `ls -sl`;
    $nametypeZ = `ls -showType $C`;
    $nameA = `match "[a-zA-Z]+" $nametypeZ[0]`;
    $zeroOR1Z = `gmatch "Curve" $nameA`;
    print $zeroOR1Z;
    return $zeroOR1Z;

}


/******************************************************************************
 * @procedure    ifCurveToolsCTX1
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ifCurveToolsCTX1()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $whichCtx;
    string $list[] = { "pencilContext"};
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $whichCtx = `currentCtx`;
    $list = { "pencilContext"};
    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $whichCtx $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ifCurveToolsCTX2
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ifCurveToolsCTX2()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $whichCtx;
    string $list[] = {"curveContextEP", "curveAddPtContext"};
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $whichCtx = `currentCtx`;
    $list = {"curveContextEP", "curveAddPtContext"};
    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $whichCtx $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ifCurveToolsCTX3
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ifCurveToolsCTX3()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $whichCtx;
    string $list[] = {"threePointArcContext"};
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $whichCtx = `currentCtx`;
    $list = {"threePointArcContext"};
    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $whichCtx $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ifCurveToolsCTX4
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ifCurveToolsCTX4()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $whichCtx;
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $whichCtx = `currentCtx`;
    "scaleSuperContext", "xformManipContext", "softModContext" };
    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $whichCtx $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    addNumbers
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int addNumbers()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CreatedObjectCurve = `ISobjectSelectedTypeCurve`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CreatedObjectCurve = `ISobjectSelectedTypeCurve`;
    return $CreatedObjectCurve;

}


/******************************************************************************
 * @procedure    addedNumbers
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $addNumbersA : int
 *
 * @returns      int
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int addedNumbers(int $addNumbersA)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numerOfCreatedCurve = `addNumbers`;
    int $numerOfCreated = $numerOfCreatedCurve;
    int $addNumberZ = $addNumbersA + $numerOfCreatedCurve;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numerOfCreatedCurve = `addNumbers`;
    $numerOfCreated = $numerOfCreatedCurve;
    if ($numerOfCreated == 1){
    $addNumberZ = $addNumbersA + $numerOfCreatedCurve;
    $addNumbersA = $addNumberZ;
    print $addNumbersA;
    }
    return $addNumbersA;

}


/******************************************************************************
 * @procedure    queryLayerRangeMembers
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] queryLayerRangeMembers()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $query[];
    string $queryOutofRangeLayer[];
    string $queryINRangeLayer[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $queryOutofRangeLayer = `editDisplayLayerMembers -q layerCurvesOutofRange1`;
    $queryINRangeLayer = `editDisplayLayerMembers -q layerCurvesINRange1`;
    if (size($queryOutofRangeLayer) > 0){
    appendStringArray($query, $queryOutofRangeLayer, size($queryOutofRangeLayer));
    }
    if (size($queryINRangeLayer) > 0){
    appendStringArray($query, $queryINRangeLayer, size($queryINRangeLayer));
    }
    return $query;

}


/******************************************************************************
 * @procedure    AutoBoundryScript
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $everyFirstCurveShapeset : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] AutoBoundryScript(string $everyFirstCurveShapeset[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $everycurveSize = size($everyFirstCurveShapeset);
    int $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
    int $numberofconnections = size($firstcurveConn);
    int $divide;
    int $switchNumber;
    int $n;
    int $n2 = $n * 2;
    int $ISTRUE0A1;
    int $numIntZZ;
    int $switchNumberA;
    int $ISTRUE0B = catchQuiet($intersectCurveZ1 = `curveIntersect -ch 0 -ud 0 -tol 0.01 $FirstCurvesZ $eachAB`);
    int $numIntZZZ = size($intersectCurveZ1);
    int $numInts2a;
    int $numIntxZB;
    int $X = 1;
    int $ENDLOOPA;
    int $i = 1;
    int $ENDLOOP;
    int $B = 0;
    int $ISTRUE0A001;
    int $numIntZZA;
    int $numIntZZAB;
    int $ISTRUE0B002;
    int $endtrigger = 0;
    int $numsizeNearest = size($NearestCurvesZ);
    int $boundaryCurvessize = size($boundaryCurves);
    string $EdgeCurveZ[];
    string $EdgeCurveZ2[];
    string $EdgeCurveZ3[];
    string $newallCurves[];
    string $ZnewfoundEdge[];
    string $ZselectedCurve[];
    string $ZfirstcurveRelatives[];
    string $ZfirstcurveConnectionsz[];
    string $Zfirstcurveshapes[];
    string $FirstCurvesZ[];
    string $firstcurveRelatives[];
    string $firstcurveConnectionsz[];
    string $firstcurveshapes[];
    string $firstcurveConn[] = stringArrayRemove($firstcurveRelatives, $firstcurveshapes);
    string $NearestCurvesZ[] = (NearestObjectArray($n, $everyFirstCurveShapeset));
    string $NearestCurvesZn2[] = (NearestObjectArray($n2, $everyFirstCurveShapeset));
    string $TEMPzCurveAAb[];
    string $diff[];
    string $NearestCurvesZA[];
    string $diffremove[];
    string $TEMPAlldiffCurveZBBBB[];
    string $diffX[];
    string $boundaryCurvesAA[];
    string $boundaryCurves[];
    string $boundaryCurves1[];
    string $removecurveAz2[];
    string $removeoneFromeveryFirstA[];
    string $Intersectboundarycurves[];
    string $myIntersector = `stringArrayIntersector`;
    string $Foundboundarycurves[];
    string $selectedCurve[];
    string $removecurveAz[];
    string $removeoneFromeveryFirst[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    clear $EdgeCurveZ2;
    $newallCurves = $everyFirstCurveShapeset;

    for ( $Zeachboundry in $newallCurves ) {
    clear $ZselectedCurve;
    $ZselectedCurve[0] = $Zeachboundry;
    $ZfirstcurveRelatives = `listRelatives -shapes $ZselectedCurve`;
    $ZfirstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $ZfirstcurveRelatives`;
    $Zfirstcurveshapes = `listConnections -shapes 1 -type nurbsSurface $ZfirstcurveConnectionsz`;

    if (size($Zfirstcurveshapes) == 1){
    appendStringArray($ZnewfoundEdge, $ZselectedCurve, 1);
    }
    if (size($Zfirstcurveshapes) == 0){
    appendStringArray($ZnewfoundEdge, $ZselectedCurve, 1);
    }
    }
    $everyFirstCurveShapeset = $ZnewfoundEdge;


    $everycurveSize = size($everyFirstCurveShapeset);
    while( size($everyFirstCurveShapeset) > 3 ){

    $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
    $FirstCurvesZ[0] = $everyFirstCurveShapeset[$everycurveSizeIndex];

    $firstcurveRelatives = `listRelatives -shapes $FirstCurvesZ`;
    $firstcurveConnectionsz = `listConnections $firstcurveRelatives`;
    $firstcurveshapes = `listConnections -shapes 1 $firstcurveConnectionsz`;
    $firstcurveConn = stringArrayRemove($firstcurveRelatives, $firstcurveshapes);
    $numberofconnections = size($firstcurveConn);

    if ( $numberofconnections >= 2 ) {
    stringArrayRemoveAtIndex($everycurveSizeIndex, $everyFirstCurveShapeset);
    $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
    $FirstCurvesZ[0] = $everyFirstCurveShapeset[$everycurveSizeIndex];
    }

    $everycurveSize = size($everyFirstCurveShapeset);
    if (( $everycurveSize < 1000 ) && ( $everycurveSize >= 500 )){
    $divide = $everycurveSize / 50;
    $switchNumber = 0;
    print $divide;}
    if (( $everycurveSize < 500 ) && ( $everycurveSize >= 250 )){
    $divide = $everycurveSize / 25;
    $switchNumber = 0;}
    if (( $everycurveSize < 250 ) && ( $everycurveSize >= 100 )){
    $divide = $everycurveSize / 12; }
    if (( $everycurveSize < 100 ) && ( $everycurveSize >= 50 )){
    $divide = $everycurveSize / 5;
    $switchNumber = 0;}
    if (( $everycurveSize < 50 ) && ( $everycurveSize >= 20 )){
    $divide =$everycurveSize / 4;
    $switchNumber = 0;}
    if (( $everycurveSize < 20 ) && ( $everycurveSize > 18 )){
    $divide = $everycurveSize / 2;
    $switchNumber = 0;
    print $divide;
    }
    if ( $everycurveSize <= 18 ){
    $switchNumber = 1;
    }


    switch($switchNumber)

    {
    case 0:
    $n = $divide;
    $NearestCurvesZ = (NearestObjectArray($n, $everyFirstCurveShapeset));
    $n2 = $n * 2;
    $NearestCurvesZn2 = (NearestObjectArray($n2, $everyFirstCurveShapeset));
    break;

    case 1:
    $NearestCurvesZ = $everyFirstCurveShapeset;
    $NearestCurvesZn2 = $everyFirstCurveShapeset;
    break;

    }
    print $NearestCurvesZ;
    if ( size($TEMPzCurveAAb) > 0){
    clear $TEMPzCurveAAb;
    }
    for ( $eachZ in $NearestCurvesZ ) {

    $ISTRUE0A1 = catchQuiet($intersectCurveZ0 = `curveIntersect -ch 0 -ud 0 -tol 0.01 $FirstCurvesZ $eachZ`);
    $numIntZZ = size($intersectCurveZ0);
    if (($ISTRUE0A1 > 0) || ($numIntZZ > 0)) {
    stringArrayInsertAtIndex(0, $TEMPzCurveAAb, $eachZ);
    }
    }
    $NearestCurvesZ = $TEMPzCurveAAb;
    $numInts2 = size($TEMPzCurveA);
    if ( $numInts2 > 0 ){
    clear $TEMPzCurveA;
    }

    if ( size($diff) > 0){
    clear $diff;
    }
    $diff = stringArrayRemove($NearestCurvesZ, $NearestCurvesZn2);
    if( size($diff) == 0 ) {
    clear $everyFirstCurveShapeset;
    clear $NearestCurvesZ;
    $switchNumberA = 0;
    } else if( size($diff) > 0 ){
    $switchNumberA = 1;
    }

    if(( size($NearestCurvesZ) == 3 ) && ($everycurveSize == 3)) {
    $switchNumberA = 0; }
    switch($switchNumberA)

    {
    case 0:
    print "done";
    break;

    case 1:

    for ( $eachAB in $diff ) {
    $ISTRUE0B = catchQuiet($intersectCurveZ1 = `curveIntersect -ch 0 -ud 0 -tol 0.01 $FirstCurvesZ $eachAB`);
    $numIntZZZ = size($intersectCurveZ1);
    if (($ISTRUE0B > 0) || ($numIntZZZ > 0)) {
    stringArrayInsertAtIndex(0, $TEMPzCurveA, $eachAB);
    }
    }
    $numInts2a = size($NearestCurvesZA);
    if ( $numInts2a > 0 ){
    clear $NearestCurvesZA;
    }
    $NearestCurvesZA = stringArrayCatenate($NearestCurvesZ, $TEMPzCurveA);
    $NearestCurvesZ = $NearestCurvesZA;
    $numInts2a = size($diffremove);
    if ( $numInts2a > 0 ){
    clear $diffremove;
    }
    $diffremove = stringArrayRemove($TEMPzCurveA, $diff);
    $numInts = size($TEMPAlldiffCurveZBBBB);
    if ( $numInts > 0 ){
    clear $TEMPAlldiffCurveZBBBB;
    }
    $TEMPAlldiffCurveZBBBB = $diffremove;
    //////////////////////////////////////////////////////

    clear $boundaryCurves;
    clear $boundaryCurves1;
    $X = 1;
    $i = 1;
    $B = 0;
    $endtrigger = 0;

    while (size($NearestCurvesZ) > 0 ){
    if ( $endtrigger == 2 ){
    clear $NearestCurvesZ;
    size($NearestCurvesZ);
    }
    for ( $each in $NearestCurvesZ ) {
    stringArrayInsertAtIndex(0, $boundaryCurves1, $each);
    clear $oneboundaryCurve;
    stringArrayInsertAtIndex(0, $oneboundaryCurve, $boundaryCurves1[0]);
    $X = 1;
    $ENDLOOPA = size($TEMPAlldiffCurveZBBBB);
    for ( $eachA in $TEMPAlldiffCurveZBBBB ) {
    stringArrayInsertAtIndex(0, $boundaryCurves1, $each);
    clear $oneboundaryCurve;
    stringArrayInsertAtIndex(0, $oneboundaryCurve, $boundaryCurves1[0]);
    $ISTRUE0A001 = catchQuiet($intersectCurveZ0A = `curveIntersect -ch 0 -ud 0 -tol 1.0 $each $eachA`);
    $ENDLOOPA = size($TEMPAlldiffCurveZBBBB);
    $X++;
    $numIntZZA = size($intersectCurveZ0A);
    if ((($ISTRUE0A001 == 0) && ( $X == $ENDLOOPA)) || (($numIntZZA == 0) && ( $X == $ENDLOOPA))) {
    $removecurveAz2[0] = $each;
    $NearestCurvesZ = stringArrayRemove($removecurveAz2, $NearestCurvesZ);
    } else if (($ISTRUE0A001 > 0) || ($numIntZZA > 0)){
    clear $diffX;
    $diffX = stringArrayRemoveExact($oneboundaryCurve, $NearestCurvesZ);
    $ENDLOOP = size($diffX);
    for ( $eachB in $diffX ) {
    if ( $endtrigger == 2 ){
    clear $NearestCurvesZ; }
    $ISTRUE0B002 = catchQuiet($intersectCurveZAB = `curveIntersect -ch 0 -ud 0 -tol 0.001 $eachA $eachB`);
    $numIntZZAB = size($intersectCurveZAB);
    $numsizeNearest = size($NearestCurvesZ);
    if (( $endtrigger == 0 ) && ( $numsizeNearest < 2 )){
    $removeoneFromeveryFirstA = stringArrayRemove($FirstCurvesZ, $everyFirstCurveShapeset);
    clear $NearestCurvesZ; }
    if (($ISTRUE0B002 > 0) || ($numIntZZAB > 0)) {
    ///////
    $myIntersector = `stringArrayIntersector`;
    clear $Foundboundarycurves;
    stringArrayInsertAtIndex(0, $Foundboundarycurves, $FirstCurvesZ[0]);
    stringArrayInsertAtIndex(0, $Foundboundarycurves, $each);
    stringArrayInsertAtIndex(0, $Foundboundarycurves, $eachA);
    stringArrayInsertAtIndex(0, $Foundboundarycurves, $eachB);
    for ( $eachboundry in $Foundboundarycurves ) {

    clear $selectedCurve;
    $selectedCurve[0] = $eachboundry;
    $firstcurveRelatives = `listRelatives -shapes $selectedCurve`;
    $firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
    $firstcurveshapes = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;
    stringArrayIntersector -edit -allowDuplicates false -intersect $firstcurveshapes $myIntersector;
    }
    $Intersectboundarycurves = `stringArrayIntersector -query $myIntersector`;

    stringArrayIntersector -edit -reset $myIntersector;
    if (size($Intersectboundarycurves) == 0){
    ///////
    boundary -ch 1 -or 0 -ep 1 -rn 1 -po 0 -ept 0.1 $FirstCurvesZ $each $eachA $eachB;

    }
    $endtrigger = $endtrigger +1;
    if ( $endtrigger == 1 || $endtrigger == 2 ) {
    stringArrayInsertAtIndex(0, $boundaryCurves, $each);
    stringArrayInsertAtIndex(0, $boundaryCurves, $eachB);
    stringArrayInsertAtIndex(0, $boundaryCurves, $eachA);
    }
    if ( $endtrigger < 2 ){
    $removecurveAz[0] = $each;
    $removecurveBz[0] = $eachB;
    $removecurveCz[0] = $eachA;
    $NearestCurvesZ = stringArrayRemove($removecurveAz, $NearestCurvesZ);
    $NearestCurvesZ = stringArrayRemove($removecurveBz, $NearestCurvesZ);
    $TEMPAlldiffCurveZBBBB = stringArrayRemove($removecurveCz, $TEMPAlldiffCurveZBBBB);
    else if ( $endtrigger == 2 ){
    clear $NearestCurvesZ; }

    }
    }
    //end of if
    }
    //end of For
    }
    }
    }

    $boundaryCurvessize = size($boundaryCurves);
    if( $boundaryCurvessize > 0 ) {

    for ( $eachboundry in $boundaryCurves ) {
    clear $selectedCurve;
    $selectedCurve[0] = $eachboundry;
    $firstcurveRelatives = `listRelatives -shapes $selectedCurve`;
    $firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
    $firstcurveshapes = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;
    $numberofconnections = size($firstcurveshapes);
    if ( $numberofconnections == 2 ) {
    $firstcurveConn = stringArrayRemove($selectedCurve, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset = $firstcurveConn;
    }
    }

    }
    $removeoneFromeveryFirst = stringArrayRemove($FirstCurvesZ, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset = $removeoneFromeveryFirst;
    clear $FirstCurvesZ;
    break;
    }

    }
    return $newallCurves;

}


/******************************************************************************
 * @procedure    Make_Middle_of_Curve_ParamlocatorZMirror
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $objectCurveSelected : string[]
 *   $MakeArcLocatorZ : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Make_Middle_of_Curve_ParamlocatorZMirror(string $objectCurveSelected[], string $MakeArcLocatorZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $a = 1;
    float $arclenghtzALL = `arclen $objectCurveSelected`;
    float $arclenghtzDivide = $arclenghtzALL / 2.0;
    float $step = 10;
    float $t = $a/$step;
    float $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    float $divZZ = $arclenghtzDivide / $arclenghtzparamZ;
    float $divZZ2 = $t * $divZZ;
    float $posA[];
    float $posB[];
    float $posC[];
    string $paramlocatorZARC[];
    string $paramANDCurve[] = `paramToCurvePts( $paramlocatorZARC )`;
    string $CircularArcFromCurve[];
    string $ArcCurve[];
    string $ParentArc[];
    string $ArcZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $arclenghtzALL = `arclen $objectCurveSelected`;
    $arclenghtzDivide = $arclenghtzALL / 2.0;
    $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectCurveSelected[0] + ".cv[0]") ;
    $CurveSelection[1] = ($objectCurveSelected[0] + ".cv[" + $numCVrealNum + "]") ;
    $paramlocatorZARC[0] = eval("paramLocator " +  $objectCurveSelected[0] + ".u[" + 0.0 + "]");

    $step = 10;
    $a = 1;
    $t = $a/$step;

    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $t;
    $paramANDCurve = `paramToCurvePts( $paramlocatorZARC )`;
    $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;

    $divZZ = $arclenghtzDivide / $arclenghtzparamZ ;
    $divZZ2 = $t * $divZZ ;
    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $divZZ2;
    ////////////////////// Moved ParamLoc to middle

    $posA = `pointPosition -w $CurveSelection[0]`;
    $posB = `pointPosition -w $paramlocatorZARC[0]`;
    $posC = `pointPosition -w $CurveSelection[1]`;
    $CircularArcFromCurve[0] = `createNode makeThreePointCircularArc`;
    setAttr ($CircularArcFromCurve[0] + ".pt1") $posA[0] $posA[1] $posA[2] ;
    setAttr ($CircularArcFromCurve[0] + ".pt2") $posB[0] $posB[1] $posB[2];
    setAttr ($CircularArcFromCurve[0] + ".pt3") $posC[0] $posC[1] $posC[2];
    setAttr ($CircularArcFromCurve[0] + ".d") 3;
    setAttr ($CircularArcFromCurve[0] + ".s") 8;
    $ArcCurve[0] = `createNode nurbsCurve` ;
    connectAttr ($CircularArcFromCurve[0] + ".oc") ($ArcCurve[0] +".cr");
    //delete $objectCurveSelected;
    $ParentArc = `listRelatives -parent $ArcCurve`;
    ResetTranlation($ParentArc);

    $ConnectLocToPoint2 = `connectAttr -f ($MakeArcLocatorZ[0] + ".translate") ( $CircularArcFromCurve[0] + ".pt2")`;

    $ArcZ[0] = `rename $ParentArc $objectCurveSelected`;
    delete $paramlocatorZARC;
    delete $objectCurveSelected;

    return $ArcZ;


}


/******************************************************************************
 * @procedure    stringArrayGmatchToArray
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] stringArrayGmatchToArray(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $listItem;
    string $MatchedItem[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    for ($listItem in $list) {
    if ( `gmatch $listItem $item` == 1){
    $result = true;
    if ($result == true ){ $MatchedItem = {$listItem};}
    break;	}
    }
    return $MatchedItem;

}


/******************************************************************************
 * @procedure    StraitCurvesSCRIPTZ
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] StraitCurvesSCRIPTZ()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $pA1 = PointsEquivalentTol($CurveCVzero,$BoxPointA);
    int $pA2 = PointsEquivalentTol($CurveCVLast,$BoxPointA);
    int $pC1 = PointsEquivalentTol($CurveCVzero,$BoxPointC);
    int $pC2 = PointsEquivalentTol($CurveCVLast,$BoxPointC);
    int $AorC = 0;
    int $squareA = 0;
    int $squareB = 0;
    int $XZ = 0;
    float $rotationz[];
    float $translationz[];
    float $bbox[] = `exactWorldBoundingBox $ObjectCurveduplicate`;
    float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox[2]};
    float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox[5]};
    float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox[2]};
    float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox[5]};
    float $BoxMPointAC[] = MidPointBetween($BoxPointA, $BoxPointC);
    float $BoxMPointBD[] = MidPointBetween($BoxPointB, $BoxPointD);
    float $BoxMPointAD[] = MidPointBetween($BoxPointA, $BoxPointD);
    float $BoxMPointBC[] = MidPointBetween($BoxPointB, $BoxPointC);
    float $CrossMPointAB[] = MidPointBetween($BoxPointA, $BoxPointB);
    float $translationzMiddle[];
    float $CurveCVzero[] = GetCurveCVposENDS($ObjectCurveduplicate, 0);
    float $CurveCVLast[] = GetCurveCVposENDS($ObjectCurveduplicate, 1);
    float $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    float $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);
    float $distanceAverage = (($distanceA + $distanceB) * (0.5));
    float $radiusX = ( $distanceAverage / 2.0);
    float $squarePercentA;
    float $squarePercentB;
    string $ObjectCurve[];
    string $StraitCurve[];
    string $ObjectCurveduplicate[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    //StraitCurves SCRIPT 5000

    $ObjectCurve = `ls -selection`;
    xform -cp;
    resetPivot;
    duplicatePreset(1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1);

    $ObjectCurveduplicate = `ls -selection`;
    setAttr ($ObjectCurveduplicate[0] + ".translate") 0 0 0;
    setAttr ($ObjectCurveduplicate[0] + ".rotate") 0 0 0;
    playButtonStepForward; select -cl  ;

    $rotationz = `xform -q -rotation $ObjectCurve`;
    $translationz = `xform -q -translation $ObjectCurve`;

    $bbox = `exactWorldBoundingBox $ObjectCurveduplicate`;
    print("Bounding box ranges from: " +
    $bbox[0] + "," + $bbox[1] + "," + $bbox[2] + ", to " +
    $bbox[3] + "," + $bbox[4] + "," + $bbox[5] + ".\n");

    spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
    move -ws $bbox[0] $bbox[1] $bbox[2] BoxspaceLocatorA;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
    move -ws $bbox[3] $bbox[4] $bbox[5] BoxspaceLocatorB;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
    move -ws $bbox[3] $bbox[1] $bbox[2] BoxspaceLocatorC;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
    move -ws $bbox[0] $bbox[4] $bbox[5] BoxspaceLocatorD;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;

    // xform -query -worldSpace -translation;


    $BoxPointA = {$bbox[0], $bbox[1], $bbox[2]};
    $BoxPointB = {$bbox[3], $bbox[4], $bbox[5]};
    $BoxPointC = {$bbox[3], $bbox[1], $bbox[2]};
    $BoxPointD = {$bbox[0], $bbox[4], $bbox[5]};

    $BoxPointA = `MakeCleanFloats($BoxPointA)`;
    $BoxPointB = `MakeCleanFloats($BoxPointB)`;
    $BoxPointC = `MakeCleanFloats($BoxPointC)`;
    $BoxPointD = `MakeCleanFloats($BoxPointD)`;

    $BoxMPointAC = MidPointBetween($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween($BoxPointB, $BoxPointC);
    //   MoveObjectSelection($BoxMPointAC);

    ///////////////////////////////
    ///////////////////////////////

    $CrossMPointAB = MidPointBetween($BoxPointA, $BoxPointB);
    // BoxspaceLocatorMiddle CHANGES need here in the future
    $translationzMiddle = $CrossMPointAB;

    $CurveCVzero = GetCurveCVposENDS($ObjectCurveduplicate, 0);
    $CurveCVLast = GetCurveCVposENDS($ObjectCurveduplicate, 1);

    $pA1 = PointsEquivalentTol($CurveCVzero,$BoxPointA);
    $pA2 = PointsEquivalentTol($CurveCVLast,$BoxPointA);
    $pC1 = PointsEquivalentTol($CurveCVzero,$BoxPointC);
    $pC2 = PointsEquivalentTol($CurveCVLast,$BoxPointC);

    $AorC = 0;
    if (($pA1 == 3) || ($pA2 == 3)){
    $AorC = 1;
    }
    if (($pC1 == 3) || ($pC2 == 3)){
    $AorC = 2;
    }
    $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);
    $distanceAverage = (($distanceA + $distanceB) * (0.5)) ;
    $radiusX = ( $distanceAverage / 2.0);

    if ( $distanceA > $distanceAverage) {
    $squarePercentA = (( $distanceAverage / $distanceA ) * (100));
    }
    if ( $distanceA < $distanceAverage) {
    $squarePercentA = (( $distanceA / $distanceAverage ) * (100));
    }
    if ( $distanceB > $distanceAverage) {
    $squarePercentB = (( $distanceAverage / $distanceB ) * (100));
    }
    if ( $distanceB < $distanceAverage) {
    $squarePercentB = (( $distanceB / $distanceAverage ) * (100));
    }
    /////////////////////


    $squareA = 0;
    $squareB = 0;
    if ( $squarePercentA > 55){
    $squareA = 1;
    }
    if ( $squarePercentB > 55){
    $squareB =  1;
    }

    $addSquareResults = ($squareA + $squareB);
    if ( $addSquareResults == 2 ){

    //Eval Diaginal curve
    // USE $radiusX for curve points

    if ( $AorC == 1){
    $StraitCurve[0] = `curve -d 1 -p $BoxPointA[0] $BoxPointA[1] $BoxPointA[2] -p $BoxPointB[0] $BoxPointB[1] $BoxPointB[2]`;
    }
    if ( $AorC == 2){
    $StraitCurve[0] = `curve -d 1 -p $BoxPointC[0] $BoxPointC[1] $BoxPointC[2] -p $BoxPointD[0] $BoxPointD[1] $BoxPointD[2]`;
    }

    } else {

    // Not Diagonal curves

    $XZ = 0;
    if ( $distanceA > $distanceB) {
    $XZ = 1;
    }
    if ( $distanceA < $distanceB) {
    $XZ = 2;
    }
    if ($XZ == 1){
    //$BoxMPointAD  $BoxMPointBC
    $StraitCurve[0] = `curve -d 1 -p $BoxMPointAD[0] $BoxMPointAD[1] $BoxMPointAD[2] -p $BoxMPointBC[0] $BoxMPointBC[1] $BoxMPointBC[2]`;
    }
    if ($XZ == 2){
    //$BoxMPointAC $BoxMPointBD
    $StraitCurve[0] = `curve -d 1 -p $BoxMPointAC[0] $BoxMPointAC[1] $BoxMPointAC[2] -p $BoxMPointBD[0] $BoxMPointBD[1] $BoxMPointBD[2]`;
    }
    }
    setAttr ($StraitCurve[0] + ".rotateX") $rotationz[0];
    setAttr ($StraitCurve[0] + ".rotateY") $rotationz[1];
    setAttr ($StraitCurve[0] + ".rotateZ") $rotationz[2];
    setAttr ($StraitCurve[0] + ".translateX") $translationz[0];
    setAttr ($StraitCurve[0] + ".translateY") $translationz[1];
    setAttr ($StraitCurve[0] + ".translateZ") $translationz[2];

    select -r $ObjectCurve $ObjectCurveduplicate BoxspaceLocatorA BoxspaceLocatorB BoxspaceLocatorC BoxspaceLocatorD BoxspaceLocatorMiddle;
    delete;
    select -r $StraitCurve;
    return $StraitCurve;


}


/******************************************************************************
 * @procedure    StartofCurveScriptRetopo2
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] StartofCurveScriptRetopo2()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    float $EACHCVposA[];
    float $EACHCVposB[];
    float $eachCVpos[];
    string $digitalSkeleton[];
    string $objectcurv[];
    string $CurveItemA = $objectcurv[0];
    string $CurveSelection[] = `ls -fl ($CurveItemA+".ep[0:*]")`;
    string $CurveEPzCount = size ($CurveSelection);
    string $AllIntersectCurveZ[];
    string $IntersectCurves[];
    string $MakeExtrudeSurface[];
    string $MakeBirailSurface[];
    string $MakeXBetween[];
    string $MakeIntersectCurvez[];
    string $MakespaceLocator[];
    string $each;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    Removefromsurface;
    performRebuildCurveSet 1 1 0 0.001 64 3 1 0 0 1 0 1 0.05;

    $numInts = size($digitalSkeleton);
    if ( $numInts > 0 ){
    clear $digitalSkeleton;
    }
    $objectcurv = `ls -sl`;
    $CurveItemA = $objectcurv[0];
    $CurveSelection = `ls -fl ($CurveItemA+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    ///////////////GATHER ALL BUILDING STRUCTURE/////////##
    appendStringArray($digitalSkeleton, $objectcurv, 1);
    /////////////////////////////////////////////////////##
    $numInts = size($AllIntersectCurveZ);
    if ( $numInts > 0 ){
    clear $AllIntersectCurveZ;
    }
    for ($each in $CurveSelection) {
    $eachCVpos = `pointPosition -w  $each`;
    $MakeIntersectCurvez[0] = `curve -d 1 -p 0 0 0 -p 12 0 0 -k 0 -k 1 -n IntersectCurve` ;
    appendStringArray($AllIntersectCurveZ, $MakeIntersectCurvez, 1);
    $numInts = size($AllIntersectCurveZ);
    extendCurvePresetArgList( "2", {"0", "0","0","0","100","0","0","0","0","1","1","1"} );
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 2 -kcp 0 -kep 1 -kt 0 -s 22 -d 3 -tol 0.001 ;
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos[2] $MakeIntersectCurvez[0];
    PAUSE;
    aimConstraint -offset 0 0 0 -weight 0.5 -aimVector -1 0 0 -upVector 0 0 -1 -worldUpType "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM   $MakeIntersectCurvez[0];
    PAUSE;
    }
    print $AllIntersectCurveZ;
    delete $objectcurv;
    return $AllIntersectCurveZ;

}


/******************************************************************************
 * @procedure    StartofCurveScriptRetopo3
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $PolygonShapeZ : string[]
 *   $ProjectionCurves : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] StartofCurveScriptRetopo3(string $PolygonShapeZ[], string $ProjectionCurves[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $KillScript = 1;
    int $curvesNumber = size($Allcurves) -1;
    int $iY = -1;
    int $switchN = 0;
    int $Xi = 1;
    int $a = 1;
    int $ADDSUB = 1;
    int $ADDSUB2 = 2;
    int $XiX = 0;
    int $triggerA = 0;
    int $RDivideTotalWithUnit;
    int $A2;
    int $Gate2 = 0;
    int $Gate1 = 0;
    int $a3 = 1;
    int $IFequivalent = equivalentTol($DistanceAB, $ZeroDistanceAB, 0.1);
    float $ZeroDistanceAB = 0.0;
    float $step = 1;
    float $DistanceFourth;
    float $UnitDistance;
    float $DivideTotalWithUnit;
    float $UnitDistanceA;
    float $UnitDistanceFourth;
    float $UnitDistanceHalf;
    float $valuesC[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    float $valuesD[] = `getAttr ($myCPOM+".position")`;
    float $DistanceCD = PointsGetDistanceFLOAT($valuesC, $valuesD);
    float $valuesA[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    float $valuesB[] = `getAttr ($myCPOM+".position")`;
    float $DistanceAB = PointsGetDistanceFLOAT($valuesA, $valuesB);
    string $PolygonShape[];
    string $AllIntersectCurveZA[] = $ProjectionCurves;
    string $curve = "curve -d 1";
    string $Allcurves[];
    string $curvePoints = "";
    string $crShape[];
    string $myCurve;
    string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = {$Newcurvez};
    string $NewcurveA[] = `ls -sl`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $PolygonShape[0] = $PolygonShapeZ[0];
    $AllIntersectCurveZA = $ProjectionCurves;

    //$PolygonShape[0] = $PolygonShapeZA[0];
    //string $AllIntersectCurveZA[] = $retopoProjectionCurves;
    //print $retopoProjectionCurves;

    makeIdentity -apply true -t 0 -r 0 -s 1 -n 0 $PolygonShape;
    $KillScript = 1;

    $curve = "curve -d 1";
    $Allcurves = $AllIntersectCurveZA;
    $curvesNumber = size($Allcurves) -1;
    $iY = -1;
    $ZeroDistanceAB = 0.0;
    $switchN = 0;
    $Xi = 1;
    $curvePoints = "";
    $step = 1;
    while ($curvesNumber > $iY ){
    if ($KillScript == 0 ){$iY = 1000;}
    $iY++;
    $a = 1;
    $ADDSUB = 1;
    $ADDSUB2 = 2;
    $b = 0;
    ///////////////////
    $switchN = 0;
    //////////////////
    $Xi = 1;
    $step = 1;
    $myCurve =  $Allcurves[$iY];
    $cube = $PolygonShape[0];
    $myCPOM = `createNode closestPointOnMesh`;
    connectAttr ($cube+".worldMesh") ($myCPOM+".inMesh");
    $LocatorResultA = `spaceLocator -p 0 0 0 -n LocA`;
    $LocA = $LocatorResultA[0];
    connectAttr ($myCPOM+".position") ($LocA+".translate");
    $LocatorResultB = `spaceLocator -p 0 0 0 -n LocB`;
    $LocB = $LocatorResultB[0];
    connectAttr ($LocB+".translate") ($myCPOM+".inPosition");

    $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    $connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($LocB + ".translate")`;
    $crShape = `listRelatives -s $myCurve`;
    $XiX = 0;
    $triggerA = 0;
    $Gate2 = 0;
    $Gate1 = 0;
    $a3 = 1;

    while($Xi > 0 ){

    $XiX++;
    if ($XiX == 1000){$Xi = 0; $KillScript = 0;}

    $valuesC = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    $valuesD = `getAttr ($myCPOM+".position")`;
    $DistanceCD = PointsGetDistanceFLOAT($valuesC, $valuesD);
    //float $DistanceAB1  = PointsGetDistanceFLOAT($valuesA, $valuesB);
    $a = AddorSubtract($a ,$ADDSUB);
    $t =  $a/$step;
    setAttr ($paramlocatorpointOnCurvex + ".parameter") $t;
    $para = `getAttr ($paramlocatorpointOnCurvex + ".parameter")`;
    PAUSE; select -r $LocA $LocB; PAUSE;
    $valuesA = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    $valuesB = `getAttr ($myCPOM+".position")`;
    $DistanceAB = PointsGetDistanceFLOAT($valuesA, $valuesB);
    if ($XiX < 4){ $Gate1 = $XiX;}
    if ($XiX == 1){ $Gate2 = 1;
    $UnitDistanceFourth = $DistanceAB/4;
    $UnitDistanceA  = PointsGetDistanceFLOAT($valuesC, $valuesA);
    }
    /*
    $DivideTotalWithUnit = $DistanceCD / $UnitDistance;
    $RDivideTotalWithUnit = $DivideTotalWithUnit;
    */

    print ("cycle "+$XiX);
    print ("Gate2 "+$Gate2);
    /////////////////////////////////////

    if ($XiX == $Gate2){ $Gate2 = $Gate1;
    $UnitDistance  = $UnitDistanceA;
    $UnitDistanceHalf = $UnitDistance/2;
    $DivideTotalWithUnit = ($DistanceAB/2) / $UnitDistanceHalf;
    $A2 = ($DivideTotalWithUnit +1);
    if ($A2 >= 1){
    print $a;
    //$a3 = $A2;
    $a = $a + $A2;
    //print $a;
    }else{ print "lessthen One unit";}
    }
    ///////////////////////////////////
    if ($switchN == 0){
    if ($triggerA == 0){
    if (( $DistanceAB <= $UnitDistanceHalf ) && ( $DistanceAB < $DistanceCD )) {$ADDSUB = 1; $step = 40; $a = $a * 40;
    $triggerA = 1; }
    }
    if (!($XiX == $Gate2)){
    if ( $DistanceAB > $DistanceCD ) { $ADDSUB = 0; $step = 20; $a = $a * 20; $switchN = 1;
    print ("0000  Passed Target Distance  0000" + "\n"); }
    }
    }
    if ($switchN == 2){
    if ( $DistanceAB > $DistanceCD ) { $ADDSUB = 1; $step = 80; $a = $a * 80;  $switchN = 3;
    $ADDSUB2 = 1; }
    }
    if ($switchN == 1){ $switchN = 2; }
    $IFequivalent = equivalentTol($DistanceAB, $ZeroDistanceAB, 0.1);
    if ($IFequivalent == 1){
    $curve += " -p "+$valuesA[0]+" "+$valuesA[1]+" "+$valuesA[2];
    delete $myCPOM $LocA $LocB $paramlocatorpointOnCurvex;
    $Xi = 0;
    }
    $b = AddorSubtract($b ,$ADDSUB2);
    if ( $b > 10 ){ delete $myCPOM $LocA $LocB $paramlocatorpointOnCurvex;
    $Xi = 0; }

    //////////////////////////////////

    /*
    print ($UnitDistance + "\n");
    print ($DistanceAB   + "\n");
    print ($DivideTotalWithUnit + "\n");
    print ($PercentDistanceZ + "\n");
    print ($RDivideTotalWithUnit + "\n");
    print ($a + "\n");
    print ($A2 + "\n");
    //if ( $DistanceAB <= $DistanceFourth ){ polySphere -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 -ch 1;
    //print ("0000  At One Fourth Distance  0000" + "\n");  }
    print ($switchN  + "\n");
    print ($triggerA  + "\n");
    print ($DistanceAB   + "\n");
    print ($DistanceCD   + "\n");
    print ($DivideTotalWithUnit   + "\n");
    */


    }


    }

    print $curve;
    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    $NewcurveA = `ls -sl`;

    //return $digitalSkeleton;
    //delete $AllIntersectCurveZA;

    //rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 2 -kcp 0 -kep 1 -kt 0 -s 40 -d 3 -tol 0.001 $Newcurve[0];

    //smoothCurve -ch 0 -rpo 1 -s 10.5 ($Newcurve[0]+".cv[*]");

    return $Newcurve;


}


/******************************************************************************
 * @procedure    StartofCurveScriptRetopo4
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $PolygonShapeZ : string[]
 *
 * @returns      string[]
 * @source       complex changes to Retopo3 script (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] StartofCurveScriptRetopo4(string $PolygonShapeZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $curvesNumber = size($Allcurves) -1;
    int $iY = -1;
    int $a;
    int $b;
    int $switchN = 0;
    int $Xi = 1;
    int $XiV = 1;
    int $XiX = 1;
    int $IFequivalent = equivalentTol($DistanceAB, $ZeroDistanceAB, 0.1);
    float $ZeroDistanceAB = 0.0;
    float $step = 1.0;
    float $valuesC[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    float $valuesD[] = `getAttr ($myCPOM+".position")`;
    float $DistanceCD = PointsGetDistanceFLOAT($valuesC, $valuesD);
    float $valuesA[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    float $valuesB[] = `getAttr ($myCPOM+".position")`;
    float $DistanceAB = PointsGetDistanceFLOAT($valuesA, $valuesB);
    float $DistanceFourth = $DistanceCD/4;
    string $AllIntersectCurveZA[] = `StartofCurveScriptRetopo2`;
    string $PolygonShape[];
    string $curve = "curve -d 1";
    string $Allcurves[];
    string $Ai = "$a++;
    string $Bi = "$b = 0;
    string $curvePoints = "";
    string $crShape[];
    string $myCurve;
    string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = {$Newcurvez};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $AllIntersectCurveZA = `StartofCurveScriptRetopo2`;
    select -cl  ;
    //TEMp
    //$PolygonShape[0] = $PolygonShapeZA[0];

    $PolygonShape[0] = $PolygonShapeZ[0];

    makeIdentity -apply true -t 0 -r 0 -s 1 -n 0 $PolygonShape;
    $curve = "curve -d 1";
    $Allcurves = $AllIntersectCurveZA;

    $curvesNumber = size($Allcurves) -1;
    $iY = -1;


    eval("int $a = 1;");
    eval("int $b = 0;");


    $ZeroDistanceAB = 0.0;
    $Ai = "$a++;";
    $Bi = "$b = 0;";
    $switchN = 0;
    $Xi = 1;
    $curvePoints = "";

    $step = 1.0;
    $XiV = 1;

    while (size($Allcurves) > $iY ){


    $XiV++;
    if ($XiV == 200){$iY = 0;}
    $iY++;
    $a = 1;
    $b = 0;
    $Ai = "$a++;";
    $Bi = "$b = 0;";
    $switchN = 0;
    $Xi = 1;
    $step = 1.0;

    $XiX = 1;


    $myCurve =  $Allcurves[$iY];
    $cube = $PolygonShape[0];
    $myCPOM = `createNode closestPointOnMesh`;
    connectAttr ($cube+".worldMesh") ($myCPOM+".inMesh");
    $LocatorResultA = `spaceLocator -p 0 0 0 -n LocA`;
    $LocA = $LocatorResultA[0];
    connectAttr ($myCPOM+".position") ($LocA+".translate");
    $LocatorResultB = `spaceLocator -p 0 0 0 -n LocB`;
    $LocB = $LocatorResultB[0];
    connectAttr ($LocB+".translate") ($myCPOM+".inPosition");

    $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    $connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($LocB + ".translate")`;
    $crShape = `listRelatives -s $myCurve`;

    while($Xi > 0 ){
    $XiX++;
    if ($XiX == 200){$Xi = 0;}
    $valuesC = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    $valuesD = `getAttr ($myCPOM+".position")`;
    $DistanceCD = PointsGetDistanceFLOAT($valuesC, $valuesD);

    eval($Ai);
    $t =  $a/$step;
    setAttr ($paramlocatorpointOnCurvex + ".parameter") $t;
    $para = `getAttr ($paramlocatorpointOnCurvex + ".parameter")`;
    PAUSE;
    select -r $LocA $LocB;
    PAUSE;
    $valuesA = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    $valuesB = `getAttr ($myCPOM+".position")`;
    $DistanceAB = PointsGetDistanceFLOAT($valuesA, $valuesB);

    $DistanceFourth = $DistanceCD/4;

    //if ( $DistanceAB > $DistanceCD ) {print "Past Intersect"; }

    if ($switchN == 0){
    if ( $DistanceAB > $DistanceCD ) { $Ai = "$a--;"; $step = 20; $a = $a * 20; $switchN = 1;  }
    }

    if ($switchN == 2){
    if ( $DistanceAB > $DistanceCD ) { $Ai = "$a++;"; $step = 40; $a = $a * 40;  $switchN = 3;
    $Bi = "$b++;";
    }
    }
    if ($switchN == 1){ $switchN = 2; }
    $IFequivalent = equivalentTol($DistanceAB, $ZeroDistanceAB, 0.1);
    if ($IFequivalent == 1){
    $curve += " -p "+$valuesA[0]+" "+$valuesA[1]+" "+$valuesA[2];
    delete $myCPOM $LocA $LocB $paramlocatorpointOnCurvex;
    PAUSE;
    select -r $LocA $LocB $myCurve;
    PAUSE;

    $Xi = 0;
    }
    eval($Bi);
    if ( $b > 10 ){ PAUSE;
    select -r $myCurve;
    PAUSE;
    delete $myCPOM $LocA $LocB $paramlocatorpointOnCurvex;
    $Xi = 0; }



    }

    print $curve;




    }

    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    ////
    //return $digitalSkeleton;
    delete $AllIntersectCurveZA;
    return $Newcurve;

}


/******************************************************************************
 * @procedure    Eval3DCircleStereo
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $NewArrayBEllipZ : int[]
 *   $EmptyVectorArrayB : vector[]
 *   $NewArrayIntX : int[]
 *   $EmptyVectorArrayA : vector[]
 *
 * @returns      string []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] Eval3DCircleStereo(int $NewArrayBEllipZ[], vector $EmptyVectorArrayB[], int $NewArrayIntX[], vector $EmptyVectorArrayA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iiz = 0;
    float $CamPos_A[];
    float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;
    string $ThefirstCurve = VecArrayToCurveB($Intersect_A);
    string $ThefirstCurvei = VecArrayToCurveB($Intersect_B);
    string $BothCurves[];
    vector $PositionsZ_B[] = $EmptyVectorArrayB;
    vector $VecPtsMirrorA[];
    vector $Intersect_A[];
    vector $Intersect_B[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PositionsZ_B = $EmptyVectorArrayB;
    $VecPtsMirrorA = VecPtsToZMirrorPts( $EmptyVectorArrayA);
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    $iiz = 0;
    for ($eachVecx in  $VecPtsMirrorA)	{
    $Intersect_A[`size($Intersect_A)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_B[$NewArrayBEllipZ[$iiz]], $CamPos_M, $VecPtsMirrorA[$NewArrayIntX[$iiz]]));
    $iiz++;
    }
    $ThefirstCurve = VecArrayToCurveB($Intersect_A);
    $Intersect_B= VecPtsToZMirrorPts($Intersect_A);
    $ThefirstCurvei = VecArrayToCurveB($Intersect_B);
    $BothCurves[0] = $ThefirstCurve;
    $BothCurves[1] = $ThefirstCurvei;
    return  $BothCurves;


}


/******************************************************************************
 * @procedure    NewVecOrderEllipZ
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $NewOneCurveS : string
 *   $EmptyVectorArrayA : vector[]
 *   $MidEpipolPosFCam : float[]
 *
 * @returns      int []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] NewVecOrderEllipZ(string $NewOneCurveS, vector $EmptyVectorArrayA[], float $MidEpipolPosFCam[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IndexTrackE[];
    int $TwoZeroOne[] = {0,1};
    int $TwoZeroOneG[] = {0,1};
    int $TFmostRArray[];
    int $LargestIntR_KEY[];
    int $LargestIntL_KEY[];
    int $COUNT_Nlr = 0;
    int $LargestIntR[] = SortNumbersIntIndex($AllAngiX_RIGHT);
    int $LargestIntL[] = SortNumbersIntIndex($AllAngiX_LEFT);
    int $NewStartInt = $LargestIntL_KEY[$LargestIntL[0]];
    int $SizeE = `size($EmptyVectorArrayA)`;
    int $NewArrayInt;
    int $NewArrayIntX[];
    int $Add = 0;
    float $EllipesPos_A[];
    float $allAngiX[];
    float $DIff;
    float $AllAngiX_RIGHT[];
    float $AllAngiX_LEFT[];
    vector $Dir_VecMAIN;
    vector $threeVecs[];
    vector $threeVecsG[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $EllipesPos_A = `xform -q -ws -t $NewOneCurveS`;
    $Dir_VecMAIN =  DirectionFN($MidEpipolPosFCam, $EllipesPos_A);
    $IndexTrackE = CreateIntIndex(`size($EmptyVectorArrayA)`);

    $TwoZeroOne = {0,1};
    $TwoZeroOneG = {0,1};
    clear $allAngiX; clear $TFmostRArray;
    $threeVecs[0] = FloatToVec($MidEpipolPosFCam);
    $threeVecs[1] = FloatToVec($EllipesPos_A);

    for($EachVector in $EmptyVectorArrayA){

    $DIff = FindDirectionDiff($Dir_VecMAIN, $MidEpipolPosFCam, $EachVector);
    if($DIff!= 0){
    $allAngiX[`size($allAngiX)`]=  VAnglesofThreeVec($MidEpipolPosFCam, $EllipesPos_A, $EachVector);
    $threeVecs[2] = $EachVector;
    $TFmostRArray[`size($TFmostRArray)`] = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);

    }else{ $allAngiX[`size($allAngiX)`]= 0;  $TFmostRArray[`size($TFmostRArray)`] =0;}

    }

    //print  $allAngiX;
    //print  $TFmostRArray;

    clear $LargestIntR_KEY;
    clear $LargestIntL_KEY;
    clear $AllAngiX_LEFT;
    clear $AllAngiX_RIGHT;
    $COUNT_Nlr = 0;
    for($EachIntarray in $TFmostRArray){
    if($EachIntarray==1){
    $AllAngiX_RIGHT[`size($AllAngiX_RIGHT)`]= $allAngiX[$COUNT_Nlr];
    $LargestIntR_KEY[`size($LargestIntR_KEY)`]=$COUNT_Nlr;
    }
    if($EachIntarray==0){
    $AllAngiX_LEFT[`size($AllAngiX_LEFT)`]= $allAngiX[$COUNT_Nlr];
    $LargestIntL_KEY[`size($LargestIntL_KEY)`]=$COUNT_Nlr;
    }
    $COUNT_Nlr++;
    }

    $LargestIntR = SortNumbersIntIndex($AllAngiX_RIGHT);
    $LargestIntR = ReverseIntArray($LargestIntR);
    // Loc $EmptyVectorArrayA[$LargestIntR_KEY[$LargestIntR[0]]];
    $LargestIntL = SortNumbersIntIndex($AllAngiX_LEFT);
    $LargestIntL = ReverseIntArray($LargestIntL);
    // Loc $EmptyVectorArrayA[$LargestIntL_KEY[$LargestIntL[0]]];

    print $LargestIntR_KEY[$LargestIntR[0]];
    print $LargestIntL_KEY[$LargestIntL[0]];
    // Loc $EmptyVectorArrayA[$LargestIntL_KEY[$LargestIntL[0]]];
    // test
    $NewStartInt = $LargestIntL_KEY[$LargestIntL[0]];
    //  $IndexTrackE
    $SizeE = `size($EmptyVectorArrayA)`;
    $Add = 0;
    for($EachIntX in $IndexTrackE){
    $NewArrayIntX[`size($NewArrayIntX)`] = fmod(($NewStartInt+$Add),$SizeE);
    $Add++;
    }
    Loc $EmptyVectorArrayA[$NewArrayIntX[0]];
    Loc $EmptyVectorArrayA[$NewArrayIntX[12]];
    curve2points($EmptyVectorArrayA[$NewArrayIntX[0]],$EllipesPos_A);
    curve2points($EmptyVectorArrayA[$NewArrayIntX[0]],$EmptyVectorArrayA[$NewArrayIntX[12]]);
    $threeVecsG[0] = $EmptyVectorArrayA[$NewArrayIntX[0]];
    $threeVecsG[1] = FloatToVec($EllipesPos_A);
    $threeVecsG[2] = $EmptyVectorArrayA[$NewArrayIntX[12]];
    $MostRL_Int = MostRightClockWiseInt ($threeVecsG, $TwoZeroOneG);
    return $NewArrayIntX;


}


/******************************************************************************
 * @procedure    CurvatureIsCircle
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $curvesZ : string
 *   $NumberofSteps : int
 *   $angleZ : float[]
 *   $TotalDeg : float
 *   $low : int
 *   $C : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] CurvatureIsCircle(string $curvesZ, int $NumberofSteps, float $angleZ[], float $TotalDeg, int $low, float $C[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 4 );
    int $Par = 0;
    int $a;
    int $ii = 0;
    int $iX = 0;
    int $Trigger = 0;
    int $Lowest = 11110;
    int $Past = 0;
    int $TF = 0;
    int $CountEVEN = 0;
    int $Even_Odd;
    float $AverageVecCurve[] = AverageVectorPoint($PositionsZ_A);
    float $CIrceP[];
    float $CN[];
    float $step = $NumberofSteps;
    float $StepCycle = 0;
    float $pastA = 0.0;
    float $AddAngles = 0.0;
    float $allAngiX[];
    float $DistancesCycle[];
    float $FXiI = $StepCycle;
    float $Fnumbers = 100.0/$FXiI;
    float $floatZ[];
    string $myCurve = $curvesZ;
    string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size  ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    vector $PositionsZ_A[];
    vector $VecAverage = FloatToVec($AverageVecCurve);
    vector $CurveVectors[];
    vector $FlushVectors[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $myCurve = $curvesZ;
    //smoothCurve -ch 0 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($curvesZ);
    $AverageVecCurve = AverageVectorPoint($PositionsZ_A);
    $CIrceP = `xform -q -ws -t $myCurve`;
    $AverageVecCurve =$CIrceP;
    Loc $AverageVecCurve;
    $VecAverage = FloatToVec($AverageVecCurve);

    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 4 );

    $numEPrealNum2 = $NumberofSteps;
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    $step = $NumberofSteps;
    $Par = 0;
    $StepCycle = 0;
    $ii = 0;
    $iX = 0;
    $Trigger = 0;
    $Lowest = 11110;
    $Past = 0;
    $pastA = 0.0;
    $AddAngles = 0.0;
    $allAngi[`size($allAngi)`] = 0;
    $allAngiX[`size($allAngiX)`] = 0;
    $TwoZeroOne = {0,1};
    $C[0] = 0;
    $CN[0] = 0;
    $TF = 0;
    $CountEVEN = 0;

    for($a = 0; $a <= $step;$a++){

    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $valuesXYZ  = {$values[0], $values[1], $values[2]};
    $CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
    $FlushVectors[`size($FlushVectors)`] = <<$values[0], $values[1], $values[2]>>;
    $PresentV = FloatToVec($values);
    // creat a vator array thatclears every time it passes 360 deg.. so the last few steps are recored..
    // then take the last angle find the persect it is of 360  divide that by the number of septs then use that as a float step

    if($ii>0){$Past=$ii-1;
    $EachAngle = VAnglesofThreeVec($VecAverage, $PositionsZ_A[0], $CurveVectors[$ii]);
    $threeVecs[0] = $PositionsZ_A[0]; $threeVecs[1] = $VecAverage; $threeVecs[2] = $PresentV;
    $TFmostR = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);
    $C[$iX] = $TFmostR;
    if($ii==1){ $C[$iX-1]= $C[$iX];
    $CN[`size($CN)`-1]=$C[$iX];
    }
    $allAngi[$iX] =$EachAngle;
    if($Trigger== 1){
    $allAngi[$iX] = (abs($pastA - $EachAngle))+$allAngi[$iX-1];
    if($allAngi[$iX]> 360){ $allAngi[$iX]=$EachAngle; $allAngi[$iX-1]=0;  $Trigger= 0; $TF++; }
    }

    if($C[$iX]!=$C[$iX-1]){
    //Loc $valuesXYZ;
    $CN[`size($CN)`]= $iX;
    $CN[`size($CN)`]=$C[$iX];
    $Even_Odd = fmod($CountEVEN,2);
    if($Even_Odd ==1){
    $DistancesCycle[`size($DistancesCycle)`]= distance2Pts ($PositionsZ_A[0], $PresentV);
    }
    $CountEVEN++;
    $angleTii = (180.00- $allAngi[$iX]) +(180.00- $allAngi[$iX-1]);
    $allAngi[$iX] =  $angleTii +$allAngi[$iX-1];
    $Trigger= 1;
    }
    $pastA = $EachAngle;
    $AddAngles+= abs($EachAngle - $allAngiX[`size($allAngiX)`-1]);
    if($allAngi[`size($allAngi)`-1]>=360){
    clear $FlushVectors;
    $StepCycle =  abs ($StepCycle -$a);
    $FXiI = $StepCycle;
    $Fnumbers = 100.0/$FXiI;
    $floatZ = CreateIntIndexF($FXiI, $Fnumbers);
    $StepCycle = $a;
    //Loc $CurveVectors[$ii];
    $AddAngles=0;
    }
    }
    if($StepCycle < $Lowest){
    if($StepCycle!=0){
    $Lowest = $StepCycle;
    }
    }
    $PastV = FloatToVec($values);
    $iX++;
    $ii++;
    if( $ii == 990){
    break;
    }
    }
    $CN[`size($CN)`]= $iX;
    //$low = $StepCycle;
    $low = $TF;
    //print $TF;
    $angleZ = $DistancesCycle;
    $low = $TF;
    delete $paramlocatorpointOnCurvex;
    $TotalDeg = $AddAngles;
    //$angleZ = $allAngi;
    //print $CN;
    return $CN;

}


/******************************************************************************
 * @procedure    IScircleTF
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $EachCrvX : string
 *   $TFCc : int
 *
 * @returns      string
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string IScircleTF(string $EachCrvX, int $TFCc)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sizeZ = `size($PositionsZ_Aii)`;
    int $LowX;
    int $CirTrigger = 0;
    int $Count = 0;
    int $XnN = `size($AverNumber)`-1;
    float $Arc = `arclen $EachCrv`;
    float $ArcX = ($Arc /3.5) + 5.0;
    float $angleZi[];
    float $CollectCii[];
    float $TotalDegi;
    float $TrackCi[];
    float $CycleDIstAv = $angleZi[0];
    float $AverNumber[] = GatherDataC($TrackCi);
    float $Even_Odd = fmod((`size($AverNumber)` ),2);
    float $AverageUnits = AverageFloats($AverNumber);
    float $NewFarray[];
    float $MathA;
    float $DivideArc;
    float $SegArc;
    float $MathADX;
    float $DiffFromAv[];
    float $AverageDiffA;
    float $MathAD;
    float $DiffMathA;
    string $EachCrv;
    string $firstCurveii;
    string $curvesZi = $EachCrv;
    vector $PositionsZ_Aii[];
    vector $CurveCollectVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    global int $TFCircleORnotCircle;
    $TFCircleORnotCircle =0;
    $PositionsZ_Aii = VecCurveEps($EachCrvX );

    $EachCrv = VecArrayToCurveB($PositionsZ_Aii);
    $firstCurveii = $EachCrv;
    ResetTransEachSL;
    $sizeZ = `size($PositionsZ_Aii)`;

    $Arc = `arclen $EachCrv`;
    $Arc = ($Arc /3.5);
    $ArcX = ($Arc /3.5) + 5.0;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s $sizeZ -d 3 -tol 0.05 $EachCrv;
    $curvesZi = $EachCrv;

    $CollectCii = CurvatureIsCircle($curvesZi, 130, $angleZi, $TotalDegi, $LowX, $TrackCi);
    $CycleDIstAv = $angleZi[0];
    if(`size($angleZi)`>1){ $CycleDIstAv = AverageFloats($angleZi);}

    $AverNumber = GatherDataC($TrackCi);
    $Even_Odd = fmod((`size($AverNumber)` ),2);
    $AverageUnits = AverageFloats($AverNumber);
    $CirTrigger = 0;
    if($TrackCi[`size($TrackCi)`-1]<$AverageUnits){
    $Count = 0;
    $XnN = `size($AverNumber)`-1;

    if($XnN>1){
    for($eachFl in $AverNumber){
    if($Count!= $XnN){
    $NewFarray[`size($NewFarray)`] = $eachFl;
    }
    $Count++;
    }
    $CirTrigger =1;
    }else{$CirTrigger =0;}
    }

    //print ($CirTrigger+"\n");

    clear $DiffFromAv;

    if($CirTrigger==1){
    $Even_Odd = fmod((`size($NewFarray)` ),2);
    $SegArc = `size($NewFarray)`;
    $DivideArc = $Arc/$SegArc;
    $AverageUnits=AverageFloats($NewFarray);
    $MathA= $Arc/$AverageUnits;
    $DiffFromAv=GatherDataDiff($NewFarray,$AverageUnits);
    $AverageDiffA=AverageFloats($DiffFromAv);
    $DiffMathA =  $AverageDiffA / ($AverageUnits/100.0);
    $MathAD= `abs ($AverageDiffA-$AverageUnits)`;
    $MathADX = $DivideArc/$MathAD;
    //print ( "DiffMathA "+$DiffMathA+"\n");
    //print ("CycleDIstAv "+$CycleDIstAv+"\n");

    if(($DiffMathA<14.5)&&($CycleDIstAv<$Arc)){
    $TFCircleORnotCircle=1;
    $TFCc++;
    }else{ $TFCircleORnotCircle=0;}

    }else{ $TFCircleORnotCircle=0;}

    // print ("TFCircleORnotCircle "+$TFCircleORnotCircle+"\n");
    if($TFCircleORnotCircle==1){
    $TFCc += 1;
    }
    if($TFCircleORnotCircle==1){
    // delete $EachCrvX ;
    }
    if($TFCircleORnotCircle==0){
    delete $EachCrv ;
    }

    return $firstCurveii;

}


/******************************************************************************
 * @procedure    NewVecOrderWithINTKey
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $IntIndexTrack : int[]
 *   $ObjsCurve : vector[]
 *
 * @returns      vector[]
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] NewVecOrderWithINTKey(int $IntIndexTrack[], vector $ObjsCurve[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $newOrderVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($eachVi in $IntIndexTrack){
    $newOrderVec[`size($newOrderVec)`] = $ObjsCurve[$eachVi];
    }
    return $newOrderVec;

}


/******************************************************************************
 * @procedure    CurvatureUtilityAngles
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $curvesZ : string
 *   $NumberofSteps : int
 *   $angleZ : float[]
 *   $TotalDeg : float
 *   $low : int
 *   $C : int[]
 *
 * @returns      vector []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] CurvatureUtilityAngles(string $curvesZ, int $NumberofSteps, float $angleZ[], float $TotalDeg, int $low, int $C[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 4 );
    int $Par = 0;
    int $a;
    int $ii = 0;
    int $iX = 0;
    int $Trigger = 0;
    int $Lowest = 11110;
    int $Past = 0;
    float $AverageVecCurve[] = AverageVectorPoint($PositionsZ_A);
    float $step = $NumberofSteps;
    float $StepCycle = 0;
    float $pastA = 0.0;
    float $AddAngles = 0.0;
    float $allAngiX[];
    float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    float $FXiI = $StepCycle;
    float $Fnumbers = 100.0/$FXiI;
    float $floatZ[];
    string $myCurve = $curvesZ;
    string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size  ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    vector $PositionsZ_A[];
    vector $VecAverage = FloatToVec($AverageVecCurve);
    vector $CurveVectors[];
    vector $FlushVectors[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $myCurve = $curvesZ;
    //smoothCurve -ch 0 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($curvesZ);

    $AverageVecCurve = AverageVectorPoint($PositionsZ_A);
    //Loc $AverageVecCurve;
    $VecAverage = FloatToVec($AverageVecCurve);


    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 4 );

    $numEPrealNum2 = $NumberofSteps;
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;

    $step = $NumberofSteps;
    $Par = 0;
    $StepCycle = 0;
    $ii = 0;
    $iX = 0;
    $Trigger = 0;
    $Lowest = 11110;
    $Past = 0;
    $pastA = 0.0;
    $AddAngles = 0.0;
    $allAngi[`size($allAngi)`] = 0;
    $allAngiX[`size($allAngiX)`] = 0;
    $TwoZeroOne = {0,1};
    $C[0] = 0;

    for($a = 0; $a <= $step;$a++){

    $t =  $a/$step;
    $Par = ($a/$step);

    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $valuesXYZ  = {$values[0], $values[1], $values[2]};
    $CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
    $FlushVectors[`size($FlushVectors)`] = <<$values[0], $values[1], $values[2]>>;
    $PresentV = FloatToVec($values);


    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    // creat a vator array thatclears every time it passes 360 deg.. so the last few steps are recored..
    // then take the last angle find the persect it is of 360  divide that by the number of septs then use that as a float step

    if($ii>0){$Past=$ii-1;

    $EachAngle = VAnglesofThreeVec($VecAverage, $PositionsZ_A[0], $CurveVectors[$ii]);
    $threeVecs[0] = $PositionsZ_A[0]; $threeVecs[1] = $VecAverage; $threeVecs[2] = $PresentV;

    $TFmostR = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);

    $C[$iX] = $TFmostR;
    if($ii==1){ $C[$iX-1]= $C[$iX]; }


    $allAngi[$iX] =$EachAngle;

    if($Trigger== 1){
    $allAngi[$iX] = (abs($pastA - $EachAngle))+$allAngi[$iX-1];
    if($allAngi[$iX]> 360){ $allAngi[$iX]=$EachAngle; $allAngi[$iX-1]=0;  $Trigger= 0;}
    }


    if($C[$iX]!=$C[$iX-1]){
    $angleTii = (180.00- $allAngi[$iX]) +(180.00- $allAngi[$iX-1]);
    $allAngi[$iX] =  $angleTii +$allAngi[$iX-1];
    $Trigger= 1;
    }

    $pastA = $EachAngle;
    $AddAngles+= abs($EachAngle - $allAngiX[`size($allAngiX)`-1]);


    if($allAngi[`size($allAngi)`-1]>=360){
    clear $FlushVectors;
    $StepCycle =  abs ($StepCycle -$a);
    $FXiI = $StepCycle;
    $Fnumbers = 100.0/$FXiI;
    $floatZ = CreateIntIndexF($FXiI, $Fnumbers);

    $StepCycle = $a;
    //Loc $CurveVectors[$ii];
    $AddAngles=0;

    }
    }

    if($StepCycle < $Lowest){
    if($StepCycle!=0){
    $Lowest = $StepCycle;
    }
    }

    $PastV = FloatToVec($values);

    $iX++;
    $ii++;

    if( $ii == 990){
    break;
    }

    }
    $low = $StepCycle;


    delete $paramlocatorpointOnCurvex;
    $TotalDeg = $AddAngles;
    $angleZ = $allAngi;
    return $CurveVectors;

}


/******************************************************************************
 * @procedure    EllipesSketchFitting
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $curveItemC : string
 *   $EmptyVectorArray : vector[]
 *
 * @returns      string
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string EllipesSketchFitting(string $curveItemC, vector $EmptyVectorArray[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Low_X;
    int $TrackC[];
    int $NewIndex[];
    int $Xv = 0;
    int $Mini[];
    int $NewIndexAi[];
    int $MidAngle = (`size($NewIndexAi)`-1)/2;
    int $xc = 0;
    int $findLowestGroup[];
    int $Pastint;
    int $ChangeOver;
    int $Sub;
    float $Arc = `arclen $CurveItemZai[0]`;
    float $angleZi[];
    float $TotalDegi;
    float $AverageVecCurve[] = AverageVectorPoint($vectorZnewX);
    float $CIrceP[];
    float $DPiMidi = distance2Pts($CurveCollectVec[$NewIndexAi[0]],$AverageVecCurve);
    float $FloatDirMA[] = DirectionFN($AverageVecCurve,$CurveCollectVec[$NewIndexAi[0]]);
    float $LowestAngle = $angleZii[$NewIndexAi[0]];
    float $MiddleAngle = $angleZii[$NewIndexAi[$MidAngle]];
    float $HighestAngle = $angleZii[$NewIndexAi[`size($NewIndexAi)`-1]];
    float $AvAllangles = ($LowestAngle+$MiddleAngle+$HighestAngle)/3.0;
    float $eachAi;
    string $CurveItemZai[];
    string $curvesZi = $CurveItemZai[0];
    string $TestCurveC;
    string $NewCurveE[] = `ls -sl`;
    vector $CurveCollectVec[];
    vector $nevVec[] = NewVecOrderWithINTKey($NewIndex,$CurveCollectVec);
    vector $vectorZnewX[];
    vector $MidVecDir = FloatToVec($FloatDirMA);
    vector $AveVec = FloatToVec($AverageVecCurve);
    vector $NewPvec;
    vector $ThreeEllipVecP[];
    vector $NewEllipesCurve[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    // string $CurveItemZai[]; $CurveItemZai[0] = $CurveNS;
    $CurveItemZai[0] = $curveItemC;

    $Arc = `arclen $CurveItemZai[0]`;
    $Arc = $Arc /3.5;

    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 130 -d 3 -tol 0.05 $CurveItemZai[0];

    $curvesZi = $CurveItemZai[0];
    $CurveCollectVec = CurvatureUtilityAngles($curvesZi, 130, $angleZi, $TotalDegi,$Low_X, $TrackC);


    clear $NewIndex;
    $NewIndex  = SortNumbersIntIndex($angleZi);
    $nevVec = NewVecOrderWithINTKey($NewIndex,$CurveCollectVec);
    $vectorZnewX =$nevVec;
    $Xv = 0;
    while($Xv < 22){
    $vectorZnewX = AverageCurveVec($vectorZnewX);
    $Xv++;
    }
    $TestCurveC = VecArrayToCurveB($vectorZnewX);
    ResetTransEachSL;

    $AverageVecCurve = AverageVectorPoint($vectorZnewX);
    //Loc $AverageVecCurve;

    $CIrceP = `xform -q -ws -t $TestCurveC`;
    //Loc $CIrceP;
    $AverageVecCurve =$CIrceP;

    clear $angleZii;  clear $CurveCollectVec;
    //select -r $TestCurveC;

    $CurveCollectVec = CurvatureUtility($TestCurveC, 3, $angleZii, $TrackC, $AddedCurvA);


    clear $NewIndexAi;
    $NewIndexAi  = SortNumbersIntIndex($angleZii);


    //curve2points($CurveCollectVec[$NewIndexAi[0]],$AverageVecCurve);

    $DPiMidi = distance2Pts($CurveCollectVec[$NewIndexAi[0]],$AverageVecCurve);
    $FloatDirMA = DirectionFN($AverageVecCurve,$CurveCollectVec[$NewIndexAi[0]]);

    $MidVecDir = FloatToVec($FloatDirMA);
    $AveVec = FloatToVec($AverageVecCurve);
    $NewPvec = ($MidVecDir * $DPiMidi)+ $AveVec;
    //Loc $NewPvec;
    // the three vectors needed to make the ellipse
    //$CurveCollectVec[$NewIndexAi[0]] , $NewPvec and any point one curve (close to first vec)


    $MidAngle = (`size($NewIndexAi)`-1)/2;

    $LowestAngle = $angleZii[$NewIndexAi[0]];
    $MiddleAngle = $angleZii[$NewIndexAi[$MidAngle]];
    $HighestAngle = $angleZii[$NewIndexAi[`size($NewIndexAi)`-1]];
    $AvAllangles = ($LowestAngle+$MiddleAngle+$HighestAngle)/3.0;

    $xc = 0;
    clear $findLowestGroup;
    for($eachAi in $angleZii){
    if($eachAi< $AvAllangles){
    $findLowestGroup[`size($findLowestGroup)`]=$xc;
    //Loc  $CurveCollectVec[$xc];
    }
    $xc++;
    }

    $findLowestGroup = `sort $findLowestGroup`;

    $xc =0;
    for($eachInt in $findLowestGroup){
    if($xc>0){
    $Sub =$eachInt -$Pastint;
    if(($eachInt -$Pastint)> 3){
    $ChangeOver =  $Pastint;
    //Loc  $CurveCollectVec[$ChangeOver];
    }
    }
    $Pastint = $eachInt;
    $xc++;
    }


    // the three vectors needed to make the ellipse
    //$CurveCollectVec[$NewIndexAi[0]] , $NewPvec and any point one curve (close to first vec)
    //$CurveCollectVec[$NewIndexAi[0]] , $NewPvec, $CurveCollectVec[$ChangeOver];

    $ThreeEllipVecP[0] = $CurveCollectVec[$NewIndexAi[0]] ;
    $ThreeEllipVecP[1] = $NewPvec;
    $ThreeEllipVecP[2] = $CurveCollectVec[$ChangeOver];

    $NewEllipesCurve = calculateEllipseCurve($ThreeEllipVecP, 300);
    $NewCurveE = `ls -sl`;
    $EmptyVectorArray = $NewEllipesCurve;

    delete $CurveItemZai[0];
    delete $TestCurveC;
    return $NewCurveE[0];


}


/******************************************************************************
 * @procedure    MultLenToDirAddToPoint
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Length : float
 *   $Dir : float[]
 *   $Pos : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] MultLenToDirAddToPoint(float $Length, float $Dir[], float $Pos[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MultLengthDir[] = multiplyFloat($Length, $Dir);
    float $AddMultDirPos[] = AddFloats($Pos, $MultLengthDir);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MultLengthDir = multiplyFloat($Length, $Dir);
    $AddMultDirPos = AddFloats($Pos, $MultLengthDir);
    return $AddMultDirPos;

}


/******************************************************************************
 * @procedure    SimpleEllipse3Pts
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $TestCurveC : string
 *   $EmptyVectorArray : vector[]
 *
 * @returns      string
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string SimpleEllipse3Pts(string $TestCurveC, vector $EmptyVectorArray[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $TrackC[];
    int $Mini[];
    int $NewIndexAi[];
    int $MidAngle = (`size($NewIndexAi)`-1)/2;
    int $xc = 0;
    int $findLowestGroup[];
    int $Pastint;
    int $ChangeOver;
    int $Sub;
    float $CIrceP[];
    float $DPiMidi = distance2Pts($CurveCollectVec[$NewIndexAi[0]],$AverageVecCurve);
    float $FloatDirMA[] = DirectionFN($AverageVecCurve,$CurveCollectVec[$NewIndexAi[0]]);
    float $LowestAngle = $angleZii[$NewIndexAi[0]];
    float $MiddleAngle = $angleZii[$NewIndexAi[$MidAngle]];
    float $HighestAngle = $angleZii[$NewIndexAi[`size($NewIndexAi)`-1]];
    float $AvAllangles = ($LowestAngle+$MiddleAngle+$HighestAngle)/3.0;
    float $eachAi;
    string $NewCurveE[] = `ls -sl`;
    vector $CurveCollectVec[];
    vector $MidVecDir = FloatToVec($FloatDirMA);
    vector $AveVec = FloatToVec($AverageVecCurve);
    vector $NewPvec;
    vector $ThreeEllipVecP[];
    vector $NewEllipesCurve[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CIrceP = `xform -q -ws -t $TestCurveC`;
    $AverageVecCurve =$CIrceP;

    clear $angleZii;  clear $CurveCollectVec;
    $CurveCollectVec = CurvatureUtility($TestCurveC, 3, $angleZii, $TrackC, $AddedCurvA);

    clear $NewIndexAi;
    $NewIndexAi  = SortNumbersIntIndex($angleZii);
    //##
    curve2points($CurveCollectVec[$NewIndexAi[0]],$AverageVecCurve);

    $DPiMidi = distance2Pts($CurveCollectVec[$NewIndexAi[0]],$AverageVecCurve);
    $FloatDirMA = DirectionFN($AverageVecCurve,$CurveCollectVec[$NewIndexAi[0]]);
    $MidVecDir = FloatToVec($FloatDirMA);
    $AveVec = FloatToVec($AverageVecCurve);
    $NewPvec = ($MidVecDir * $DPiMidi)+ $AveVec;
    // the three vectors needed to make the ellipse
    //$CurveCollectVec[$NewIndexAi[0]] , $NewPvec and any point one curve (close to first vec)
    $MidAngle = (`size($NewIndexAi)`-1)/2;
    $LowestAngle = $angleZii[$NewIndexAi[0]];
    $MiddleAngle = $angleZii[$NewIndexAi[$MidAngle]];
    $HighestAngle = $angleZii[$NewIndexAi[`size($NewIndexAi)`-1]];
    $AvAllangles = ($LowestAngle+$MiddleAngle+$HighestAngle)/3.0;
    $xc = 0;
    clear $findLowestGroup;
    for($eachAi in $angleZii){
    if($eachAi< $AvAllangles){
    $findLowestGroup[`size($findLowestGroup)`]=$xc;
    Loc  $CurveCollectVec[$xc];
    }
    $xc++;
    }

    $findLowestGroup = `sort $findLowestGroup`;
    $xc =0;
    for($eachInt in $findLowestGroup){
    if($xc>0){
    $Sub =$eachInt -$Pastint;
    if(($eachInt -$Pastint)> 3){
    $ChangeOver =  $Pastint;
    Loc  $CurveCollectVec[$ChangeOver];
    }
    }
    $Pastint = $eachInt;
    $xc++;
    }


    // the three vectors needed to make the ellipse
    //$CurveCollectVec[$NewIndexAi[0]] , $NewPvec and any point one curve (close to first vec)
    //$CurveCollectVec[$NewIndexAi[0]] , $NewPvec, $CurveCollectVec[$ChangeOver];

    $ThreeEllipVecP[0] = $CurveCollectVec[$NewIndexAi[0]] ;
    $ThreeEllipVecP[1] = $NewPvec;
    $ThreeEllipVecP[2] = $CurveCollectVec[$ChangeOver];

    $NewEllipesCurve = calculateEllipseCurve($ThreeEllipVecP, 300);
    $NewCurveE = `ls -sl`;
    $EmptyVectorArray = $NewEllipesCurve;

    return $NewCurveE[0];

}


/******************************************************************************
 * @procedure    Matrix4ToFloat
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $m : matrix[]
 *
 * @returns      float[]
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] Matrix4ToFloat(matrix $m[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MatrixPoints[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MatrixPoints = {($m[0][0]), ($m[0][1]), ($m[0][2]), ($m[0][3]),
    ($m[1][0]), ($m[1][1]), ($m[1][2]), ($m[1][3]),
    ($m[2][0]), ($m[2][1]), ($m[2][2]), ($m[2][3]),
    ($m[3][0]), ($m[3][1]), ($m[3][2]), ($m[3][3])};
    return $MatrixPoints;

}


/******************************************************************************
 * @procedure    CreatePairIntIndexEven
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $ArraySize : int
 *
 * @returns      int []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] CreatePairIntIndexEven(int $ArraySize)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iNdexi = 0;
    int $iNdex = 0;
    int $store;
    int $IntArrayInex[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $iNdexi = 0;
    $iNdex = 0;
    while($iNdex < $ArraySize){
    if($iNdexi == 0){
    $IntArrayInex[$iNdex] = $iNdex;
    $store =$iNdex;
    }
    if($iNdexi == 1){ $iNdexi = -1;
    $IntArrayInex[$iNdex] = $store;
    }
    $iNdexi++;
    $iNdex++;
    }
    return $IntArrayInex;

}


/******************************************************************************
 * @procedure    CreatePairIntIndex
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $AS : int
 *
 * @returns      int []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] CreatePairIntIndex(int $AS)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Ai = 0;
    int $Bi = 0;
    int $N = 0;
    int $store;
    int $IntA[];
    int $Times = $AS*2;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Ai = 0;
    $Bi = 0;
    $N = 0;
    $Times = $AS*2;
    while($Bi < $Times){
    if($Ai == 0){$IntA[$Bi] = $N;}
    if($Ai == 1){ $Ai = -1; $IntA[$Bi] = $N;
    $N++; }
    $Ai++;
    $Bi++;
    }
    return $IntA;

}


/******************************************************************************
 * @procedure    CreateIntIndexExpand
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $IndexArray : int[]
 *   $ExpandSize : int
 *
 * @returns      int []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] CreateIntIndexExpand(int $IndexArray[], int $ExpandSize)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IntArrayInex[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ($eachNumber in $IndexArray){
    for ($i=0;$i<$ExpandSize; $i++){
    $IntArrayInex[`size($IntArrayInex)`] = $eachNumber;
    }
    }
    return $IntArrayInex;

}


/******************************************************************************
 * @procedure    VecMultMatrix
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $PtsVec : vector
 *   $Matrix_m0 : matrix
 *
 * @returns      vector
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector VecMultMatrix(vector $PtsVec, matrix $Matrix_m0)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $New_Three_Pt_Vec = << $Matrix_m2[0][0], $Matrix_m2[0][1], $Matrix_m2[0][2] >>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    matrix $Matrix_m1[1][4]= << $PtsVec.x, $PtsVec.y, $PtsVec.z, 1 >>;
    matrix $Matrix_m2[1][4]= $Matrix_m1 * $Matrix_m0;
    $New_Three_Pt_Vec = << $Matrix_m2[0][0], $Matrix_m2[0][1], $Matrix_m2[0][2] >>;
    return $New_Three_Pt_Vec;

}


/******************************************************************************
 * @procedure    MatrixAddCol
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $mat : matrix[]
 *
 * @returns      vector
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector MatrixAddCol(matrix $mat[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $UVW = <<$uvwF[0],$uvwF[1],$uvwF[2] >>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $uvwF[0] = $mat[0][0]+$mat[1][0]+$mat[2][0]+$mat[3][0];
    $uvwF[1] = $mat[0][1]+$mat[1][1]+$mat[2][1]+$mat[3][1];
    $uvwF[2] = $mat[0][2]+$mat[1][2]+$mat[2][2]+$mat[3][2];
    $UVW = <<$uvwF[0],$uvwF[1],$uvwF[2] >>;
    return $UVW;

}


/******************************************************************************
 * @procedure    GetRotationVectorsMatrix
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $mAtRiX : matrix[]
 *
 * @returns      vector []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] GetRotationVectorsMatrix(matrix $mAtRiX[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MatrizFloatiA[];
    vector $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
    vector $VecR[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MatrizFloatiA = MatrixToFloat($mAtRiX);
    $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
    $VecR[0] = $VecAii;
    $VecAii = << $MatrizFloatiA[4], $MatrizFloatiA[5], $MatrizFloatiA[6]>>;
    $VecR[1] =$VecAii;
    $VecAii = << $MatrizFloatiA[8], $MatrizFloatiA[9], $MatrizFloatiA[10]>>;
    $VecR[2] = $VecAii;
    return $VecR;

}


/******************************************************************************
 * @procedure    MultPointMatrix
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $PtsVec : vector
 *   $mIA : matrix[]
 *
 * @returns      vector
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector MultPointMatrix(vector $PtsVec, matrix $mIA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MatrizFloatiA[] = MatrixToFloat($mIA);
    float $RowA[] = $VecR[0];
    float $RowB[] = $VecR[1];
    float $RowC[] = $VecR[2];
    float $GivenPoint[] = $PtsVec;
    float $NewPoint[];
    float $NewPointa[];
    float $NewPointb[];
    float $NewPtMatrixMult[];
    vector $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
    vector $VecR[];
    vector $ReturnValVec = FloatToVec($NewPoint);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    /*
    Given an input vector (a, b, c) and an input matrix:
    A B C D
    E F G H
    I J K L
    M N O P
    Then Vector Matrix Product is defined as follows:
    x = (a*A) + (b*B) + (c*C)
    y = (a*E) + (b*F) + (c*G)
    z = (a*I) + (b*J) + (c*K)
    And the Point Matrix Product is defined as follows:
    x = (a*A) + (b*B) + (c*C) + D
    y = (a*E) + (b*F) + (c*G) + H
    z = (a*I) + (b*J) + (c*K) + L
    */
    $MatrizFloatiA = MatrixToFloat($mIA);
    $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
    $VecR[0] = $VecAii;
    $VecAii = << $MatrizFloatiA[4], $MatrizFloatiA[5], $MatrizFloatiA[6]>>;
    $VecR[1] =$VecAii;
    $VecAii = << $MatrizFloatiA[8], $MatrizFloatiA[9], $MatrizFloatiA[10]>>;
    $VecR[2] = $VecAii;
    $RowA = $VecR[0];
    $RowB = $VecR[1];
    $RowC = $VecR[2];
    $GivenPoint = $PtsVec;
    $NewPoint = multiplyFloat($GivenPoint[0], $RowA);
    $NewPointa = multiplyFloat($GivenPoint[1], $RowB);
    $NewPointb = multiplyFloat($GivenPoint[2], $RowC);
    $NewPtMatrixMult = AddFloats($NewPoint, $NewPointa);
    $NewPtMatrixMult = AddFloats($NewPtMatrixMult, $NewPointb);
    $NewPoint[0] = (($RowA[0])*($GivenPoint[0])) + (($RowB[0])*$GivenPoint[1]) + (($RowC[0])*$GivenPoint[2]);
    $NewPoint[1] = (($RowA[1])*($GivenPoint[0])) + (($RowB[1])*$GivenPoint[1]) + (($RowC[1])*$GivenPoint[2]);
    $NewPoint[2] = (($RowA[2])*($GivenPoint[0])) + (($RowB[2])*$GivenPoint[1]) + (($RowC[2])*$GivenPoint[2]);
    $ReturnValVec = FloatToVec($NewPoint);
    return $ReturnValVec;

}


/******************************************************************************
 * @procedure    MultPointMatrixProduct
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $PtsVec : vector
 *   $mIA : matrix[]
 *
 * @returns      vector
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector MultPointMatrixProduct(vector $PtsVec, matrix $mIA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MatrizFloatiA[] = MatrixToFloat($mIA);
    float $RowA[] = $VecR[0];
    float $RowB[] = $VecR[1];
    float $RowC[] = $VecR[2];
    float $GivenPoint[] = $PtsVec;
    float $NewPoint[];
    float $NewPointa[];
    float $NewPointb[];
    float $NewPtMatrixMult[];
    vector $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
    vector $VecR[];
    vector $ReturnValVec = FloatToVec($NewPoint);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    /*
    Given an input vector (a, b, c) and an input matrix:
    A B C D
    E F G H
    I J K L
    M N O P
    Then Vector Matrix Product is defined as follows:
    x = (a*A) + (b*B) + (c*C)
    y = (a*E) + (b*F) + (c*G)
    z = (a*I) + (b*J) + (c*K)
    And the Point Matrix Product is defined as follows:
    x = (a*A) + (b*B) + (c*C) + D
    y = (a*E) + (b*F) + (c*G) + H
    z = (a*I) + (b*J) + (c*K) + L
    */
    $MatrizFloatiA = MatrixToFloat($mIA);
    $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
    $VecR[0] = $VecAii;
    $VecAii = << $MatrizFloatiA[4], $MatrizFloatiA[5], $MatrizFloatiA[6]>>;
    $VecR[1] =$VecAii;
    $VecAii = << $MatrizFloatiA[8], $MatrizFloatiA[9], $MatrizFloatiA[10]>>;
    $VecR[2] = $VecAii;
    $RowA = $VecR[0];
    $RowB = $VecR[1];
    $RowC = $VecR[2];
    $GivenPoint = $PtsVec;
    $NewPoint = multiplyFloat($GivenPoint[0], $RowA);
    $NewPointa = multiplyFloat($GivenPoint[1], $RowB);
    $NewPointb = multiplyFloat($GivenPoint[2], $RowC);
    $NewPtMatrixMult = AddFloats($NewPoint, $NewPointa);
    $NewPtMatrixMult = AddFloats($NewPtMatrixMult, $NewPointb);
    $NewPoint[0] = (($RowA[0])*($GivenPoint[0])) + (($RowB[0])*$GivenPoint[1]) + (($RowC[0])*$GivenPoint[2])+$MatrizFloatiA[3];
    $NewPoint[1] = (($RowA[1])*($GivenPoint[0])) + (($RowB[1])*$GivenPoint[1]) + (($RowC[1])*$GivenPoint[2])+$MatrizFloatiA[7];
    $NewPoint[2] = (($RowA[2])*($GivenPoint[0])) + (($RowB[2])*$GivenPoint[1]) + (($RowC[2])*$GivenPoint[2])+$MatrizFloatiA[11];
    $ReturnValVec = FloatToVec($NewPoint);
    return $ReturnValVec;

}


/******************************************************************************
 * @procedure    FloatToMatrix
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $v : float[]
 *
 * @returns      matrix
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix FloatToMatrix(float $v[])
{

    matrix $mat[4][4]=<<$v[0], $v[1], $v[2], $v[3];
    $v[4], $v[5], $v[6], $v[7];
    $v[8], $v[9], $v[10], $v[11];
    $v[12], $v[13], $v[14], $v[15]>>;
    return $mat;

}


/******************************************************************************
 * @procedure    MatrixToFloat
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $FourByFour_matrix : matrix[]
 *
 * @returns      float[]
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] MatrixToFloat(matrix $FourByFour_matrix[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $FLOATindex = 0;
    int $Inx = 0;
    int $Inxb = 0;
    float $matrixFloat[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $FLOATindex = 0;
    $Inx = 0;
    $Inxb = 0;
    for($Inx = 0; $Inx <= 3; $Inx++){
    for($Inxb = 0; $Inxb <= 3; $Inxb++){
    $matrixFloat[$FLOATindex] = $FourByFour_matrix[$Inx][$Inxb];
    $FLOATindex++;
    }
    }
    return $matrixFloat;

}


/******************************************************************************
 * @procedure    TwoPointMatrixPlusAxisWorld
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $PtsVec : vector[]
 *   $EmptyDirVector : vector[]
 *   $ZeroOne : int
 *
 * @returns      matrix
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix TwoPointMatrixPlusAxisWorld(vector $PtsVec[], vector $EmptyDirVector[], int $ZeroOne)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CombA = 0;
    int $CountIndexV = 0;
    float $MidPt[];
    float $CamDirVecNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $MatrizFloati[] = MatrixToFloat($mI);
    string $curveAxis = "";
    vector $Line_Y_zeroMain;
    vector $Dir_VecA;
    vector $eachPointVd;
    vector $DirLine = PositiveDirectionLine($PtsVec[0], $PtsVec[1]);
    vector $Vperp = crossProduct( $DirLine, $CamDirVecNormal, 0, 0 );
    vector $BInomalV = FloatToVec(MultLenToDirAddToPoint(2, $Vperp, $PtsVec[0]));
    vector $BInomalVDirLine = DirectionFN($PtsVec[0], $BInomalV);
    vector $TangentV = FloatToVec(MultLenToDirAddToPoint(4,$CamDirVecNormal, $PtsVec[0]));
    vector $norm = FloatToVec($CamDirVecNormal);
    vector $bi = $BInomalVDirLine;
    vector $tan = $DirLine;
    vector $bi_two = `cross $tan $norm`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Line_Y_zeroMain =FloatToVec (DirectionFN($PtsVec[0], $PtsVec[1]));
    $MidPt = MidPoint($PtsVec[0], $PtsVec[1]);
    $Line_Y_zeroMain = PositiveDirectionLine($PtsVec[0], $PtsVec[1]);
    $CombA = 0;
    $CountIndexV = 0;
    for ($eachPointVd in $PtsVec){
    $Dir_VecA = FloatToVec (DirectionFN($eachPointVd, $MidPt));
    $CombA = PointsEquivalentTol ($Dir_VecA, $Line_Y_zeroMain);
    if($CombA == 3){break;}else{
    $CountIndexV++;}
    }
    if($CountIndexV == 1){
    $PtsVec = ReverseVectorArray($PtsVec);
    }
    $CamDirVecNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $CamDirVecNormal= multiplyFloat(-1.0, $CamDirVecNormal);
    $DirLine = PositiveDirectionLine($PtsVec[0], $PtsVec[1]);
    $Vperp = crossProduct( $DirLine, $CamDirVecNormal, 0, 0 );
    $BInomalV = FloatToVec(MultLenToDirAddToPoint(2, $Vperp, $PtsVec[0]));
    $BInomalVDirLine = DirectionFN($PtsVec[0], $BInomalV);
    $BInomalV = FloatToVec(MultLenToDirAddToPoint(4, $BInomalVDirLine, $PtsVec[0]));
    $TangentV = FloatToVec(MultLenToDirAddToPoint(4,$CamDirVecNormal, $PtsVec[0]));
    // $BInomalVDirLine
    // $CamDirVecNormal
    // $DirLine
    $norm = FloatToVec($CamDirVecNormal);
    $bi = $BInomalVDirLine;
    $tan = $DirLine;
    matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    ///////////////////////////////////////###
    // I dont understand it //pretty weird
    $DirectionVector[0] =  $norm;
    $DirectionVector[1] =  $bi;
    $DirectionVector[2] =  $tan;
    $EmptyDirVector = $DirectionVector;
    /*
    $curveAxis = "";
    $curveAxis += makeCurvePointDirectionLength((6), $norm, $MidPt); //
    $curveAxis += makeCurvePointDirectionLength((6), $bi, $MidPt); //
    $curveAxis += makeCurvePointDirectionLength((6), $tan, $MidPt); //
    */
    $bi_two = `cross $tan $norm`;
    print (" bi_two : "+"\n");
    print $bi_two;
    print (" "+"\n");
    print (" bi : "+"\n");
    print $bi;
    print (" "+"\n");
    if($ZeroOne== 0){
    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
    ($bi.x), ($bi.y), ($bi.z),  0.0;     // Y axis
    ($tan.x), ($tan.y), ($tan.z), 0.0;     // Z axis
    0.0, 0.0, 0.0, 1.0  >>;  // Position
    }
    if($ZeroOne== 1){
    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
    ($bi.x), ($bi.y), ($bi.z),  0.0;     // Y axis
    ($tan.x), ($tan.y), ($tan.z), 0.0;     // Z axis
    $MidPt[0], $MidPt[1], $MidPt[2], 1.0  >>;  // Position
    }
    $mI = MatrixCleanNegZero($mI);
    $MatrizFloati = MatrixToFloat($mI);
    return $mI;

}


/******************************************************************************
 * @procedure    MatrixAxisTranlation
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $SVeci : vector
 *   $mIA : matrix
 *   $mIB : matrix
 *
 * @returns      vector
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector MatrixAxisTranlation(vector $SVeci, matrix $mIA, matrix $mIB)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CombA = 0;
    int $CombB = 0;
    int $CountN = 0;
    int $Time;
    int $sIZes = `size $FixVec `;
    int $NUmers[] = CreateIntIndex($sIZes);
    int $CreatedObjectCurve = `ISSelectedTypeCurve`;
    int $zeroOR1Z = `gmatch $nameB "*[C-c]urve*"`;
    int $scriptt_jobNumConnectionChanged = `scriptJob -conditionChange delete evalVectorIndexAdditionSubtract`;
    int $IndeXa = 0;
    int $rAngle = $angle;
    int $rX = $Qx*100;
    int $rY = $Qy*100;
    int $rZ = $Qz*100;
    int $MatrixNi = $MatrixN-1;
    int $BytNum[];
    int $BytNumSort[] = $BytNum;
    int $BytNumLarg = $BytNumSort[`size($BytNumSort)`-1];
    int $BytNumSmall = $BytNumSort[0];
    int $BytNumDiff[];
    int $IndXeF = 0;
    int $IndXeFi = 0;
    int $Xz = 0;
    int $iX = 0;
    int $count = 0;
    int $Low_X;
    int $TrackC[];
    int $NewIndex[];
    int $Xv = 0;
    int $TFNS = 1;
    int $IndexTrack[];
    int $TrueorFalseCircle = `IsCircle`;
    int $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);
    int $IfTrue;
    int $weighedtFindings = 0;
    int $weighedtFindingsZ = 0;
    int $weighedtFindingsN = 0;
    int $triggerStraitCRV = 0;
    int $Trueii = 0;
    int $iia = 0;
    int $AllLocsi[] = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    int $New_AllLocs_A[];
    int $Near_index_A = $New_AllLocs_A[0];
    int $New_AllLocs_B[];
    int $Near_index_B = $New_AllLocs_B[0];
    int $triggerNoTrans = 0;
    int $iiz = 0;
    int $colori[];
    int $numIparms = size($intersections1);
    int $TF = 0;
    int $CurveIndexInter[];
    int $NodeCurveIndex[] = CreateCrvInterTF($CurveItemZai, $PlaneCurveS,0,0.001,$interVecA, $interVecB);
    int $COuntN = 0;
    int $foundN[];
    int $Number = 0;
    int $CollectN_index[];
    int $COLLECT_INDEX[];
    int $COLLECTN_INDEX[];
    int $COLLECT_Wanted_INDEX[];
    int $Cni = 0;
    int $Cnii = 0;
    int $AllM[];
    int $ExistingIntA[];
    int $COLLECT_INDEX_M[];
    int $eachIntE;
    int $Cniim = 0;
    int $NodeCurveIndexi[];
    int $CountPara = 0;
    int $ParaSize[];
    int $CurveSFoundS = `size($NodeCurveIndexi)`;
    int $PointOnCrvIND[] = CreateIntIndex(`size($VecPointOnCrv)`);
    int $New_PointOnCrvIND_A[];
    int $FOUNDc = $New_PointOnCrvIND_A[0];
    int $WhatCurve;
    int $CountWhatCurve = -1;
    int $CountParab = 0;
    int $ParaSizeb[];
    int $CurveSFoundSb = `size($NodeCurveIndex)`;
    int $PointOnCrvINDb[] = CreateIntIndex(`size($VecPointOnCrvb)`);
    int $New_PointOnCrvIND_Ab[];
    int $FOUNDcb = $New_PointOnCrvIND_Ab[0];
    int $WhatCurveb;
    int $CountWhatCurveb = -1;
    int $pX = equivalentTol($posA[0], $posB[0],  0.001);
    int $pY = equivalentTol($posA[1], $posB[1],  0.001);
    int $pZ = equivalentTol($posA[2], $posB[2],  0.001);
    int $addedResults = $pX + $pY + $pZ;
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 4 );
    int $FindSteps;
    int $StepZNum = $numLength;
    int $MasterCount = 0;
    int $Par = 0;
    int $ii = 0;
    int $CountSteps;
    int $NewIndexN[];
    int $TwoNew[];
    int $iNdex = 0;
    int $returnValue = 1;
    int $vi = 0;
    int $Trigger = 0;
    int $Lowest = 11110;
    int $Past = 0;
    int $CountEVEN = 0;
    int $Even_Odd;
    int $Count = 0;
    int $CountP = 0;
    int $Size = size($x0);
    int $evenOdd = fmod($sIZes, 2);
    int $sIZesHalf = (($sIZes)/2)+1;
    int $countN = 0;
    int $CountVV = 0;
    int $index[] = CreateIntIndex(3);
    int $isOrthoTrueZi = 0;
    int $triggerNoTransENDA = 0;
    int $triggerNoTransENDB = 0;
    int $First_Second_Both_None = 0;
    int $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
    int $TrackAllExisting3DCrv[] = CreatePairIntIndex($SizeCrvi);
    int $SizeCrvR = `size($LayerCurvesRangeA)`;
    int $Cn = 0;
    int $triggerNoTransA = 0;
    int $triggerNoTransB = 0;
    int $trigger_straitC = 0;
    int $iis = 0;
    int $ConnectedEnds = $triggerNoTransENDA + $triggerNoTransENDB;
    int $AddAB = $triggerNoTransA+$triggerNoTransB;
    int $New_AllLocs_AB[];
    int $PairInt[];
    int $EndsAtZero = isCurveEndAtZY($EndrEndsa);
    int $STEPSZ = 200;
    int $LowX;
    int $NewArrayAEllipZ[] = NewVecOrderEllipZ($NewOneCurveS, $EmptyVectorArrayA, $MidEpipolPosFCam);
    int $NewArrayBEllipZ[] = NewVecOrderEllipZ($NewOneCurveSB, $EmptyVectorArrayB, $MidEpipolPosFCam);
    int $IndexTrackE[];
    int $TwoZeroOne[] = {0,1};
    int $TFmostRArray[];
    int $LargestIntR_KEY[];
    int $LargestIntL_KEY[];
    int $COUNT_Nlr = 0;
    int $LargestIntR[] = SortNumbersIntIndex($AllAngiX_RIGHT);
    int $LargestIntL[] = SortNumbersIntIndex($AllAngiX_LEFT);
    int $SizeE = `size($EmptyVectorArrayA)`;
    int $NewArrayInt;
    int $NewArrayIntX[];
    int $Add = 0;
    int $edgeZsetA;
    int $edgeZsetB;
    int $ReducedIndexA[] = floatArrayCountDuplicates($distancesEachToCurve);
    int $ReducedIndexB[] = floatArrayCountDuplicates($distancesEachToCurveB);
    int $NearestInt[] = SortNumbersIntIndex($distAz);
    int $NearestIntB[] = SortNumbersIntIndex($distBz);
    int $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    int $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];
    int $NearestIndex;
    int $NearestIndexEach;
    int $ReducedIndexXAB[];
    int $AxisOrthoLineA = $AxisOrthoLine;
    int $iVc = 0;
    int $TrackFoundN[];
    int $TrackN[];
    int $TwoPointsi[];
    int $AXIS = $AxisOrthoLineA;
    int $ALLlikeness[];
    int $ALLlikenessForce[];
    int $TriggerPoints;
    int $SortedForce[];
    int $Sorted[] = SortNumbersIntIndex($distTo3DCurveEnd);
    int $ReducedIndex[] = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    int $OntheSameLine = 0;
    int $AddInt = $AdditR;
    int $Xi = 0;
    int $NumberE[];
    int $NoneDup[];
    int $ixX = 0;
    int $len = size( $list );
    int $indexAx[] = CreateIntIndex(6);
    int $indexAxNew[] = ArrayToIntList( $BestThree);
    int $color;
    int $iiX = 0;
    int $Cindex = 0;
    int $IndexZ = $indexAxNew[$Count];
    int $triggerMiddle = 0;
    int $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
    int $iv = -1;
    int $CRV_index_number = 0;
    int $CRc = 0;
    int $CRcT = 0;
    int $EDGEpoints[];
    int $pointNearEdgeCurve[];
    int $SnappingVector = 0;
    int $OneIsNotNearThePlane = 0;
    int $Sortedi[] = SortNumbersIntIndex($distancesTo3DCurveEndi);
    int $C1;
    float $TransL[];
    float $SCale = $mIB[3][3];
    float $DistToPlane[];
    float $XYZs[];
    float $TransLb[];
    float $NewPos[] = AddFloats($TransLb, $NewAXis);
    float $pAv[] = AverageVectorPoint($Vec);
    float $n[] = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    float $DistanceLoc = distance2Pts(  $Veciiv, $pAv);
    float $MultDirCam[] = multiplyFloat($DistanceLoc, $n);
    float $FloatDirectionCamNormalA[] = AddFloats($pAv, $MultDirCam);
    float $PointN[] = ClosestPoint2LineVec($n, $pAv, $Veciiv);
    float $FloatDirectionAi[] = DirectionFN($pAv,$PointN);
    float $MultDirPC1[] = multiplyFloat($DistanceLoc, $FloatDirectionAi);
    float $AddMultMiiF[] = AddFloats($Veciiv, $MultDirPC1);
    float $LengthA = distance2Pts ($VecPairA[0], $VecPairA[1]);
    float $LengthB = distance2Pts ($VecPairB[0], $VecPairB[1]);
    float $LengthAB;
    float $Sign_F;
    float $MatrixFB[] = MatrixToFloat($matrixB);
    float $AddMepi[];
    float $ni;
    float $valuesBi[] = $eachVeCx;
    float $EulerAngleA[] = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
    float $x = $oneItemFLoats[0];
    float $y = $oneItemFLoats[1];
    float $z = $oneItemFLoats[2];
    float $normal[] = $bi;
    float $p[] = AverageVectorPoint($SelectVec);
    float $d = $normal[0] * $p[0] + $normal[1] * $p[1] + $normal[2] * $p[2];
    float $dist = $x * $normal[0] + $y * $normal[1] + $z * $normal[2] - $d;
    float $LivePlanePosX[];
    float $MirrorF[] = MirrorPointFrom3PointPlane( PointArrayT(`ls -sl`), $LivePlanePosX);
    float $Zx[] = $eachVecEp;
    float $Pi = 3.1415926535;
    float $pi = 3.1415926535;
    float $CamPos1[];
    float $LivePlanePos[];
    float $CamerasDirectionVectorNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
    float $FloatDirectionA[] = DirectionFN($CamPos1, $LocPos1);
    float $DistanceLocA = $DistanceLoc;
    float $FloatDirectionCamNormal[] = AddFloats($CamPos1, $MultDirPC1);
    float $CamerasDirectionVectorA[] = DirectionFN($FloatDirectionCamNormal, $CamPos1);
    float $MultDirPC1A[] = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
    float $p1[] = $CamPos1;
    float $p2[] = $LocPos1;
    float $p3[] = $FloatDirectionCamNormal;
    float $center[];
    float $FloatPosZero[] = {0, 0, 0};
    float $FloatDirection[] = DirectionFN($FloatPosZero, $normal);
    float $FloatDirPerpCenterC[] = DirectionFN($center,$mid2);
    float $FloatDirPointAC[] = DirectionFN($p1, $p3);
    float $center8[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    float $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
    float $FloatDirLocToPerpIntersect[] = DirectionFN($center8,$p2);
    float $OnPlane[] = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $UnitDirection[] = $vectorUnit;
    float $u = $xi - $x;
    float $w = $zi - $z;
    float $e = 1;
    float $Y = $u/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    float $U = $v/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    float $V = $w/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    float $newF[];
    float $a = 7.5;
    float $b = 3.4;
    float $c = 5.3;
    float $t1 = ((2*$a*$a*$a) - (9*$a*$b) +(27*$c));
    float $t2 = ((-$a*$a) + (3*$b));
    float $t3 = $t1*$t1 + 4*$t2*$t2*$t2;
    float $t4 = ((-$t1 + (`sqrt $t3`))/54);
    float $t41 = ((-$t1 - (`sqrt $t3`))/54);
    float $t5 = ((-$a*$a) + (3*$b));
    float $t6 = `sqrt($t1*$t1 + (4*$t5*$t5*$t5))`;
    float $t7 = ((-$t1 - $t6)/54);
    float $TimesOne = 1.0;
    float $N = 1;
    float $Ni = 1;
    float $valueA;
    float $valueB;
    float $valueC;
    float $valueD;
    float $valueE;
    float $valueF;
    float $valueG;
    float $value = $valueA - $valueB - $valueC - $valueD - $valueE - $valueF - $valueG;
    float $ParamX;
    float $ParamY;
    float $ParamZ;
    float $cx;
    float $cy;
    float $cz;
    float $sx;
    float $sy;
    float $sz;
    float $cycz;
    float $sysz;
    float $sycz;
    float $cysz;
    float $Qx;
    float $Qy;
    float $Qz;
    float $Qw;
    float $l;
    float $Nin = 1;
    float $Niin = 1;
    float $DirAB[] = DirectionF ($PosA, $PosB);
    float $DirCD[] = DirectionF ($PosC, $PosD);
    float $locsA[] = lineIntersection($PosA, $DirAB, $PosC, $DirCD);
    float $result[];
    float $FLoatMatrixA[] = MatrixToFloat($MatriXM);
    float $MatrixA[] = `MatrixToFloat($m)`;
    float $MatrixB[] = `MatrixToFloat($m2)`;
    float $DividedFLoats[];
    float $FLoatPointA[] = pointMatrixMult( $point, $MatrixB );
    float $CleanFLoats[];
    float $Arc = `arclen $CurveItemZai[0]`;
    float $angleZi[];
    float $TotalDegi;
    float $Ellipes_A[];
    float $CamPos_A[];
    float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;
    float $MidEpipolZx[] = MidPoint($CamPos_M, $CamPos_A);
    float $MidEpipolPosFCam[] = FloatPointsToCamPlane($MidEpipolZx);
    float $AngleX[];
    float $angleA;
    float $AngleB[] = EulerAngB((DirectionFN($vecA, $vecB)), (DirectionFN($vecC, $vecD)));
    float $AverageVecCurve[] = AverageVectorPoint($PositionsZ_A);
    float $CamDirVecNormalA[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $CamPlane1[];
    float $CamDirVecNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $CamNormM[] = ` MirrorFloatXYZ 0 $MultDirCam`;
    float $EpipolPosCamM[] = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;
    float $MidPosFCam[] = $CamPlane1;
    float $FloatDirEpipol[] = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    float $FloatDirEpipolB[] = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
    float $EpipolXx[] = {0.0,$CamPos_A[1],$CamPos_A[2]};
    float $PlaneEpipolXx[] = FloatPointsToCamPlane( $EpipolXx);
    float $EpipolYx[] = {$CamPos_A[0],0.0,$CamPos_A[2]};
    float $PlaneEpipolYx[] = FloatPointsToCamPlane( $EpipolYx);
    float $EpipolZx[] = {$CamPos_A[0],$CamPos_A[1],0.0};
    float $PlaneEpipolZx[] = FloatPointsToCamPlane( $EpipolZx);
    float $DistTOEpipol_CurEndA;
    float $DistTOEpipol_CurEndB;
    float $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
    float $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
    float $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;
    float $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    float $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
    float $BCDiff = abs($BCurEndB - $BCurEndBNN);
    float $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd;
    float $BCDiffi = abs($BCurEndB - $BCurEndBNNi);
    float $FloatDirEndPtsA[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
    float $EulerAngle_A = $EulerAngleA[3];
    float $FloatDirEndPtsB[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
    float $EulerAngleB[] = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);
    float $EulerAngle_B = $EulerAngleB[3];
    float $FloatDirEndPtsAi[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
    float $EulerAngleAi[] = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);
    float $EulerAngle_Ai = $EulerAngleAi[3];
    float $FloatDirEndPtsBi[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
    float $EulerAngleBi[] = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);
    float $EulerAngle_Bi = $EulerAngleBi[3];
    float $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
    float $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;
    float $LengCRV_a = `arclen $CurveItemZai`;
    float $DistEndsi;
    float $PerDiff = percent_of( $LengCRV_a, $DistEndsi);
    float $LengCRV_b = `arclen $CurveItemZbi`;
    float $DistEndsii;
    float $PerDiffii = percent_of( $LengCRV_b, $DistEndsii);
    float $PerDiffSum = ($PerDiff+$PerDiffii)/2.0;
    float $DDirEpipol[] = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
    float $MidCurveA[] = MidPoint($VecCurEndsa[0], $VecCurEndsa[1]);
    float $MidCurveB[] = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);
    float $AngleXi;
    float $DDirEpipolB[] = DirectionFN($MidCurveB, $FoundEpipol);
    float $DDirEpipolA[] = DirectionFN($FoundEpipol,$MidCurveB);
    float $PointToCamDir[];
    float $PointsClos[];
    float $distToCurveE_A[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[0]);
    float $newOrdersZA[] = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    float $Distance_A = $distToCurveE_A[$Near_index_A];
    float $Found_pt_A[] = $LocCurveEndsVec3D[$Near_index_A];
    float $newOrdersZAM[] = $Found_pt_A;
    float $distToCurveE_B[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[1]);
    float $newOrdersZB[] = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    float $Distance_B = $distToCurveE_B[$Near_index_B];
    float $Found_pt_B[] = $LocCurveEndsVec3D[$Near_index_B];
    float $newOrdersZBM[] = $Found_pt_B;
    float $distToPlaneLoc[];
    float $intersectionsA[];
    float $intersections1A[];
    float $intersections1B[];
    float $interVecA[];
    float $interVecB[];
    float $intersectposA[];
    float $newOrderVec[];
    float $eachFloat;
    float $ThreeFs[];
    float $OffsetTol = 1.0005;
    float $Distance_Aii;
    float $VEcF[];
    float $EveryPara[];
    float $EachPara;
    float $posA[];
    float $ParaFloat[];
    float $distCA[] = ArrayDistancesVecTofloat($VecPointOnCrv, $UnconnectedEnds[1]);
    float $newCA[] = SortFloatArrayAndString($distCA, $PointOnCrv_String, $EmptyCA);
    float $NearestDistCA = $distCA[$New_PointOnCrvIND_A[0]];
    float $EveryParab[];
    float $EachParab;
    float $posAb[];
    float $ParaFloatb[];
    float $distCAb[] = ArrayDistancesVecTofloat($VecPointOnCrvb, $UnconnectedEnds[0]);
    float $newCAb[] = SortFloatArrayAndString($distCAb, $PointOnCrv_Stringb, $EmptyCAb);
    float $NearestDistCAb = $distCA[$New_PointOnCrvIND_Ab[0]];
    float $PointBc[] = $CUT_CrvIntersectMirrorEnds_A[0];
    float $uParam = `closestPointOnCurve -ip $PointBc[0] $PointBc[1] $PointBc[2] -q -paramU $newNamesCB`;
    float $interposA[];
    float $interposB[];
    float $Addit[] = $VecLineDirM;
    float $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    float $MultDirOne[] = multiplyFloat(1.0, $DirectionLineF);
    float $AddMultF[] = AddFloats($PointOnLine, $MultDirOne);
    float $FDirNorA[] = Normal3Points($PointOnLine, $AddMultF, $PointN);
    float $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    float $MultDirMx[] = multiplyFloat($DistToLineSTart, $FDirNorA);
    float $AddMultMiiFx[] = AddFloats($PointOnLine, $MultDirMx);
    float $FDirNorB[] = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);
    float $MultDirMxz[] = multiplyFloat($DistToLineSTart,  $FDirNorB);
    float $AddMultMiiFxz[] = AddFloats($PointOnLine, $MultDirMxz);
    float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    float $CircleCenter[] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureCenter")`;
    float $step = $numEPrealNum2;
    float $curveMin = $curveM;
    float $numLength = (`arclen $Newcurvez`) +1;
    float $values[];
    float $MultDirA[] = multiplyFloat(($Length/2.0),  $Direction);
    float $DirectionN[];
    float $MultDirB[] = multiplyFloat(($Length/2.0),  $DirectionN);
    float $FDirA[] = AddFloats($posA, $MultDirA);
    float $FDirB[] = AddFloats($posA, $MultDirB);
    float $CRVRadi[];
    float $CIrceP[];
    float $DistanceS[];
    float $point1[] = FloatToVec($Vecs[0]);
    float $point2[] = FloatToVec($Vecs[1]);
    float $point3[] = FloatToVec($Vecs[2]);
    float $normalA[] = `unit ($normalV[0])`;
    float $normalB[] = `unit ($normalV[1])`;
    float $normalAAdd = $normalA[0] + $normalA[1];
    float $normalAAdd2 = $normalB[0] + $normalB[1];
    float $FArrayInex[];
    float $AddF = 0;
    float $Lengthi = distance2Pts ($FixVeci[0], $FixVeci[1]);
    float $MidPt[] = MidPoint($FixVeci[0], $FixVeci[1]);
    float $FloatDirMajor[] = DirectionFN($FixVeci[0], $FixVeci[1]);
    float $Lengthiii = distance2Pts ($MidPt, $FixVeci[2]);
    float $FDirNorAi[] = Normal3Points($FixVeci[0], $FixVeci[1], $FixVeci[2]);
    float $LENGTH = $Lengthi/2.0;
    float $C_radius[] = Circle3PtsM($ABC[0], $ABC[1], $ABC[2]);
    float $ObjsCirclesRad = $C_radius[3];
    float $Di = distance2Pts( $MidVec , $PointN);
    float $DiffL = ($ObjsCirclesRad-$Di)*2.0;
    float $PointNii[];
    float $PointNiii[];
    float $PointNiiiB[];
    float $FloatDirXn[] = DirectionFN( $MidVec, $FixVeci[2]);
    float $DistAddiR2 = $Di*2.0;
    float $HightD = sqrt (abs ((`pow $Di 2`) - (`pow $ObjsCirclesRad 2`)));
    float $DiX = distance2Pts( $FixVeci[2] , $PointNiii);
    float $DiY = distance2Pts( $FixVeci[2] , $PointNiiiB);
    float $ClosestPoint[];
    float $RadiOfOuter = distance2Pts($MidVec, $ClosestPoint);
    float $DirRaytoIntersectC[];
    float $CircleRayPointN[];
    float $SecondIntersectCsmall[] = lineIntersection( $MidVec, $DirRaytoIntersectC, $FixVeci[2], $norm);
    float $RadiOfInnerC = distance2Pts($MidVec,$SecondIntersectCsmall);
    float $MatrizFloati[] = MatrixToFloat($mI);
    float $angle = 0;
    float $points[];
    float $newLocP[];
    float $VecAngle = VAnglesofThreeVec($MidPt, $FixVeci[1], $FixVeci[2]);
    float $beta = `deg_to_rad ($angle)`;
    float $sinbeta = sin($beta);
    float $cosbeta = cos($beta);
    float $valuesiiA[] = {$x,0.0,$y};
    float $valuesiAi[] = {$x, 0, $y};
    float $i;
    float $X = $x + ($a * $cosalpha * $cosbeta - $b * $sinalpha * $sinbeta);
    float $valuesA[] = {$X, 0, $Y};
    float $MidTwoDtoElPoint = distance2Pts ($valuesiiA, $valuesA);
    float $FloatDirEpoint[] = DirectionFN($valuesiiA, $valuesA);
    float $MultDii[] = multiplyFloat($MidTwoDtoElPoint, $newLocP);
    float $CN[];
    float $StepCycle = 0;
    float $pastA = 0.0;
    float $AddAngles = 0.0;
    float $allAngiX[];
    float $Ct[];
    float $DistancesCycle[];
    float $AngleNine = $AngleB[3];
    float $FXiI = $StepCycle;
    float $Fnumbers = 100.0/$FXiI;
    float $floatZ[];
    float $Sum;
    float $Result;
    float $Output;
    float $Correction;
    float $Error;
    float $S = (1.0/(1.0+`exp(-$x)`));
    float $Vt[];
    float $Ix = 0;
    float $AddAll = 0;
    float $Divide = $AddAll/$Ix;
    float $Fx = 0.0;
    float $DiffMathA;
    float $ZO[];
    float $PastF;
    float $ThresholdX = 1.5;
    float $FloatDirA[];
    float $Anglei;
    float $SnapR = 1.55;
    float $Smooth = 398;
    float $DiffMathB = $DistEndsii / ($LengCRV_b/100.0);
    float $DistToIntersectTOnear[];
    float $distToPlaneLoc3D[];
    float $DiffMathAm = $DistToIntersectTOnear[2]/ ($distToPlaneLoc3D[2]/100.0);
    float $DiffMathBm = $DistToIntersectTOnear[3] / ($distToPlaneLoc3D[3]/100.0);
    float $relativeDistanceA = ($DiffMathA+$DiffMathAm)/2.0;
    float $relativeDistanceB = ( $DiffMathB+$DiffMathBm)/2.0;
    float $relativeDistanceAi = ($Distance_A+$distToPlaneLoc[0])/2.0;
    float $relativeDistanceBi = ($Distance_B+$distToPlaneLoc[1])/2.0;
    float $relativeDistanceAZ = distance2Pts($VecOnPlaneA[0], $PointsA[0]);
    float $relativeDistanceBZ = distance2Pts($VecOnPlaneB[0], $PointsB[0]);
    float $DiffMathAi = $relativeDistanceAi/ ($relativeDistanceAZ/100.0);
    float $DiffMathBi = $relativeDistanceBi / ($relativeDistanceBZ/100.0);
    float $TimesMathAi = $relativeDistanceA*$relativeDistanceAZ/ ($distToPlaneLoc3D[0]/100.0);
    float $TimesMathBi = $relativeDistanceB*$relativeDistanceBZ/ ($distToPlaneLoc3D[1]/100.0);
    float $distToCurveE_AB[];
    float $lineEPointA[] = MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);
    float $Point3DA[] = $Intersect_LineB_a;
    float $Point3DAM[] = {($Point3DA[0]*-1), $Point3DA[1],$Point3DA[2]};
    float $TotalDegii[];
    float $TrackCi[];
    float $anglesMade[];
    float $EllipesPos_A[];
    float $DIff;
    float $AllAngiX_RIGHT[];
    float $AllAngiX_LEFT[];
    float $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    float $distancesEachToCurve[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    float $distancesEachToCurveB[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    float $distAz[];
    float $distBz[];
    float $FPointN_LineC[];
    float $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);
    float $XY[];
    float $XYZi[];
    float $XYZadd[];
    float $Xd;
    float $Yd;
    float $Zd;
    float $All_X[];
    float $All_Y[];
    float $All_Z[];
    float $All_ZYX[];
    float $All_ZYXDiff[];
    float $diffXYZ;
    float $Dist_3DNear = (($Dist_3D/3.0)*2.0);
    float $newOrderFloat;
    float $distTo3DCurveEnd[] = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    float $SdistTo3DCurveEnd[];
    float $Additi[];
    float $AdditiB[];
    float $AdditRi;
    float $AdditRiX;
    float $DistSnap;
    float $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    float $list[] = $listX;
    float $listItem;
    float $DistToPoint = distance2Pts($Pos_A, $VecLoc);
    float $SnapD = 0.003;
    float $MultDirForWard[] = multiplyFloat(-1, $CamerasDirectionVector);
    float $DirectionVectorXn[] = {-2,0,0};
    float $DirectionVectorX[] = {2,0,0};
    float $DirectionVectorY[] = {0,-2,0};
    float $DirectionVectorYn[] = {0,2,0};
    float $DirectionVectorZn[] = {0,0,-2};
    float $DirectionVectorZ[] = {0,0,2};
    float $FloatPointDirectionXn[] = AddFloats($CamPos1, $DirectionVectorXn);
    float $FloatPointDirectionX[] = AddFloats($CamPos1, $DirectionVectorX);
    float $FloatPointDirectionY[] = AddFloats($CamPos1, $DirectionVectorY);
    float $FloatPointDirectionYn[] = AddFloats($CamPos1, $DirectionVectorYn);
    float $FloatPointDirectionZn[] = AddFloats($CamPos1, $DirectionVectorZn);
    float $FloatPointDirectionZ[] = AddFloats($CamPos1, $DirectionVectorZ);
    float $AverageVecXYZsOnP[] = AverageVectorPoint($VecXYZsOnPlane);
    float $AnglesAll[];
    float $ANgnew[] = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
    float $AverageVecCurEndsP[] = AverageVectorPoint($VecCurEnds);
    float $FloatPointDirectionZniY[];
    float $CurveDirectionZiY[];
    float $FloatPointDirectionZniiY[];
    float $CurveDirectionZiiY[];
    float $CurvePsD[] = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
    float $FloatPointDirectVpoint[];
    float $CurveDirectionVpoint[];
    float $locsAi[] = lineIntersection($VecCurEnds[1], $CurveDirectionZiY, $VecCurEnds[0],  $CurveDirectionZiiY);
    float $IntersectEnds_Ai[];
    float $IntersectEnds_Bi[];
    float $distsA = $NdistA;
    float $distsB = $NdistB;
    float $ThreepointVecs[];
    float $EdgeDist;
    float $smallestDistance;
    float $distancesTo3DCurveEnd[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
    float $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
    float $distancesTo3DCurveEndi[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
    float $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
    float $XX = $VecA.x;
    float $XXX = $VecB.x;
    string $curvei = "curve -d 1";
    string $xyz[] = {"x", "y", "z"};
    string $command = ("\$ni ="+"$v"+"."+$xyz[$ZeroOneTwo]);
    string $K = "";
    string $curve = "curve -d 1";
    string $Newcurvez = `eval($curve)`;
    string $newPlaneCurve = VecArrayToCurve($AllPlaneLocPositionZ);
    string $itemOne[] = `ls -sl`;
    string $newCurvei = VecArrayToCurve($AllPlaneLocs);
    string $C[];
    string $nametypeZi;
    string $nameA;
    string $nameB;
    string $CurveItemZ[] = `ls -sl`;
    string $ObjectSel[] = `ls -sl`;
    string $attr = $object +".worldMatrix";
    string $multNode;
    string $stringFloat[] = FloatArrayToStringArray($FLoatMatrixA);
    string $Syb = " ";
    string $printcommand = "";
    string $AddedSPaces = AddItemString($BytNumDiff[$IndXeF], $Syb);
    string $AddItem = "";
    string $itemD[] = `duplicate -rr $item`;
    string $CurveItemZai[];
    string $curvesZi = $CurveItemZai[0];
    string $TestCurveC;
    string $OneCurve[] = `ls -sl`;
    string $OneCurveS = $OneCurve[0];
    string $CurveNS;
    string $NewOneCurveS;
    string $PCurvesName = "Plane";
    string $Combine;
    string $PlaneCurvA[];
    string $LayerCurvesRangeA[] = `queryLayerRangeMembers`;
    string $newCircle[] = `MakeCIRCLE($StereoCurveZ)`;
    string $CurveItemZbi = $StereoCurveZ[1];
    string $queryLocCurveEnds3D[];
    string $AllLocs_String[] = IntArrayToStringArray($AllLocsi);
    string $EmptyStringNewOrderA[];
    string $EmptyStringNewOrderB[];
    string $NewFoundLocs[];
    string $arrayCurvesNear[];
    string $AllCirTemp[];
    string $CirTemp[];
    string $ThefirstCurve = VecArrayToCurve($Intersect_A);
    string $ThefirstCurvei = VecArrayToCurve($Intersect_B);
    string $intersectNode = `createNode curveIntersect`;
    string $curveIntersectZ = "";
    string $buffer[];
    string $param = eval("paramLocator "+ $TwoCurveA[1] + ".u[" + $buffer[7] + "]");
    string $paramANDCurve[];
    string $curvesZ[];
    string $FloatSTRING[] = FloatArrayToStringArray($intersections1A);
    string $Ax = stringArrayToString($FloatSTRING, " ");
    string $Axi = stringArrayToString($FloatSTRING, " ");
    string $SortedRangeCrv[];
    string $newNames;
    string $ExpandedStringi[];
    string $ExpandedStringiS[];
    string $ExpandedStringii[];
    string $ExpandedStringiiS[];
    string $diff[] = stringArrayRemoveDuplicates($ExpandedStringi);
    string $diffS[] = stringArrayRemoveDuplicates($ExpandedStringiS);
    string $arrayCurvesNearABM[];
    string $arrayCurvesNearS[];
    string $ExpandedStringiim[];
    string $diffB[] = stringArrayRemoveExact($arrayCurvesNearABM, $diff);
    string $diffB_s[] = stringArrayRemoveExact($arrayCurvesNearS, $diffS);
    string $interVecAx[];
    string $interVecAy[];
    string $CURVEiA[];
    string $PointOnCrv_String[] = IntArrayToStringArray($PointOnCrvIND);
    string $EmptyCA[];
    string $CURVEiAb[];
    string $paramb;
    string $PointOnCrv_Stringb[] = IntArrayToStringArray($PointOnCrvINDb);
    string $EmptyCAb[];
    string $CurveA = $diffB[$NodeCurveIndexi[$WhatCurve]];
    string $CurveB = $diffB[$NodeCurveIndex[$WhatCurveb]];
    string $newNamesCA = $CurveA;
    string $newNamesCB = $CurveB;
    string $selectionItemB = $CurveB + ".u[" +$uParam+ "]";
    string $selectionItemA = $CurveA + ".u[" +$uParam+ "]";
    string $detachCurve1[] = `detachCurve -ch off - replaceOriginal on $selectionItemB`;
    string $detachCurve2[] = `detachCurve -ch off - replaceOriginal on $selectionItemA`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size  ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`;
    string $Newcurve[] = {$Newcurvez};
    string $circlesZ[];
    string $CurveBetween;
    string $ThreePoints[] = { "0", "1", "2"};
    string $curveA = "curve -d 1";
    string $curveB = "curve -d 1";
    string $NewcurvezA = `eval($curveA)`;
    string $NewcurvezB = `eval($curveB)`;
    string $NewcurvezAB[];
    string $stringF[];
    string $EmptyIndx[];
    string $stringIndTr[] = IntArrayToStringArray($index);
    string $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    string $ExpandedString[];
    string $arrayCurvesNearA[];
    string $arrayCurvesNearB[];
    string $curvesZii = $ThefirstCurvei;
    string $NewOneCurveSB;
    string $StereoCircle[] = Eval3DCircleStereo( $NewArrayBEllipZ  , $EmptyVectorArrayB ,  $NewArrayAEllipZ , $EmptyVectorArrayA );
    string $queryLocCurveEnds[] = queryLocOnLivePlaneBLayer();
    string $queryLocCurveEndsOLD[] = $queryLocCurveEnds;
    string $NearCurvesEnds[];
    string $BothCurves[];
    string $LocA = $queryLocCurveEnds[$NearestInt[0]];
    string $LocB = $queryLocCurveEnds[$NearestIntB[0]];
    string $LocName;
    string $Loc_AorB = "";
    string $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    string $AllarrayCurvesNear[];
    string $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    string $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    string $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    string $CurvesV[];
    string $LocsV[];
    string $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    string $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    string $VanishingLOC[];
    string $DirectionsZ[] = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    string $Alll = "";
    string $AllStrings[];
    string $EmptyIndxNewOrder[];
    string $BestThree[];
    string $CirTempi[] = `ls -sl`;
    string $newCurveii;
    string $CurveAv[];
    string $newNamesResultA1;
    string $ThreeDCurvesNear[];
    string $CurveItemAa[];
    string $StringAllNearA[];
    string $newNamesResultAx = substituteAllString($newNames, "Plane", "");
    string $arrayCurvesNearA1[];
    string $SetCol = `setAttr ($VanishingLOC[size($VanishingLOC)-1]+".overrideColor ") 6 `;
    string $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    string $LocNames[];
    string $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
    vector $VecROne[] = GetRotationVectorsMatrix($mIA );
    vector $tranSVec = << $TransL[0], $TransL[1], $TransL[2]>>;
    vector $tranSVecA = $VecROne[0]+$tranSVec;
    vector $tranSVecB = $VecROne[1]+$tranSVec;
    vector $tranSVecC = $VecROne[2]+$tranSVec;
    vector $SVecii[];
    vector $SVecPoint = $SVeci;
    vector $YZvec = PointToPlaneN($SVecPoint, $SVecii);
    vector $ZXvec = PointToPlaneN($SVecPoint, $SVecii);
    vector $XYvec = PointToPlaneN($SVecPoint, $SVecii);
    vector $VecPlanes[];
    vector $CHeckVecOnLine = <<-1, -1, -1>>;
    vector $VecLineDirM;
    vector $VecLineDiri;
    vector $EachVec;
    vector $NewAXis;
    vector $NewPosVec = <<$NewPos[0], $NewPos[1], $NewPos[2]>>;
    vector $planePointN;
    vector $EmptyVecA[];
    vector $EmptyVecB[];
    vector $NewCurveVecPts[];
    vector $eachCurveVec;
    vector $newTranVec;
    vector $v = $veci;
    vector $AllLocPositionsZ[];
    vector $AllPlaneLocPositionZ[] = VecPointsToCameraPlane($AllLocPositionsZ);
    vector $AllPlaneLocs[];
    vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
    vector $Vai = $VecbvA[0];
    vector $Vbi = $VecbvA[1];
    vector $VbiUnit = << $u, $v, $w >>;
    vector $VbiUnitA = `unit $VbiUnit`;
    vector $YUV = << $Y, $U, $V>>;
    vector $Va = << $posAZ[0], $posAZ[1], $posAZ[2] >>;
    vector $Vb = << $posBZ[0],  $posBZ[1], $posBZ[2] >>;
    vector $VecLi[];
    vector $NewVeci;
    vector $CurveCollectVec[];
    vector $nevVec[] = NewVecOrderWithINTKey($NewIndex,$CurveCollectVec);
    vector $vectorZnewX[];
    vector $EmptyVectorArrayA[];
    vector $PositionsZ_A[];
    vector $AllLocPositionsZi[];
    vector $VecCurEndsa[] = VecCurveEnds({$CurveItemZai});
    vector $VecCurEndsb[] = VecCurveEnds({$CurveItemZbi});
    vector $PositionsZ_B[];
    vector $VecPtsMirrorA[];
    vector $VecPtsMirrorB[];
    vector $VecPtsMirrorEnds_A[];
    vector $VecPtsMirrorEnds_B[];
    vector $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
    vector $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);
    vector $Vecbv[];
    vector $Vecbvi[];
    vector $NewVecENDsi[];
    vector $CRV_ENDSi[];
    vector $CRV_ENDSii[];
    vector $DDirEpipolXYZ[];
    vector $AllEpipolXYZ[];
    vector $EpipolD[];
    vector $LineMidi;
    vector $NewDirZi;
    vector $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    vector $Intersect_LineB_a;
    vector $Intersect_LineB_b = FloatToVec (lineIntersection($MidCurveB, $DDirEpipolA, $VecCurEndsa[1],$FloatDirEpipolB));
    vector $IntersectEnds_A[];
    vector $Intersect_A[];
    vector $IntersectForce_A[];
    vector $IntersectAverage_A[];
    vector $PositionsZ_Ai[];
    vector $PositionsZ_Bi[];
    vector $LocCurveEndsVec3D[] = PointArray($queryLocCurveEnds3D);
    vector $PointsA[];
    vector $PointsB[];
    vector $VecOnPlaneA[];
    vector $VecOnPlaneB[];
    vector $LocOnPlaneVec[] = PointArray($NewFoundLocs);
    vector $Intersect_B[];
    vector $LocSMirror[];
    vector $AllNearestVecCA[];
    vector $VecPointOnCrv[];
    vector $NearestVecCA = $VecPointOnCrv[$New_PointOnCrvIND_A[0]];
    vector $AllNearestVecCAb[];
    vector $VecPointOnCrvb[];
    vector $NearestVecCAb = $VecPointOnCrvb[$New_PointOnCrvIND_Ab[0]];
    vector $CUT_CrvMirrorEnds_A[] = VecPtsToZMirrorPts({$NearestVecCAb});
    vector $CUT_CrvIntersectEnds_A = FloatToVec (lineIntersectionF($CamPos_A, $NearestVecCA, $CamPos_M, $CUT_CrvMirrorEnds_A[0]));
    vector $CUT_CrvIntersectMirrorEnds_A[] = VecPtsToZMirrorPts({$CUT_CrvIntersectEnds_A});
    vector $VecCUT_CrvA = FloatToVec (FloatPointsToCamPlane($VecIntCB));
    vector $VecCUT_CrvB = FloatToVec (FloatPointsToCamPlane($VecIntCA));
    vector $VlocA;
    vector $VecLineDir = PositiveDir($DirectionLineF);
    vector $tan;
    vector $norm;
    vector $bi;
    vector $Avec[];
    vector $AVvects[];
    vector $Aver;
    vector $CurveVectors[];
    vector $Ui = FloatToVec($p1p2);
    vector $Vi = FloatToVec($p1p3);
    vector $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;
    vector $U1 = TwoVecsOrFloats($point2, $point1);
    vector $V1 = TwoVecsOrFloats($point3, $point1);
    vector $U2 = TwoVecsOrFloats($point3, $point1);
    vector $V2 = TwoVecsOrFloats($point2, $point1);
    vector $U3 = TwoVecsOrFloats($point1, $point3);
    vector $V3 = TwoVecsOrFloats($point2, $point3);
    vector $normalV[];
    vector $DirNormi = FloatToVec ($FDirNorAi);
    vector $MidVec = FloatToVec( $MidPt);
    vector $ABC[];
    vector $DirecOfPointABi = FloatToVec ( DirectionFN($FixVeci[0], $FixVeci[1]));
    vector $VecH[];
    vector $aV = FloatToVec($valuesA);
    vector $bV = FloatToVec($valuesiAi);
    vector $VecAverage = FloatToVec($AverageVecCurve);
    vector $SharpValuesTan[];
    vector $FlushVectors[];
    vector $valuesTan[];
    vector $valuesTanSpace[];
    vector $valuesTanPastSpace;
    vector $valuesTanPast;
    vector $DeepPastTan;
    vector $DeepPast;
    vector $threeVecsT[];
    vector $CurrentVecT;
    vector $eachVecLine;
    vector $Xdirect;
    vector $Ydirect;
    vector $Zdirect;
    vector $XYZdirect[];
    vector $NewDirectionZ;
    vector $XYZdirectL[];
    vector $LineDirect_3D;
    vector $IntersectEnds_Ax[];
    vector $PositionsZ_Bii[];
    vector $PositionsZ_Aii[];
    vector $PtsMirrorAi[];
    vector $LoCz_3D[];
    vector $TXI = << -1.0 , 1.0, 1.0>>;
    vector $UnconnectedEnds[];
    vector $Xdirection = << 1.0,0.0,0.0>>;
    vector $Intersect_BX[];
    vector $PairVectors[];
    vector $EpipolXLine = DirectionFN( $MidEpipolPosFCam, $PairVectors[$PairInt[0]]);
    vector $EndrEndsa[] = VecCurveEnds({$ThefirstCurvei});
    vector $EmptyVectorArrayB[];
    vector $Dir_VecMAIN;
    vector $threeVecs[];
    vector $Dir_VecA;
    vector $Positions[];
    vector $VecCurEnds[] = VecCurveEnds({$TempCrv});
    vector $LocCurveEndsVec[] = PointArray($queryLocCurveEnds);
    vector $EndSnapAndEndProject[];
    vector $endNotNearZ[];
    vector $NearEndZ;
    vector $Loc3D_Vec[] = PointArray($NewFoundLocs );
    vector $ALLLoc3D_VecAB[] = PointArray($AllarrayCurvesNear);
    vector $ReducedVecAB[];
    vector $ALLLoc3D_Vec[];
    vector $MovedEndPointPlane[] = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    vector $Dir_CamRay;
    vector $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    vector $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);
    vector $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    vector $One;
    vector $each;
    vector $NearPointsXYZ[];
    vector $ReducedVec[];
    vector $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    vector $VecLineDirMi;
    vector $PointN_LineXYZ;
    vector $SnapN;
    vector $SnapPlaceN;
    vector $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);
    vector $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    vector $Points3DPair_And_2DPair[];
    vector $Crv_Pts[];
    vector $MirrorAcrossPlaneVecs[] = VecMultMatrixMirror($Crv_Pts);
    vector $DirLine = DirectionFN( $VecLoc, $Pos_A);
    vector $TranstatedVecs[];
    vector $PointN_Line = ClosestPoint2LineVec($Dir_CamRay, $MovedEndPointPlane[0], $Loc3D_Vec[0]);
    vector $PointN_LineB = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $PointN_Line);
    vector $PositionsZ_Ax[];
    vector $ZYplaneMatrix[];
    vector $VecDirection_A_XYZ[];
    vector $VecDirectionXYZ[];
    vector $VecXYZsOnPlane[] = VecPointsToCameraPlane($VecXYZs);
    vector $VecXYZsOnPlaneiY[];
    vector $VecXYZsOnPlaneiiY[];
    vector $VecXYZsOnPlaneVpoint[];
    vector $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
    vector $VIntersectEnds_A[];
    vector $ObjLoc3DCurv[];
    vector $LocCurveEndsVec_3D[] = PointArray($arrayCurvesNearA1);
    vector $PointN_LineA = ClosestPoint2LineVec($LineDirect_3D, $VecCurEnds[0], $LocCurveEndsVec_3D[0]);
    vector $NearVecPts[];
    vector $PositionsZ_Aiix[];
    vector $VecTest[];
    vector $FistAndSecond[];
    vector $VecA = $FistAndSecond[0];
    vector $VecB = $FistAndSecond[1];
    vector $ReversePositionsZ_Ai[] = ReverseVectorArray($PositionsZ_Ai);
    vector $XIntersect_Ax[];
    vector $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $TransL[0] = $mIA[3][0];
    $TransL[1] = $mIA[3][1];
    $TransL[2] = $mIA[3][2];
    $VecROne = GetRotationVectorsMatrix($mIA );

    $tranSVec = << $TransL[0], $TransL[1], $TransL[2]>>;
    //X
    $tranSVecA = $VecROne[0]+$tranSVec ;
    //Loc $tranSVecA;
    //Y
    $tranSVecB = $VecROne[1]+$tranSVec ;
    //Loc $tranSVecB;
    //Z
    $tranSVecC = $VecROne[2]+$tranSVec ;
    //Loc $tranSVecC;
    //YZ
    //ZX
    //XY
    clear $SVecii;
    $SVecii[0] = $tranSVecB;
    $SVecii[1] = $tranSVecC;
    $SVecii[2] = $tranSVec;
    $SVecPoint = $SVeci ;
    $YZvec = PointToPlaneN($SVecPoint, $SVecii);
    clear $SVecii;
    $SVecii[0] = $tranSVecC;
    $SVecii[1] = $tranSVecA;
    $SVecii[2] = $tranSVec;
    $ZXvec = PointToPlaneN($SVecPoint, $SVecii);
    clear $SVecii;
    $SVecii[0] = $tranSVecA;
    $SVecii[1] = $tranSVecB;
    $SVecii[2] = $tranSVec;
    $XYvec = PointToPlaneN($SVecPoint, $SVecii);
    //dist
    // distance2Pts
    $VecPlanes[0] = $YZvec;
    $VecPlanes[1] = $ZXvec;
    $VecPlanes[2] = $XYvec;

    $SCale = $mIB[3][3];
    $CombA = 0;
    $CombB = 0;
    $CHeckVecOnLine = <<-1, -1, -1>>;
    $CountN = 0;
    for($EachVec in $VecPlanes){

    if (catch($VecLineDiri = DirectionFN($SVeci,$EachVec))){
    //$VecLineDiri = DirectionFN($SVeci,$EachVec);

    $VecLineDirM = $VecLineDiri*$VecROne[$CountN];

    if(!(($VecLineDirM.x) == ($VecLineDirM.y))&&(($VecLineDirM.x) == ($VecLineDirM.z))){

    //if($CombA != 3){
    //KEY
    $VecLineDiri = DirectionFN($SVeci,$EachVec);
    $XYZs = $VecLineDiri;
    $DistToPlane[$CountN]= distance2Pts($SVeci,$EachVec);
    $Time = `sign $XYZs[$CountN]`;

    if(1 !=$Time){
    //$DistToPlane[$CountN]*= -1.0;
    $DistToPlane[$CountN]*= $Time;
    }
    }else{$DistToPlane[$CountN]= 0.0;}
    }else{$DistToPlane[$CountN]= 0.0;}

    $CountN++;
    }
    //print $DistToPlane;
    // $DistToPlane is Zero cord
    $DistToPlane = multiplyFloat($SCale, $DistToPlane);
    $NewAXis = MultPointMatrix($DistToPlane, $mIB);
    //$NewAXis = MultPointMatrixProduct($DistToPlane, $mIB);
    $TransLb[0] = $mIB[3][0];
    $TransLb[1] = $mIB[3][1];
    $TransLb[2] = $mIB[3][2];
    $NewPos = AddFloats($TransLb, $NewAXis);
    //Loc $NewPos;
    $NewPosVec = <<$NewPos[0], $NewPos[1], $NewPos[2]>>;
    //vector $NewPosVec = $NewAXis;
    return $NewPosVec;
    }
    /////////////////////////////////////////////////
    proc vector PointToPlaneN( vector $Veciiv, vector $Vec[]){
    $pAv = AverageVectorPoint($Vec);
    $n = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    $DistanceLoc = distance2Pts(  $Veciiv, $pAv);
    $MultDirCam = multiplyFloat($DistanceLoc, $n);
    $FloatDirectionCamNormalA = AddFloats($pAv, $MultDirCam);
    $PointN = ClosestPoint2LineVec($n, $pAv, $Veciiv);
    //CHANGE_HERE useing distance
    //int $CombA = distance2Pts($PointN, $pAv);
    $CombA = PointsEquivalentTol ($PointN, $pAv);
    //if($CombA != 0){
    if($CombA != 3){
    //KEY switch these to findthe one that makes sence
    $FloatDirectionAi = DirectionFN($pAv,$PointN);
    //float $FloatDirectionAi[] = DirectionFN($PointN,$pAv);
    $DistanceLoc = distance2Pts( $PointN, $pAv );
    $MultDirPC1 = multiplyFloat($DistanceLoc, $FloatDirectionAi);
    $AddMultMiiF = AddFloats($Veciiv, $MultDirPC1);
    $planePointN = << $AddMultMiiF[0], $AddMultMiiF[1], $AddMultMiiF[2]>>;
    }else{ $planePointN = $Veciiv;
    }
    return $planePointN;
    }

    proc vector [] Matrix_Curve_Translation(vector $VecPairA[],vector $VecPairB[], vector $CurveVecPointZ[]){
    matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    matrix $matrixB[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $matrixA = TwoPointMatrixPlusAxisWorld($VecPairA, $EmptyVecA, 1);
    $matrixB = TwoPointMatrixPlusAxisWorld($VecPairB, $EmptyVecB, 1);
    // Get scale changerelative to multiply in matrix
    // 3 7 11 // shear
    // float matrix size 16 numbers its index Number for Scale is 15
    // matrix [3][3]
    $LengthA = distance2Pts ($VecPairA[0], $VecPairA[1]);
    $LengthB = distance2Pts ($VecPairB[0], $VecPairB[1]);

    if($LengthA<$LengthB){$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}else{$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}
    $LengthAB *= $Sign_F;
    $MatrixFB = MatrixToFloat($matrixB);
    size $MatrixFB;
    //PrintMatrix($matrixB, 4);
    $MatrixFB[15] = $LengthAB;
    $matrixNB = FloatToMatrix($MatrixFB);
    //PrintMatrix($matrixNB, 4);
    $curvei = "curve -d 1";
    $CountCpts =0;
    for($eachCurveVec in $CurveVecPointZ){

    //Key MatrixAxisTranlation
    $newTranVec = MatrixAxisTranlation($eachCurveVec, $matrixA, $matrixNB);
    $AddMepi = $newTranVec;
    $NewCurveVecPts[$CountCpts] = <<$AddMepi[0],$AddMepi[1],$AddMepi[2]>>;
    $curvei += " -p "+$AddMepi[0]+" "+$AddMepi[1]+" "+$AddMepi[2];
    $CountCpts++;
    }
    //eval($curvei);
    //ResetTransEachSL;
    return $NewCurveVecPts;
    }


    //END of Matrix Axis Translation
    ///////////////////////////////////////////////////////////////////////////


    proc float VectorsComp(int $ZeroOneTwo , vector $veci){
    $xyz = {"x", "y", "z"};
    $v = $veci;
    $command = ("\$ni ="+"$v"+"."+$xyz[$ZeroOneTwo]);
    return  eval($command);
    }

    proc string VecArrayToCurve(vector $FixVec[]){
    $sIZes = `size $FixVec `;
    $NUmers = CreateIntIndex($sIZes);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $curve = "curve -d 1";
    for ($eachVeCx in $FixVec){
    $valuesBi = $eachVeCx;
    $curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    }
    $curve += " "+ $K;
    $Newcurvez = `eval($curve)`;
    return $Newcurvez;
    }
    proc PointCurvesToPlaneCurve(string $CurveItemZ[]){
    for ($eachCurve in $CurveItemZ){
    clear $AllLocPositionsZ;
    $AllLocPositionsZ = VecCurveEps( $eachCurve );
    $AllPlaneLocPositionZ = VecPointsToCameraPlane($AllLocPositionsZ);
    $newPlaneCurve = VecArrayToCurve($AllPlaneLocPositionZ);
    ResetTranslation({$newPlaneCurve});
    }
    }
    proc float [] EulerAngB(float $pointB1[], float $pointB2[]){
    $EulerAngleA = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
    return $EulerAngleA;
    }

    proc float [] MirrorPointFrom3PointPlane(vector $SelectVec[], float $oneItemFLoats[]){
    //p t n Are just a directions....
    $p = $SelectVec[0];
    $t = $SelectVec[1];
    $n = $SelectVec[2];
    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
    $norm = `unit << $n[0], $n[1], $n[2] >>`;
    // Calculate the binormal.
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
    << ($norm.x), ($norm.y), ($norm.z) >>`;
    // Normalize our vector.
    $bi = `unit $bi`;
    $x = $oneItemFLoats[0];
    $y = $oneItemFLoats[1];
    $z = $oneItemFLoats[2];
    $bi *=-1.0;
    $normal = $bi;
    $p = AverageVectorPoint($SelectVec);
    $d = $normal[0] * $p[0] + $normal[1] * $p[1] + $normal[2] * $p[2] ;
    $dist = $x * $normal[0] + $y * $normal[1] + $z * $normal[2] - $d ;
    $dist *=-1.0;
    $mp[0] = $x ;
    $mp[1] = $y ;
    $mp[2] = $z ;
    $dist *= 1.0 ;
    $dist += -1.0;
    $mp[0] = ($x + 2.0 * $normal[0] * ($dist))   ;
    $mp[1] = ($y + 2.0 * $normal[1] * ($dist))   ;
    $mp[2] = ($z + 2.0 * $normal[2] * ($dist))   ;

    return $mp;
    }

    /*
    $itemOne = `ls -sl`;
    $LivePlanePosX = `xform -q -ws -t $itemOne[0]`;
    $MirrorF = MirrorPointFrom3PointPlane( PointArrayT(`ls -sl`), $LivePlanePosX);
    Loc $MirrorF;

    */


    proc vector [] PointCurvesToMirrorPoint(string $CurveItemZ[], vector $SelectVec[]){
    clear  $AllPlaneLocs;
    clear $AllLocPositionsZ;
    $AllLocPositionsZ = VecCurveEps($CurveItemZ[0] );
    for ($eachVecEp in $AllLocPositionsZ){
    $AllPlaneLocs[`size($AllPlaneLocs)`] = `FloatToVec (MirrorPointFrom3PointPlane( $SelectVec, $eachVecEp))`;
    }
    $newCurvei = VecArrayToCurve($AllPlaneLocs);
    ResetTranslation({$newCurvei});
    return $AllPlaneLocs;
    }
    proc vector [] PtCurvesToZMirrorPt(string $CurveItemZ[]){
    clear  $AllPlaneLocs;
    clear $AllLocPositionsZ;
    $AllLocPositionsZ = VecCurveEps($CurveItemZ[0] );
    for ($eachVecEp in $AllLocPositionsZ){
    $Zx = $eachVecEp;
    $Zx[0] *= -1.0;
    $AllPlaneLocs[`size($AllPlaneLocs)`] = `FloatToVec ($Zx)`;
    }
    $newCurvei = VecArrayToCurve($AllPlaneLocs);
    ResetTranslation({$newCurvei});
    return $AllPlaneLocs;
    }
    proc vector [] VecPtsToZMirrorPts(vector $AllLocPositionsZ[]){
    clear  $AllPlaneLocs;
    for ($eachVecEp in $AllLocPositionsZ){
    $Zx = $eachVecEp;
    $Zx[0] *= -1.0;
    $AllPlaneLocs[`size($AllPlaneLocs)`] = `FloatToVec ($Zx)`;
    }
    return $AllPlaneLocs;
    }



    proc int addStereoCurve(){
    $CreatedObjectCurve = `ISSelectedTypeCurve`;
    return $CreatedObjectCurve;
    }
    /////////////////
    proc int ISSelectedTypeCurve(){
    $C = `ls -sl`;
    $nametypeZi= `getTypeItemString $C`;
    $nameA = `match "[a-zA-Z]+" $nametypeZi`;
    $nameB = `match ".urve" $nameA`;
    $zeroOR1Z = `gmatch $nameB "*[C-c]urve*"`;
    return $zeroOR1Z;
    }
    ///////////////////

    ////////////////////
    proc int addCurveNumbers(int $addNumbersiA){
    $addNumbersiA++;
    if($addNumbersiA>2){$addNumbersiA=0;}
    return $addNumbersiA;
    }
    ///////////////
    proc EvalAddingCurves(){
    global int $addNumbersA;
    $addNumbersA = addCurveNumbers($addNumbersA);
    print $addNumbersA;
    }
    //////////////////
    //////////////////

    proc float [] FloatPointsToCamPlane(float $LocPos1[]){
    $Pi = 3.1415926535;
    $pi = 3.1415926535;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $LivePlanePos = `xform -q -ws -t LiveSurfaceB`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $CamerasDirectionVector = $CamerasDirectionVectorNormal;
    $FloatDirectionA = DirectionFN($CamPos1, $LocPos1);
    $DistanceLoc = distance2Pts( $LocPos1, $CamPos1 );
    $DistanceLocA = $DistanceLoc;
    $DistanceLoc = $DistanceLoc * -1;
    $MultDirPC1 = multiplyFloat($DistanceLoc, $CamerasDirectionVector);
    $FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1);
    $CamerasDirectionVectorA = DirectionFN($FloatDirectionCamNormal, $CamPos1);
    $MultDirPC1A = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
    $FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1A);
    $p1 = $CamPos1;
    $p2 = $LocPos1;
    $p3 = $FloatDirectionCamNormal;
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );
    $FloatPosZero = {0, 0, 0};
    $FloatDirection = DirectionFN($FloatPosZero, $normal);
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $mid3 = midPoint2Pts( $p2, $p3 );
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    $FloatDirPerpCenterC = DirectionFN($center,$mid2);
    $FloatDirPointAC = DirectionFN($p1, $p3);
    $center8 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
    $FloatDirLocToPerpIntersect = DirectionFN($center8,$p2);
    $OnPlane = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );
    return $OnPlane;
    }

    //PROBLEM

    proc float[] DirectionF(float $EACHCVposAZ[], float $EACHCVposBZ[]){
    $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    //This is freaky since it is reversed!! not sure I could ever fix this
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]);
    /*
    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]);
    */
    $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
    $UnitDirection = $vectorUnit;
    ///////////////////////////////////////////////// ////
    return $UnitDirection;
    }


    proc float[] DirectionFN(float $posAZ[], float $posBZ[]){

    /*

    $Vai = $VecbvA[0];
    $Vbi = $VecbvA[1];

    */

    $Vai = << $posAZ[0], $posAZ[1], $posAZ[2] >> ;
    $Vbi = << $posBZ[0],  $posBZ[1], $posBZ[2] >> ;

    $xi = $Vai.x;
    $yi = $Vai.y;
    $zi = $Vai.z;
    $x = $Vbi.x;
    $y = $Vbi.y;
    $z = $Vbi.z;
    $u = $xi - $x;
    $v = $yi - $y;
    $w = $zi - $z;


    $VbiUnit = << $u, $v, $w >> ;
    $VbiUnitA = `unit $VbiUnit`;
    /*
    $e = 1;
    //float $Mult = $e*$v;
    $Y = $u/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $U = $v/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $V = $w/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $YUV = << $Y, $U, $V>>;
    $UnitDirection = $YUV;
    */
    $UnitDirection = $VbiUnitA;

    //////////
    return $UnitDirection;
    }


    /*
    proc float[] DirectionF(float $posAZ[], float $posBZ[]){

    $Va = << $posAZ[0], $posAZ[1], $posAZ[2] >> ;
    $Vb = << $posBZ[0],  $posBZ[1], $posBZ[2] >> ;

    $xi = $Va.x;
    $yi = $Va.y;
    $zi = $Va.z;
    $x = $Vb.x;
    $y = $Vb.y;
    $z = $Vb.z;
    $u = $xi - $x;
    $v = $yi - $y;
    $w = $zi - $z;
    $e = 1;
    //float $Mult = $e*$v;
    $Y = $u/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $U = $v/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $V = $w/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $YUV = << $Y, $U, $V>>;
    $UnitDirection = $YUV;
    //////////
    return $UnitDirection;
    }
    */


    ///////////////////////////////////////////////////////////////////////////



    //STart up the engine
    /*

    EvalAllCurvesToolZ;
    $scriptt_jobNumConnectionChanged = `scriptJob -conditionChange delete evalVectorIndexAdditionSubtract`;
    eval(" $jobNumtranslateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.translate  RUNMoveZCURVEM`;");
    eval(" $jobNumrotateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.rotate  RUNMoveZCURVEM`;");

    select -r LiveSurfaceB ;
    MakeLive;
    PencilCurveTool;

    */










    //eval("print $gLastAction");

    ///////////////////










    //////////////////////////////////////////////////////////End of all known used Stereo_curve


    proc setTranslationObj(string $objectitem1[], float  $tranlate[] ){
    setAttr ($objectitem1[0]+".translate") $tranlate[0] $tranlate[1] $tranlate[2];
    }
    proc SetObjectsToROundPoints( string $objectZ[], vector $FixVec[]){
    $IndeXa = 0;
    for ($eachObject in $FixVec){
    $newF  = roundFloatsInt($eachObject);
    setTranslationObj( {$objectZ[$IndeXa]}, $newF );
    $IndeXa++;
    }
    }

    proc DisRotPiv(){
    $CurveItemZ = `ls -sl`;
    for ($eachItemC in $CurveItemZ){
    setAttr ($eachItemC +".displayRotatePivot") 1;
    }
    }

    proc cubic(float $a, float $b, float $c, float $d, float $resultReal[] , float $resultImaginary[]) {
    /*
    if ( abs(a) < 0.000001) {
    //
    if a=0 equation is quadratic
    // handle seperately to avoid divide by zero
    quadratic(b,c,d,$resultReal,$resultImaginary);
    // the quadratic function is defined on this page:
    // http://www.euclideanspace.com/maths/algebra/equations/polynomial/quadratic/
    return;
    }
    */
    $a = 7.5;
    $b = 3.4;
    $c = 5.3;
    $d = 1.7;
    // recuring terms
    //proc cubic(float $a, float $b, float $c, float $d, float $resultReal[] , float $resultImaginary[]) {
    $t1 = ((2*$a*$a*$a) - (9*$a*$b) +(27*$c));
    $t2 = ((-$a*$a) + (3*$b));
    $t3 = $t1*$t1 + 4*$t2*$t2*$t2;
    // if ($t3<0) handle complex roots;
    $t4 = ((-$t1 + (`sqrt $t3`))/54);
    $t41 = ((-$t1 - (`sqrt $t3`))/54);
    $t5 = ((-$a*$a) + (3*$b));
    $t6 = `sqrt($t1*$t1 + (4*$t5*$t5*$t5))`;
    $t7 = ((-$t1 - $t6)/54);
    $TimesOne = 1.0;
    if($t7<0){ $TimesOne = -1.0;}
    //print $t4;
    //print $t7;
    //print $t41;
    $N = 1;
    if($t7<0){$N=-1;}
    $Ni = 1;
    if($t41<0){$Ni=-1;}
    $resultReal[0] = (-$a/3) + (` pow  $t4 (1.0/3.0)` ) +  $N*(` pow  ($t7*$N) (1.0/3.0)`) ;
    $resultReal[1] = (-$a/3) - (0.5*(`pow $t4 (1.0/3.0)`)) +  (-0.5*(`pow $t4 (1.0/3.0)`));
    $resultReal[2] = (-$a/3) + (`pow $t4 (1.0/3.0) `) + $Ni*(`pow ($Ni*$t41) (1.0/3.0)`);
    $resultImaginary[0] = 0;
    $resultImaginary[1] =  (`sqrt $t3`) * 0.5 * (`pow $t4 (1.0/3.0)`) +  (`sqrt $t3` )*0.5*(`pow $t4 (1.0/3.0) `) ;
    $resultImaginary[2] = 0;
    print $resultReal;
    print("\n");
    print  $resultImaginary;
    print("\n");
    }
    proc float DoubleDeterminant(matrix $mat[][]) {
    $valueA = $mat[0][3] * $mat[1][2] * $mat[2][1] * $mat[3][0]-$mat[0][2] * $mat[1][3] * $mat[2][1] * $mat[3][0];
    $valueB = $mat[0][3] * $mat[1][1] * $mat[2][2] * $mat[3][0]+$mat[0][1] * $mat[1][3] * $mat[2][2] * $mat[3][0]+ $mat[0][2] * $mat[1][1] * $mat[2][3] * $mat[3][0]-$mat[0][1] * $mat[1][2] * $mat[2][3] * $mat[3][0];
    $valueC = $mat[0][3] * $mat[1][2] * $mat[2][0] * $mat[3][1]+$mat[0][2] * $mat[1][3] * $mat[2][0] * $mat[3][1]+ $mat[0][3] * $mat[1][0] * $mat[2][2] * $mat[3][1]-$mat[0][0] * $mat[1][3] * $mat[2][2] * $mat[3][1];
    $valueD = $mat[0][2] * $mat[1][0] * $mat[2][3] * $mat[3][1]+$mat[0][0] * $mat[1][2] * $mat[2][3] * $mat[3][1]+ $mat[0][3] * $mat[1][1] * $mat[2][0] * $mat[3][2]-$mat[0][1] * $mat[1][3] * $mat[2][0] * $mat[3][2];
    $valueE = $mat[0][3] * $mat[1][0] * $mat[2][1] * $mat[3][2]+$mat[0][0] * $mat[1][3] * $mat[2][1] * $mat[3][2]+ $mat[0][1] * $mat[1][0] * $mat[2][3] * $mat[3][2]-$mat[0][0] * $mat[1][1] * $mat[2][3] * $mat[3][2];
    $valueF = $mat[0][2] * $mat[1][1] * $mat[2][0] * $mat[3][3]+$mat[0][1] * $mat[1][2] * $mat[2][0] * $mat[3][3]+ $mat[0][2] * $mat[1][0] * $mat[2][1] * $mat[3][3]-$mat[0][0] * $mat[1][2] * $mat[2][1] * $mat[3][3];
    $valueG = $mat[0][1] * $mat[1][0] * $mat[2][2] * $mat[3][3]+$mat[0][0] * $mat[1][1] * $mat[2][2] * $mat[3][3];
    $value = $valueA - $valueB - $valueC - $valueD - $valueE - $valueF - $valueG;
    return $value;
    }
    /////////////////////////
    proc Quaternion()
    {
    $ObjectSel = `ls -sl`;
    ///////WRONG Attr!
    $ParamX =  getAttr ($ObjectSel[0]+".rx") ;
    $ParamY =  getAttr ($ObjectSel[0]+".ry") ;
    $ParamZ =  getAttr ($ObjectSel[0]+".rz") ;
    $x = deg_to_rad($ParamX );
    $y = deg_to_rad($ParamY );
    $z = deg_to_rad($ParamZ );
    $x = -$x * 0.5;
    $y = -$y * 0.5;
    $z = -$z * 0.5;
    $cx =  cos($x) ;
    $cy =  cos($y) ;
    $cz =  cos($z) ;
    $sx =  sin($x) ;
    $sy =  sin($y) ;
    $sz =  sin($z) ;
    $cycz = $cy * $cz;
    $sysz = $sy * $sz;
    $sycz = $sy * $cz;
    $cysz = $cy * $sz;
    $Qw = $cycz * $cx + $sysz * $sx;
    $Qx = $cycz * $sx + $sysz * $cx;
    $Qy = $sycz * $cx - $cysz * $sx;
    $Qz = $cysz * $cx - $sycz * $sx;
    $l = sqrt( $Qx*$Qx + $Qy*$Qy + $Qz*$Qz + $Qw*$Qw );
    if( $l == 0 )
    {
    $Qx = 0;
    $Qy = 0;
    $Qz = 0;
    }
    else
    {
    $Qx /= $l;
    $Qy /= $l;
    $Qz /= $l;
    $Qw /= $l;
    }
    $angle = acosd($Qw) * 2;
    $sinHalfAngle = sqrt(1 - ($Qw * $Qw));
    if ($sinHalfAngle != 0)
    {
    $Qx = $Qx / $sinHalfAngle;
    $Qy = $Qy / $sinHalfAngle;
    $Qz = $Qz / $sinHalfAngle;
    }
    else
    {
    $Qx = 1;
    $Qy = 0;
    $Qz = 0;
    }
    $angleN = $angle;
    // this is just for the other print that truncates to 0.00//
    $rAngle = $angle;
    $rX = $Qx*100; float $fx = $rX; float $xxx = $fx/100;
    $rY = $Qy*100; float $fy = $rY; float $yyy = $fy/100;
    $rZ = $Qz*100; float $fz = $rZ; float $zzz = $fz/100;
    // truncated print is muted, DOES NOT ROUND OFF //
    //print ($xxx+" "+-$zzz+" "+$yyy+" "+$rAngle);
    print ($Qx+" "+-$Qz+" "+$Qy+" "+$angleN);
    }
    proc cubic(float $a, float $b, float $c, float $d, float $resultReal[] , float $resultImaginary[]) {
    $t1 = ((2*$a*$a*$a) - (9*$a*$b) +(27*$c));
    $t2 = ((-$a*$a) + (3*$b));
    $t3 = $t1*$t1 + 4*$t2*$t2*$t2;
    // if ($t3<0) handle complex roots;
    $t4 = ((-$t1 + (`sqrt $t3`))/54);
    $t41 = ((-$t1 - (`sqrt $t3`))/54);
    $t5 = ((-$a*$a) + (3*$b));
    $t6 = `sqrt($t1*$t1 + (4*$t5*$t5*$t5))`;
    $t7 = ((-$t1 - $t6)/54);
    $TimesOne = 1.0;
    if($t7<0){ $TimesOne = -1.0;}
    $Nin = 1;
    if($t4<0){$Nin=-1;}
    $N = 1;
    if($t7<0){$N=-1;}
    $Ni = 1;
    if($t41<0){$Ni=-1;}
    $Niin = 1;
    if($t3<0){$Niin=-1;}
    $resultReal[0] = (-$a/3) + $Nin*(` pow ($Nin*$t4) (1.0/3.0)` ) +  $N*(` pow  ($t7*$N) (1.0/3.0)  `) ;
    $resultReal[1] = (-$a/3) - (0.5*($Nin*(` pow ($Nin*$t4) (1.0/3.0)` ))) +  (-0.5*($Nin*(` pow ($Nin*$t4) (1.0/3.0)` )));
    $resultReal[2] = (-$a/3) + $Nin*(` pow ($Nin*$t4) (1.0/3.0)` ) + $Ni*(`pow ($Ni*$t41) (1.0/3.0) `);
    $resultImaginary[0] = 0;
    $resultImaginary[1] =  (`sqrt $t3`) * 0.5 * ($Nin*(` pow ($Nin*$t4) (1.0/3.0)` )) +  (`sqrt $t3` )*0.5*($Nin*(` pow ($Nin*$t4) (1.0/3.0)` )) ;
    $resultImaginary[2] = 0;
    print $resultReal;
    print("\n");
    print  $resultImaginary;
    print("\n");
    }
    proc float [] lineIntersectionF(float $PosA[], float $PosB[], float $PosC[], float $PosD[]){
    $DirAB = DirectionF ($PosA, $PosB);
    $DirCD = DirectionF ($PosC, $PosD);
    $locsA = lineIntersection($PosA, $DirAB, $PosC, $DirCD);
    return $locsA;
    }
    // Get a matrix
    proc matrix screenSpaceGetMatrix(string $attr){
    $v = `getAttr $attr`;
    matrix $mat[4][4]=<<$v[0], $v[1], $v[2], $v[3];
    $v[4], $v[5], $v[6], $v[7];
    $v[8], $v[9], $v[10], $v[11];
    $v[12], $v[13], $v[14], $v[15]>>;
    return $mat;
    }
    // Multiply the vector v by the 4x4 matrix m, this is probably
    // already in mel but I cant find it.
    proc vector screenSpaceVecMult(vector $v, matrix $m){
    matrix $v1[1][4]=<<$v.x, $v.y, $v.z, 1>>;
    matrix $v2[1][4]=$v1*$m;
    return <<$v2[0][0], $v2[0][1],  $v2[0][2]>>;
    }
    proc vector matrixSpaceVecMult(vector $v, matrix $m){
    matrix $v1[1][4]=<<$v.x, $v.y, $v.z, 1>>;
    matrix $v2[1][4]=$v1*$m;
    return <<$v2[0][0], $v2[0][1],  $v2[0][2]>>;
    }
    proc matrix GetworldMatrix(string $object){
    $attr = $object +".worldMatrix";
    $v = `getAttr $attr`;
    matrix $mat[4][4]= `FloatToMatrix($v)`;
    return $mat;
    }
    proc matrix GetworldInverseMatrix(string $object){
    $attr = $object +".worldInverseMatrix";
    $v = `getAttr $attr`;
    matrix $mat[4][4]= `FloatToMatrix($v)`;
    return $mat;
    }
    proc matrix GetInverseMatrix(string $object){
    $attr = $object +".inverseMatrix";
    $v = `getAttr $attr`;
    matrix $mat[4][4]= `FloatToMatrix($v)`;
    return $mat;
    }
    proc matrix GetMatrix(string $object){
    $attr = $object +".matrix";
    $v = `getAttr $attr`;
    matrix $mat[4][4]= `FloatToMatrix($v)`;
    return $mat;
    }

    // matrix // float $MatrixSUrfaceB[]  matrix $SbMatrix[4][4];  $SbMatrix= GetMatrix("LiveSurfaceB");  float $MatrixSUrfaceB[] = MatrixToFloat($SbMatrix);

    //<description>
    //  	This script returns the multiplication of a point and a
    //		matrix as an array of 3 doubles:
    //<pre>
    //      vector * matrix = result

    //		<b>Note:</b> The matrix is assumed to be a single dimension
    //		array of 16 elements.
    //<BR>
    //		<b>Remember:</b> That the arrays are 0-based.
    //		e.g. [1][0] is matrix[4] element
    //<flags>
    //		float $point[]	Co-ordinates of the point.
    //		float $matrix[]	The matrix to be used.
    //<returns>
    //		float[] : Result as an array of 3 doubles.
    //
    //<examples>
    //	float $p[] = {1,2,3};
    //	float $m[] = {1,0,0,0,0,2,0,0,0,0,3,0,0,0,0,0};
    //	pointMatrixMult($p, $m);
    //	// Results: 1 4 9 //

    proc float[] pointMatrixMult( float $point[], float $matrix[] ){
    $result[0] = 0.0;
    $result[1] = 0.0;
    $result[2] = 0.0;
    if ( size($point) != 3 || size($matrix) != 16 )
    {
    warning (uiRes("m_pointMatrixMult.kPointArray"));
    return $result;
    }
    // create the node that will do the actual computation
    //
    if ( catch($multNode = `createNode pointMatrixMult`) )
    {
    warning (uiRes("m_pointMatrixMult.kCouldNotCreateNode"));
    return $result;
    }
    // set the matrix and point inputs to the node
    //
    setAttr ($multNode+".vectorMultiply") true;
    setAttr ($multNode+".inPoint") -type "double3" $point[0] $point[1] $point[2];
    setAttr ($multNode+".inMatrix") -type "matrix" $matrix[0] $matrix[1] $matrix[2] $matrix[3] $matrix[4] $matrix[5] $matrix[6] $matrix[7] $matrix[8] $matrix[9] $matrix[10] $matrix[11] $matrix[12] $matrix[13] $matrix[14] $matrix[15];
    // get the result and delete the node since it is no longer required
    //
    $result = `getAttr ($multNode+".output")`;
    delete $multNode;
    return $result;
    }

    proc  PrintMatrix(matrix $MatriXM[][] , int $MatrixN){

    $MatrixNi = $MatrixN-1;
    $FLoatMatrixA = MatrixToFloat($MatriXM);
    $FLoatMatrixA = MakeCleanFloatsZ($FLoatMatrixA);
    $stringFloat = FloatArrayToStringArray($FLoatMatrixA);
    clear $BytNum;
    for ($eachFloatz in $stringFloat){
    $BytNum[`size($BytNum)`] = (`sizeBytes $eachFloatz`)+2;
    }
    $BytNumSort = $BytNum;
    $BytNumSort = `sort $BytNumSort`;
    $BytNumLarg = $BytNumSort[`size($BytNumSort)`-1];
    $BytNumSmall = $BytNumSort[0];
    clear $BytNumDiff;
    for ($eachBytNum in $BytNum){
    $BytNumDiff[`size($BytNumDiff)`] = (`abs ($eachBytNum - $BytNumLarg)`)+2;
    }

    $IndXeF = 0;
    $IndXeFi = 0;
    $Syb = " ";
    $printcommand = "";
    for ($eachItemF in $stringFloat){
    $AddedSPaces = AddItemString($BytNumDiff[$IndXeF], $Syb);
    if($IndXeFi==$MatrixNi){ $printcommand += $AddedSPaces + $eachItemF + "|"+ "\n" ;
    $IndXeFi= -1; }else{ if($IndXeFi==0){$printcommand += "|"+$AddedSPaces + $eachItemF;}else{ $printcommand += $AddedSPaces + $eachItemF;}}
    $IndXeFi++;
    $IndXeF++;
    }
    print $printcommand;
    }


    proc string AddItemString(int $iN, string $NumLetorSy){
    $Xz = 0;
    $AddItem = "";
    while($iN > $Xz){
    $AddItem+= $NumLetorSy;
    $Xz++;
    }
    return $AddItem;
    }


    proc matrix MatrixMirrorX(matrix $m[][]){
    $MatrixA = `MatrixToFloat($m)`;
    matrix $m2[4][4]=<<1.0, 0.0, -1.0, 0.0;
    -1.0, 1.0, 1.0, 0.0;
    -1.0, 1.0, 1.0, 0.0;
    -1.0, 1.0, 1.0, 1.0>>;
    $MatrixB = `MatrixToFloat($m2)`;
    $iX = 0;
    for ($eachFloat in $MatrixA){
    if(!($MatrixB[$iX]==0)){
    $DividedFLoats[`size($DividedFLoats)`] = $eachFloat * $MatrixB[$iX];
    }else{$DividedFLoats[`size($DividedFLoats)`] = $eachFloat;}
    $iX++;
    }
    matrix $MatrixDiv[4][4]= FloatToMatrix($DividedFLoats);
    return $MatrixDiv;
    }

    proc float [] MultMatrixMirrorX(float $point[]){

    matrix $m2[4][4]=<<1.0, 0.0, -1.0, 0.0;
    -1.0, 1.0, 1.0, 0.0;
    -1.0, 1.0, 1.0, 0.0;
    -1.0, 1.0, 1.0, 1.0>>;
    $MatrixB = `MatrixToFloat($m2)`;
    $FLoatPointA = pointMatrixMult( $point, $MatrixB );
    return $FLoatPointA;
    }

    proc matrix MatrixTimesFloat(matrix $m[][], float $X){
    $MatrixA = `MatrixToFloat($m)`;

    $iX = 0;
    for ($eachFloat in $MatrixA){
    $DividedFLoats[`size($DividedFLoats)`] = $eachFloat * $X;

    $iX++;
    }
    matrix $MatrixDiv[4][4]= FloatToMatrix($DividedFLoats);
    return $MatrixDiv;
    }

    proc matrix MatrixDivide(matrix $m[][], matrix $m2[][]){
    $MatrixA = `MatrixToFloat($m)`;
    $MatrixB = `MatrixToFloat($m2)`;
    $iX = 0;
    for ($eachFloat in $MatrixA){
    if(!($MatrixB[$iX]==0)){
    $DividedFLoats[`size($DividedFLoats)`] = $eachFloat/ $MatrixB[$iX];
    }else{$DividedFLoats[`size($DividedFLoats)`] = $eachFloat;}
    $iX++;
    }
    matrix $MatrixDiv[4][4]= FloatToMatrix($DividedFLoats);
    return $MatrixDiv;
    }

    proc matrix MatrixCleanNegZero(matrix $m[][]){
    $MatrixA = `MatrixToFloat($m)`;

    $iX = 0;
    for ($eachFloat in $MatrixA){
    if(($eachFloat == 0)||($eachFloat == -0)){
    $CleanFLoats[`size($CleanFLoats)`] = 0.0;
    }else{$CleanFLoats[`size($CleanFLoats)`] = $eachFloat;}
    $iX++;
    }
    $CleanFLoats = MakeCleanFloatsZ($CleanFLoats);
    matrix $MatrixClean[4][4]= FloatToMatrix($CleanFLoats);
    return $MatrixClean;
    }

    proc TransformRelByMatrixXform(matrix $m[][], string $item){
    $itemD = `duplicate -rr $item`;
    $VecLi = PointArrayT($itemD);
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    (0) (0) (0) (1) $itemD[0];
    $NewVeci = VecMultMatrix($VecLi[0], $m);
    xform -ws -t ($NewVeci.x) ($NewVeci.y) ($NewVeci.z) $itemD[0];
    }

    proc TransformRelByMatrixXformM(matrix $m[][], string $itemA[]){
    $VecLi = PointArrayT($itemA);
    $count = 0;
    for($item in $itemA){
    $itemD  = `duplicate -rr $item`;
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    (0) (0) (0) (1) $itemD[0];
    $NewVeci = VecMultMatrix($NewVeci, $m);
    xform -ws -t ($NewVeci.x) ($NewVeci.y) ($NewVeci.z) $itemD[0];
    $count++;
    }
    }

    proc TransformItemByMatrixXform(matrix $m[][], string $item){
    $itemD = `duplicate -rr $item`;
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $itemD[0];
    }
    proc TransformItemByMatrixXformObjSpace(matrix $m[][], string $item){
    $itemD = `duplicate -rr $item`;
    xform -os -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $itemD[0];
    }


    //////////////////






    //LOCcurve268END
    //LOCcurve208END



    //////////////////
    /// StereoCurveZ($StereoCurveZ[0], $StereoCurveZ[1]);
    //modifySelectedCurves smooth 18 0;
    /////////////////////////////////////////////////////////////////////


    /*

    //////////////////////////////////////////////////////////////////////
    proc string AverageANdCLoseSketchFittingCircle(string $curveItemC){
    ///////////////////////////////
    $CurveItemZai[0] = $curveItemC;
    $Arc = `arclen $CurveItemZai[0]`;
    $Arc = $Arc /3.5;
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s $Arc -d 3 -tol 0.05 $CurveItemZai[0];
    $curvesZi = $CurveItemZai[0];
    $CurveCollectVec = CurvatureUtilityAngles($curvesZi, 130, $angleZi, $TotalDegi,$Low_X, $TrackC);
    clear $NewIndex;
    $NewIndex  = SortNumbersIntIndex($angleZi);
    $nevVec = NewVecOrderWithINTKey($NewIndex,$CurveCollectVec);
    $vectorZnewX =$nevVec;
    $Xv = 0;
    while($Xv < 22){
    $vectorZnewX = AverageCurveVec($vectorZnewX);
    $Xv++;
    }
    $TestCurveC = VecArrayToCurveB($vectorZnewX);
    ResetTransEachSL;
    // Error: line 70: No object matches name: layer1 //
    createDisplayLayer -name "layer1" -number 1 -empty;
    // Problem with return values above N kinds.. maya errors
    ////////////////////////////////////////////////



    $OneCurve = `ls -sl`;
    $OneCurveS = $OneCurve[0];
    $TFNS = 1;
    $CurveNS = IScircleTF($OneCurveS,$TFNS);
    print $TFNS;


    if($TFNS==1){
    $NewOneCurveS = EllipesSketchFitting($CurveNS, $EmptyVectorArrayA);
    }else{  $NewOneCurveS = $OneCurveS;}

    print $EmptyVectorArrayA;

    select -r $NewOneCurveS;


    $Ellipes_A = `xform -q -ws -t $NewOneCurveS`;



    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);

    Loc $MidEpipolPosFCam;


    for($EachVec in $EmptyVectorArrayA){

    //if line betweens average centor  is not the line between N vec point from curve find its angle becuase if the vector point on curve
    // if it happens to be exactly on the line i would be tring to find the angle  of three point of a line which is zero........

    $AngleX[`size($AngleX)`] = AngleofTwoLines($EachVec,$MidEpipolPosFCam,$Ellipes_A ,$MidEpipolPosFCam);


    }

    clear $NewIndex;
    $NewIndex  = SortNumbersIntIndex($AngleX);

    Loc  $EmptyVectorArrayA[$NewIndex[0]];
    Loc  $EmptyVectorArrayA[$NewIndex[1]];

    $IndexTrack = $NewIndex;
    $IndexTrack = ReverseIntArray($IndexTrack);
    Loc  $EmptyVectorArrayA[$IndexTrack[0]];
    Loc  $EmptyVectorArrayA[$IndexTrack[1]];

    print $IndexTrack[0]
    161;

    print $AngleX;




    */



    // need for some reason
    createDisplayLayer -name "layer1" -number 1 -empty;

    proc float AngleofTwoLines(vector $vecA,vector $vecB,vector $vecC,vector $vecD){
    $AngleB = EulerAngB((DirectionFN($vecA, $vecB)), (DirectionFN($vecC, $vecD)));
    $angleA = $AngleB[3];
    return $angleA;
    }





    proc CurvesToPlane(string $CurveItemZ[]){
    global string $PlaneCurveS[];
    $PCurvesName = "Plane";
    $CountN = 0;
    for ($eachCurve in $CurveItemZ){
    clear $AllLocPositionsZ;
    $AllLocPositionsZ = VecCurveEps( $eachCurve );
    $AllPlaneLocPositionZ = VecPointsToCameraPlane($AllLocPositionsZ);
    $newPlaneCurve = VecArrayToCurve($AllPlaneLocPositionZ);
    //$Combine = ($PCurvesName+$eachCurve);
    //$newPlaneCurve = `rename $newPlaneCurve  $Combine`;
    ResetTranslation({$newPlaneCurve});
    $PlaneCurvA[$CountN]= $newPlaneCurve;
    $CountN++;
    }
    $PlaneCurveS = $PlaneCurvA;

    }

    /*
    global string $PlaneCurveS[];

    $LayerCurvesRangeA = `queryLayerRangeMembers`;
    CurvesToPlane($LayerCurvesRangeA);
    select -r $PlaneCurveS;

    //setAttr "locator1.scaleX" 0.085;
    */

    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;



    proc StereoCurveZ(string $CurveItemZai, string $CurveItemZbi){

    /*
    temp debug

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemZai );

    $AverageVecCurve = AverageVectorPoint($PositionsZ_A);
    Loc $AverageVecCurve;
    $CamDirVecNormalA = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);



    $TrueorFalseCircle = `IsCircle`;
    if ($TrueorFalseCircle == 1){
    $newCircle = `MakeCIRCLE($StereoCurveZ)`;
    }
    //////////////////////////////////////////////////////////////

    $StereoCurveZ= `ls -sl`;
    $CurveItemZai = $StereoCurveZ[0];
    $CurveItemZbi = $StereoCurveZ[1];

    global string $PlaneCurveS[];

    $LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;

    CurvesToPlane($LayerCurvesRangeA);
    select -r $PlaneCurveS;

    clear $AllLocPositionsZi;
    $AllLocPositionsZi = VecCurveEps( $eachCurve );



    */


    global string $StereoCurveZ[];
    global string $VanishingPointsLinesTempGuides[];
    global int $addNumbersA;
    global float $VanishingPointGlobal[];

    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;


    $VecCurEndsa = VecCurveEnds({$CurveItemZai});
    $VecCurEndsb = VecCurveEnds({$CurveItemZbi});

    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 1 -tol 0.05 $CurveItemZai;
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 1 -tol 0.05 $CurveItemZbi;
    //gathering all Curve Points

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemZai );
    clear $PositionsZ_B;
    $PositionsZ_B = VecCurveEps($CurveItemZbi );

    // mirroring across ZY plane or X axis
    clear $VecPtsMirrorA;
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    clear $VecPtsMirrorB;
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
    $CamDirVecNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $MultDirCam = multiplyFloat(-1, $CamDirVecNormal);
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;

    clear $VecPtsMirrorEnds_A;
    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    clear $VecPtsMirrorEnds_B;
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);

    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);

    //Key Element
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);

    // Loc $MidEpipolPosFCam;
    // Loc $CamPos_A;

    $EpipolPosCamM = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;
    //float $MidPosFCam[]= FloatPointsToCamPlane($centerCam);
    $MidPosFCam = $CamPlane1;

    $FloatDirEpipol = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    $FloatDirEpipolB = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);

    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    //Loc $PlaneEpipolXx;
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    //Loc $PlaneEpipolYx;
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);
    //Loc $PlaneEpipolZx;

    // The end Points of the first curve Drawn to the Epipol of CAMERA one //##
    $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
    $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);

    // Loc $PointN_Epi;
    // Loc $PointN_EpiB;
    //Loc $VecCurEndsb[0];


    //below I use a if statement to weigh if the two curves start and end points are corrosponding to its mirror symetry
    $DistTOEpipol_CurEndA = distance2Pts($PointN_Epi, $VecCurEndsb[0]);
    $DistTOEpipol_CurEndB = distance2Pts($PointN_EpiB, $VecCurEndsb[0]);

    // if( $DistTOEpipol_CurEndA > $DistTOEpipol_CurEndB){ //

    //curve2points ($PointN_Epi, $VecCurEndsb[0]);
    //curve2points ($PointN_EpiB, $VecCurEndsb[0]);

    $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
    $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
    $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;


    $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
    // $BCurEndBNN -= $BCurEndBiiAdd ;
    $BCDiff = abs($BCurEndB - $BCurEndBNN);


    $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd ;
    $BCDiffi = abs($BCurEndB - $BCurEndBNNi);
    //int $IntIfNearZero = equivalentTol($BCurEndB, $BCurEndBNNi,  0.0001);
    $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);

    //Loc $PointN_Epi;
    //Loc $PointN_EpiB;

    $FloatDirEndPtsA = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
    $EulerAngleA = EulerAngB($FloatDirEndPtsA, $FloatDirEpipol);
    $EulerAngle_A = $EulerAngleA[3];
    $FloatDirEndPtsB = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
    $EulerAngleB = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);
    $EulerAngle_B = $EulerAngleB[3];

    $FloatDirEndPtsAi = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
    $EulerAngleAi = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);
    $EulerAngle_Ai = $EulerAngleAi[3];
    $FloatDirEndPtsBi = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
    $EulerAngleBi = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);
    $EulerAngle_Bi = $EulerAngleBi[3];

    print ($EulerAngle_A+"\n");
    print ($EulerAngle_B+"\n");
    print ($EulerAngle_Ai+"\n");
    print ($EulerAngle_Bi+"\n");

    $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
    $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;


    $Vecbv  = $VecCurEndsa;
    $Vecbvi = $VecCurEndsb;
    $IfTrue = FindLineCross( $Vecbv , $Vecbvi );
    $weighedtFindings = 0;
    $weighedtFindingsZ = 0;
    $weighedtFindingsN = 0;


    if($IfTrue==0){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;
    }



    if($IntIfNearZero==1){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}


    if($EulerAngle_AB<$EulerAngle_AiBi){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}

    print ($weighedtFindings+"\n");
    print ($weighedtFindingsZ+"\n");
    print ($weighedtFindingsN+"\n");

    ////////////////PLace find otrtho Curve here


    $LengCRV_a = `arclen $CurveItemZai`;

    $CRV_ENDSi = $VecCurEndsa;
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $PerDiff = percent_of( $LengCRV_a, $DistEndsi);

    $LengCRV_b = `arclen $CurveItemZbi`;
    $CRV_ENDSii = $VecCurEndsb;
    $DistEndsii = distance2Pts($CRV_ENDSii[0], $CRV_ENDSii[1]);
    $PerDiffii = percent_of( $LengCRV_b, $DistEndsii);

    $PerDiffSum = ($PerDiff+$PerDiffii)/2.0;
    $triggerStraitCRV = 0;

    //START of StraitCurve//

    if( $PerDiffSum<5.5){

    $triggerStraitCRV=1;


    $DDirEpipol = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
    $MidCurveA = MidPoint($VecCurEndsa[0], $VecCurEndsa[1]);
    $MidCurveB = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);

    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);


    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);

    //PositiveDirectionLine
    //    Loc $MidEpipolPosFCam;
    //$VecCurEndsa


    $EpipolD = $DDirEpipolXYZ;

    $Trueii = 0;
    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    //print $IsOrthoLineTrue;
    //print $AxisOrthoLine;
    //print $LineMidi;
    //print $NewDirZi;
    //found Direction

    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];


    if($IsOrthoLineTrue==1){


    $NewVecENDsi  = makeCurvePointDirectionLengthN($DistEndsi, $NewDirZi, $MidCurveA);
    //delete;

    $VecCurEndsa[0] = $NewVecENDsi[0];
    $VecCurEndsa[1] = $NewVecENDsi[1];

    if($AxisOrthoLine!=0){

    $FloatDirEpipol = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    $FloatDirEpipolB= DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
    //float $DistEndsii = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    $MidCurveB = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);

    $DDirEpipolB = DirectionFN($MidCurveB, $FoundEpipol);
    $DDirEpipolA = DirectionFN($FoundEpipol,$MidCurveB);


    $Intersect_LineB_a = FloatToVec (lineIntersection($MidCurveB, $DDirEpipolB, $VecCurEndsa[0],$FloatDirEpipol));
    $Intersect_LineB_b = FloatToVec (lineIntersection($MidCurveB, $DDirEpipolA, $VecCurEndsa[1],$FloatDirEpipolB));
    //Loc $Intersect_LineB_a;
    //Loc $Intersect_LineB_b;

    $VecCurEndsb[0] = $Intersect_LineB_a;
    $VecCurEndsb[1] = $Intersect_LineB_b;

    clear $PositionsZ_A;
    clear $PositionsZ_B;
    clear $VecPtsMirrorEnds_A;
    clear $VecPtsMirrorEnds_B;
    clear $VecPtsMirrorA;
    clear $VecPtsMirrorB;

    $PositionsZ_A[0] =  $NewVecENDsi[0];
    $PositionsZ_A[1]= FloatToVec (MidPoint($NewVecENDsi[0],$NewVecENDsi[1]));
    $PositionsZ_A[2] =  $NewVecENDsi[1];

    $PositionsZ_B[0] =  $Intersect_LineB_a;
    $PositionsZ_B[1]= FloatToVec (MidPoint($Intersect_LineB_a, $Intersect_LineB_b));
    $PositionsZ_B[2] =  $Intersect_LineB_b;

    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);

    }



    }
    }

    if($weighedtFindingsZ<$weighedtFindingsN){

    cycleBackgroundColor;
    //reverseCurve  -ch 0 -rpo 1 -cos on $CurveItemZai;
    //$VecCurEndsa = ReverseVectorArray($VecCurEndsa);
    $PositionsZ_B = ReverseVectorArray($PositionsZ_B);
    // $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
    $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);

    }




    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;

    clear $IntersectEnds_A;
    $iia = 0;
    clear $Intersect_A;
    clear $Intersect_ATwo;
    clear $IntersectForce_A;
    clear $IntersectAverage_A;



    if(`size( $queryLocCurveEnds3D)`>3){

    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);

    for ($eachVecx in  $VecCurEndsa)
    {

    $IntersectEnds_A[$iia] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsa[$iia], $CamPos_M, $VecPtsMirrorEnds_B[$iia]));
    $iia++;
    }

    ///////// find nearest for both curve ends on one curve with those two points they become four points mirrored X

    $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[0]);
    $AllLocsi = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    $AllLocs_String = IntArrayToStringArray($AllLocsi);
    $newOrdersZA = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    $EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
    $New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
    $Near_index_A = $New_AllLocs_A[0];
    $Distance_A = $distToCurveE_A[$Near_index_A];
    $Found_pt_A = $LocCurveEndsVec3D[$Near_index_A];
    $newOrdersZAM = $Found_pt_A;
    $newOrdersZAM[0] = $Found_pt_A[0] *-1;

    $distToCurveE_B = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[1]);
    $newOrdersZB = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    $EmptyStringNewOrderB = ReverseStringArray($EmptyStringNewOrderB);
    $New_AllLocs_B = ArrayToIntList($EmptyStringNewOrderB);
    $Near_index_B = $New_AllLocs_B[0];
    $Distance_B = $distToCurveE_B[$Near_index_B];
    $Found_pt_B = $LocCurveEndsVec3D[$Near_index_B];
    $newOrdersZBM = $Found_pt_B;
    $newOrdersZBM[0] = $Found_pt_B[0] *-1;

    $PointsA[0] = FloatToVec($Found_pt_A);
    $PointsA[1] = FloatToVec($Found_pt_B);
    $PointsB[0] = FloatToVec($newOrdersZAM); // negative mirror of first endpoint of first curve
    $PointsB[1] = FloatToVec($newOrdersZBM);
    // vec points to plane
    //them matrix transformation
    //  know that the camera may be in the positive or negative x axis ... try to make it so that
    //  it will not matter what order  the curve is drawn for the first curve might represent the positive axis or
    // the negitive where is the camera is what you know first  .. what you know second is what the first curve represents
    //Loc $PointsA[0];


    $VecOnPlaneA = VecPointsToCameraPlane($PointsA);
    $VecOnPlaneB = VecPointsToCameraPlane($PointsB);

    //print $Distance_A;
    //print $Distance_B;

    $triggerNoTrans = 0;

    $NewFoundLocs[0] = $queryLocCurveEnds3D[$Near_index_A];
    $NewFoundLocs[1] = $queryLocCurveEnds3D[$Near_index_B];
    $arrayCurvesNear[0] = ("Plane"+$NewFoundLocs[0]);
    $arrayCurvesNear[1] = ("Plane"+$NewFoundLocs[1]);
    $NewFoundLocs = $arrayCurvesNear;

    $LocOnPlaneVec = PointArray($NewFoundLocs);
    $distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocOnPlaneVec[0]);
    $distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocOnPlaneVec[1]);
    print $distToPlaneLoc;



    //if($distToPlaneLoc[0]<0.0025){

    if(!($Distance_A<2.0005)){
    //if((!($Distance_B<1.0005))&&(!($distToPlaneLoc[1]<0.00195))){
    $VecOnPlaneA[0] = $VecCurEndsa[0];
    $VecOnPlaneB[0] = $VecCurEndsb[0];
    PAUSE;
    $triggerNoTrans++;
    }

    //}

    //if($distToPlaneLoc[1]<0.0025){

    if(!($Distance_B<2.0005)){
    //if((!($Distance_B<1.0005))&&(!($distToPlaneLoc[1]<0.00195))){
    $VecOnPlaneA[1] = $VecCurEndsa[1];
    $VecOnPlaneB[1] = $VecCurEndsb[1];
    PAUSE;
    $triggerNoTrans++;
    }

    //}


    if($triggerNoTrans!=2){

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemZai );



    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEndsa,$VecOnPlaneA, $PositionsZ_A);



    $PositionsZ_Bi = Matrix_Curve_TranslationCC($VecCurEndsb, $VecOnPlaneB, $PositionsZ_B);




    clear $VecPtsMirrorA;
    $VecPtsMirrorA= VecPtsToZMirrorPts( $PositionsZ_Ai);
    clear $VecPtsMirrorB;
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_Bi);
    $PositionsZ_A = $PositionsZ_Ai;
    $PositionsZ_B = $PositionsZ_Bi;
    cycleBackgroundColor;
    }

    }


    //////////////////////////////////////////////////////////////////////////////////////
    //Closest Point to Line !! is you want to make it more true to the curve drawn.
    //cool!
    ///////////////      ///////////////
    ///////////////      ///////////////

    //$IntersectEnds_A[$iia] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsa[$iia], $CamPos_M, $VecPtsMirrorEnds_B[$iia]));
    //ADDED
    //$PointToCamDir = DirectionFN($CamPos_A, $VecCurEndsa[$iia]);

    //$IntersectForce_A[$iia] = FloatToVec (ClosestPoint2Line($PointToCamDir, $CamPos_A,  $IntersectEnds_A[$iia]));
    //$Intersect_ATwo[0] = $IntersectEnds_A[$iia];
    //$Intersect_ATwo[1] = $IntersectForce_A[$iia];
    //$IntersectAverage_A[$iia] =  FloatToVec(AverageVectorPoint($Intersect_ATwo));
    ///
    //$iia++;


    $iiz = 0;
    clear $IntersectEnds_A;
    $iia = 0;
    clear $Intersect_A;
    clear $Intersect_ATwo;
    clear $IntersectForce_A;
    clear $IntersectAverage_A;


    $colori[`size($colori)`] = 13;
    $colori[`size($colori)`] = 14;


    for ($eachVecx in  $VecPtsMirrorA)
    {
    $Intersect_A[`size($Intersect_A)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_B[$iiz], $CamPos_M, $VecPtsMirrorA[$iiz]));
    //DEMO
    if((fmod($iiz, 12))== 2){
    curve2points($PositionsZ_B[$iiz], $Intersect_A[`size($Intersect_A)`-1]);
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[0]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    curve2points($VecPtsMirrorA[$iiz], $Intersect_A[`size($Intersect_A)`-1]);
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[1]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    }

    $iiz++;
    }


    delete $AllCirTemp;

    $ThefirstCurve = VecArrayToCurve($Intersect_A);
    //string $ThefirstCurve = VecArrayToCurve($IntersectAverage_A);
    modifySelectedCurves smooth 18 0;
    //  string $NewCurveA[] = SmoothCurvature3(6);
    //rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 28 -d 1 -tol 0.05 $ThefirstCurve;
    ///////////////
    /*
    $iiz = 0;
    clear $Intersect_B;
    /////
    ////////
    for ($eachVecxi in  $VecPtsMirrorA)
    {
    $Intersect_B[`size($Intersect_B)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_A[$iiz], $CamPos_M,   $VecPtsMirrorB[$iiz]));
    $iiz++;
    }
    */
    clear $Intersect_B;
    $Intersect_B= VecPtsToZMirrorPts($Intersect_A);
    $ThefirstCurvei = VecArrayToCurve($Intersect_B);
    modifySelectedCurves smooth 18 0;
    // string $NewCurveB[] = SmoothCurvature3(6);
    //rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 28 -d 1 -tol 0.05 $ThefirstCurvei;
    ///////////////      ///////////////
    ///////////////      ///////////////
    //offsetCurve  -ch on -rn false -cb 2 -st true -cl true -cr 0 -d 1 -tol 0.01 -sd 5 -ugn false  $ThefirstCurve ;
    //offsetCurve  -ch on -rn false -cb 2 -st true -cl true -cr 0 -d 1 -tol 0.01 -sd 5 -ugn false  $ThefirstCurvei ;

    delete $VanishingPointsLinesTempGuides;
    clear $VanishingPointsLinesTempGuides;
    delete $CurveItemZai $CurveItemZbi;
    clear $StereoCurveZ;
    $addNumbersA =0;
    clear $VanishingPointGlobal;
    ResetTranslation({$ThefirstCurve});
    CurveIndexVecTracking({$ThefirstCurve});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1
    $ThefirstCurve;
    ResetTranslation({$ThefirstCurvei});
    CurveIndexVecTracking({$ThefirstCurvei});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1
    $ThefirstCurvei;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    }

    //getAttr "ZCURVEModelingCAMShape.centerOfInterest" 559.102043;
    //-worldCenterOfInterest

    //getAttr "ZCURVEModelingCAMShape.worldCenterOfInterest"
    //camera -q -worldCenterOfInterest "ZCURVEModelingCAMShape"
    //////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    /*
    temp debug

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemZai );

    $AverageVecCurve = AverageVectorPoint($PositionsZ_A);
    Loc $AverageVecCurve;
    $CamDirVecNormalA = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);



    $TrueorFalseCircle = `IsCircle`;
    if ($TrueorFalseCircle == 1){
    $newCircle = `MakeCIRCLE($StereoCurveZ)`;
    }
    //////////////////////////////////////////////////////////////

    proc string CreateCrvInter( string $crv1, string $crv2,
    {
    // Create the intersect node
    $intersectNode = `createNode curveIntersect`;
    setAttr ($intersectNode + ".tolerance") $tolerance;
    connectAttr ($crv1 + ".worldSpace") ($intersectNode + ".inputCurve1");
    connectAttr ($crv2 + ".worldSpace") ($intersectNode + ".inputCurve2");
    setAttr ($intersectNode + ".useDirection") $useDir;
    // Check if there are any intersections.  If not, then delete
    // the node and return nothing.
    //
    $intersections1 = `getAttr ($intersectNode + ".parameter1")`;
    $numIparms = size($intersections1);
    if( $numIparms == 0 ) {
    delete $intersectNode;
    $intersectNode = "";
    } else {
    $intersections2 = `getAttr ($intersectNode + ".parameter2")`;
    }
    // remenber to
    delete $intersectNode;
    return $intersectNode;
    }


    proc int [] CreateCrvInterTF( string $crv1, string $Allcrv2[],
    {

    $TF = 0;
    // Create the intersect node
    for($eachCurve in $Allcrv2){
    $intersectNode = `createNode curveIntersect`;
    setAttr ($intersectNode + ".tolerance") $tolerance;
    connectAttr ($crv1 + ".worldSpace") ($intersectNode + ".inputCurve1");
    connectAttr ($eachCurve + ".worldSpace") ($intersectNode + ".inputCurve2");
    setAttr ($intersectNode + ".useDirection") $useDir;
    // Check if there are any intersections.  If not, then delete
    // the node and return nothing.
    $intersectionsA = `getAttr ($intersectNode + ".parameter1")`;
    $numIparms = size($intersectionsA);
    if( $numIparms == 0 ) {
    $TF=0;
    } else {
    $TF=1;
    $intersections1A = `getAttr ($intersectNode + ".parameter1")`;
    $intersections1B = `getAttr ($intersectNode + ".parameter2")`;
    AppendFloatArray($intersections1,$intersections1A);
    AppendFloatArray($intersections1,$intersections1B);
    print $eachCurve;
    }
    $CurveIndexInter[`size($CurveIndexInter)`] = $TF;
    delete $intersectNode;
    }
    // remenber to

    return $CurveIndexInter;
    }




    $StereoCurveZ= `ls -sl`;
    $CurveItemZai = $StereoCurveZ[0];
    $CurveItemZbi = $StereoCurveZ[1];

    // $VanishingPointsLinesTempGuides = VanishingCurves({$StereoCurveZ[0]});


    global string $PlaneCurveS[];
    $LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;
    CurvesToPlane($LayerCurvesRangeA);
    select -r $PlaneCurveS;

    $NodeCurveIndex = CreateCrvInterTF($CurveItemZai, $PlaneCurveS,0,0.001,$interVecA, $interVecB);
    print $NodeCurveIndex;



    print $TwoCurveA;
    $intersectCURVEiA = `listRelatives -children  $TwoCurveA[0]`;
    $intersectCURVEiB = `listRelatives -children  $TwoCurveA[1]`;

    ///
    $curveIntersectZ = "";
    $curveIntersectZ = `curveIntersect -ch 0 -tolerance 0.00001 $CurveItemZai $CurveItemZbi`;
    $curveIntersectZ = `curveIntersect -ch 0 -tolerance 0.00001 $TwoCurveA[0] $TwoCurveA[1]`;
    $numTokens = `tokenize $curveIntersectZ " "  $buffer`;
    print $buffer;
    $param = eval("paramLocator "+ $TwoCurveA[1] + ".u[" + $buffer[7] + "]");
    $intersectposA = `pointPosition -w  $param`;
    Loc $intersectposA;


    ///

    $paramANDCurve  = `paramToCurvePts2({$param})`;
    delete $param;
    $curvesZ = `detachCurve -ch 1 -cos on -rpo 1  $paramANDCurve`;

    print $NodeCurveA;
    print $NodeCurveA;

    proc float[] NewFloatOrderWithIndexKey(int $IndexTrack[], float $NewFloat[]){
    for($eachV in $IndexTrack){
    $newOrderVec[`size($newOrderVec)`] = $NewFloat[$eachV];
    }
    return $newOrderVec;
    }


    select -r Planecurve12 ;
    select -r curve69 ;

    $intersectNode = `createNode curveIntersect`;
    setAttr ($intersectNode + ".tolerance") 0.001;
    connectAttr ("curve69" + ".worldSpace") ($intersectNode + ".inputCurve1");
    connectAttr ("Planecurve12" + ".worldSpace") ($intersectNode + ".inputCurve2");
    setAttr ($intersectNode + ".useDirection") 0;
    $intersectionsA = `getAttr ($intersectNode + ".parameter2")`;
    $param = eval("paramLocator "+"Planecurve12"+".u["+$intersectionsA[0]+"]");

    */

    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////

    proc int [] CreateCrvInterTF( string $crv1, string $Allcrv2[],
    {

    $TF = 0;
    // Create the intersect node

    $COuntN = 0;
    for($eachCurve in $Allcrv2){
    $intersectNode = `createNode curveIntersect`;
    //listAttr $intersectNode;
    setAttr ($intersectNode + ".tolerance") $tolerance;
    connectAttr ($crv1 + ".worldSpace") ($intersectNode + ".inputCurve1");
    connectAttr ($eachCurve + ".worldSpace") ($intersectNode + ".inputCurve2");
    setAttr ($intersectNode + ".useDirection") $useDir;
    $intersectionsA = `getAttr ($intersectNode + ".parameter1")`;
    $numIparms = size($intersectionsA);
    if( $numIparms == 0 ) {
    $TF=0;
    } else {
    $TF=1;
    $intersections1A = `getAttr ($intersectNode + ".parameter2")`;
    print $intersections1A;
    $FloatSTRING = FloatArrayToStringArray($intersections1A);
    $Ax = stringArrayToString($FloatSTRING, " ");
    /*
    $intersections1A = `getAttr ($intersectNode + ".parameter2")`;
    print $intersections1A;
    $FloatSTRING = FloatArrayToStringArray($intersections1A);
    $Axi = stringArrayToString($FloatSTRING, " ");
    $Ax += (" "+$Axi);
    */
    $intersections1[`size($intersections1)`] = $Ax;
    //AppendFloatArray($intersections1,$intersections1A);
    //print $eachCurve;
    $CurveIndexInter[`size($CurveIndexInter)`] = $COuntN;
    }

    delete $intersectNode;
    $COuntN++;
    }
    // remenber to

    return $CurveIndexInter;
    }

    proc int [] FindEqualVec(vector $VectorA[], vector $Vec){
    $CountN = 0;
    for($eachMvec in $VectorA){
    $CombA = PointsEquivalentTol ($eachMvec, $Vec);
    if($CombA ==3){
    $foundN[`size($foundN)`]= $CountN;
    }
    $CountN++;

    }

    return $foundN;
    }

    proc AppendIntArray(int $ExistingInt[],int $AddtoExistingInt[]){
    for($eachInt in $AddtoExistingInt){
    $ExistingInt[`size($ExistingInt)`]= $eachInt;
    }

    }

    proc AppendFloatArray(float $ExistingF[],float $AddtoExistingF[]){
    for($eachFloat in $AddtoExistingF){
    $ExistingF[`size($ExistingF)`]= $eachFloat;
    }

    }

    proc float [] DistanceSortStereoCrv(float $distToCurveE_A[], vector $LocCurveEndsVec3D[], vector $IntersectEnds_Ai, int $New_AllLocs_AI[] , float $Distance_A){
    $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ai);
    $AllLocsi = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    $AllLocs_String = IntArrayToStringArray($AllLocsi);
    $newOrdersZA = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    $EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
    $New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
    $Near_index_A = $New_AllLocs_A[0];
    $Distance_A = $distToCurveE_A[$Near_index_A];
    $Found_pt_A = $LocCurveEndsVec3D[$Near_index_A];
    $New_AllLocs_AI = $New_AllLocs_A;
    return $Found_pt_A;
    }

    // clear $StereoCurveZ;

    global string $PlaneCurveS[];
    /*

    $StereoCurveZ= `ls -sl`;
    $CurveItemZai = $StereoCurveZ[0];
    $CurveItemZbi = $StereoCurveZ[1];


    */












    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    proc int isCurveEndAtZY(vector $EndVectors[]){
    $Number = 0;
    for($eachVec in $EndVectors){
    $ThreeFs = $eachVec;
    if($ThreeFs[0] == 0){
    $Number++;
    }
    }
    return $Number;
    }

    //CUT CURVE

    /*




    if((fmod($iiz, 12))== 2){
    curve2points($PositionsZ_B[$iiz], $Intersect_A[`size($Intersect_A)`-1]);
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[0]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    curve2points($VecPtsMirrorA[$iiz], $Intersect_A[`size($Intersect_A)`-1]);
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[1]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    }









    if($AddAB==1){

    //START of one End Intersect
    //START of one End Intersect


    if($triggerNoTransA==1){
    $New_AllLocs_AB = $New_AllLocs_A;
    $distToCurveE_AB = $distToCurveE_A;
    }
    if($triggerNoTransB==1){
    $New_AllLocs_AB = $New_AllLocs_B;
    $distToCurveE_AB = $distToCurveE_B;
    }


    $LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;
    $ExpandedString = `sort $ExpandedString`;
    $SortedRangeCrv = `sort $LayerCurvesRangeA`;
    CurvesToPlane($SortedRangeCrv);

    $OffsetTol = 1.0005;
    clear $CollectN_index;

    // index pair of Locs and Curves   $TrackAllExisting3DCrv

    clear $COLLECT_INDEX;
    clear $COLLECTN_INDEX;
    clear $COLLECT_Wanted_INDEX;

    //print $New_AllLocs_AB;
    //print $distToCurveE_AB;
    //print $distToCurveE_AB[$New_AllLocs_AB[0]];

    for($eachIndex in $New_AllLocs_AB){

    $Distance_Aii = $distToCurveE_AB[$eachIndex];
    if($Distance_Aii<=$OffsetTol){
    //print $eachIndex;
    $CollectN_index[`size($CollectN_index)`] =  $eachIndex;
    $COLLECT_INDEX[`size($COLLECT_INDEX)`] = $TrackAllExisting3DCrv[$eachIndex];
    }else{
    $COLLECT_Wanted_INDEX[`size($COLLECT_Wanted_INDEX)`] = $TrackAllExisting3DCrv[$eachIndex];}
    }

    //print $CollectN_index;
    //print $queryLocCurveEnds3D;
    //print $ExpandedString;
    //print $TrackAllExisting3DCrv;
    //print $SortedRangeCrv;
    //print $CollectN_index
    // print size($queryLocCurveEnds3D);
    // print $COLLECT_INDEX;
    // print $COLLECT_Wanted_INDEX;
    // print $ExpandedString;
    //print $COLLECT_Wanted_INDEX;

    clear $ExpandedStringi;
    clear $ExpandedStringiS;
    $Cni = 0;
    for($eachIntCCi in $COLLECT_Wanted_INDEX){
    $ExpandedStringi[$Cni] = $SortedRangeCrv[$eachIntCCi];
    $ExpandedStringiS[$Cni] = $PlaneCurveS[$eachIntCCi];
    $Cni++;
    }

    // print $ExpandedStringi;

    clear $ExpandedStringii;
    clear $ExpandedStringiiS;
    $Cnii = 0;
    for($eachIntCCii in $COLLECT_INDEX){
    $ExpandedStringii[$Cnii] = $SortedRangeCrv[$eachIntCCii];
    $ExpandedStringiiS[$Cnii] = $PlaneCurveS[$eachIntCCii];
    $Cnii++;
    }
    // print $ExpandedStringii;
    // print $COLLECT_INDEX;



    // PROBLEM what if the curve that is draw interesects the curve its end is attached to?.... can fix later if needed

    $diff = stringArrayRemoveDuplicates($ExpandedStringi);
    $diff = stringArrayRemoveExact($ExpandedStringii, $diff);

    $diffS = stringArrayRemoveDuplicates($ExpandedStringiS);
    $diffS = stringArrayRemoveExact($ExpandedStringiiS, $diffS);

    //select -r $ExpandedStringii;
    //select -r $diffS;
    //select -r $diff;
    //PAUSE;
    // print $CollectN_index;
    // print $COLLECT_INDEX;


    clear $LocSMirror;
    for($eachIndex in $CollectN_index){
    $VEcF = $LocCurveEndsVec3D[$eachIndex];
    $VEcF[0] = $VEcF[0]*-1.0;
    $LocSMirror[`size($LocSMirror)`] = FloatToVec($VEcF);
    }
    //////////////////////////////////////////////////////
    //print $LocSMirror;
    // Loc $LocSMirror[0];


    clear $AllM;
    clear $ExistingIntA;
    for($eachFvec in $LocSMirror){
    $AllM = FindEqualVec($LocCurveEndsVec3D, $eachFvec);
    if(`size($AllM)`>0){
    AppendIntArray($ExistingIntA,$AllM);}
    clear $AllM;
    }


    //print $ExistingIntA;
    clear $arrayCurvesNearABM;
    clear $arrayCurvesNearS;

    clear $COLLECT_INDEX_M;
    for($eachIntE in $ExistingIntA){
    $arrayCurvesNearABM[`size($arrayCurvesNearABM)`] = $ExpandedString[$eachIntE];
    $arrayCurvesNearS[`size($arrayCurvesNearS)`] = $PlaneCurveS[$TrackAllExisting3DCrv[$eachIntE]];
    $COLLECT_INDEX_M[`size($COLLECT_INDEX_M)`] = $TrackAllExisting3DCrv[$eachIntE];
    }
    //print $TrackAllExisting3DCrv;
    //print $arrayCurvesNearS;
    //print $arrayCurvesNearABM;
    //print $COLLECT_INDEX_M;
    //print $TrackAllExisting3DCrv;
    //select -r $arrayCurvesNearABM;

    clear $ExpandedStringiim;
    $Cniim = 0;
    for($eachIntCCiim in $COLLECT_INDEX_M){
    $ExpandedStringiim[$Cniim] = $SortedRangeCrv[$eachIntCCiim];
    $Cniim++;
    }
    //print $ExpandedStringiim;
    //print $ExpandedString;

    $diffB = stringArrayRemoveExact($arrayCurvesNearABM, $diff);

    $diffB_s = stringArrayRemoveExact($arrayCurvesNearS, $diffS);

    //select -r $diffB;
    //select -r $diffB_s;
    //PAUSE;

    //////////////////////////////////////////////////////

    clear $interVecAx;
    clear $NodeCurveIndex;
    $NodeCurveIndex = CreateCrvInterTF($CurveItemZai, $diffB_s,0,0.001,$interVecAx);

    //print $interVecAx;
    // select -r $diffB[$NodeCurveIndex[0]];
    //PAUSE; PAUSE;
    //print $NodeCurveIndex;
    //print $interVecAx;

    //select -r $CurveItemZai;


    clear $interVecAy;
    clear $NodeCurveIndexi;
    $NodeCurveIndexi = CreateCrvInterTF($CurveItemZbi, $diffB_s,0,0.001,$interVecAy);
    //print $NodeCurveIndexi;
    // select -r $diffB[$NodeCurveIndexi[0]];
    //PAUSE; PAUSE;
    //////////////////////////////////////////////////////

    if((`size($NodeCurveIndexi)` >0 )&&(`size($NodeCurveIndex)` >0 )){




    clear $VecPointOnCrv;
    $CountPara = 0;
    $CurveSFoundS = `size($NodeCurveIndexi)`;
    //print $diffB;
    for($EachIndC in $NodeCurveIndexi){

    $CURVEiA = `listRelatives -children  $diffB_s[$EachIndC]`;
    $ParaFloat = StringArrayToFloatArray(stringToStringArray($interVecAy[$CountPara], " "));
    if($CountPara>0){
    $ParaSize[$CountPara] = `size($ParaFloat)`+$ParaSize[$CountPara-1];}
    if($CountPara==0){
    $ParaSize[$CountPara] = `size($ParaFloat)`;}
    for($EachPara in $ParaFloat){

    $EveryPara[`size($EveryPara)`] = $EachPara;
    $param = eval("paramLocator "+$CURVEiA[0]+".u["+$EachPara+"]");
    $posA = `pointPosition -w $param`;
    //print $posA;
    $VecPointOnCrv[`size($VecPointOnCrv)`] = FloatToVec($posA);
    delete  $param;
    }
    $CountPara++;

    }


    //for($eachVVec in $VecPointOnCrv){
    //Loc $eachVVec;
    //}

    $distCA = ArrayDistancesVecTofloat($VecPointOnCrv, $UnconnectedEnds[1]);
    $PointOnCrvIND = CreateIntIndex(`size($VecPointOnCrv)`);
    $PointOnCrv_String = IntArrayToStringArray($PointOnCrvIND);
    clear $EmptyCA;
    $newCA = SortFloatArrayAndString($distCA, $PointOnCrv_String, $EmptyCA);
    $EmptyCA = ReverseStringArray($EmptyCA);
    $New_PointOnCrvIND_A = ArrayToIntList($EmptyCA);
    $FOUNDc = $New_PointOnCrvIND_A[0];
    $NearestDistCA = $distCA[$New_PointOnCrvIND_A[0]];
    $NearestVecCA = $VecPointOnCrv[$New_PointOnCrvIND_A[0]];
    //Loc $NearestVecCA;
    //PAUSE;
    $CountWhatCurve = -1;
    //print $ParaSize;
    for($eachIntPara in $ParaSize){
    $CountWhatCurve++;
    if(($ParaSize[$CountWhatCurve]-1)>=$FOUNDc){
    $WhatCurve=$CountWhatCurve;
    break;
    }
    }

    //select -r $diffB_s[$NodeCurveIndexi[$WhatCurve]];
    //PAUSE;

    //print $interVecAx;

    clear $VecPointOnCrvb;
    $CountParab = 0;
    $CurveSFoundSb = `size($NodeCurveIndex)`;
    //print $diffB;
    for($EachIndCb in $NodeCurveIndex){

    $CURVEiAb = `listRelatives -children  $diffB_s[$EachIndCb]`;
    $ParaFloatb = StringArrayToFloatArray(stringToStringArray($interVecAx[$CountParab], " "));
    if($CountParab>0){
    $ParaSizeb[$CountParab] = `size($ParaFloatb)`+$ParaSizeb[$CountParab-1];}
    if($CountParab==0){
    $ParaSizeb[$CountParab] = `size($ParaFloatb)`;}
    for($EachParab in $ParaFloatb){

    $EveryParab[`size($EveryParab)`] = $EachParab;
    $paramb = eval("paramLocator "+$CURVEiAb[0]+".u["+$EachParab+"]");
    $posAb = `pointPosition -w $paramb`;
    //print $posAb;
    $VecPointOnCrvb[`size($VecPointOnCrvb)`] = FloatToVec($posAb);
    delete  $paramb;
    }
    $CountParab++;

    }


    // for($eachVVec in $VecPointOnCrvb){
    // Loc $eachVVec;
    // }

    $distCAb = ArrayDistancesVecTofloat($VecPointOnCrvb, $UnconnectedEnds[0]);
    $PointOnCrvINDb = CreateIntIndex(`size($VecPointOnCrvb)`);
    $PointOnCrv_Stringb = IntArrayToStringArray($PointOnCrvINDb);
    clear $EmptyCAb;
    $newCAb = SortFloatArrayAndString($distCAb, $PointOnCrv_Stringb, $EmptyCAb);
    $EmptyCAb = ReverseStringArray($EmptyCAb);
    $New_PointOnCrvIND_Ab = ArrayToIntList($EmptyCAb);
    $FOUNDcb = $New_PointOnCrvIND_Ab[0];
    $NearestDistCAb = $distCA[$New_PointOnCrvIND_Ab[0]];
    $NearestVecCAb = $VecPointOnCrvb[$New_PointOnCrvIND_Ab[0]];

    //Loc $NearestVecCAb;
    //PAUSE;
    $CountWhatCurveb = -1;
    print $ParaSize;
    for($eachIntParab in $ParaSizeb){
    $CountWhatCurveb++;
    if(($ParaSize[$CountWhatCurve]-1)>=$FOUNDcb){
    $WhatCurveb=$CountWhatCurveb;
    break;
    }
    }

    //select -r $diffB_s[$NodeCurveIndex[$WhatCurveb]];
    //PAUSE;


    ///////////////////////////////////////////////////////////////////
    //select -r $diffB_s[$NodeCurveIndex[$WhatCurveb]];
    //PAUSE;
    //select -r $diffB[$NodeCurveIndex[$WhatCurveb]];
    //PAUSE;
    //select -r $diffB_s[$NodeCurveIndexi[$WhatCurve]];
    //PAUSE;
    //select -r $diffB[$NodeCurveIndexi[$WhatCurve]];
    //PAUSE;




    $CurveA = $diffB[$NodeCurveIndexi[$WhatCurve]];
    $CurveB = $diffB[$NodeCurveIndex[$WhatCurveb]];
    //string $newNamesCA = substituteAllString($CurveA, "Plane", "");
    //string $newNamesCB = substituteAllString($CurveB, "Plane", "");
    $newNamesCA = $CurveA;
    $newNamesCB = $CurveB;
    Loc $NearestVecCA;
    Loc $NearestVecCAb;

    $CUT_CrvMirrorEnds_A = VecPtsToZMirrorPts({$NearestVecCAb});
    $CUT_CrvIntersectEnds_A = FloatToVec (lineIntersectionF($CamPos_A, $NearestVecCA, $CamPos_M, $CUT_CrvMirrorEnds_A[0]));
    $CUT_CrvIntersectMirrorEnds_A = VecPtsToZMirrorPts({$CUT_CrvIntersectEnds_A});


    // this places CUT_CrvIntersectEnds_A the 3d ifnferance Points of the two curve intersection points into the assumed curve end vectors
    // the trigger signifies the vector that which was not connecting directly to another curve end that which the other end will be attached to
    // since the new end of the drawn curve that intersects an existing 3d curve is not drwan with mathmatical percision its intersecting will
    // have a slightly different end
    // if have not gone so far as to program a choice between cutting the drawn vs. shifting the end to meet the found 3d intersecting
    // projected on the plane


    // float $ParaB = $EveryParab[$FOUNDcb];
    // string $selectionItemB = $CurveB + ".u[" + $ParaB + "]";
    // string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $selectionItemB`;

    $myCPOC = `createNode closestPointOnCurve`;
    connectAttr ($newNamesCB+".worldSpace")  ($myCPOC+".inCurve");
    $PointBc = $CUT_CrvIntersectMirrorEnds_A[0];
    $uParam = `closestPointOnCurve -ip $PointBc[0] $PointBc[1] $PointBc[2] -q -paramU $newNamesCB`;
    $paramZ = eval("paramLocator "+$newNamesCB+".u["+$uParam+"]");
    $paramZA = eval("paramLocator "+$newNamesCA+".u["+$uParam+"]");
    delete $myCPOC;


    $selectionItemB = $CurveB + ".u[" +$uParam+ "]";
    $selectionItemA = $CurveA + ".u[" +$uParam+ "]";
    delete  $paramZ;
    delete  $paramZA;
    $detachCurve1 = `detachCurve -ch off - replaceOriginal on $selectionItemB`;
    $detachCurve2 = `detachCurve -ch off - replaceOriginal on $selectionItemA`;

    CurveIndexVecTracking({$detachCurve1[0]});
    CurveIndexVecTracking({$detachCurve2[0]});

    $interposA = `pointPosition -w  $paramZ`;
    $interposB = `pointPosition -w  $paramZA`;
    $VecIntCB = FloatToVec ($interposB);
    $VecIntCA = FloatToVec ($interposA);

    Loc $CUT_CrvIntersectEnds_A;
    Loc $CUT_CrvIntersectMirrorEnds_A[0];

    $VecCUT_CrvA = FloatToVec (FloatPointsToCamPlane($VecIntCB));
    $VecCUT_CrvB = FloatToVec (FloatPointsToCamPlane($VecIntCA));

    if($triggerNoTransENDA==1){
    $VecOnPlaneA[0]= $VecCUT_CrvA;
    $VecOnPlaneB[0]= $VecCUT_CrvB;
    }else{$VecOnPlaneA[1]= $VecCUT_CrvA;
    $VecOnPlaneB[1]= $VecCUT_CrvB;}

    //END of one End Intersect
    //END of one End Intersect
    //END of one End Intersect
    //END of one End Intersect
    //END of one End Intersect

    }
    }
    */

    ///CUT CURVE ^





    // clear $StereoCurveZ;

    /*
    $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[0]);
    $AllLocsi = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    $AllLocs_String = IntArrayToStringArray($AllLocsi);
    $newOrdersZA = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    $EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
    $New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
    $Near_index_A = $New_AllLocs_A[0];
    $Distance_A = $distToCurveE_A[$Near_index_A];
    $Found_pt_A = $LocCurveEndsVec3D[$Near_index_A];
    $newOrdersZAM = $Found_pt_A;
    $newOrdersZAM[0] = $Found_pt_A[0] *-1;

    $distToCurveE_B = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[1]);
    $newOrdersZB = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    $EmptyStringNewOrderB = ReverseStringArray($EmptyStringNewOrderB);
    $New_AllLocs_B = ArrayToIntList($EmptyStringNewOrderB);
    $Near_index_B = $New_AllLocs_B[0];

    $Distance_B = $distToCurveE_B[$Near_index_B];
    $Found_pt_B = $LocCurveEndsVec3D[$Near_index_B];
    $newOrdersZBM = $Found_pt_B;
    $newOrdersZBM[0] = $Found_pt_B[0] *-1;


    */



    //////////////////////


    /*

    // if($EulerAngle_B <$EulerAngle_A ){
    if($BCurEndBiiAdd>$BCDiff){
    if($IntIfNearZero==0){
    //if( $DistTOEpipol_CurEndA > $DistTOEpipol_CurEndB){
    PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
    //if($DistTOEpipol_CurEndA > $DistTOEpipol_CurEndB){
    PAUSE;
    $IfTrue = FindLineCross( $Vecbv , $Vecbvi );
    if($IfTrue==1){
    cycleBackgroundColor;
    //reverseCurve  -ch 0 -rpo 1 -cos on $CurveItemZai;
    //$VecCurEndsa = ReverseVectorArray($VecCurEndsa);
    $PositionsZ_B = ReverseVectorArray($PositionsZ_B);
    // $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
    $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);
    }
    }
    //}
    }
    //}

    if($EulerAngle_B <$EulerAngle_A ){
    if($DistTOEpipol_CurEndA > $DistTOEpipol_CurEndB){
    print "Reverse_it";
    PAUSE;
    makeCurvePointDirectionLength((6), $FloatDirEpipol, $VecCurEndsa[1]);
    PAUSE; PAUSE;
    }
    if($DistTOEpipol_CurEndA>$DistTOEpipol_CurEndB){
    reverseCurve  -ch 0 -rpo 1 -cos on $CurveItemZai;
    }
    if($DistTOEpipol_CurEndA>$DistTOEpipol_CurEndB){
    $VecCurEndsb = ReverseVectorArray($VecCurEndsb);
    $PositionsZ_B = ReverseVectorArray($PositionsZ_B);
    $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
    $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);
    }
    }

    */

    ////////////////////




    proc int  PointsEquivalentTol( float $posA[],  float $posB[]){
    $pX = equivalentTol($posA[0], $posB[0],  0.001);
    $pY = equivalentTol($posA[1], $posB[1],  0.001);
    $pZ = equivalentTol($posA[2], $posB[2],  0.001);
    $addedResults = $pX + $pY + $pZ;
    return $addedResults;
    }


    proc vector ClosestPoint2LineVec(float $DirectionLineF[], float $PointOnLine[], float $PointN[]){
    $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    $VecLineDir = PositiveDir($DirectionLineF);

    $VecLineDirM = $VecLineDiri-$VecLineDir;
    //if on line Result: <<1, 1, 1>>  a point on the line and the point in question directions vector Mult//

    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];

    if($AdditR != 0.0){
    $MultDirOne = multiplyFloat(1.0, $DirectionLineF);
    $AddMultF = AddFloats($PointOnLine, $MultDirOne);
    $FDirNorA = Normal3Points($PointOnLine, $AddMultF, $PointN);
    $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    $MultDirMx = multiplyFloat($DistToLineSTart, $FDirNorA);
    $AddMultMiiFx = AddFloats($PointOnLine, $MultDirMx);
    $FDirNorB = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);
    $MultDirMxz = multiplyFloat($DistToLineSTart,  $FDirNorB);
    $AddMultMiiFxz = AddFloats($PointOnLine, $MultDirMxz);
    $locsA = lineIntersection($PointN, $FDirNorB, $PointOnLine, $DirectionLineF);

    $VlocA = <<$locsA[0],$locsA[1],$locsA[2]>>;
    }else{$VlocA = FloatToVec($PointN);}

    return $VlocA;
    }

    proc vector PointDirTang2LineVec(float $DirectionLineF[], float $PointOnLine[], float $PointN[]){
    $MultDirOne = multiplyFloat(1.0, $DirectionLineF);
    $AddMultF = AddFloats($PointOnLine, $MultDirOne);
    $FDirNorA = Normal3Points($PointOnLine, $AddMultF, $PointN);
    $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    $MultDirMx = multiplyFloat($DistToLineSTart, $FDirNorA);
    $AddMultMiiFx = AddFloats($PointOnLine, $MultDirMx);
    $FDirNorB = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);

    $VlocA = <<$FDirNorB[0],$FDirNorB[1],$FDirNorB[2]>>;

    return $VlocA;
    }

    /*
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    $CircleCenter = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureCenter")`;

    //-curvatureCenter


    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
    << ($norm.x), ($norm.y), ($norm.z) >>`;

    */

    //SmoothCurvature3(6);
    //attachCurveTangent( 1 );

    proc string[] SmoothCurvature3(float $curveM ){
    $curves = `ls -sl`;
    $myCurve = $curves[0];
    //rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    //smoothCurve -ch 0 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 4 );
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0  -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] +  ".translate")`;
    $step = $numEPrealNum2;
    $curve = "curve -d 3";
    $curveMin = $curveM;

    $curve = IteratCurve( $step, $paramlocatorpointOnCurvex, $curveMin, $FindSteps);

    $Newcurvez = `eval($curve)`;

    //rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $Newcurvez;
    $numLength = (`arclen $Newcurvez`) +1;
    $StepZNum = $numLength;
    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    // rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s $StepZNum -d 3 -tol 0.001  $Newcurvez;
    $Newcurve = {$Newcurvez};
    rename $Newcurve $curves;
    $Newcurve = {$curves[0]};
    return $Newcurve;
    }


    proc string IteratCurve(float $step, string $paramlocatorpointOnCurvex, float $curveMin, int $FindSteps){

    $MasterCount = 0;
    $curve = "curve -d 3";



    while ($FindSteps < 4){
    $curve = "curve -d 3";

    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    $CircleCenter = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureCenter")`;
    $tan = `getAttr  ($paramlocatorpointOnCurvex +  ".normal")`;
    $norm = `getAttr  ($paramlocatorpointOnCurvex +  ".tangent")`;
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
    << ($norm.x), ($norm.y), ($norm.z) >>`;


    if ( $CurvatureRadi <=  $curveMin){
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
    if((fmod($CountSteps, 12))== 2){
    $circlesZ[`size($circlesZ)`] = Circles_Direction($CircleCenter, $bi, $CurvatureRadi);
    }
    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    if((fmod($CountSteps, 12))== 2){
    $circlesZ[`size($circlesZ)`] =Circles_Direction($CircleCenter, $bi, $CurvatureRadi);
    }
    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    if((fmod($CountSteps, 12))== 2){
    $circlesZ[`size($circlesZ)`] =Circles_Direction($CircleCenter, $bi, $CurvatureRadi);
    }
    $CountSteps++;
    }
    }
    $FindSteps = $CountSteps;
    if($FindSteps < 4){$curveMin += 8.0; $curve = "curve -d 3"; delete $circlesZ;}
    if($MasterCount== 4){break;}
    $MasterCount++;

    }

    return $curve;
    }

    proc string IteratCurve(float $step, string $paramlocatorpointOnCurvex, float $curveMin, int $FindSteps){

    $MasterCount = 0;
    $curve = "curve -d 3";


    while ($FindSteps < 4){
    $curve = "curve -d 3";

    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;

    if ( $CurvatureRadi <=  $curveMin){
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];

    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];

    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];

    $CountSteps++;
    }
    }
    $FindSteps = $CountSteps;
    if($FindSteps < 10){$curveMin += 18.0; $curve = "curve -d 3";  }
    if($MasterCount== 4){break;}
    $MasterCount++;

    }

    return $curve;
    }

    proc vector [] makeCurvePointDirectionLengthN(float $Length, float $Direction[], float $posA[]){
    $MultDirA = multiplyFloat(($Length/2.0),  $Direction);
    $DirectionN = multiplyFloatArray(-1.0,$Direction);
    $MultDirB = multiplyFloat(($Length/2.0),  $DirectionN);
    $FDirA = AddFloats($posA, $MultDirA);
    $FDirB = AddFloats($posA, $MultDirB);
    $Avec[0]= FloatToVec($FDirA);
    $Avec[1]= FloatToVec($FDirB);
    $CurveBetween = curve2points($FDirA,  $FDirB);
    return $Avec;
    }

    proc vector [] LockEndsAverageCurveVec( vector $newVec[]){

    $range = 3;
    $TotalS = `size($newVec)`;
    $indexState = 0;
    while($indexState<$TotalS){
    $countS=1;
    $Xs=0;
    while($countS<$range){
    $indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
    $indexRight = fmod(($indexState + $countS),$TotalS);
    $indexLeftS[$Xs] = $indexLeft;
    $indexRightS[$Xs]= $indexRight;
    $countS++;
    $Xs++;
    }

    if(($indexState<=2)||($indexState>=($TotalS-3))){
    if($indexState<=2){
    $Aver = (( ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec[$indexState])/2.5;
    $AVvects[$indexState] = $Aver;
    }
    if($indexState>=($TotalS-3)){
    $Aver = (( ($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0))+$newVec[$indexState])/2.5;
    $AVvects[$indexState] = $Aver;
    }
    }else{
    $Aver = ((($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0) + ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec [$indexState])/4.0;
    $AVvects[$indexState] = $Aver;
    }
    clear $indexLeftS;
    clear $indexRightS;
    $indexState++;
    }
    return $AVvects;
    }

    global int $SortDistanceIntG;
    proc vector [] CurvatureUtility(string $curvesZ, int $NumberofSteps, float $curvature[], int $C[], float $TotalCA){
    global int $SortDistanceIntG;
    $step = $NumberofSteps;
    $myCurve = $curvesZ;
    $ii = 0;
    $TotalCAX =0;
    $t=0.0;
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;


    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );

    $CIrceP = `xform -q -ws -t $curvesZ`;
    for($a = 0.0; $t < $numEPrealNum;$a++){

    $t =  $a/$step;
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
    $CRVRadi[$ii] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;



    $DistanceS[$ii] = distance2Pts($values,$CIrceP);

    $ii++;
    }
    $NewIndexN = SortNumbersIntIndex($DistanceS);
    $SortDistanceIntG = $NewIndexN[0];
    delete $paramlocatorpointOnCurvex;

    for($eachCURVA in $CRVRadi){
    $TotalCAX +=  $eachCURVA;
    }
    $TotalCA = $TotalCAX;
    $curvature = $CRVRadi;
    return $CurveVectors;
    }

    proc vector [] AverageCurveVec( vector $newVec[]){

    $range = 3;
    $TotalS = `size($newVec)`;
    $indexState = 0;
    while($indexState<$TotalS){

    $countS=1;
    $Xs=0;
    while($countS<$range){
    $indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
    $indexRight = fmod(($indexState + $countS),$TotalS);
    $indexLeftS[$Xs] = $indexLeft;
    $indexRightS[$Xs]= $indexRight;
    $countS++;
    $Xs++;
    }
    $Aver = ((($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0) + ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec [$indexState])/4.0;
    $AVvects[$indexState] = $Aver;
    clear $indexLeftS;
    clear $indexRightS;
    $indexState++;
    }
    return $AVvects;
    }


    proc string VecArrayToCurveB(vector $FixVec[]){
    $sIZes = `size $FixVec `;
    $NUmers = CreateIntIndex($sIZes);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $K += "\-k"+" "+ $sIZes+" ";
    $sIZes++;
    $K += "\-k"+" "+ $sIZes+" ";
    $curve = "curve -d 3";
    for ($eachVeCx in $FixVec){
    $valuesBi = $eachVeCx;
    $curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    }
    $Newcurvez = `eval($curve)`;
    return $Newcurvez;
    }


    proc vector TwoVecsOrFloats(float $p1p2[], float $p1p3[]){
    $Ui = FloatToVec($p1p2);
    $Vi = FloatToVec($p1p3);
    $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;
    return $VEcLine;
    }

    proc int MostRightClockWiseInt ( vector $Vecs[], int $Two[]){
    $ThreePoints = { "0", "1", "2"};
    $point1 = FloatToVec($Vecs[0]);
    $point2 = FloatToVec($Vecs[1]);
    $point3 = FloatToVec($Vecs[2]);
    $U1 = TwoVecsOrFloats($point2, $point1);
    $V1 = TwoVecsOrFloats($point3, $point1);
    $U2 = TwoVecsOrFloats($point3, $point1);
    $V2 = TwoVecsOrFloats($point2, $point1);
    $U3 = TwoVecsOrFloats($point1, $point3);
    $V3 = TwoVecsOrFloats($point2, $point3);
    clear $normalV;
    $normalV[0] = FloatToVec( crossProduct( $U1, $V1, 0, 1 ) );
    $normalV[1] = FloatToVec( crossProduct( $U2, $V2, 0, 1 ) );
    $normalA = `unit ($normalV[0])`;
    $normalB = `unit ($normalV[1])`;
    $normalAAdd = $normalA[0] + $normalA[1];
    $normalAAdd2 = $normalB[0] + $normalB[1];

    if( $normalAAdd< $normalAAdd2){
    $TwoNew ={$Two[1], $Two[0]};

    }else{
    $TwoNew ={$Two[0], $Two[1]};

    }
    //$Two = $TwoNew;
    return $TwoNew[0];
    }

    proc AppendFloat(float $A[] , float $B[]){
    for($eachF in $B){
    $A[`size($A)`]= $eachF;
    }
    }

    proc float [] CreateIntIndexF(int $ArraySize, float $Fstep){
    $iNdex = 0;
    $AddF = 0;
    while($iNdex < $ArraySize){
    $AddF+= $Fstep;
    $FArrayInex[$iNdex] = $AddF;
    $iNdex++;
    }
    return $FArrayInex;
    }

    proc vector [] calculateEllipseCurve(vector $FixVeci[], float $steps){

    // $a == Major Axis
    // $b == Minor Axis




    $x=8;
    $y=8;
    $z = 8;
    $Lengthi = distance2Pts ($FixVeci[0], $FixVeci[1]);
    $MidPt = MidPoint($FixVeci[0], $FixVeci[1]);
    $FloatDirMajor = DirectionFN($FixVeci[0], $FixVeci[1]);

    $Lengthiii = distance2Pts ($MidPt, $FixVeci[2]);
    $FDirNorAi = Normal3Points($FixVeci[0], $FixVeci[1], $FixVeci[2]);
    $DirNormi = FloatToVec ($FDirNorAi);
    $normal = crossProduct( $FloatDirMajor, $FDirNorAi, 0, 0 );

    matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $norm = FloatToVec($FloatDirMajor);
    $bi = FloatToVec($FDirNorAi);
    $tan = FloatToVec( $normal);
    $MidVec = FloatToVec( $MidPt);
    $LENGTH = $Lengthi/2.0;
    // length times direction add to Point to move it??
    $ABC[0] = $FixVeci[0];
    $ABC[1] = ($tan * $LENGTH)+ $MidVec;
    $ABC[2] = $FixVeci[1];

    $C_radius = Circle3PtsM($ABC[0], $ABC[1], $ABC[2]);
    $ObjsCirclesRad = $C_radius[3];

    $VecLineDir = PositiveDirectionLine($ABC[1],$MidVec);
    $PointN = ClosestPoint2Line($VecLineDir, $FixVeci[2], $MidVec);
    $Di = distance2Pts( $MidVec , $PointN);
    $DiffL = ($ObjsCirclesRad-$Di)*2.0;

    $returnValue = 1;
    if($Di<$ObjsCirclesRad){
    $returnValue =1;}
    if($Di==$ObjsCirclesRad){
    $returnValue =0;}
    if($Di>$ObjsCirclesRad){
    $returnValue =-1;}


    if($returnValue==1){
    $FloatDirXn = DirectionFN( $MidVec, $FixVeci[2]);
    $PointNii = MultLenToDirAddToPoint($Di, DirectionFN( $MidVec, $PointN), $PointN);
    $DistAddiR2 = $Di*2.0;
    $HightD = sqrt (abs ((`pow $Di 2`) - (`pow $ObjsCirclesRad 2`)));
    $PointNiii = MultLenToDirAddToPoint($HightD,($tan), $PointN);
    $PointNiiiB = MultLenToDirAddToPoint($HightD,($tan*-1), $PointN);
    }

    $DiX = distance2Pts( $FixVeci[2] , $PointNiii);
    $DiY = distance2Pts( $FixVeci[2] , $PointNiiiB);
    if($DiX<$DiY){
    $ClosestPoint=$PointNiii;
    }
    if($DiX>$DiY){
    $ClosestPoint=$PointNiiiB;
    }

    $RadiOfOuter = distance2Pts($MidVec, $ClosestPoint);
    $DirRaytoIntersectC  = DirectionFN($MidVec, $ClosestPoint);
    $CircleRayPointN = ClosestPoint2Line($DirRaytoIntersectC, $MidVec, $FixVeci[2]);
    $SecondIntersectCsmall = lineIntersection( $MidVec, $DirRaytoIntersectC, $FixVeci[2], $norm);


    $RadiOfInnerC = distance2Pts($MidVec,$SecondIntersectCsmall);

    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
    ($bi.x),   ($bi.y),   ($bi.z),   0.0;     // Y axis
    ($tan.x),  ($tan.y),  ($tan.z),  0.0;     // Z axis
    $MidPt[0], $MidPt[1], $MidPt[2],     1.0 >>;  // Position
    $MatrizFloati = MatrixToFloat($mI);
    $x = $MidPt[0];
    $y = $MidPt[2];
    $z = $MidPt[1];
    $a = $Lengthi/2.0;

    ////////////////////////
    $b = $RadiOfInnerC;
    ///////////////////////////

    $angle = 0;

    $DirecOfPointABi = FloatToVec ( DirectionFN($FixVeci[0], $FixVeci[1]));
    $curvei = "curve -d 3";
    clear $VecH;
    $vi = 0;
    $Pi = 3.1415926535;

    $VecAngle = VAnglesofThreeVec($MidPt, $FixVeci[1], $FixVeci[2]);

    $beta = `deg_to_rad ($angle)`;
    $sinbeta = sin($beta);
    $cosbeta = cos($beta);
    $valuesiiA = {$x,0.0,$y} ;
    $valuesiAi = {$x, 0, $y} ;
    $valuesiAi = {$x, 0, $y} ;


    for ( $i = 0; $i < 360; $i += 360.0/$steps)
    {
    $alpha = $i * ( $Pi / 180.00) ;
    $sinalpha =  sin($alpha);
    $cosalpha =  cos($alpha);

    $X = $x + ($a * $cosalpha * $cosbeta - $b * $sinalpha * $sinbeta);
    $Y = $y + ($a * $cosalpha * $sinbeta + $b * $sinalpha * $cosbeta);

    $valuesA = {$X, 0, $Y} ;
    $MidTwoDtoElPoint = distance2Pts ($valuesiiA, $valuesA);
    $FloatDirEpoint = DirectionFN($valuesiiA, $valuesA);
    $newLocP = pointMatrixMult(  $FloatDirEpoint, $MatrizFloati );
    $MultDii = multiplyFloat($MidTwoDtoElPoint, $newLocP);
    $AddMepi = AddFloats($MidPt, $MultDii);
    $aV = FloatToVec($valuesA);
    $bV = FloatToVec($valuesiAi);

    $VecH[`size($VecH)`]= `FloatToVec $AddMepi`;

    $curvei += " -p "+$AddMepi[0]+" "+$AddMepi[1]+" "+$AddMepi[2];
    }

    eval($curvei);
    ResetTransEachSL;
    return $VecH;
    }

    global int $TrackDirectionChange;

    proc vector [] CurvatureIsCircleData(string $curvesZ, int $NumberofSteps, float $angleZ[], float $TotalDeg[], int $low, float $C[], float $Ang[]){

    $myCurve = $curvesZ;
    //smoothCurve -ch 0 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($curvesZ);

    $AverageVecCurve = AverageVectorPoint($PositionsZ_A);

    $CIrceP = `xform -q -ws -t $myCurve`;
    $AverageVecCurve =$CIrceP;
    //Loc $AverageVecCurve;
    $VecAverage = FloatToVec($AverageVecCurve);


    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 4 );

    $numEPrealNum2 = $NumberofSteps;
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -top 1 -p $myCurve`;
    $SharpValuesTan[0] = $PositionsZ_A[0];
    $step = $NumberofSteps;
    $Par = 0;
    $StepCycle = 0;
    $ii = 0;
    $iX = 0;
    $Trigger = 0;
    $Lowest = 11110;
    $Past = 0;
    $pastA = 0.0;
    $AddAngles = 0.0;
    $allAngi[`size($allAngi)`] = 0;
    $allAngiX[`size($allAngiX)`] = 0;
    $TwoZeroOne = {0,1};
    $TwoZeroOneT = {0,1};
    $Ct[0] = 0.0;
    $C[0] = 0.0;
    $CN[0] = 0;
    $TF = 0;
    $CountEVEN = 0;
    global int $TrackDirectionChange;
    $TrackDirectionChange=0;

    for($a = 0; $a <= $step;$a++){

    $t =  $a/$step;
    $Par = ($a/$step);

    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $valuesTan[$ii]  = `getAttr  ($paramlocatorpointOnCurvex + ".tangent")`;

    $CurvatureRadi[$ii] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    $valuesXYZ  = {$values[0], $values[1], $values[2]};
    $CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
    $valuesTanSpace[$ii] = $CurveVectors[$ii]+$valuesTan[$ii];

    $FlushVectors[`size($FlushVectors)`] = <<$values[0], $values[1], $values[2]>>;
    $PresentV = FloatToVec($values);

    // creat a vator array thatclears every time it passes 360 deg.. so the last few steps are recored..
    // then take the last angle find the persect it is of 360  divide that by the number of septs then use that as a float step

    if($ii>0){$Past=$ii-1;

    $EachAngle = VAnglesofThreeVec($VecAverage, $PositionsZ_A[0], $CurveVectors[$ii]);
    $threeVecs[0] = $PositionsZ_A[0]; $threeVecs[1] = $VecAverage; $threeVecs[2] = $PresentV;
    $TFmostR = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);

    // for copy past  $valuesTanPastSpace = $valuesTanSpace[$ii];
    $threeVecsT[0] = $valuesTanPastSpace; $threeVecsT[1] = $PastV; $threeVecsT[2] = $PresentV;
    $TFmostRT = MostRightClockWiseInt ($threeVecsT, $TwoZeroOneT);
    $allAngiX[`size($allAngiX)`]= $EachAngle;

    $Ct[$iX] =  $TFmostRT;
    $C[$iX] = $TFmostR;
    if($ii==1){
    $C[$iX-1]= $C[$iX];
    $Ct[$iX-1]= $Ct[$iX];
    $CN[`size($CN)`-1]=$C[$iX];
    $DeepPastTan = $valuesTanPast;
    $DeepPast= $PastV;
    }

    $AngleB = EulerAngB($DeepPastTan, $valuesTan[$ii]);
    $AngleNine = $AngleB[3];
    //if((($AngleNine>82)&&($AngleNine<98))||(($AngleNine>39)&&($AngleNine<51))){

    if($Ct[$iX]==$Ct[$iX-1]){
    if(($AngleNine>82)&&($AngleNine<98)){
    //print ("direction Same "+$AngleNine+"\n");

    $CurrentVecT = $CurveVectors[$ii]+$valuesTan[$ii];
    //Loc $CurrentVecT;

    //Loc $valuesXYZ;
    $SharpValuesTan[`size($SharpValuesTan)`]= FloatToVec (lineIntersectionF($DeepPast, ($DeepPast+$DeepPastTan), $valuesXYZ, $CurrentVecT));
    //Loc $SharpValuesTan[`size($SharpValuesTan)`-1];
    $SharpValuesTan[`size($SharpValuesTan)`]= $CurveVectors[$ii];
    //$SharpValuesTan[`size($SharpValuesTan)`]= $CurrentVecT;

    $DeepPastTan =  $valuesTan[$ii];
    $DeepPast= $CurveVectors[$ii];
    }
    }

    $allAngi[$iX] =$EachAngle;

    if($Trigger== 1){
    $allAngi[$iX] = (abs($pastA - $EachAngle))+$allAngi[$iX-1];
    if($allAngi[$iX]> 360){ $allAngi[$iX]=$EachAngle; $allAngi[$iX-1]=0;  $Trigger= 0; $TF++; }
    }

    if($Ct[$iX]!=$Ct[$iX-1]){
    //means it changed direction left or right from past tangent ..exe: the road that was curved right is now starting to curve left
    $TrackDirectionChange++;
    //print ("Direction CHANGE! "+$AngleNine+"\n");
    $CurrentVecT = $CurveVectors[$ii]+$valuesTan[$ii];
    //Loc $CurrentVecT;
    //Loc $valuesXYZ;
    //Cube $valuesXYZ;


    //if(($AngleNine>82)&&($AngleNine<98)){

    if(!(($AngleNine>135)||($AngleNine==0))){
    $SharpValuesTan[`size($SharpValuesTan)`]= FloatToVec (lineIntersectionF($DeepPast, ($DeepPast+$DeepPastTan), $valuesXYZ, $CurrentVecT));}
    //Loc $SharpValuesTan[`size($SharpValuesTan)`-1];
    $SharpValuesTan[`size($SharpValuesTan)`]= $CurveVectors[$ii];
    $DeepPastTan =  $valuesTan[$ii];
    $DeepPast= $CurveVectors[$ii];

    //}else{ if($AngleNine>90){$SharpValuesTan[`size($SharpValuesTan)`]= $CurveVectors[$ii];
    //	$DeepPastTan =  $valuesTan[$ii];
    //	$DeepPast= $CurveVectors[$ii];
    //}


    }

    if($C[$iX]!=$C[$iX-1]){
    //Loc $valuesXYZ;
    //Loc $valuesTanPast;
    $CN[`size($CN)`]= $iX;
    $CN[`size($CN)`]=$C[$iX];
    $Even_Odd = fmod($CountEVEN,2);
    if($Even_Odd ==1){
    $DistancesCycle[`size($DistancesCycle)`]= distance2Pts ($PositionsZ_A[0], $PresentV);

    }

    $CountEVEN++;
    $angleTii = (180.00- $allAngi[$iX]) +(180.00- $allAngi[$iX-1]);
    $allAngi[$iX] =  $angleTii +$allAngi[$iX-1];
    $Trigger= 1;

    }

    $pastA = $EachAngle;
    $AddAngles+= abs($EachAngle - $allAngiX[`size($allAngiX)`-1]);


    if($allAngi[`size($allAngi)`-1]>=360){
    clear $FlushVectors;
    $StepCycle =  abs ($StepCycle -$a);
    $FXiI = $StepCycle;
    $Fnumbers = 100.0/$FXiI;
    $floatZ = CreateIntIndexF($FXiI, $Fnumbers);
    $StepCycle = $a;
    //Loc $CurveVectors[$ii];
    $AddAngles=0;
    }
    }

    if($StepCycle < $Lowest){
    if($StepCycle!=0){
    $Lowest = $StepCycle;
    }
    }

    $PastV = FloatToVec($values);
    $valuesTanPast = $valuesTan[$ii];
    $valuesTanPastSpace = $valuesTanSpace[$ii];

    $iX++;
    $ii++;



    }

    /////////END of Loop

    $SharpValuesTan[`size($SharpValuesTan)`]= $PastV;

    $CN[`size($CN)`]= $iX;
    $low = $TF;
    $angleZ = $DistancesCycle;
    delete $paramlocatorpointOnCurvex;
    $TotalDeg = $CurvatureRadi;
    $Ang = $allAngiX;

    VecArrayToCurve($SharpValuesTan);
    ResetTransEachSL;
    editDisplayLayerMembers -noRecurse VecToCurve `ls -selection`;
    toggle -editPoint;
    VecArrayToCurveB($SharpValuesTan);
    ResetTransEachSL;
    editDisplayLayerMembers -noRecurse VecToCurveB `ls -selection`;

    return $CurveVectors;

    }

    //////////////////////////////////////

    global float $x0W;
    global float $x1W;
    global float $LearningCoeff;
    global float $Threshold;
    global float $Out;

    proc CPerceptron_CPerceptron(){
    global float $LearningCoeff;
    global float $Threshold;
    global float $x0W;
    global float $x1W;
    //srand((unsigned)(time(NULL)));
    $LearningCoeff = 0.2;
    $Threshold = 0.5;
    $x0W =  (float)(rand(32007))/(32767/2) - 1;
    $x1W =  (float)(rand(32007))/(32767/2) - 1;


    $x0W = 0.1;
    $x1W = 0.1;

    }


    //Setting up parameters
    proc CPerceptron_SetValues(float $x0WeightPar, float $x1WeightPar, float $LearningC, float $Thresh)
    {
    global float $x0W;
    global float $x1W;
    $x0W = $x0WeightPar;
    $x1W = $x1WeightPar;
    $LearningCoeff = $LearningC;
    $Threshold = $Thresh;
    }


    //Training function
    proc float CPerceptron_Train(float $x0, float $x1, float $r)
    {
    global float $x0W;
    global float $x1W;
    global float $LearningCoeff;
    global float $Threshold;
    global float $Out;

    $Sum = ($x0*$x0W)+($x1*$x1W)+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result = Sigmoid($Sum);

    $Out = ($x0*$x0W)+($x1*$x1W);
    if($Out>$Threshold){ $Output = 1.0;
    }else{ $Output = 0.0;}

    $Error = ((float)$r)-($Output);
    $Correction = $LearningCoeff*$Error;

    if($x0==1){ $x0W += $Correction;}
    if($x1==1){ $x1W += $Correction;}
    return $Result;
    }

    //Sigmoid function
    proc float CPerceptron_Sigmoid(float $x){
    $S = (1.0/(1.0+`exp(-$x)`));
    return $S;
    }


    //Get current weight values function
    proc float CPerceptron_Getx0Weight()
    {
    global float $x0W;
    return $x0W;
    }
    proc float CPerceptron_Getx1Weight()
    {
    global float $x1W;
    return $x1W;
    }


    //Run function, return y value
    proc float CPerceptron_Run(float $x0, float $x1)
    {
    global float $x0W;
    global float $x1W;
    global float $Threshold;
    $Sum = ($x0*$x0W)+($x1*$x1W);
    if($Sum>$Threshold){ $Result = 1;
    }else{ $Result = 0;}
    $Result = Sigmoid($Sum);
    return $Result;
    }


    proc float CPerceptron_RunX(float $x0)
    {

    global float $Threshold;
    if($x0>$Threshold){ $Result = 1;
    }else{ $Result = 0;}
    //$Result = Sigmoid($Sum);
    return $Result;
    }

    proc int PrintMod(int $StepN, float $Mod ){
    if ( fmod($StepN, $Mod) == ($Mod-1)  ) {
    return 1;
    }else {return 0;}
    }



    proc float [] GatherDataR(float $Xt[], float $Av){
    for ($eachInt in $Xt){
    if($eachInt > $Av){
    $Vt[`size($Vt)`]= 0;
    }else{$Vt[`size($Vt)`]= 1;}}
    return $Vt;
    }



    proc float [] GatherDataDiff(float $Xt[], float $Av){

    for ($eachInt in $Xt){
    $Vt[`size($Vt)`]= `abs ($Av-$eachInt)`;
    }
    return $Vt;
    }


    proc float AverageFloats(float $FloatArray[]){
    $Ix = 0;
    $AddAll = 0;
    for($eachF in $FloatArray){
    $AddAll+= $eachF;
    $Ix++;
    }
    $Divide = $AddAll/$Ix;
    return $Divide;
    }


    proc float [] AverageFloatArrays(float $FloatArrayA[], float $FloatArrayB[]){
    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = ($eachF + $FloatArrayB[$Ix])/2.0;
    $Ix++;
    }
    return $AddAll;
    }

    proc float [] AddFloatArrays(float $FloatArrayA[], float $FloatArrayB[]){
    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = ($eachF + $FloatArrayB[$Ix]);
    $Ix++;
    }
    return $AddAll;
    }

    proc float [] DivideFloatArrays(float $FloatArrayA[], float $DivideX){
    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] =  $eachF/$DivideX;
    $Ix++;
    }
    return $AddAll;
    }

    proc float [] DiffFloatArrays(float $FloatArrayA[], float $FloatArrayB[]){
    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = abs (($eachF - $FloatArrayB[$Ix]));
    $Ix++;
    }
    return $AddAll;
    }


    proc float PercentDiffZeroOneArrays(float $FloatArrayA[], float $FloatArrayB[]){
    $Ix = 0;
    $Fx = 0.0;
    for($eachF in $FloatArrayA){
    if ($eachF != $FloatArrayB[$Ix]){
    $AddAll+= 1.0;
    }
    $Fx++;
    $Ix++;
    }

    //print ($AddAll +" "+$Fx+"\n");

    if($AddAll != 0){
    $DiffMathA =  $AddAll / ($Fx/100.0);
    }else{ $DiffMathA = 0;}

    return $DiffMathA;
    }




    proc float [] GatherDataC(float $Xt[]){

    $Count = 0;
    $CountP = 0;
    //$Vt[`size($Vt)`] =0;
    for ($eachInt in $Xt){

    if($Count>0){
    if($Xt[$Count-1]!=$Xt[$Count]){

    $Vt[`size($Vt)`]= $CountP;
    $CountP = 0;
    }
    }
    $CountP++;
    $Count++;
    }
    $Vt[`size($Vt)`]= $CountP;

    return $Vt;
    }

    proc int [] GatherData(int $Xt[]){

    if(`size($Xt)`>0){
    return $Xt;
    }
    }
    proc float [] GatherDataF(float $Xt[]){

    if(`size($Xt)`>0){
    return $Xt;
    }
    }


    proc float CPerceptron_TrainX(float $x0, float $x1)
    {

    global float $Threshold;
    $Sum = ($x0)+($x1)+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result = Sigmoid($Sum);
    return $Result;
    }


    //Sigmoid function
    proc float CPerceptron_Sigmoid(float $x){
    $S = (1.0/(1.0+`exp(-$x)`));
    return $S;
    }


    proc float [] GatherDataZeroOne(float $Xt[]){
    $count = 0;
    for ($eachF in $Xt){
    if($eachF == 1){
    $ZO[$count] = 1;
    }
    if($eachF == -1){
    $ZO[$count] = 0;
    }
    $count++;

    }
    return $ZO;
    }


    proc GatherDataRRV(float $Xt[], vector $Pts[]){
    $count = 0;
    for ($eachF in $Xt){
    if($eachF == 1){
    Loc $Pts[$count];
    }
    $count++;

    }
    }




    proc float [] GatherDataRR(float $Xt[], float $Av){
    $count = 0;

    for ($eachF in $Xt){

    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= -1;}

    if($count>0){

    if($PastF<$eachF){
    if($PastF<$Av){
    if(($PastF+$eachF/2.0)<$Av){
    $Vt[$count]= 1; }
    }
    }

    }

    $PastF = $eachF;
    $count++;
    }
    return $Vt;
    }

    proc float [] GatherDataRRZO(float $Xt[], float $Av){
    $count = 0;

    for ($eachF in $Xt){

    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= 0;}

    if($count>0){

    if($PastF<$eachF){
    if($PastF<$Av){
    if(($PastF+$eachF/2.0)<$Av){
    $Vt[$count]= 1; }
    }
    }

    }

    $PastF = $eachF;
    $count++;
    }
    return $Vt;
    }

    proc float [] GatherDataAboveBelowT(float $Xt[], float $Av){
    $count = 0;
    for ($eachF in $Xt){
    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= 0;}
    $count++;
    }
    return $Vt;
    }




    proc float [] CPerceptronZ_Train(float $x0[], float $x1[], float $r)
    {

    global float $x0WX[];
    global float $x1WX[];
    global float $LearningCoeff;
    global float $Threshold;
    global float $Out;


    $Size = size($x0);
    for($i=0; $i<$Size; $i++){
    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i])+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result[$i] = Sigmoid($Sum);

    $Out = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
    if($Out>$Threshold){ $Output = 1.0;
    }else{ $Output = 0.0;}

    $Error = ((float)$r)-($Output);
    $Correction = $LearningCoeff*$Error;

    if($x0[$i]==1){ $x0WX[$i] += $Correction;}
    if($x1[$i]==1){ $x1WX[$i] += $Correction;}

    }

    return $Result;
    }
    /*
    GatherDataF($x1WX);
    9.906

    $Out = (-1*3.01)+(1*3.01);
    if($Out>$Threshold){ $Output = 1.0;
    }else{ $Output = 0.0;}
    print $Output;
    $Error = ((float)0.99)-($Output);
    $Correction = $LearningCoeff*$Error;

    $Sum = (-1*3.01)+(1*3.01)+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    Sigmoid($Sum);

    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1
    print $x1WX[29];
    print $x0WX[29];
    */
    proc float [] CPerceptronZ_TrainX(float $x0[], float $x1[])
    {

    global float $Threshold;
    $Size = size($x0);
    for($i=0; $i<$Size; $i++){
    $Sum = ($x0[$i])+($x1[$i])+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result[$i] = Sigmoid($Sum);
    }
    return $Result;
    }




    proc float [] CPerceptronZ_RunXZ(float $x0[], float $x1[])
    {
    global float $x0WX[];
    global float $x1WX[];
    global float $Threshold;
    $Size = size($x0);

    for($i=0; $i<$Size; $i++){

    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
    if($Sum>$Threshold){ $Result[$i] = 1;
    }else{ $Result[$i] = 0;}
    $Result[$i] = Sigmoid($Sum);
    }
    return $Result;
    }

    proc float [] CPerceptronZ_RunXYZ(float $x0[], float $x1[])
    {
    global float $x0WX[];
    global float $x1WX[];
    global float $Threshold;
    $Size = size($x0);

    for($i=0; $i<$Size; $i++){

    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i])+((-1)*$Threshold);
    $Result[$i] = Sigmoid($Sum);
    }
    return $Result;
    }



    proc float [] CPerceptronZ_RunOUTPUT(float $x0[], float $x1[])
    {
    global float $x0WX[];
    global float $x1WX[];
    global float $Threshold;
    $Size = size($x0);

    for($i=0; $i<$Size; $i++){

    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
    if($Sum>$Threshold){ $Result[$i] = 1;
    }else{ $Result[$i] = 0;}
    $Result[$i] = Sigmoid($Sum);

    }
    return $Result;
    }

    proc float [] Sum_PerceptronZ_TrainX(float $x0[], float $x1[])
    {

    $ThresholdX = 1.5;
    $Size = size($x0);
    for($i=0; $i<$Size; $i++){
    $Sum = ($x0[$i] + $x1[$i] );
    //print ("Sum "+$Sum+"\n");
    if($Sum > $ThresholdX){ $Result[$i] = 1;
    }else{ $Result[$i] = -1;}
    }
    return $Result;
    }
    proc string [] VecArrayToSplitCurve(vector $FixVec[]){

    // the middle curve will always be even!

    $sIZes = `size $FixVec `;
    $evenOdd = fmod($sIZes, 2);

    $sIZesHalf = (($sIZes)/2)+1;
    $NUmers = CreateIntIndex($sIZesHalf);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $countN = 0;
    $curveA = "curve -d 1";
    for ($eachVeCx in $NUmers){
    $valuesBi  = $FixVec[$countN];
    $curveA += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    $countN++;
    }
    $curveA += " "+ $K;
    $curveB = "curve -d 1";
    $countN--;
    for ($eachVeCx in $NUmers){
    $valuesBi  = $FixVec[$countN];
    $curveB += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    $countN++;
    }
    $curveB += " "+ $K;
    $NewcurvezA = `eval($curveA)`;
    $NewcurvezB = `eval($curveB)`;
    $NewcurvezAB = {$NewcurvezA , $NewcurvezB};
    return $NewcurvezAB;
    }

    proc vector [] LineIntersectPlaneCam( vector $Vecii[], float $CamP[], vector $Vec[]){

    $pAv = AverageVectorPoint($Vec);
    $n = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    $CountVV = 0;
    for($eachVecLine in $Vecii){
    $FloatDirA  = DirectionF($eachVecLine, $CamP);
    $FloatDirNormalA = multiplyFloat(2, $FloatDirA);
    $MultDirA = AddFloats( $FloatDirNormalA, $eachVecLine);

    $DistanceLocA = distance2Pts(  $eachVecLine, $pAv);
    $MultDirCam  = multiplyFloat($DistanceLocA, $n);
    $FloatDirectionCamNormalA  = AddFloats($pAv, $MultDirCam);

    $PointN  = ClosestPoint2Line($n, $pAv, $eachVecLine);
    $FloatDirectionAi  = DirectionF($PointN, $pAv);
    $DistanceLoc = distance2Pts( $PointN, $pAv );

    $MultDirPC1  = multiplyFloat($DistanceLoc, $FloatDirectionAi);
    $FloatDirNormalDist  = AddFloats($eachVecLine, $MultDirPC1);
    $PointNii  = ClosestPoint2Line(DirectionF($PointN, $pAv), $eachVecLine, $MultDirA);
    $FloatDirectionAii  = DirectionF($PointNii, $MultDirA);

    $OnPlane[$CountVV] = FloatToVec (lineIntersection( $FloatDirNormalDist, $FloatDirectionAii, $eachVecLine, $FloatDirA));
    //Loc $OnPlane[$CountVV];
    $CountVV++;
    }
    return $OnPlane;
    }

    proc vector FindIfCurveIsOrthoEpipol(vector $EpipolD[], vector $CRV_ENDS[], float $DistEnds, vector $LineMid){

    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;


    // when working with the plane get the vanishing points directions


    if(`size($EpipolD)` == 3){

    //print "EpiPolar";

    $Xdirect = $EpipolD[0];
    $Ydirect = $EpipolD[1];
    $Zdirect = $EpipolD[2];
    }else{
    $Xdirect = << 1,0,0>>;
    $Ydirect = << 0,1,0>>;
    $Zdirect = << 0,0,1>>;
    }

    $XYZdirect[0] = $Xdirect;
    $XYZdirect[1] = $Ydirect;
    $XYZdirect[2] = $Zdirect;


    $LineAMain = PositiveDirectionLine($CRV_ENDS[0], $CRV_ENDS[1]);
    $EulerAngleA  = EulerAngB($Xdirect,$LineAMain);
    $EulerAngleB  = EulerAngB($Ydirect,$LineAMain);
    $EulerAngleC  = EulerAngB($Zdirect,$LineAMain);
    $EulerABCi[0]= $EulerAngleA[3];
    $EulerABCi[1]= $EulerAngleB[3];
    $EulerABCi[2]= $EulerAngleC[3];
    $stringF = FloatArrayToStringArray($EulerABCi);
    clear $EmptyIndx;
    $index = CreateIntIndex(3);
    $stringIndTr = IntArrayToStringArray($index);
    SortFloatArrayAndString( $EulerABCi, $stringIndTr, $EmptyIndx);
    $EmptyIndx = ReverseStringArray($EmptyIndx);
    $xyz = $EmptyIndx[0];
    $AxisOrthoLine = $xyz;
    $Anglei = $EulerABCi[$xyz];
    //print $Anglei;
    $NewDirectionZ = $XYZdirect[$xyz];
    $DistEnds= distance2Pts($CRV_ENDS[0], $CRV_ENDS[1]);
    $LineMid = ($CRV_ENDS[0] + $CRV_ENDS[1])/2.0;
    $AngleEpiPole = $Anglei;

    $isOrthoTrueZi = 0;
    if($Anglei < 8.55){
    $isOrthoTrueZi = 1;
    }
    $IsOrthoLineTrue = $isOrthoTrueZi;
    //print $IsOrthoLineTrue;
    return $NewDirectionZ;
    }




    /*
    $StereoCurveZ= `ls -sl`;
    $CurveItemZai = $StereoCurveZ[0];
    $CurveItemZbi = $StereoCurveZ[1];
    */

    global string $PlaneCurveS[];


    proc StereoCurveZ(string $CurveItemZai, string $CurveItemZbi){
    global string $StereoCurveZ[];
    global string $VanishingPointsLinesTempGuides[];
    global int $addNumbersA;
    global float $VanishingPointGlobal[];
    global string $PlaneCurveS[];
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;
    $SnapR = 1.55;
    $Smooth = 398;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 1 -tol 0.05 $CurveItemZai;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 1 -tol 0.05 $CurveItemZbi;
    clear $AllLocPositionsZi;
    $AllLocPositionsZi = VecCurveCvs( $CurveItemZai);
    $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    ResetTranslation({$newPlaneCurveA});
    delete $CurveItemZai;
    $CurveItemZai = $newPlaneCurveA;
    clear $AllLocPositionsZi;
    $AllLocPositionsZi = VecCurveCvs( $CurveItemZbi);
    $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    ResetTranslation({$newPlaneCurveA});
    delete $CurveItemZbi;
    $CurveItemZbi = $newPlaneCurveA;
    $VecCurEndsa = VecCurveEnds({$CurveItemZai});
    $VecCurEndsb = VecCurveEnds({$CurveItemZbi});
    $StereoCurveZ[0]= $CurveItemZai;
    $StereoCurveZ[1]= $CurveItemZbi;
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveCvs($CurveItemZai );
    clear $PositionsZ_B;
    $PositionsZ_B = VecCurveCvs($CurveItemZbi );
    clear $VecPtsMirrorA;
    clear $VecPtsMirrorB;
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
    $CamDirVecNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $MultDirCam = multiplyFloat(-1, $CamDirVecNormal);
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    clear $VecPtsMirrorEnds_A;

    clear $VecPtsMirrorEnds_B;
    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);
    $EpipolPosCamM = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;
    $MidPosFCam = $CamPlane1;
    $FloatDirEpipol = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    $FloatDirEpipolB = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
    $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
    $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);
    $DistTOEpipol_CurEndA = distance2Pts($PointN_Epi, $VecCurEndsb[0]);
    $DistTOEpipol_CurEndB = distance2Pts($PointN_EpiB, $VecCurEndsb[0]);
    $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
    $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
    $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;
    $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
    $BCDiff = abs($BCurEndB - $BCurEndBNN);
    $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd ;
    $BCDiffi = abs($BCurEndB - $BCurEndBNNi);

    $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);
    $FloatDirEndPtsA = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
    $EulerAngleA = EulerAngB($FloatDirEndPtsA, $FloatDirEpipol);
    $EulerAngle_A = $EulerAngleA[3];
    $FloatDirEndPtsB = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
    $EulerAngleB = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);
    $EulerAngle_B = $EulerAngleB[3];
    $FloatDirEndPtsAi = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
    $EulerAngleAi = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);
    $EulerAngle_Ai = $EulerAngleAi[3];
    $FloatDirEndPtsBi = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
    $EulerAngleBi = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);
    $EulerAngle_Bi = $EulerAngleBi[3];
    $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
    $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;
    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);

    $Vecbv  = $VecCurEndsa;
    $Vecbvi = $VecCurEndsb;
    $IfTrue = FindLineCross( $Vecbv , $Vecbvi );
    $weighedtFindings = 0;
    $weighedtFindingsZ = 0;
    $weighedtFindingsN = 0;
    if($IfTrue=1){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;
    }
    if($IntIfNearZero==1){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}
    if($EulerAngle_AB<$EulerAngle_AiBi){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}

    $LengCRV_a = `arclen $CurveItemZai`;
    $CRV_ENDSi = $VecCurEndsa;
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
    //float $DiffMathA = ($LengCRV_a-$DistEndsi) / ($DistEndsi/100.0);

    $LengCRV_b = `arclen $CurveItemZbi`;
    $CRV_ENDSii = $VecCurEndsb;
    $DistEndsii = distance2Pts($CRV_ENDSii[0], $CRV_ENDSii[1]);
    $DiffMathB = $DistEndsii / ($LengCRV_b/100.0);

    $PerDiffSum = ($DiffMathA+$DiffMathB)/2.0;

    //print (" DiffMathA " +$DiffMathA + " DiffMathB " +$DiffMathB +"\n");
    //if(($DiffMathA> 96.5) && ($DiffMathB > 96.5)){
    //$PerDiffSum =99;
    //}else{$PerDiffSum =1;}

    $triggerStraitCRV = 0;
    $triggerNoTransENDA = 0;
    $triggerNoTransENDB = 0;
    $First_Second_Both_None = 0;
    //print ("START FindIfCurveIsOrthoEpipol" +"\n");
    $XYZdirectL[0] = << 1,0,0>>;
    $XYZdirectL[1] = << 0,1,0>>;
    $XYZdirectL[2] = << 0,0,1>>;
    if( $PerDiffSum>97.05){
    print ("FIST IF : ENGAGED PerDiffSum" +$PerDiffSum +"\n");
    print ("ENGAGED FindIfCurveIsOrthoEpipol" +"\n");
    $triggerStraitCRV=1;
    $DDirEpipol = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
    $MidCurveA  = MidPoint($VecCurEndsa[0], $VecCurEndsa[1]);
    $MidCurveB  = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);
    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);

    $EpipolD = $DDirEpipolXYZ;
    $Trueii = 0;

    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    }


    if($weighedtFindingsZ<$weighedtFindingsN){
    /////////////////////////////REMOVED


    /////////////////////////////
    //if(($DistB<$DistA)||($weighedtFindingsZ<$weighedtFindingsN)){
    if( ($weighedtFindingsZ<$weighedtFindingsN)){

    cycleBackgroundColor;
    $PositionsZ_B = ReverseVectorArray($PositionsZ_B);
    $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);
    $VecCurEndsb = ReverseVectorArray($VecCurEndsb);
    $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
    }
    }


    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
    $queryLocCurveEnds3D = `sort $queryLocCurveEnds3D`;
    $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
    $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
    $TrackAllExisting3DCrv = CreatePairIntIndex($SizeCrvi);
    $LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;
    $SizeCrvR = `size($LayerCurvesRangeA)` ;
    clear $ExpandedString;
    $Cn = 0;
    for($eachIntCC in $TrackAllExisting3DCrv){
    $ExpandedString[$Cn] = $LayerCurvesRangeA[$eachIntCC];
    $Cn++;
    }
    $triggerNoTrans = 0;
    $triggerNoTransA = 0;
    $triggerNoTransB = 0;
    $triggerNoTrans = 0;

    clear $IntersectEnds_Ax;
    $iia = 0;


    $trigger_straitC = 0;
    if(!(`size($queryLocCurveEnds3D)` > 2)){
    print ("ENGAGED PerDiffSum " +$PerDiffSum +"\n");
    if($PerDiffSum >95.05){
    $iis = 0;
    for ($eachVecx in  $VecCurEndsb){
    $XIntersect_Ax[$iis] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsb[$iis], $CamPos_M, $VecPtsMirrorEnds_A[$iis]));
    $iis++;
    }
    $XIntersect_Ax[2] =  $XIntersect_Ax[1];
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    $XIntersect_Ax[0] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[0]);
    $XIntersect_Ax[2] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[2]);
    $PositionsZ_Bii= $XIntersect_Ax;
    $PositionsZ_Aii= VecPtsToZMirrorPts($PositionsZ_Bii);
    $ThefirstCurve = VecArrayToCurve($XIntersect_Ax);
    $PtsMirrorAi= VecPtsToZMirrorPts($XIntersect_Ax);
    $ThefirstCurvei = VecArrayToCurve($PtsMirrorAi);

    $trigger_straitC =1;
    }
    }

    ////////////
    if(`size( $queryLocCurveEnds3D)`>2){

    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);
    for ($eachVecx in  $VecCurEndsa)
    {
    $IntersectEnds_Ax[$iia] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsa[$iia], $CamPos_M, $VecPtsMirrorEnds_B[$iia]));
    $iia++;
    }

    $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[0]);
    $AllLocsi = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    $AllLocs_String = IntArrayToStringArray($AllLocsi);
    $newOrdersZA = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    $EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
    $New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
    $Near_index_A = $New_AllLocs_A[0];
    $Distance_A = $distToCurveE_A[$Near_index_A];
    $Found_pt_A = $LocCurveEndsVec3D[$Near_index_A];
    $newOrdersZAM = $Found_pt_A;
    $newOrdersZAM[0] = $Found_pt_A[0] *-1;
    $distToCurveE_B = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[1]);
    $newOrdersZB = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    $EmptyStringNewOrderB = ReverseStringArray($EmptyStringNewOrderB);
    $New_AllLocs_B = ArrayToIntList($EmptyStringNewOrderB);
    $Near_index_B = $New_AllLocs_B[0];
    $Distance_B = $distToCurveE_B[$Near_index_B];
    $Found_pt_B = $LocCurveEndsVec3D[$Near_index_B];
    $newOrdersZBM = $Found_pt_B;
    $newOrdersZBM[0] = $Found_pt_B[0] *-1;

    $PointsA[0] = FloatToVec($Found_pt_A);
    $PointsA[1] = FloatToVec($Found_pt_B);
    $PointsB[0] = FloatToVec($newOrdersZAM); // negative mirror of first endpoint of first curve
    $PointsB[1] = FloatToVec($newOrdersZBM);

    $VecOnPlaneA = VecPointsToCameraPlane($PointsA);
    $VecOnPlaneB = VecPointsToCameraPlane($PointsB);

    $NewFoundLocs[0] = $queryLocCurveEnds3D[$Near_index_A];
    $NewFoundLocs[1] = $queryLocCurveEnds3D[$Near_index_B];
    $arrayCurvesNear[0] = ("Plane"+$NewFoundLocs[0]);
    $arrayCurvesNear[1] = ("Plane"+$NewFoundLocs[1]);
    $NewFoundLocs = $arrayCurvesNear;
    $LocOnPlaneVec = PointArray($NewFoundLocs);
    $distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocOnPlaneVec[0]);
    $distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocOnPlaneVec[1]);
    $TXI = << -1.0 , 1.0, 1.0>>;
    $LoCz_3D[0] = MultVec($IntersectEnds_Ax[0],$TXI);
    $LoCz_3D[1] = MultVec($IntersectEnds_Ax[1], $TXI);

    ////////////////////////
    $DistToIntersectTOnear[0] = distance2Pts($IntersectEnds_Ax[0], $PointsA[0]);
    $DistToIntersectTOnear[1] = distance2Pts($IntersectEnds_Ax[1], $PointsA[1]);
    $DistToIntersectTOnear[2] = distance2Pts($LoCz_3D[0], $PointsB[0]);
    $DistToIntersectTOnear[3] = distance2Pts($LoCz_3D[1], $PointsB[1]);

    $distToPlaneLoc3D[0] = distance2Pts($VecCurEndsa[0], $PointsA[0]);
    $distToPlaneLoc3D[1] = distance2Pts($VecCurEndsa[1], $PointsA[1]);
    $distToPlaneLoc3D[2] = distance2Pts($VecCurEndsb[0], $PointsB[0]);
    $distToPlaneLoc3D[3] = distance2Pts($VecCurEndsb[1], $PointsB[1]);
    //////////////////////////

    $DiffMathA = $DistToIntersectTOnear[0]/ ($distToPlaneLoc3D[0]/100.0);
    $DiffMathB = $DistToIntersectTOnear[1] / ($distToPlaneLoc3D[1]/100.0);
    $DiffMathAm = $DistToIntersectTOnear[2]/ ($distToPlaneLoc3D[2]/100.0);
    $DiffMathBm = $DistToIntersectTOnear[3] / ($distToPlaneLoc3D[3]/100.0);

    $relativeDistanceA = ($DiffMathA+$DiffMathAm)/2.0;
    $relativeDistanceB = ( $DiffMathB+$DiffMathBm)/2.0;
    /*
    $relativeDistanceAi = ($Distance_A+$distToPlaneLoc[0])/2.0;
    $relativeDistanceBi = ($Distance_B+$distToPlaneLoc[1])/2.0;
    $relativeDistanceAZ = distance2Pts($VecOnPlaneA[0], $PointsA[0]);
    $relativeDistanceBZ = distance2Pts($VecOnPlaneB[0], $PointsB[0]);
    $DiffMathAi = $relativeDistanceAi/ ($relativeDistanceAZ/100.0);
    $DiffMathBi = $relativeDistanceBi / ($relativeDistanceBZ/100.0);
    $TimesMathAi = $relativeDistanceA*$relativeDistanceAZ/ ($distToPlaneLoc3D[0]/100.0);
    $TimesMathBi = $relativeDistanceB*$relativeDistanceBZ/ ($distToPlaneLoc3D[1]/100.0);
    //float $SnapR = 1.95;
    print ("\n");
    print ("relativeDistanceA "+"\n");
    print ($relativeDistanceA+"\n");
    print ("relativeDistanceB "+"\n");
    print ($relativeDistanceB+"\n");
    print ("\n");
    print ("TimesMathA "+"\n");
    print ($TimesMathA+"\n");
    print ("\n");
    print ("TimesMathB "+"\n");
    print ($TimesMathB+"\n");
    print ("\n");
    */

    if($relativeDistanceA<$SnapR){
    $triggerNoTransA++;
    }
    if($relativeDistanceA <$SnapR){
    $triggerNoTransB++;
    }
    if(!($relativeDistanceA<$SnapR)){
    $VecOnPlaneA[0] = $VecCurEndsa[0];
    $VecOnPlaneB[0] = $VecCurEndsb[0];
    $triggerNoTransENDA=1;
    }else{$triggerNoTrans++;
    $First_Second_Both_None =0;
    }		if(!($relativeDistanceB<$SnapR)){
    $VecOnPlaneA[1] = $VecCurEndsa[1];
    $VecOnPlaneB[1] = $VecCurEndsb[1];
    $triggerNoTransENDB=1;
    }else{$triggerNoTrans++;
    $First_Second_Both_None =1;

    if($triggerNoTransENDA==0){ $First_Second_Both_None =-2;}

    }

    if($triggerNoTrans==0){
    $First_Second_Both_None =-1;}

    //if(($triggerNoTransENDA +$triggerNoTransENDB)== 2){
    //}

    //if(($triggerNoTransENDA +$triggerNoTransENDB)== 0){
    //}


    $ConnectedEnds = $triggerNoTransENDA + $triggerNoTransENDB;
    if($triggerNoTransENDA==1){
    $UnconnectedEnds[0]= $VecOnPlaneA[0];
    $UnconnectedEnds[1]= $VecOnPlaneB[0];
    }else{$UnconnectedEnds[0]= $VecOnPlaneA[1];
    $UnconnectedEnds[1]= $VecOnPlaneB[1];}

    clear $arrayCurvesNearA;
    clear $arrayCurvesNearA;
    $AddAB = $triggerNoTransA+$triggerNoTransB;


    if($triggerNoTrans!=0){

    $PositionsZ_A = VecCurveCvs($CurveItemZai );
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEndsa,$VecOnPlaneA, $PositionsZ_A);
    $PositionsZ_Bi = Matrix_Curve_TranslationCC($VecCurEndsb, $VecOnPlaneB, $PositionsZ_B);
    clear $VecPtsMirrorA;
    $VecPtsMirrorA= VecPtsToZMirrorPts( $PositionsZ_Ai);
    clear $VecPtsMirrorB;
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_Bi);
    $PositionsZ_A = $PositionsZ_Ai;
    $PositionsZ_B = $PositionsZ_Bi;
    cycleBackgroundColor;
    }

    }

    //print (" IsOrthoTrueZi Eq  "+$IsOrthoLineTrue +"\n");

    if($triggerNoTrans==0){
    if($PerDiffSum >97.0){

    $iis = 0;
    for ($eachVecx in  $VecCurEndsb){
    $XIntersect_Ax[$iis] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsb[$iis], $CamPos_M, $VecPtsMirrorEnds_A[$iis]));
    $iis++;
    }
    $XIntersect_Ax[2] =  $XIntersect_Ax[1];
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    $XIntersect_Ax[0] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[0]);
    $XIntersect_Ax[2] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[2]);

    $PositionsZ_Bii= $XIntersect_Ax;
    $PositionsZ_Aii= VecPtsToZMirrorPts($PositionsZ_Bii);

    $ThefirstCurve = VecArrayToCurve($XIntersect_Ax);
    $PtsMirrorAi= VecPtsToZMirrorPts($XIntersect_Ax);
    $ThefirstCurvei = VecArrayToCurve($PtsMirrorAi);

    $trigger_straitC =1;
    }
    }


    if($triggerNoTrans!=0){

    //print ("triggerNoTrans Doesnt not Eq ZERO" +"\n");

    if($IsOrthoLineTrue==1){
    //print ("IsOrthoLineTrue Eq ONE" +"\n");

    if($AxisOrthoLine!=0){

    //print ("AxisOrthoLine Doesnt not Eq ZERO" +"\n");

    if($First_Second_Both_None>=0){
    //print ("First_Second_Both_None LESS then ZERO!" +"\n");

    //if($AxisOrthoLine==0){
    if($trigger_straitC==1){

    $FloatDirEpipol = DirectionFN($VecOnPlaneA[$First_Second_Both_None], $FoundEpipol);
    $FloatDirEpipolB= DirectionFN($VecOnPlaneB[$First_Second_Both_None], $FoundEpipol);
    if($AxisOrthoLine==0){
    //print ("AxisOrthoLine Eq ZERO!" +"\n");
    //print ("line ortho Direction same as CAM epipole");

    $lineEPointA = MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);

    $Xdirection = << 1.0,0.0,0.0>>;
    $Intersect_LineB_a = FloatToVec (lineIntersection($PointsA[$First_Second_Both_None], $Xdirection, $lineEPointA,(DirectionFN( $CamPos_A,$lineEPointA)) ));

    $Point3DA = $Intersect_LineB_a;
    $Point3DAM = {($Point3DA[0]*-1), $Point3DA[1],$Point3DA[2]};

    }


    if($First_Second_Both_None==1){
    //print ("First_Second_Both_None Eq ONE! " +"\n");
    $PairInt={0,1};

    }else{ $PairInt={2,3};
    //print ("First_Second_Both_None NOT Eq ONE! " +"\n");
    }

    $Intersect_BX= VecPtsToZMirrorPts($IntersectEnds_Ax);
    $PairVectors[0]=FloatToVec(FloatPointsToCamPlane($IntersectEnds_Ax[0]));
    $PairVectors[1]= FloatToVec(FloatPointsToCamPlane($Intersect_BX[0]));
    $PairVectors[2]=FloatToVec(FloatPointsToCamPlane($IntersectEnds_Ax[1]));
    $PairVectors[3]= FloatToVec(FloatPointsToCamPlane($Intersect_BX[1]));
    $EpipolXLine = DirectionFN( $MidEpipolPosFCam, $PairVectors[$PairInt[0]]) ;

    $Intersect_LineB_a = FloatToVec (lineIntersection($VecOnPlaneA[$First_Second_Both_None], $FloatDirEpipol, $MidEpipolPosFCam,$EpipolXLine));
    //Loc $Intersect_LineB_a;
    $Intersect_LineB_b = FloatToVec (lineIntersection($VecOnPlaneB[$First_Second_Both_None], $FloatDirEpipolB, $MidEpipolPosFCam,$EpipolXLine));
    //Loc $Intersect_LineB_b;

    clear $PositionsZ_A;
    clear $PositionsZ_B;
    clear $VecPtsMirrorEnds_A;
    clear $VecPtsMirrorEnds_B;
    clear $VecPtsMirrorA;
    clear $VecPtsMirrorB;
    $PositionsZ_A[0] =  $VecOnPlaneA[$First_Second_Both_None];
    $PositionsZ_A[1]= FloatToVec (MidPoint($VecOnPlaneA[$First_Second_Both_None],$Intersect_LineB_a));
    $PositionsZ_A[2] =  $Intersect_LineB_a;
    $PositionsZ_B[0] =  $VecOnPlaneB[$First_Second_Both_None];
    $PositionsZ_B[1]= FloatToVec (MidPoint($VecOnPlaneB[$First_Second_Both_None], $Intersect_LineB_b));
    $PositionsZ_B[2] =  $Intersect_LineB_b;
    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
    }
    }
    }
    }
    }


    if($trigger_straitC!=1){
    $iiz = 0;

    for ($eachVecx in  $VecPtsMirrorA)
    {
    $Intersect_A[`size($Intersect_A)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_B[$iiz], $CamPos_M, $VecPtsMirrorA[$iiz]));
    $iiz++;
    }

    $ThefirstCurve = VecArrayToCurve($Intersect_A);
    modifySelectedCurves smooth $Smooth 0;
    $Intersect_B= VecPtsToZMirrorPts($Intersect_A);
    $ThefirstCurvei = VecArrayToCurve($Intersect_B);
    modifySelectedCurves smooth $Smooth 0;
    $EndrEndsa = VecCurveEnds({$ThefirstCurvei});
    $EndsAtZero = isCurveEndAtZY($EndrEndsa);
    $STEPSZ = 200;
    $curvesZi = $ThefirstCurve;
    $curvesZi = CurvatureIsCircleData($curvesZi, $STEPSZ, $angleZi, $TotalDegii, $LowX, $TrackCi, $anglesMade);
    delete $ThefirstCurve;
    $ThefirstCurve = $curvesZi;
    $curvesZii = $ThefirstCurvei;
    $curvesZii = CurvatureIsCircleData($curvesZii, $STEPSZ, $angleZi, $TotalDegii, $LowX, $TrackCi, $anglesMade);
    delete $ThefirstCurvei;
    $ThefirstCurvei = $curvesZii;

    if($EndsAtZero>0){
    sets -include ZEdgeCurvesSet ({$ThefirstCurvei,$ThefirstCurve});
    }

    }
    delete $VanishingPointsLinesTempGuides;
    clear $VanishingPointsLinesTempGuides;
    delete $CurveItemZai $CurveItemZbi;
    clear $StereoCurveZ;
    $addNumbersA =0;
    clear $VanishingPointGlobal;

    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $ThefirstCurve;
    ResetTranslation({$ThefirstCurve});
    CurveIndexVecTracking({$ThefirstCurve});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ThefirstCurve;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $ThefirstCurvei;
    ResetTranslation({$ThefirstCurvei});
    CurveIndexVecTracking({$ThefirstCurvei});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ThefirstCurvei;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    }










    proc int isCurveEndAtZY(vector $EndVectors[]){
    $Number = 0;
    for($eachVec in $EndVectors){
    $ThreeFs = $eachVec;
    if($ThreeFs[0] == 0){
    $Number++;
    }}
    return $Number;
    }



    global int $ifSingleCurve;
    $ifSingleCurve =0;
    createDisplayLayer -name "VanishingPointsLines"  -empty;
    setAttr VanishingPointsLines.visibility 1; setAttr VanishingPointsLines.displayType 0; setAttr VanishingPointsLines.color 0;

    ////////////////////////////////////////////////


    /*
    $OneCurve = `ls -sl`;
    $OneCurveS = $OneCurve[0];
    $TFNS = 1;
    $CurveNS = IScircleTF($OneCurveS,$TFNS);
    print $TFNS;
    if($TFNS==1){
    $NewOneCurveS = EllipesSketchFitting($CurveNS, $EmptyVectorArrayA);
    }else{  $NewOneCurveS = $OneCurveS;}

    $NewArrayAEllipZ = NewVecOrderEllipZ($NewOneCurveS, $EmptyVectorArrayA, $MidEpipolPosFCam);
    $OneCurve = `ls -sl`;
    $NewOneCurveSB = EllipesSketchFitting($OneCurve[0], $EmptyVectorArrayB);
    $NewArrayBEllipZ = NewVecOrderEllipZ($NewOneCurveSB, $EmptyVectorArrayB, $MidEpipolPosFCam);
    $StereoCircle = Eval3DCircleStereo( $NewArrayBEllipZ  , $EmptyVectorArrayB ,  $NewArrayAEllipZ , $EmptyVectorArrayA );

    // print $EmptyVectorArrayA;
    $IndexTrackE = CreateIntIndex(`size($EmptyVectorArrayA)`);
    //select -r $NewOneCurveS;
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);
    // Loc $MidEpipolPosFCam;

    $EllipesPos_A = `xform -q -ws -t $NewOneCurveS`;
    $Dir_VecMAIN =  DirectionFN($MidEpipolPosFCam, $EllipesPos_A);

    $TwoZeroOne = {0,1};
    clear $allAngiX; clear $TFmostRArray;
    $threeVecs[0] = FloatToVec($MidEpipolPosFCam);
    $threeVecs[1] = FloatToVec($EllipesPos_A);

    for($EachVector in $EmptyVectorArrayA){
    $DIff = FindDirectionDiff($Dir_VecMAIN, $MidEpipolPosFCam, $EachVector);
    if($DIff!= 0){
    $allAngiX[`size($allAngiX)`]=  VAnglesofThreeVec($MidEpipolPosFCam, $EllipesPos_A, $EachVector);
    $threeVecs[2] = $EachVector;
    $TFmostRArray[`size($TFmostRArray)`] = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);
    }else{ $allAngiX[`size($allAngiX)`]= 0;  $TFmostRArray[`size($TFmostRArray)`] =0;}
    }

    clear $LargestIntR_KEY;
    clear $LargestIntL_KEY;
    clear $AllAngiX_LEFT;
    clear $AllAngiX_RIGHT;
    $COUNT_Nlr = 0;
    for($EachIntarray in $TFmostRArray){
    if($EachIntarray==1){
    $AllAngiX_RIGHT[`size($AllAngiX_RIGHT)`]= $allAngiX[$COUNT_Nlr];
    $LargestIntR_KEY[`size($LargestIntR_KEY)`]=$COUNT_Nlr;
    }
    if($EachIntarray==0){
    $AllAngiX_LEFT[`size($AllAngiX_LEFT)`]= $allAngiX[$COUNT_Nlr];
    $LargestIntL_KEY[`size($LargestIntL_KEY)`]=$COUNT_Nlr;
    }
    $COUNT_Nlr++;
    }


    $LargestIntR = SortNumbersIntIndex($AllAngiX_RIGHT);
    $LargestIntR = ReverseIntArray($LargestIntR);
    // Loc $EmptyVectorArrayA[$LargestIntR_KEY[$LargestIntR[0]]];
    $LargestIntL = SortNumbersIntIndex($AllAngiX_LEFT);
    $LargestIntL = ReverseIntArray($LargestIntL);
    // Loc $EmptyVectorArrayA[$LargestIntL_KEY[$LargestIntL[0]]];
    print $LargestIntR_KEY[$LargestIntR[0]];
    print $LargestIntL_KEY[$LargestIntL[0]];
    // test int $NewStartInt = $LargestIntL_KEY[$LargestIntL[0]];
    //  $IndexTrackE
    $SizeE = `size($EmptyVectorArrayA)`;
    $Add = 0;
    for($EachIntX in $IndexTrackE){
    $NewArrayIntX[`size($NewArrayIntX)`] = fmod(($NewStartInt+$Add),$SizeE);
    $Add++;
    }

    // just to see the result - $NewArrayIntX = ReverseIntArray($NewArrayIntX);

    $NewArrayAEllipZ = NewVecOrderEllipZ($NewOneCurveS, $EmptyVectorArrayA, $MidEpipolPosFCam);
    $OneCurve = `ls -sl`;
    $NewOneCurveSB = EllipesSketchFitting($OneCurve[0], $EmptyVectorArrayB);
    $NewArrayBEllipZ = NewVecOrderEllipZ($NewOneCurveSB, $EmptyVectorArrayB, $MidEpipolPosFCam);
    $StereoCircle = Eval3DCircleStereo( $NewArrayBEllipZ  , $EmptyVectorArrayB ,  $NewArrayAEllipZ , $EmptyVectorArrayA );



    */








    proc float  FindDirectionDiff(vector $Line_Y_zeroMain, vector $VecCurEndsA, vector $VecCurEndsB){
    $Dir_VecA =  DirectionFN($VecCurEndsA,$VecCurEndsB);
    $VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    return $AdditR;
    }

    global int $ForceOrthoOFFON;
    $ForceOrthoOFFON = 0;


    proc string [] ForceOrtho(string  $CurveItemAX[]){

    // string  $CurveItemAX[] =`ls -sl`;
    global string $StereoCurveZ[];
    global int $addNumbersA;
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;

    //string  $CurveItemAX[] =`ls -sl`;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemAX[0];

    /////////////////////
    $Positions = VecCurveEps($CurveItemAX[0]);
    $TempCrv = VecArrayToCurve($Positions);
    delete $CurveItemAX[0];
    $VecCurEnds = VecCurveEnds({$TempCrv});
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEndsOLD = $queryLocCurveEnds;
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );

    if(`size($queryLocCurveEnds)` >= 2){

    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $distancesEachToCurveB = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);

    $ReducedIndexA = floatArrayCountDuplicates($distancesEachToCurve);
    $ReducedIndexB = floatArrayCountDuplicates($distancesEachToCurveB);
    for($eachInt in $ReducedIndexA){
    $distAz[`size($distAz)`]= $distancesEachToCurve[$eachInt];
    }
    for($eachInt in $ReducedIndexB){
    $distBz[`size($distBz)`]= $distancesEachToCurveB[$eachInt];
    }

    //clear $NearestInt;
    //clear $NearestIntB;
    $NearestInt = SortNumbersIntIndex($distAz);
    $NearestIntB = SortNumbersIntIndex($distBz);

    $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];


    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$ReducedIndexA[$NearestInt[0]]];
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$ReducedIndexB[$NearestIntB[0]]];
    $NearestInt[0] =  $NewIntIndexAA;
    $NearestIntB[0] = $NewIntIndexBB;


    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];
    $LocA = $queryLocCurveEnds[$NearestInt[0]];
    $LocB = $queryLocCurveEnds[$NearestIntB[0]];

    //Loc $LocCurveEndsVec[$NearestInt[0]];
    //Loc $LocCurveEndsVec[$NearestIntB[0]];

    clear $EndSnapAndEndProject;
    $Loc_AorB = "";
    //////////////////////////////////////////
    if($NdistA<$NdistB){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    $Loc_AorB="B";
    }else{
    $Loc_AorB="A";
    $LocName =$LocB;
    $NearestIndex=$NearestIntB[0];
    $NearEndZ = $VecCurEnds[1];
    $endNotNearZ[0] = $VecCurEnds[0];}
    //////////////////////
    // very very rare event
    if($NdistA==$NdistB){
    $Loc_AorB="A";
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    }
    /////////////////////
    if($NearestInt[0]==$NearestIntB[0]){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    }
    //////////////////////////////////////////
    $newNames = stringArrayToString($queryLocCurveEnds, " ");
    $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    $AllarrayCurvesNear = stringToStringArray($newNamesResultAX, " ");
    $NewFoundLocs[0]  = $AllarrayCurvesNear[$NearestIndex];
    $arrayCurvesNear[0] = $queryLocCurveEnds[$NearestIndex];
    /*
    // needed for later for edgeCurves and dynamic local axis plane mirroring
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    */


    $LocOnPlaneVec = PointArray($arrayCurvesNear );
    $Loc3D_Vec = PointArray($NewFoundLocs );
    $ALLLoc3D_VecAB = PointArray($AllarrayCurvesNear);

    if($Loc_AorB == "A"){
    $ReducedIndexXAB = $ReducedIndexA;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexA,$ALLLoc3D_VecAB);
    }
    if($Loc_AorB == "B"){
    $ReducedIndexXAB = $ReducedIndexB;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexB,$ALLLoc3D_VecAB);
    }

    $ALLLoc3D_Vec = $ReducedVecAB;

    $MovedEndPointPlane = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    $CRV_ENDSi[0]= $LocOnPlaneVec[0];
    $CRV_ENDSi[1]= $MovedEndPointPlane[0];
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);
    $MidCurveA = MidPoint($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
    $EpipolD = $DDirEpipolXYZ;
    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);
    $XYZdirectL[0] = << 1,0,0>>;
    $XYZdirectL[1] = << 0,1,0>>;
    $XYZdirectL[2] = << 0,0,1>>;
    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    $AxisOrthoLineA = $AxisOrthoLine;
    // 3d start point $Loc3D_Vec[0]  free Endpoint of plane curve $MovedEndPointPlane[0]
    $Dir_CamRay =  DirectionFN($MovedEndPointPlane[0],$CamPos_A);

    // lineIntersection NOTE arguments are in this order: Point then Line ...Point then Line
    $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);

    $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);

    $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    $XYZi  = $PointN_LineC;
    $XYZadd  = $PointN_LineC;

    $XYZi[0] = $XYZadd[0]+$XYZadd[1];
    $XYZi[1] = $XYZadd[1]+$XYZadd[2];
    $XYZi[2] = $XYZadd[0]+$XYZadd[2];
    $iVc = 0;
    clear $TrackFoundN;
    if($AxisOrthoLineA ==2){
    $TwoPointsi[0] = 0;
    }
    if($AxisOrthoLineA ==1){
    $TwoPointsi[0] = 2;
    }
    if($AxisOrthoLineA ==0){
    $TwoPointsi[0] = 1;
    }
    $AXIS = $AxisOrthoLineA;

    clear $ALLlikeness;
    $i = 0;
    $Dist_3DNear = (($Dist_3D/3.0)*2.0);

    for ($each in $ALLLoc3D_Vec){

    $One = $ALLLoc3D_Vec[$i];
    $XY[0] = $Xx  = $One.x;
    $XY[1] = $Yy  = $One.y;
    $XY[2] = $Zz  = $One.z;

    if( $ReducedIndexXAB[$iVc]!= $NearestIndex ){

    $TriggerPoints=0;
    if( (equivalentTol($XYZadd[0], $Xx,  0.01) )==1){
    $All_X[$i] = $Xx;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[1], $Yy,  0.01) )==1){
    $All_Y[$i] = $Yy;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[2], $Zz,  0.01) )==1){
    $All_Z[$i] = $Zz;
    $TriggerPoints++;
    }

    if( $TriggerPoints<2){
    $diffXYZ = `abs ($XY[$AXIS] - $XYZadd[$AXIS])`;
    if(($diffXYZ< $Dist_3DNear)&&($diffXYZ!=0)){
    $All_ZYX[`size($All_ZYX)`] =$XY[$AXIS];
    $All_ZYXDiff[`size($All_ZYXDiff)`] = $diffXYZ;
    }
    }


    if( $TriggerPoints==2){

    $ALLlikeness[`size($ALLlikeness)`] = $ReducedIndexXAB[$i];
    }
    }
    $i++;
    $iVc++;
    }



    if(`size($All_ZYXDiff)`> 0){
    $SortedForce = SortNumbersIntIndex($All_ZYXDiff);
    $newOrderFloat = $All_ZYX[$SortedForce[0]];

    }


    if(`size($ALLlikeness)`> 0){


    select -cl;
    for($eachIn in $ALLlikeness){
    select -add $AllarrayCurvesNear[$eachIn];
    PAUSE;
    }


    clear $NearPointsXYZ;
    $iVc =0;
    for($eachIn in $ALLlikeness){
    if( $iVc!= $NearestIndex ){
    $NearPointsXYZ[`size($NearPointsXYZ )`] =  $ALLLoc3D_VecAB[$eachIn];
    }
    $iVc++;
    }


    $distTo3DCurveEnd = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    $Sorted = SortNumbersIntIndex($distTo3DCurveEnd);
    $NearPointsXYZ = NewVecOrderWithINTKey($Sorted,$NearPointsXYZ);

    clear $SdistTo3DCurveEnd;
    for($eachIn in $Sorted){
    $SdistTo3DCurveEnd[`size($SdistTo3DCurveEnd)`] = $distTo3DCurveEnd[$eachIn];
    }

    $ReducedIndex = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    $ReducedVec = NewVecOrderWithINTKey($ReducedIndex,$NearPointsXYZ);

    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    // if($AdditRi = 0.0){ then snap to point IF the direction is the same

    $OntheSameLine = 0;
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $OntheSameLine =1;
    }


    $CountN = 0;
    for($eachVec in $ReducedVec){


    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $eachVec);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $PointN_LineXYZ = $eachVec;
    print " on same Line ";
    }else{

    $PointN_LineXYZ  = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $eachVec);

    }

    if( (distance2Pts($PointN_LineXYZ, $PointN_LineC))>0.001){
    $LocsV[`size($LocsV)`] = `Loc $PointN_LineXYZ`;
    $CurvesV[`size($CurvesV)`] = curve2points($eachVec, $PointN_LineXYZ);
    PAUSE;
    }

    if($CountN==0){
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapN = $eachVec;
    $SnapPlaceN = $PointN_LineXYZ;
    }

    if($CountN!=0){
    print  $DistSnap;
    if((distance2Pts($PointN_LineXYZ, $PointN_LineC))<  $DistSnap){
    $SnapN = $eachVec;
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapPlaceN = $PointN_LineXYZ;

    }
    }
    $CountN++;
    }



    $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);

    delete $CurvesV;
    delete $LocsV;

    //$EulerAngleA  = EulerAngB($DirLineSnapXYZ,$LineDirect_3D);
    if(($EulerAngleA[3] >85)&&($EulerAngleA[3]<95)){



    $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    if($Dist_3DSnap<($Dist_3D/2.0)){
    cycleBackgroundColor;
    PAUSE;
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    $AddInt = $AdditR;
    if($AddInt == 0){
    $PointN_LineC = $SnapPlaceN;
    PAUSE; PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }else{

    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $FPointN_LineC =  $PointN_LineC;
    $FPointN_LineC[$AXIS] = $newOrderFloat;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }


    }

    }else{
    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }

    //}

    // $LocsV[`size($LocsV)`] = `Loc $First3dIntersect`;
    // $LocsV[`size($LocsV)`] = `Loc $PointN_LineC`;
    // $CurvesV[`size($CurvesV)`] = curve2points($First3dIntersect, $PointN_LineC);

    $Points3DPair_And_2DPair[0]= $Loc3D_Vec[0];
    $Points3DPair_And_2DPair[1]= $PointN_LineC;
    $Points3DPair_And_2DPair[2]= $LocOnPlaneVec[0];
    $Points3DPair_And_2DPair[3]= $NewPlanePoint;

    delete $TempCrv;
    $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 10 -d 3 -tol 0.05 $CurvesVi;

    $Crv_Pts = VecCurveEps($CurvesVi );
    $MirrorAcrossPlaneVecs = VecMultMatrixMirror($Crv_Pts);
    $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    //delete $CurvesV;
    //delete  $LocsV;
    clear $StereoCurveZ;
    $BothCurves[0] = $CurvesVi;
    $BothCurves[1] = $TheSecondCurve;
    $StereoCurveZ = $BothCurves;
    $addNumbersA =-3;
    ResetTranslation($BothCurves);
    CurveIndexVecTracking($BothCurves);
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $BothCurves;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    clear $StereoCurveZ;
    }
    return $BothCurves;
    }

    //////////////////////////////////////////////////////////

    proc int [] floatArrayCountDuplicates(float $listX[]){
    $list = $listX;
    $index = 0;
    $X = 0;
    $Xi = 0;
    $C = 0;
    $result = $list;
    for ($item in $list) {
    $NumberE[$X] = floatArrayCount($item, $result);
    if (1 == $NumberE[$X]) {
    $NoneDup[`size($NoneDup)`] = $Xi;
    }else{
    if (1 < $NumberE[$X]) {
    floatArrayRemoveAtIndex($X, $result);
    $X--;
    }
    }
    $Xi++;
    $X++;	}
    return $NoneDup;
    }

    //////////////////////////////////////////////////////

    proc int floatArrayCount(float $item, float $list[]){
    $result = 0;
    for ($listItem in $list) {
    if ($item == $listItem) $result++;	}
    return $result;
    }

    proc floatArrayRemoveToIndex(int $ix, float $floatArray[]){
    $ixX = 0;
    while($ixX<$ix){
    floatArrayRemoveAtIndex(0, $floatArray);
    $ixX++;
    }
    }



    proc int floatArrayRemoveAtIndex( int $index, float $list[] ){
    $len = size( $list );

    if( $index > $len  || $index < 0 ){
    return( false );
    }

    for( $i = 0; $i < $index; $i++ ){
    $result[$i] = $list[$i];
    }

    for( ; $i < $len - 1; $i++ ){
    $result[$i] = $list[$i + 1];
    }
    $list = $result;
    return( true );
    }




    ////////////////////////////////

    /*

    if(($XY[$TwoPointsi[0]] != $XYZadd[$TwoPointsi[0]])){
    print (" !!!yes TRIGGER two HERE!!"+"\n");

    }


    if( (equivalentTol($XYZadd[0], $Xx,  0.1) )==1){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }
    if( (equivalentTol($XYZadd[1], $Yy,  0.1) )==1){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }
    if( (equivalentTol($XYZadd[2], $Zz,  0.1) )==1){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }


    if (( $XYZadd[0] ==$Xx)&&( $XYZadd[1] ==$Yy)){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }

    if (( $XYZadd[1] ==$Yy)&&( $XYZadd[2] ==$Zz)){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }

    if (( $XYZadd[2] ==$Zz)&&( $XYZadd[0] ==$Xx)){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }

    }
    }
    $iVc++;
    }
    */

    //////////////////////////////////

    /*

    $XYZi  = $PointN_LineC;
    $XYZadd  = $PointN_LineC;
    $XYZi[0] = $XYZadd[0]+$XYZadd[1];
    $XYZi[1] = $XYZadd[1]+$XYZadd[2];
    $XYZi[2] = $XYZadd[0]+$XYZadd[2];
    $iVc = 0;
    clear $TrackFoundN;
    if($AxisOrthoLineA ==2){
    $TwoPointsi[0] = 0;
    }
    if($AxisOrthoLineA ==1){
    $TwoPointsi[0] = 2;
    }
    if($AxisOrthoLineA ==0){
    $TwoPointsi[0] = 1;
    }
    clear $ALLlikeness;

    for ($each in $ALLLoc3D_Vec){


    $One = $ALLLoc3D_Vec[$iVc];
    $XY[0] = $Xx  = $One.x;
    $XY[1] = $Yy  = $One.y;
    $XY[2] = $Zz  = $One.z;


    if  (( $XYZadd[0]!=0 )&&($Xx!=0)){
    if  (( $XYZadd[1]!=0 )&&($Yy!=0)){
    if  (( $XYZadd[2]!=0 )&&($Zz!=0)){
    if($iVc==0){
    $Xd =  ($XYZi[0] - ($Xx )) ;
    $Yd =  ($XYZi[1] - ($Yy )) ;
    $Zd =  ($XYZi[2] - ($Zz)) ;
    }

    if( $iVc!= $NearestIndex ){
    if(($XY[$TwoPointsi[0]] != $XYZadd[$TwoPointsi[0]])){



    //  if  ( (equivalentTol($XY[0], $XYZadd[0],  0.01) )==1 ){

    if (((equivalentTol( $XY[0], $XYZadd[0],  0.00001 ) )!=1 )  || ((equivalentTol($XY[1], $XYZadd[1],  0.00001))!=1) || ((equivalentTol($XY[2], $XYZadd[2],  0.00001))!=1 )){

    //equivalentTol($XY[0], $XYZadd[0],  0.01) equivalentTol($XY[1], $XYZadd[1],  0.01)
    //  if(  ($XY[0] == $XYZadd[0] )   ||   ($XY[1] == $XYZadd[1] )  ||   ($XY[2] == $XYZadd[2] )   ){
    //  if(  ($XY[0] == $XYZadd[0] )   ||   ($XY[1] == $XYZadd[1] )  ||   ($XY[2] == $XYZadd[2] )   ){
    print  " HERE PASSED ";
    if($iVc==13){
    print  " HERE PASSED ";
    }
    if($iVc==0){
    $Xd =  ($XYZi[0] - ($Xx )) ;
    $Yd =  ($XYZi[1] - ($Yy )) ;
    $Zd =  ($XYZi[2] - ($Zz)) ;
    $Dx =  `sqrt ($XYZi[0] + $Xx)`;
    $Dy =  `sqrt ($XYZi[1] + $Yy)`;
    $Dz =  `sqrt ($XYZi[2] + $Zz)`;
    }


    $ALLlikeness[`size($ALLlikeness)`] = $iVc;

    if( $iVc!= 0 ){

    if($Xd > ( `abs($XYZi[0] - ($Xx))` )){
    $Xd = $Xx;
    $TrackN[0]= $iVc;
    }
    if($Xd == ( `abs($XYZi[0] - ($Xx))` )){
    if(`sqrt ($XYZi[0] + $Xx)`< $Dx){
    $TrackN[0]= $iVc;
    $Dx =  `sqrt ($XYZi[0] + $Xx)`;
    }
    }

    if($Yd > ( `abs($XYZi[1] - ($Yy))` )){
    $Yd = $Yy;
    $TrackN[1]= $iVc;}

    if($Yd == ( `abs($XYZi[1] - ($Yy))` )){
    if(`sqrt ($XYZi[1] + $Yy)`< $Dy){
    $TrackN[1]= $iVc;
    $Dy =  `sqrt ($XYZi[1] + $Yy)`;
    }
    }

    if($Zd > ( `abs($XYZi[2] - ($Zz))` )){
    $Zd = $Zz;
    $TrackN[2]= $iVc;}

    if($Zd == ( `abs($XYZi[2] - ($Zz))` )){
    if(`sqrt ($XYZi[2] + $Zz)`< $Dz){
    $TrackN[2]= $iVc;
    $Dz =  `sqrt ($XYZi[2] + $Zz)`;
    }
    }

    }
    }



    ///////////////

    }

    }
    }
    }



    }
    $iVc++;
    }



    */



    //print $ALLlikeness;


    //print $ALLlikeness;
    //print $TrackN;
    //print $NearestIndex


    /*
    if($Xd >= ( ($XYZi[0] - ($Xx+$Yy)) )){
    $Xd = $Xx;
    $TrackN[0]= $iVc;
    if($iVc==13){
    print  " HERE1 ";
    }

    }


    if($Yd >= ( ($XYZi[1] - ($Yy+$Zz)) )){
    $Yd = $Yy;
    $TrackN[1]= $iVc;

    if($iVc==13){
    print  " HERE2 ";
    }
    }


    if($Zd >= ( ($XYZi[2] - ($Xx+$Zz)) )){
    $Zd = $Zz;
    $TrackN[2]= $iVc;
    if($iVc==13){
    print  " HERE3 ";
    }




    clear $NearPointsXYZ;
    for($eachIn in $ALLlikeness){
    $NearPointsXYZ[`size($NearPointsXYZ )`]=  $ALLLoc3D_Vec[$eachIn];

    }

    for($eachIn in $ALLlikeness){
    select -add $AllarrayCurvesNear[$eachIn];

    }
    */










    proc vector [] VecMultMatrixMirror(vector $pointZ[]){

    matrix $m2[4][4]= <<	-1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0>>;

    $MatrixB = `MatrixToFloat($m2)`;
    for($eachVec in $pointZ){
    $FLoatPointA[`size($FLoatPointA)`] = FloatToVec(pointMatrixMult( $eachVec, $MatrixB ));
    }
    return $FLoatPointA;
    }

    ////////////////////////////////

    ////////////////////////////////


    proc vector [] MoveVectors(vector $Pos_A, vector $VecLoc, vector $Crv_Pts[]){

    $DirLine = DirectionFN( $VecLoc, $Pos_A);
    $DistToPoint = distance2Pts($Pos_A, $VecLoc);

    // DISTANCE TIMES DIRECTION VEC PLUS POINT VECTOR To translate
    clear $TranstatedVecs;
    for($eachVector in $Crv_Pts){
    $TranstatedVecs[`size($TranstatedVecs)`] = ($eachVector+($DistToPoint*$DirLine));
    }
    return $TranstatedVecs;
    }

    ////////////////////////////////

    /*
    // playing around  used at the end of new force othro script
    $PointN_Line = ClosestPoint2LineVec($Dir_CamRay, $MovedEndPointPlane[0], $Loc3D_Vec[0]);
    $LocsV[`size($LocsV)`] = `Loc $PointN_Line`;
    $CurvesV[`size($CurvesV)`] = curve2points($MovedEndPointPlane[0], (($Dir_CamRay*$Dist2D3D)+$MovedEndPointPlane[0]));
    $CurvesV[`size($CurvesV)`] = curve2points($Loc3D_Vec[0], $PointN_Line);
    $PointN_LineB = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $PointN_Line);
    $LocsV[`size($LocsV)`] = `Loc $PointN_LineB`;
    $CurvesV[`size($CurvesV)`] = curve2points($PointN_LineB, $PointN_Line);
    */


    proc string [] VanishingCurves( string  $CurveItemA[]){

    //     string  $CurveItemA[] =`ls -sl`;
    global string $VanishingPointsLinesTempGuides[];
    global int $ifSingleCurve;
    //float $SnapD = 0.013;
    $SnapD = 0.003;
    global vector $TempVectorsCrv[];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemA[0];

    /////////////////////
    if(size($TempVectorsCrv)>0){
    clear $TempVectorsCrv;}
    $Positions = VecCurveCvs($CurveItemA[0]);
    $TempCrv = VecArrayToCurve($Positions);

    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $TempCrv;
    $PositionsZ_Ax = VecCurveEps($TempCrv);

    $ZYplaneMatrix[0] = <<0, 0, 0>>;
    $ZYplaneMatrix[1] = <<0, 1, 0>>;
    $ZYplaneMatrix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;

    $TempVectorsCrv  = LineIntersectPlaneCam( $PositionsZ_Ax, $CamPos1, $ZYplaneMatrix);
    delete $TempCrv;
    ////////////////////

    $Pi = 3.1415926535;
    $pi = 3.1415926535;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $CamerasDirectionVector = $CamerasDirectionVectorNormal;
    $MultDirForWard = multiplyFloat(-1, $CamerasDirectionVector);
    $MultDirCam = multiplyFloat(-3, $CamerasDirectionVector);
    $FloatDirectionCamNormalA = AddFloats($CamPos1, $MultDirCam);
    $DirectionVectorXn = {-2,0,0};
    $DirectionVectorX = {2,0,0};
    $DirectionVectorY = {0,-2,0};
    $DirectionVectorYn = {0,2,0};
    $DirectionVectorZn = {0,0,-2};
    $DirectionVectorZ = {0,0,2};
    $VecDirection_A_XYZ[0] = <<-2,0,0>>;
    $VecDirection_A_XYZ[1] = <<2,0,0>>;
    $VecDirection_A_XYZ[2] = <<0,2,0>>;
    $VecDirection_A_XYZ[3] = <<0,-2,0>>;
    $VecDirection_A_XYZ[4] = <<0,0,-2>>;
    $VecDirection_A_XYZ[5] = <<0,0,2>>;
    $VecDirectionXYZ[0] = <<-1,0,0>>;
    $VecDirectionXYZ[1] = <<1,0,0>>;
    $VecDirectionXYZ[2] = <<0,1,0>>;
    $VecDirectionXYZ[3] = <<0,-1,0>>;
    $VecDirectionXYZ[4] = <<0,0,-1>>;
    $VecDirectionXYZ[5] = <<0,0,1>>;
    $FloatPointDirectionXn = AddFloats($CamPos1, $DirectionVectorXn);
    $FloatPointDirectionX = AddFloats($CamPos1, $DirectionVectorX);
    $FloatPointDirectionY = AddFloats($CamPos1, $DirectionVectorY);
    $FloatPointDirectionYn = AddFloats($CamPos1, $DirectionVectorYn);
    $FloatPointDirectionZn = AddFloats($CamPos1, $DirectionVectorZn);
    $FloatPointDirectionZ = AddFloats($CamPos1, $DirectionVectorZ);
    clear $VecXYZs;
    $VecXYZs[0] = FloatToVec($FloatPointDirectionXn);
    $VecXYZs[1] = FloatToVec($FloatPointDirectionX);
    $VecXYZs[2] = FloatToVec($FloatPointDirectionY);
    $VecXYZs[3] = FloatToVec($FloatPointDirectionYn);
    $VecXYZs[4] = FloatToVec($FloatPointDirectionZn);
    $VecXYZs[5] = FloatToVec($FloatPointDirectionZ);
    $VecXYZsOnPlane = VecPointsToCameraPlane($VecXYZs);
    $AverageVecXYZsOnP = AverageVectorPoint($VecXYZsOnPlane);
    $DirectionsZ = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    $FloatDirxyz[0] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[0]));
    $FloatDirxyz[1] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[1]));
    $FloatDirxyz[2] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[3]));
    $FloatDirxyz[3] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[2]));
    $FloatDirxyz[4] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[4]));
    $FloatDirxyz[5] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[5]));
    $Alll = "";
    clear $AllStrings $AnglesAll ;
    for ($eachOrthD in $VecDirectionXYZ){
    $EulerAngleA = EulerAngB($eachOrthD, $CamerasDirectionVector);
    $AnglesAll[`size($AnglesAll)`]= $EulerAngleA[3];
    $stringFloat = FloatArrayToStringArray($EulerAngleA);
    $Alll  = stringArrayToString($stringFloat, " ");
    $AllStrings[`size($AllStrings)`]= $Alll;
    }
    clear $EmptyIndxNewOrder;
    $indexAx = CreateIntIndex(6);
    $stringIndTr = IntArrayToStringArray($indexAx);
    $ANgnew = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
    $EmptyIndxNewOrder = ReverseStringArray($EmptyIndxNewOrder);
    $BestThree = {$EmptyIndxNewOrder[0], $EmptyIndxNewOrder[1], $EmptyIndxNewOrder[2]};
    $BestThree = ReverseStringArray($BestThree);
    $BestThree = stringArrayRemoveDuplicates ($BestThree);
    $indexAxNew = ArrayToIntList( $BestThree);
    $VecCurEnds = VecCurveEnds($CurveItemA);

    $LengCRV_a = `arclen $CurveItemA`;
    $DistEndsi = distance2Pts($VecCurEnds[0], $VecCurEnds[1]);
    $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);

    $AverageVecCurEndsP = AverageVectorPoint($VecCurEnds);
    $Count = 0;
    $CurvePsD = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
    size($EmptyIndxNewOrder);
    $DirectionsZ = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    clear $colori;
    $iiX = 0;
    for($eachDirection in $indexAxNew){
    if($eachDirection ==0 || $eachDirection ==1){$colori[`size($colori)`] = 13;}
    if($eachDirection ==3 || $eachDirection ==2){$colori[`size($colori)`] = 14;}
    if($eachDirection ==4 || $eachDirection ==5){$colori[`size($colori)`] = 6;}
    }
    clear $CurvesV;
    $Cindex = 0;
    for ($eachDii in $indexAxNew){
    $IndexZ = $indexAxNew[$Count];

    $FloatPointDirectionZniY  = AddFloats( $VecCurEnds[1], $VecDirection_A_XYZ[$IndexZ]);
    $VecXYZsOnPlaneiY = VecPointsToCameraPlane($FloatPointDirectionZniY);
    $CurveDirectionZiY =  DirectionF($VecCurEnds[1],  $VecXYZsOnPlaneiY[0]);
    $FloatPointDirectionZniiY = AddFloats( $VecCurEnds[0], $VecDirection_A_XYZ[$IndexZ]);
    $VecXYZsOnPlaneiiY = VecPointsToCameraPlane($FloatPointDirectionZniiY);
    $CurveDirectionZiiY =  DirectionF($VecCurEnds[0],  $VecXYZsOnPlaneiiY[0]);
    $locsAi = lineIntersection($VecCurEnds[1], $CurveDirectionZiY, $VecCurEnds[0],  $CurveDirectionZiiY);

    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[0], $locsAi);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], $colori[$Cindex]);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[1], $locsAi);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], $colori[$Cindex]);
    editDisplayLayerMembers -noRecurse VanishingPointsLines $CurvesV;
    $Cindex++;
    $Count++;
    }

    $ifSingleCurve = 0;
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);

    DirectionFN($MidEpipolPosFCam,$VecCurEnds[1]);
    DirectionFN($VecCurEnds[0],$VecCurEnds[1]);
    $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
    $Dir_VecA =   PositiveDirectionLine($VecCurEnds[0],$VecCurEnds[1]);
    $VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];


    $VecPtsMirrorEnds_A= VecPtsToZMirrorPts( $VecCurEnds);
    $triggerMiddle = 0;
    $VIntersectEnds_A[0] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[1], $CamPos_M, $VecPtsMirrorEnds_A[0]));
    $VIntersectEnds_A[1] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[0], $CamPos_M, $VecPtsMirrorEnds_A[1]));
    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
    $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
    $IntersectEnds_Ai =  FloatPointsToCamPlane($VIntersectEnds_A[0]);
    $IntersectEnds_Bi = FloatPointsToCamPlane($VIntersectEnds_A[1]);
    $CurveItemAa[0] = $CurveItemA[0];
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEndsOLD = queryLocOnLivePlaneBLayer();
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );



    if(`size($queryLocCurveEnds)` > 2){

    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $NearestInt = SortNumbersIntIndex($distancesEachToCurve);
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[0]];
    $distancesEachToCurveB = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    $NearestIntB = SortNumbersIntIndex($distancesEachToCurveB);
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$NearestIntB[0]];


    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];

    if(($NdistA<$SnapD)||($NdistB<$SnapD)){

    $iv = -1;
    $distsA = $NdistA;
    $distsB = $NdistB;
    for (  $i = 1; $i < 5; $i++) {
    if( $distsA < $distsB){
    $NdistA = $distancesEachToCurve[$NearestInt[$i]];
    if($iv==-1){
    $iv++;
    $StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[0]];}
    if (equivalentTol($NdistA, $distsA, 0.001) == 1){
    $StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[$i]];
    }
    }


    }

    //print $StringAllNearA;
    //print ("NdistA :" +$NearestInt[$i]+" "+$NdistA+"  NdistB :"+$NearestIntB[$i]+" "+$NdistB+"\n");

    $newNames = stringArrayToString( $StringAllNearA, " ");
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    $arrayCurvesNearA = stringToStringArray($newNamesResultC, " ");
    $CRV_index_number = 0;
    $CRc = 0;
    $CRcT = 0;
    for($eachCurve in $arrayCurvesNearA){
    if(`sets -im ZEdgeCurvesSet $eachCurve` ==1){
    $CRV_index_number = $CRc;
    $CRcT++;
    break;
    }
    $CRc++;
    }

    if($CRcT ==1){
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[$CRc]];
    }
    }

    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];

    $newNames = stringArrayToString($EmptyStringNewOrderA, " ");
    $newNamesResultAx = substituteAllString($newNames, "Plane", "");
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    $arrayCurvesNear = stringToStringArray($newNamesResultC, " ");
    $NearCurvesEnds[0] = $arrayCurvesNear[0];
    $NearCurvesEnds[1] = $arrayCurvesNear[1];

    $arrayCurvesNearA1 = stringToStringArray($newNamesResultAx, " ");

    $LocCurveEndsVec_3D = PointArray($arrayCurvesNearA1);


    $LoCz_3D = $LocCurveEndsVec_3D;

    /*
    $FloatDirCam[0] = FloatToVec (DirectionF($CamPos1, $VecXYZs[0]));
    $FloatDirCam[1] = FloatToVec (DirectionF($CamPos1, $VecXYZs[1]));
    $PointN_LineA = ClosestPoint2LineVec($LineDirect_3D, $VecCurEnds[0], $LocCurveEndsVec_3D[0]);
    $distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocCurveEndsVec_3D[0]);
    $distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocCurveEndsVec_3D[1]);
    $relativeDistanceA = ($Distance_A+$distToPlaneLoc[0])/2.0;
    $relativeDistanceB = ($Distance_B+$distToPlaneLoc[1])/2.0;
    */



    $TXI = << -1.0 , 1.0, 1.0>>;
    $LoCz_3D[2] = MultVec($LoCz_3D[0],$TXI);
    $LoCz_3D[3] = MultVec($LoCz_3D[1], $TXI);
    for($eachItemVEC in $LoCz_3D){
    $VanishingLOC[`size($VanishingLOC)`] = Loc($eachItemVEC);
    $SetCol = `setAttr ($VanishingLOC[size($VanishingLOC)-1]+".overrideColor ") 6 `;
    setAttr ( $VanishingLOC[size($VanishingLOC)-1]+".scale") 5.0 5.0 5.0;
    }

    appendStringArray($CurvesV, $VanishingLOC, size($VanishingLOC));
    //string $edgeZsetAB[] = `sets -q ZEdgeCurvesSet`;
    //select -r $edgeZsetAB;
    $edgeZsetA = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[0]`;
    $edgeZsetB = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[1]`;
    $COuntN = 0;
    for($eachVec in $LocCurveEndsVec_3D){
    $ThreepointVecs = $eachVec;
    if (equivalentTol($ThreepointVecs[0], 0.00, 0.001) == 1){
    $EDGEpoints[$COuntN]= 1;
    }else{$EDGEpoints[$COuntN]= 0;}
    $COuntN++;
    }
    $edgeZsetA =$EDGEpoints[0];
    $edgeZsetB =$EDGEpoints[1];


    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    if(($NearCurvesEnds[0] == $NearCurvesEnds[1])&&( ($edgeZsetA+$edgeZsetB) ==2)){

    if($NdistA<$NdistB){
    $edgeZsetA =1;
    $edgeZsetB =0;
    }
    if($NdistA>$NdistB){
    $edgeZsetA =0;
    $edgeZsetB =1;
    }
    if($edgeZsetA==0){$NdistA=100;}
    if($edgeZsetB==0){$NdistB=100;}

    }
    }

    if(($NdistA>$SnapD)&&($NdistB>$SnapD)){
    $edgeZsetA =0;
    $edgeZsetB =0;
    }


    }



    if(($edgeZsetA==1)&&($NdistA<$SnapD)){
    $pointNearEdgeCurve[0]= 1;
    }
    if(($edgeZsetA==1)&&($NdistA>$SnapD)){
    $pointNearEdgeCurve[0]= 0;
    }
    if(($edgeZsetA==0)&&($NdistA>$SnapD)){
    $pointNearEdgeCurve[0]= 0;
    }
    if(($edgeZsetA==0)&&($NdistA<$SnapD)){
    $pointNearEdgeCurve[0]= 2;
    }

    if(($edgeZsetB==1)&&($NdistB<$SnapD)){
    $pointNearEdgeCurve[1]= 1;
    }
    if(($edgeZsetB==1)&&($NdistB>$SnapD)){
    $pointNearEdgeCurve[1]= 0;
    }
    if(($edgeZsetB==0)&&($NdistB>$SnapD)){
    $pointNearEdgeCurve[1]= 0;
    }
    if(($edgeZsetB==0)&&($NdistB<$SnapD)){
    $pointNearEdgeCurve[1]= 2;
    }



    /////////////////////////////////////////////

    if($edgeZsetA==1){
    $EdgeDist =$NdistA;
    }else{$EdgeDist=$NdistB;}

    $SnappingVector = 0;
    if($NdistA<$NdistB){
    $SnappingVector=0;
    }else{$SnappingVector=1;}

    if($NdistA>$SnapD){
    $edgeZsetA = 0;
    }
    if($NdistB>$SnapD){
    $edgeZsetB = 0;
    }
    $OneIsNotNearThePlane = 0;
    if(($NdistA>$SnapD)||($NdistB<$SnapD)){
    if(($NdistA<$SnapD)||($NdistB>$SnapD)){
    $OneIsNotNearThePlane =1;
    }
    }

    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    if(($edgeZsetA==1)||($edgeZsetB==1)){
    $EdgeDist =0.001;
    }
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




    if($pointNearEdgeCurve[0]+$pointNearEdgeCurve[1]== 1){



    $newNamesResultA1 = substituteAllString($newNames, "Plane", "");
    $ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
    $ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
    $A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
    $A= `MakeCleanFloats($A)`;
    $B= `MakeCleanFloats($B)`;
    if(($A[0] ==0)||($B[0] ==0)){

    $triggerMiddle =2;
    $ifSingleCurve=1;
    if($edgeZsetA==1){
    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
    $NearVecPts[1]= $VecCurEnds[1];
    }else{
    $NearVecPts[0]= $VecCurEnds[0];
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
    }
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    if($EdgeDist<2.5){

    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    $PositionsZ_Aii = $PositionsZ_Ai;
    }
    $PositionsZ_Aiix[0] = <<0, 0, 0>>;
    $PositionsZ_Aiix[1] = <<0, 1, 0>>;
    $PositionsZ_Aiix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    if($EdgeDist<2.5){
    $VecTest  = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
    }else{$VecTest  = LineIntersectPlaneCam($PositionsZ_A, $CamPos1, $PositionsZ_Aiix);
    }
    $CurveAv[0] = VecArrayToCurveB($VecTest);
    }

    }



    if( $pointNearEdgeCurve[1]==1){

    $newNamesResultA1 = substituteAllString($newNames, "Plane", "");
    $ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
    $ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
    $A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
    $A = MakeCleanFloatsZ($A);
    $B = MakeCleanFloatsZ($B);

    if(($A[0] ==0)&&($B[0] ==0)){

    // NOTE these two
    $triggerMiddle =2;
    $ifSingleCurve=1;

    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    delete $CurveItemA;
    $CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);

    $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    if($DiffMathA >95.0){
    $PositionsZ_Aii[0] = $NearVecPts[0];
    $PositionsZ_Aii[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
    $PositionsZ_Aii[2]= $NearVecPts[1];

    } else{
    $PositionsZ_Aii = $PositionsZ_Ai;}
    $PositionsZ_Aiix[0] = <<0, 0, 0>>;
    $PositionsZ_Aiix[1] = <<0, 1, 0>>;
    $PositionsZ_Aiix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $VecTest = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
    if($DiffMathA >95.0){	$CurveAv[0] = VecArrayToCurve($VecTest);}else{
    $CurveAv[0] = VecArrayToCurve($VecTest);}
    }
    }


    if($triggerMiddle==0){

    if($GetSizeOfCRV_ends>0){
    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);
    $distancesTo3DCurveEnd = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
    $Sorted = SortNumbersIntIndex($distancesTo3DCurveEnd);
    $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
    $distancesTo3DCurveEndi = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
    $Sortedi = SortNumbersIntIndex($distancesTo3DCurveEndi);
    $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
    $FistAndSecond[0]=$LocCurveEndsVec3D[$Sorted[0]];
    $FistAndSecond[1]=$LocCurveEndsVec3D[$Sortedi[0]];
    $LocNames[0]=$queryLocCurveEnds3D[$Sorted[0]];
    $LocNames[1]=$queryLocCurveEnds3D[$Sortedi[0]];
    $LocNames[2]=$queryLocCurveEnds3D[$Sorted[1]];
    $LocNames[3]=$queryLocCurveEnds3D[$Sortedi[1]];
    $VecA = $FistAndSecond[0];
    $VecB = $FistAndSecond[1];
    $XX = $VecA.x;
    $XXX = $VecB.x;
    if( ($XX*-1)==$XXX){
    if($NptsDist<2.5){

    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($VecA));
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($VecB));
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    delete $CurveItemA;
    $CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);
    $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    clear $PositionsZ_A;

    if($DiffMathA >95.0){

    $PositionsZ_Ai[0] = $NearVecPts[0];
    $PositionsZ_Ai[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
    $PositionsZ_Ai[2]= $NearVecPts[1];

    }else{
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    }
    $ReversePositionsZ_Ai = ReverseVectorArray($PositionsZ_Ai);
    clear $PtsMirrorAi;
    $PtsMirrorAi= VecPtsToZMirrorPts($ReversePositionsZ_Ai);
    $iiz = 0;
    clear $XIntersect_Ax;
    for ($eachVecx in  $ReversePositionsZ_Ai){
    $XIntersect_Ax[`size($XIntersect_Ax)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_Ai[$iiz], $CamPos_M, $PtsMirrorAi[$iiz]));
    $iiz++;
    }
    if($DiffMathA >95.0){
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    }

    $CurveAv =  VecArrayToSplitCurve($XIntersect_Ax);
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
    $evalSmoothi += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmoothi);
    $ifSingleCurve=1;
    }
    }
    }
    }

    $VanishingPointsLinesTempGuides = $CurvesV;
    if(( $ifSingleCurve == 1)&&($triggerMiddle ==0)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[1];
    sets -include ZEdgeCurvesSet $CurveAv;
    }else{
    if(( $ifSingleCurve == 1)&&($triggerMiddle ==1)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    }
    }

    if( ($ifSingleCurve == 1)&&($triggerMiddle ==2)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv;
    $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    sets -include ZEdgeCurvesSet $CurveAv;
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    }
    return $CurvesV;
    }

    proc vector [] VecPointsToCameraPlane(vector $V[]){
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+($D1*$F3);
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    return $O;
    }
}


/******************************************************************************
 * @procedure    PointToPlaneN
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Veciiv : vector
 *   $Vec : vector[]
 *
 * @returns      vector
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector PointToPlaneN(vector $Veciiv, vector $Vec[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CombA = PointsEquivalentTol ($PointN, $pAv);
    int $sIZes = `size $FixVec `;
    int $NUmers[] = CreateIntIndex($sIZes);
    int $CreatedObjectCurve = `ISSelectedTypeCurve`;
    int $zeroOR1Z = `gmatch $nameB "*[C-c]urve*"`;
    int $scriptt_jobNumConnectionChanged = `scriptJob -conditionChange delete evalVectorIndexAdditionSubtract`;
    int $IndeXa = 0;
    int $rAngle = $angle;
    int $rX = $Qx*100;
    int $rY = $Qy*100;
    int $rZ = $Qz*100;
    int $MatrixNi = $MatrixN-1;
    int $BytNum[];
    int $BytNumSort[] = $BytNum;
    int $BytNumLarg = $BytNumSort[`size($BytNumSort)`-1];
    int $BytNumSmall = $BytNumSort[0];
    int $BytNumDiff[];
    int $IndXeF = 0;
    int $IndXeFi = 0;
    int $Xz = 0;
    int $iX = 0;
    int $count = 0;
    int $Low_X;
    int $TrackC[];
    int $NewIndex[];
    int $Xv = 0;
    int $TFNS = 1;
    int $IndexTrack[];
    int $CountN = 0;
    int $TrueorFalseCircle = `IsCircle`;
    int $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);
    int $IfTrue;
    int $weighedtFindings = 0;
    int $weighedtFindingsZ = 0;
    int $weighedtFindingsN = 0;
    int $triggerStraitCRV = 0;
    int $Trueii = 0;
    int $iia = 0;
    int $AllLocsi[] = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    int $New_AllLocs_A[];
    int $Near_index_A = $New_AllLocs_A[0];
    int $New_AllLocs_B[];
    int $Near_index_B = $New_AllLocs_B[0];
    int $triggerNoTrans = 0;
    int $iiz = 0;
    int $colori[];
    int $numIparms = size($intersections1);
    int $TF = 0;
    int $CurveIndexInter[];
    int $NodeCurveIndex[] = CreateCrvInterTF($CurveItemZai, $PlaneCurveS,0,0.001,$interVecA, $interVecB);
    int $COuntN = 0;
    int $foundN[];
    int $Number = 0;
    int $CollectN_index[];
    int $COLLECT_INDEX[];
    int $COLLECTN_INDEX[];
    int $COLLECT_Wanted_INDEX[];
    int $Cni = 0;
    int $Cnii = 0;
    int $AllM[];
    int $ExistingIntA[];
    int $COLLECT_INDEX_M[];
    int $eachIntE;
    int $Cniim = 0;
    int $NodeCurveIndexi[];
    int $CountPara = 0;
    int $ParaSize[];
    int $CurveSFoundS = `size($NodeCurveIndexi)`;
    int $PointOnCrvIND[] = CreateIntIndex(`size($VecPointOnCrv)`);
    int $New_PointOnCrvIND_A[];
    int $FOUNDc = $New_PointOnCrvIND_A[0];
    int $WhatCurve;
    int $CountWhatCurve = -1;
    int $CountParab = 0;
    int $ParaSizeb[];
    int $CurveSFoundSb = `size($NodeCurveIndex)`;
    int $PointOnCrvINDb[] = CreateIntIndex(`size($VecPointOnCrvb)`);
    int $New_PointOnCrvIND_Ab[];
    int $FOUNDcb = $New_PointOnCrvIND_Ab[0];
    int $WhatCurveb;
    int $CountWhatCurveb = -1;
    int $pX = equivalentTol($posA[0], $posB[0],  0.001);
    int $pY = equivalentTol($posA[1], $posB[1],  0.001);
    int $pZ = equivalentTol($posA[2], $posB[2],  0.001);
    int $addedResults = $pX + $pY + $pZ;
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 4 );
    int $FindSteps;
    int $StepZNum = $numLength;
    int $MasterCount = 0;
    int $Par = 0;
    int $ii = 0;
    int $CountSteps;
    int $NewIndexN[];
    int $TwoNew[];
    int $iNdex = 0;
    int $returnValue = 1;
    int $vi = 0;
    int $Trigger = 0;
    int $Lowest = 11110;
    int $Past = 0;
    int $CountEVEN = 0;
    int $Even_Odd;
    int $Count = 0;
    int $CountP = 0;
    int $Size = size($x0);
    int $evenOdd = fmod($sIZes, 2);
    int $sIZesHalf = (($sIZes)/2)+1;
    int $countN = 0;
    int $CountVV = 0;
    int $index[] = CreateIntIndex(3);
    int $isOrthoTrueZi = 0;
    int $triggerNoTransENDA = 0;
    int $triggerNoTransENDB = 0;
    int $First_Second_Both_None = 0;
    int $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
    int $TrackAllExisting3DCrv[] = CreatePairIntIndex($SizeCrvi);
    int $SizeCrvR = `size($LayerCurvesRangeA)`;
    int $Cn = 0;
    int $triggerNoTransA = 0;
    int $triggerNoTransB = 0;
    int $trigger_straitC = 0;
    int $iis = 0;
    int $ConnectedEnds = $triggerNoTransENDA + $triggerNoTransENDB;
    int $AddAB = $triggerNoTransA+$triggerNoTransB;
    int $New_AllLocs_AB[];
    int $PairInt[];
    int $EndsAtZero = isCurveEndAtZY($EndrEndsa);
    int $STEPSZ = 200;
    int $LowX;
    int $NewArrayAEllipZ[] = NewVecOrderEllipZ($NewOneCurveS, $EmptyVectorArrayA, $MidEpipolPosFCam);
    int $NewArrayBEllipZ[] = NewVecOrderEllipZ($NewOneCurveSB, $EmptyVectorArrayB, $MidEpipolPosFCam);
    int $IndexTrackE[];
    int $TwoZeroOne[] = {0,1};
    int $TFmostRArray[];
    int $LargestIntR_KEY[];
    int $LargestIntL_KEY[];
    int $COUNT_Nlr = 0;
    int $LargestIntR[] = SortNumbersIntIndex($AllAngiX_RIGHT);
    int $LargestIntL[] = SortNumbersIntIndex($AllAngiX_LEFT);
    int $SizeE = `size($EmptyVectorArrayA)`;
    int $NewArrayInt;
    int $NewArrayIntX[];
    int $Add = 0;
    int $edgeZsetA;
    int $edgeZsetB;
    int $ReducedIndexA[] = floatArrayCountDuplicates($distancesEachToCurve);
    int $ReducedIndexB[] = floatArrayCountDuplicates($distancesEachToCurveB);
    int $NearestInt[] = SortNumbersIntIndex($distAz);
    int $NearestIntB[] = SortNumbersIntIndex($distBz);
    int $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    int $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];
    int $NearestIndex;
    int $NearestIndexEach;
    int $ReducedIndexXAB[];
    int $AxisOrthoLineA = $AxisOrthoLine;
    int $iVc = 0;
    int $TrackFoundN[];
    int $TrackN[];
    int $TwoPointsi[];
    int $AXIS = $AxisOrthoLineA;
    int $ALLlikeness[];
    int $ALLlikenessForce[];
    int $TriggerPoints;
    int $SortedForce[];
    int $Sorted[] = SortNumbersIntIndex($distTo3DCurveEnd);
    int $ReducedIndex[] = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    int $OntheSameLine = 0;
    int $AddInt = $AdditR;
    int $Xi = 0;
    int $NumberE[];
    int $NoneDup[];
    int $ixX = 0;
    int $len = size( $list );
    int $indexAx[] = CreateIntIndex(6);
    int $indexAxNew[] = ArrayToIntList( $BestThree);
    int $color;
    int $iiX = 0;
    int $Cindex = 0;
    int $IndexZ = $indexAxNew[$Count];
    int $triggerMiddle = 0;
    int $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
    int $iv = -1;
    int $CRV_index_number = 0;
    int $CRc = 0;
    int $CRcT = 0;
    int $EDGEpoints[];
    int $pointNearEdgeCurve[];
    int $SnappingVector = 0;
    int $OneIsNotNearThePlane = 0;
    int $Sortedi[] = SortNumbersIntIndex($distancesTo3DCurveEndi);
    int $C1;
    float $pAv[] = AverageVectorPoint($Vec);
    float $n[] = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    float $DistanceLoc = distance2Pts(  $Veciiv, $pAv);
    float $MultDirCam[] = multiplyFloat($DistanceLoc, $n);
    float $FloatDirectionCamNormalA[] = AddFloats($pAv, $MultDirCam);
    float $PointN[] = ClosestPoint2LineVec($n, $pAv, $Veciiv);
    float $FloatDirectionAi[] = DirectionFN($pAv,$PointN);
    float $MultDirPC1[] = multiplyFloat($DistanceLoc, $FloatDirectionAi);
    float $AddMultMiiF[] = AddFloats($Veciiv, $MultDirPC1);
    float $LengthA = distance2Pts ($VecPairA[0], $VecPairA[1]);
    float $LengthB = distance2Pts ($VecPairB[0], $VecPairB[1]);
    float $LengthAB;
    float $Sign_F;
    float $MatrixFB[] = MatrixToFloat($matrixB);
    float $AddMepi[];
    float $ni;
    float $valuesBi[] = $eachVeCx;
    float $EulerAngleA[] = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
    float $x = $oneItemFLoats[0];
    float $y = $oneItemFLoats[1];
    float $z = $oneItemFLoats[2];
    float $normal[] = $bi;
    float $p[] = AverageVectorPoint($SelectVec);
    float $d = $normal[0] * $p[0] + $normal[1] * $p[1] + $normal[2] * $p[2];
    float $dist = $x * $normal[0] + $y * $normal[1] + $z * $normal[2] - $d;
    float $LivePlanePosX[];
    float $MirrorF[] = MirrorPointFrom3PointPlane( PointArrayT(`ls -sl`), $LivePlanePosX);
    float $Zx[] = $eachVecEp;
    float $Pi = 3.1415926535;
    float $pi = 3.1415926535;
    float $CamPos1[];
    float $LivePlanePos[];
    float $CamerasDirectionVectorNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
    float $FloatDirectionA[] = DirectionFN($CamPos1, $LocPos1);
    float $DistanceLocA = $DistanceLoc;
    float $FloatDirectionCamNormal[] = AddFloats($CamPos1, $MultDirPC1);
    float $CamerasDirectionVectorA[] = DirectionFN($FloatDirectionCamNormal, $CamPos1);
    float $MultDirPC1A[] = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
    float $p1[] = $CamPos1;
    float $p2[] = $LocPos1;
    float $p3[] = $FloatDirectionCamNormal;
    float $center[];
    float $FloatPosZero[] = {0, 0, 0};
    float $FloatDirection[] = DirectionFN($FloatPosZero, $normal);
    float $FloatDirPerpCenterC[] = DirectionFN($center,$mid2);
    float $FloatDirPointAC[] = DirectionFN($p1, $p3);
    float $center8[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    float $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
    float $FloatDirLocToPerpIntersect[] = DirectionFN($center8,$p2);
    float $OnPlane[] = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $UnitDirection[] = $vectorUnit;
    float $u = $xi - $x;
    float $w = $zi - $z;
    float $e = 1;
    float $Y = $u/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    float $U = $v/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    float $V = $w/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    float $newF[];
    float $a = 7.5;
    float $b = 3.4;
    float $c = 5.3;
    float $t1 = ((2*$a*$a*$a) - (9*$a*$b) +(27*$c));
    float $t2 = ((-$a*$a) + (3*$b));
    float $t3 = $t1*$t1 + 4*$t2*$t2*$t2;
    float $t4 = ((-$t1 + (`sqrt $t3`))/54);
    float $t41 = ((-$t1 - (`sqrt $t3`))/54);
    float $t5 = ((-$a*$a) + (3*$b));
    float $t6 = `sqrt($t1*$t1 + (4*$t5*$t5*$t5))`;
    float $t7 = ((-$t1 - $t6)/54);
    float $TimesOne = 1.0;
    float $N = 1;
    float $Ni = 1;
    float $valueA;
    float $valueB;
    float $valueC;
    float $valueD;
    float $valueE;
    float $valueF;
    float $valueG;
    float $value = $valueA - $valueB - $valueC - $valueD - $valueE - $valueF - $valueG;
    float $ParamX;
    float $ParamY;
    float $ParamZ;
    float $cx;
    float $cy;
    float $cz;
    float $sx;
    float $sy;
    float $sz;
    float $cycz;
    float $sysz;
    float $sycz;
    float $cysz;
    float $Qx;
    float $Qy;
    float $Qz;
    float $Qw;
    float $l;
    float $Nin = 1;
    float $Niin = 1;
    float $DirAB[] = DirectionF ($PosA, $PosB);
    float $DirCD[] = DirectionF ($PosC, $PosD);
    float $locsA[] = lineIntersection($PosA, $DirAB, $PosC, $DirCD);
    float $result[];
    float $FLoatMatrixA[] = MatrixToFloat($MatriXM);
    float $MatrixA[] = `MatrixToFloat($m)`;
    float $MatrixB[] = `MatrixToFloat($m2)`;
    float $DividedFLoats[];
    float $FLoatPointA[] = pointMatrixMult( $point, $MatrixB );
    float $CleanFLoats[];
    float $Arc = `arclen $CurveItemZai[0]`;
    float $angleZi[];
    float $TotalDegi;
    float $Ellipes_A[];
    float $CamPos_A[];
    float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;
    float $MidEpipolZx[] = MidPoint($CamPos_M, $CamPos_A);
    float $MidEpipolPosFCam[] = FloatPointsToCamPlane($MidEpipolZx);
    float $AngleX[];
    float $angleA;
    float $AngleB[] = EulerAngB((DirectionFN($vecA, $vecB)), (DirectionFN($vecC, $vecD)));
    float $AverageVecCurve[] = AverageVectorPoint($PositionsZ_A);
    float $CamDirVecNormalA[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $CamPlane1[];
    float $CamDirVecNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $CamNormM[] = ` MirrorFloatXYZ 0 $MultDirCam`;
    float $EpipolPosCamM[] = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;
    float $MidPosFCam[] = $CamPlane1;
    float $FloatDirEpipol[] = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    float $FloatDirEpipolB[] = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
    float $EpipolXx[] = {0.0,$CamPos_A[1],$CamPos_A[2]};
    float $PlaneEpipolXx[] = FloatPointsToCamPlane( $EpipolXx);
    float $EpipolYx[] = {$CamPos_A[0],0.0,$CamPos_A[2]};
    float $PlaneEpipolYx[] = FloatPointsToCamPlane( $EpipolYx);
    float $EpipolZx[] = {$CamPos_A[0],$CamPos_A[1],0.0};
    float $PlaneEpipolZx[] = FloatPointsToCamPlane( $EpipolZx);
    float $DistTOEpipol_CurEndA;
    float $DistTOEpipol_CurEndB;
    float $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
    float $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
    float $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;
    float $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    float $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
    float $BCDiff = abs($BCurEndB - $BCurEndBNN);
    float $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd;
    float $BCDiffi = abs($BCurEndB - $BCurEndBNNi);
    float $FloatDirEndPtsA[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
    float $EulerAngle_A = $EulerAngleA[3];
    float $FloatDirEndPtsB[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
    float $EulerAngleB[] = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);
    float $EulerAngle_B = $EulerAngleB[3];
    float $FloatDirEndPtsAi[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
    float $EulerAngleAi[] = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);
    float $EulerAngle_Ai = $EulerAngleAi[3];
    float $FloatDirEndPtsBi[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
    float $EulerAngleBi[] = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);
    float $EulerAngle_Bi = $EulerAngleBi[3];
    float $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
    float $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;
    float $LengCRV_a = `arclen $CurveItemZai`;
    float $DistEndsi;
    float $PerDiff = percent_of( $LengCRV_a, $DistEndsi);
    float $LengCRV_b = `arclen $CurveItemZbi`;
    float $DistEndsii;
    float $PerDiffii = percent_of( $LengCRV_b, $DistEndsii);
    float $PerDiffSum = ($PerDiff+$PerDiffii)/2.0;
    float $DDirEpipol[] = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
    float $MidCurveA[] = MidPoint($VecCurEndsa[0], $VecCurEndsa[1]);
    float $MidCurveB[] = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);
    float $AngleXi;
    float $DDirEpipolB[] = DirectionFN($MidCurveB, $FoundEpipol);
    float $DDirEpipolA[] = DirectionFN($FoundEpipol,$MidCurveB);
    float $PointToCamDir[];
    float $PointsClos[];
    float $distToCurveE_A[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[0]);
    float $newOrdersZA[] = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    float $Distance_A = $distToCurveE_A[$Near_index_A];
    float $Found_pt_A[] = $LocCurveEndsVec3D[$Near_index_A];
    float $newOrdersZAM[] = $Found_pt_A;
    float $distToCurveE_B[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[1]);
    float $newOrdersZB[] = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    float $Distance_B = $distToCurveE_B[$Near_index_B];
    float $Found_pt_B[] = $LocCurveEndsVec3D[$Near_index_B];
    float $newOrdersZBM[] = $Found_pt_B;
    float $distToPlaneLoc[];
    float $intersectionsA[];
    float $intersections1A[];
    float $intersections1B[];
    float $interVecA[];
    float $interVecB[];
    float $intersectposA[];
    float $newOrderVec[];
    float $eachFloat;
    float $ThreeFs[];
    float $OffsetTol = 1.0005;
    float $Distance_Aii;
    float $VEcF[];
    float $EveryPara[];
    float $EachPara;
    float $posA[];
    float $ParaFloat[];
    float $distCA[] = ArrayDistancesVecTofloat($VecPointOnCrv, $UnconnectedEnds[1]);
    float $newCA[] = SortFloatArrayAndString($distCA, $PointOnCrv_String, $EmptyCA);
    float $NearestDistCA = $distCA[$New_PointOnCrvIND_A[0]];
    float $EveryParab[];
    float $EachParab;
    float $posAb[];
    float $ParaFloatb[];
    float $distCAb[] = ArrayDistancesVecTofloat($VecPointOnCrvb, $UnconnectedEnds[0]);
    float $newCAb[] = SortFloatArrayAndString($distCAb, $PointOnCrv_Stringb, $EmptyCAb);
    float $NearestDistCAb = $distCA[$New_PointOnCrvIND_Ab[0]];
    float $PointBc[] = $CUT_CrvIntersectMirrorEnds_A[0];
    float $uParam = `closestPointOnCurve -ip $PointBc[0] $PointBc[1] $PointBc[2] -q -paramU $newNamesCB`;
    float $interposA[];
    float $interposB[];
    float $Addit[] = $VecLineDirM;
    float $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    float $MultDirOne[] = multiplyFloat(1.0, $DirectionLineF);
    float $AddMultF[] = AddFloats($PointOnLine, $MultDirOne);
    float $FDirNorA[] = Normal3Points($PointOnLine, $AddMultF, $PointN);
    float $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    float $MultDirMx[] = multiplyFloat($DistToLineSTart, $FDirNorA);
    float $AddMultMiiFx[] = AddFloats($PointOnLine, $MultDirMx);
    float $FDirNorB[] = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);
    float $MultDirMxz[] = multiplyFloat($DistToLineSTart,  $FDirNorB);
    float $AddMultMiiFxz[] = AddFloats($PointOnLine, $MultDirMxz);
    float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    float $CircleCenter[] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureCenter")`;
    float $step = $numEPrealNum2;
    float $curveMin = $curveM;
    float $numLength = (`arclen $Newcurvez`) +1;
    float $values[];
    float $MultDirA[] = multiplyFloat(($Length/2.0),  $Direction);
    float $DirectionN[];
    float $MultDirB[] = multiplyFloat(($Length/2.0),  $DirectionN);
    float $FDirA[] = AddFloats($posA, $MultDirA);
    float $FDirB[] = AddFloats($posA, $MultDirB);
    float $CRVRadi[];
    float $CIrceP[];
    float $DistanceS[];
    float $point1[] = FloatToVec($Vecs[0]);
    float $point2[] = FloatToVec($Vecs[1]);
    float $point3[] = FloatToVec($Vecs[2]);
    float $normalA[] = `unit ($normalV[0])`;
    float $normalB[] = `unit ($normalV[1])`;
    float $normalAAdd = $normalA[0] + $normalA[1];
    float $normalAAdd2 = $normalB[0] + $normalB[1];
    float $FArrayInex[];
    float $AddF = 0;
    float $Lengthi = distance2Pts ($FixVeci[0], $FixVeci[1]);
    float $MidPt[] = MidPoint($FixVeci[0], $FixVeci[1]);
    float $FloatDirMajor[] = DirectionFN($FixVeci[0], $FixVeci[1]);
    float $Lengthiii = distance2Pts ($MidPt, $FixVeci[2]);
    float $FDirNorAi[] = Normal3Points($FixVeci[0], $FixVeci[1], $FixVeci[2]);
    float $LENGTH = $Lengthi/2.0;
    float $C_radius[] = Circle3PtsM($ABC[0], $ABC[1], $ABC[2]);
    float $ObjsCirclesRad = $C_radius[3];
    float $Di = distance2Pts( $MidVec , $PointN);
    float $DiffL = ($ObjsCirclesRad-$Di)*2.0;
    float $PointNii[];
    float $PointNiii[];
    float $PointNiiiB[];
    float $FloatDirXn[] = DirectionFN( $MidVec, $FixVeci[2]);
    float $DistAddiR2 = $Di*2.0;
    float $HightD = sqrt (abs ((`pow $Di 2`) - (`pow $ObjsCirclesRad 2`)));
    float $DiX = distance2Pts( $FixVeci[2] , $PointNiii);
    float $DiY = distance2Pts( $FixVeci[2] , $PointNiiiB);
    float $ClosestPoint[];
    float $RadiOfOuter = distance2Pts($MidVec, $ClosestPoint);
    float $DirRaytoIntersectC[];
    float $CircleRayPointN[];
    float $SecondIntersectCsmall[] = lineIntersection( $MidVec, $DirRaytoIntersectC, $FixVeci[2], $norm);
    float $RadiOfInnerC = distance2Pts($MidVec,$SecondIntersectCsmall);
    float $MatrizFloati[] = MatrixToFloat($mI);
    float $angle = 0;
    float $points[];
    float $newLocP[];
    float $VecAngle = VAnglesofThreeVec($MidPt, $FixVeci[1], $FixVeci[2]);
    float $beta = `deg_to_rad ($angle)`;
    float $sinbeta = sin($beta);
    float $cosbeta = cos($beta);
    float $valuesiiA[] = {$x,0.0,$y};
    float $valuesiAi[] = {$x, 0, $y};
    float $i;
    float $X = $x + ($a * $cosalpha * $cosbeta - $b * $sinalpha * $sinbeta);
    float $valuesA[] = {$X, 0, $Y};
    float $MidTwoDtoElPoint = distance2Pts ($valuesiiA, $valuesA);
    float $FloatDirEpoint[] = DirectionFN($valuesiiA, $valuesA);
    float $MultDii[] = multiplyFloat($MidTwoDtoElPoint, $newLocP);
    float $CN[];
    float $StepCycle = 0;
    float $pastA = 0.0;
    float $AddAngles = 0.0;
    float $allAngiX[];
    float $Ct[];
    float $DistancesCycle[];
    float $AngleNine = $AngleB[3];
    float $FXiI = $StepCycle;
    float $Fnumbers = 100.0/$FXiI;
    float $floatZ[];
    float $Sum;
    float $Result;
    float $Output;
    float $Correction;
    float $Error;
    float $S = (1.0/(1.0+`exp(-$x)`));
    float $Vt[];
    float $Ix = 0;
    float $AddAll = 0;
    float $Divide = $AddAll/$Ix;
    float $Fx = 0.0;
    float $DiffMathA;
    float $ZO[];
    float $PastF;
    float $ThresholdX = 1.5;
    float $FloatDirA[];
    float $Anglei;
    float $SnapR = 1.55;
    float $Smooth = 398;
    float $DiffMathB = $DistEndsii / ($LengCRV_b/100.0);
    float $DistToIntersectTOnear[];
    float $distToPlaneLoc3D[];
    float $DiffMathAm = $DistToIntersectTOnear[2]/ ($distToPlaneLoc3D[2]/100.0);
    float $DiffMathBm = $DistToIntersectTOnear[3] / ($distToPlaneLoc3D[3]/100.0);
    float $relativeDistanceA = ($DiffMathA+$DiffMathAm)/2.0;
    float $relativeDistanceB = ( $DiffMathB+$DiffMathBm)/2.0;
    float $relativeDistanceAi = ($Distance_A+$distToPlaneLoc[0])/2.0;
    float $relativeDistanceBi = ($Distance_B+$distToPlaneLoc[1])/2.0;
    float $relativeDistanceAZ = distance2Pts($VecOnPlaneA[0], $PointsA[0]);
    float $relativeDistanceBZ = distance2Pts($VecOnPlaneB[0], $PointsB[0]);
    float $DiffMathAi = $relativeDistanceAi/ ($relativeDistanceAZ/100.0);
    float $DiffMathBi = $relativeDistanceBi / ($relativeDistanceBZ/100.0);
    float $TimesMathAi = $relativeDistanceA*$relativeDistanceAZ/ ($distToPlaneLoc3D[0]/100.0);
    float $TimesMathBi = $relativeDistanceB*$relativeDistanceBZ/ ($distToPlaneLoc3D[1]/100.0);
    float $distToCurveE_AB[];
    float $lineEPointA[] = MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);
    float $Point3DA[] = $Intersect_LineB_a;
    float $Point3DAM[] = {($Point3DA[0]*-1), $Point3DA[1],$Point3DA[2]};
    float $TotalDegii[];
    float $TrackCi[];
    float $anglesMade[];
    float $EllipesPos_A[];
    float $DIff;
    float $AllAngiX_RIGHT[];
    float $AllAngiX_LEFT[];
    float $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    float $distancesEachToCurve[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    float $distancesEachToCurveB[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    float $distAz[];
    float $distBz[];
    float $FPointN_LineC[];
    float $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);
    float $XY[];
    float $XYZi[];
    float $XYZadd[];
    float $Xd;
    float $Yd;
    float $Zd;
    float $All_X[];
    float $All_Y[];
    float $All_Z[];
    float $All_ZYX[];
    float $All_ZYXDiff[];
    float $diffXYZ;
    float $Dist_3DNear = (($Dist_3D/3.0)*2.0);
    float $newOrderFloat;
    float $distTo3DCurveEnd[] = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    float $SdistTo3DCurveEnd[];
    float $Additi[];
    float $AdditiB[];
    float $AdditRi;
    float $AdditRiX;
    float $DistSnap;
    float $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    float $list[] = $listX;
    float $listItem;
    float $DistToPoint = distance2Pts($Pos_A, $VecLoc);
    float $SnapD = 0.003;
    float $MultDirForWard[] = multiplyFloat(-1, $CamerasDirectionVector);
    float $DirectionVectorXn[] = {-2,0,0};
    float $DirectionVectorX[] = {2,0,0};
    float $DirectionVectorY[] = {0,-2,0};
    float $DirectionVectorYn[] = {0,2,0};
    float $DirectionVectorZn[] = {0,0,-2};
    float $DirectionVectorZ[] = {0,0,2};
    float $FloatPointDirectionXn[] = AddFloats($CamPos1, $DirectionVectorXn);
    float $FloatPointDirectionX[] = AddFloats($CamPos1, $DirectionVectorX);
    float $FloatPointDirectionY[] = AddFloats($CamPos1, $DirectionVectorY);
    float $FloatPointDirectionYn[] = AddFloats($CamPos1, $DirectionVectorYn);
    float $FloatPointDirectionZn[] = AddFloats($CamPos1, $DirectionVectorZn);
    float $FloatPointDirectionZ[] = AddFloats($CamPos1, $DirectionVectorZ);
    float $AverageVecXYZsOnP[] = AverageVectorPoint($VecXYZsOnPlane);
    float $AnglesAll[];
    float $ANgnew[] = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
    float $AverageVecCurEndsP[] = AverageVectorPoint($VecCurEnds);
    float $FloatPointDirectionZniY[];
    float $CurveDirectionZiY[];
    float $FloatPointDirectionZniiY[];
    float $CurveDirectionZiiY[];
    float $CurvePsD[] = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
    float $FloatPointDirectVpoint[];
    float $CurveDirectionVpoint[];
    float $locsAi[] = lineIntersection($VecCurEnds[1], $CurveDirectionZiY, $VecCurEnds[0],  $CurveDirectionZiiY);
    float $IntersectEnds_Ai[];
    float $IntersectEnds_Bi[];
    float $distsA = $NdistA;
    float $distsB = $NdistB;
    float $ThreepointVecs[];
    float $EdgeDist;
    float $smallestDistance;
    float $distancesTo3DCurveEnd[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
    float $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
    float $distancesTo3DCurveEndi[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
    float $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
    float $XX = $VecA.x;
    float $XXX = $VecB.x;
    string $curvei = "curve -d 1";
    string $xyz[] = {"x", "y", "z"};
    string $command = ("\$ni ="+"$v"+"."+$xyz[$ZeroOneTwo]);
    string $K = "";
    string $curve = "curve -d 1";
    string $Newcurvez = `eval($curve)`;
    string $newPlaneCurve = VecArrayToCurve($AllPlaneLocPositionZ);
    string $itemOne[] = `ls -sl`;
    string $newCurvei = VecArrayToCurve($AllPlaneLocs);
    string $C[];
    string $nametypeZi;
    string $nameA;
    string $nameB;
    string $CurveItemZ[] = `ls -sl`;
    string $ObjectSel[] = `ls -sl`;
    string $attr = $object +".worldMatrix";
    string $multNode;
    string $stringFloat[] = FloatArrayToStringArray($FLoatMatrixA);
    string $Syb = " ";
    string $printcommand = "";
    string $AddedSPaces = AddItemString($BytNumDiff[$IndXeF], $Syb);
    string $AddItem = "";
    string $itemD[] = `duplicate -rr $item`;
    string $CurveItemZai[];
    string $curvesZi = $CurveItemZai[0];
    string $TestCurveC;
    string $OneCurve[] = `ls -sl`;
    string $OneCurveS = $OneCurve[0];
    string $CurveNS;
    string $NewOneCurveS;
    string $PCurvesName = "Plane";
    string $Combine;
    string $PlaneCurvA[];
    string $LayerCurvesRangeA[] = `queryLayerRangeMembers`;
    string $newCircle[] = `MakeCIRCLE($StereoCurveZ)`;
    string $CurveItemZbi = $StereoCurveZ[1];
    string $queryLocCurveEnds3D[];
    string $AllLocs_String[] = IntArrayToStringArray($AllLocsi);
    string $EmptyStringNewOrderA[];
    string $EmptyStringNewOrderB[];
    string $NewFoundLocs[];
    string $arrayCurvesNear[];
    string $AllCirTemp[];
    string $CirTemp[];
    string $ThefirstCurve = VecArrayToCurve($Intersect_A);
    string $ThefirstCurvei = VecArrayToCurve($Intersect_B);
    string $intersectNode = `createNode curveIntersect`;
    string $curveIntersectZ = "";
    string $buffer[];
    string $param = eval("paramLocator "+ $TwoCurveA[1] + ".u[" + $buffer[7] + "]");
    string $paramANDCurve[];
    string $curvesZ[];
    string $FloatSTRING[] = FloatArrayToStringArray($intersections1A);
    string $Ax = stringArrayToString($FloatSTRING, " ");
    string $Axi = stringArrayToString($FloatSTRING, " ");
    string $SortedRangeCrv[];
    string $newNames;
    string $ExpandedStringi[];
    string $ExpandedStringiS[];
    string $ExpandedStringii[];
    string $ExpandedStringiiS[];
    string $diff[] = stringArrayRemoveDuplicates($ExpandedStringi);
    string $diffS[] = stringArrayRemoveDuplicates($ExpandedStringiS);
    string $arrayCurvesNearABM[];
    string $arrayCurvesNearS[];
    string $ExpandedStringiim[];
    string $diffB[] = stringArrayRemoveExact($arrayCurvesNearABM, $diff);
    string $diffB_s[] = stringArrayRemoveExact($arrayCurvesNearS, $diffS);
    string $interVecAx[];
    string $interVecAy[];
    string $CURVEiA[];
    string $PointOnCrv_String[] = IntArrayToStringArray($PointOnCrvIND);
    string $EmptyCA[];
    string $CURVEiAb[];
    string $paramb;
    string $PointOnCrv_Stringb[] = IntArrayToStringArray($PointOnCrvINDb);
    string $EmptyCAb[];
    string $CurveA = $diffB[$NodeCurveIndexi[$WhatCurve]];
    string $CurveB = $diffB[$NodeCurveIndex[$WhatCurveb]];
    string $newNamesCA = $CurveA;
    string $newNamesCB = $CurveB;
    string $selectionItemB = $CurveB + ".u[" +$uParam+ "]";
    string $selectionItemA = $CurveA + ".u[" +$uParam+ "]";
    string $detachCurve1[] = `detachCurve -ch off - replaceOriginal on $selectionItemB`;
    string $detachCurve2[] = `detachCurve -ch off - replaceOriginal on $selectionItemA`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size  ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`;
    string $Newcurve[] = {$Newcurvez};
    string $circlesZ[];
    string $CurveBetween;
    string $ThreePoints[] = { "0", "1", "2"};
    string $curveA = "curve -d 1";
    string $curveB = "curve -d 1";
    string $NewcurvezA = `eval($curveA)`;
    string $NewcurvezB = `eval($curveB)`;
    string $NewcurvezAB[];
    string $stringF[];
    string $EmptyIndx[];
    string $stringIndTr[] = IntArrayToStringArray($index);
    string $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    string $ExpandedString[];
    string $arrayCurvesNearA[];
    string $arrayCurvesNearB[];
    string $curvesZii = $ThefirstCurvei;
    string $NewOneCurveSB;
    string $StereoCircle[] = Eval3DCircleStereo( $NewArrayBEllipZ  , $EmptyVectorArrayB ,  $NewArrayAEllipZ , $EmptyVectorArrayA );
    string $queryLocCurveEnds[] = queryLocOnLivePlaneBLayer();
    string $queryLocCurveEndsOLD[] = $queryLocCurveEnds;
    string $NearCurvesEnds[];
    string $BothCurves[];
    string $LocA = $queryLocCurveEnds[$NearestInt[0]];
    string $LocB = $queryLocCurveEnds[$NearestIntB[0]];
    string $LocName;
    string $Loc_AorB = "";
    string $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    string $AllarrayCurvesNear[];
    string $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    string $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    string $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    string $CurvesV[];
    string $LocsV[];
    string $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    string $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    string $VanishingLOC[];
    string $DirectionsZ[] = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    string $Alll = "";
    string $AllStrings[];
    string $EmptyIndxNewOrder[];
    string $BestThree[];
    string $CirTempi[] = `ls -sl`;
    string $newCurveii;
    string $CurveAv[];
    string $newNamesResultA1;
    string $ThreeDCurvesNear[];
    string $CurveItemAa[];
    string $StringAllNearA[];
    string $newNamesResultAx = substituteAllString($newNames, "Plane", "");
    string $arrayCurvesNearA1[];
    string $SetCol = `setAttr ($VanishingLOC[size($VanishingLOC)-1]+".overrideColor ") 6 `;
    string $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    string $LocNames[];
    string $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
    vector $planePointN;
    vector $EmptyVecA[];
    vector $EmptyVecB[];
    vector $NewCurveVecPts[];
    vector $eachCurveVec;
    vector $newTranVec;
    vector $v = $veci;
    vector $AllLocPositionsZ[];
    vector $AllPlaneLocPositionZ[] = VecPointsToCameraPlane($AllLocPositionsZ);
    vector $AllPlaneLocs[];
    vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
    vector $Vai = $VecbvA[0];
    vector $Vbi = $VecbvA[1];
    vector $VbiUnit = << $u, $v, $w >>;
    vector $VbiUnitA = `unit $VbiUnit`;
    vector $YUV = << $Y, $U, $V>>;
    vector $Va = << $posAZ[0], $posAZ[1], $posAZ[2] >>;
    vector $Vb = << $posBZ[0],  $posBZ[1], $posBZ[2] >>;
    vector $VecLi[];
    vector $NewVeci;
    vector $CurveCollectVec[];
    vector $nevVec[] = NewVecOrderWithINTKey($NewIndex,$CurveCollectVec);
    vector $vectorZnewX[];
    vector $EmptyVectorArrayA[];
    vector $PositionsZ_A[];
    vector $AllLocPositionsZi[];
    vector $VecCurEndsa[] = VecCurveEnds({$CurveItemZai});
    vector $VecCurEndsb[] = VecCurveEnds({$CurveItemZbi});
    vector $PositionsZ_B[];
    vector $VecPtsMirrorA[];
    vector $VecPtsMirrorB[];
    vector $VecPtsMirrorEnds_A[];
    vector $VecPtsMirrorEnds_B[];
    vector $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
    vector $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);
    vector $Vecbv[];
    vector $Vecbvi[];
    vector $NewVecENDsi[];
    vector $CRV_ENDSi[];
    vector $CRV_ENDSii[];
    vector $DDirEpipolXYZ[];
    vector $AllEpipolXYZ[];
    vector $EpipolD[];
    vector $LineMidi;
    vector $NewDirZi;
    vector $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    vector $Intersect_LineB_a;
    vector $Intersect_LineB_b = FloatToVec (lineIntersection($MidCurveB, $DDirEpipolA, $VecCurEndsa[1],$FloatDirEpipolB));
    vector $IntersectEnds_A[];
    vector $Intersect_A[];
    vector $IntersectForce_A[];
    vector $IntersectAverage_A[];
    vector $PositionsZ_Ai[];
    vector $PositionsZ_Bi[];
    vector $LocCurveEndsVec3D[] = PointArray($queryLocCurveEnds3D);
    vector $PointsA[];
    vector $PointsB[];
    vector $VecOnPlaneA[];
    vector $VecOnPlaneB[];
    vector $LocOnPlaneVec[] = PointArray($NewFoundLocs);
    vector $Intersect_B[];
    vector $LocSMirror[];
    vector $AllNearestVecCA[];
    vector $VecPointOnCrv[];
    vector $NearestVecCA = $VecPointOnCrv[$New_PointOnCrvIND_A[0]];
    vector $AllNearestVecCAb[];
    vector $VecPointOnCrvb[];
    vector $NearestVecCAb = $VecPointOnCrvb[$New_PointOnCrvIND_Ab[0]];
    vector $CUT_CrvMirrorEnds_A[] = VecPtsToZMirrorPts({$NearestVecCAb});
    vector $CUT_CrvIntersectEnds_A = FloatToVec (lineIntersectionF($CamPos_A, $NearestVecCA, $CamPos_M, $CUT_CrvMirrorEnds_A[0]));
    vector $CUT_CrvIntersectMirrorEnds_A[] = VecPtsToZMirrorPts({$CUT_CrvIntersectEnds_A});
    vector $VecCUT_CrvA = FloatToVec (FloatPointsToCamPlane($VecIntCB));
    vector $VecCUT_CrvB = FloatToVec (FloatPointsToCamPlane($VecIntCA));
    vector $VlocA;
    vector $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    vector $VecLineDir = PositiveDir($DirectionLineF);
    vector $VecLineDirM = $VecLineDiri-$VecLineDir;
    vector $tan;
    vector $norm;
    vector $bi;
    vector $Avec[];
    vector $AVvects[];
    vector $Aver;
    vector $CurveVectors[];
    vector $Ui = FloatToVec($p1p2);
    vector $Vi = FloatToVec($p1p3);
    vector $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;
    vector $U1 = TwoVecsOrFloats($point2, $point1);
    vector $V1 = TwoVecsOrFloats($point3, $point1);
    vector $U2 = TwoVecsOrFloats($point3, $point1);
    vector $V2 = TwoVecsOrFloats($point2, $point1);
    vector $U3 = TwoVecsOrFloats($point1, $point3);
    vector $V3 = TwoVecsOrFloats($point2, $point3);
    vector $normalV[];
    vector $DirNormi = FloatToVec ($FDirNorAi);
    vector $MidVec = FloatToVec( $MidPt);
    vector $ABC[];
    vector $DirecOfPointABi = FloatToVec ( DirectionFN($FixVeci[0], $FixVeci[1]));
    vector $VecH[];
    vector $aV = FloatToVec($valuesA);
    vector $bV = FloatToVec($valuesiAi);
    vector $VecAverage = FloatToVec($AverageVecCurve);
    vector $SharpValuesTan[];
    vector $FlushVectors[];
    vector $valuesTan[];
    vector $valuesTanSpace[];
    vector $valuesTanPastSpace;
    vector $valuesTanPast;
    vector $DeepPastTan;
    vector $DeepPast;
    vector $threeVecsT[];
    vector $CurrentVecT;
    vector $eachVecLine;
    vector $Xdirect;
    vector $Ydirect;
    vector $Zdirect;
    vector $XYZdirect[];
    vector $NewDirectionZ;
    vector $XYZdirectL[];
    vector $LineDirect_3D;
    vector $IntersectEnds_Ax[];
    vector $PositionsZ_Bii[];
    vector $PositionsZ_Aii[];
    vector $PtsMirrorAi[];
    vector $LoCz_3D[];
    vector $TXI = << -1.0 , 1.0, 1.0>>;
    vector $UnconnectedEnds[];
    vector $Xdirection = << 1.0,0.0,0.0>>;
    vector $Intersect_BX[];
    vector $PairVectors[];
    vector $EpipolXLine = DirectionFN( $MidEpipolPosFCam, $PairVectors[$PairInt[0]]);
    vector $EndrEndsa[] = VecCurveEnds({$ThefirstCurvei});
    vector $EmptyVectorArrayB[];
    vector $Dir_VecMAIN;
    vector $threeVecs[];
    vector $Dir_VecA;
    vector $Positions[];
    vector $VecCurEnds[] = VecCurveEnds({$TempCrv});
    vector $LocCurveEndsVec[] = PointArray($queryLocCurveEnds);
    vector $EndSnapAndEndProject[];
    vector $endNotNearZ[];
    vector $NearEndZ;
    vector $Loc3D_Vec[] = PointArray($NewFoundLocs );
    vector $ALLLoc3D_VecAB[] = PointArray($AllarrayCurvesNear);
    vector $ReducedVecAB[];
    vector $ALLLoc3D_Vec[];
    vector $MovedEndPointPlane[] = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    vector $Dir_CamRay;
    vector $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    vector $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);
    vector $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    vector $One;
    vector $each;
    vector $NearPointsXYZ[];
    vector $ReducedVec[];
    vector $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    vector $VecLineDirMi;
    vector $PointN_LineXYZ;
    vector $SnapN;
    vector $SnapPlaceN;
    vector $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);
    vector $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    vector $Points3DPair_And_2DPair[];
    vector $Crv_Pts[];
    vector $MirrorAcrossPlaneVecs[] = VecMultMatrixMirror($Crv_Pts);
    vector $DirLine = DirectionFN( $VecLoc, $Pos_A);
    vector $TranstatedVecs[];
    vector $PointN_Line = ClosestPoint2LineVec($Dir_CamRay, $MovedEndPointPlane[0], $Loc3D_Vec[0]);
    vector $PointN_LineB = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $PointN_Line);
    vector $PositionsZ_Ax[];
    vector $ZYplaneMatrix[];
    vector $VecDirection_A_XYZ[];
    vector $VecDirectionXYZ[];
    vector $VecXYZsOnPlane[] = VecPointsToCameraPlane($VecXYZs);
    vector $VecXYZsOnPlaneiY[];
    vector $VecXYZsOnPlaneiiY[];
    vector $VecXYZsOnPlaneVpoint[];
    vector $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
    vector $VIntersectEnds_A[];
    vector $ObjLoc3DCurv[];
    vector $LocCurveEndsVec_3D[] = PointArray($arrayCurvesNearA1);
    vector $PointN_LineA = ClosestPoint2LineVec($LineDirect_3D, $VecCurEnds[0], $LocCurveEndsVec_3D[0]);
    vector $NearVecPts[];
    vector $PositionsZ_Aiix[];
    vector $VecTest[];
    vector $FistAndSecond[];
    vector $VecA = $FistAndSecond[0];
    vector $VecB = $FistAndSecond[1];
    vector $ReversePositionsZ_Ai[] = ReverseVectorArray($PositionsZ_Ai);
    vector $XIntersect_Ax[];
    vector $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pAv = AverageVectorPoint($Vec);
    $n = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    $DistanceLoc = distance2Pts(  $Veciiv, $pAv);
    $MultDirCam = multiplyFloat($DistanceLoc, $n);
    $FloatDirectionCamNormalA = AddFloats($pAv, $MultDirCam);
    $PointN = ClosestPoint2LineVec($n, $pAv, $Veciiv);
    //CHANGE_HERE useing distance
    //int $CombA = distance2Pts($PointN, $pAv);
    $CombA = PointsEquivalentTol ($PointN, $pAv);
    //if($CombA != 0){
    if($CombA != 3){
    //KEY switch these to findthe one that makes sence
    $FloatDirectionAi = DirectionFN($pAv,$PointN);
    //float $FloatDirectionAi[] = DirectionFN($PointN,$pAv);
    $DistanceLoc = distance2Pts( $PointN, $pAv );
    $MultDirPC1 = multiplyFloat($DistanceLoc, $FloatDirectionAi);
    $AddMultMiiF = AddFloats($Veciiv, $MultDirPC1);
    $planePointN = << $AddMultMiiF[0], $AddMultMiiF[1], $AddMultMiiF[2]>>;
    }else{ $planePointN = $Veciiv;
    }
    return $planePointN;
    }

    proc vector [] Matrix_Curve_Translation(vector $VecPairA[],vector $VecPairB[], vector $CurveVecPointZ[]){
    matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    matrix $matrixB[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $matrixA = TwoPointMatrixPlusAxisWorld($VecPairA, $EmptyVecA, 1);
    $matrixB = TwoPointMatrixPlusAxisWorld($VecPairB, $EmptyVecB, 1);
    // Get scale changerelative to multiply in matrix
    // 3 7 11 // shear
    // float matrix size 16 numbers its index Number for Scale is 15
    // matrix [3][3]
    $LengthA = distance2Pts ($VecPairA[0], $VecPairA[1]);
    $LengthB = distance2Pts ($VecPairB[0], $VecPairB[1]);

    if($LengthA<$LengthB){$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}else{$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}
    $LengthAB *= $Sign_F;
    $MatrixFB = MatrixToFloat($matrixB);
    size $MatrixFB;
    //PrintMatrix($matrixB, 4);
    $MatrixFB[15] = $LengthAB;
    $matrixNB = FloatToMatrix($MatrixFB);
    //PrintMatrix($matrixNB, 4);
    $curvei = "curve -d 1";
    $CountCpts =0;
    for($eachCurveVec in $CurveVecPointZ){

    //Key MatrixAxisTranlation
    $newTranVec = MatrixAxisTranlation($eachCurveVec, $matrixA, $matrixNB);
    $AddMepi = $newTranVec;
    $NewCurveVecPts[$CountCpts] = <<$AddMepi[0],$AddMepi[1],$AddMepi[2]>>;
    $curvei += " -p "+$AddMepi[0]+" "+$AddMepi[1]+" "+$AddMepi[2];
    $CountCpts++;
    }
    //eval($curvei);
    //ResetTransEachSL;
    return $NewCurveVecPts;
    }


    //END of Matrix Axis Translation
    ///////////////////////////////////////////////////////////////////////////


    proc float VectorsComp(int $ZeroOneTwo , vector $veci){
    $xyz = {"x", "y", "z"};
    $v = $veci;
    $command = ("\$ni ="+"$v"+"."+$xyz[$ZeroOneTwo]);
    return  eval($command);
    }

    proc string VecArrayToCurve(vector $FixVec[]){
    $sIZes = `size $FixVec `;
    $NUmers = CreateIntIndex($sIZes);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $curve = "curve -d 1";
    for ($eachVeCx in $FixVec){
    $valuesBi = $eachVeCx;
    $curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    }
    $curve += " "+ $K;
    $Newcurvez = `eval($curve)`;
    return $Newcurvez;
    }
    proc PointCurvesToPlaneCurve(string $CurveItemZ[]){
    for ($eachCurve in $CurveItemZ){
    clear $AllLocPositionsZ;
    $AllLocPositionsZ = VecCurveEps( $eachCurve );
    $AllPlaneLocPositionZ = VecPointsToCameraPlane($AllLocPositionsZ);
    $newPlaneCurve = VecArrayToCurve($AllPlaneLocPositionZ);
    ResetTranslation({$newPlaneCurve});
    }
    }
    proc float [] EulerAngB(float $pointB1[], float $pointB2[]){
    $EulerAngleA = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
    return $EulerAngleA;
    }

    proc float [] MirrorPointFrom3PointPlane(vector $SelectVec[], float $oneItemFLoats[]){
    //p t n Are just a directions....
    $p = $SelectVec[0];
    $t = $SelectVec[1];
    $n = $SelectVec[2];
    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
    $norm = `unit << $n[0], $n[1], $n[2] >>`;
    // Calculate the binormal.
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
    << ($norm.x), ($norm.y), ($norm.z) >>`;
    // Normalize our vector.
    $bi = `unit $bi`;
    $x = $oneItemFLoats[0];
    $y = $oneItemFLoats[1];
    $z = $oneItemFLoats[2];
    $bi *=-1.0;
    $normal = $bi;
    $p = AverageVectorPoint($SelectVec);
    $d = $normal[0] * $p[0] + $normal[1] * $p[1] + $normal[2] * $p[2] ;
    $dist = $x * $normal[0] + $y * $normal[1] + $z * $normal[2] - $d ;
    $dist *=-1.0;
    $mp[0] = $x ;
    $mp[1] = $y ;
    $mp[2] = $z ;
    $dist *= 1.0 ;
    $dist += -1.0;
    $mp[0] = ($x + 2.0 * $normal[0] * ($dist))   ;
    $mp[1] = ($y + 2.0 * $normal[1] * ($dist))   ;
    $mp[2] = ($z + 2.0 * $normal[2] * ($dist))   ;

    return $mp;
    }

    /*
    $itemOne = `ls -sl`;
    $LivePlanePosX = `xform -q -ws -t $itemOne[0]`;
    $MirrorF = MirrorPointFrom3PointPlane( PointArrayT(`ls -sl`), $LivePlanePosX);
    Loc $MirrorF;

    */


    proc vector [] PointCurvesToMirrorPoint(string $CurveItemZ[], vector $SelectVec[]){
    clear  $AllPlaneLocs;
    clear $AllLocPositionsZ;
    $AllLocPositionsZ = VecCurveEps($CurveItemZ[0] );
    for ($eachVecEp in $AllLocPositionsZ){
    $AllPlaneLocs[`size($AllPlaneLocs)`] = `FloatToVec (MirrorPointFrom3PointPlane( $SelectVec, $eachVecEp))`;
    }
    $newCurvei = VecArrayToCurve($AllPlaneLocs);
    ResetTranslation({$newCurvei});
    return $AllPlaneLocs;
    }
    proc vector [] PtCurvesToZMirrorPt(string $CurveItemZ[]){
    clear  $AllPlaneLocs;
    clear $AllLocPositionsZ;
    $AllLocPositionsZ = VecCurveEps($CurveItemZ[0] );
    for ($eachVecEp in $AllLocPositionsZ){
    $Zx = $eachVecEp;
    $Zx[0] *= -1.0;
    $AllPlaneLocs[`size($AllPlaneLocs)`] = `FloatToVec ($Zx)`;
    }
    $newCurvei = VecArrayToCurve($AllPlaneLocs);
    ResetTranslation({$newCurvei});
    return $AllPlaneLocs;
    }
    proc vector [] VecPtsToZMirrorPts(vector $AllLocPositionsZ[]){
    clear  $AllPlaneLocs;
    for ($eachVecEp in $AllLocPositionsZ){
    $Zx = $eachVecEp;
    $Zx[0] *= -1.0;
    $AllPlaneLocs[`size($AllPlaneLocs)`] = `FloatToVec ($Zx)`;
    }
    return $AllPlaneLocs;
    }



    proc int addStereoCurve(){
    $CreatedObjectCurve = `ISSelectedTypeCurve`;
    return $CreatedObjectCurve;
    }
    /////////////////
    proc int ISSelectedTypeCurve(){
    $C = `ls -sl`;
    $nametypeZi= `getTypeItemString $C`;
    $nameA = `match "[a-zA-Z]+" $nametypeZi`;
    $nameB = `match ".urve" $nameA`;
    $zeroOR1Z = `gmatch $nameB "*[C-c]urve*"`;
    return $zeroOR1Z;
    }
    ///////////////////

    ////////////////////
    proc int addCurveNumbers(int $addNumbersiA){
    $addNumbersiA++;
    if($addNumbersiA>2){$addNumbersiA=0;}
    return $addNumbersiA;
    }
    ///////////////
    proc EvalAddingCurves(){
    global int $addNumbersA;
    $addNumbersA = addCurveNumbers($addNumbersA);
    print $addNumbersA;
    }
    //////////////////
    //////////////////

    proc float [] FloatPointsToCamPlane(float $LocPos1[]){
    $Pi = 3.1415926535;
    $pi = 3.1415926535;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $LivePlanePos = `xform -q -ws -t LiveSurfaceB`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $CamerasDirectionVector = $CamerasDirectionVectorNormal;
    $FloatDirectionA = DirectionFN($CamPos1, $LocPos1);
    $DistanceLoc = distance2Pts( $LocPos1, $CamPos1 );
    $DistanceLocA = $DistanceLoc;
    $DistanceLoc = $DistanceLoc * -1;
    $MultDirPC1 = multiplyFloat($DistanceLoc, $CamerasDirectionVector);
    $FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1);
    $CamerasDirectionVectorA = DirectionFN($FloatDirectionCamNormal, $CamPos1);
    $MultDirPC1A = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
    $FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1A);
    $p1 = $CamPos1;
    $p2 = $LocPos1;
    $p3 = $FloatDirectionCamNormal;
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );
    $FloatPosZero = {0, 0, 0};
    $FloatDirection = DirectionFN($FloatPosZero, $normal);
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $mid3 = midPoint2Pts( $p2, $p3 );
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    $FloatDirPerpCenterC = DirectionFN($center,$mid2);
    $FloatDirPointAC = DirectionFN($p1, $p3);
    $center8 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
    $FloatDirLocToPerpIntersect = DirectionFN($center8,$p2);
    $OnPlane = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );
    return $OnPlane;
    }

    //PROBLEM

    proc float[] DirectionF(float $EACHCVposAZ[], float $EACHCVposBZ[]){
    $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    //This is freaky since it is reversed!! not sure I could ever fix this
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]);
    /*
    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]);
    */
    $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
    $UnitDirection = $vectorUnit;
    ///////////////////////////////////////////////// ////
    return $UnitDirection;
    }


    proc float[] DirectionFN(float $posAZ[], float $posBZ[]){

    /*

    $Vai = $VecbvA[0];
    $Vbi = $VecbvA[1];

    */

    $Vai = << $posAZ[0], $posAZ[1], $posAZ[2] >> ;
    $Vbi = << $posBZ[0],  $posBZ[1], $posBZ[2] >> ;

    $xi = $Vai.x;
    $yi = $Vai.y;
    $zi = $Vai.z;
    $x = $Vbi.x;
    $y = $Vbi.y;
    $z = $Vbi.z;
    $u = $xi - $x;
    $v = $yi - $y;
    $w = $zi - $z;


    $VbiUnit = << $u, $v, $w >> ;
    $VbiUnitA = `unit $VbiUnit`;
    /*
    $e = 1;
    //float $Mult = $e*$v;
    $Y = $u/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $U = $v/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $V = $w/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $YUV = << $Y, $U, $V>>;
    $UnitDirection = $YUV;
    */
    $UnitDirection = $VbiUnitA;

    //////////
    return $UnitDirection;
    }


    /*
    proc float[] DirectionF(float $posAZ[], float $posBZ[]){

    $Va = << $posAZ[0], $posAZ[1], $posAZ[2] >> ;
    $Vb = << $posBZ[0],  $posBZ[1], $posBZ[2] >> ;

    $xi = $Va.x;
    $yi = $Va.y;
    $zi = $Va.z;
    $x = $Vb.x;
    $y = $Vb.y;
    $z = $Vb.z;
    $u = $xi - $x;
    $v = $yi - $y;
    $w = $zi - $z;
    $e = 1;
    //float $Mult = $e*$v;
    $Y = $u/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $U = $v/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $V = $w/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $YUV = << $Y, $U, $V>>;
    $UnitDirection = $YUV;
    //////////
    return $UnitDirection;
    }
    */


    ///////////////////////////////////////////////////////////////////////////



    //STart up the engine
    /*

    EvalAllCurvesToolZ;
    $scriptt_jobNumConnectionChanged = `scriptJob -conditionChange delete evalVectorIndexAdditionSubtract`;
    eval(" $jobNumtranslateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.translate  RUNMoveZCURVEM`;");
    eval(" $jobNumrotateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.rotate  RUNMoveZCURVEM`;");

    select -r LiveSurfaceB ;
    MakeLive;
    PencilCurveTool;

    */










    //eval("print $gLastAction");

    ///////////////////










    //////////////////////////////////////////////////////////End of all known used Stereo_curve


    proc setTranslationObj(string $objectitem1[], float  $tranlate[] ){
    setAttr ($objectitem1[0]+".translate") $tranlate[0] $tranlate[1] $tranlate[2];
    }
    proc SetObjectsToROundPoints( string $objectZ[], vector $FixVec[]){
    $IndeXa = 0;
    for ($eachObject in $FixVec){
    $newF  = roundFloatsInt($eachObject);
    setTranslationObj( {$objectZ[$IndeXa]}, $newF );
    $IndeXa++;
    }
    }

    proc DisRotPiv(){
    $CurveItemZ = `ls -sl`;
    for ($eachItemC in $CurveItemZ){
    setAttr ($eachItemC +".displayRotatePivot") 1;
    }
    }

    proc cubic(float $a, float $b, float $c, float $d, float $resultReal[] , float $resultImaginary[]) {
    /*
    if ( abs(a) < 0.000001) {
    //
    if a=0 equation is quadratic
    // handle seperately to avoid divide by zero
    quadratic(b,c,d,$resultReal,$resultImaginary);
    // the quadratic function is defined on this page:
    // http://www.euclideanspace.com/maths/algebra/equations/polynomial/quadratic/
    return;
    }
    */
    $a = 7.5;
    $b = 3.4;
    $c = 5.3;
    $d = 1.7;
    // recuring terms
    //proc cubic(float $a, float $b, float $c, float $d, float $resultReal[] , float $resultImaginary[]) {
    $t1 = ((2*$a*$a*$a) - (9*$a*$b) +(27*$c));
    $t2 = ((-$a*$a) + (3*$b));
    $t3 = $t1*$t1 + 4*$t2*$t2*$t2;
    // if ($t3<0) handle complex roots;
    $t4 = ((-$t1 + (`sqrt $t3`))/54);
    $t41 = ((-$t1 - (`sqrt $t3`))/54);
    $t5 = ((-$a*$a) + (3*$b));
    $t6 = `sqrt($t1*$t1 + (4*$t5*$t5*$t5))`;
    $t7 = ((-$t1 - $t6)/54);
    $TimesOne = 1.0;
    if($t7<0){ $TimesOne = -1.0;}
    //print $t4;
    //print $t7;
    //print $t41;
    $N = 1;
    if($t7<0){$N=-1;}
    $Ni = 1;
    if($t41<0){$Ni=-1;}
    $resultReal[0] = (-$a/3) + (` pow  $t4 (1.0/3.0)` ) +  $N*(` pow  ($t7*$N) (1.0/3.0)`) ;
    $resultReal[1] = (-$a/3) - (0.5*(`pow $t4 (1.0/3.0)`)) +  (-0.5*(`pow $t4 (1.0/3.0)`));
    $resultReal[2] = (-$a/3) + (`pow $t4 (1.0/3.0) `) + $Ni*(`pow ($Ni*$t41) (1.0/3.0)`);
    $resultImaginary[0] = 0;
    $resultImaginary[1] =  (`sqrt $t3`) * 0.5 * (`pow $t4 (1.0/3.0)`) +  (`sqrt $t3` )*0.5*(`pow $t4 (1.0/3.0) `) ;
    $resultImaginary[2] = 0;
    print $resultReal;
    print("\n");
    print  $resultImaginary;
    print("\n");
    }
    proc float DoubleDeterminant(matrix $mat[][]) {
    $valueA = $mat[0][3] * $mat[1][2] * $mat[2][1] * $mat[3][0]-$mat[0][2] * $mat[1][3] * $mat[2][1] * $mat[3][0];
    $valueB = $mat[0][3] * $mat[1][1] * $mat[2][2] * $mat[3][0]+$mat[0][1] * $mat[1][3] * $mat[2][2] * $mat[3][0]+ $mat[0][2] * $mat[1][1] * $mat[2][3] * $mat[3][0]-$mat[0][1] * $mat[1][2] * $mat[2][3] * $mat[3][0];
    $valueC = $mat[0][3] * $mat[1][2] * $mat[2][0] * $mat[3][1]+$mat[0][2] * $mat[1][3] * $mat[2][0] * $mat[3][1]+ $mat[0][3] * $mat[1][0] * $mat[2][2] * $mat[3][1]-$mat[0][0] * $mat[1][3] * $mat[2][2] * $mat[3][1];
    $valueD = $mat[0][2] * $mat[1][0] * $mat[2][3] * $mat[3][1]+$mat[0][0] * $mat[1][2] * $mat[2][3] * $mat[3][1]+ $mat[0][3] * $mat[1][1] * $mat[2][0] * $mat[3][2]-$mat[0][1] * $mat[1][3] * $mat[2][0] * $mat[3][2];
    $valueE = $mat[0][3] * $mat[1][0] * $mat[2][1] * $mat[3][2]+$mat[0][0] * $mat[1][3] * $mat[2][1] * $mat[3][2]+ $mat[0][1] * $mat[1][0] * $mat[2][3] * $mat[3][2]-$mat[0][0] * $mat[1][1] * $mat[2][3] * $mat[3][2];
    $valueF = $mat[0][2] * $mat[1][1] * $mat[2][0] * $mat[3][3]+$mat[0][1] * $mat[1][2] * $mat[2][0] * $mat[3][3]+ $mat[0][2] * $mat[1][0] * $mat[2][1] * $mat[3][3]-$mat[0][0] * $mat[1][2] * $mat[2][1] * $mat[3][3];
    $valueG = $mat[0][1] * $mat[1][0] * $mat[2][2] * $mat[3][3]+$mat[0][0] * $mat[1][1] * $mat[2][2] * $mat[3][3];
    $value = $valueA - $valueB - $valueC - $valueD - $valueE - $valueF - $valueG;
    return $value;
    }
    /////////////////////////
    proc Quaternion()
    {
    $ObjectSel = `ls -sl`;
    ///////WRONG Attr!
    $ParamX =  getAttr ($ObjectSel[0]+".rx") ;
    $ParamY =  getAttr ($ObjectSel[0]+".ry") ;
    $ParamZ =  getAttr ($ObjectSel[0]+".rz") ;
    $x = deg_to_rad($ParamX );
    $y = deg_to_rad($ParamY );
    $z = deg_to_rad($ParamZ );
    $x = -$x * 0.5;
    $y = -$y * 0.5;
    $z = -$z * 0.5;
    $cx =  cos($x) ;
    $cy =  cos($y) ;
    $cz =  cos($z) ;
    $sx =  sin($x) ;
    $sy =  sin($y) ;
    $sz =  sin($z) ;
    $cycz = $cy * $cz;
    $sysz = $sy * $sz;
    $sycz = $sy * $cz;
    $cysz = $cy * $sz;
    $Qw = $cycz * $cx + $sysz * $sx;
    $Qx = $cycz * $sx + $sysz * $cx;
    $Qy = $sycz * $cx - $cysz * $sx;
    $Qz = $cysz * $cx - $sycz * $sx;
    $l = sqrt( $Qx*$Qx + $Qy*$Qy + $Qz*$Qz + $Qw*$Qw );
    if( $l == 0 )
    {
    $Qx = 0;
    $Qy = 0;
    $Qz = 0;
    }
    else
    {
    $Qx /= $l;
    $Qy /= $l;
    $Qz /= $l;
    $Qw /= $l;
    }
    $angle = acosd($Qw) * 2;
    $sinHalfAngle = sqrt(1 - ($Qw * $Qw));
    if ($sinHalfAngle != 0)
    {
    $Qx = $Qx / $sinHalfAngle;
    $Qy = $Qy / $sinHalfAngle;
    $Qz = $Qz / $sinHalfAngle;
    }
    else
    {
    $Qx = 1;
    $Qy = 0;
    $Qz = 0;
    }
    $angleN = $angle;
    // this is just for the other print that truncates to 0.00//
    $rAngle = $angle;
    $rX = $Qx*100; float $fx = $rX; float $xxx = $fx/100;
    $rY = $Qy*100; float $fy = $rY; float $yyy = $fy/100;
    $rZ = $Qz*100; float $fz = $rZ; float $zzz = $fz/100;
    // truncated print is muted, DOES NOT ROUND OFF //
    //print ($xxx+" "+-$zzz+" "+$yyy+" "+$rAngle);
    print ($Qx+" "+-$Qz+" "+$Qy+" "+$angleN);
    }
    proc cubic(float $a, float $b, float $c, float $d, float $resultReal[] , float $resultImaginary[]) {
    $t1 = ((2*$a*$a*$a) - (9*$a*$b) +(27*$c));
    $t2 = ((-$a*$a) + (3*$b));
    $t3 = $t1*$t1 + 4*$t2*$t2*$t2;
    // if ($t3<0) handle complex roots;
    $t4 = ((-$t1 + (`sqrt $t3`))/54);
    $t41 = ((-$t1 - (`sqrt $t3`))/54);
    $t5 = ((-$a*$a) + (3*$b));
    $t6 = `sqrt($t1*$t1 + (4*$t5*$t5*$t5))`;
    $t7 = ((-$t1 - $t6)/54);
    $TimesOne = 1.0;
    if($t7<0){ $TimesOne = -1.0;}
    $Nin = 1;
    if($t4<0){$Nin=-1;}
    $N = 1;
    if($t7<0){$N=-1;}
    $Ni = 1;
    if($t41<0){$Ni=-1;}
    $Niin = 1;
    if($t3<0){$Niin=-1;}
    $resultReal[0] = (-$a/3) + $Nin*(` pow ($Nin*$t4) (1.0/3.0)` ) +  $N*(` pow  ($t7*$N) (1.0/3.0)  `) ;
    $resultReal[1] = (-$a/3) - (0.5*($Nin*(` pow ($Nin*$t4) (1.0/3.0)` ))) +  (-0.5*($Nin*(` pow ($Nin*$t4) (1.0/3.0)` )));
    $resultReal[2] = (-$a/3) + $Nin*(` pow ($Nin*$t4) (1.0/3.0)` ) + $Ni*(`pow ($Ni*$t41) (1.0/3.0) `);
    $resultImaginary[0] = 0;
    $resultImaginary[1] =  (`sqrt $t3`) * 0.5 * ($Nin*(` pow ($Nin*$t4) (1.0/3.0)` )) +  (`sqrt $t3` )*0.5*($Nin*(` pow ($Nin*$t4) (1.0/3.0)` )) ;
    $resultImaginary[2] = 0;
    print $resultReal;
    print("\n");
    print  $resultImaginary;
    print("\n");
    }
    proc float [] lineIntersectionF(float $PosA[], float $PosB[], float $PosC[], float $PosD[]){
    $DirAB = DirectionF ($PosA, $PosB);
    $DirCD = DirectionF ($PosC, $PosD);
    $locsA = lineIntersection($PosA, $DirAB, $PosC, $DirCD);
    return $locsA;
    }
    // Get a matrix
    proc matrix screenSpaceGetMatrix(string $attr){
    $v = `getAttr $attr`;
    matrix $mat[4][4]=<<$v[0], $v[1], $v[2], $v[3];
    $v[4], $v[5], $v[6], $v[7];
    $v[8], $v[9], $v[10], $v[11];
    $v[12], $v[13], $v[14], $v[15]>>;
    return $mat;
    }
    // Multiply the vector v by the 4x4 matrix m, this is probably
    // already in mel but I cant find it.
    proc vector screenSpaceVecMult(vector $v, matrix $m){
    matrix $v1[1][4]=<<$v.x, $v.y, $v.z, 1>>;
    matrix $v2[1][4]=$v1*$m;
    return <<$v2[0][0], $v2[0][1],  $v2[0][2]>>;
    }
    proc vector matrixSpaceVecMult(vector $v, matrix $m){
    matrix $v1[1][4]=<<$v.x, $v.y, $v.z, 1>>;
    matrix $v2[1][4]=$v1*$m;
    return <<$v2[0][0], $v2[0][1],  $v2[0][2]>>;
    }
    proc matrix GetworldMatrix(string $object){
    $attr = $object +".worldMatrix";
    $v = `getAttr $attr`;
    matrix $mat[4][4]= `FloatToMatrix($v)`;
    return $mat;
    }
    proc matrix GetworldInverseMatrix(string $object){
    $attr = $object +".worldInverseMatrix";
    $v = `getAttr $attr`;
    matrix $mat[4][4]= `FloatToMatrix($v)`;
    return $mat;
    }
    proc matrix GetInverseMatrix(string $object){
    $attr = $object +".inverseMatrix";
    $v = `getAttr $attr`;
    matrix $mat[4][4]= `FloatToMatrix($v)`;
    return $mat;
    }
    proc matrix GetMatrix(string $object){
    $attr = $object +".matrix";
    $v = `getAttr $attr`;
    matrix $mat[4][4]= `FloatToMatrix($v)`;
    return $mat;
    }

    // matrix // float $MatrixSUrfaceB[]  matrix $SbMatrix[4][4];  $SbMatrix= GetMatrix("LiveSurfaceB");  float $MatrixSUrfaceB[] = MatrixToFloat($SbMatrix);

    //<description>
    //  	This script returns the multiplication of a point and a
    //		matrix as an array of 3 doubles:
    //<pre>
    //      vector * matrix = result

    //		<b>Note:</b> The matrix is assumed to be a single dimension
    //		array of 16 elements.
    //<BR>
    //		<b>Remember:</b> That the arrays are 0-based.
    //		e.g. [1][0] is matrix[4] element
    //<flags>
    //		float $point[]	Co-ordinates of the point.
    //		float $matrix[]	The matrix to be used.
    //<returns>
    //		float[] : Result as an array of 3 doubles.
    //
    //<examples>
    //	float $p[] = {1,2,3};
    //	float $m[] = {1,0,0,0,0,2,0,0,0,0,3,0,0,0,0,0};
    //	pointMatrixMult($p, $m);
    //	// Results: 1 4 9 //

    proc float[] pointMatrixMult( float $point[], float $matrix[] ){
    $result[0] = 0.0;
    $result[1] = 0.0;
    $result[2] = 0.0;
    if ( size($point) != 3 || size($matrix) != 16 )
    {
    warning (uiRes("m_pointMatrixMult.kPointArray"));
    return $result;
    }
    // create the node that will do the actual computation
    //
    if ( catch($multNode = `createNode pointMatrixMult`) )
    {
    warning (uiRes("m_pointMatrixMult.kCouldNotCreateNode"));
    return $result;
    }
    // set the matrix and point inputs to the node
    //
    setAttr ($multNode+".vectorMultiply") true;
    setAttr ($multNode+".inPoint") -type "double3" $point[0] $point[1] $point[2];
    setAttr ($multNode+".inMatrix") -type "matrix" $matrix[0] $matrix[1] $matrix[2] $matrix[3] $matrix[4] $matrix[5] $matrix[6] $matrix[7] $matrix[8] $matrix[9] $matrix[10] $matrix[11] $matrix[12] $matrix[13] $matrix[14] $matrix[15];
    // get the result and delete the node since it is no longer required
    //
    $result = `getAttr ($multNode+".output")`;
    delete $multNode;
    return $result;
    }

    proc  PrintMatrix(matrix $MatriXM[][] , int $MatrixN){

    $MatrixNi = $MatrixN-1;
    $FLoatMatrixA = MatrixToFloat($MatriXM);
    $FLoatMatrixA = MakeCleanFloatsZ($FLoatMatrixA);
    $stringFloat = FloatArrayToStringArray($FLoatMatrixA);
    clear $BytNum;
    for ($eachFloatz in $stringFloat){
    $BytNum[`size($BytNum)`] = (`sizeBytes $eachFloatz`)+2;
    }
    $BytNumSort = $BytNum;
    $BytNumSort = `sort $BytNumSort`;
    $BytNumLarg = $BytNumSort[`size($BytNumSort)`-1];
    $BytNumSmall = $BytNumSort[0];
    clear $BytNumDiff;
    for ($eachBytNum in $BytNum){
    $BytNumDiff[`size($BytNumDiff)`] = (`abs ($eachBytNum - $BytNumLarg)`)+2;
    }

    $IndXeF = 0;
    $IndXeFi = 0;
    $Syb = " ";
    $printcommand = "";
    for ($eachItemF in $stringFloat){
    $AddedSPaces = AddItemString($BytNumDiff[$IndXeF], $Syb);
    if($IndXeFi==$MatrixNi){ $printcommand += $AddedSPaces + $eachItemF + "|"+ "\n" ;
    $IndXeFi= -1; }else{ if($IndXeFi==0){$printcommand += "|"+$AddedSPaces + $eachItemF;}else{ $printcommand += $AddedSPaces + $eachItemF;}}
    $IndXeFi++;
    $IndXeF++;
    }
    print $printcommand;
    }


    proc string AddItemString(int $iN, string $NumLetorSy){
    $Xz = 0;
    $AddItem = "";
    while($iN > $Xz){
    $AddItem+= $NumLetorSy;
    $Xz++;
    }
    return $AddItem;
    }


    proc matrix MatrixMirrorX(matrix $m[][]){
    $MatrixA = `MatrixToFloat($m)`;
    matrix $m2[4][4]=<<1.0, 0.0, -1.0, 0.0;
    -1.0, 1.0, 1.0, 0.0;
    -1.0, 1.0, 1.0, 0.0;
    -1.0, 1.0, 1.0, 1.0>>;
    $MatrixB = `MatrixToFloat($m2)`;
    $iX = 0;
    for ($eachFloat in $MatrixA){
    if(!($MatrixB[$iX]==0)){
    $DividedFLoats[`size($DividedFLoats)`] = $eachFloat * $MatrixB[$iX];
    }else{$DividedFLoats[`size($DividedFLoats)`] = $eachFloat;}
    $iX++;
    }
    matrix $MatrixDiv[4][4]= FloatToMatrix($DividedFLoats);
    return $MatrixDiv;
    }

    proc float [] MultMatrixMirrorX(float $point[]){

    matrix $m2[4][4]=<<1.0, 0.0, -1.0, 0.0;
    -1.0, 1.0, 1.0, 0.0;
    -1.0, 1.0, 1.0, 0.0;
    -1.0, 1.0, 1.0, 1.0>>;
    $MatrixB = `MatrixToFloat($m2)`;
    $FLoatPointA = pointMatrixMult( $point, $MatrixB );
    return $FLoatPointA;
    }

    proc matrix MatrixTimesFloat(matrix $m[][], float $X){
    $MatrixA = `MatrixToFloat($m)`;

    $iX = 0;
    for ($eachFloat in $MatrixA){
    $DividedFLoats[`size($DividedFLoats)`] = $eachFloat * $X;

    $iX++;
    }
    matrix $MatrixDiv[4][4]= FloatToMatrix($DividedFLoats);
    return $MatrixDiv;
    }

    proc matrix MatrixDivide(matrix $m[][], matrix $m2[][]){
    $MatrixA = `MatrixToFloat($m)`;
    $MatrixB = `MatrixToFloat($m2)`;
    $iX = 0;
    for ($eachFloat in $MatrixA){
    if(!($MatrixB[$iX]==0)){
    $DividedFLoats[`size($DividedFLoats)`] = $eachFloat/ $MatrixB[$iX];
    }else{$DividedFLoats[`size($DividedFLoats)`] = $eachFloat;}
    $iX++;
    }
    matrix $MatrixDiv[4][4]= FloatToMatrix($DividedFLoats);
    return $MatrixDiv;
    }

    proc matrix MatrixCleanNegZero(matrix $m[][]){
    $MatrixA = `MatrixToFloat($m)`;

    $iX = 0;
    for ($eachFloat in $MatrixA){
    if(($eachFloat == 0)||($eachFloat == -0)){
    $CleanFLoats[`size($CleanFLoats)`] = 0.0;
    }else{$CleanFLoats[`size($CleanFLoats)`] = $eachFloat;}
    $iX++;
    }
    $CleanFLoats = MakeCleanFloatsZ($CleanFLoats);
    matrix $MatrixClean[4][4]= FloatToMatrix($CleanFLoats);
    return $MatrixClean;
    }

    proc TransformRelByMatrixXform(matrix $m[][], string $item){
    $itemD = `duplicate -rr $item`;
    $VecLi = PointArrayT($itemD);
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    (0) (0) (0) (1) $itemD[0];
    $NewVeci = VecMultMatrix($VecLi[0], $m);
    xform -ws -t ($NewVeci.x) ($NewVeci.y) ($NewVeci.z) $itemD[0];
    }

    proc TransformRelByMatrixXformM(matrix $m[][], string $itemA[]){
    $VecLi = PointArrayT($itemA);
    $count = 0;
    for($item in $itemA){
    $itemD  = `duplicate -rr $item`;
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    (0) (0) (0) (1) $itemD[0];
    $NewVeci = VecMultMatrix($NewVeci, $m);
    xform -ws -t ($NewVeci.x) ($NewVeci.y) ($NewVeci.z) $itemD[0];
    $count++;
    }
    }

    proc TransformItemByMatrixXform(matrix $m[][], string $item){
    $itemD = `duplicate -rr $item`;
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $itemD[0];
    }
    proc TransformItemByMatrixXformObjSpace(matrix $m[][], string $item){
    $itemD = `duplicate -rr $item`;
    xform -os -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $itemD[0];
    }


    //////////////////






    //LOCcurve268END
    //LOCcurve208END



    //////////////////
    /// StereoCurveZ($StereoCurveZ[0], $StereoCurveZ[1]);
    //modifySelectedCurves smooth 18 0;
    /////////////////////////////////////////////////////////////////////


    /*

    //////////////////////////////////////////////////////////////////////
    proc string AverageANdCLoseSketchFittingCircle(string $curveItemC){
    ///////////////////////////////
    $CurveItemZai[0] = $curveItemC;
    $Arc = `arclen $CurveItemZai[0]`;
    $Arc = $Arc /3.5;
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s $Arc -d 3 -tol 0.05 $CurveItemZai[0];
    $curvesZi = $CurveItemZai[0];
    $CurveCollectVec = CurvatureUtilityAngles($curvesZi, 130, $angleZi, $TotalDegi,$Low_X, $TrackC);
    clear $NewIndex;
    $NewIndex  = SortNumbersIntIndex($angleZi);
    $nevVec = NewVecOrderWithINTKey($NewIndex,$CurveCollectVec);
    $vectorZnewX =$nevVec;
    $Xv = 0;
    while($Xv < 22){
    $vectorZnewX = AverageCurveVec($vectorZnewX);
    $Xv++;
    }
    $TestCurveC = VecArrayToCurveB($vectorZnewX);
    ResetTransEachSL;
    // Error: line 70: No object matches name: layer1 //
    createDisplayLayer -name "layer1" -number 1 -empty;
    // Problem with return values above N kinds.. maya errors
    ////////////////////////////////////////////////



    $OneCurve = `ls -sl`;
    $OneCurveS = $OneCurve[0];
    $TFNS = 1;
    $CurveNS = IScircleTF($OneCurveS,$TFNS);
    print $TFNS;


    if($TFNS==1){
    $NewOneCurveS = EllipesSketchFitting($CurveNS, $EmptyVectorArrayA);
    }else{  $NewOneCurveS = $OneCurveS;}

    print $EmptyVectorArrayA;

    select -r $NewOneCurveS;


    $Ellipes_A = `xform -q -ws -t $NewOneCurveS`;



    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);

    Loc $MidEpipolPosFCam;


    for($EachVec in $EmptyVectorArrayA){

    //if line betweens average centor  is not the line between N vec point from curve find its angle becuase if the vector point on curve
    // if it happens to be exactly on the line i would be tring to find the angle  of three point of a line which is zero........

    $AngleX[`size($AngleX)`] = AngleofTwoLines($EachVec,$MidEpipolPosFCam,$Ellipes_A ,$MidEpipolPosFCam);


    }

    clear $NewIndex;
    $NewIndex  = SortNumbersIntIndex($AngleX);

    Loc  $EmptyVectorArrayA[$NewIndex[0]];
    Loc  $EmptyVectorArrayA[$NewIndex[1]];

    $IndexTrack = $NewIndex;
    $IndexTrack = ReverseIntArray($IndexTrack);
    Loc  $EmptyVectorArrayA[$IndexTrack[0]];
    Loc  $EmptyVectorArrayA[$IndexTrack[1]];

    print $IndexTrack[0]
    161;

    print $AngleX;




    */



    // need for some reason
    createDisplayLayer -name "layer1" -number 1 -empty;

    proc float AngleofTwoLines(vector $vecA,vector $vecB,vector $vecC,vector $vecD){
    $AngleB = EulerAngB((DirectionFN($vecA, $vecB)), (DirectionFN($vecC, $vecD)));
    $angleA = $AngleB[3];
    return $angleA;
    }





    proc CurvesToPlane(string $CurveItemZ[]){
    global string $PlaneCurveS[];
    $PCurvesName = "Plane";
    $CountN = 0;
    for ($eachCurve in $CurveItemZ){
    clear $AllLocPositionsZ;
    $AllLocPositionsZ = VecCurveEps( $eachCurve );
    $AllPlaneLocPositionZ = VecPointsToCameraPlane($AllLocPositionsZ);
    $newPlaneCurve = VecArrayToCurve($AllPlaneLocPositionZ);
    //$Combine = ($PCurvesName+$eachCurve);
    //$newPlaneCurve = `rename $newPlaneCurve  $Combine`;
    ResetTranslation({$newPlaneCurve});
    $PlaneCurvA[$CountN]= $newPlaneCurve;
    $CountN++;
    }
    $PlaneCurveS = $PlaneCurvA;

    }

    /*
    global string $PlaneCurveS[];

    $LayerCurvesRangeA = `queryLayerRangeMembers`;
    CurvesToPlane($LayerCurvesRangeA);
    select -r $PlaneCurveS;

    //setAttr "locator1.scaleX" 0.085;
    */

    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;



    proc StereoCurveZ(string $CurveItemZai, string $CurveItemZbi){

    /*
    temp debug

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemZai );

    $AverageVecCurve = AverageVectorPoint($PositionsZ_A);
    Loc $AverageVecCurve;
    $CamDirVecNormalA = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);



    $TrueorFalseCircle = `IsCircle`;
    if ($TrueorFalseCircle == 1){
    $newCircle = `MakeCIRCLE($StereoCurveZ)`;
    }
    //////////////////////////////////////////////////////////////

    $StereoCurveZ= `ls -sl`;
    $CurveItemZai = $StereoCurveZ[0];
    $CurveItemZbi = $StereoCurveZ[1];

    global string $PlaneCurveS[];

    $LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;

    CurvesToPlane($LayerCurvesRangeA);
    select -r $PlaneCurveS;

    clear $AllLocPositionsZi;
    $AllLocPositionsZi = VecCurveEps( $eachCurve );



    */


    global string $StereoCurveZ[];
    global string $VanishingPointsLinesTempGuides[];
    global int $addNumbersA;
    global float $VanishingPointGlobal[];

    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;


    $VecCurEndsa = VecCurveEnds({$CurveItemZai});
    $VecCurEndsb = VecCurveEnds({$CurveItemZbi});

    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 1 -tol 0.05 $CurveItemZai;
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 1 -tol 0.05 $CurveItemZbi;
    //gathering all Curve Points

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemZai );
    clear $PositionsZ_B;
    $PositionsZ_B = VecCurveEps($CurveItemZbi );

    // mirroring across ZY plane or X axis
    clear $VecPtsMirrorA;
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    clear $VecPtsMirrorB;
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
    $CamDirVecNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $MultDirCam = multiplyFloat(-1, $CamDirVecNormal);
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;

    clear $VecPtsMirrorEnds_A;
    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    clear $VecPtsMirrorEnds_B;
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);

    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);

    //Key Element
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);

    // Loc $MidEpipolPosFCam;
    // Loc $CamPos_A;

    $EpipolPosCamM = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;
    //float $MidPosFCam[]= FloatPointsToCamPlane($centerCam);
    $MidPosFCam = $CamPlane1;

    $FloatDirEpipol = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    $FloatDirEpipolB = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);

    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    //Loc $PlaneEpipolXx;
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    //Loc $PlaneEpipolYx;
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);
    //Loc $PlaneEpipolZx;

    // The end Points of the first curve Drawn to the Epipol of CAMERA one //##
    $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
    $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);

    // Loc $PointN_Epi;
    // Loc $PointN_EpiB;
    //Loc $VecCurEndsb[0];


    //below I use a if statement to weigh if the two curves start and end points are corrosponding to its mirror symetry
    $DistTOEpipol_CurEndA = distance2Pts($PointN_Epi, $VecCurEndsb[0]);
    $DistTOEpipol_CurEndB = distance2Pts($PointN_EpiB, $VecCurEndsb[0]);

    // if( $DistTOEpipol_CurEndA > $DistTOEpipol_CurEndB){ //

    //curve2points ($PointN_Epi, $VecCurEndsb[0]);
    //curve2points ($PointN_EpiB, $VecCurEndsb[0]);

    $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
    $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
    $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;


    $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
    // $BCurEndBNN -= $BCurEndBiiAdd ;
    $BCDiff = abs($BCurEndB - $BCurEndBNN);


    $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd ;
    $BCDiffi = abs($BCurEndB - $BCurEndBNNi);
    //int $IntIfNearZero = equivalentTol($BCurEndB, $BCurEndBNNi,  0.0001);
    $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);

    //Loc $PointN_Epi;
    //Loc $PointN_EpiB;

    $FloatDirEndPtsA = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
    $EulerAngleA = EulerAngB($FloatDirEndPtsA, $FloatDirEpipol);
    $EulerAngle_A = $EulerAngleA[3];
    $FloatDirEndPtsB = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
    $EulerAngleB = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);
    $EulerAngle_B = $EulerAngleB[3];

    $FloatDirEndPtsAi = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
    $EulerAngleAi = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);
    $EulerAngle_Ai = $EulerAngleAi[3];
    $FloatDirEndPtsBi = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
    $EulerAngleBi = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);
    $EulerAngle_Bi = $EulerAngleBi[3];

    print ($EulerAngle_A+"\n");
    print ($EulerAngle_B+"\n");
    print ($EulerAngle_Ai+"\n");
    print ($EulerAngle_Bi+"\n");

    $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
    $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;


    $Vecbv  = $VecCurEndsa;
    $Vecbvi = $VecCurEndsb;
    $IfTrue = FindLineCross( $Vecbv , $Vecbvi );
    $weighedtFindings = 0;
    $weighedtFindingsZ = 0;
    $weighedtFindingsN = 0;


    if($IfTrue==0){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;
    }



    if($IntIfNearZero==1){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}


    if($EulerAngle_AB<$EulerAngle_AiBi){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}

    print ($weighedtFindings+"\n");
    print ($weighedtFindingsZ+"\n");
    print ($weighedtFindingsN+"\n");

    ////////////////PLace find otrtho Curve here


    $LengCRV_a = `arclen $CurveItemZai`;

    $CRV_ENDSi = $VecCurEndsa;
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $PerDiff = percent_of( $LengCRV_a, $DistEndsi);

    $LengCRV_b = `arclen $CurveItemZbi`;
    $CRV_ENDSii = $VecCurEndsb;
    $DistEndsii = distance2Pts($CRV_ENDSii[0], $CRV_ENDSii[1]);
    $PerDiffii = percent_of( $LengCRV_b, $DistEndsii);

    $PerDiffSum = ($PerDiff+$PerDiffii)/2.0;
    $triggerStraitCRV = 0;

    //START of StraitCurve//

    if( $PerDiffSum<5.5){

    $triggerStraitCRV=1;


    $DDirEpipol = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
    $MidCurveA = MidPoint($VecCurEndsa[0], $VecCurEndsa[1]);
    $MidCurveB = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);

    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);


    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);

    //PositiveDirectionLine
    //    Loc $MidEpipolPosFCam;
    //$VecCurEndsa


    $EpipolD = $DDirEpipolXYZ;

    $Trueii = 0;
    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    //print $IsOrthoLineTrue;
    //print $AxisOrthoLine;
    //print $LineMidi;
    //print $NewDirZi;
    //found Direction

    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];


    if($IsOrthoLineTrue==1){


    $NewVecENDsi  = makeCurvePointDirectionLengthN($DistEndsi, $NewDirZi, $MidCurveA);
    //delete;

    $VecCurEndsa[0] = $NewVecENDsi[0];
    $VecCurEndsa[1] = $NewVecENDsi[1];

    if($AxisOrthoLine!=0){

    $FloatDirEpipol = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    $FloatDirEpipolB= DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
    //float $DistEndsii = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    $MidCurveB = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);

    $DDirEpipolB = DirectionFN($MidCurveB, $FoundEpipol);
    $DDirEpipolA = DirectionFN($FoundEpipol,$MidCurveB);


    $Intersect_LineB_a = FloatToVec (lineIntersection($MidCurveB, $DDirEpipolB, $VecCurEndsa[0],$FloatDirEpipol));
    $Intersect_LineB_b = FloatToVec (lineIntersection($MidCurveB, $DDirEpipolA, $VecCurEndsa[1],$FloatDirEpipolB));
    //Loc $Intersect_LineB_a;
    //Loc $Intersect_LineB_b;

    $VecCurEndsb[0] = $Intersect_LineB_a;
    $VecCurEndsb[1] = $Intersect_LineB_b;

    clear $PositionsZ_A;
    clear $PositionsZ_B;
    clear $VecPtsMirrorEnds_A;
    clear $VecPtsMirrorEnds_B;
    clear $VecPtsMirrorA;
    clear $VecPtsMirrorB;

    $PositionsZ_A[0] =  $NewVecENDsi[0];
    $PositionsZ_A[1]= FloatToVec (MidPoint($NewVecENDsi[0],$NewVecENDsi[1]));
    $PositionsZ_A[2] =  $NewVecENDsi[1];

    $PositionsZ_B[0] =  $Intersect_LineB_a;
    $PositionsZ_B[1]= FloatToVec (MidPoint($Intersect_LineB_a, $Intersect_LineB_b));
    $PositionsZ_B[2] =  $Intersect_LineB_b;

    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);

    }



    }
    }

    if($weighedtFindingsZ<$weighedtFindingsN){

    cycleBackgroundColor;
    //reverseCurve  -ch 0 -rpo 1 -cos on $CurveItemZai;
    //$VecCurEndsa = ReverseVectorArray($VecCurEndsa);
    $PositionsZ_B = ReverseVectorArray($PositionsZ_B);
    // $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
    $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);

    }




    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;

    clear $IntersectEnds_A;
    $iia = 0;
    clear $Intersect_A;
    clear $Intersect_ATwo;
    clear $IntersectForce_A;
    clear $IntersectAverage_A;



    if(`size( $queryLocCurveEnds3D)`>3){

    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);

    for ($eachVecx in  $VecCurEndsa)
    {

    $IntersectEnds_A[$iia] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsa[$iia], $CamPos_M, $VecPtsMirrorEnds_B[$iia]));
    $iia++;
    }

    ///////// find nearest for both curve ends on one curve with those two points they become four points mirrored X

    $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[0]);
    $AllLocsi = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    $AllLocs_String = IntArrayToStringArray($AllLocsi);
    $newOrdersZA = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    $EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
    $New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
    $Near_index_A = $New_AllLocs_A[0];
    $Distance_A = $distToCurveE_A[$Near_index_A];
    $Found_pt_A = $LocCurveEndsVec3D[$Near_index_A];
    $newOrdersZAM = $Found_pt_A;
    $newOrdersZAM[0] = $Found_pt_A[0] *-1;

    $distToCurveE_B = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[1]);
    $newOrdersZB = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    $EmptyStringNewOrderB = ReverseStringArray($EmptyStringNewOrderB);
    $New_AllLocs_B = ArrayToIntList($EmptyStringNewOrderB);
    $Near_index_B = $New_AllLocs_B[0];
    $Distance_B = $distToCurveE_B[$Near_index_B];
    $Found_pt_B = $LocCurveEndsVec3D[$Near_index_B];
    $newOrdersZBM = $Found_pt_B;
    $newOrdersZBM[0] = $Found_pt_B[0] *-1;

    $PointsA[0] = FloatToVec($Found_pt_A);
    $PointsA[1] = FloatToVec($Found_pt_B);
    $PointsB[0] = FloatToVec($newOrdersZAM); // negative mirror of first endpoint of first curve
    $PointsB[1] = FloatToVec($newOrdersZBM);
    // vec points to plane
    //them matrix transformation
    //  know that the camera may be in the positive or negative x axis ... try to make it so that
    //  it will not matter what order  the curve is drawn for the first curve might represent the positive axis or
    // the negitive where is the camera is what you know first  .. what you know second is what the first curve represents
    //Loc $PointsA[0];


    $VecOnPlaneA = VecPointsToCameraPlane($PointsA);
    $VecOnPlaneB = VecPointsToCameraPlane($PointsB);

    //print $Distance_A;
    //print $Distance_B;

    $triggerNoTrans = 0;

    $NewFoundLocs[0] = $queryLocCurveEnds3D[$Near_index_A];
    $NewFoundLocs[1] = $queryLocCurveEnds3D[$Near_index_B];
    $arrayCurvesNear[0] = ("Plane"+$NewFoundLocs[0]);
    $arrayCurvesNear[1] = ("Plane"+$NewFoundLocs[1]);
    $NewFoundLocs = $arrayCurvesNear;

    $LocOnPlaneVec = PointArray($NewFoundLocs);
    $distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocOnPlaneVec[0]);
    $distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocOnPlaneVec[1]);
    print $distToPlaneLoc;



    //if($distToPlaneLoc[0]<0.0025){

    if(!($Distance_A<2.0005)){
    //if((!($Distance_B<1.0005))&&(!($distToPlaneLoc[1]<0.00195))){
    $VecOnPlaneA[0] = $VecCurEndsa[0];
    $VecOnPlaneB[0] = $VecCurEndsb[0];
    PAUSE;
    $triggerNoTrans++;
    }

    //}

    //if($distToPlaneLoc[1]<0.0025){

    if(!($Distance_B<2.0005)){
    //if((!($Distance_B<1.0005))&&(!($distToPlaneLoc[1]<0.00195))){
    $VecOnPlaneA[1] = $VecCurEndsa[1];
    $VecOnPlaneB[1] = $VecCurEndsb[1];
    PAUSE;
    $triggerNoTrans++;
    }

    //}


    if($triggerNoTrans!=2){

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemZai );



    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEndsa,$VecOnPlaneA, $PositionsZ_A);



    $PositionsZ_Bi = Matrix_Curve_TranslationCC($VecCurEndsb, $VecOnPlaneB, $PositionsZ_B);




    clear $VecPtsMirrorA;
    $VecPtsMirrorA= VecPtsToZMirrorPts( $PositionsZ_Ai);
    clear $VecPtsMirrorB;
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_Bi);
    $PositionsZ_A = $PositionsZ_Ai;
    $PositionsZ_B = $PositionsZ_Bi;
    cycleBackgroundColor;
    }

    }


    //////////////////////////////////////////////////////////////////////////////////////
    //Closest Point to Line !! is you want to make it more true to the curve drawn.
    //cool!
    ///////////////      ///////////////
    ///////////////      ///////////////

    //$IntersectEnds_A[$iia] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsa[$iia], $CamPos_M, $VecPtsMirrorEnds_B[$iia]));
    //ADDED
    //$PointToCamDir = DirectionFN($CamPos_A, $VecCurEndsa[$iia]);

    //$IntersectForce_A[$iia] = FloatToVec (ClosestPoint2Line($PointToCamDir, $CamPos_A,  $IntersectEnds_A[$iia]));
    //$Intersect_ATwo[0] = $IntersectEnds_A[$iia];
    //$Intersect_ATwo[1] = $IntersectForce_A[$iia];
    //$IntersectAverage_A[$iia] =  FloatToVec(AverageVectorPoint($Intersect_ATwo));
    ///
    //$iia++;


    $iiz = 0;
    clear $IntersectEnds_A;
    $iia = 0;
    clear $Intersect_A;
    clear $Intersect_ATwo;
    clear $IntersectForce_A;
    clear $IntersectAverage_A;


    $colori[`size($colori)`] = 13;
    $colori[`size($colori)`] = 14;


    for ($eachVecx in  $VecPtsMirrorA)
    {
    $Intersect_A[`size($Intersect_A)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_B[$iiz], $CamPos_M, $VecPtsMirrorA[$iiz]));
    //DEMO
    if((fmod($iiz, 12))== 2){
    curve2points($PositionsZ_B[$iiz], $Intersect_A[`size($Intersect_A)`-1]);
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[0]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    curve2points($VecPtsMirrorA[$iiz], $Intersect_A[`size($Intersect_A)`-1]);
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[1]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    }

    $iiz++;
    }


    delete $AllCirTemp;

    $ThefirstCurve = VecArrayToCurve($Intersect_A);
    //string $ThefirstCurve = VecArrayToCurve($IntersectAverage_A);
    modifySelectedCurves smooth 18 0;
    //  string $NewCurveA[] = SmoothCurvature3(6);
    //rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 28 -d 1 -tol 0.05 $ThefirstCurve;
    ///////////////
    /*
    $iiz = 0;
    clear $Intersect_B;
    /////
    ////////
    for ($eachVecxi in  $VecPtsMirrorA)
    {
    $Intersect_B[`size($Intersect_B)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_A[$iiz], $CamPos_M,   $VecPtsMirrorB[$iiz]));
    $iiz++;
    }
    */
    clear $Intersect_B;
    $Intersect_B= VecPtsToZMirrorPts($Intersect_A);
    $ThefirstCurvei = VecArrayToCurve($Intersect_B);
    modifySelectedCurves smooth 18 0;
    // string $NewCurveB[] = SmoothCurvature3(6);
    //rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 28 -d 1 -tol 0.05 $ThefirstCurvei;
    ///////////////      ///////////////
    ///////////////      ///////////////
    //offsetCurve  -ch on -rn false -cb 2 -st true -cl true -cr 0 -d 1 -tol 0.01 -sd 5 -ugn false  $ThefirstCurve ;
    //offsetCurve  -ch on -rn false -cb 2 -st true -cl true -cr 0 -d 1 -tol 0.01 -sd 5 -ugn false  $ThefirstCurvei ;

    delete $VanishingPointsLinesTempGuides;
    clear $VanishingPointsLinesTempGuides;
    delete $CurveItemZai $CurveItemZbi;
    clear $StereoCurveZ;
    $addNumbersA =0;
    clear $VanishingPointGlobal;
    ResetTranslation({$ThefirstCurve});
    CurveIndexVecTracking({$ThefirstCurve});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1
    $ThefirstCurve;
    ResetTranslation({$ThefirstCurvei});
    CurveIndexVecTracking({$ThefirstCurvei});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1
    $ThefirstCurvei;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    }

    //getAttr "ZCURVEModelingCAMShape.centerOfInterest" 559.102043;
    //-worldCenterOfInterest

    //getAttr "ZCURVEModelingCAMShape.worldCenterOfInterest"
    //camera -q -worldCenterOfInterest "ZCURVEModelingCAMShape"
    //////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    /*
    temp debug

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemZai );

    $AverageVecCurve = AverageVectorPoint($PositionsZ_A);
    Loc $AverageVecCurve;
    $CamDirVecNormalA = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);



    $TrueorFalseCircle = `IsCircle`;
    if ($TrueorFalseCircle == 1){
    $newCircle = `MakeCIRCLE($StereoCurveZ)`;
    }
    //////////////////////////////////////////////////////////////

    proc string CreateCrvInter( string $crv1, string $crv2,
    {
    // Create the intersect node
    $intersectNode = `createNode curveIntersect`;
    setAttr ($intersectNode + ".tolerance") $tolerance;
    connectAttr ($crv1 + ".worldSpace") ($intersectNode + ".inputCurve1");
    connectAttr ($crv2 + ".worldSpace") ($intersectNode + ".inputCurve2");
    setAttr ($intersectNode + ".useDirection") $useDir;
    // Check if there are any intersections.  If not, then delete
    // the node and return nothing.
    //
    $intersections1 = `getAttr ($intersectNode + ".parameter1")`;
    $numIparms = size($intersections1);
    if( $numIparms == 0 ) {
    delete $intersectNode;
    $intersectNode = "";
    } else {
    $intersections2 = `getAttr ($intersectNode + ".parameter2")`;
    }
    // remenber to
    delete $intersectNode;
    return $intersectNode;
    }


    proc int [] CreateCrvInterTF( string $crv1, string $Allcrv2[],
    {

    $TF = 0;
    // Create the intersect node
    for($eachCurve in $Allcrv2){
    $intersectNode = `createNode curveIntersect`;
    setAttr ($intersectNode + ".tolerance") $tolerance;
    connectAttr ($crv1 + ".worldSpace") ($intersectNode + ".inputCurve1");
    connectAttr ($eachCurve + ".worldSpace") ($intersectNode + ".inputCurve2");
    setAttr ($intersectNode + ".useDirection") $useDir;
    // Check if there are any intersections.  If not, then delete
    // the node and return nothing.
    $intersectionsA = `getAttr ($intersectNode + ".parameter1")`;
    $numIparms = size($intersectionsA);
    if( $numIparms == 0 ) {
    $TF=0;
    } else {
    $TF=1;
    $intersections1A = `getAttr ($intersectNode + ".parameter1")`;
    $intersections1B = `getAttr ($intersectNode + ".parameter2")`;
    AppendFloatArray($intersections1,$intersections1A);
    AppendFloatArray($intersections1,$intersections1B);
    print $eachCurve;
    }
    $CurveIndexInter[`size($CurveIndexInter)`] = $TF;
    delete $intersectNode;
    }
    // remenber to

    return $CurveIndexInter;
    }




    $StereoCurveZ= `ls -sl`;
    $CurveItemZai = $StereoCurveZ[0];
    $CurveItemZbi = $StereoCurveZ[1];

    // $VanishingPointsLinesTempGuides = VanishingCurves({$StereoCurveZ[0]});


    global string $PlaneCurveS[];
    $LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;
    CurvesToPlane($LayerCurvesRangeA);
    select -r $PlaneCurveS;

    $NodeCurveIndex = CreateCrvInterTF($CurveItemZai, $PlaneCurveS,0,0.001,$interVecA, $interVecB);
    print $NodeCurveIndex;



    print $TwoCurveA;
    $intersectCURVEiA = `listRelatives -children  $TwoCurveA[0]`;
    $intersectCURVEiB = `listRelatives -children  $TwoCurveA[1]`;

    ///
    $curveIntersectZ = "";
    $curveIntersectZ = `curveIntersect -ch 0 -tolerance 0.00001 $CurveItemZai $CurveItemZbi`;
    $curveIntersectZ = `curveIntersect -ch 0 -tolerance 0.00001 $TwoCurveA[0] $TwoCurveA[1]`;
    $numTokens = `tokenize $curveIntersectZ " "  $buffer`;
    print $buffer;
    $param = eval("paramLocator "+ $TwoCurveA[1] + ".u[" + $buffer[7] + "]");
    $intersectposA = `pointPosition -w  $param`;
    Loc $intersectposA;


    ///

    $paramANDCurve  = `paramToCurvePts2({$param})`;
    delete $param;
    $curvesZ = `detachCurve -ch 1 -cos on -rpo 1  $paramANDCurve`;

    print $NodeCurveA;
    print $NodeCurveA;

    proc float[] NewFloatOrderWithIndexKey(int $IndexTrack[], float $NewFloat[]){
    for($eachV in $IndexTrack){
    $newOrderVec[`size($newOrderVec)`] = $NewFloat[$eachV];
    }
    return $newOrderVec;
    }


    select -r Planecurve12 ;
    select -r curve69 ;

    $intersectNode = `createNode curveIntersect`;
    setAttr ($intersectNode + ".tolerance") 0.001;
    connectAttr ("curve69" + ".worldSpace") ($intersectNode + ".inputCurve1");
    connectAttr ("Planecurve12" + ".worldSpace") ($intersectNode + ".inputCurve2");
    setAttr ($intersectNode + ".useDirection") 0;
    $intersectionsA = `getAttr ($intersectNode + ".parameter2")`;
    $param = eval("paramLocator "+"Planecurve12"+".u["+$intersectionsA[0]+"]");

    */

    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////

    proc int [] CreateCrvInterTF( string $crv1, string $Allcrv2[],
    {

    $TF = 0;
    // Create the intersect node

    $COuntN = 0;
    for($eachCurve in $Allcrv2){
    $intersectNode = `createNode curveIntersect`;
    //listAttr $intersectNode;
    setAttr ($intersectNode + ".tolerance") $tolerance;
    connectAttr ($crv1 + ".worldSpace") ($intersectNode + ".inputCurve1");
    connectAttr ($eachCurve + ".worldSpace") ($intersectNode + ".inputCurve2");
    setAttr ($intersectNode + ".useDirection") $useDir;
    $intersectionsA = `getAttr ($intersectNode + ".parameter1")`;
    $numIparms = size($intersectionsA);
    if( $numIparms == 0 ) {
    $TF=0;
    } else {
    $TF=1;
    $intersections1A = `getAttr ($intersectNode + ".parameter2")`;
    print $intersections1A;
    $FloatSTRING = FloatArrayToStringArray($intersections1A);
    $Ax = stringArrayToString($FloatSTRING, " ");
    /*
    $intersections1A = `getAttr ($intersectNode + ".parameter2")`;
    print $intersections1A;
    $FloatSTRING = FloatArrayToStringArray($intersections1A);
    $Axi = stringArrayToString($FloatSTRING, " ");
    $Ax += (" "+$Axi);
    */
    $intersections1[`size($intersections1)`] = $Ax;
    //AppendFloatArray($intersections1,$intersections1A);
    //print $eachCurve;
    $CurveIndexInter[`size($CurveIndexInter)`] = $COuntN;
    }

    delete $intersectNode;
    $COuntN++;
    }
    // remenber to

    return $CurveIndexInter;
    }

    proc int [] FindEqualVec(vector $VectorA[], vector $Vec){
    $CountN = 0;
    for($eachMvec in $VectorA){
    $CombA = PointsEquivalentTol ($eachMvec, $Vec);
    if($CombA ==3){
    $foundN[`size($foundN)`]= $CountN;
    }
    $CountN++;

    }

    return $foundN;
    }

    proc AppendIntArray(int $ExistingInt[],int $AddtoExistingInt[]){
    for($eachInt in $AddtoExistingInt){
    $ExistingInt[`size($ExistingInt)`]= $eachInt;
    }

    }

    proc AppendFloatArray(float $ExistingF[],float $AddtoExistingF[]){
    for($eachFloat in $AddtoExistingF){
    $ExistingF[`size($ExistingF)`]= $eachFloat;
    }

    }

    proc float [] DistanceSortStereoCrv(float $distToCurveE_A[], vector $LocCurveEndsVec3D[], vector $IntersectEnds_Ai, int $New_AllLocs_AI[] , float $Distance_A){
    $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ai);
    $AllLocsi = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    $AllLocs_String = IntArrayToStringArray($AllLocsi);
    $newOrdersZA = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    $EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
    $New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
    $Near_index_A = $New_AllLocs_A[0];
    $Distance_A = $distToCurveE_A[$Near_index_A];
    $Found_pt_A = $LocCurveEndsVec3D[$Near_index_A];
    $New_AllLocs_AI = $New_AllLocs_A;
    return $Found_pt_A;
    }

    // clear $StereoCurveZ;

    global string $PlaneCurveS[];
    /*

    $StereoCurveZ= `ls -sl`;
    $CurveItemZai = $StereoCurveZ[0];
    $CurveItemZbi = $StereoCurveZ[1];


    */












    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    proc int isCurveEndAtZY(vector $EndVectors[]){
    $Number = 0;
    for($eachVec in $EndVectors){
    $ThreeFs = $eachVec;
    if($ThreeFs[0] == 0){
    $Number++;
    }
    }
    return $Number;
    }

    //CUT CURVE

    /*




    if((fmod($iiz, 12))== 2){
    curve2points($PositionsZ_B[$iiz], $Intersect_A[`size($Intersect_A)`-1]);
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[0]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    curve2points($VecPtsMirrorA[$iiz], $Intersect_A[`size($Intersect_A)`-1]);
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[1]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    }









    if($AddAB==1){

    //START of one End Intersect
    //START of one End Intersect


    if($triggerNoTransA==1){
    $New_AllLocs_AB = $New_AllLocs_A;
    $distToCurveE_AB = $distToCurveE_A;
    }
    if($triggerNoTransB==1){
    $New_AllLocs_AB = $New_AllLocs_B;
    $distToCurveE_AB = $distToCurveE_B;
    }


    $LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;
    $ExpandedString = `sort $ExpandedString`;
    $SortedRangeCrv = `sort $LayerCurvesRangeA`;
    CurvesToPlane($SortedRangeCrv);

    $OffsetTol = 1.0005;
    clear $CollectN_index;

    // index pair of Locs and Curves   $TrackAllExisting3DCrv

    clear $COLLECT_INDEX;
    clear $COLLECTN_INDEX;
    clear $COLLECT_Wanted_INDEX;

    //print $New_AllLocs_AB;
    //print $distToCurveE_AB;
    //print $distToCurveE_AB[$New_AllLocs_AB[0]];

    for($eachIndex in $New_AllLocs_AB){

    $Distance_Aii = $distToCurveE_AB[$eachIndex];
    if($Distance_Aii<=$OffsetTol){
    //print $eachIndex;
    $CollectN_index[`size($CollectN_index)`] =  $eachIndex;
    $COLLECT_INDEX[`size($COLLECT_INDEX)`] = $TrackAllExisting3DCrv[$eachIndex];
    }else{
    $COLLECT_Wanted_INDEX[`size($COLLECT_Wanted_INDEX)`] = $TrackAllExisting3DCrv[$eachIndex];}
    }

    //print $CollectN_index;
    //print $queryLocCurveEnds3D;
    //print $ExpandedString;
    //print $TrackAllExisting3DCrv;
    //print $SortedRangeCrv;
    //print $CollectN_index
    // print size($queryLocCurveEnds3D);
    // print $COLLECT_INDEX;
    // print $COLLECT_Wanted_INDEX;
    // print $ExpandedString;
    //print $COLLECT_Wanted_INDEX;

    clear $ExpandedStringi;
    clear $ExpandedStringiS;
    $Cni = 0;
    for($eachIntCCi in $COLLECT_Wanted_INDEX){
    $ExpandedStringi[$Cni] = $SortedRangeCrv[$eachIntCCi];
    $ExpandedStringiS[$Cni] = $PlaneCurveS[$eachIntCCi];
    $Cni++;
    }

    // print $ExpandedStringi;

    clear $ExpandedStringii;
    clear $ExpandedStringiiS;
    $Cnii = 0;
    for($eachIntCCii in $COLLECT_INDEX){
    $ExpandedStringii[$Cnii] = $SortedRangeCrv[$eachIntCCii];
    $ExpandedStringiiS[$Cnii] = $PlaneCurveS[$eachIntCCii];
    $Cnii++;
    }
    // print $ExpandedStringii;
    // print $COLLECT_INDEX;



    // PROBLEM what if the curve that is draw interesects the curve its end is attached to?.... can fix later if needed

    $diff = stringArrayRemoveDuplicates($ExpandedStringi);
    $diff = stringArrayRemoveExact($ExpandedStringii, $diff);

    $diffS = stringArrayRemoveDuplicates($ExpandedStringiS);
    $diffS = stringArrayRemoveExact($ExpandedStringiiS, $diffS);

    //select -r $ExpandedStringii;
    //select -r $diffS;
    //select -r $diff;
    //PAUSE;
    // print $CollectN_index;
    // print $COLLECT_INDEX;


    clear $LocSMirror;
    for($eachIndex in $CollectN_index){
    $VEcF = $LocCurveEndsVec3D[$eachIndex];
    $VEcF[0] = $VEcF[0]*-1.0;
    $LocSMirror[`size($LocSMirror)`] = FloatToVec($VEcF);
    }
    //////////////////////////////////////////////////////
    //print $LocSMirror;
    // Loc $LocSMirror[0];


    clear $AllM;
    clear $ExistingIntA;
    for($eachFvec in $LocSMirror){
    $AllM = FindEqualVec($LocCurveEndsVec3D, $eachFvec);
    if(`size($AllM)`>0){
    AppendIntArray($ExistingIntA,$AllM);}
    clear $AllM;
    }


    //print $ExistingIntA;
    clear $arrayCurvesNearABM;
    clear $arrayCurvesNearS;

    clear $COLLECT_INDEX_M;
    for($eachIntE in $ExistingIntA){
    $arrayCurvesNearABM[`size($arrayCurvesNearABM)`] = $ExpandedString[$eachIntE];
    $arrayCurvesNearS[`size($arrayCurvesNearS)`] = $PlaneCurveS[$TrackAllExisting3DCrv[$eachIntE]];
    $COLLECT_INDEX_M[`size($COLLECT_INDEX_M)`] = $TrackAllExisting3DCrv[$eachIntE];
    }
    //print $TrackAllExisting3DCrv;
    //print $arrayCurvesNearS;
    //print $arrayCurvesNearABM;
    //print $COLLECT_INDEX_M;
    //print $TrackAllExisting3DCrv;
    //select -r $arrayCurvesNearABM;

    clear $ExpandedStringiim;
    $Cniim = 0;
    for($eachIntCCiim in $COLLECT_INDEX_M){
    $ExpandedStringiim[$Cniim] = $SortedRangeCrv[$eachIntCCiim];
    $Cniim++;
    }
    //print $ExpandedStringiim;
    //print $ExpandedString;

    $diffB = stringArrayRemoveExact($arrayCurvesNearABM, $diff);

    $diffB_s = stringArrayRemoveExact($arrayCurvesNearS, $diffS);

    //select -r $diffB;
    //select -r $diffB_s;
    //PAUSE;

    //////////////////////////////////////////////////////

    clear $interVecAx;
    clear $NodeCurveIndex;
    $NodeCurveIndex = CreateCrvInterTF($CurveItemZai, $diffB_s,0,0.001,$interVecAx);

    //print $interVecAx;
    // select -r $diffB[$NodeCurveIndex[0]];
    //PAUSE; PAUSE;
    //print $NodeCurveIndex;
    //print $interVecAx;

    //select -r $CurveItemZai;


    clear $interVecAy;
    clear $NodeCurveIndexi;
    $NodeCurveIndexi = CreateCrvInterTF($CurveItemZbi, $diffB_s,0,0.001,$interVecAy);
    //print $NodeCurveIndexi;
    // select -r $diffB[$NodeCurveIndexi[0]];
    //PAUSE; PAUSE;
    //////////////////////////////////////////////////////

    if((`size($NodeCurveIndexi)` >0 )&&(`size($NodeCurveIndex)` >0 )){




    clear $VecPointOnCrv;
    $CountPara = 0;
    $CurveSFoundS = `size($NodeCurveIndexi)`;
    //print $diffB;
    for($EachIndC in $NodeCurveIndexi){

    $CURVEiA = `listRelatives -children  $diffB_s[$EachIndC]`;
    $ParaFloat = StringArrayToFloatArray(stringToStringArray($interVecAy[$CountPara], " "));
    if($CountPara>0){
    $ParaSize[$CountPara] = `size($ParaFloat)`+$ParaSize[$CountPara-1];}
    if($CountPara==0){
    $ParaSize[$CountPara] = `size($ParaFloat)`;}
    for($EachPara in $ParaFloat){

    $EveryPara[`size($EveryPara)`] = $EachPara;
    $param = eval("paramLocator "+$CURVEiA[0]+".u["+$EachPara+"]");
    $posA = `pointPosition -w $param`;
    //print $posA;
    $VecPointOnCrv[`size($VecPointOnCrv)`] = FloatToVec($posA);
    delete  $param;
    }
    $CountPara++;

    }


    //for($eachVVec in $VecPointOnCrv){
    //Loc $eachVVec;
    //}

    $distCA = ArrayDistancesVecTofloat($VecPointOnCrv, $UnconnectedEnds[1]);
    $PointOnCrvIND = CreateIntIndex(`size($VecPointOnCrv)`);
    $PointOnCrv_String = IntArrayToStringArray($PointOnCrvIND);
    clear $EmptyCA;
    $newCA = SortFloatArrayAndString($distCA, $PointOnCrv_String, $EmptyCA);
    $EmptyCA = ReverseStringArray($EmptyCA);
    $New_PointOnCrvIND_A = ArrayToIntList($EmptyCA);
    $FOUNDc = $New_PointOnCrvIND_A[0];
    $NearestDistCA = $distCA[$New_PointOnCrvIND_A[0]];
    $NearestVecCA = $VecPointOnCrv[$New_PointOnCrvIND_A[0]];
    //Loc $NearestVecCA;
    //PAUSE;
    $CountWhatCurve = -1;
    //print $ParaSize;
    for($eachIntPara in $ParaSize){
    $CountWhatCurve++;
    if(($ParaSize[$CountWhatCurve]-1)>=$FOUNDc){
    $WhatCurve=$CountWhatCurve;
    break;
    }
    }

    //select -r $diffB_s[$NodeCurveIndexi[$WhatCurve]];
    //PAUSE;

    //print $interVecAx;

    clear $VecPointOnCrvb;
    $CountParab = 0;
    $CurveSFoundSb = `size($NodeCurveIndex)`;
    //print $diffB;
    for($EachIndCb in $NodeCurveIndex){

    $CURVEiAb = `listRelatives -children  $diffB_s[$EachIndCb]`;
    $ParaFloatb = StringArrayToFloatArray(stringToStringArray($interVecAx[$CountParab], " "));
    if($CountParab>0){
    $ParaSizeb[$CountParab] = `size($ParaFloatb)`+$ParaSizeb[$CountParab-1];}
    if($CountParab==0){
    $ParaSizeb[$CountParab] = `size($ParaFloatb)`;}
    for($EachParab in $ParaFloatb){

    $EveryParab[`size($EveryParab)`] = $EachParab;
    $paramb = eval("paramLocator "+$CURVEiAb[0]+".u["+$EachParab+"]");
    $posAb = `pointPosition -w $paramb`;
    //print $posAb;
    $VecPointOnCrvb[`size($VecPointOnCrvb)`] = FloatToVec($posAb);
    delete  $paramb;
    }
    $CountParab++;

    }


    // for($eachVVec in $VecPointOnCrvb){
    // Loc $eachVVec;
    // }

    $distCAb = ArrayDistancesVecTofloat($VecPointOnCrvb, $UnconnectedEnds[0]);
    $PointOnCrvINDb = CreateIntIndex(`size($VecPointOnCrvb)`);
    $PointOnCrv_Stringb = IntArrayToStringArray($PointOnCrvINDb);
    clear $EmptyCAb;
    $newCAb = SortFloatArrayAndString($distCAb, $PointOnCrv_Stringb, $EmptyCAb);
    $EmptyCAb = ReverseStringArray($EmptyCAb);
    $New_PointOnCrvIND_Ab = ArrayToIntList($EmptyCAb);
    $FOUNDcb = $New_PointOnCrvIND_Ab[0];
    $NearestDistCAb = $distCA[$New_PointOnCrvIND_Ab[0]];
    $NearestVecCAb = $VecPointOnCrvb[$New_PointOnCrvIND_Ab[0]];

    //Loc $NearestVecCAb;
    //PAUSE;
    $CountWhatCurveb = -1;
    print $ParaSize;
    for($eachIntParab in $ParaSizeb){
    $CountWhatCurveb++;
    if(($ParaSize[$CountWhatCurve]-1)>=$FOUNDcb){
    $WhatCurveb=$CountWhatCurveb;
    break;
    }
    }

    //select -r $diffB_s[$NodeCurveIndex[$WhatCurveb]];
    //PAUSE;


    ///////////////////////////////////////////////////////////////////
    //select -r $diffB_s[$NodeCurveIndex[$WhatCurveb]];
    //PAUSE;
    //select -r $diffB[$NodeCurveIndex[$WhatCurveb]];
    //PAUSE;
    //select -r $diffB_s[$NodeCurveIndexi[$WhatCurve]];
    //PAUSE;
    //select -r $diffB[$NodeCurveIndexi[$WhatCurve]];
    //PAUSE;




    $CurveA = $diffB[$NodeCurveIndexi[$WhatCurve]];
    $CurveB = $diffB[$NodeCurveIndex[$WhatCurveb]];
    //string $newNamesCA = substituteAllString($CurveA, "Plane", "");
    //string $newNamesCB = substituteAllString($CurveB, "Plane", "");
    $newNamesCA = $CurveA;
    $newNamesCB = $CurveB;
    Loc $NearestVecCA;
    Loc $NearestVecCAb;

    $CUT_CrvMirrorEnds_A = VecPtsToZMirrorPts({$NearestVecCAb});
    $CUT_CrvIntersectEnds_A = FloatToVec (lineIntersectionF($CamPos_A, $NearestVecCA, $CamPos_M, $CUT_CrvMirrorEnds_A[0]));
    $CUT_CrvIntersectMirrorEnds_A = VecPtsToZMirrorPts({$CUT_CrvIntersectEnds_A});


    // this places CUT_CrvIntersectEnds_A the 3d ifnferance Points of the two curve intersection points into the assumed curve end vectors
    // the trigger signifies the vector that which was not connecting directly to another curve end that which the other end will be attached to
    // since the new end of the drawn curve that intersects an existing 3d curve is not drwan with mathmatical percision its intersecting will
    // have a slightly different end
    // if have not gone so far as to program a choice between cutting the drawn vs. shifting the end to meet the found 3d intersecting
    // projected on the plane


    // float $ParaB = $EveryParab[$FOUNDcb];
    // string $selectionItemB = $CurveB + ".u[" + $ParaB + "]";
    // string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $selectionItemB`;

    $myCPOC = `createNode closestPointOnCurve`;
    connectAttr ($newNamesCB+".worldSpace")  ($myCPOC+".inCurve");
    $PointBc = $CUT_CrvIntersectMirrorEnds_A[0];
    $uParam = `closestPointOnCurve -ip $PointBc[0] $PointBc[1] $PointBc[2] -q -paramU $newNamesCB`;
    $paramZ = eval("paramLocator "+$newNamesCB+".u["+$uParam+"]");
    $paramZA = eval("paramLocator "+$newNamesCA+".u["+$uParam+"]");
    delete $myCPOC;


    $selectionItemB = $CurveB + ".u[" +$uParam+ "]";
    $selectionItemA = $CurveA + ".u[" +$uParam+ "]";
    delete  $paramZ;
    delete  $paramZA;
    $detachCurve1 = `detachCurve -ch off - replaceOriginal on $selectionItemB`;
    $detachCurve2 = `detachCurve -ch off - replaceOriginal on $selectionItemA`;

    CurveIndexVecTracking({$detachCurve1[0]});
    CurveIndexVecTracking({$detachCurve2[0]});

    $interposA = `pointPosition -w  $paramZ`;
    $interposB = `pointPosition -w  $paramZA`;
    $VecIntCB = FloatToVec ($interposB);
    $VecIntCA = FloatToVec ($interposA);

    Loc $CUT_CrvIntersectEnds_A;
    Loc $CUT_CrvIntersectMirrorEnds_A[0];

    $VecCUT_CrvA = FloatToVec (FloatPointsToCamPlane($VecIntCB));
    $VecCUT_CrvB = FloatToVec (FloatPointsToCamPlane($VecIntCA));

    if($triggerNoTransENDA==1){
    $VecOnPlaneA[0]= $VecCUT_CrvA;
    $VecOnPlaneB[0]= $VecCUT_CrvB;
    }else{$VecOnPlaneA[1]= $VecCUT_CrvA;
    $VecOnPlaneB[1]= $VecCUT_CrvB;}

    //END of one End Intersect
    //END of one End Intersect
    //END of one End Intersect
    //END of one End Intersect
    //END of one End Intersect

    }
    }
    */

    ///CUT CURVE ^





    // clear $StereoCurveZ;

    /*
    $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[0]);
    $AllLocsi = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    $AllLocs_String = IntArrayToStringArray($AllLocsi);
    $newOrdersZA = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    $EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
    $New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
    $Near_index_A = $New_AllLocs_A[0];
    $Distance_A = $distToCurveE_A[$Near_index_A];
    $Found_pt_A = $LocCurveEndsVec3D[$Near_index_A];
    $newOrdersZAM = $Found_pt_A;
    $newOrdersZAM[0] = $Found_pt_A[0] *-1;

    $distToCurveE_B = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[1]);
    $newOrdersZB = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    $EmptyStringNewOrderB = ReverseStringArray($EmptyStringNewOrderB);
    $New_AllLocs_B = ArrayToIntList($EmptyStringNewOrderB);
    $Near_index_B = $New_AllLocs_B[0];

    $Distance_B = $distToCurveE_B[$Near_index_B];
    $Found_pt_B = $LocCurveEndsVec3D[$Near_index_B];
    $newOrdersZBM = $Found_pt_B;
    $newOrdersZBM[0] = $Found_pt_B[0] *-1;


    */



    //////////////////////


    /*

    // if($EulerAngle_B <$EulerAngle_A ){
    if($BCurEndBiiAdd>$BCDiff){
    if($IntIfNearZero==0){
    //if( $DistTOEpipol_CurEndA > $DistTOEpipol_CurEndB){
    PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
    //if($DistTOEpipol_CurEndA > $DistTOEpipol_CurEndB){
    PAUSE;
    $IfTrue = FindLineCross( $Vecbv , $Vecbvi );
    if($IfTrue==1){
    cycleBackgroundColor;
    //reverseCurve  -ch 0 -rpo 1 -cos on $CurveItemZai;
    //$VecCurEndsa = ReverseVectorArray($VecCurEndsa);
    $PositionsZ_B = ReverseVectorArray($PositionsZ_B);
    // $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
    $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);
    }
    }
    //}
    }
    //}

    if($EulerAngle_B <$EulerAngle_A ){
    if($DistTOEpipol_CurEndA > $DistTOEpipol_CurEndB){
    print "Reverse_it";
    PAUSE;
    makeCurvePointDirectionLength((6), $FloatDirEpipol, $VecCurEndsa[1]);
    PAUSE; PAUSE;
    }
    if($DistTOEpipol_CurEndA>$DistTOEpipol_CurEndB){
    reverseCurve  -ch 0 -rpo 1 -cos on $CurveItemZai;
    }
    if($DistTOEpipol_CurEndA>$DistTOEpipol_CurEndB){
    $VecCurEndsb = ReverseVectorArray($VecCurEndsb);
    $PositionsZ_B = ReverseVectorArray($PositionsZ_B);
    $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
    $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);
    }
    }

    */

    ////////////////////




    proc int  PointsEquivalentTol( float $posA[],  float $posB[]){
    $pX = equivalentTol($posA[0], $posB[0],  0.001);
    $pY = equivalentTol($posA[1], $posB[1],  0.001);
    $pZ = equivalentTol($posA[2], $posB[2],  0.001);
    $addedResults = $pX + $pY + $pZ;
    return $addedResults;
    }


    proc vector ClosestPoint2LineVec(float $DirectionLineF[], float $PointOnLine[], float $PointN[]){
    $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    $VecLineDir = PositiveDir($DirectionLineF);

    $VecLineDirM = $VecLineDiri-$VecLineDir;
    //if on line Result: <<1, 1, 1>>  a point on the line and the point in question directions vector Mult//

    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];

    if($AdditR != 0.0){
    $MultDirOne = multiplyFloat(1.0, $DirectionLineF);
    $AddMultF = AddFloats($PointOnLine, $MultDirOne);
    $FDirNorA = Normal3Points($PointOnLine, $AddMultF, $PointN);
    $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    $MultDirMx = multiplyFloat($DistToLineSTart, $FDirNorA);
    $AddMultMiiFx = AddFloats($PointOnLine, $MultDirMx);
    $FDirNorB = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);
    $MultDirMxz = multiplyFloat($DistToLineSTart,  $FDirNorB);
    $AddMultMiiFxz = AddFloats($PointOnLine, $MultDirMxz);
    $locsA = lineIntersection($PointN, $FDirNorB, $PointOnLine, $DirectionLineF);

    $VlocA = <<$locsA[0],$locsA[1],$locsA[2]>>;
    }else{$VlocA = FloatToVec($PointN);}

    return $VlocA;
    }

    proc vector PointDirTang2LineVec(float $DirectionLineF[], float $PointOnLine[], float $PointN[]){
    $MultDirOne = multiplyFloat(1.0, $DirectionLineF);
    $AddMultF = AddFloats($PointOnLine, $MultDirOne);
    $FDirNorA = Normal3Points($PointOnLine, $AddMultF, $PointN);
    $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    $MultDirMx = multiplyFloat($DistToLineSTart, $FDirNorA);
    $AddMultMiiFx = AddFloats($PointOnLine, $MultDirMx);
    $FDirNorB = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);

    $VlocA = <<$FDirNorB[0],$FDirNorB[1],$FDirNorB[2]>>;

    return $VlocA;
    }

    /*
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    $CircleCenter = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureCenter")`;

    //-curvatureCenter


    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
    << ($norm.x), ($norm.y), ($norm.z) >>`;

    */

    //SmoothCurvature3(6);
    //attachCurveTangent( 1 );

    proc string[] SmoothCurvature3(float $curveM ){
    $curves = `ls -sl`;
    $myCurve = $curves[0];
    //rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    //smoothCurve -ch 0 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 4 );
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0  -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] +  ".translate")`;
    $step = $numEPrealNum2;
    $curve = "curve -d 3";
    $curveMin = $curveM;

    $curve = IteratCurve( $step, $paramlocatorpointOnCurvex, $curveMin, $FindSteps);

    $Newcurvez = `eval($curve)`;

    //rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $Newcurvez;
    $numLength = (`arclen $Newcurvez`) +1;
    $StepZNum = $numLength;
    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    // rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s $StepZNum -d 3 -tol 0.001  $Newcurvez;
    $Newcurve = {$Newcurvez};
    rename $Newcurve $curves;
    $Newcurve = {$curves[0]};
    return $Newcurve;
    }


    proc string IteratCurve(float $step, string $paramlocatorpointOnCurvex, float $curveMin, int $FindSteps){

    $MasterCount = 0;
    $curve = "curve -d 3";



    while ($FindSteps < 4){
    $curve = "curve -d 3";

    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    $CircleCenter = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureCenter")`;
    $tan = `getAttr  ($paramlocatorpointOnCurvex +  ".normal")`;
    $norm = `getAttr  ($paramlocatorpointOnCurvex +  ".tangent")`;
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
    << ($norm.x), ($norm.y), ($norm.z) >>`;


    if ( $CurvatureRadi <=  $curveMin){
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
    if((fmod($CountSteps, 12))== 2){
    $circlesZ[`size($circlesZ)`] = Circles_Direction($CircleCenter, $bi, $CurvatureRadi);
    }
    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    if((fmod($CountSteps, 12))== 2){
    $circlesZ[`size($circlesZ)`] =Circles_Direction($CircleCenter, $bi, $CurvatureRadi);
    }
    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    if((fmod($CountSteps, 12))== 2){
    $circlesZ[`size($circlesZ)`] =Circles_Direction($CircleCenter, $bi, $CurvatureRadi);
    }
    $CountSteps++;
    }
    }
    $FindSteps = $CountSteps;
    if($FindSteps < 4){$curveMin += 8.0; $curve = "curve -d 3"; delete $circlesZ;}
    if($MasterCount== 4){break;}
    $MasterCount++;

    }

    return $curve;
    }

    proc string IteratCurve(float $step, string $paramlocatorpointOnCurvex, float $curveMin, int $FindSteps){

    $MasterCount = 0;
    $curve = "curve -d 3";


    while ($FindSteps < 4){
    $curve = "curve -d 3";

    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;

    if ( $CurvatureRadi <=  $curveMin){
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];

    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];

    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];

    $CountSteps++;
    }
    }
    $FindSteps = $CountSteps;
    if($FindSteps < 10){$curveMin += 18.0; $curve = "curve -d 3";  }
    if($MasterCount== 4){break;}
    $MasterCount++;

    }

    return $curve;
    }

    proc vector [] makeCurvePointDirectionLengthN(float $Length, float $Direction[], float $posA[]){
    $MultDirA = multiplyFloat(($Length/2.0),  $Direction);
    $DirectionN = multiplyFloatArray(-1.0,$Direction);
    $MultDirB = multiplyFloat(($Length/2.0),  $DirectionN);
    $FDirA = AddFloats($posA, $MultDirA);
    $FDirB = AddFloats($posA, $MultDirB);
    $Avec[0]= FloatToVec($FDirA);
    $Avec[1]= FloatToVec($FDirB);
    $CurveBetween = curve2points($FDirA,  $FDirB);
    return $Avec;
    }

    proc vector [] LockEndsAverageCurveVec( vector $newVec[]){

    $range = 3;
    $TotalS = `size($newVec)`;
    $indexState = 0;
    while($indexState<$TotalS){
    $countS=1;
    $Xs=0;
    while($countS<$range){
    $indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
    $indexRight = fmod(($indexState + $countS),$TotalS);
    $indexLeftS[$Xs] = $indexLeft;
    $indexRightS[$Xs]= $indexRight;
    $countS++;
    $Xs++;
    }

    if(($indexState<=2)||($indexState>=($TotalS-3))){
    if($indexState<=2){
    $Aver = (( ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec[$indexState])/2.5;
    $AVvects[$indexState] = $Aver;
    }
    if($indexState>=($TotalS-3)){
    $Aver = (( ($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0))+$newVec[$indexState])/2.5;
    $AVvects[$indexState] = $Aver;
    }
    }else{
    $Aver = ((($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0) + ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec [$indexState])/4.0;
    $AVvects[$indexState] = $Aver;
    }
    clear $indexLeftS;
    clear $indexRightS;
    $indexState++;
    }
    return $AVvects;
    }

    global int $SortDistanceIntG;
    proc vector [] CurvatureUtility(string $curvesZ, int $NumberofSteps, float $curvature[], int $C[], float $TotalCA){
    global int $SortDistanceIntG;
    $step = $NumberofSteps;
    $myCurve = $curvesZ;
    $ii = 0;
    $TotalCAX =0;
    $t=0.0;
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;


    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );

    $CIrceP = `xform -q -ws -t $curvesZ`;
    for($a = 0.0; $t < $numEPrealNum;$a++){

    $t =  $a/$step;
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
    $CRVRadi[$ii] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;



    $DistanceS[$ii] = distance2Pts($values,$CIrceP);

    $ii++;
    }
    $NewIndexN = SortNumbersIntIndex($DistanceS);
    $SortDistanceIntG = $NewIndexN[0];
    delete $paramlocatorpointOnCurvex;

    for($eachCURVA in $CRVRadi){
    $TotalCAX +=  $eachCURVA;
    }
    $TotalCA = $TotalCAX;
    $curvature = $CRVRadi;
    return $CurveVectors;
    }

    proc vector [] AverageCurveVec( vector $newVec[]){

    $range = 3;
    $TotalS = `size($newVec)`;
    $indexState = 0;
    while($indexState<$TotalS){

    $countS=1;
    $Xs=0;
    while($countS<$range){
    $indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
    $indexRight = fmod(($indexState + $countS),$TotalS);
    $indexLeftS[$Xs] = $indexLeft;
    $indexRightS[$Xs]= $indexRight;
    $countS++;
    $Xs++;
    }
    $Aver = ((($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0) + ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec [$indexState])/4.0;
    $AVvects[$indexState] = $Aver;
    clear $indexLeftS;
    clear $indexRightS;
    $indexState++;
    }
    return $AVvects;
    }


    proc string VecArrayToCurveB(vector $FixVec[]){
    $sIZes = `size $FixVec `;
    $NUmers = CreateIntIndex($sIZes);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $K += "\-k"+" "+ $sIZes+" ";
    $sIZes++;
    $K += "\-k"+" "+ $sIZes+" ";
    $curve = "curve -d 3";
    for ($eachVeCx in $FixVec){
    $valuesBi = $eachVeCx;
    $curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    }
    $Newcurvez = `eval($curve)`;
    return $Newcurvez;
    }


    proc vector TwoVecsOrFloats(float $p1p2[], float $p1p3[]){
    $Ui = FloatToVec($p1p2);
    $Vi = FloatToVec($p1p3);
    $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;
    return $VEcLine;
    }

    proc int MostRightClockWiseInt ( vector $Vecs[], int $Two[]){
    $ThreePoints = { "0", "1", "2"};
    $point1 = FloatToVec($Vecs[0]);
    $point2 = FloatToVec($Vecs[1]);
    $point3 = FloatToVec($Vecs[2]);
    $U1 = TwoVecsOrFloats($point2, $point1);
    $V1 = TwoVecsOrFloats($point3, $point1);
    $U2 = TwoVecsOrFloats($point3, $point1);
    $V2 = TwoVecsOrFloats($point2, $point1);
    $U3 = TwoVecsOrFloats($point1, $point3);
    $V3 = TwoVecsOrFloats($point2, $point3);
    clear $normalV;
    $normalV[0] = FloatToVec( crossProduct( $U1, $V1, 0, 1 ) );
    $normalV[1] = FloatToVec( crossProduct( $U2, $V2, 0, 1 ) );
    $normalA = `unit ($normalV[0])`;
    $normalB = `unit ($normalV[1])`;
    $normalAAdd = $normalA[0] + $normalA[1];
    $normalAAdd2 = $normalB[0] + $normalB[1];

    if( $normalAAdd< $normalAAdd2){
    $TwoNew ={$Two[1], $Two[0]};

    }else{
    $TwoNew ={$Two[0], $Two[1]};

    }
    //$Two = $TwoNew;
    return $TwoNew[0];
    }

    proc AppendFloat(float $A[] , float $B[]){
    for($eachF in $B){
    $A[`size($A)`]= $eachF;
    }
    }

    proc float [] CreateIntIndexF(int $ArraySize, float $Fstep){
    $iNdex = 0;
    $AddF = 0;
    while($iNdex < $ArraySize){
    $AddF+= $Fstep;
    $FArrayInex[$iNdex] = $AddF;
    $iNdex++;
    }
    return $FArrayInex;
    }

    proc vector [] calculateEllipseCurve(vector $FixVeci[], float $steps){

    // $a == Major Axis
    // $b == Minor Axis




    $x=8;
    $y=8;
    $z = 8;
    $Lengthi = distance2Pts ($FixVeci[0], $FixVeci[1]);
    $MidPt = MidPoint($FixVeci[0], $FixVeci[1]);
    $FloatDirMajor = DirectionFN($FixVeci[0], $FixVeci[1]);

    $Lengthiii = distance2Pts ($MidPt, $FixVeci[2]);
    $FDirNorAi = Normal3Points($FixVeci[0], $FixVeci[1], $FixVeci[2]);
    $DirNormi = FloatToVec ($FDirNorAi);
    $normal = crossProduct( $FloatDirMajor, $FDirNorAi, 0, 0 );

    matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $norm = FloatToVec($FloatDirMajor);
    $bi = FloatToVec($FDirNorAi);
    $tan = FloatToVec( $normal);
    $MidVec = FloatToVec( $MidPt);
    $LENGTH = $Lengthi/2.0;
    // length times direction add to Point to move it??
    $ABC[0] = $FixVeci[0];
    $ABC[1] = ($tan * $LENGTH)+ $MidVec;
    $ABC[2] = $FixVeci[1];

    $C_radius = Circle3PtsM($ABC[0], $ABC[1], $ABC[2]);
    $ObjsCirclesRad = $C_radius[3];

    $VecLineDir = PositiveDirectionLine($ABC[1],$MidVec);
    $PointN = ClosestPoint2Line($VecLineDir, $FixVeci[2], $MidVec);
    $Di = distance2Pts( $MidVec , $PointN);
    $DiffL = ($ObjsCirclesRad-$Di)*2.0;

    $returnValue = 1;
    if($Di<$ObjsCirclesRad){
    $returnValue =1;}
    if($Di==$ObjsCirclesRad){
    $returnValue =0;}
    if($Di>$ObjsCirclesRad){
    $returnValue =-1;}


    if($returnValue==1){
    $FloatDirXn = DirectionFN( $MidVec, $FixVeci[2]);
    $PointNii = MultLenToDirAddToPoint($Di, DirectionFN( $MidVec, $PointN), $PointN);
    $DistAddiR2 = $Di*2.0;
    $HightD = sqrt (abs ((`pow $Di 2`) - (`pow $ObjsCirclesRad 2`)));
    $PointNiii = MultLenToDirAddToPoint($HightD,($tan), $PointN);
    $PointNiiiB = MultLenToDirAddToPoint($HightD,($tan*-1), $PointN);
    }

    $DiX = distance2Pts( $FixVeci[2] , $PointNiii);
    $DiY = distance2Pts( $FixVeci[2] , $PointNiiiB);
    if($DiX<$DiY){
    $ClosestPoint=$PointNiii;
    }
    if($DiX>$DiY){
    $ClosestPoint=$PointNiiiB;
    }

    $RadiOfOuter = distance2Pts($MidVec, $ClosestPoint);
    $DirRaytoIntersectC  = DirectionFN($MidVec, $ClosestPoint);
    $CircleRayPointN = ClosestPoint2Line($DirRaytoIntersectC, $MidVec, $FixVeci[2]);
    $SecondIntersectCsmall = lineIntersection( $MidVec, $DirRaytoIntersectC, $FixVeci[2], $norm);


    $RadiOfInnerC = distance2Pts($MidVec,$SecondIntersectCsmall);

    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
    ($bi.x),   ($bi.y),   ($bi.z),   0.0;     // Y axis
    ($tan.x),  ($tan.y),  ($tan.z),  0.0;     // Z axis
    $MidPt[0], $MidPt[1], $MidPt[2],     1.0 >>;  // Position
    $MatrizFloati = MatrixToFloat($mI);
    $x = $MidPt[0];
    $y = $MidPt[2];
    $z = $MidPt[1];
    $a = $Lengthi/2.0;

    ////////////////////////
    $b = $RadiOfInnerC;
    ///////////////////////////

    $angle = 0;

    $DirecOfPointABi = FloatToVec ( DirectionFN($FixVeci[0], $FixVeci[1]));
    $curvei = "curve -d 3";
    clear $VecH;
    $vi = 0;
    $Pi = 3.1415926535;

    $VecAngle = VAnglesofThreeVec($MidPt, $FixVeci[1], $FixVeci[2]);

    $beta = `deg_to_rad ($angle)`;
    $sinbeta = sin($beta);
    $cosbeta = cos($beta);
    $valuesiiA = {$x,0.0,$y} ;
    $valuesiAi = {$x, 0, $y} ;
    $valuesiAi = {$x, 0, $y} ;


    for ( $i = 0; $i < 360; $i += 360.0/$steps)
    {
    $alpha = $i * ( $Pi / 180.00) ;
    $sinalpha =  sin($alpha);
    $cosalpha =  cos($alpha);

    $X = $x + ($a * $cosalpha * $cosbeta - $b * $sinalpha * $sinbeta);
    $Y = $y + ($a * $cosalpha * $sinbeta + $b * $sinalpha * $cosbeta);

    $valuesA = {$X, 0, $Y} ;
    $MidTwoDtoElPoint = distance2Pts ($valuesiiA, $valuesA);
    $FloatDirEpoint = DirectionFN($valuesiiA, $valuesA);
    $newLocP = pointMatrixMult(  $FloatDirEpoint, $MatrizFloati );
    $MultDii = multiplyFloat($MidTwoDtoElPoint, $newLocP);
    $AddMepi = AddFloats($MidPt, $MultDii);
    $aV = FloatToVec($valuesA);
    $bV = FloatToVec($valuesiAi);

    $VecH[`size($VecH)`]= `FloatToVec $AddMepi`;

    $curvei += " -p "+$AddMepi[0]+" "+$AddMepi[1]+" "+$AddMepi[2];
    }

    eval($curvei);
    ResetTransEachSL;
    return $VecH;
    }

    global int $TrackDirectionChange;

    proc vector [] CurvatureIsCircleData(string $curvesZ, int $NumberofSteps, float $angleZ[], float $TotalDeg[], int $low, float $C[], float $Ang[]){

    $myCurve = $curvesZ;
    //smoothCurve -ch 0 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($curvesZ);

    $AverageVecCurve = AverageVectorPoint($PositionsZ_A);

    $CIrceP = `xform -q -ws -t $myCurve`;
    $AverageVecCurve =$CIrceP;
    //Loc $AverageVecCurve;
    $VecAverage = FloatToVec($AverageVecCurve);


    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 4 );

    $numEPrealNum2 = $NumberofSteps;
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -top 1 -p $myCurve`;
    $SharpValuesTan[0] = $PositionsZ_A[0];
    $step = $NumberofSteps;
    $Par = 0;
    $StepCycle = 0;
    $ii = 0;
    $iX = 0;
    $Trigger = 0;
    $Lowest = 11110;
    $Past = 0;
    $pastA = 0.0;
    $AddAngles = 0.0;
    $allAngi[`size($allAngi)`] = 0;
    $allAngiX[`size($allAngiX)`] = 0;
    $TwoZeroOne = {0,1};
    $TwoZeroOneT = {0,1};
    $Ct[0] = 0.0;
    $C[0] = 0.0;
    $CN[0] = 0;
    $TF = 0;
    $CountEVEN = 0;
    global int $TrackDirectionChange;
    $TrackDirectionChange=0;

    for($a = 0; $a <= $step;$a++){

    $t =  $a/$step;
    $Par = ($a/$step);

    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $valuesTan[$ii]  = `getAttr  ($paramlocatorpointOnCurvex + ".tangent")`;

    $CurvatureRadi[$ii] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    $valuesXYZ  = {$values[0], $values[1], $values[2]};
    $CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
    $valuesTanSpace[$ii] = $CurveVectors[$ii]+$valuesTan[$ii];

    $FlushVectors[`size($FlushVectors)`] = <<$values[0], $values[1], $values[2]>>;
    $PresentV = FloatToVec($values);

    // creat a vator array thatclears every time it passes 360 deg.. so the last few steps are recored..
    // then take the last angle find the persect it is of 360  divide that by the number of septs then use that as a float step

    if($ii>0){$Past=$ii-1;

    $EachAngle = VAnglesofThreeVec($VecAverage, $PositionsZ_A[0], $CurveVectors[$ii]);
    $threeVecs[0] = $PositionsZ_A[0]; $threeVecs[1] = $VecAverage; $threeVecs[2] = $PresentV;
    $TFmostR = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);

    // for copy past  $valuesTanPastSpace = $valuesTanSpace[$ii];
    $threeVecsT[0] = $valuesTanPastSpace; $threeVecsT[1] = $PastV; $threeVecsT[2] = $PresentV;
    $TFmostRT = MostRightClockWiseInt ($threeVecsT, $TwoZeroOneT);
    $allAngiX[`size($allAngiX)`]= $EachAngle;

    $Ct[$iX] =  $TFmostRT;
    $C[$iX] = $TFmostR;
    if($ii==1){
    $C[$iX-1]= $C[$iX];
    $Ct[$iX-1]= $Ct[$iX];
    $CN[`size($CN)`-1]=$C[$iX];
    $DeepPastTan = $valuesTanPast;
    $DeepPast= $PastV;
    }

    $AngleB = EulerAngB($DeepPastTan, $valuesTan[$ii]);
    $AngleNine = $AngleB[3];
    //if((($AngleNine>82)&&($AngleNine<98))||(($AngleNine>39)&&($AngleNine<51))){

    if($Ct[$iX]==$Ct[$iX-1]){
    if(($AngleNine>82)&&($AngleNine<98)){
    //print ("direction Same "+$AngleNine+"\n");

    $CurrentVecT = $CurveVectors[$ii]+$valuesTan[$ii];
    //Loc $CurrentVecT;

    //Loc $valuesXYZ;
    $SharpValuesTan[`size($SharpValuesTan)`]= FloatToVec (lineIntersectionF($DeepPast, ($DeepPast+$DeepPastTan), $valuesXYZ, $CurrentVecT));
    //Loc $SharpValuesTan[`size($SharpValuesTan)`-1];
    $SharpValuesTan[`size($SharpValuesTan)`]= $CurveVectors[$ii];
    //$SharpValuesTan[`size($SharpValuesTan)`]= $CurrentVecT;

    $DeepPastTan =  $valuesTan[$ii];
    $DeepPast= $CurveVectors[$ii];
    }
    }

    $allAngi[$iX] =$EachAngle;

    if($Trigger== 1){
    $allAngi[$iX] = (abs($pastA - $EachAngle))+$allAngi[$iX-1];
    if($allAngi[$iX]> 360){ $allAngi[$iX]=$EachAngle; $allAngi[$iX-1]=0;  $Trigger= 0; $TF++; }
    }

    if($Ct[$iX]!=$Ct[$iX-1]){
    //means it changed direction left or right from past tangent ..exe: the road that was curved right is now starting to curve left
    $TrackDirectionChange++;
    //print ("Direction CHANGE! "+$AngleNine+"\n");
    $CurrentVecT = $CurveVectors[$ii]+$valuesTan[$ii];
    //Loc $CurrentVecT;
    //Loc $valuesXYZ;
    //Cube $valuesXYZ;


    //if(($AngleNine>82)&&($AngleNine<98)){

    if(!(($AngleNine>135)||($AngleNine==0))){
    $SharpValuesTan[`size($SharpValuesTan)`]= FloatToVec (lineIntersectionF($DeepPast, ($DeepPast+$DeepPastTan), $valuesXYZ, $CurrentVecT));}
    //Loc $SharpValuesTan[`size($SharpValuesTan)`-1];
    $SharpValuesTan[`size($SharpValuesTan)`]= $CurveVectors[$ii];
    $DeepPastTan =  $valuesTan[$ii];
    $DeepPast= $CurveVectors[$ii];

    //}else{ if($AngleNine>90){$SharpValuesTan[`size($SharpValuesTan)`]= $CurveVectors[$ii];
    //	$DeepPastTan =  $valuesTan[$ii];
    //	$DeepPast= $CurveVectors[$ii];
    //}


    }

    if($C[$iX]!=$C[$iX-1]){
    //Loc $valuesXYZ;
    //Loc $valuesTanPast;
    $CN[`size($CN)`]= $iX;
    $CN[`size($CN)`]=$C[$iX];
    $Even_Odd = fmod($CountEVEN,2);
    if($Even_Odd ==1){
    $DistancesCycle[`size($DistancesCycle)`]= distance2Pts ($PositionsZ_A[0], $PresentV);

    }

    $CountEVEN++;
    $angleTii = (180.00- $allAngi[$iX]) +(180.00- $allAngi[$iX-1]);
    $allAngi[$iX] =  $angleTii +$allAngi[$iX-1];
    $Trigger= 1;

    }

    $pastA = $EachAngle;
    $AddAngles+= abs($EachAngle - $allAngiX[`size($allAngiX)`-1]);


    if($allAngi[`size($allAngi)`-1]>=360){
    clear $FlushVectors;
    $StepCycle =  abs ($StepCycle -$a);
    $FXiI = $StepCycle;
    $Fnumbers = 100.0/$FXiI;
    $floatZ = CreateIntIndexF($FXiI, $Fnumbers);
    $StepCycle = $a;
    //Loc $CurveVectors[$ii];
    $AddAngles=0;
    }
    }

    if($StepCycle < $Lowest){
    if($StepCycle!=0){
    $Lowest = $StepCycle;
    }
    }

    $PastV = FloatToVec($values);
    $valuesTanPast = $valuesTan[$ii];
    $valuesTanPastSpace = $valuesTanSpace[$ii];

    $iX++;
    $ii++;



    }

    /////////END of Loop

    $SharpValuesTan[`size($SharpValuesTan)`]= $PastV;

    $CN[`size($CN)`]= $iX;
    $low = $TF;
    $angleZ = $DistancesCycle;
    delete $paramlocatorpointOnCurvex;
    $TotalDeg = $CurvatureRadi;
    $Ang = $allAngiX;

    VecArrayToCurve($SharpValuesTan);
    ResetTransEachSL;
    editDisplayLayerMembers -noRecurse VecToCurve `ls -selection`;
    toggle -editPoint;
    VecArrayToCurveB($SharpValuesTan);
    ResetTransEachSL;
    editDisplayLayerMembers -noRecurse VecToCurveB `ls -selection`;

    return $CurveVectors;

    }

    //////////////////////////////////////

    global float $x0W;
    global float $x1W;
    global float $LearningCoeff;
    global float $Threshold;
    global float $Out;

    proc CPerceptron_CPerceptron(){
    global float $LearningCoeff;
    global float $Threshold;
    global float $x0W;
    global float $x1W;
    //srand((unsigned)(time(NULL)));
    $LearningCoeff = 0.2;
    $Threshold = 0.5;
    $x0W =  (float)(rand(32007))/(32767/2) - 1;
    $x1W =  (float)(rand(32007))/(32767/2) - 1;


    $x0W = 0.1;
    $x1W = 0.1;

    }


    //Setting up parameters
    proc CPerceptron_SetValues(float $x0WeightPar, float $x1WeightPar, float $LearningC, float $Thresh)
    {
    global float $x0W;
    global float $x1W;
    $x0W = $x0WeightPar;
    $x1W = $x1WeightPar;
    $LearningCoeff = $LearningC;
    $Threshold = $Thresh;
    }


    //Training function
    proc float CPerceptron_Train(float $x0, float $x1, float $r)
    {
    global float $x0W;
    global float $x1W;
    global float $LearningCoeff;
    global float $Threshold;
    global float $Out;

    $Sum = ($x0*$x0W)+($x1*$x1W)+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result = Sigmoid($Sum);

    $Out = ($x0*$x0W)+($x1*$x1W);
    if($Out>$Threshold){ $Output = 1.0;
    }else{ $Output = 0.0;}

    $Error = ((float)$r)-($Output);
    $Correction = $LearningCoeff*$Error;

    if($x0==1){ $x0W += $Correction;}
    if($x1==1){ $x1W += $Correction;}
    return $Result;
    }

    //Sigmoid function
    proc float CPerceptron_Sigmoid(float $x){
    $S = (1.0/(1.0+`exp(-$x)`));
    return $S;
    }


    //Get current weight values function
    proc float CPerceptron_Getx0Weight()
    {
    global float $x0W;
    return $x0W;
    }
    proc float CPerceptron_Getx1Weight()
    {
    global float $x1W;
    return $x1W;
    }


    //Run function, return y value
    proc float CPerceptron_Run(float $x0, float $x1)
    {
    global float $x0W;
    global float $x1W;
    global float $Threshold;
    $Sum = ($x0*$x0W)+($x1*$x1W);
    if($Sum>$Threshold){ $Result = 1;
    }else{ $Result = 0;}
    $Result = Sigmoid($Sum);
    return $Result;
    }


    proc float CPerceptron_RunX(float $x0)
    {

    global float $Threshold;
    if($x0>$Threshold){ $Result = 1;
    }else{ $Result = 0;}
    //$Result = Sigmoid($Sum);
    return $Result;
    }

    proc int PrintMod(int $StepN, float $Mod ){
    if ( fmod($StepN, $Mod) == ($Mod-1)  ) {
    return 1;
    }else {return 0;}
    }



    proc float [] GatherDataR(float $Xt[], float $Av){
    for ($eachInt in $Xt){
    if($eachInt > $Av){
    $Vt[`size($Vt)`]= 0;
    }else{$Vt[`size($Vt)`]= 1;}}
    return $Vt;
    }



    proc float [] GatherDataDiff(float $Xt[], float $Av){

    for ($eachInt in $Xt){
    $Vt[`size($Vt)`]= `abs ($Av-$eachInt)`;
    }
    return $Vt;
    }


    proc float AverageFloats(float $FloatArray[]){
    $Ix = 0;
    $AddAll = 0;
    for($eachF in $FloatArray){
    $AddAll+= $eachF;
    $Ix++;
    }
    $Divide = $AddAll/$Ix;
    return $Divide;
    }


    proc float [] AverageFloatArrays(float $FloatArrayA[], float $FloatArrayB[]){
    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = ($eachF + $FloatArrayB[$Ix])/2.0;
    $Ix++;
    }
    return $AddAll;
    }

    proc float [] AddFloatArrays(float $FloatArrayA[], float $FloatArrayB[]){
    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = ($eachF + $FloatArrayB[$Ix]);
    $Ix++;
    }
    return $AddAll;
    }

    proc float [] DivideFloatArrays(float $FloatArrayA[], float $DivideX){
    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] =  $eachF/$DivideX;
    $Ix++;
    }
    return $AddAll;
    }

    proc float [] DiffFloatArrays(float $FloatArrayA[], float $FloatArrayB[]){
    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = abs (($eachF - $FloatArrayB[$Ix]));
    $Ix++;
    }
    return $AddAll;
    }


    proc float PercentDiffZeroOneArrays(float $FloatArrayA[], float $FloatArrayB[]){
    $Ix = 0;
    $Fx = 0.0;
    for($eachF in $FloatArrayA){
    if ($eachF != $FloatArrayB[$Ix]){
    $AddAll+= 1.0;
    }
    $Fx++;
    $Ix++;
    }

    //print ($AddAll +" "+$Fx+"\n");

    if($AddAll != 0){
    $DiffMathA =  $AddAll / ($Fx/100.0);
    }else{ $DiffMathA = 0;}

    return $DiffMathA;
    }




    proc float [] GatherDataC(float $Xt[]){

    $Count = 0;
    $CountP = 0;
    //$Vt[`size($Vt)`] =0;
    for ($eachInt in $Xt){

    if($Count>0){
    if($Xt[$Count-1]!=$Xt[$Count]){

    $Vt[`size($Vt)`]= $CountP;
    $CountP = 0;
    }
    }
    $CountP++;
    $Count++;
    }
    $Vt[`size($Vt)`]= $CountP;

    return $Vt;
    }

    proc int [] GatherData(int $Xt[]){

    if(`size($Xt)`>0){
    return $Xt;
    }
    }
    proc float [] GatherDataF(float $Xt[]){

    if(`size($Xt)`>0){
    return $Xt;
    }
    }


    proc float CPerceptron_TrainX(float $x0, float $x1)
    {

    global float $Threshold;
    $Sum = ($x0)+($x1)+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result = Sigmoid($Sum);
    return $Result;
    }


    //Sigmoid function
    proc float CPerceptron_Sigmoid(float $x){
    $S = (1.0/(1.0+`exp(-$x)`));
    return $S;
    }


    proc float [] GatherDataZeroOne(float $Xt[]){
    $count = 0;
    for ($eachF in $Xt){
    if($eachF == 1){
    $ZO[$count] = 1;
    }
    if($eachF == -1){
    $ZO[$count] = 0;
    }
    $count++;

    }
    return $ZO;
    }


    proc GatherDataRRV(float $Xt[], vector $Pts[]){
    $count = 0;
    for ($eachF in $Xt){
    if($eachF == 1){
    Loc $Pts[$count];
    }
    $count++;

    }
    }




    proc float [] GatherDataRR(float $Xt[], float $Av){
    $count = 0;

    for ($eachF in $Xt){

    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= -1;}

    if($count>0){

    if($PastF<$eachF){
    if($PastF<$Av){
    if(($PastF+$eachF/2.0)<$Av){
    $Vt[$count]= 1; }
    }
    }

    }

    $PastF = $eachF;
    $count++;
    }
    return $Vt;
    }

    proc float [] GatherDataRRZO(float $Xt[], float $Av){
    $count = 0;

    for ($eachF in $Xt){

    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= 0;}

    if($count>0){

    if($PastF<$eachF){
    if($PastF<$Av){
    if(($PastF+$eachF/2.0)<$Av){
    $Vt[$count]= 1; }
    }
    }

    }

    $PastF = $eachF;
    $count++;
    }
    return $Vt;
    }

    proc float [] GatherDataAboveBelowT(float $Xt[], float $Av){
    $count = 0;
    for ($eachF in $Xt){
    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= 0;}
    $count++;
    }
    return $Vt;
    }




    proc float [] CPerceptronZ_Train(float $x0[], float $x1[], float $r)
    {

    global float $x0WX[];
    global float $x1WX[];
    global float $LearningCoeff;
    global float $Threshold;
    global float $Out;


    $Size = size($x0);
    for($i=0; $i<$Size; $i++){
    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i])+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result[$i] = Sigmoid($Sum);

    $Out = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
    if($Out>$Threshold){ $Output = 1.0;
    }else{ $Output = 0.0;}

    $Error = ((float)$r)-($Output);
    $Correction = $LearningCoeff*$Error;

    if($x0[$i]==1){ $x0WX[$i] += $Correction;}
    if($x1[$i]==1){ $x1WX[$i] += $Correction;}

    }

    return $Result;
    }
    /*
    GatherDataF($x1WX);
    9.906

    $Out = (-1*3.01)+(1*3.01);
    if($Out>$Threshold){ $Output = 1.0;
    }else{ $Output = 0.0;}
    print $Output;
    $Error = ((float)0.99)-($Output);
    $Correction = $LearningCoeff*$Error;

    $Sum = (-1*3.01)+(1*3.01)+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    Sigmoid($Sum);

    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1
    print $x1WX[29];
    print $x0WX[29];
    */
    proc float [] CPerceptronZ_TrainX(float $x0[], float $x1[])
    {

    global float $Threshold;
    $Size = size($x0);
    for($i=0; $i<$Size; $i++){
    $Sum = ($x0[$i])+($x1[$i])+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result[$i] = Sigmoid($Sum);
    }
    return $Result;
    }




    proc float [] CPerceptronZ_RunXZ(float $x0[], float $x1[])
    {
    global float $x0WX[];
    global float $x1WX[];
    global float $Threshold;
    $Size = size($x0);

    for($i=0; $i<$Size; $i++){

    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
    if($Sum>$Threshold){ $Result[$i] = 1;
    }else{ $Result[$i] = 0;}
    $Result[$i] = Sigmoid($Sum);
    }
    return $Result;
    }

    proc float [] CPerceptronZ_RunXYZ(float $x0[], float $x1[])
    {
    global float $x0WX[];
    global float $x1WX[];
    global float $Threshold;
    $Size = size($x0);

    for($i=0; $i<$Size; $i++){

    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i])+((-1)*$Threshold);
    $Result[$i] = Sigmoid($Sum);
    }
    return $Result;
    }



    proc float [] CPerceptronZ_RunOUTPUT(float $x0[], float $x1[])
    {
    global float $x0WX[];
    global float $x1WX[];
    global float $Threshold;
    $Size = size($x0);

    for($i=0; $i<$Size; $i++){

    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
    if($Sum>$Threshold){ $Result[$i] = 1;
    }else{ $Result[$i] = 0;}
    $Result[$i] = Sigmoid($Sum);

    }
    return $Result;
    }

    proc float [] Sum_PerceptronZ_TrainX(float $x0[], float $x1[])
    {

    $ThresholdX = 1.5;
    $Size = size($x0);
    for($i=0; $i<$Size; $i++){
    $Sum = ($x0[$i] + $x1[$i] );
    //print ("Sum "+$Sum+"\n");
    if($Sum > $ThresholdX){ $Result[$i] = 1;
    }else{ $Result[$i] = -1;}
    }
    return $Result;
    }
    proc string [] VecArrayToSplitCurve(vector $FixVec[]){

    // the middle curve will always be even!

    $sIZes = `size $FixVec `;
    $evenOdd = fmod($sIZes, 2);

    $sIZesHalf = (($sIZes)/2)+1;
    $NUmers = CreateIntIndex($sIZesHalf);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $countN = 0;
    $curveA = "curve -d 1";
    for ($eachVeCx in $NUmers){
    $valuesBi  = $FixVec[$countN];
    $curveA += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    $countN++;
    }
    $curveA += " "+ $K;
    $curveB = "curve -d 1";
    $countN--;
    for ($eachVeCx in $NUmers){
    $valuesBi  = $FixVec[$countN];
    $curveB += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    $countN++;
    }
    $curveB += " "+ $K;
    $NewcurvezA = `eval($curveA)`;
    $NewcurvezB = `eval($curveB)`;
    $NewcurvezAB = {$NewcurvezA , $NewcurvezB};
    return $NewcurvezAB;
    }

    proc vector [] LineIntersectPlaneCam( vector $Vecii[], float $CamP[], vector $Vec[]){

    $pAv = AverageVectorPoint($Vec);
    $n = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    $CountVV = 0;
    for($eachVecLine in $Vecii){
    $FloatDirA  = DirectionF($eachVecLine, $CamP);
    $FloatDirNormalA = multiplyFloat(2, $FloatDirA);
    $MultDirA = AddFloats( $FloatDirNormalA, $eachVecLine);

    $DistanceLocA = distance2Pts(  $eachVecLine, $pAv);
    $MultDirCam  = multiplyFloat($DistanceLocA, $n);
    $FloatDirectionCamNormalA  = AddFloats($pAv, $MultDirCam);

    $PointN  = ClosestPoint2Line($n, $pAv, $eachVecLine);
    $FloatDirectionAi  = DirectionF($PointN, $pAv);
    $DistanceLoc = distance2Pts( $PointN, $pAv );

    $MultDirPC1  = multiplyFloat($DistanceLoc, $FloatDirectionAi);
    $FloatDirNormalDist  = AddFloats($eachVecLine, $MultDirPC1);
    $PointNii  = ClosestPoint2Line(DirectionF($PointN, $pAv), $eachVecLine, $MultDirA);
    $FloatDirectionAii  = DirectionF($PointNii, $MultDirA);

    $OnPlane[$CountVV] = FloatToVec (lineIntersection( $FloatDirNormalDist, $FloatDirectionAii, $eachVecLine, $FloatDirA));
    //Loc $OnPlane[$CountVV];
    $CountVV++;
    }
    return $OnPlane;
    }

    proc vector FindIfCurveIsOrthoEpipol(vector $EpipolD[], vector $CRV_ENDS[], float $DistEnds, vector $LineMid){

    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;


    // when working with the plane get the vanishing points directions


    if(`size($EpipolD)` == 3){

    //print "EpiPolar";

    $Xdirect = $EpipolD[0];
    $Ydirect = $EpipolD[1];
    $Zdirect = $EpipolD[2];
    }else{
    $Xdirect = << 1,0,0>>;
    $Ydirect = << 0,1,0>>;
    $Zdirect = << 0,0,1>>;
    }

    $XYZdirect[0] = $Xdirect;
    $XYZdirect[1] = $Ydirect;
    $XYZdirect[2] = $Zdirect;


    $LineAMain = PositiveDirectionLine($CRV_ENDS[0], $CRV_ENDS[1]);
    $EulerAngleA  = EulerAngB($Xdirect,$LineAMain);
    $EulerAngleB  = EulerAngB($Ydirect,$LineAMain);
    $EulerAngleC  = EulerAngB($Zdirect,$LineAMain);
    $EulerABCi[0]= $EulerAngleA[3];
    $EulerABCi[1]= $EulerAngleB[3];
    $EulerABCi[2]= $EulerAngleC[3];
    $stringF = FloatArrayToStringArray($EulerABCi);
    clear $EmptyIndx;
    $index = CreateIntIndex(3);
    $stringIndTr = IntArrayToStringArray($index);
    SortFloatArrayAndString( $EulerABCi, $stringIndTr, $EmptyIndx);
    $EmptyIndx = ReverseStringArray($EmptyIndx);
    $xyz = $EmptyIndx[0];
    $AxisOrthoLine = $xyz;
    $Anglei = $EulerABCi[$xyz];
    //print $Anglei;
    $NewDirectionZ = $XYZdirect[$xyz];
    $DistEnds= distance2Pts($CRV_ENDS[0], $CRV_ENDS[1]);
    $LineMid = ($CRV_ENDS[0] + $CRV_ENDS[1])/2.0;
    $AngleEpiPole = $Anglei;

    $isOrthoTrueZi = 0;
    if($Anglei < 8.55){
    $isOrthoTrueZi = 1;
    }
    $IsOrthoLineTrue = $isOrthoTrueZi;
    //print $IsOrthoLineTrue;
    return $NewDirectionZ;
    }




    /*
    $StereoCurveZ= `ls -sl`;
    $CurveItemZai = $StereoCurveZ[0];
    $CurveItemZbi = $StereoCurveZ[1];
    */

    global string $PlaneCurveS[];


    proc StereoCurveZ(string $CurveItemZai, string $CurveItemZbi){
    global string $StereoCurveZ[];
    global string $VanishingPointsLinesTempGuides[];
    global int $addNumbersA;
    global float $VanishingPointGlobal[];
    global string $PlaneCurveS[];
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;
    $SnapR = 1.55;
    $Smooth = 398;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 1 -tol 0.05 $CurveItemZai;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 1 -tol 0.05 $CurveItemZbi;
    clear $AllLocPositionsZi;
    $AllLocPositionsZi = VecCurveCvs( $CurveItemZai);
    $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    ResetTranslation({$newPlaneCurveA});
    delete $CurveItemZai;
    $CurveItemZai = $newPlaneCurveA;
    clear $AllLocPositionsZi;
    $AllLocPositionsZi = VecCurveCvs( $CurveItemZbi);
    $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    ResetTranslation({$newPlaneCurveA});
    delete $CurveItemZbi;
    $CurveItemZbi = $newPlaneCurveA;
    $VecCurEndsa = VecCurveEnds({$CurveItemZai});
    $VecCurEndsb = VecCurveEnds({$CurveItemZbi});
    $StereoCurveZ[0]= $CurveItemZai;
    $StereoCurveZ[1]= $CurveItemZbi;
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveCvs($CurveItemZai );
    clear $PositionsZ_B;
    $PositionsZ_B = VecCurveCvs($CurveItemZbi );
    clear $VecPtsMirrorA;
    clear $VecPtsMirrorB;
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
    $CamDirVecNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $MultDirCam = multiplyFloat(-1, $CamDirVecNormal);
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    clear $VecPtsMirrorEnds_A;

    clear $VecPtsMirrorEnds_B;
    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);
    $EpipolPosCamM = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;
    $MidPosFCam = $CamPlane1;
    $FloatDirEpipol = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    $FloatDirEpipolB = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
    $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
    $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);
    $DistTOEpipol_CurEndA = distance2Pts($PointN_Epi, $VecCurEndsb[0]);
    $DistTOEpipol_CurEndB = distance2Pts($PointN_EpiB, $VecCurEndsb[0]);
    $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
    $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
    $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;
    $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
    $BCDiff = abs($BCurEndB - $BCurEndBNN);
    $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd ;
    $BCDiffi = abs($BCurEndB - $BCurEndBNNi);

    $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);
    $FloatDirEndPtsA = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
    $EulerAngleA = EulerAngB($FloatDirEndPtsA, $FloatDirEpipol);
    $EulerAngle_A = $EulerAngleA[3];
    $FloatDirEndPtsB = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
    $EulerAngleB = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);
    $EulerAngle_B = $EulerAngleB[3];
    $FloatDirEndPtsAi = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
    $EulerAngleAi = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);
    $EulerAngle_Ai = $EulerAngleAi[3];
    $FloatDirEndPtsBi = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
    $EulerAngleBi = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);
    $EulerAngle_Bi = $EulerAngleBi[3];
    $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
    $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;
    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);

    $Vecbv  = $VecCurEndsa;
    $Vecbvi = $VecCurEndsb;
    $IfTrue = FindLineCross( $Vecbv , $Vecbvi );
    $weighedtFindings = 0;
    $weighedtFindingsZ = 0;
    $weighedtFindingsN = 0;
    if($IfTrue=1){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;
    }
    if($IntIfNearZero==1){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}
    if($EulerAngle_AB<$EulerAngle_AiBi){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}

    $LengCRV_a = `arclen $CurveItemZai`;
    $CRV_ENDSi = $VecCurEndsa;
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
    //float $DiffMathA = ($LengCRV_a-$DistEndsi) / ($DistEndsi/100.0);

    $LengCRV_b = `arclen $CurveItemZbi`;
    $CRV_ENDSii = $VecCurEndsb;
    $DistEndsii = distance2Pts($CRV_ENDSii[0], $CRV_ENDSii[1]);
    $DiffMathB = $DistEndsii / ($LengCRV_b/100.0);

    $PerDiffSum = ($DiffMathA+$DiffMathB)/2.0;

    //print (" DiffMathA " +$DiffMathA + " DiffMathB " +$DiffMathB +"\n");
    //if(($DiffMathA> 96.5) && ($DiffMathB > 96.5)){
    //$PerDiffSum =99;
    //}else{$PerDiffSum =1;}

    $triggerStraitCRV = 0;
    $triggerNoTransENDA = 0;
    $triggerNoTransENDB = 0;
    $First_Second_Both_None = 0;
    //print ("START FindIfCurveIsOrthoEpipol" +"\n");
    $XYZdirectL[0] = << 1,0,0>>;
    $XYZdirectL[1] = << 0,1,0>>;
    $XYZdirectL[2] = << 0,0,1>>;
    if( $PerDiffSum>97.05){
    print ("FIST IF : ENGAGED PerDiffSum" +$PerDiffSum +"\n");
    print ("ENGAGED FindIfCurveIsOrthoEpipol" +"\n");
    $triggerStraitCRV=1;
    $DDirEpipol = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
    $MidCurveA  = MidPoint($VecCurEndsa[0], $VecCurEndsa[1]);
    $MidCurveB  = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);
    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);

    $EpipolD = $DDirEpipolXYZ;
    $Trueii = 0;

    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    }


    if($weighedtFindingsZ<$weighedtFindingsN){
    /////////////////////////////REMOVED


    /////////////////////////////
    //if(($DistB<$DistA)||($weighedtFindingsZ<$weighedtFindingsN)){
    if( ($weighedtFindingsZ<$weighedtFindingsN)){

    cycleBackgroundColor;
    $PositionsZ_B = ReverseVectorArray($PositionsZ_B);
    $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);
    $VecCurEndsb = ReverseVectorArray($VecCurEndsb);
    $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
    }
    }


    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
    $queryLocCurveEnds3D = `sort $queryLocCurveEnds3D`;
    $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
    $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
    $TrackAllExisting3DCrv = CreatePairIntIndex($SizeCrvi);
    $LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;
    $SizeCrvR = `size($LayerCurvesRangeA)` ;
    clear $ExpandedString;
    $Cn = 0;
    for($eachIntCC in $TrackAllExisting3DCrv){
    $ExpandedString[$Cn] = $LayerCurvesRangeA[$eachIntCC];
    $Cn++;
    }
    $triggerNoTrans = 0;
    $triggerNoTransA = 0;
    $triggerNoTransB = 0;
    $triggerNoTrans = 0;

    clear $IntersectEnds_Ax;
    $iia = 0;


    $trigger_straitC = 0;
    if(!(`size($queryLocCurveEnds3D)` > 2)){
    print ("ENGAGED PerDiffSum " +$PerDiffSum +"\n");
    if($PerDiffSum >95.05){
    $iis = 0;
    for ($eachVecx in  $VecCurEndsb){
    $XIntersect_Ax[$iis] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsb[$iis], $CamPos_M, $VecPtsMirrorEnds_A[$iis]));
    $iis++;
    }
    $XIntersect_Ax[2] =  $XIntersect_Ax[1];
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    $XIntersect_Ax[0] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[0]);
    $XIntersect_Ax[2] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[2]);
    $PositionsZ_Bii= $XIntersect_Ax;
    $PositionsZ_Aii= VecPtsToZMirrorPts($PositionsZ_Bii);
    $ThefirstCurve = VecArrayToCurve($XIntersect_Ax);
    $PtsMirrorAi= VecPtsToZMirrorPts($XIntersect_Ax);
    $ThefirstCurvei = VecArrayToCurve($PtsMirrorAi);

    $trigger_straitC =1;
    }
    }

    ////////////
    if(`size( $queryLocCurveEnds3D)`>2){

    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);
    for ($eachVecx in  $VecCurEndsa)
    {
    $IntersectEnds_Ax[$iia] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsa[$iia], $CamPos_M, $VecPtsMirrorEnds_B[$iia]));
    $iia++;
    }

    $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[0]);
    $AllLocsi = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    $AllLocs_String = IntArrayToStringArray($AllLocsi);
    $newOrdersZA = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    $EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
    $New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
    $Near_index_A = $New_AllLocs_A[0];
    $Distance_A = $distToCurveE_A[$Near_index_A];
    $Found_pt_A = $LocCurveEndsVec3D[$Near_index_A];
    $newOrdersZAM = $Found_pt_A;
    $newOrdersZAM[0] = $Found_pt_A[0] *-1;
    $distToCurveE_B = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[1]);
    $newOrdersZB = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    $EmptyStringNewOrderB = ReverseStringArray($EmptyStringNewOrderB);
    $New_AllLocs_B = ArrayToIntList($EmptyStringNewOrderB);
    $Near_index_B = $New_AllLocs_B[0];
    $Distance_B = $distToCurveE_B[$Near_index_B];
    $Found_pt_B = $LocCurveEndsVec3D[$Near_index_B];
    $newOrdersZBM = $Found_pt_B;
    $newOrdersZBM[0] = $Found_pt_B[0] *-1;

    $PointsA[0] = FloatToVec($Found_pt_A);
    $PointsA[1] = FloatToVec($Found_pt_B);
    $PointsB[0] = FloatToVec($newOrdersZAM); // negative mirror of first endpoint of first curve
    $PointsB[1] = FloatToVec($newOrdersZBM);

    $VecOnPlaneA = VecPointsToCameraPlane($PointsA);
    $VecOnPlaneB = VecPointsToCameraPlane($PointsB);

    $NewFoundLocs[0] = $queryLocCurveEnds3D[$Near_index_A];
    $NewFoundLocs[1] = $queryLocCurveEnds3D[$Near_index_B];
    $arrayCurvesNear[0] = ("Plane"+$NewFoundLocs[0]);
    $arrayCurvesNear[1] = ("Plane"+$NewFoundLocs[1]);
    $NewFoundLocs = $arrayCurvesNear;
    $LocOnPlaneVec = PointArray($NewFoundLocs);
    $distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocOnPlaneVec[0]);
    $distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocOnPlaneVec[1]);
    $TXI = << -1.0 , 1.0, 1.0>>;
    $LoCz_3D[0] = MultVec($IntersectEnds_Ax[0],$TXI);
    $LoCz_3D[1] = MultVec($IntersectEnds_Ax[1], $TXI);

    ////////////////////////
    $DistToIntersectTOnear[0] = distance2Pts($IntersectEnds_Ax[0], $PointsA[0]);
    $DistToIntersectTOnear[1] = distance2Pts($IntersectEnds_Ax[1], $PointsA[1]);
    $DistToIntersectTOnear[2] = distance2Pts($LoCz_3D[0], $PointsB[0]);
    $DistToIntersectTOnear[3] = distance2Pts($LoCz_3D[1], $PointsB[1]);

    $distToPlaneLoc3D[0] = distance2Pts($VecCurEndsa[0], $PointsA[0]);
    $distToPlaneLoc3D[1] = distance2Pts($VecCurEndsa[1], $PointsA[1]);
    $distToPlaneLoc3D[2] = distance2Pts($VecCurEndsb[0], $PointsB[0]);
    $distToPlaneLoc3D[3] = distance2Pts($VecCurEndsb[1], $PointsB[1]);
    //////////////////////////

    $DiffMathA = $DistToIntersectTOnear[0]/ ($distToPlaneLoc3D[0]/100.0);
    $DiffMathB = $DistToIntersectTOnear[1] / ($distToPlaneLoc3D[1]/100.0);
    $DiffMathAm = $DistToIntersectTOnear[2]/ ($distToPlaneLoc3D[2]/100.0);
    $DiffMathBm = $DistToIntersectTOnear[3] / ($distToPlaneLoc3D[3]/100.0);

    $relativeDistanceA = ($DiffMathA+$DiffMathAm)/2.0;
    $relativeDistanceB = ( $DiffMathB+$DiffMathBm)/2.0;
    /*
    $relativeDistanceAi = ($Distance_A+$distToPlaneLoc[0])/2.0;
    $relativeDistanceBi = ($Distance_B+$distToPlaneLoc[1])/2.0;
    $relativeDistanceAZ = distance2Pts($VecOnPlaneA[0], $PointsA[0]);
    $relativeDistanceBZ = distance2Pts($VecOnPlaneB[0], $PointsB[0]);
    $DiffMathAi = $relativeDistanceAi/ ($relativeDistanceAZ/100.0);
    $DiffMathBi = $relativeDistanceBi / ($relativeDistanceBZ/100.0);
    $TimesMathAi = $relativeDistanceA*$relativeDistanceAZ/ ($distToPlaneLoc3D[0]/100.0);
    $TimesMathBi = $relativeDistanceB*$relativeDistanceBZ/ ($distToPlaneLoc3D[1]/100.0);
    //float $SnapR = 1.95;
    print ("\n");
    print ("relativeDistanceA "+"\n");
    print ($relativeDistanceA+"\n");
    print ("relativeDistanceB "+"\n");
    print ($relativeDistanceB+"\n");
    print ("\n");
    print ("TimesMathA "+"\n");
    print ($TimesMathA+"\n");
    print ("\n");
    print ("TimesMathB "+"\n");
    print ($TimesMathB+"\n");
    print ("\n");
    */

    if($relativeDistanceA<$SnapR){
    $triggerNoTransA++;
    }
    if($relativeDistanceA <$SnapR){
    $triggerNoTransB++;
    }
    if(!($relativeDistanceA<$SnapR)){
    $VecOnPlaneA[0] = $VecCurEndsa[0];
    $VecOnPlaneB[0] = $VecCurEndsb[0];
    $triggerNoTransENDA=1;
    }else{$triggerNoTrans++;
    $First_Second_Both_None =0;
    }		if(!($relativeDistanceB<$SnapR)){
    $VecOnPlaneA[1] = $VecCurEndsa[1];
    $VecOnPlaneB[1] = $VecCurEndsb[1];
    $triggerNoTransENDB=1;
    }else{$triggerNoTrans++;
    $First_Second_Both_None =1;

    if($triggerNoTransENDA==0){ $First_Second_Both_None =-2;}

    }

    if($triggerNoTrans==0){
    $First_Second_Both_None =-1;}

    //if(($triggerNoTransENDA +$triggerNoTransENDB)== 2){
    //}

    //if(($triggerNoTransENDA +$triggerNoTransENDB)== 0){
    //}


    $ConnectedEnds = $triggerNoTransENDA + $triggerNoTransENDB;
    if($triggerNoTransENDA==1){
    $UnconnectedEnds[0]= $VecOnPlaneA[0];
    $UnconnectedEnds[1]= $VecOnPlaneB[0];
    }else{$UnconnectedEnds[0]= $VecOnPlaneA[1];
    $UnconnectedEnds[1]= $VecOnPlaneB[1];}

    clear $arrayCurvesNearA;
    clear $arrayCurvesNearA;
    $AddAB = $triggerNoTransA+$triggerNoTransB;


    if($triggerNoTrans!=0){

    $PositionsZ_A = VecCurveCvs($CurveItemZai );
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEndsa,$VecOnPlaneA, $PositionsZ_A);
    $PositionsZ_Bi = Matrix_Curve_TranslationCC($VecCurEndsb, $VecOnPlaneB, $PositionsZ_B);
    clear $VecPtsMirrorA;
    $VecPtsMirrorA= VecPtsToZMirrorPts( $PositionsZ_Ai);
    clear $VecPtsMirrorB;
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_Bi);
    $PositionsZ_A = $PositionsZ_Ai;
    $PositionsZ_B = $PositionsZ_Bi;
    cycleBackgroundColor;
    }

    }

    //print (" IsOrthoTrueZi Eq  "+$IsOrthoLineTrue +"\n");

    if($triggerNoTrans==0){
    if($PerDiffSum >97.0){

    $iis = 0;
    for ($eachVecx in  $VecCurEndsb){
    $XIntersect_Ax[$iis] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsb[$iis], $CamPos_M, $VecPtsMirrorEnds_A[$iis]));
    $iis++;
    }
    $XIntersect_Ax[2] =  $XIntersect_Ax[1];
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    $XIntersect_Ax[0] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[0]);
    $XIntersect_Ax[2] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[2]);

    $PositionsZ_Bii= $XIntersect_Ax;
    $PositionsZ_Aii= VecPtsToZMirrorPts($PositionsZ_Bii);

    $ThefirstCurve = VecArrayToCurve($XIntersect_Ax);
    $PtsMirrorAi= VecPtsToZMirrorPts($XIntersect_Ax);
    $ThefirstCurvei = VecArrayToCurve($PtsMirrorAi);

    $trigger_straitC =1;
    }
    }


    if($triggerNoTrans!=0){

    //print ("triggerNoTrans Doesnt not Eq ZERO" +"\n");

    if($IsOrthoLineTrue==1){
    //print ("IsOrthoLineTrue Eq ONE" +"\n");

    if($AxisOrthoLine!=0){

    //print ("AxisOrthoLine Doesnt not Eq ZERO" +"\n");

    if($First_Second_Both_None>=0){
    //print ("First_Second_Both_None LESS then ZERO!" +"\n");

    //if($AxisOrthoLine==0){
    if($trigger_straitC==1){

    $FloatDirEpipol = DirectionFN($VecOnPlaneA[$First_Second_Both_None], $FoundEpipol);
    $FloatDirEpipolB= DirectionFN($VecOnPlaneB[$First_Second_Both_None], $FoundEpipol);
    if($AxisOrthoLine==0){
    //print ("AxisOrthoLine Eq ZERO!" +"\n");
    //print ("line ortho Direction same as CAM epipole");

    $lineEPointA = MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);

    $Xdirection = << 1.0,0.0,0.0>>;
    $Intersect_LineB_a = FloatToVec (lineIntersection($PointsA[$First_Second_Both_None], $Xdirection, $lineEPointA,(DirectionFN( $CamPos_A,$lineEPointA)) ));

    $Point3DA = $Intersect_LineB_a;
    $Point3DAM = {($Point3DA[0]*-1), $Point3DA[1],$Point3DA[2]};

    }


    if($First_Second_Both_None==1){
    //print ("First_Second_Both_None Eq ONE! " +"\n");
    $PairInt={0,1};

    }else{ $PairInt={2,3};
    //print ("First_Second_Both_None NOT Eq ONE! " +"\n");
    }

    $Intersect_BX= VecPtsToZMirrorPts($IntersectEnds_Ax);
    $PairVectors[0]=FloatToVec(FloatPointsToCamPlane($IntersectEnds_Ax[0]));
    $PairVectors[1]= FloatToVec(FloatPointsToCamPlane($Intersect_BX[0]));
    $PairVectors[2]=FloatToVec(FloatPointsToCamPlane($IntersectEnds_Ax[1]));
    $PairVectors[3]= FloatToVec(FloatPointsToCamPlane($Intersect_BX[1]));
    $EpipolXLine = DirectionFN( $MidEpipolPosFCam, $PairVectors[$PairInt[0]]) ;

    $Intersect_LineB_a = FloatToVec (lineIntersection($VecOnPlaneA[$First_Second_Both_None], $FloatDirEpipol, $MidEpipolPosFCam,$EpipolXLine));
    //Loc $Intersect_LineB_a;
    $Intersect_LineB_b = FloatToVec (lineIntersection($VecOnPlaneB[$First_Second_Both_None], $FloatDirEpipolB, $MidEpipolPosFCam,$EpipolXLine));
    //Loc $Intersect_LineB_b;

    clear $PositionsZ_A;
    clear $PositionsZ_B;
    clear $VecPtsMirrorEnds_A;
    clear $VecPtsMirrorEnds_B;
    clear $VecPtsMirrorA;
    clear $VecPtsMirrorB;
    $PositionsZ_A[0] =  $VecOnPlaneA[$First_Second_Both_None];
    $PositionsZ_A[1]= FloatToVec (MidPoint($VecOnPlaneA[$First_Second_Both_None],$Intersect_LineB_a));
    $PositionsZ_A[2] =  $Intersect_LineB_a;
    $PositionsZ_B[0] =  $VecOnPlaneB[$First_Second_Both_None];
    $PositionsZ_B[1]= FloatToVec (MidPoint($VecOnPlaneB[$First_Second_Both_None], $Intersect_LineB_b));
    $PositionsZ_B[2] =  $Intersect_LineB_b;
    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
    }
    }
    }
    }
    }


    if($trigger_straitC!=1){
    $iiz = 0;

    for ($eachVecx in  $VecPtsMirrorA)
    {
    $Intersect_A[`size($Intersect_A)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_B[$iiz], $CamPos_M, $VecPtsMirrorA[$iiz]));
    $iiz++;
    }

    $ThefirstCurve = VecArrayToCurve($Intersect_A);
    modifySelectedCurves smooth $Smooth 0;
    $Intersect_B= VecPtsToZMirrorPts($Intersect_A);
    $ThefirstCurvei = VecArrayToCurve($Intersect_B);
    modifySelectedCurves smooth $Smooth 0;
    $EndrEndsa = VecCurveEnds({$ThefirstCurvei});
    $EndsAtZero = isCurveEndAtZY($EndrEndsa);
    $STEPSZ = 200;
    $curvesZi = $ThefirstCurve;
    $curvesZi = CurvatureIsCircleData($curvesZi, $STEPSZ, $angleZi, $TotalDegii, $LowX, $TrackCi, $anglesMade);
    delete $ThefirstCurve;
    $ThefirstCurve = $curvesZi;
    $curvesZii = $ThefirstCurvei;
    $curvesZii = CurvatureIsCircleData($curvesZii, $STEPSZ, $angleZi, $TotalDegii, $LowX, $TrackCi, $anglesMade);
    delete $ThefirstCurvei;
    $ThefirstCurvei = $curvesZii;

    if($EndsAtZero>0){
    sets -include ZEdgeCurvesSet ({$ThefirstCurvei,$ThefirstCurve});
    }

    }
    delete $VanishingPointsLinesTempGuides;
    clear $VanishingPointsLinesTempGuides;
    delete $CurveItemZai $CurveItemZbi;
    clear $StereoCurveZ;
    $addNumbersA =0;
    clear $VanishingPointGlobal;

    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $ThefirstCurve;
    ResetTranslation({$ThefirstCurve});
    CurveIndexVecTracking({$ThefirstCurve});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ThefirstCurve;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $ThefirstCurvei;
    ResetTranslation({$ThefirstCurvei});
    CurveIndexVecTracking({$ThefirstCurvei});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ThefirstCurvei;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    }










    proc int isCurveEndAtZY(vector $EndVectors[]){
    $Number = 0;
    for($eachVec in $EndVectors){
    $ThreeFs = $eachVec;
    if($ThreeFs[0] == 0){
    $Number++;
    }}
    return $Number;
    }



    global int $ifSingleCurve;
    $ifSingleCurve =0;
    createDisplayLayer -name "VanishingPointsLines"  -empty;
    setAttr VanishingPointsLines.visibility 1; setAttr VanishingPointsLines.displayType 0; setAttr VanishingPointsLines.color 0;

    ////////////////////////////////////////////////


    /*
    $OneCurve = `ls -sl`;
    $OneCurveS = $OneCurve[0];
    $TFNS = 1;
    $CurveNS = IScircleTF($OneCurveS,$TFNS);
    print $TFNS;
    if($TFNS==1){
    $NewOneCurveS = EllipesSketchFitting($CurveNS, $EmptyVectorArrayA);
    }else{  $NewOneCurveS = $OneCurveS;}

    $NewArrayAEllipZ = NewVecOrderEllipZ($NewOneCurveS, $EmptyVectorArrayA, $MidEpipolPosFCam);
    $OneCurve = `ls -sl`;
    $NewOneCurveSB = EllipesSketchFitting($OneCurve[0], $EmptyVectorArrayB);
    $NewArrayBEllipZ = NewVecOrderEllipZ($NewOneCurveSB, $EmptyVectorArrayB, $MidEpipolPosFCam);
    $StereoCircle = Eval3DCircleStereo( $NewArrayBEllipZ  , $EmptyVectorArrayB ,  $NewArrayAEllipZ , $EmptyVectorArrayA );

    // print $EmptyVectorArrayA;
    $IndexTrackE = CreateIntIndex(`size($EmptyVectorArrayA)`);
    //select -r $NewOneCurveS;
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);
    // Loc $MidEpipolPosFCam;

    $EllipesPos_A = `xform -q -ws -t $NewOneCurveS`;
    $Dir_VecMAIN =  DirectionFN($MidEpipolPosFCam, $EllipesPos_A);

    $TwoZeroOne = {0,1};
    clear $allAngiX; clear $TFmostRArray;
    $threeVecs[0] = FloatToVec($MidEpipolPosFCam);
    $threeVecs[1] = FloatToVec($EllipesPos_A);

    for($EachVector in $EmptyVectorArrayA){
    $DIff = FindDirectionDiff($Dir_VecMAIN, $MidEpipolPosFCam, $EachVector);
    if($DIff!= 0){
    $allAngiX[`size($allAngiX)`]=  VAnglesofThreeVec($MidEpipolPosFCam, $EllipesPos_A, $EachVector);
    $threeVecs[2] = $EachVector;
    $TFmostRArray[`size($TFmostRArray)`] = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);
    }else{ $allAngiX[`size($allAngiX)`]= 0;  $TFmostRArray[`size($TFmostRArray)`] =0;}
    }

    clear $LargestIntR_KEY;
    clear $LargestIntL_KEY;
    clear $AllAngiX_LEFT;
    clear $AllAngiX_RIGHT;
    $COUNT_Nlr = 0;
    for($EachIntarray in $TFmostRArray){
    if($EachIntarray==1){
    $AllAngiX_RIGHT[`size($AllAngiX_RIGHT)`]= $allAngiX[$COUNT_Nlr];
    $LargestIntR_KEY[`size($LargestIntR_KEY)`]=$COUNT_Nlr;
    }
    if($EachIntarray==0){
    $AllAngiX_LEFT[`size($AllAngiX_LEFT)`]= $allAngiX[$COUNT_Nlr];
    $LargestIntL_KEY[`size($LargestIntL_KEY)`]=$COUNT_Nlr;
    }
    $COUNT_Nlr++;
    }


    $LargestIntR = SortNumbersIntIndex($AllAngiX_RIGHT);
    $LargestIntR = ReverseIntArray($LargestIntR);
    // Loc $EmptyVectorArrayA[$LargestIntR_KEY[$LargestIntR[0]]];
    $LargestIntL = SortNumbersIntIndex($AllAngiX_LEFT);
    $LargestIntL = ReverseIntArray($LargestIntL);
    // Loc $EmptyVectorArrayA[$LargestIntL_KEY[$LargestIntL[0]]];
    print $LargestIntR_KEY[$LargestIntR[0]];
    print $LargestIntL_KEY[$LargestIntL[0]];
    // test int $NewStartInt = $LargestIntL_KEY[$LargestIntL[0]];
    //  $IndexTrackE
    $SizeE = `size($EmptyVectorArrayA)`;
    $Add = 0;
    for($EachIntX in $IndexTrackE){
    $NewArrayIntX[`size($NewArrayIntX)`] = fmod(($NewStartInt+$Add),$SizeE);
    $Add++;
    }

    // just to see the result - $NewArrayIntX = ReverseIntArray($NewArrayIntX);

    $NewArrayAEllipZ = NewVecOrderEllipZ($NewOneCurveS, $EmptyVectorArrayA, $MidEpipolPosFCam);
    $OneCurve = `ls -sl`;
    $NewOneCurveSB = EllipesSketchFitting($OneCurve[0], $EmptyVectorArrayB);
    $NewArrayBEllipZ = NewVecOrderEllipZ($NewOneCurveSB, $EmptyVectorArrayB, $MidEpipolPosFCam);
    $StereoCircle = Eval3DCircleStereo( $NewArrayBEllipZ  , $EmptyVectorArrayB ,  $NewArrayAEllipZ , $EmptyVectorArrayA );



    */








    proc float  FindDirectionDiff(vector $Line_Y_zeroMain, vector $VecCurEndsA, vector $VecCurEndsB){
    $Dir_VecA =  DirectionFN($VecCurEndsA,$VecCurEndsB);
    $VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    return $AdditR;
    }

    global int $ForceOrthoOFFON;
    $ForceOrthoOFFON = 0;


    proc string [] ForceOrtho(string  $CurveItemAX[]){

    // string  $CurveItemAX[] =`ls -sl`;
    global string $StereoCurveZ[];
    global int $addNumbersA;
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;

    //string  $CurveItemAX[] =`ls -sl`;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemAX[0];

    /////////////////////
    $Positions = VecCurveEps($CurveItemAX[0]);
    $TempCrv = VecArrayToCurve($Positions);
    delete $CurveItemAX[0];
    $VecCurEnds = VecCurveEnds({$TempCrv});
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEndsOLD = $queryLocCurveEnds;
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );

    if(`size($queryLocCurveEnds)` >= 2){

    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $distancesEachToCurveB = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);

    $ReducedIndexA = floatArrayCountDuplicates($distancesEachToCurve);
    $ReducedIndexB = floatArrayCountDuplicates($distancesEachToCurveB);
    for($eachInt in $ReducedIndexA){
    $distAz[`size($distAz)`]= $distancesEachToCurve[$eachInt];
    }
    for($eachInt in $ReducedIndexB){
    $distBz[`size($distBz)`]= $distancesEachToCurveB[$eachInt];
    }

    //clear $NearestInt;
    //clear $NearestIntB;
    $NearestInt = SortNumbersIntIndex($distAz);
    $NearestIntB = SortNumbersIntIndex($distBz);

    $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];


    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$ReducedIndexA[$NearestInt[0]]];
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$ReducedIndexB[$NearestIntB[0]]];
    $NearestInt[0] =  $NewIntIndexAA;
    $NearestIntB[0] = $NewIntIndexBB;


    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];
    $LocA = $queryLocCurveEnds[$NearestInt[0]];
    $LocB = $queryLocCurveEnds[$NearestIntB[0]];

    //Loc $LocCurveEndsVec[$NearestInt[0]];
    //Loc $LocCurveEndsVec[$NearestIntB[0]];

    clear $EndSnapAndEndProject;
    $Loc_AorB = "";
    //////////////////////////////////////////
    if($NdistA<$NdistB){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    $Loc_AorB="B";
    }else{
    $Loc_AorB="A";
    $LocName =$LocB;
    $NearestIndex=$NearestIntB[0];
    $NearEndZ = $VecCurEnds[1];
    $endNotNearZ[0] = $VecCurEnds[0];}
    //////////////////////
    // very very rare event
    if($NdistA==$NdistB){
    $Loc_AorB="A";
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    }
    /////////////////////
    if($NearestInt[0]==$NearestIntB[0]){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    }
    //////////////////////////////////////////
    $newNames = stringArrayToString($queryLocCurveEnds, " ");
    $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    $AllarrayCurvesNear = stringToStringArray($newNamesResultAX, " ");
    $NewFoundLocs[0]  = $AllarrayCurvesNear[$NearestIndex];
    $arrayCurvesNear[0] = $queryLocCurveEnds[$NearestIndex];
    /*
    // needed for later for edgeCurves and dynamic local axis plane mirroring
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    */


    $LocOnPlaneVec = PointArray($arrayCurvesNear );
    $Loc3D_Vec = PointArray($NewFoundLocs );
    $ALLLoc3D_VecAB = PointArray($AllarrayCurvesNear);

    if($Loc_AorB == "A"){
    $ReducedIndexXAB = $ReducedIndexA;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexA,$ALLLoc3D_VecAB);
    }
    if($Loc_AorB == "B"){
    $ReducedIndexXAB = $ReducedIndexB;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexB,$ALLLoc3D_VecAB);
    }

    $ALLLoc3D_Vec = $ReducedVecAB;

    $MovedEndPointPlane = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    $CRV_ENDSi[0]= $LocOnPlaneVec[0];
    $CRV_ENDSi[1]= $MovedEndPointPlane[0];
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);
    $MidCurveA = MidPoint($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
    $EpipolD = $DDirEpipolXYZ;
    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);
    $XYZdirectL[0] = << 1,0,0>>;
    $XYZdirectL[1] = << 0,1,0>>;
    $XYZdirectL[2] = << 0,0,1>>;
    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    $AxisOrthoLineA = $AxisOrthoLine;
    // 3d start point $Loc3D_Vec[0]  free Endpoint of plane curve $MovedEndPointPlane[0]
    $Dir_CamRay =  DirectionFN($MovedEndPointPlane[0],$CamPos_A);

    // lineIntersection NOTE arguments are in this order: Point then Line ...Point then Line
    $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);

    $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);

    $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    $XYZi  = $PointN_LineC;
    $XYZadd  = $PointN_LineC;

    $XYZi[0] = $XYZadd[0]+$XYZadd[1];
    $XYZi[1] = $XYZadd[1]+$XYZadd[2];
    $XYZi[2] = $XYZadd[0]+$XYZadd[2];
    $iVc = 0;
    clear $TrackFoundN;
    if($AxisOrthoLineA ==2){
    $TwoPointsi[0] = 0;
    }
    if($AxisOrthoLineA ==1){
    $TwoPointsi[0] = 2;
    }
    if($AxisOrthoLineA ==0){
    $TwoPointsi[0] = 1;
    }
    $AXIS = $AxisOrthoLineA;

    clear $ALLlikeness;
    $i = 0;
    $Dist_3DNear = (($Dist_3D/3.0)*2.0);

    for ($each in $ALLLoc3D_Vec){

    $One = $ALLLoc3D_Vec[$i];
    $XY[0] = $Xx  = $One.x;
    $XY[1] = $Yy  = $One.y;
    $XY[2] = $Zz  = $One.z;

    if( $ReducedIndexXAB[$iVc]!= $NearestIndex ){

    $TriggerPoints=0;
    if( (equivalentTol($XYZadd[0], $Xx,  0.01) )==1){
    $All_X[$i] = $Xx;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[1], $Yy,  0.01) )==1){
    $All_Y[$i] = $Yy;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[2], $Zz,  0.01) )==1){
    $All_Z[$i] = $Zz;
    $TriggerPoints++;
    }

    if( $TriggerPoints<2){
    $diffXYZ = `abs ($XY[$AXIS] - $XYZadd[$AXIS])`;
    if(($diffXYZ< $Dist_3DNear)&&($diffXYZ!=0)){
    $All_ZYX[`size($All_ZYX)`] =$XY[$AXIS];
    $All_ZYXDiff[`size($All_ZYXDiff)`] = $diffXYZ;
    }
    }


    if( $TriggerPoints==2){

    $ALLlikeness[`size($ALLlikeness)`] = $ReducedIndexXAB[$i];
    }
    }
    $i++;
    $iVc++;
    }



    if(`size($All_ZYXDiff)`> 0){
    $SortedForce = SortNumbersIntIndex($All_ZYXDiff);
    $newOrderFloat = $All_ZYX[$SortedForce[0]];

    }


    if(`size($ALLlikeness)`> 0){


    select -cl;
    for($eachIn in $ALLlikeness){
    select -add $AllarrayCurvesNear[$eachIn];
    PAUSE;
    }


    clear $NearPointsXYZ;
    $iVc =0;
    for($eachIn in $ALLlikeness){
    if( $iVc!= $NearestIndex ){
    $NearPointsXYZ[`size($NearPointsXYZ )`] =  $ALLLoc3D_VecAB[$eachIn];
    }
    $iVc++;
    }


    $distTo3DCurveEnd = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    $Sorted = SortNumbersIntIndex($distTo3DCurveEnd);
    $NearPointsXYZ = NewVecOrderWithINTKey($Sorted,$NearPointsXYZ);

    clear $SdistTo3DCurveEnd;
    for($eachIn in $Sorted){
    $SdistTo3DCurveEnd[`size($SdistTo3DCurveEnd)`] = $distTo3DCurveEnd[$eachIn];
    }

    $ReducedIndex = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    $ReducedVec = NewVecOrderWithINTKey($ReducedIndex,$NearPointsXYZ);

    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    // if($AdditRi = 0.0){ then snap to point IF the direction is the same

    $OntheSameLine = 0;
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $OntheSameLine =1;
    }


    $CountN = 0;
    for($eachVec in $ReducedVec){


    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $eachVec);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $PointN_LineXYZ = $eachVec;
    print " on same Line ";
    }else{

    $PointN_LineXYZ  = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $eachVec);

    }

    if( (distance2Pts($PointN_LineXYZ, $PointN_LineC))>0.001){
    $LocsV[`size($LocsV)`] = `Loc $PointN_LineXYZ`;
    $CurvesV[`size($CurvesV)`] = curve2points($eachVec, $PointN_LineXYZ);
    PAUSE;
    }

    if($CountN==0){
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapN = $eachVec;
    $SnapPlaceN = $PointN_LineXYZ;
    }

    if($CountN!=0){
    print  $DistSnap;
    if((distance2Pts($PointN_LineXYZ, $PointN_LineC))<  $DistSnap){
    $SnapN = $eachVec;
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapPlaceN = $PointN_LineXYZ;

    }
    }
    $CountN++;
    }



    $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);

    delete $CurvesV;
    delete $LocsV;

    //$EulerAngleA  = EulerAngB($DirLineSnapXYZ,$LineDirect_3D);
    if(($EulerAngleA[3] >85)&&($EulerAngleA[3]<95)){



    $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    if($Dist_3DSnap<($Dist_3D/2.0)){
    cycleBackgroundColor;
    PAUSE;
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    $AddInt = $AdditR;
    if($AddInt == 0){
    $PointN_LineC = $SnapPlaceN;
    PAUSE; PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }else{

    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $FPointN_LineC =  $PointN_LineC;
    $FPointN_LineC[$AXIS] = $newOrderFloat;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }


    }

    }else{
    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }

    //}

    // $LocsV[`size($LocsV)`] = `Loc $First3dIntersect`;
    // $LocsV[`size($LocsV)`] = `Loc $PointN_LineC`;
    // $CurvesV[`size($CurvesV)`] = curve2points($First3dIntersect, $PointN_LineC);

    $Points3DPair_And_2DPair[0]= $Loc3D_Vec[0];
    $Points3DPair_And_2DPair[1]= $PointN_LineC;
    $Points3DPair_And_2DPair[2]= $LocOnPlaneVec[0];
    $Points3DPair_And_2DPair[3]= $NewPlanePoint;

    delete $TempCrv;
    $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 10 -d 3 -tol 0.05 $CurvesVi;

    $Crv_Pts = VecCurveEps($CurvesVi );
    $MirrorAcrossPlaneVecs = VecMultMatrixMirror($Crv_Pts);
    $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    //delete $CurvesV;
    //delete  $LocsV;
    clear $StereoCurveZ;
    $BothCurves[0] = $CurvesVi;
    $BothCurves[1] = $TheSecondCurve;
    $StereoCurveZ = $BothCurves;
    $addNumbersA =-3;
    ResetTranslation($BothCurves);
    CurveIndexVecTracking($BothCurves);
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $BothCurves;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    clear $StereoCurveZ;
    }
    return $BothCurves;
    }

    //////////////////////////////////////////////////////////

    proc int [] floatArrayCountDuplicates(float $listX[]){
    $list = $listX;
    $index = 0;
    $X = 0;
    $Xi = 0;
    $C = 0;
    $result = $list;
    for ($item in $list) {
    $NumberE[$X] = floatArrayCount($item, $result);
    if (1 == $NumberE[$X]) {
    $NoneDup[`size($NoneDup)`] = $Xi;
    }else{
    if (1 < $NumberE[$X]) {
    floatArrayRemoveAtIndex($X, $result);
    $X--;
    }
    }
    $Xi++;
    $X++;	}
    return $NoneDup;
    }

    //////////////////////////////////////////////////////

    proc int floatArrayCount(float $item, float $list[]){
    $result = 0;
    for ($listItem in $list) {
    if ($item == $listItem) $result++;	}
    return $result;
    }

    proc floatArrayRemoveToIndex(int $ix, float $floatArray[]){
    $ixX = 0;
    while($ixX<$ix){
    floatArrayRemoveAtIndex(0, $floatArray);
    $ixX++;
    }
    }



    proc int floatArrayRemoveAtIndex( int $index, float $list[] ){
    $len = size( $list );

    if( $index > $len  || $index < 0 ){
    return( false );
    }

    for( $i = 0; $i < $index; $i++ ){
    $result[$i] = $list[$i];
    }

    for( ; $i < $len - 1; $i++ ){
    $result[$i] = $list[$i + 1];
    }
    $list = $result;
    return( true );
    }




    ////////////////////////////////

    /*

    if(($XY[$TwoPointsi[0]] != $XYZadd[$TwoPointsi[0]])){
    print (" !!!yes TRIGGER two HERE!!"+"\n");

    }


    if( (equivalentTol($XYZadd[0], $Xx,  0.1) )==1){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }
    if( (equivalentTol($XYZadd[1], $Yy,  0.1) )==1){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }
    if( (equivalentTol($XYZadd[2], $Zz,  0.1) )==1){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }


    if (( $XYZadd[0] ==$Xx)&&( $XYZadd[1] ==$Yy)){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }

    if (( $XYZadd[1] ==$Yy)&&( $XYZadd[2] ==$Zz)){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }

    if (( $XYZadd[2] ==$Zz)&&( $XYZadd[0] ==$Xx)){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }

    }
    }
    $iVc++;
    }
    */

    //////////////////////////////////

    /*

    $XYZi  = $PointN_LineC;
    $XYZadd  = $PointN_LineC;
    $XYZi[0] = $XYZadd[0]+$XYZadd[1];
    $XYZi[1] = $XYZadd[1]+$XYZadd[2];
    $XYZi[2] = $XYZadd[0]+$XYZadd[2];
    $iVc = 0;
    clear $TrackFoundN;
    if($AxisOrthoLineA ==2){
    $TwoPointsi[0] = 0;
    }
    if($AxisOrthoLineA ==1){
    $TwoPointsi[0] = 2;
    }
    if($AxisOrthoLineA ==0){
    $TwoPointsi[0] = 1;
    }
    clear $ALLlikeness;

    for ($each in $ALLLoc3D_Vec){


    $One = $ALLLoc3D_Vec[$iVc];
    $XY[0] = $Xx  = $One.x;
    $XY[1] = $Yy  = $One.y;
    $XY[2] = $Zz  = $One.z;


    if  (( $XYZadd[0]!=0 )&&($Xx!=0)){
    if  (( $XYZadd[1]!=0 )&&($Yy!=0)){
    if  (( $XYZadd[2]!=0 )&&($Zz!=0)){
    if($iVc==0){
    $Xd =  ($XYZi[0] - ($Xx )) ;
    $Yd =  ($XYZi[1] - ($Yy )) ;
    $Zd =  ($XYZi[2] - ($Zz)) ;
    }

    if( $iVc!= $NearestIndex ){
    if(($XY[$TwoPointsi[0]] != $XYZadd[$TwoPointsi[0]])){



    //  if  ( (equivalentTol($XY[0], $XYZadd[0],  0.01) )==1 ){

    if (((equivalentTol( $XY[0], $XYZadd[0],  0.00001 ) )!=1 )  || ((equivalentTol($XY[1], $XYZadd[1],  0.00001))!=1) || ((equivalentTol($XY[2], $XYZadd[2],  0.00001))!=1 )){

    //equivalentTol($XY[0], $XYZadd[0],  0.01) equivalentTol($XY[1], $XYZadd[1],  0.01)
    //  if(  ($XY[0] == $XYZadd[0] )   ||   ($XY[1] == $XYZadd[1] )  ||   ($XY[2] == $XYZadd[2] )   ){
    //  if(  ($XY[0] == $XYZadd[0] )   ||   ($XY[1] == $XYZadd[1] )  ||   ($XY[2] == $XYZadd[2] )   ){
    print  " HERE PASSED ";
    if($iVc==13){
    print  " HERE PASSED ";
    }
    if($iVc==0){
    $Xd =  ($XYZi[0] - ($Xx )) ;
    $Yd =  ($XYZi[1] - ($Yy )) ;
    $Zd =  ($XYZi[2] - ($Zz)) ;
    $Dx =  `sqrt ($XYZi[0] + $Xx)`;
    $Dy =  `sqrt ($XYZi[1] + $Yy)`;
    $Dz =  `sqrt ($XYZi[2] + $Zz)`;
    }


    $ALLlikeness[`size($ALLlikeness)`] = $iVc;

    if( $iVc!= 0 ){

    if($Xd > ( `abs($XYZi[0] - ($Xx))` )){
    $Xd = $Xx;
    $TrackN[0]= $iVc;
    }
    if($Xd == ( `abs($XYZi[0] - ($Xx))` )){
    if(`sqrt ($XYZi[0] + $Xx)`< $Dx){
    $TrackN[0]= $iVc;
    $Dx =  `sqrt ($XYZi[0] + $Xx)`;
    }
    }

    if($Yd > ( `abs($XYZi[1] - ($Yy))` )){
    $Yd = $Yy;
    $TrackN[1]= $iVc;}

    if($Yd == ( `abs($XYZi[1] - ($Yy))` )){
    if(`sqrt ($XYZi[1] + $Yy)`< $Dy){
    $TrackN[1]= $iVc;
    $Dy =  `sqrt ($XYZi[1] + $Yy)`;
    }
    }

    if($Zd > ( `abs($XYZi[2] - ($Zz))` )){
    $Zd = $Zz;
    $TrackN[2]= $iVc;}

    if($Zd == ( `abs($XYZi[2] - ($Zz))` )){
    if(`sqrt ($XYZi[2] + $Zz)`< $Dz){
    $TrackN[2]= $iVc;
    $Dz =  `sqrt ($XYZi[2] + $Zz)`;
    }
    }

    }
    }



    ///////////////

    }

    }
    }
    }



    }
    $iVc++;
    }



    */



    //print $ALLlikeness;


    //print $ALLlikeness;
    //print $TrackN;
    //print $NearestIndex


    /*
    if($Xd >= ( ($XYZi[0] - ($Xx+$Yy)) )){
    $Xd = $Xx;
    $TrackN[0]= $iVc;
    if($iVc==13){
    print  " HERE1 ";
    }

    }


    if($Yd >= ( ($XYZi[1] - ($Yy+$Zz)) )){
    $Yd = $Yy;
    $TrackN[1]= $iVc;

    if($iVc==13){
    print  " HERE2 ";
    }
    }


    if($Zd >= ( ($XYZi[2] - ($Xx+$Zz)) )){
    $Zd = $Zz;
    $TrackN[2]= $iVc;
    if($iVc==13){
    print  " HERE3 ";
    }




    clear $NearPointsXYZ;
    for($eachIn in $ALLlikeness){
    $NearPointsXYZ[`size($NearPointsXYZ )`]=  $ALLLoc3D_Vec[$eachIn];

    }

    for($eachIn in $ALLlikeness){
    select -add $AllarrayCurvesNear[$eachIn];

    }
    */










    proc vector [] VecMultMatrixMirror(vector $pointZ[]){

    matrix $m2[4][4]= <<	-1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0>>;

    $MatrixB = `MatrixToFloat($m2)`;
    for($eachVec in $pointZ){
    $FLoatPointA[`size($FLoatPointA)`] = FloatToVec(pointMatrixMult( $eachVec, $MatrixB ));
    }
    return $FLoatPointA;
    }

    ////////////////////////////////

    ////////////////////////////////


    proc vector [] MoveVectors(vector $Pos_A, vector $VecLoc, vector $Crv_Pts[]){

    $DirLine = DirectionFN( $VecLoc, $Pos_A);
    $DistToPoint = distance2Pts($Pos_A, $VecLoc);

    // DISTANCE TIMES DIRECTION VEC PLUS POINT VECTOR To translate
    clear $TranstatedVecs;
    for($eachVector in $Crv_Pts){
    $TranstatedVecs[`size($TranstatedVecs)`] = ($eachVector+($DistToPoint*$DirLine));
    }
    return $TranstatedVecs;
    }

    ////////////////////////////////

    /*
    // playing around  used at the end of new force othro script
    $PointN_Line = ClosestPoint2LineVec($Dir_CamRay, $MovedEndPointPlane[0], $Loc3D_Vec[0]);
    $LocsV[`size($LocsV)`] = `Loc $PointN_Line`;
    $CurvesV[`size($CurvesV)`] = curve2points($MovedEndPointPlane[0], (($Dir_CamRay*$Dist2D3D)+$MovedEndPointPlane[0]));
    $CurvesV[`size($CurvesV)`] = curve2points($Loc3D_Vec[0], $PointN_Line);
    $PointN_LineB = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $PointN_Line);
    $LocsV[`size($LocsV)`] = `Loc $PointN_LineB`;
    $CurvesV[`size($CurvesV)`] = curve2points($PointN_LineB, $PointN_Line);
    */


    proc string [] VanishingCurves( string  $CurveItemA[]){

    //     string  $CurveItemA[] =`ls -sl`;
    global string $VanishingPointsLinesTempGuides[];
    global int $ifSingleCurve;
    //float $SnapD = 0.013;
    $SnapD = 0.003;
    global vector $TempVectorsCrv[];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemA[0];

    /////////////////////
    if(size($TempVectorsCrv)>0){
    clear $TempVectorsCrv;}
    $Positions = VecCurveCvs($CurveItemA[0]);
    $TempCrv = VecArrayToCurve($Positions);

    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $TempCrv;
    $PositionsZ_Ax = VecCurveEps($TempCrv);

    $ZYplaneMatrix[0] = <<0, 0, 0>>;
    $ZYplaneMatrix[1] = <<0, 1, 0>>;
    $ZYplaneMatrix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;

    $TempVectorsCrv  = LineIntersectPlaneCam( $PositionsZ_Ax, $CamPos1, $ZYplaneMatrix);
    delete $TempCrv;
    ////////////////////

    $Pi = 3.1415926535;
    $pi = 3.1415926535;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $CamerasDirectionVector = $CamerasDirectionVectorNormal;
    $MultDirForWard = multiplyFloat(-1, $CamerasDirectionVector);
    $MultDirCam = multiplyFloat(-3, $CamerasDirectionVector);
    $FloatDirectionCamNormalA = AddFloats($CamPos1, $MultDirCam);
    $DirectionVectorXn = {-2,0,0};
    $DirectionVectorX = {2,0,0};
    $DirectionVectorY = {0,-2,0};
    $DirectionVectorYn = {0,2,0};
    $DirectionVectorZn = {0,0,-2};
    $DirectionVectorZ = {0,0,2};
    $VecDirection_A_XYZ[0] = <<-2,0,0>>;
    $VecDirection_A_XYZ[1] = <<2,0,0>>;
    $VecDirection_A_XYZ[2] = <<0,2,0>>;
    $VecDirection_A_XYZ[3] = <<0,-2,0>>;
    $VecDirection_A_XYZ[4] = <<0,0,-2>>;
    $VecDirection_A_XYZ[5] = <<0,0,2>>;
    $VecDirectionXYZ[0] = <<-1,0,0>>;
    $VecDirectionXYZ[1] = <<1,0,0>>;
    $VecDirectionXYZ[2] = <<0,1,0>>;
    $VecDirectionXYZ[3] = <<0,-1,0>>;
    $VecDirectionXYZ[4] = <<0,0,-1>>;
    $VecDirectionXYZ[5] = <<0,0,1>>;
    $FloatPointDirectionXn = AddFloats($CamPos1, $DirectionVectorXn);
    $FloatPointDirectionX = AddFloats($CamPos1, $DirectionVectorX);
    $FloatPointDirectionY = AddFloats($CamPos1, $DirectionVectorY);
    $FloatPointDirectionYn = AddFloats($CamPos1, $DirectionVectorYn);
    $FloatPointDirectionZn = AddFloats($CamPos1, $DirectionVectorZn);
    $FloatPointDirectionZ = AddFloats($CamPos1, $DirectionVectorZ);
    clear $VecXYZs;
    $VecXYZs[0] = FloatToVec($FloatPointDirectionXn);
    $VecXYZs[1] = FloatToVec($FloatPointDirectionX);
    $VecXYZs[2] = FloatToVec($FloatPointDirectionY);
    $VecXYZs[3] = FloatToVec($FloatPointDirectionYn);
    $VecXYZs[4] = FloatToVec($FloatPointDirectionZn);
    $VecXYZs[5] = FloatToVec($FloatPointDirectionZ);
    $VecXYZsOnPlane = VecPointsToCameraPlane($VecXYZs);
    $AverageVecXYZsOnP = AverageVectorPoint($VecXYZsOnPlane);
    $DirectionsZ = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    $FloatDirxyz[0] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[0]));
    $FloatDirxyz[1] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[1]));
    $FloatDirxyz[2] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[3]));
    $FloatDirxyz[3] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[2]));
    $FloatDirxyz[4] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[4]));
    $FloatDirxyz[5] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[5]));
    $Alll = "";
    clear $AllStrings $AnglesAll ;
    for ($eachOrthD in $VecDirectionXYZ){
    $EulerAngleA = EulerAngB($eachOrthD, $CamerasDirectionVector);
    $AnglesAll[`size($AnglesAll)`]= $EulerAngleA[3];
    $stringFloat = FloatArrayToStringArray($EulerAngleA);
    $Alll  = stringArrayToString($stringFloat, " ");
    $AllStrings[`size($AllStrings)`]= $Alll;
    }
    clear $EmptyIndxNewOrder;
    $indexAx = CreateIntIndex(6);
    $stringIndTr = IntArrayToStringArray($indexAx);
    $ANgnew = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
    $EmptyIndxNewOrder = ReverseStringArray($EmptyIndxNewOrder);
    $BestThree = {$EmptyIndxNewOrder[0], $EmptyIndxNewOrder[1], $EmptyIndxNewOrder[2]};
    $BestThree = ReverseStringArray($BestThree);
    $BestThree = stringArrayRemoveDuplicates ($BestThree);
    $indexAxNew = ArrayToIntList( $BestThree);
    $VecCurEnds = VecCurveEnds($CurveItemA);

    $LengCRV_a = `arclen $CurveItemA`;
    $DistEndsi = distance2Pts($VecCurEnds[0], $VecCurEnds[1]);
    $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);

    $AverageVecCurEndsP = AverageVectorPoint($VecCurEnds);
    $Count = 0;
    $CurvePsD = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
    size($EmptyIndxNewOrder);
    $DirectionsZ = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    clear $colori;
    $iiX = 0;
    for($eachDirection in $indexAxNew){
    if($eachDirection ==0 || $eachDirection ==1){$colori[`size($colori)`] = 13;}
    if($eachDirection ==3 || $eachDirection ==2){$colori[`size($colori)`] = 14;}
    if($eachDirection ==4 || $eachDirection ==5){$colori[`size($colori)`] = 6;}
    }
    clear $CurvesV;
    $Cindex = 0;
    for ($eachDii in $indexAxNew){
    $IndexZ = $indexAxNew[$Count];

    $FloatPointDirectionZniY  = AddFloats( $VecCurEnds[1], $VecDirection_A_XYZ[$IndexZ]);
    $VecXYZsOnPlaneiY = VecPointsToCameraPlane($FloatPointDirectionZniY);
    $CurveDirectionZiY =  DirectionF($VecCurEnds[1],  $VecXYZsOnPlaneiY[0]);
    $FloatPointDirectionZniiY = AddFloats( $VecCurEnds[0], $VecDirection_A_XYZ[$IndexZ]);
    $VecXYZsOnPlaneiiY = VecPointsToCameraPlane($FloatPointDirectionZniiY);
    $CurveDirectionZiiY =  DirectionF($VecCurEnds[0],  $VecXYZsOnPlaneiiY[0]);
    $locsAi = lineIntersection($VecCurEnds[1], $CurveDirectionZiY, $VecCurEnds[0],  $CurveDirectionZiiY);

    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[0], $locsAi);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], $colori[$Cindex]);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[1], $locsAi);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], $colori[$Cindex]);
    editDisplayLayerMembers -noRecurse VanishingPointsLines $CurvesV;
    $Cindex++;
    $Count++;
    }

    $ifSingleCurve = 0;
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);

    DirectionFN($MidEpipolPosFCam,$VecCurEnds[1]);
    DirectionFN($VecCurEnds[0],$VecCurEnds[1]);
    $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
    $Dir_VecA =   PositiveDirectionLine($VecCurEnds[0],$VecCurEnds[1]);
    $VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];


    $VecPtsMirrorEnds_A= VecPtsToZMirrorPts( $VecCurEnds);
    $triggerMiddle = 0;
    $VIntersectEnds_A[0] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[1], $CamPos_M, $VecPtsMirrorEnds_A[0]));
    $VIntersectEnds_A[1] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[0], $CamPos_M, $VecPtsMirrorEnds_A[1]));
    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
    $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
    $IntersectEnds_Ai =  FloatPointsToCamPlane($VIntersectEnds_A[0]);
    $IntersectEnds_Bi = FloatPointsToCamPlane($VIntersectEnds_A[1]);
    $CurveItemAa[0] = $CurveItemA[0];
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEndsOLD = queryLocOnLivePlaneBLayer();
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );



    if(`size($queryLocCurveEnds)` > 2){

    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $NearestInt = SortNumbersIntIndex($distancesEachToCurve);
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[0]];
    $distancesEachToCurveB = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    $NearestIntB = SortNumbersIntIndex($distancesEachToCurveB);
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$NearestIntB[0]];


    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];

    if(($NdistA<$SnapD)||($NdistB<$SnapD)){

    $iv = -1;
    $distsA = $NdistA;
    $distsB = $NdistB;
    for (  $i = 1; $i < 5; $i++) {
    if( $distsA < $distsB){
    $NdistA = $distancesEachToCurve[$NearestInt[$i]];
    if($iv==-1){
    $iv++;
    $StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[0]];}
    if (equivalentTol($NdistA, $distsA, 0.001) == 1){
    $StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[$i]];
    }
    }


    }

    //print $StringAllNearA;
    //print ("NdistA :" +$NearestInt[$i]+" "+$NdistA+"  NdistB :"+$NearestIntB[$i]+" "+$NdistB+"\n");

    $newNames = stringArrayToString( $StringAllNearA, " ");
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    $arrayCurvesNearA = stringToStringArray($newNamesResultC, " ");
    $CRV_index_number = 0;
    $CRc = 0;
    $CRcT = 0;
    for($eachCurve in $arrayCurvesNearA){
    if(`sets -im ZEdgeCurvesSet $eachCurve` ==1){
    $CRV_index_number = $CRc;
    $CRcT++;
    break;
    }
    $CRc++;
    }

    if($CRcT ==1){
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[$CRc]];
    }
    }

    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];

    $newNames = stringArrayToString($EmptyStringNewOrderA, " ");
    $newNamesResultAx = substituteAllString($newNames, "Plane", "");
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    $arrayCurvesNear = stringToStringArray($newNamesResultC, " ");
    $NearCurvesEnds[0] = $arrayCurvesNear[0];
    $NearCurvesEnds[1] = $arrayCurvesNear[1];

    $arrayCurvesNearA1 = stringToStringArray($newNamesResultAx, " ");

    $LocCurveEndsVec_3D = PointArray($arrayCurvesNearA1);


    $LoCz_3D = $LocCurveEndsVec_3D;

    /*
    $FloatDirCam[0] = FloatToVec (DirectionF($CamPos1, $VecXYZs[0]));
    $FloatDirCam[1] = FloatToVec (DirectionF($CamPos1, $VecXYZs[1]));
    $PointN_LineA = ClosestPoint2LineVec($LineDirect_3D, $VecCurEnds[0], $LocCurveEndsVec_3D[0]);
    $distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocCurveEndsVec_3D[0]);
    $distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocCurveEndsVec_3D[1]);
    $relativeDistanceA = ($Distance_A+$distToPlaneLoc[0])/2.0;
    $relativeDistanceB = ($Distance_B+$distToPlaneLoc[1])/2.0;
    */



    $TXI = << -1.0 , 1.0, 1.0>>;
    $LoCz_3D[2] = MultVec($LoCz_3D[0],$TXI);
    $LoCz_3D[3] = MultVec($LoCz_3D[1], $TXI);
    for($eachItemVEC in $LoCz_3D){
    $VanishingLOC[`size($VanishingLOC)`] = Loc($eachItemVEC);
    $SetCol = `setAttr ($VanishingLOC[size($VanishingLOC)-1]+".overrideColor ") 6 `;
    setAttr ( $VanishingLOC[size($VanishingLOC)-1]+".scale") 5.0 5.0 5.0;
    }

    appendStringArray($CurvesV, $VanishingLOC, size($VanishingLOC));
    //string $edgeZsetAB[] = `sets -q ZEdgeCurvesSet`;
    //select -r $edgeZsetAB;
    $edgeZsetA = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[0]`;
    $edgeZsetB = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[1]`;
    $COuntN = 0;
    for($eachVec in $LocCurveEndsVec_3D){
    $ThreepointVecs = $eachVec;
    if (equivalentTol($ThreepointVecs[0], 0.00, 0.001) == 1){
    $EDGEpoints[$COuntN]= 1;
    }else{$EDGEpoints[$COuntN]= 0;}
    $COuntN++;
    }
    $edgeZsetA =$EDGEpoints[0];
    $edgeZsetB =$EDGEpoints[1];


    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    if(($NearCurvesEnds[0] == $NearCurvesEnds[1])&&( ($edgeZsetA+$edgeZsetB) ==2)){

    if($NdistA<$NdistB){
    $edgeZsetA =1;
    $edgeZsetB =0;
    }
    if($NdistA>$NdistB){
    $edgeZsetA =0;
    $edgeZsetB =1;
    }
    if($edgeZsetA==0){$NdistA=100;}
    if($edgeZsetB==0){$NdistB=100;}

    }
    }

    if(($NdistA>$SnapD)&&($NdistB>$SnapD)){
    $edgeZsetA =0;
    $edgeZsetB =0;
    }


    }



    if(($edgeZsetA==1)&&($NdistA<$SnapD)){
    $pointNearEdgeCurve[0]= 1;
    }
    if(($edgeZsetA==1)&&($NdistA>$SnapD)){
    $pointNearEdgeCurve[0]= 0;
    }
    if(($edgeZsetA==0)&&($NdistA>$SnapD)){
    $pointNearEdgeCurve[0]= 0;
    }
    if(($edgeZsetA==0)&&($NdistA<$SnapD)){
    $pointNearEdgeCurve[0]= 2;
    }

    if(($edgeZsetB==1)&&($NdistB<$SnapD)){
    $pointNearEdgeCurve[1]= 1;
    }
    if(($edgeZsetB==1)&&($NdistB>$SnapD)){
    $pointNearEdgeCurve[1]= 0;
    }
    if(($edgeZsetB==0)&&($NdistB>$SnapD)){
    $pointNearEdgeCurve[1]= 0;
    }
    if(($edgeZsetB==0)&&($NdistB<$SnapD)){
    $pointNearEdgeCurve[1]= 2;
    }



    /////////////////////////////////////////////

    if($edgeZsetA==1){
    $EdgeDist =$NdistA;
    }else{$EdgeDist=$NdistB;}

    $SnappingVector = 0;
    if($NdistA<$NdistB){
    $SnappingVector=0;
    }else{$SnappingVector=1;}

    if($NdistA>$SnapD){
    $edgeZsetA = 0;
    }
    if($NdistB>$SnapD){
    $edgeZsetB = 0;
    }
    $OneIsNotNearThePlane = 0;
    if(($NdistA>$SnapD)||($NdistB<$SnapD)){
    if(($NdistA<$SnapD)||($NdistB>$SnapD)){
    $OneIsNotNearThePlane =1;
    }
    }

    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    if(($edgeZsetA==1)||($edgeZsetB==1)){
    $EdgeDist =0.001;
    }
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




    if($pointNearEdgeCurve[0]+$pointNearEdgeCurve[1]== 1){



    $newNamesResultA1 = substituteAllString($newNames, "Plane", "");
    $ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
    $ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
    $A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
    $A= `MakeCleanFloats($A)`;
    $B= `MakeCleanFloats($B)`;
    if(($A[0] ==0)||($B[0] ==0)){

    $triggerMiddle =2;
    $ifSingleCurve=1;
    if($edgeZsetA==1){
    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
    $NearVecPts[1]= $VecCurEnds[1];
    }else{
    $NearVecPts[0]= $VecCurEnds[0];
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
    }
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    if($EdgeDist<2.5){

    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    $PositionsZ_Aii = $PositionsZ_Ai;
    }
    $PositionsZ_Aiix[0] = <<0, 0, 0>>;
    $PositionsZ_Aiix[1] = <<0, 1, 0>>;
    $PositionsZ_Aiix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    if($EdgeDist<2.5){
    $VecTest  = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
    }else{$VecTest  = LineIntersectPlaneCam($PositionsZ_A, $CamPos1, $PositionsZ_Aiix);
    }
    $CurveAv[0] = VecArrayToCurveB($VecTest);
    }

    }



    if( $pointNearEdgeCurve[1]==1){

    $newNamesResultA1 = substituteAllString($newNames, "Plane", "");
    $ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
    $ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
    $A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
    $A = MakeCleanFloatsZ($A);
    $B = MakeCleanFloatsZ($B);

    if(($A[0] ==0)&&($B[0] ==0)){

    // NOTE these two
    $triggerMiddle =2;
    $ifSingleCurve=1;

    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    delete $CurveItemA;
    $CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);

    $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    if($DiffMathA >95.0){
    $PositionsZ_Aii[0] = $NearVecPts[0];
    $PositionsZ_Aii[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
    $PositionsZ_Aii[2]= $NearVecPts[1];

    } else{
    $PositionsZ_Aii = $PositionsZ_Ai;}
    $PositionsZ_Aiix[0] = <<0, 0, 0>>;
    $PositionsZ_Aiix[1] = <<0, 1, 0>>;
    $PositionsZ_Aiix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $VecTest = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
    if($DiffMathA >95.0){	$CurveAv[0] = VecArrayToCurve($VecTest);}else{
    $CurveAv[0] = VecArrayToCurve($VecTest);}
    }
    }


    if($triggerMiddle==0){

    if($GetSizeOfCRV_ends>0){
    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);
    $distancesTo3DCurveEnd = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
    $Sorted = SortNumbersIntIndex($distancesTo3DCurveEnd);
    $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
    $distancesTo3DCurveEndi = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
    $Sortedi = SortNumbersIntIndex($distancesTo3DCurveEndi);
    $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
    $FistAndSecond[0]=$LocCurveEndsVec3D[$Sorted[0]];
    $FistAndSecond[1]=$LocCurveEndsVec3D[$Sortedi[0]];
    $LocNames[0]=$queryLocCurveEnds3D[$Sorted[0]];
    $LocNames[1]=$queryLocCurveEnds3D[$Sortedi[0]];
    $LocNames[2]=$queryLocCurveEnds3D[$Sorted[1]];
    $LocNames[3]=$queryLocCurveEnds3D[$Sortedi[1]];
    $VecA = $FistAndSecond[0];
    $VecB = $FistAndSecond[1];
    $XX = $VecA.x;
    $XXX = $VecB.x;
    if( ($XX*-1)==$XXX){
    if($NptsDist<2.5){

    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($VecA));
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($VecB));
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    delete $CurveItemA;
    $CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);
    $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    clear $PositionsZ_A;

    if($DiffMathA >95.0){

    $PositionsZ_Ai[0] = $NearVecPts[0];
    $PositionsZ_Ai[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
    $PositionsZ_Ai[2]= $NearVecPts[1];

    }else{
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    }
    $ReversePositionsZ_Ai = ReverseVectorArray($PositionsZ_Ai);
    clear $PtsMirrorAi;
    $PtsMirrorAi= VecPtsToZMirrorPts($ReversePositionsZ_Ai);
    $iiz = 0;
    clear $XIntersect_Ax;
    for ($eachVecx in  $ReversePositionsZ_Ai){
    $XIntersect_Ax[`size($XIntersect_Ax)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_Ai[$iiz], $CamPos_M, $PtsMirrorAi[$iiz]));
    $iiz++;
    }
    if($DiffMathA >95.0){
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    }

    $CurveAv =  VecArrayToSplitCurve($XIntersect_Ax);
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
    $evalSmoothi += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmoothi);
    $ifSingleCurve=1;
    }
    }
    }
    }

    $VanishingPointsLinesTempGuides = $CurvesV;
    if(( $ifSingleCurve == 1)&&($triggerMiddle ==0)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[1];
    sets -include ZEdgeCurvesSet $CurveAv;
    }else{
    if(( $ifSingleCurve == 1)&&($triggerMiddle ==1)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    }
    }

    if( ($ifSingleCurve == 1)&&($triggerMiddle ==2)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv;
    $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    sets -include ZEdgeCurvesSet $CurveAv;
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    }
    return $CurvesV;
    }

    proc vector [] VecPointsToCameraPlane(vector $V[]){
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+($D1*$F3);
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    return $O;
    }
}


/******************************************************************************
 * @procedure    Matrix_Curve_Translation
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $VecPairA : vector[]
 *   $VecPairB : vector[]
 *   $CurveVecPointZ : vector[]
 *
 * @returns      vector []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] Matrix_Curve_Translation(vector $VecPairA[], vector $VecPairB[], vector $CurveVecPointZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $LengthA = distance2Pts ($VecPairA[0], $VecPairA[1]);
    float $LengthB = distance2Pts ($VecPairB[0], $VecPairB[1]);
    float $LengthAB;
    float $Sign_F;
    float $MatrixFB[] = MatrixToFloat($matrixB);
    float $AddMepi[];
    string $curvei = "curve -d 1";
    vector $EmptyVecA[];
    vector $EmptyVecB[];
    vector $NewCurveVecPts[];
    vector $eachCurveVec;
    vector $newTranVec;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    matrix $matrixB[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $matrixA = TwoPointMatrixPlusAxisWorld($VecPairA, $EmptyVecA, 1);
    $matrixB = TwoPointMatrixPlusAxisWorld($VecPairB, $EmptyVecB, 1);
    // Get scale changerelative to multiply in matrix
    // 3 7 11 // shear
    // float matrix size 16 numbers its index Number for Scale is 15
    // matrix [3][3]
    $LengthA = distance2Pts ($VecPairA[0], $VecPairA[1]);
    $LengthB = distance2Pts ($VecPairB[0], $VecPairB[1]);

    if($LengthA<$LengthB){$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}else{$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}
    $LengthAB *= $Sign_F;
    $MatrixFB = MatrixToFloat($matrixB);
    size $MatrixFB;
    //PrintMatrix($matrixB, 4);
    $MatrixFB[15] = $LengthAB;
    $matrixNB = FloatToMatrix($MatrixFB);
    //PrintMatrix($matrixNB, 4);
    $curvei = "curve -d 1";
    $CountCpts =0;
    for($eachCurveVec in $CurveVecPointZ){

    //Key MatrixAxisTranlation
    $newTranVec = MatrixAxisTranlation($eachCurveVec, $matrixA, $matrixNB);
    $AddMepi = $newTranVec;
    $NewCurveVecPts[$CountCpts] = <<$AddMepi[0],$AddMepi[1],$AddMepi[2]>>;
    $curvei += " -p "+$AddMepi[0]+" "+$AddMepi[1]+" "+$AddMepi[2];
    $CountCpts++;
    }
    //eval($curvei);
    //ResetTransEachSL;
    return $NewCurveVecPts;

}


/******************************************************************************
 * @procedure    VectorsComp
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $ZeroOneTwo : int
 *   $veci : vector
 *
 * @returns      float
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float VectorsComp(int $ZeroOneTwo, vector $veci)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $ni;
    string $xyz[] = {"x", "y", "z"};
    string $command = ("\$ni ="+"$v"+"."+$xyz[$ZeroOneTwo]);
    vector $v = $veci;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $xyz = {"x", "y", "z"};
    $v = $veci;
    $command = ("\$ni ="+"$v"+"."+$xyz[$ZeroOneTwo]);
    return  eval($command);

}


/******************************************************************************
 * @procedure    VecArrayToCurve
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $FixVec : vector[]
 *
 * @returns      string
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string VecArrayToCurve(vector $FixVec[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sIZes = `size $FixVec `;
    int $NUmers[] = CreateIntIndex($sIZes);
    float $valuesBi[] = $eachVeCx;
    string $K = "";
    string $curve = "curve -d 1";
    string $Newcurvez = `eval($curve)`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $sIZes = `size $FixVec `;
    $NUmers = CreateIntIndex($sIZes);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $curve = "curve -d 1";
    for ($eachVeCx in $FixVec){
    $valuesBi = $eachVeCx;
    $curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    }
    $curve += " "+ $K;
    $Newcurvez = `eval($curve)`;
    return $Newcurvez;

}


/******************************************************************************
 * @procedure    EulerAngB
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $pointB1 : float[]
 *   $pointB2 : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] EulerAngB(float $pointB1[], float $pointB2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $EulerAngleA[] = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $EulerAngleA = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
    return $EulerAngleA;

}


/******************************************************************************
 * @procedure    MirrorPointFrom3PointPlane
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $SelectVec : vector[]
 *   $oneItemFLoats : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] MirrorPointFrom3PointPlane(vector $SelectVec[], float $oneItemFLoats[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $x = $oneItemFLoats[0];
    float $y = $oneItemFLoats[1];
    float $z = $oneItemFLoats[2];
    float $normal[] = $bi;
    float $p[] = AverageVectorPoint($SelectVec);
    float $d = $normal[0] * $p[0] + $normal[1] * $p[1] + $normal[2] * $p[2];
    float $dist = $x * $normal[0] + $y * $normal[1] + $z * $normal[2] - $d;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    //p t n Are just a directions....
    $p = $SelectVec[0];
    $t = $SelectVec[1];
    $n = $SelectVec[2];
    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
    $norm = `unit << $n[0], $n[1], $n[2] >>`;
    // Calculate the binormal.
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
    << ($norm.x), ($norm.y), ($norm.z) >>`;
    // Normalize our vector.
    $bi = `unit $bi`;
    $x = $oneItemFLoats[0];
    $y = $oneItemFLoats[1];
    $z = $oneItemFLoats[2];
    $bi *=-1.0;
    $normal = $bi;
    $p = AverageVectorPoint($SelectVec);
    $d = $normal[0] * $p[0] + $normal[1] * $p[1] + $normal[2] * $p[2] ;
    $dist = $x * $normal[0] + $y * $normal[1] + $z * $normal[2] - $d ;
    $dist *=-1.0;
    $mp[0] = $x ;
    $mp[1] = $y ;
    $mp[2] = $z ;
    $dist *= 1.0 ;
    $dist += -1.0;
    $mp[0] = ($x + 2.0 * $normal[0] * ($dist))   ;
    $mp[1] = ($y + 2.0 * $normal[1] * ($dist))   ;
    $mp[2] = ($z + 2.0 * $normal[2] * ($dist))   ;

    return $mp;

}


/******************************************************************************
 * @procedure    PointCurvesToMirrorPoint
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $CurveItemZ : string[]
 *   $SelectVec : vector[]
 *
 * @returns      vector []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] PointCurvesToMirrorPoint(string $CurveItemZ[], vector $SelectVec[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $newCurvei = VecArrayToCurve($AllPlaneLocs);
    vector $AllPlaneLocs[];
    vector $AllLocPositionsZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    clear  $AllPlaneLocs;
    clear $AllLocPositionsZ;
    $AllLocPositionsZ = VecCurveEps($CurveItemZ[0] );
    for ($eachVecEp in $AllLocPositionsZ){
    $AllPlaneLocs[`size($AllPlaneLocs)`] = `FloatToVec (MirrorPointFrom3PointPlane( $SelectVec, $eachVecEp))`;
    }
    $newCurvei = VecArrayToCurve($AllPlaneLocs);
    ResetTranslation({$newCurvei});
    return $AllPlaneLocs;

}


/******************************************************************************
 * @procedure    PtCurvesToZMirrorPt
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $CurveItemZ : string[]
 *
 * @returns      vector []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] PtCurvesToZMirrorPt(string $CurveItemZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Zx[] = $eachVecEp;
    string $newCurvei = VecArrayToCurve($AllPlaneLocs);
    vector $AllPlaneLocs[];
    vector $AllLocPositionsZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    clear  $AllPlaneLocs;
    clear $AllLocPositionsZ;
    $AllLocPositionsZ = VecCurveEps($CurveItemZ[0] );
    for ($eachVecEp in $AllLocPositionsZ){
    $Zx = $eachVecEp;
    $Zx[0] *= -1.0;
    $AllPlaneLocs[`size($AllPlaneLocs)`] = `FloatToVec ($Zx)`;
    }
    $newCurvei = VecArrayToCurve($AllPlaneLocs);
    ResetTranslation({$newCurvei});
    return $AllPlaneLocs;

}


/******************************************************************************
 * @procedure    VecPtsToZMirrorPts
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $AllLocPositionsZ : vector[]
 *
 * @returns      vector []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecPtsToZMirrorPts(vector $AllLocPositionsZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Zx[] = $eachVecEp;
    vector $AllPlaneLocs[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    clear  $AllPlaneLocs;
    for ($eachVecEp in $AllLocPositionsZ){
    $Zx = $eachVecEp;
    $Zx[0] *= -1.0;
    $AllPlaneLocs[`size($AllPlaneLocs)`] = `FloatToVec ($Zx)`;
    }
    return $AllPlaneLocs;

}


/******************************************************************************
 * @procedure    addStereoCurve
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      int
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int addStereoCurve()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CreatedObjectCurve = `ISSelectedTypeCurve`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CreatedObjectCurve = `ISSelectedTypeCurve`;
    return $CreatedObjectCurve;

}


/******************************************************************************
 * @procedure    ISSelectedTypeCurve
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      int
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ISSelectedTypeCurve()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroOR1Z = `gmatch $nameB "*[C-c]urve*"`;
    string $C[];
    string $nametypeZi;
    string $nameA;
    string $nameB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $C = `ls -sl`;
    $nametypeZi= `getTypeItemString $C`;
    $nameA = `match "[a-zA-Z]+" $nametypeZi`;
    $nameB = `match ".urve" $nameA`;
    $zeroOR1Z = `gmatch $nameB "*[C-c]urve*"`;
    return $zeroOR1Z;

}


/******************************************************************************
 * @procedure    addCurveNumbers
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $addNumbersiA : int
 *
 * @returns      int
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int addCurveNumbers(int $addNumbersiA)
{

    $addNumbersiA++;
    if($addNumbersiA>2){$addNumbersiA=0;}
    return $addNumbersiA;

}


/******************************************************************************
 * @procedure    FloatPointsToCamPlane
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $LocPos1 : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] FloatPointsToCamPlane(float $LocPos1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Pi = 3.1415926535;
    float $pi = 3.1415926535;
    float $CamPos1[];
    float $LivePlanePos[];
    float $CamerasDirectionVectorNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
    float $FloatDirectionA[] = DirectionFN($CamPos1, $LocPos1);
    float $DistanceLoc = distance2Pts( $LocPos1, $CamPos1 );
    float $DistanceLocA = $DistanceLoc;
    float $MultDirPC1[] = multiplyFloat($DistanceLoc, $CamerasDirectionVector);
    float $FloatDirectionCamNormal[] = AddFloats($CamPos1, $MultDirPC1);
    float $CamerasDirectionVectorA[] = DirectionFN($FloatDirectionCamNormal, $CamPos1);
    float $MultDirPC1A[] = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
    float $p1[] = $CamPos1;
    float $p2[] = $LocPos1;
    float $p3[] = $FloatDirectionCamNormal;
    float $center[];
    float $normal[];
    float $FloatPosZero[] = {0, 0, 0};
    float $FloatDirection[] = DirectionFN($FloatPosZero, $normal);
    float $FloatDirPerpCenterC[] = DirectionFN($center,$mid2);
    float $FloatDirPointAC[] = DirectionFN($p1, $p3);
    float $center8[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    float $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
    float $FloatDirLocToPerpIntersect[] = DirectionFN($center8,$p2);
    float $OnPlane[] = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Pi = 3.1415926535;
    $pi = 3.1415926535;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $LivePlanePos = `xform -q -ws -t LiveSurfaceB`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $CamerasDirectionVector = $CamerasDirectionVectorNormal;
    $FloatDirectionA = DirectionFN($CamPos1, $LocPos1);
    $DistanceLoc = distance2Pts( $LocPos1, $CamPos1 );
    $DistanceLocA = $DistanceLoc;
    $DistanceLoc = $DistanceLoc * -1;
    $MultDirPC1 = multiplyFloat($DistanceLoc, $CamerasDirectionVector);
    $FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1);
    $CamerasDirectionVectorA = DirectionFN($FloatDirectionCamNormal, $CamPos1);
    $MultDirPC1A = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
    $FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1A);
    $p1 = $CamPos1;
    $p2 = $LocPos1;
    $p3 = $FloatDirectionCamNormal;
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );
    $FloatPosZero = {0, 0, 0};
    $FloatDirection = DirectionFN($FloatPosZero, $normal);
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $mid3 = midPoint2Pts( $p2, $p3 );
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    $FloatDirPerpCenterC = DirectionFN($center,$mid2);
    $FloatDirPointAC = DirectionFN($p1, $p3);
    $center8 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
    $FloatDirLocToPerpIntersect = DirectionFN($center8,$p2);
    $OnPlane = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );
    return $OnPlane;

}


/******************************************************************************
 * @procedure    DirectionF
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $EACHCVposAZ : float[]
 *   $EACHCVposBZ : float[]
 *
 * @returns      float[]
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] DirectionF(float $EACHCVposAZ[], float $EACHCVposBZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $UnitDirection[] = $vectorUnit;
    vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    //This is freaky since it is reversed!! not sure I could ever fix this
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]);
    /*
    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
    $vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]);
    */
    $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
    $UnitDirection = $vectorUnit;
    ///////////////////////////////////////////////// ////
    return $UnitDirection;

}


/******************************************************************************
 * @procedure    DirectionFN
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $posAZ : float[]
 *   $posBZ : float[]
 *
 * @returns      float[]
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] DirectionFN(float $posAZ[], float $posBZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $u = $xi - $x;
    float $v = $yi - $y;
    float $w = $zi - $z;
    float $e = 1;
    float $Y = $u/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    float $U = $v/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    float $V = $w/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    float $UnitDirection[] = $YUV;
    vector $Vai = $VecbvA[0];
    vector $Vbi = $VecbvA[1];
    vector $VbiUnit = << $u, $v, $w >>;
    vector $VbiUnitA = `unit $VbiUnit`;
    vector $YUV = << $Y, $U, $V>>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    /*

    $Vai = $VecbvA[0];
    $Vbi = $VecbvA[1];

    */

    $Vai = << $posAZ[0], $posAZ[1], $posAZ[2] >> ;
    $Vbi = << $posBZ[0],  $posBZ[1], $posBZ[2] >> ;

    $xi = $Vai.x;
    $yi = $Vai.y;
    $zi = $Vai.z;
    $x = $Vbi.x;
    $y = $Vbi.y;
    $z = $Vbi.z;
    $u = $xi - $x;
    $v = $yi - $y;
    $w = $zi - $z;


    $VbiUnit = << $u, $v, $w >> ;
    $VbiUnitA = `unit $VbiUnit`;
    /*
    $e = 1;
    //float $Mult = $e*$v;
    $Y = $u/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $U = $v/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $V = $w/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
    $YUV = << $Y, $U, $V>>;
    $UnitDirection = $YUV;
    */
    $UnitDirection = $VbiUnitA;

    //////////
    return $UnitDirection;

}


/******************************************************************************
 * @procedure    DoubleDeterminant
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $mat : matrix[]
 *
 * @returns      float
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float DoubleDeterminant(matrix $mat[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $valueA;
    float $valueB;
    float $valueC;
    float $valueD;
    float $valueE;
    float $valueF;
    float $valueG;
    float $value = $valueA - $valueB - $valueC - $valueD - $valueE - $valueF - $valueG;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $valueA = $mat[0][3] * $mat[1][2] * $mat[2][1] * $mat[3][0]-$mat[0][2] * $mat[1][3] * $mat[2][1] * $mat[3][0];
    $valueB = $mat[0][3] * $mat[1][1] * $mat[2][2] * $mat[3][0]+$mat[0][1] * $mat[1][3] * $mat[2][2] * $mat[3][0]+ $mat[0][2] * $mat[1][1] * $mat[2][3] * $mat[3][0]-$mat[0][1] * $mat[1][2] * $mat[2][3] * $mat[3][0];
    $valueC = $mat[0][3] * $mat[1][2] * $mat[2][0] * $mat[3][1]+$mat[0][2] * $mat[1][3] * $mat[2][0] * $mat[3][1]+ $mat[0][3] * $mat[1][0] * $mat[2][2] * $mat[3][1]-$mat[0][0] * $mat[1][3] * $mat[2][2] * $mat[3][1];
    $valueD = $mat[0][2] * $mat[1][0] * $mat[2][3] * $mat[3][1]+$mat[0][0] * $mat[1][2] * $mat[2][3] * $mat[3][1]+ $mat[0][3] * $mat[1][1] * $mat[2][0] * $mat[3][2]-$mat[0][1] * $mat[1][3] * $mat[2][0] * $mat[3][2];
    $valueE = $mat[0][3] * $mat[1][0] * $mat[2][1] * $mat[3][2]+$mat[0][0] * $mat[1][3] * $mat[2][1] * $mat[3][2]+ $mat[0][1] * $mat[1][0] * $mat[2][3] * $mat[3][2]-$mat[0][0] * $mat[1][1] * $mat[2][3] * $mat[3][2];
    $valueF = $mat[0][2] * $mat[1][1] * $mat[2][0] * $mat[3][3]+$mat[0][1] * $mat[1][2] * $mat[2][0] * $mat[3][3]+ $mat[0][2] * $mat[1][0] * $mat[2][1] * $mat[3][3]-$mat[0][0] * $mat[1][2] * $mat[2][1] * $mat[3][3];
    $valueG = $mat[0][1] * $mat[1][0] * $mat[2][2] * $mat[3][3]+$mat[0][0] * $mat[1][1] * $mat[2][2] * $mat[3][3];
    $value = $valueA - $valueB - $valueC - $valueD - $valueE - $valueF - $valueG;
    return $value;

}


/******************************************************************************
 * @procedure    lineIntersectionF
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $PosA : float[]
 *   $PosB : float[]
 *   $PosC : float[]
 *   $PosD : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] lineIntersectionF(float $PosA[], float $PosB[], float $PosC[], float $PosD[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $DirAB[] = DirectionF ($PosA, $PosB);
    float $DirCD[] = DirectionF ($PosC, $PosD);
    float $locsA[] = lineIntersection($PosA, $DirAB, $PosC, $DirCD);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $DirAB = DirectionF ($PosA, $PosB);
    $DirCD = DirectionF ($PosC, $PosD);
    $locsA = lineIntersection($PosA, $DirAB, $PosC, $DirCD);
    return $locsA;

}


/******************************************************************************
 * @procedure    screenSpaceGetMatrix
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $attr : string
 *
 * @returns      matrix
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix screenSpaceGetMatrix(string $attr)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $v[] = `getAttr $attr`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $v = `getAttr $attr`;
    matrix $mat[4][4]=<<$v[0], $v[1], $v[2], $v[3];
    $v[4], $v[5], $v[6], $v[7];
    $v[8], $v[9], $v[10], $v[11];
    $v[12], $v[13], $v[14], $v[15]>>;
    return $mat;

}


/******************************************************************************
 * @procedure    screenSpaceVecMult
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $v : vector
 *   $m : matrix
 *
 * @returns      vector
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector screenSpaceVecMult(vector $v, matrix $m)
{

    matrix $v1[1][4]=<<$v.x, $v.y, $v.z, 1>>;
    matrix $v2[1][4]=$v1*$m;
    return <<$v2[0][0], $v2[0][1],  $v2[0][2]>>;

}


/******************************************************************************
 * @procedure    matrixSpaceVecMult
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $v : vector
 *   $m : matrix
 *
 * @returns      vector
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector matrixSpaceVecMult(vector $v, matrix $m)
{

    matrix $v1[1][4]=<<$v.x, $v.y, $v.z, 1>>;
    matrix $v2[1][4]=$v1*$m;
    return <<$v2[0][0], $v2[0][1],  $v2[0][2]>>;

}


/******************************************************************************
 * @procedure    GetworldMatrix
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $object : string
 *
 * @returns      matrix
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix GetworldMatrix(string $object)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $v[] = `getAttr $attr`;
    string $attr = $object +".worldMatrix";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $attr = $object +".worldMatrix";
    $v = `getAttr $attr`;
    matrix $mat[4][4]= `FloatToMatrix($v)`;
    return $mat;

}


/******************************************************************************
 * @procedure    GetworldInverseMatrix
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $object : string
 *
 * @returns      matrix
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix GetworldInverseMatrix(string $object)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $v[] = `getAttr $attr`;
    string $attr = $object +".worldInverseMatrix";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $attr = $object +".worldInverseMatrix";
    $v = `getAttr $attr`;
    matrix $mat[4][4]= `FloatToMatrix($v)`;
    return $mat;

}


/******************************************************************************
 * @procedure    GetInverseMatrix
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $object : string
 *
 * @returns      matrix
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix GetInverseMatrix(string $object)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $v[] = `getAttr $attr`;
    string $attr = $object +".inverseMatrix";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $attr = $object +".inverseMatrix";
    $v = `getAttr $attr`;
    matrix $mat[4][4]= `FloatToMatrix($v)`;
    return $mat;

}


/******************************************************************************
 * @procedure    GetMatrix
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $object : string
 *
 * @returns      matrix
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix GetMatrix(string $object)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $v[] = `getAttr $attr`;
    string $attr = $object +".matrix";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $attr = $object +".matrix";
    $v = `getAttr $attr`;
    matrix $mat[4][4]= `FloatToMatrix($v)`;
    return $mat;

}


/******************************************************************************
 * @procedure    pointMatrixMult
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $point : float[]
 *   $matrix : float[]
 *
 * @returns      float[]
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] pointMatrixMult(float $point[], float $matrix[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $result[];
    string $multNode;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result[0] = 0.0;
    $result[1] = 0.0;
    $result[2] = 0.0;
    if ( size($point) != 3 || size($matrix) != 16 )
    {
    warning (uiRes("m_pointMatrixMult.kPointArray"));
    return $result;
    }
    // create the node that will do the actual computation
    //
    if ( catch($multNode = `createNode pointMatrixMult`) )
    {
    warning (uiRes("m_pointMatrixMult.kCouldNotCreateNode"));
    return $result;
    }
    // set the matrix and point inputs to the node
    //
    setAttr ($multNode+".vectorMultiply") true;
    setAttr ($multNode+".inPoint") -type "double3" $point[0] $point[1] $point[2];
    setAttr ($multNode+".inMatrix") -type "matrix" $matrix[0] $matrix[1] $matrix[2] $matrix[3] $matrix[4] $matrix[5] $matrix[6] $matrix[7] $matrix[8] $matrix[9] $matrix[10] $matrix[11] $matrix[12] $matrix[13] $matrix[14] $matrix[15];
    // get the result and delete the node since it is no longer required
    //
    $result = `getAttr ($multNode+".output")`;
    delete $multNode;
    return $result;

}


/******************************************************************************
 * @procedure    AddItemString
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $iN : int
 *   $NumLetorSy : string
 *
 * @returns      string
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string AddItemString(int $iN, string $NumLetorSy)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Xz = 0;
    string $AddItem = "";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Xz = 0;
    $AddItem = "";
    while($iN > $Xz){
    $AddItem+= $NumLetorSy;
    $Xz++;
    }
    return $AddItem;

}


/******************************************************************************
 * @procedure    MatrixMirrorX
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $m : matrix[]
 *
 * @returns      matrix
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix MatrixMirrorX(matrix $m[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iX = 0;
    float $MatrixA[] = `MatrixToFloat($m)`;
    float $MatrixB[] = `MatrixToFloat($m2)`;
    float $DividedFLoats[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MatrixA = `MatrixToFloat($m)`;
    matrix $m2[4][4]=<<1.0, 0.0, -1.0, 0.0;
    -1.0, 1.0, 1.0, 0.0;
    -1.0, 1.0, 1.0, 0.0;
    -1.0, 1.0, 1.0, 1.0>>;
    $MatrixB = `MatrixToFloat($m2)`;
    $iX = 0;
    for ($eachFloat in $MatrixA){
    if(!($MatrixB[$iX]==0)){
    $DividedFLoats[`size($DividedFLoats)`] = $eachFloat * $MatrixB[$iX];
    }else{$DividedFLoats[`size($DividedFLoats)`] = $eachFloat;}
    $iX++;
    }
    matrix $MatrixDiv[4][4]= FloatToMatrix($DividedFLoats);
    return $MatrixDiv;

}


/******************************************************************************
 * @procedure    MultMatrixMirrorX
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $point : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] MultMatrixMirrorX(float $point[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MatrixB[] = `MatrixToFloat($m2)`;
    float $FLoatPointA[] = pointMatrixMult( $point, $MatrixB );

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    matrix $m2[4][4]=<<1.0, 0.0, -1.0, 0.0;
    -1.0, 1.0, 1.0, 0.0;
    -1.0, 1.0, 1.0, 0.0;
    -1.0, 1.0, 1.0, 1.0>>;
    $MatrixB = `MatrixToFloat($m2)`;
    $FLoatPointA = pointMatrixMult( $point, $MatrixB );
    return $FLoatPointA;

}


/******************************************************************************
 * @procedure    MatrixTimesFloat
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $m : matrix[]
 *   $X : float
 *
 * @returns      matrix
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix MatrixTimesFloat(matrix $m[], float $X)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iX = 0;
    float $MatrixA[] = `MatrixToFloat($m)`;
    float $DividedFLoats[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MatrixA = `MatrixToFloat($m)`;

    $iX = 0;
    for ($eachFloat in $MatrixA){
    $DividedFLoats[`size($DividedFLoats)`] = $eachFloat * $X;

    $iX++;
    }
    matrix $MatrixDiv[4][4]= FloatToMatrix($DividedFLoats);
    return $MatrixDiv;

}


/******************************************************************************
 * @procedure    MatrixDivide
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $m : matrix[]
 *   $m2 : matrix[]
 *
 * @returns      matrix
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix MatrixDivide(matrix $m[], matrix $m2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iX = 0;
    float $MatrixA[] = `MatrixToFloat($m)`;
    float $MatrixB[] = `MatrixToFloat($m2)`;
    float $DividedFLoats[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MatrixA = `MatrixToFloat($m)`;
    $MatrixB = `MatrixToFloat($m2)`;
    $iX = 0;
    for ($eachFloat in $MatrixA){
    if(!($MatrixB[$iX]==0)){
    $DividedFLoats[`size($DividedFLoats)`] = $eachFloat/ $MatrixB[$iX];
    }else{$DividedFLoats[`size($DividedFLoats)`] = $eachFloat;}
    $iX++;
    }
    matrix $MatrixDiv[4][4]= FloatToMatrix($DividedFLoats);
    return $MatrixDiv;

}


/******************************************************************************
 * @procedure    MatrixCleanNegZero
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $m : matrix[]
 *
 * @returns      matrix
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix MatrixCleanNegZero(matrix $m[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iX = 0;
    float $MatrixA[] = `MatrixToFloat($m)`;
    float $CleanFLoats[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MatrixA = `MatrixToFloat($m)`;

    $iX = 0;
    for ($eachFloat in $MatrixA){
    if(($eachFloat == 0)||($eachFloat == -0)){
    $CleanFLoats[`size($CleanFLoats)`] = 0.0;
    }else{$CleanFLoats[`size($CleanFLoats)`] = $eachFloat;}
    $iX++;
    }
    $CleanFLoats = MakeCleanFloatsZ($CleanFLoats);
    matrix $MatrixClean[4][4]= FloatToMatrix($CleanFLoats);
    return $MatrixClean;

}


/******************************************************************************
 * @procedure    AverageANdCLoseSketchFittingCircle
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $curveItemC : string
 *
 * @returns      string
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string AverageANdCLoseSketchFittingCircle(string $curveItemC)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Low_X;
    int $TrackC[];
    int $NewIndex[];
    int $Xv = 0;
    int $TFNS = 1;
    int $IndexTrack[];
    int $CountN = 0;
    int $TrueorFalseCircle = `IsCircle`;
    int $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);
    int $IfTrue;
    int $weighedtFindings = 0;
    int $weighedtFindingsZ = 0;
    int $weighedtFindingsN = 0;
    int $triggerStraitCRV = 0;
    int $Trueii = 0;
    int $iia = 0;
    int $AllLocsi[] = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    int $New_AllLocs_A[];
    int $Near_index_A = $New_AllLocs_A[0];
    int $New_AllLocs_B[];
    int $Near_index_B = $New_AllLocs_B[0];
    int $triggerNoTrans = 0;
    int $iiz = 0;
    int $colori[];
    int $numIparms = size($intersections1);
    int $TF = 0;
    int $CurveIndexInter[];
    int $NodeCurveIndex[] = CreateCrvInterTF($CurveItemZai, $PlaneCurveS,0,0.001,$interVecA, $interVecB);
    int $COuntN = 0;
    int $foundN[];
    int $CombA;
    int $Number = 0;
    int $CollectN_index[];
    int $COLLECT_INDEX[];
    int $COLLECTN_INDEX[];
    int $COLLECT_Wanted_INDEX[];
    int $Cni = 0;
    int $Cnii = 0;
    int $AllM[];
    int $ExistingIntA[];
    int $COLLECT_INDEX_M[];
    int $eachIntE;
    int $Cniim = 0;
    int $NodeCurveIndexi[];
    int $CountPara = 0;
    int $ParaSize[];
    int $CurveSFoundS = `size($NodeCurveIndexi)`;
    int $PointOnCrvIND[] = CreateIntIndex(`size($VecPointOnCrv)`);
    int $New_PointOnCrvIND_A[];
    int $FOUNDc = $New_PointOnCrvIND_A[0];
    int $WhatCurve;
    int $CountWhatCurve = -1;
    int $CountParab = 0;
    int $ParaSizeb[];
    int $CurveSFoundSb = `size($NodeCurveIndex)`;
    int $PointOnCrvINDb[] = CreateIntIndex(`size($VecPointOnCrvb)`);
    int $New_PointOnCrvIND_Ab[];
    int $FOUNDcb = $New_PointOnCrvIND_Ab[0];
    int $WhatCurveb;
    int $CountWhatCurveb = -1;
    int $pX = equivalentTol($posA[0], $posB[0],  0.001);
    int $pY = equivalentTol($posA[1], $posB[1],  0.001);
    int $pZ = equivalentTol($posA[2], $posB[2],  0.001);
    int $addedResults = $pX + $pY + $pZ;
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 4 );
    int $FindSteps;
    int $StepZNum = $numLength;
    int $MasterCount = 0;
    int $Par = 0;
    int $a;
    int $ii = 0;
    int $CountSteps;
    int $NewIndexN[];
    int $sIZes = `size $FixVec `;
    int $NUmers[] = CreateIntIndex($sIZes);
    int $TwoNew[];
    int $iNdex = 0;
    int $returnValue = 1;
    int $vi = 0;
    int $iX = 0;
    int $Trigger = 0;
    int $Lowest = 11110;
    int $Past = 0;
    int $CountEVEN = 0;
    int $Even_Odd;
    int $Count = 0;
    int $CountP = 0;
    int $count = 0;
    int $Size = size($x0);
    int $evenOdd = fmod($sIZes, 2);
    int $sIZesHalf = (($sIZes)/2)+1;
    int $countN = 0;
    int $CountVV = 0;
    int $index[] = CreateIntIndex(3);
    int $xyz = $EmptyIndx[0];
    int $isOrthoTrueZi = 0;
    int $triggerNoTransENDA = 0;
    int $triggerNoTransENDB = 0;
    int $First_Second_Both_None = 0;
    int $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
    int $TrackAllExisting3DCrv[] = CreatePairIntIndex($SizeCrvi);
    int $SizeCrvR = `size($LayerCurvesRangeA)`;
    int $Cn = 0;
    int $triggerNoTransA = 0;
    int $triggerNoTransB = 0;
    int $trigger_straitC = 0;
    int $iis = 0;
    int $ConnectedEnds = $triggerNoTransENDA + $triggerNoTransENDB;
    int $AddAB = $triggerNoTransA+$triggerNoTransB;
    int $New_AllLocs_AB[];
    int $PairInt[];
    int $EndsAtZero = isCurveEndAtZY($EndrEndsa);
    int $STEPSZ = 200;
    int $LowX;
    int $NewArrayAEllipZ[] = NewVecOrderEllipZ($NewOneCurveS, $EmptyVectorArrayA, $MidEpipolPosFCam);
    int $NewArrayBEllipZ[] = NewVecOrderEllipZ($NewOneCurveSB, $EmptyVectorArrayB, $MidEpipolPosFCam);
    int $IndexTrackE[];
    int $TwoZeroOne[] = {0,1};
    int $TFmostRArray[];
    int $LargestIntR_KEY[];
    int $LargestIntL_KEY[];
    int $COUNT_Nlr = 0;
    int $LargestIntR[] = SortNumbersIntIndex($AllAngiX_RIGHT);
    int $LargestIntL[] = SortNumbersIntIndex($AllAngiX_LEFT);
    int $SizeE = `size($EmptyVectorArrayA)`;
    int $NewArrayInt;
    int $NewArrayIntX[];
    int $Add = 0;
    int $edgeZsetA;
    int $edgeZsetB;
    int $ReducedIndexA[] = floatArrayCountDuplicates($distancesEachToCurve);
    int $ReducedIndexB[] = floatArrayCountDuplicates($distancesEachToCurveB);
    int $NearestInt[] = SortNumbersIntIndex($distAz);
    int $NearestIntB[] = SortNumbersIntIndex($distBz);
    int $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    int $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];
    int $NearestIndex;
    int $NearestIndexEach;
    int $ReducedIndexXAB[];
    int $AxisOrthoLineA = $AxisOrthoLine;
    int $iVc = 0;
    int $TrackFoundN[];
    int $TrackN[];
    int $TwoPointsi[];
    int $AXIS = $AxisOrthoLineA;
    int $ALLlikeness[];
    int $ALLlikenessForce[];
    int $TriggerPoints;
    int $SortedForce[];
    int $Sorted[] = SortNumbersIntIndex($distTo3DCurveEnd);
    int $ReducedIndex[] = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    int $OntheSameLine = 0;
    int $AddInt = $AdditR;
    int $Xi = 0;
    int $C = 0;
    int $NumberE[];
    int $NoneDup[];
    int $result = 0;
    int $ixX = 0;
    int $len = size( $list );
    int $indexAx[] = CreateIntIndex(6);
    int $indexAxNew[] = ArrayToIntList( $BestThree);
    int $color;
    int $iiX = 0;
    int $Cindex = 0;
    int $IndexZ = $indexAxNew[$Count];
    int $triggerMiddle = 0;
    int $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
    int $iv = -1;
    int $CRV_index_number = 0;
    int $CRc = 0;
    int $CRcT = 0;
    int $EDGEpoints[];
    int $pointNearEdgeCurve[];
    int $SnappingVector = 0;
    int $OneIsNotNearThePlane = 0;
    int $Sortedi[] = SortNumbersIntIndex($distancesTo3DCurveEndi);
    int $C1;
    float $Arc = `arclen $CurveItemZai[0]`;
    float $angleZi[];
    float $TotalDegi;
    float $Ellipes_A[];
    float $CamPos_A[];
    float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;
    float $MidEpipolZx[] = MidPoint($CamPos_M, $CamPos_A);
    float $MidEpipolPosFCam[] = FloatPointsToCamPlane($MidEpipolZx);
    float $AngleX[];
    float $angleA;
    float $AngleB[] = EulerAngB((DirectionFN($vecA, $vecB)), (DirectionFN($vecC, $vecD)));
    float $AverageVecCurve[] = AverageVectorPoint($PositionsZ_A);
    float $CamDirVecNormalA[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $CamPlane1[];
    float $CamDirVecNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $MultDirCam[] = multiplyFloat(-1, $CamDirVecNormal);
    float $CamNormM[] = ` MirrorFloatXYZ 0 $MultDirCam`;
    float $EpipolPosCamM[] = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;
    float $MidPosFCam[] = $CamPlane1;
    float $FloatDirEpipol[] = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    float $FloatDirEpipolB[] = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
    float $EpipolXx[] = {0.0,$CamPos_A[1],$CamPos_A[2]};
    float $PlaneEpipolXx[] = FloatPointsToCamPlane( $EpipolXx);
    float $EpipolYx[] = {$CamPos_A[0],0.0,$CamPos_A[2]};
    float $PlaneEpipolYx[] = FloatPointsToCamPlane( $EpipolYx);
    float $EpipolZx[] = {$CamPos_A[0],$CamPos_A[1],0.0};
    float $PlaneEpipolZx[] = FloatPointsToCamPlane( $EpipolZx);
    float $DistTOEpipol_CurEndA;
    float $DistTOEpipol_CurEndB;
    float $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
    float $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
    float $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;
    float $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    float $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
    float $BCDiff = abs($BCurEndB - $BCurEndBNN);
    float $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd;
    float $BCDiffi = abs($BCurEndB - $BCurEndBNNi);
    float $FloatDirEndPtsA[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
    float $EulerAngleA[] = EulerAngB($FloatDirEndPtsA, $FloatDirEpipol);
    float $EulerAngle_A = $EulerAngleA[3];
    float $FloatDirEndPtsB[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
    float $EulerAngleB[] = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);
    float $EulerAngle_B = $EulerAngleB[3];
    float $FloatDirEndPtsAi[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
    float $EulerAngleAi[] = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);
    float $EulerAngle_Ai = $EulerAngleAi[3];
    float $FloatDirEndPtsBi[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
    float $EulerAngleBi[] = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);
    float $EulerAngle_Bi = $EulerAngleBi[3];
    float $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
    float $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;
    float $LengCRV_a = `arclen $CurveItemZai`;
    float $DistEndsi;
    float $PerDiff = percent_of( $LengCRV_a, $DistEndsi);
    float $LengCRV_b = `arclen $CurveItemZbi`;
    float $DistEndsii;
    float $PerDiffii = percent_of( $LengCRV_b, $DistEndsii);
    float $PerDiffSum = ($PerDiff+$PerDiffii)/2.0;
    float $DDirEpipol[] = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
    float $MidCurveA[] = MidPoint($VecCurEndsa[0], $VecCurEndsa[1]);
    float $MidCurveB[] = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);
    float $AngleXi;
    float $DDirEpipolB[] = DirectionFN($MidCurveB, $FoundEpipol);
    float $DDirEpipolA[] = DirectionFN($FoundEpipol,$MidCurveB);
    float $PointToCamDir[];
    float $PointsClos[];
    float $distToCurveE_A[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[0]);
    float $newOrdersZA[] = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    float $Distance_A = $distToCurveE_A[$Near_index_A];
    float $Found_pt_A[] = $LocCurveEndsVec3D[$Near_index_A];
    float $newOrdersZAM[] = $Found_pt_A;
    float $distToCurveE_B[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[1]);
    float $newOrdersZB[] = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    float $Distance_B = $distToCurveE_B[$Near_index_B];
    float $Found_pt_B[] = $LocCurveEndsVec3D[$Near_index_B];
    float $newOrdersZBM[] = $Found_pt_B;
    float $distToPlaneLoc[];
    float $intersectionsA[];
    float $intersections1A[];
    float $intersections1B[];
    float $interVecA[];
    float $interVecB[];
    float $intersectposA[];
    float $newOrderVec[];
    float $eachFloat;
    float $ThreeFs[];
    float $OffsetTol = 1.0005;
    float $Distance_Aii;
    float $VEcF[];
    float $EveryPara[];
    float $EachPara;
    float $posA[];
    float $ParaFloat[];
    float $distCA[] = ArrayDistancesVecTofloat($VecPointOnCrv, $UnconnectedEnds[1]);
    float $newCA[] = SortFloatArrayAndString($distCA, $PointOnCrv_String, $EmptyCA);
    float $NearestDistCA = $distCA[$New_PointOnCrvIND_A[0]];
    float $EveryParab[];
    float $EachParab;
    float $posAb[];
    float $ParaFloatb[];
    float $distCAb[] = ArrayDistancesVecTofloat($VecPointOnCrvb, $UnconnectedEnds[0]);
    float $newCAb[] = SortFloatArrayAndString($distCAb, $PointOnCrv_Stringb, $EmptyCAb);
    float $NearestDistCAb = $distCA[$New_PointOnCrvIND_Ab[0]];
    float $PointBc[] = $CUT_CrvIntersectMirrorEnds_A[0];
    float $uParam = `closestPointOnCurve -ip $PointBc[0] $PointBc[1] $PointBc[2] -q -paramU $newNamesCB`;
    float $interposA[];
    float $interposB[];
    float $locsA[];
    float $Addit[] = $VecLineDirM;
    float $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    float $MultDirOne[] = multiplyFloat(1.0, $DirectionLineF);
    float $AddMultF[] = AddFloats($PointOnLine, $MultDirOne);
    float $FDirNorA[] = Normal3Points($PointOnLine, $AddMultF, $PointN);
    float $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    float $MultDirMx[] = multiplyFloat($DistToLineSTart, $FDirNorA);
    float $AddMultMiiFx[] = AddFloats($PointOnLine, $MultDirMx);
    float $FDirNorB[] = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);
    float $MultDirMxz[] = multiplyFloat($DistToLineSTart,  $FDirNorB);
    float $AddMultMiiFxz[] = AddFloats($PointOnLine, $MultDirMxz);
    float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    float $CircleCenter[] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureCenter")`;
    float $step = $numEPrealNum2;
    float $curveMin = $curveM;
    float $numLength = (`arclen $Newcurvez`) +1;
    float $values[];
    float $MultDirA[] = multiplyFloat(($Length/2.0),  $Direction);
    float $DirectionN[];
    float $MultDirB[] = multiplyFloat(($Length/2.0),  $DirectionN);
    float $FDirA[] = AddFloats($posA, $MultDirA);
    float $FDirB[] = AddFloats($posA, $MultDirB);
    float $CRVRadi[];
    float $CIrceP[];
    float $DistanceS[];
    float $valuesBi[] = $eachVeCx;
    float $point1[] = FloatToVec($Vecs[0]);
    float $point2[] = FloatToVec($Vecs[1]);
    float $point3[] = FloatToVec($Vecs[2]);
    float $normalA[] = `unit ($normalV[0])`;
    float $normalB[] = `unit ($normalV[1])`;
    float $normalAAdd = $normalA[0] + $normalA[1];
    float $normalAAdd2 = $normalB[0] + $normalB[1];
    float $FArrayInex[];
    float $AddF = 0;
    float $z = 8;
    float $Lengthi = distance2Pts ($FixVeci[0], $FixVeci[1]);
    float $MidPt[] = MidPoint($FixVeci[0], $FixVeci[1]);
    float $FloatDirMajor[] = DirectionFN($FixVeci[0], $FixVeci[1]);
    float $Lengthiii = distance2Pts ($MidPt, $FixVeci[2]);
    float $FDirNorAi[] = Normal3Points($FixVeci[0], $FixVeci[1], $FixVeci[2]);
    float $LENGTH = $Lengthi/2.0;
    float $C_radius[] = Circle3PtsM($ABC[0], $ABC[1], $ABC[2]);
    float $ObjsCirclesRad = $C_radius[3];
    float $PointN[] = ClosestPoint2Line($VecLineDir, $FixVeci[2], $MidVec);
    float $Di = distance2Pts( $MidVec , $PointN);
    float $DiffL = ($ObjsCirclesRad-$Di)*2.0;
    float $PointNii[];
    float $PointNiii[];
    float $PointNiiiB[];
    float $FloatDirXn[] = DirectionFN( $MidVec, $FixVeci[2]);
    float $DistAddiR2 = $Di*2.0;
    float $HightD = sqrt (abs ((`pow $Di 2`) - (`pow $ObjsCirclesRad 2`)));
    float $DiX = distance2Pts( $FixVeci[2] , $PointNiii);
    float $DiY = distance2Pts( $FixVeci[2] , $PointNiiiB);
    float $ClosestPoint[];
    float $RadiOfOuter = distance2Pts($MidVec, $ClosestPoint);
    float $DirRaytoIntersectC[];
    float $CircleRayPointN[];
    float $SecondIntersectCsmall[] = lineIntersection( $MidVec, $DirRaytoIntersectC, $FixVeci[2], $norm);
    float $RadiOfInnerC = distance2Pts($MidVec,$SecondIntersectCsmall);
    float $MatrizFloati[] = MatrixToFloat($mI);
    float $x = $MidPt[0];
    float $y = $MidPt[2];
    float $b = $RadiOfInnerC;
    float $angle = 0;
    float $points[];
    float $Pi = 3.1415926535;
    float $newLocP[];
    float $VecAngle = VAnglesofThreeVec($MidPt, $FixVeci[1], $FixVeci[2]);
    float $beta = `deg_to_rad ($angle)`;
    float $sinbeta = sin($beta);
    float $cosbeta = cos($beta);
    float $valuesiiA[] = {$x,0.0,$y};
    float $valuesiAi[] = {$x, 0, $y};
    float $i;
    float $X = $x + ($a * $cosalpha * $cosbeta - $b * $sinalpha * $sinbeta);
    float $Y = $y + ($a * $cosalpha * $sinbeta + $b * $sinalpha * $cosbeta);
    float $valuesA[] = {$X, 0, $Y};
    float $MidTwoDtoElPoint = distance2Pts ($valuesiiA, $valuesA);
    float $FloatDirEpoint[] = DirectionFN($valuesiiA, $valuesA);
    float $MultDii[] = multiplyFloat($MidTwoDtoElPoint, $newLocP);
    float $AddMepi[] = AddFloats($MidPt, $MultDii);
    float $CN[];
    float $StepCycle = 0;
    float $pastA = 0.0;
    float $AddAngles = 0.0;
    float $allAngiX[];
    float $Ct[];
    float $DistancesCycle[];
    float $AngleNine = $AngleB[3];
    float $FXiI = $StepCycle;
    float $Fnumbers = 100.0/$FXiI;
    float $floatZ[];
    float $Sum;
    float $Result;
    float $Output;
    float $Correction;
    float $Error;
    float $S = (1.0/(1.0+`exp(-$x)`));
    float $Vt[];
    float $Ix = 0;
    float $AddAll = 0;
    float $Divide = $AddAll/$Ix;
    float $Fx = 0.0;
    float $DiffMathA;
    float $ZO[];
    float $PastF;
    float $ThresholdX = 1.5;
    float $pAv[] = AverageVectorPoint($Vec);
    float $n[] = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    float $FloatDirA[];
    float $Anglei;
    float $SnapR = 1.55;
    float $Smooth = 398;
    float $DiffMathB = $DistEndsii / ($LengCRV_b/100.0);
    float $DistToIntersectTOnear[];
    float $distToPlaneLoc3D[];
    float $DiffMathAm = $DistToIntersectTOnear[2]/ ($distToPlaneLoc3D[2]/100.0);
    float $DiffMathBm = $DistToIntersectTOnear[3] / ($distToPlaneLoc3D[3]/100.0);
    float $relativeDistanceA = ($DiffMathA+$DiffMathAm)/2.0;
    float $relativeDistanceB = ( $DiffMathB+$DiffMathBm)/2.0;
    float $relativeDistanceAi = ($Distance_A+$distToPlaneLoc[0])/2.0;
    float $relativeDistanceBi = ($Distance_B+$distToPlaneLoc[1])/2.0;
    float $relativeDistanceAZ = distance2Pts($VecOnPlaneA[0], $PointsA[0]);
    float $relativeDistanceBZ = distance2Pts($VecOnPlaneB[0], $PointsB[0]);
    float $DiffMathAi = $relativeDistanceAi/ ($relativeDistanceAZ/100.0);
    float $DiffMathBi = $relativeDistanceBi / ($relativeDistanceBZ/100.0);
    float $TimesMathAi = $relativeDistanceA*$relativeDistanceAZ/ ($distToPlaneLoc3D[0]/100.0);
    float $TimesMathBi = $relativeDistanceB*$relativeDistanceBZ/ ($distToPlaneLoc3D[1]/100.0);
    float $distToCurveE_AB[];
    float $lineEPointA[] = MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);
    float $Point3DA[] = $Intersect_LineB_a;
    float $Point3DAM[] = {($Point3DA[0]*-1), $Point3DA[1],$Point3DA[2]};
    float $TotalDegii[];
    float $TrackCi[];
    float $anglesMade[];
    float $EllipesPos_A[];
    float $DIff;
    float $AllAngiX_RIGHT[];
    float $AllAngiX_LEFT[];
    float $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    float $distancesEachToCurve[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    float $distancesEachToCurveB[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    float $distAz[];
    float $distBz[];
    float $FPointN_LineC[];
    float $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);
    float $XY[];
    float $XYZi[];
    float $XYZadd[];
    float $Xd;
    float $Yd;
    float $Zd;
    float $All_X[];
    float $All_Y[];
    float $All_Z[];
    float $All_ZYX[];
    float $All_ZYXDiff[];
    float $diffXYZ;
    float $Dist_3DNear = (($Dist_3D/3.0)*2.0);
    float $newOrderFloat;
    float $distTo3DCurveEnd[] = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    float $SdistTo3DCurveEnd[];
    float $Additi[];
    float $AdditiB[];
    float $AdditRi;
    float $AdditRiX;
    float $DistSnap;
    float $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    float $list[] = $listX;
    float $listItem;
    float $MatrixB[] = `MatrixToFloat($m2)`;
    float $DistToPoint = distance2Pts($Pos_A, $VecLoc);
    float $SnapD = 0.003;
    float $CamPos1[];
    float $pi = 3.1415926535;
    float $CamerasDirectionVectorNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
    float $MultDirForWard[] = multiplyFloat(-1, $CamerasDirectionVector);
    float $FloatDirectionCamNormalA[] = AddFloats($CamPos1, $MultDirCam);
    float $DirectionVectorXn[] = {-2,0,0};
    float $DirectionVectorX[] = {2,0,0};
    float $DirectionVectorY[] = {0,-2,0};
    float $DirectionVectorYn[] = {0,2,0};
    float $DirectionVectorZn[] = {0,0,-2};
    float $DirectionVectorZ[] = {0,0,2};
    float $FloatPointDirectionXn[] = AddFloats($CamPos1, $DirectionVectorXn);
    float $FloatPointDirectionX[] = AddFloats($CamPos1, $DirectionVectorX);
    float $FloatPointDirectionY[] = AddFloats($CamPos1, $DirectionVectorY);
    float $FloatPointDirectionYn[] = AddFloats($CamPos1, $DirectionVectorYn);
    float $FloatPointDirectionZn[] = AddFloats($CamPos1, $DirectionVectorZn);
    float $FloatPointDirectionZ[] = AddFloats($CamPos1, $DirectionVectorZ);
    float $AverageVecXYZsOnP[] = AverageVectorPoint($VecXYZsOnPlane);
    float $AnglesAll[];
    float $ANgnew[] = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
    float $AverageVecCurEndsP[] = AverageVectorPoint($VecCurEnds);
    float $FloatPointDirectionZniY[];
    float $CurveDirectionZiY[];
    float $FloatPointDirectionZniiY[];
    float $CurveDirectionZiiY[];
    float $CurvePsD[] = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
    float $FloatPointDirectVpoint[];
    float $CurveDirectionVpoint[];
    float $locsAi[] = lineIntersection($VecCurEnds[1], $CurveDirectionZiY, $VecCurEnds[0],  $CurveDirectionZiiY);
    float $IntersectEnds_Ai[];
    float $IntersectEnds_Bi[];
    float $distsA = $NdistA;
    float $distsB = $NdistB;
    float $ThreepointVecs[];
    float $EdgeDist;
    float $smallestDistance;
    float $distancesTo3DCurveEnd[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
    float $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
    float $distancesTo3DCurveEndi[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
    float $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
    float $XX = $VecA.x;
    float $XXX = $VecB.x;
    string $CurveItemZai[];
    string $curvesZi = $CurveItemZai[0];
    string $TestCurveC;
    string $OneCurve[] = `ls -sl`;
    string $OneCurveS = $OneCurve[0];
    string $CurveNS;
    string $NewOneCurveS;
    string $PCurvesName = "Plane";
    string $Combine;
    string $PlaneCurvA[];
    string $newPlaneCurve;
    string $LayerCurvesRangeA[] = `queryLayerRangeMembers`;
    string $newCircle[] = `MakeCIRCLE($StereoCurveZ)`;
    string $CurveItemZbi = $StereoCurveZ[1];
    string $queryLocCurveEnds3D[];
    string $AllLocs_String[] = IntArrayToStringArray($AllLocsi);
    string $EmptyStringNewOrderA[];
    string $EmptyStringNewOrderB[];
    string $NewFoundLocs[];
    string $arrayCurvesNear[];
    string $AllCirTemp[];
    string $CirTemp[];
    string $ThefirstCurve = VecArrayToCurve($Intersect_A);
    string $ThefirstCurvei = VecArrayToCurve($Intersect_B);
    string $intersectNode = `createNode curveIntersect`;
    string $curveIntersectZ = "";
    string $buffer[];
    string $param = eval("paramLocator "+ $TwoCurveA[1] + ".u[" + $buffer[7] + "]");
    string $paramANDCurve[];
    string $curvesZ[];
    string $FloatSTRING[] = FloatArrayToStringArray($intersections1A);
    string $Ax = stringArrayToString($FloatSTRING, " ");
    string $Axi = stringArrayToString($FloatSTRING, " ");
    string $SortedRangeCrv[];
    string $newNames;
    string $ExpandedStringi[];
    string $ExpandedStringiS[];
    string $ExpandedStringii[];
    string $ExpandedStringiiS[];
    string $diff[] = stringArrayRemoveDuplicates($ExpandedStringi);
    string $diffS[] = stringArrayRemoveDuplicates($ExpandedStringiS);
    string $arrayCurvesNearABM[];
    string $arrayCurvesNearS[];
    string $ExpandedStringiim[];
    string $diffB[] = stringArrayRemoveExact($arrayCurvesNearABM, $diff);
    string $diffB_s[] = stringArrayRemoveExact($arrayCurvesNearS, $diffS);
    string $interVecAx[];
    string $interVecAy[];
    string $CURVEiA[];
    string $PointOnCrv_String[] = IntArrayToStringArray($PointOnCrvIND);
    string $EmptyCA[];
    string $CURVEiAb[];
    string $paramb;
    string $PointOnCrv_Stringb[] = IntArrayToStringArray($PointOnCrvINDb);
    string $EmptyCAb[];
    string $CurveA = $diffB[$NodeCurveIndexi[$WhatCurve]];
    string $CurveB = $diffB[$NodeCurveIndex[$WhatCurveb]];
    string $newNamesCA = $CurveA;
    string $newNamesCB = $CurveB;
    string $selectionItemB = $CurveB + ".u[" +$uParam+ "]";
    string $selectionItemA = $CurveA + ".u[" +$uParam+ "]";
    string $detachCurve1[] = `detachCurve -ch off - replaceOriginal on $selectionItemB`;
    string $detachCurve2[] = `detachCurve -ch off - replaceOriginal on $selectionItemA`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size  ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = {$Newcurvez};
    string $circlesZ[];
    string $CurveBetween;
    string $K = "";
    string $curve = "curve -d 3";
    string $ThreePoints[] = { "0", "1", "2"};
    string $curvei = "curve -d 3";
    string $curveA = "curve -d 1";
    string $curveB = "curve -d 1";
    string $NewcurvezA = `eval($curveA)`;
    string $NewcurvezB = `eval($curveB)`;
    string $NewcurvezAB[];
    string $stringF[];
    string $EmptyIndx[];
    string $stringIndTr[] = IntArrayToStringArray($index);
    string $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    string $ExpandedString[];
    string $arrayCurvesNearA[];
    string $arrayCurvesNearB[];
    string $curvesZii = $ThefirstCurvei;
    string $NewOneCurveSB;
    string $StereoCircle[] = Eval3DCircleStereo( $NewArrayBEllipZ  , $EmptyVectorArrayB ,  $NewArrayAEllipZ , $EmptyVectorArrayA );
    string $queryLocCurveEnds[] = queryLocOnLivePlaneBLayer();
    string $queryLocCurveEndsOLD[] = $queryLocCurveEnds;
    string $NearCurvesEnds[];
    string $BothCurves[];
    string $LocA = $queryLocCurveEnds[$NearestInt[0]];
    string $LocB = $queryLocCurveEnds[$NearestIntB[0]];
    string $LocName;
    string $Loc_AorB = "";
    string $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    string $AllarrayCurvesNear[];
    string $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    string $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    string $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    string $CurvesV[];
    string $LocsV[];
    string $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    string $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    string $VanishingLOC[];
    string $DirectionsZ[] = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    string $Alll = "";
    string $AllStrings[];
    string $stringFloat[] = FloatArrayToStringArray($EulerAngleA);
    string $EmptyIndxNewOrder[];
    string $BestThree[];
    string $CirTempi[] = `ls -sl`;
    string $newCurveii;
    string $CurveAv[];
    string $newNamesResultA1;
    string $ThreeDCurvesNear[];
    string $CurveItemAa[];
    string $StringAllNearA[];
    string $newNamesResultAx = substituteAllString($newNames, "Plane", "");
    string $arrayCurvesNearA1[];
    string $SetCol = `setAttr ($VanishingLOC[size($VanishingLOC)-1]+".overrideColor ") 6 `;
    string $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    string $LocNames[];
    string $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
    vector $CurveCollectVec[];
    vector $nevVec[] = NewVecOrderWithINTKey($NewIndex,$CurveCollectVec);
    vector $vectorZnewX[];
    vector $EmptyVectorArrayA[];
    vector $AllLocPositionsZ[];
    vector $AllPlaneLocPositionZ[] = VecPointsToCameraPlane($AllLocPositionsZ);
    vector $PositionsZ_A[];
    vector $AllLocPositionsZi[];
    vector $VecCurEndsa[] = VecCurveEnds({$CurveItemZai});
    vector $VecCurEndsb[] = VecCurveEnds({$CurveItemZbi});
    vector $PositionsZ_B[];
    vector $VecPtsMirrorA[];
    vector $VecPtsMirrorB[];
    vector $VecPtsMirrorEnds_A[];
    vector $VecPtsMirrorEnds_B[];
    vector $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
    vector $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);
    vector $Vecbv[];
    vector $Vecbvi[];
    vector $NewVecENDsi[];
    vector $CRV_ENDSi[];
    vector $CRV_ENDSii[];
    vector $DDirEpipolXYZ[];
    vector $AllEpipolXYZ[];
    vector $EpipolD[];
    vector $LineMidi;
    vector $NewDirZi;
    vector $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    vector $Intersect_LineB_a;
    vector $Intersect_LineB_b = FloatToVec (lineIntersection($MidCurveB, $DDirEpipolA, $VecCurEndsa[1],$FloatDirEpipolB));
    vector $IntersectEnds_A[];
    vector $Intersect_A[];
    vector $IntersectForce_A[];
    vector $IntersectAverage_A[];
    vector $PositionsZ_Ai[];
    vector $PositionsZ_Bi[];
    vector $LocCurveEndsVec3D[] = PointArray($queryLocCurveEnds3D);
    vector $PointsA[];
    vector $PointsB[];
    vector $VecOnPlaneA[];
    vector $VecOnPlaneB[];
    vector $LocOnPlaneVec[] = PointArray($NewFoundLocs);
    vector $Intersect_B[];
    vector $LocSMirror[];
    vector $AllNearestVecCA[];
    vector $VecPointOnCrv[];
    vector $NearestVecCA = $VecPointOnCrv[$New_PointOnCrvIND_A[0]];
    vector $AllNearestVecCAb[];
    vector $VecPointOnCrvb[];
    vector $NearestVecCAb = $VecPointOnCrvb[$New_PointOnCrvIND_Ab[0]];
    vector $CUT_CrvMirrorEnds_A[] = VecPtsToZMirrorPts({$NearestVecCAb});
    vector $CUT_CrvIntersectEnds_A = FloatToVec (lineIntersectionF($CamPos_A, $NearestVecCA, $CamPos_M, $CUT_CrvMirrorEnds_A[0]));
    vector $CUT_CrvIntersectMirrorEnds_A[] = VecPtsToZMirrorPts({$CUT_CrvIntersectEnds_A});
    vector $VecCUT_CrvA = FloatToVec (FloatPointsToCamPlane($VecIntCB));
    vector $VecCUT_CrvB = FloatToVec (FloatPointsToCamPlane($VecIntCA));
    vector $VlocA;
    vector $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    vector $VecLineDir = PositiveDir($DirectionLineF);
    vector $VecLineDirM = $VecLineDiri-$VecLineDir;
    vector $tan;
    vector $norm;
    vector $bi;
    vector $Avec[];
    vector $AVvects[];
    vector $Aver;
    vector $CurveVectors[];
    vector $Ui = FloatToVec($p1p2);
    vector $Vi = FloatToVec($p1p3);
    vector $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;
    vector $U1 = TwoVecsOrFloats($point2, $point1);
    vector $V1 = TwoVecsOrFloats($point3, $point1);
    vector $U2 = TwoVecsOrFloats($point3, $point1);
    vector $V2 = TwoVecsOrFloats($point2, $point1);
    vector $U3 = TwoVecsOrFloats($point1, $point3);
    vector $V3 = TwoVecsOrFloats($point2, $point3);
    vector $normalV[];
    vector $DirNormi = FloatToVec ($FDirNorAi);
    vector $MidVec = FloatToVec( $MidPt);
    vector $ABC[];
    vector $DirecOfPointABi = FloatToVec ( DirectionFN($FixVeci[0], $FixVeci[1]));
    vector $VecH[];
    vector $aV = FloatToVec($valuesA);
    vector $bV = FloatToVec($valuesiAi);
    vector $VecAverage = FloatToVec($AverageVecCurve);
    vector $SharpValuesTan[];
    vector $FlushVectors[];
    vector $valuesTan[];
    vector $valuesTanSpace[];
    vector $valuesTanPastSpace;
    vector $valuesTanPast;
    vector $DeepPastTan;
    vector $DeepPast;
    vector $threeVecsT[];
    vector $CurrentVecT;
    vector $OnPlane[];
    vector $eachVecLine;
    vector $Xdirect;
    vector $Ydirect;
    vector $Zdirect;
    vector $XYZdirect[];
    vector $NewDirectionZ;
    vector $XYZdirectL[];
    vector $LineDirect_3D;
    vector $IntersectEnds_Ax[];
    vector $PositionsZ_Bii[];
    vector $PositionsZ_Aii[];
    vector $PtsMirrorAi[];
    vector $LoCz_3D[];
    vector $TXI = << -1.0 , 1.0, 1.0>>;
    vector $UnconnectedEnds[];
    vector $Xdirection = << 1.0,0.0,0.0>>;
    vector $Intersect_BX[];
    vector $PairVectors[];
    vector $EpipolXLine = DirectionFN( $MidEpipolPosFCam, $PairVectors[$PairInt[0]]);
    vector $EndrEndsa[] = VecCurveEnds({$ThefirstCurvei});
    vector $EmptyVectorArrayB[];
    vector $Dir_VecMAIN;
    vector $threeVecs[];
    vector $Dir_VecA;
    vector $Positions[];
    vector $VecCurEnds[] = VecCurveEnds({$TempCrv});
    vector $LocCurveEndsVec[] = PointArray($queryLocCurveEnds);
    vector $EndSnapAndEndProject[];
    vector $endNotNearZ[];
    vector $NearEndZ;
    vector $Loc3D_Vec[] = PointArray($NewFoundLocs );
    vector $ALLLoc3D_VecAB[] = PointArray($AllarrayCurvesNear);
    vector $ReducedVecAB[];
    vector $ALLLoc3D_Vec[];
    vector $MovedEndPointPlane[] = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    vector $Dir_CamRay;
    vector $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    vector $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);
    vector $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    vector $One;
    vector $each;
    vector $NearPointsXYZ[];
    vector $ReducedVec[];
    vector $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    vector $VecLineDirMi;
    vector $PointN_LineXYZ;
    vector $SnapN;
    vector $SnapPlaceN;
    vector $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);
    vector $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    vector $Points3DPair_And_2DPair[];
    vector $Crv_Pts[];
    vector $MirrorAcrossPlaneVecs[] = VecMultMatrixMirror($Crv_Pts);
    vector $FLoatPointA[];
    vector $DirLine = DirectionFN( $VecLoc, $Pos_A);
    vector $TranstatedVecs[];
    vector $PointN_Line = ClosestPoint2LineVec($Dir_CamRay, $MovedEndPointPlane[0], $Loc3D_Vec[0]);
    vector $PointN_LineB = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $PointN_Line);
    vector $PositionsZ_Ax[];
    vector $ZYplaneMatrix[];
    vector $VecDirection_A_XYZ[];
    vector $VecDirectionXYZ[];
    vector $VecXYZsOnPlane[] = VecPointsToCameraPlane($VecXYZs);
    vector $VecXYZsOnPlaneiY[];
    vector $VecXYZsOnPlaneiiY[];
    vector $VecXYZsOnPlaneVpoint[];
    vector $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
    vector $VIntersectEnds_A[];
    vector $ObjLoc3DCurv[];
    vector $LocCurveEndsVec_3D[] = PointArray($arrayCurvesNearA1);
    vector $PointN_LineA = ClosestPoint2LineVec($LineDirect_3D, $VecCurEnds[0], $LocCurveEndsVec_3D[0]);
    vector $NearVecPts[];
    vector $PositionsZ_Aiix[];
    vector $VecTest[];
    vector $FistAndSecond[];
    vector $VecA = $FistAndSecond[0];
    vector $VecB = $FistAndSecond[1];
    vector $ReversePositionsZ_Ai[] = ReverseVectorArray($PositionsZ_Ai);
    vector $XIntersect_Ax[];
    vector $p = `xform -q -ws -t "LiveSurfaceB"`;
    vector $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    ///////////////////////////////
    $CurveItemZai[0] = $curveItemC;
    $Arc = `arclen $CurveItemZai[0]`;
    $Arc = $Arc /3.5;
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s $Arc -d 3 -tol 0.05 $CurveItemZai[0];
    $curvesZi = $CurveItemZai[0];
    $CurveCollectVec = CurvatureUtilityAngles($curvesZi, 130, $angleZi, $TotalDegi,$Low_X, $TrackC);
    clear $NewIndex;
    $NewIndex  = SortNumbersIntIndex($angleZi);
    $nevVec = NewVecOrderWithINTKey($NewIndex,$CurveCollectVec);
    $vectorZnewX =$nevVec;
    $Xv = 0;
    while($Xv < 22){
    $vectorZnewX = AverageCurveVec($vectorZnewX);
    $Xv++;
    }
    $TestCurveC = VecArrayToCurveB($vectorZnewX);
    ResetTransEachSL;
    // Error: line 70: No object matches name: layer1 //
    createDisplayLayer -name "layer1" -number 1 -empty;
    // Problem with return values above N kinds.. maya errors
    ////////////////////////////////////////////////



    $OneCurve = `ls -sl`;
    $OneCurveS = $OneCurve[0];
    $TFNS = 1;
    $CurveNS = IScircleTF($OneCurveS,$TFNS);
    print $TFNS;


    if($TFNS==1){
    $NewOneCurveS = EllipesSketchFitting($CurveNS, $EmptyVectorArrayA);
    }else{  $NewOneCurveS = $OneCurveS;}

    print $EmptyVectorArrayA;

    select -r $NewOneCurveS;


    $Ellipes_A = `xform -q -ws -t $NewOneCurveS`;



    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);

    Loc $MidEpipolPosFCam;


    for($EachVec in $EmptyVectorArrayA){

    //if line betweens average centor  is not the line between N vec point from curve find its angle becuase if the vector point on curve
    // if it happens to be exactly on the line i would be tring to find the angle  of three point of a line which is zero........

    $AngleX[`size($AngleX)`] = AngleofTwoLines($EachVec,$MidEpipolPosFCam,$Ellipes_A ,$MidEpipolPosFCam);


    }

    clear $NewIndex;
    $NewIndex  = SortNumbersIntIndex($AngleX);

    Loc  $EmptyVectorArrayA[$NewIndex[0]];
    Loc  $EmptyVectorArrayA[$NewIndex[1]];

    $IndexTrack = $NewIndex;
    $IndexTrack = ReverseIntArray($IndexTrack);
    Loc  $EmptyVectorArrayA[$IndexTrack[0]];
    Loc  $EmptyVectorArrayA[$IndexTrack[1]];

    print $IndexTrack[0]
    161;

    print $AngleX;




    */



    // need for some reason
    createDisplayLayer -name "layer1" -number 1 -empty;

    proc float AngleofTwoLines(vector $vecA,vector $vecB,vector $vecC,vector $vecD){
    $AngleB = EulerAngB((DirectionFN($vecA, $vecB)), (DirectionFN($vecC, $vecD)));
    $angleA = $AngleB[3];
    return $angleA;
    }





    proc CurvesToPlane(string $CurveItemZ[]){
    global string $PlaneCurveS[];
    $PCurvesName = "Plane";
    $CountN = 0;
    for ($eachCurve in $CurveItemZ){
    clear $AllLocPositionsZ;
    $AllLocPositionsZ = VecCurveEps( $eachCurve );
    $AllPlaneLocPositionZ = VecPointsToCameraPlane($AllLocPositionsZ);
    $newPlaneCurve = VecArrayToCurve($AllPlaneLocPositionZ);
    //$Combine = ($PCurvesName+$eachCurve);
    //$newPlaneCurve = `rename $newPlaneCurve  $Combine`;
    ResetTranslation({$newPlaneCurve});
    $PlaneCurvA[$CountN]= $newPlaneCurve;
    $CountN++;
    }
    $PlaneCurveS = $PlaneCurvA;

    }

    /*
    global string $PlaneCurveS[];

    $LayerCurvesRangeA = `queryLayerRangeMembers`;
    CurvesToPlane($LayerCurvesRangeA);
    select -r $PlaneCurveS;

    //setAttr "locator1.scaleX" 0.085;
    */

    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;



    proc StereoCurveZ(string $CurveItemZai, string $CurveItemZbi){

    /*
    temp debug

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemZai );

    $AverageVecCurve = AverageVectorPoint($PositionsZ_A);
    Loc $AverageVecCurve;
    $CamDirVecNormalA = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);



    $TrueorFalseCircle = `IsCircle`;
    if ($TrueorFalseCircle == 1){
    $newCircle = `MakeCIRCLE($StereoCurveZ)`;
    }
    //////////////////////////////////////////////////////////////

    $StereoCurveZ= `ls -sl`;
    $CurveItemZai = $StereoCurveZ[0];
    $CurveItemZbi = $StereoCurveZ[1];

    global string $PlaneCurveS[];

    $LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;

    CurvesToPlane($LayerCurvesRangeA);
    select -r $PlaneCurveS;

    clear $AllLocPositionsZi;
    $AllLocPositionsZi = VecCurveEps( $eachCurve );



    */


    global string $StereoCurveZ[];
    global string $VanishingPointsLinesTempGuides[];
    global int $addNumbersA;
    global float $VanishingPointGlobal[];

    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;


    $VecCurEndsa = VecCurveEnds({$CurveItemZai});
    $VecCurEndsb = VecCurveEnds({$CurveItemZbi});

    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 1 -tol 0.05 $CurveItemZai;
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 1 -tol 0.05 $CurveItemZbi;
    //gathering all Curve Points

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemZai );
    clear $PositionsZ_B;
    $PositionsZ_B = VecCurveEps($CurveItemZbi );

    // mirroring across ZY plane or X axis
    clear $VecPtsMirrorA;
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    clear $VecPtsMirrorB;
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
    $CamDirVecNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $MultDirCam = multiplyFloat(-1, $CamDirVecNormal);
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;

    clear $VecPtsMirrorEnds_A;
    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    clear $VecPtsMirrorEnds_B;
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);

    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);

    //Key Element
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);

    // Loc $MidEpipolPosFCam;
    // Loc $CamPos_A;

    $EpipolPosCamM = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;
    //float $MidPosFCam[]= FloatPointsToCamPlane($centerCam);
    $MidPosFCam = $CamPlane1;

    $FloatDirEpipol = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    $FloatDirEpipolB = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);

    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    //Loc $PlaneEpipolXx;
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    //Loc $PlaneEpipolYx;
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);
    //Loc $PlaneEpipolZx;

    // The end Points of the first curve Drawn to the Epipol of CAMERA one //##
    $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
    $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);

    // Loc $PointN_Epi;
    // Loc $PointN_EpiB;
    //Loc $VecCurEndsb[0];


    //below I use a if statement to weigh if the two curves start and end points are corrosponding to its mirror symetry
    $DistTOEpipol_CurEndA = distance2Pts($PointN_Epi, $VecCurEndsb[0]);
    $DistTOEpipol_CurEndB = distance2Pts($PointN_EpiB, $VecCurEndsb[0]);

    // if( $DistTOEpipol_CurEndA > $DistTOEpipol_CurEndB){ //

    //curve2points ($PointN_Epi, $VecCurEndsb[0]);
    //curve2points ($PointN_EpiB, $VecCurEndsb[0]);

    $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
    $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
    $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;


    $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
    // $BCurEndBNN -= $BCurEndBiiAdd ;
    $BCDiff = abs($BCurEndB - $BCurEndBNN);


    $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd ;
    $BCDiffi = abs($BCurEndB - $BCurEndBNNi);
    //int $IntIfNearZero = equivalentTol($BCurEndB, $BCurEndBNNi,  0.0001);
    $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);

    //Loc $PointN_Epi;
    //Loc $PointN_EpiB;

    $FloatDirEndPtsA = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
    $EulerAngleA = EulerAngB($FloatDirEndPtsA, $FloatDirEpipol);
    $EulerAngle_A = $EulerAngleA[3];
    $FloatDirEndPtsB = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
    $EulerAngleB = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);
    $EulerAngle_B = $EulerAngleB[3];

    $FloatDirEndPtsAi = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
    $EulerAngleAi = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);
    $EulerAngle_Ai = $EulerAngleAi[3];
    $FloatDirEndPtsBi = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
    $EulerAngleBi = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);
    $EulerAngle_Bi = $EulerAngleBi[3];

    print ($EulerAngle_A+"\n");
    print ($EulerAngle_B+"\n");
    print ($EulerAngle_Ai+"\n");
    print ($EulerAngle_Bi+"\n");

    $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
    $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;


    $Vecbv  = $VecCurEndsa;
    $Vecbvi = $VecCurEndsb;
    $IfTrue = FindLineCross( $Vecbv , $Vecbvi );
    $weighedtFindings = 0;
    $weighedtFindingsZ = 0;
    $weighedtFindingsN = 0;


    if($IfTrue==0){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;
    }



    if($IntIfNearZero==1){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}


    if($EulerAngle_AB<$EulerAngle_AiBi){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}

    print ($weighedtFindings+"\n");
    print ($weighedtFindingsZ+"\n");
    print ($weighedtFindingsN+"\n");

    ////////////////PLace find otrtho Curve here


    $LengCRV_a = `arclen $CurveItemZai`;

    $CRV_ENDSi = $VecCurEndsa;
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $PerDiff = percent_of( $LengCRV_a, $DistEndsi);

    $LengCRV_b = `arclen $CurveItemZbi`;
    $CRV_ENDSii = $VecCurEndsb;
    $DistEndsii = distance2Pts($CRV_ENDSii[0], $CRV_ENDSii[1]);
    $PerDiffii = percent_of( $LengCRV_b, $DistEndsii);

    $PerDiffSum = ($PerDiff+$PerDiffii)/2.0;
    $triggerStraitCRV = 0;

    //START of StraitCurve//

    if( $PerDiffSum<5.5){

    $triggerStraitCRV=1;


    $DDirEpipol = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
    $MidCurveA = MidPoint($VecCurEndsa[0], $VecCurEndsa[1]);
    $MidCurveB = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);

    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);


    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);

    //PositiveDirectionLine
    //    Loc $MidEpipolPosFCam;
    //$VecCurEndsa


    $EpipolD = $DDirEpipolXYZ;

    $Trueii = 0;
    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    //print $IsOrthoLineTrue;
    //print $AxisOrthoLine;
    //print $LineMidi;
    //print $NewDirZi;
    //found Direction

    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];


    if($IsOrthoLineTrue==1){


    $NewVecENDsi  = makeCurvePointDirectionLengthN($DistEndsi, $NewDirZi, $MidCurveA);
    //delete;

    $VecCurEndsa[0] = $NewVecENDsi[0];
    $VecCurEndsa[1] = $NewVecENDsi[1];

    if($AxisOrthoLine!=0){

    $FloatDirEpipol = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    $FloatDirEpipolB= DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
    //float $DistEndsii = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    $MidCurveB = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);

    $DDirEpipolB = DirectionFN($MidCurveB, $FoundEpipol);
    $DDirEpipolA = DirectionFN($FoundEpipol,$MidCurveB);


    $Intersect_LineB_a = FloatToVec (lineIntersection($MidCurveB, $DDirEpipolB, $VecCurEndsa[0],$FloatDirEpipol));
    $Intersect_LineB_b = FloatToVec (lineIntersection($MidCurveB, $DDirEpipolA, $VecCurEndsa[1],$FloatDirEpipolB));
    //Loc $Intersect_LineB_a;
    //Loc $Intersect_LineB_b;

    $VecCurEndsb[0] = $Intersect_LineB_a;
    $VecCurEndsb[1] = $Intersect_LineB_b;

    clear $PositionsZ_A;
    clear $PositionsZ_B;
    clear $VecPtsMirrorEnds_A;
    clear $VecPtsMirrorEnds_B;
    clear $VecPtsMirrorA;
    clear $VecPtsMirrorB;

    $PositionsZ_A[0] =  $NewVecENDsi[0];
    $PositionsZ_A[1]= FloatToVec (MidPoint($NewVecENDsi[0],$NewVecENDsi[1]));
    $PositionsZ_A[2] =  $NewVecENDsi[1];

    $PositionsZ_B[0] =  $Intersect_LineB_a;
    $PositionsZ_B[1]= FloatToVec (MidPoint($Intersect_LineB_a, $Intersect_LineB_b));
    $PositionsZ_B[2] =  $Intersect_LineB_b;

    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);

    }



    }
    }

    if($weighedtFindingsZ<$weighedtFindingsN){

    cycleBackgroundColor;
    //reverseCurve  -ch 0 -rpo 1 -cos on $CurveItemZai;
    //$VecCurEndsa = ReverseVectorArray($VecCurEndsa);
    $PositionsZ_B = ReverseVectorArray($PositionsZ_B);
    // $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
    $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);

    }




    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;

    clear $IntersectEnds_A;
    $iia = 0;
    clear $Intersect_A;
    clear $Intersect_ATwo;
    clear $IntersectForce_A;
    clear $IntersectAverage_A;



    if(`size( $queryLocCurveEnds3D)`>3){

    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);

    for ($eachVecx in  $VecCurEndsa)
    {

    $IntersectEnds_A[$iia] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsa[$iia], $CamPos_M, $VecPtsMirrorEnds_B[$iia]));
    $iia++;
    }

    ///////// find nearest for both curve ends on one curve with those two points they become four points mirrored X

    $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[0]);
    $AllLocsi = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    $AllLocs_String = IntArrayToStringArray($AllLocsi);
    $newOrdersZA = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    $EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
    $New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
    $Near_index_A = $New_AllLocs_A[0];
    $Distance_A = $distToCurveE_A[$Near_index_A];
    $Found_pt_A = $LocCurveEndsVec3D[$Near_index_A];
    $newOrdersZAM = $Found_pt_A;
    $newOrdersZAM[0] = $Found_pt_A[0] *-1;

    $distToCurveE_B = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[1]);
    $newOrdersZB = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    $EmptyStringNewOrderB = ReverseStringArray($EmptyStringNewOrderB);
    $New_AllLocs_B = ArrayToIntList($EmptyStringNewOrderB);
    $Near_index_B = $New_AllLocs_B[0];
    $Distance_B = $distToCurveE_B[$Near_index_B];
    $Found_pt_B = $LocCurveEndsVec3D[$Near_index_B];
    $newOrdersZBM = $Found_pt_B;
    $newOrdersZBM[0] = $Found_pt_B[0] *-1;

    $PointsA[0] = FloatToVec($Found_pt_A);
    $PointsA[1] = FloatToVec($Found_pt_B);
    $PointsB[0] = FloatToVec($newOrdersZAM); // negative mirror of first endpoint of first curve
    $PointsB[1] = FloatToVec($newOrdersZBM);
    // vec points to plane
    //them matrix transformation
    //  know that the camera may be in the positive or negative x axis ... try to make it so that
    //  it will not matter what order  the curve is drawn for the first curve might represent the positive axis or
    // the negitive where is the camera is what you know first  .. what you know second is what the first curve represents
    //Loc $PointsA[0];


    $VecOnPlaneA = VecPointsToCameraPlane($PointsA);
    $VecOnPlaneB = VecPointsToCameraPlane($PointsB);

    //print $Distance_A;
    //print $Distance_B;

    $triggerNoTrans = 0;

    $NewFoundLocs[0] = $queryLocCurveEnds3D[$Near_index_A];
    $NewFoundLocs[1] = $queryLocCurveEnds3D[$Near_index_B];
    $arrayCurvesNear[0] = ("Plane"+$NewFoundLocs[0]);
    $arrayCurvesNear[1] = ("Plane"+$NewFoundLocs[1]);
    $NewFoundLocs = $arrayCurvesNear;

    $LocOnPlaneVec = PointArray($NewFoundLocs);
    $distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocOnPlaneVec[0]);
    $distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocOnPlaneVec[1]);
    print $distToPlaneLoc;



    //if($distToPlaneLoc[0]<0.0025){

    if(!($Distance_A<2.0005)){
    //if((!($Distance_B<1.0005))&&(!($distToPlaneLoc[1]<0.00195))){
    $VecOnPlaneA[0] = $VecCurEndsa[0];
    $VecOnPlaneB[0] = $VecCurEndsb[0];
    PAUSE;
    $triggerNoTrans++;
    }

    //}

    //if($distToPlaneLoc[1]<0.0025){

    if(!($Distance_B<2.0005)){
    //if((!($Distance_B<1.0005))&&(!($distToPlaneLoc[1]<0.00195))){
    $VecOnPlaneA[1] = $VecCurEndsa[1];
    $VecOnPlaneB[1] = $VecCurEndsb[1];
    PAUSE;
    $triggerNoTrans++;
    }

    //}


    if($triggerNoTrans!=2){

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemZai );



    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEndsa,$VecOnPlaneA, $PositionsZ_A);



    $PositionsZ_Bi = Matrix_Curve_TranslationCC($VecCurEndsb, $VecOnPlaneB, $PositionsZ_B);




    clear $VecPtsMirrorA;
    $VecPtsMirrorA= VecPtsToZMirrorPts( $PositionsZ_Ai);
    clear $VecPtsMirrorB;
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_Bi);
    $PositionsZ_A = $PositionsZ_Ai;
    $PositionsZ_B = $PositionsZ_Bi;
    cycleBackgroundColor;
    }

    }


    //////////////////////////////////////////////////////////////////////////////////////
    //Closest Point to Line !! is you want to make it more true to the curve drawn.
    //cool!
    ///////////////      ///////////////
    ///////////////      ///////////////

    //$IntersectEnds_A[$iia] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsa[$iia], $CamPos_M, $VecPtsMirrorEnds_B[$iia]));
    //ADDED
    //$PointToCamDir = DirectionFN($CamPos_A, $VecCurEndsa[$iia]);

    //$IntersectForce_A[$iia] = FloatToVec (ClosestPoint2Line($PointToCamDir, $CamPos_A,  $IntersectEnds_A[$iia]));
    //$Intersect_ATwo[0] = $IntersectEnds_A[$iia];
    //$Intersect_ATwo[1] = $IntersectForce_A[$iia];
    //$IntersectAverage_A[$iia] =  FloatToVec(AverageVectorPoint($Intersect_ATwo));
    ///
    //$iia++;


    $iiz = 0;
    clear $IntersectEnds_A;
    $iia = 0;
    clear $Intersect_A;
    clear $Intersect_ATwo;
    clear $IntersectForce_A;
    clear $IntersectAverage_A;


    $colori[`size($colori)`] = 13;
    $colori[`size($colori)`] = 14;


    for ($eachVecx in  $VecPtsMirrorA)
    {
    $Intersect_A[`size($Intersect_A)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_B[$iiz], $CamPos_M, $VecPtsMirrorA[$iiz]));
    //DEMO
    if((fmod($iiz, 12))== 2){
    curve2points($PositionsZ_B[$iiz], $Intersect_A[`size($Intersect_A)`-1]);
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[0]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    curve2points($VecPtsMirrorA[$iiz], $Intersect_A[`size($Intersect_A)`-1]);
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[1]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    }

    $iiz++;
    }


    delete $AllCirTemp;

    $ThefirstCurve = VecArrayToCurve($Intersect_A);
    //string $ThefirstCurve = VecArrayToCurve($IntersectAverage_A);
    modifySelectedCurves smooth 18 0;
    //  string $NewCurveA[] = SmoothCurvature3(6);
    //rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 28 -d 1 -tol 0.05 $ThefirstCurve;
    ///////////////
    /*
    $iiz = 0;
    clear $Intersect_B;
    /////
    ////////
    for ($eachVecxi in  $VecPtsMirrorA)
    {
    $Intersect_B[`size($Intersect_B)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_A[$iiz], $CamPos_M,   $VecPtsMirrorB[$iiz]));
    $iiz++;
    }
    */
    clear $Intersect_B;
    $Intersect_B= VecPtsToZMirrorPts($Intersect_A);
    $ThefirstCurvei = VecArrayToCurve($Intersect_B);
    modifySelectedCurves smooth 18 0;
    // string $NewCurveB[] = SmoothCurvature3(6);
    //rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 28 -d 1 -tol 0.05 $ThefirstCurvei;
    ///////////////      ///////////////
    ///////////////      ///////////////
    //offsetCurve  -ch on -rn false -cb 2 -st true -cl true -cr 0 -d 1 -tol 0.01 -sd 5 -ugn false  $ThefirstCurve ;
    //offsetCurve  -ch on -rn false -cb 2 -st true -cl true -cr 0 -d 1 -tol 0.01 -sd 5 -ugn false  $ThefirstCurvei ;

    delete $VanishingPointsLinesTempGuides;
    clear $VanishingPointsLinesTempGuides;
    delete $CurveItemZai $CurveItemZbi;
    clear $StereoCurveZ;
    $addNumbersA =0;
    clear $VanishingPointGlobal;
    ResetTranslation({$ThefirstCurve});
    CurveIndexVecTracking({$ThefirstCurve});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1
    $ThefirstCurve;
    ResetTranslation({$ThefirstCurvei});
    CurveIndexVecTracking({$ThefirstCurvei});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1
    $ThefirstCurvei;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    }

    //getAttr "ZCURVEModelingCAMShape.centerOfInterest" 559.102043;
    //-worldCenterOfInterest

    //getAttr "ZCURVEModelingCAMShape.worldCenterOfInterest"
    //camera -q -worldCenterOfInterest "ZCURVEModelingCAMShape"
    //////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    /*
    temp debug

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemZai );

    $AverageVecCurve = AverageVectorPoint($PositionsZ_A);
    Loc $AverageVecCurve;
    $CamDirVecNormalA = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);



    $TrueorFalseCircle = `IsCircle`;
    if ($TrueorFalseCircle == 1){
    $newCircle = `MakeCIRCLE($StereoCurveZ)`;
    }
    //////////////////////////////////////////////////////////////

    proc string CreateCrvInter( string $crv1, string $crv2,
    {
    // Create the intersect node
    $intersectNode = `createNode curveIntersect`;
    setAttr ($intersectNode + ".tolerance") $tolerance;
    connectAttr ($crv1 + ".worldSpace") ($intersectNode + ".inputCurve1");
    connectAttr ($crv2 + ".worldSpace") ($intersectNode + ".inputCurve2");
    setAttr ($intersectNode + ".useDirection") $useDir;
    // Check if there are any intersections.  If not, then delete
    // the node and return nothing.
    //
    $intersections1 = `getAttr ($intersectNode + ".parameter1")`;
    $numIparms = size($intersections1);
    if( $numIparms == 0 ) {
    delete $intersectNode;
    $intersectNode = "";
    } else {
    $intersections2 = `getAttr ($intersectNode + ".parameter2")`;
    }
    // remenber to
    delete $intersectNode;
    return $intersectNode;
    }


    proc int [] CreateCrvInterTF( string $crv1, string $Allcrv2[],
    {

    $TF = 0;
    // Create the intersect node
    for($eachCurve in $Allcrv2){
    $intersectNode = `createNode curveIntersect`;
    setAttr ($intersectNode + ".tolerance") $tolerance;
    connectAttr ($crv1 + ".worldSpace") ($intersectNode + ".inputCurve1");
    connectAttr ($eachCurve + ".worldSpace") ($intersectNode + ".inputCurve2");
    setAttr ($intersectNode + ".useDirection") $useDir;
    // Check if there are any intersections.  If not, then delete
    // the node and return nothing.
    $intersectionsA = `getAttr ($intersectNode + ".parameter1")`;
    $numIparms = size($intersectionsA);
    if( $numIparms == 0 ) {
    $TF=0;
    } else {
    $TF=1;
    $intersections1A = `getAttr ($intersectNode + ".parameter1")`;
    $intersections1B = `getAttr ($intersectNode + ".parameter2")`;
    AppendFloatArray($intersections1,$intersections1A);
    AppendFloatArray($intersections1,$intersections1B);
    print $eachCurve;
    }
    $CurveIndexInter[`size($CurveIndexInter)`] = $TF;
    delete $intersectNode;
    }
    // remenber to

    return $CurveIndexInter;
    }




    $StereoCurveZ= `ls -sl`;
    $CurveItemZai = $StereoCurveZ[0];
    $CurveItemZbi = $StereoCurveZ[1];

    // $VanishingPointsLinesTempGuides = VanishingCurves({$StereoCurveZ[0]});


    global string $PlaneCurveS[];
    $LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;
    CurvesToPlane($LayerCurvesRangeA);
    select -r $PlaneCurveS;

    $NodeCurveIndex = CreateCrvInterTF($CurveItemZai, $PlaneCurveS,0,0.001,$interVecA, $interVecB);
    print $NodeCurveIndex;



    print $TwoCurveA;
    $intersectCURVEiA = `listRelatives -children  $TwoCurveA[0]`;
    $intersectCURVEiB = `listRelatives -children  $TwoCurveA[1]`;

    ///
    $curveIntersectZ = "";
    $curveIntersectZ = `curveIntersect -ch 0 -tolerance 0.00001 $CurveItemZai $CurveItemZbi`;
    $curveIntersectZ = `curveIntersect -ch 0 -tolerance 0.00001 $TwoCurveA[0] $TwoCurveA[1]`;
    $numTokens = `tokenize $curveIntersectZ " "  $buffer`;
    print $buffer;
    $param = eval("paramLocator "+ $TwoCurveA[1] + ".u[" + $buffer[7] + "]");
    $intersectposA = `pointPosition -w  $param`;
    Loc $intersectposA;


    ///

    $paramANDCurve  = `paramToCurvePts2({$param})`;
    delete $param;
    $curvesZ = `detachCurve -ch 1 -cos on -rpo 1  $paramANDCurve`;

    print $NodeCurveA;
    print $NodeCurveA;

    proc float[] NewFloatOrderWithIndexKey(int $IndexTrack[], float $NewFloat[]){
    for($eachV in $IndexTrack){
    $newOrderVec[`size($newOrderVec)`] = $NewFloat[$eachV];
    }
    return $newOrderVec;
    }


    select -r Planecurve12 ;
    select -r curve69 ;

    $intersectNode = `createNode curveIntersect`;
    setAttr ($intersectNode + ".tolerance") 0.001;
    connectAttr ("curve69" + ".worldSpace") ($intersectNode + ".inputCurve1");
    connectAttr ("Planecurve12" + ".worldSpace") ($intersectNode + ".inputCurve2");
    setAttr ($intersectNode + ".useDirection") 0;
    $intersectionsA = `getAttr ($intersectNode + ".parameter2")`;
    $param = eval("paramLocator "+"Planecurve12"+".u["+$intersectionsA[0]+"]");

    */

    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////

    proc int [] CreateCrvInterTF( string $crv1, string $Allcrv2[],
    {

    $TF = 0;
    // Create the intersect node

    $COuntN = 0;
    for($eachCurve in $Allcrv2){
    $intersectNode = `createNode curveIntersect`;
    //listAttr $intersectNode;
    setAttr ($intersectNode + ".tolerance") $tolerance;
    connectAttr ($crv1 + ".worldSpace") ($intersectNode + ".inputCurve1");
    connectAttr ($eachCurve + ".worldSpace") ($intersectNode + ".inputCurve2");
    setAttr ($intersectNode + ".useDirection") $useDir;
    $intersectionsA = `getAttr ($intersectNode + ".parameter1")`;
    $numIparms = size($intersectionsA);
    if( $numIparms == 0 ) {
    $TF=0;
    } else {
    $TF=1;
    $intersections1A = `getAttr ($intersectNode + ".parameter2")`;
    print $intersections1A;
    $FloatSTRING = FloatArrayToStringArray($intersections1A);
    $Ax = stringArrayToString($FloatSTRING, " ");
    /*
    $intersections1A = `getAttr ($intersectNode + ".parameter2")`;
    print $intersections1A;
    $FloatSTRING = FloatArrayToStringArray($intersections1A);
    $Axi = stringArrayToString($FloatSTRING, " ");
    $Ax += (" "+$Axi);
    */
    $intersections1[`size($intersections1)`] = $Ax;
    //AppendFloatArray($intersections1,$intersections1A);
    //print $eachCurve;
    $CurveIndexInter[`size($CurveIndexInter)`] = $COuntN;
    }

    delete $intersectNode;
    $COuntN++;
    }
    // remenber to

    return $CurveIndexInter;
    }

    proc int [] FindEqualVec(vector $VectorA[], vector $Vec){
    $CountN = 0;
    for($eachMvec in $VectorA){
    $CombA = PointsEquivalentTol ($eachMvec, $Vec);
    if($CombA ==3){
    $foundN[`size($foundN)`]= $CountN;
    }
    $CountN++;

    }

    return $foundN;
    }

    proc AppendIntArray(int $ExistingInt[],int $AddtoExistingInt[]){
    for($eachInt in $AddtoExistingInt){
    $ExistingInt[`size($ExistingInt)`]= $eachInt;
    }

    }

    proc AppendFloatArray(float $ExistingF[],float $AddtoExistingF[]){
    for($eachFloat in $AddtoExistingF){
    $ExistingF[`size($ExistingF)`]= $eachFloat;
    }

    }

    proc float [] DistanceSortStereoCrv(float $distToCurveE_A[], vector $LocCurveEndsVec3D[], vector $IntersectEnds_Ai, int $New_AllLocs_AI[] , float $Distance_A){
    $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ai);
    $AllLocsi = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    $AllLocs_String = IntArrayToStringArray($AllLocsi);
    $newOrdersZA = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    $EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
    $New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
    $Near_index_A = $New_AllLocs_A[0];
    $Distance_A = $distToCurveE_A[$Near_index_A];
    $Found_pt_A = $LocCurveEndsVec3D[$Near_index_A];
    $New_AllLocs_AI = $New_AllLocs_A;
    return $Found_pt_A;
    }

    // clear $StereoCurveZ;

    global string $PlaneCurveS[];
    /*

    $StereoCurveZ= `ls -sl`;
    $CurveItemZai = $StereoCurveZ[0];
    $CurveItemZbi = $StereoCurveZ[1];


    */












    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    proc int isCurveEndAtZY(vector $EndVectors[]){
    $Number = 0;
    for($eachVec in $EndVectors){
    $ThreeFs = $eachVec;
    if($ThreeFs[0] == 0){
    $Number++;
    }
    }
    return $Number;
    }

    //CUT CURVE

    /*




    if((fmod($iiz, 12))== 2){
    curve2points($PositionsZ_B[$iiz], $Intersect_A[`size($Intersect_A)`-1]);
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[0]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    curve2points($VecPtsMirrorA[$iiz], $Intersect_A[`size($Intersect_A)`-1]);
    $CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[1]);
    $AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
    PAUSE;
    }









    if($AddAB==1){

    //START of one End Intersect
    //START of one End Intersect


    if($triggerNoTransA==1){
    $New_AllLocs_AB = $New_AllLocs_A;
    $distToCurveE_AB = $distToCurveE_A;
    }
    if($triggerNoTransB==1){
    $New_AllLocs_AB = $New_AllLocs_B;
    $distToCurveE_AB = $distToCurveE_B;
    }


    $LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;
    $ExpandedString = `sort $ExpandedString`;
    $SortedRangeCrv = `sort $LayerCurvesRangeA`;
    CurvesToPlane($SortedRangeCrv);

    $OffsetTol = 1.0005;
    clear $CollectN_index;

    // index pair of Locs and Curves   $TrackAllExisting3DCrv

    clear $COLLECT_INDEX;
    clear $COLLECTN_INDEX;
    clear $COLLECT_Wanted_INDEX;

    //print $New_AllLocs_AB;
    //print $distToCurveE_AB;
    //print $distToCurveE_AB[$New_AllLocs_AB[0]];

    for($eachIndex in $New_AllLocs_AB){

    $Distance_Aii = $distToCurveE_AB[$eachIndex];
    if($Distance_Aii<=$OffsetTol){
    //print $eachIndex;
    $CollectN_index[`size($CollectN_index)`] =  $eachIndex;
    $COLLECT_INDEX[`size($COLLECT_INDEX)`] = $TrackAllExisting3DCrv[$eachIndex];
    }else{
    $COLLECT_Wanted_INDEX[`size($COLLECT_Wanted_INDEX)`] = $TrackAllExisting3DCrv[$eachIndex];}
    }

    //print $CollectN_index;
    //print $queryLocCurveEnds3D;
    //print $ExpandedString;
    //print $TrackAllExisting3DCrv;
    //print $SortedRangeCrv;
    //print $CollectN_index
    // print size($queryLocCurveEnds3D);
    // print $COLLECT_INDEX;
    // print $COLLECT_Wanted_INDEX;
    // print $ExpandedString;
    //print $COLLECT_Wanted_INDEX;

    clear $ExpandedStringi;
    clear $ExpandedStringiS;
    $Cni = 0;
    for($eachIntCCi in $COLLECT_Wanted_INDEX){
    $ExpandedStringi[$Cni] = $SortedRangeCrv[$eachIntCCi];
    $ExpandedStringiS[$Cni] = $PlaneCurveS[$eachIntCCi];
    $Cni++;
    }

    // print $ExpandedStringi;

    clear $ExpandedStringii;
    clear $ExpandedStringiiS;
    $Cnii = 0;
    for($eachIntCCii in $COLLECT_INDEX){
    $ExpandedStringii[$Cnii] = $SortedRangeCrv[$eachIntCCii];
    $ExpandedStringiiS[$Cnii] = $PlaneCurveS[$eachIntCCii];
    $Cnii++;
    }
    // print $ExpandedStringii;
    // print $COLLECT_INDEX;



    // PROBLEM what if the curve that is draw interesects the curve its end is attached to?.... can fix later if needed

    $diff = stringArrayRemoveDuplicates($ExpandedStringi);
    $diff = stringArrayRemoveExact($ExpandedStringii, $diff);

    $diffS = stringArrayRemoveDuplicates($ExpandedStringiS);
    $diffS = stringArrayRemoveExact($ExpandedStringiiS, $diffS);

    //select -r $ExpandedStringii;
    //select -r $diffS;
    //select -r $diff;
    //PAUSE;
    // print $CollectN_index;
    // print $COLLECT_INDEX;


    clear $LocSMirror;
    for($eachIndex in $CollectN_index){
    $VEcF = $LocCurveEndsVec3D[$eachIndex];
    $VEcF[0] = $VEcF[0]*-1.0;
    $LocSMirror[`size($LocSMirror)`] = FloatToVec($VEcF);
    }
    //////////////////////////////////////////////////////
    //print $LocSMirror;
    // Loc $LocSMirror[0];


    clear $AllM;
    clear $ExistingIntA;
    for($eachFvec in $LocSMirror){
    $AllM = FindEqualVec($LocCurveEndsVec3D, $eachFvec);
    if(`size($AllM)`>0){
    AppendIntArray($ExistingIntA,$AllM);}
    clear $AllM;
    }


    //print $ExistingIntA;
    clear $arrayCurvesNearABM;
    clear $arrayCurvesNearS;

    clear $COLLECT_INDEX_M;
    for($eachIntE in $ExistingIntA){
    $arrayCurvesNearABM[`size($arrayCurvesNearABM)`] = $ExpandedString[$eachIntE];
    $arrayCurvesNearS[`size($arrayCurvesNearS)`] = $PlaneCurveS[$TrackAllExisting3DCrv[$eachIntE]];
    $COLLECT_INDEX_M[`size($COLLECT_INDEX_M)`] = $TrackAllExisting3DCrv[$eachIntE];
    }
    //print $TrackAllExisting3DCrv;
    //print $arrayCurvesNearS;
    //print $arrayCurvesNearABM;
    //print $COLLECT_INDEX_M;
    //print $TrackAllExisting3DCrv;
    //select -r $arrayCurvesNearABM;

    clear $ExpandedStringiim;
    $Cniim = 0;
    for($eachIntCCiim in $COLLECT_INDEX_M){
    $ExpandedStringiim[$Cniim] = $SortedRangeCrv[$eachIntCCiim];
    $Cniim++;
    }
    //print $ExpandedStringiim;
    //print $ExpandedString;

    $diffB = stringArrayRemoveExact($arrayCurvesNearABM, $diff);

    $diffB_s = stringArrayRemoveExact($arrayCurvesNearS, $diffS);

    //select -r $diffB;
    //select -r $diffB_s;
    //PAUSE;

    //////////////////////////////////////////////////////

    clear $interVecAx;
    clear $NodeCurveIndex;
    $NodeCurveIndex = CreateCrvInterTF($CurveItemZai, $diffB_s,0,0.001,$interVecAx);

    //print $interVecAx;
    // select -r $diffB[$NodeCurveIndex[0]];
    //PAUSE; PAUSE;
    //print $NodeCurveIndex;
    //print $interVecAx;

    //select -r $CurveItemZai;


    clear $interVecAy;
    clear $NodeCurveIndexi;
    $NodeCurveIndexi = CreateCrvInterTF($CurveItemZbi, $diffB_s,0,0.001,$interVecAy);
    //print $NodeCurveIndexi;
    // select -r $diffB[$NodeCurveIndexi[0]];
    //PAUSE; PAUSE;
    //////////////////////////////////////////////////////

    if((`size($NodeCurveIndexi)` >0 )&&(`size($NodeCurveIndex)` >0 )){




    clear $VecPointOnCrv;
    $CountPara = 0;
    $CurveSFoundS = `size($NodeCurveIndexi)`;
    //print $diffB;
    for($EachIndC in $NodeCurveIndexi){

    $CURVEiA = `listRelatives -children  $diffB_s[$EachIndC]`;
    $ParaFloat = StringArrayToFloatArray(stringToStringArray($interVecAy[$CountPara], " "));
    if($CountPara>0){
    $ParaSize[$CountPara] = `size($ParaFloat)`+$ParaSize[$CountPara-1];}
    if($CountPara==0){
    $ParaSize[$CountPara] = `size($ParaFloat)`;}
    for($EachPara in $ParaFloat){

    $EveryPara[`size($EveryPara)`] = $EachPara;
    $param = eval("paramLocator "+$CURVEiA[0]+".u["+$EachPara+"]");
    $posA = `pointPosition -w $param`;
    //print $posA;
    $VecPointOnCrv[`size($VecPointOnCrv)`] = FloatToVec($posA);
    delete  $param;
    }
    $CountPara++;

    }


    //for($eachVVec in $VecPointOnCrv){
    //Loc $eachVVec;
    //}

    $distCA = ArrayDistancesVecTofloat($VecPointOnCrv, $UnconnectedEnds[1]);
    $PointOnCrvIND = CreateIntIndex(`size($VecPointOnCrv)`);
    $PointOnCrv_String = IntArrayToStringArray($PointOnCrvIND);
    clear $EmptyCA;
    $newCA = SortFloatArrayAndString($distCA, $PointOnCrv_String, $EmptyCA);
    $EmptyCA = ReverseStringArray($EmptyCA);
    $New_PointOnCrvIND_A = ArrayToIntList($EmptyCA);
    $FOUNDc = $New_PointOnCrvIND_A[0];
    $NearestDistCA = $distCA[$New_PointOnCrvIND_A[0]];
    $NearestVecCA = $VecPointOnCrv[$New_PointOnCrvIND_A[0]];
    //Loc $NearestVecCA;
    //PAUSE;
    $CountWhatCurve = -1;
    //print $ParaSize;
    for($eachIntPara in $ParaSize){
    $CountWhatCurve++;
    if(($ParaSize[$CountWhatCurve]-1)>=$FOUNDc){
    $WhatCurve=$CountWhatCurve;
    break;
    }
    }

    //select -r $diffB_s[$NodeCurveIndexi[$WhatCurve]];
    //PAUSE;

    //print $interVecAx;

    clear $VecPointOnCrvb;
    $CountParab = 0;
    $CurveSFoundSb = `size($NodeCurveIndex)`;
    //print $diffB;
    for($EachIndCb in $NodeCurveIndex){

    $CURVEiAb = `listRelatives -children  $diffB_s[$EachIndCb]`;
    $ParaFloatb = StringArrayToFloatArray(stringToStringArray($interVecAx[$CountParab], " "));
    if($CountParab>0){
    $ParaSizeb[$CountParab] = `size($ParaFloatb)`+$ParaSizeb[$CountParab-1];}
    if($CountParab==0){
    $ParaSizeb[$CountParab] = `size($ParaFloatb)`;}
    for($EachParab in $ParaFloatb){

    $EveryParab[`size($EveryParab)`] = $EachParab;
    $paramb = eval("paramLocator "+$CURVEiAb[0]+".u["+$EachParab+"]");
    $posAb = `pointPosition -w $paramb`;
    //print $posAb;
    $VecPointOnCrvb[`size($VecPointOnCrvb)`] = FloatToVec($posAb);
    delete  $paramb;
    }
    $CountParab++;

    }


    // for($eachVVec in $VecPointOnCrvb){
    // Loc $eachVVec;
    // }

    $distCAb = ArrayDistancesVecTofloat($VecPointOnCrvb, $UnconnectedEnds[0]);
    $PointOnCrvINDb = CreateIntIndex(`size($VecPointOnCrvb)`);
    $PointOnCrv_Stringb = IntArrayToStringArray($PointOnCrvINDb);
    clear $EmptyCAb;
    $newCAb = SortFloatArrayAndString($distCAb, $PointOnCrv_Stringb, $EmptyCAb);
    $EmptyCAb = ReverseStringArray($EmptyCAb);
    $New_PointOnCrvIND_Ab = ArrayToIntList($EmptyCAb);
    $FOUNDcb = $New_PointOnCrvIND_Ab[0];
    $NearestDistCAb = $distCA[$New_PointOnCrvIND_Ab[0]];
    $NearestVecCAb = $VecPointOnCrvb[$New_PointOnCrvIND_Ab[0]];

    //Loc $NearestVecCAb;
    //PAUSE;
    $CountWhatCurveb = -1;
    print $ParaSize;
    for($eachIntParab in $ParaSizeb){
    $CountWhatCurveb++;
    if(($ParaSize[$CountWhatCurve]-1)>=$FOUNDcb){
    $WhatCurveb=$CountWhatCurveb;
    break;
    }
    }

    //select -r $diffB_s[$NodeCurveIndex[$WhatCurveb]];
    //PAUSE;


    ///////////////////////////////////////////////////////////////////
    //select -r $diffB_s[$NodeCurveIndex[$WhatCurveb]];
    //PAUSE;
    //select -r $diffB[$NodeCurveIndex[$WhatCurveb]];
    //PAUSE;
    //select -r $diffB_s[$NodeCurveIndexi[$WhatCurve]];
    //PAUSE;
    //select -r $diffB[$NodeCurveIndexi[$WhatCurve]];
    //PAUSE;




    $CurveA = $diffB[$NodeCurveIndexi[$WhatCurve]];
    $CurveB = $diffB[$NodeCurveIndex[$WhatCurveb]];
    //string $newNamesCA = substituteAllString($CurveA, "Plane", "");
    //string $newNamesCB = substituteAllString($CurveB, "Plane", "");
    $newNamesCA = $CurveA;
    $newNamesCB = $CurveB;
    Loc $NearestVecCA;
    Loc $NearestVecCAb;

    $CUT_CrvMirrorEnds_A = VecPtsToZMirrorPts({$NearestVecCAb});
    $CUT_CrvIntersectEnds_A = FloatToVec (lineIntersectionF($CamPos_A, $NearestVecCA, $CamPos_M, $CUT_CrvMirrorEnds_A[0]));
    $CUT_CrvIntersectMirrorEnds_A = VecPtsToZMirrorPts({$CUT_CrvIntersectEnds_A});


    // this places CUT_CrvIntersectEnds_A the 3d ifnferance Points of the two curve intersection points into the assumed curve end vectors
    // the trigger signifies the vector that which was not connecting directly to another curve end that which the other end will be attached to
    // since the new end of the drawn curve that intersects an existing 3d curve is not drwan with mathmatical percision its intersecting will
    // have a slightly different end
    // if have not gone so far as to program a choice between cutting the drawn vs. shifting the end to meet the found 3d intersecting
    // projected on the plane


    // float $ParaB = $EveryParab[$FOUNDcb];
    // string $selectionItemB = $CurveB + ".u[" + $ParaB + "]";
    // string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $selectionItemB`;

    $myCPOC = `createNode closestPointOnCurve`;
    connectAttr ($newNamesCB+".worldSpace")  ($myCPOC+".inCurve");
    $PointBc = $CUT_CrvIntersectMirrorEnds_A[0];
    $uParam = `closestPointOnCurve -ip $PointBc[0] $PointBc[1] $PointBc[2] -q -paramU $newNamesCB`;
    $paramZ = eval("paramLocator "+$newNamesCB+".u["+$uParam+"]");
    $paramZA = eval("paramLocator "+$newNamesCA+".u["+$uParam+"]");
    delete $myCPOC;


    $selectionItemB = $CurveB + ".u[" +$uParam+ "]";
    $selectionItemA = $CurveA + ".u[" +$uParam+ "]";
    delete  $paramZ;
    delete  $paramZA;
    $detachCurve1 = `detachCurve -ch off - replaceOriginal on $selectionItemB`;
    $detachCurve2 = `detachCurve -ch off - replaceOriginal on $selectionItemA`;

    CurveIndexVecTracking({$detachCurve1[0]});
    CurveIndexVecTracking({$detachCurve2[0]});

    $interposA = `pointPosition -w  $paramZ`;
    $interposB = `pointPosition -w  $paramZA`;
    $VecIntCB = FloatToVec ($interposB);
    $VecIntCA = FloatToVec ($interposA);

    Loc $CUT_CrvIntersectEnds_A;
    Loc $CUT_CrvIntersectMirrorEnds_A[0];

    $VecCUT_CrvA = FloatToVec (FloatPointsToCamPlane($VecIntCB));
    $VecCUT_CrvB = FloatToVec (FloatPointsToCamPlane($VecIntCA));

    if($triggerNoTransENDA==1){
    $VecOnPlaneA[0]= $VecCUT_CrvA;
    $VecOnPlaneB[0]= $VecCUT_CrvB;
    }else{$VecOnPlaneA[1]= $VecCUT_CrvA;
    $VecOnPlaneB[1]= $VecCUT_CrvB;}

    //END of one End Intersect
    //END of one End Intersect
    //END of one End Intersect
    //END of one End Intersect
    //END of one End Intersect

    }
    }
    */

    ///CUT CURVE ^





    // clear $StereoCurveZ;

    /*
    $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[0]);
    $AllLocsi = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    $AllLocs_String = IntArrayToStringArray($AllLocsi);
    $newOrdersZA = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    $EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
    $New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
    $Near_index_A = $New_AllLocs_A[0];
    $Distance_A = $distToCurveE_A[$Near_index_A];
    $Found_pt_A = $LocCurveEndsVec3D[$Near_index_A];
    $newOrdersZAM = $Found_pt_A;
    $newOrdersZAM[0] = $Found_pt_A[0] *-1;

    $distToCurveE_B = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[1]);
    $newOrdersZB = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    $EmptyStringNewOrderB = ReverseStringArray($EmptyStringNewOrderB);
    $New_AllLocs_B = ArrayToIntList($EmptyStringNewOrderB);
    $Near_index_B = $New_AllLocs_B[0];

    $Distance_B = $distToCurveE_B[$Near_index_B];
    $Found_pt_B = $LocCurveEndsVec3D[$Near_index_B];
    $newOrdersZBM = $Found_pt_B;
    $newOrdersZBM[0] = $Found_pt_B[0] *-1;


    */



    //////////////////////


    /*

    // if($EulerAngle_B <$EulerAngle_A ){
    if($BCurEndBiiAdd>$BCDiff){
    if($IntIfNearZero==0){
    //if( $DistTOEpipol_CurEndA > $DistTOEpipol_CurEndB){
    PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
    //if($DistTOEpipol_CurEndA > $DistTOEpipol_CurEndB){
    PAUSE;
    $IfTrue = FindLineCross( $Vecbv , $Vecbvi );
    if($IfTrue==1){
    cycleBackgroundColor;
    //reverseCurve  -ch 0 -rpo 1 -cos on $CurveItemZai;
    //$VecCurEndsa = ReverseVectorArray($VecCurEndsa);
    $PositionsZ_B = ReverseVectorArray($PositionsZ_B);
    // $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
    $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);
    }
    }
    //}
    }
    //}

    if($EulerAngle_B <$EulerAngle_A ){
    if($DistTOEpipol_CurEndA > $DistTOEpipol_CurEndB){
    print "Reverse_it";
    PAUSE;
    makeCurvePointDirectionLength((6), $FloatDirEpipol, $VecCurEndsa[1]);
    PAUSE; PAUSE;
    }
    if($DistTOEpipol_CurEndA>$DistTOEpipol_CurEndB){
    reverseCurve  -ch 0 -rpo 1 -cos on $CurveItemZai;
    }
    if($DistTOEpipol_CurEndA>$DistTOEpipol_CurEndB){
    $VecCurEndsb = ReverseVectorArray($VecCurEndsb);
    $PositionsZ_B = ReverseVectorArray($PositionsZ_B);
    $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
    $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);
    }
    }

    */

    ////////////////////




    proc int  PointsEquivalentTol( float $posA[],  float $posB[]){
    $pX = equivalentTol($posA[0], $posB[0],  0.001);
    $pY = equivalentTol($posA[1], $posB[1],  0.001);
    $pZ = equivalentTol($posA[2], $posB[2],  0.001);
    $addedResults = $pX + $pY + $pZ;
    return $addedResults;
    }


    proc vector ClosestPoint2LineVec(float $DirectionLineF[], float $PointOnLine[], float $PointN[]){
    $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    $VecLineDir = PositiveDir($DirectionLineF);

    $VecLineDirM = $VecLineDiri-$VecLineDir;
    //if on line Result: <<1, 1, 1>>  a point on the line and the point in question directions vector Mult//

    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];

    if($AdditR != 0.0){
    $MultDirOne = multiplyFloat(1.0, $DirectionLineF);
    $AddMultF = AddFloats($PointOnLine, $MultDirOne);
    $FDirNorA = Normal3Points($PointOnLine, $AddMultF, $PointN);
    $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    $MultDirMx = multiplyFloat($DistToLineSTart, $FDirNorA);
    $AddMultMiiFx = AddFloats($PointOnLine, $MultDirMx);
    $FDirNorB = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);
    $MultDirMxz = multiplyFloat($DistToLineSTart,  $FDirNorB);
    $AddMultMiiFxz = AddFloats($PointOnLine, $MultDirMxz);
    $locsA = lineIntersection($PointN, $FDirNorB, $PointOnLine, $DirectionLineF);

    $VlocA = <<$locsA[0],$locsA[1],$locsA[2]>>;
    }else{$VlocA = FloatToVec($PointN);}

    return $VlocA;
    }

    proc vector PointDirTang2LineVec(float $DirectionLineF[], float $PointOnLine[], float $PointN[]){
    $MultDirOne = multiplyFloat(1.0, $DirectionLineF);
    $AddMultF = AddFloats($PointOnLine, $MultDirOne);
    $FDirNorA = Normal3Points($PointOnLine, $AddMultF, $PointN);
    $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    $MultDirMx = multiplyFloat($DistToLineSTart, $FDirNorA);
    $AddMultMiiFx = AddFloats($PointOnLine, $MultDirMx);
    $FDirNorB = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);

    $VlocA = <<$FDirNorB[0],$FDirNorB[1],$FDirNorB[2]>>;

    return $VlocA;
    }

    /*
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    $CircleCenter = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureCenter")`;

    //-curvatureCenter


    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
    << ($norm.x), ($norm.y), ($norm.z) >>`;

    */

    //SmoothCurvature3(6);
    //attachCurveTangent( 1 );

    proc string[] SmoothCurvature3(float $curveM ){
    $curves = `ls -sl`;
    $myCurve = $curves[0];
    //rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    //smoothCurve -ch 0 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 4 );
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0  -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] +  ".translate")`;
    $step = $numEPrealNum2;
    $curve = "curve -d 3";
    $curveMin = $curveM;

    $curve = IteratCurve( $step, $paramlocatorpointOnCurvex, $curveMin, $FindSteps);

    $Newcurvez = `eval($curve)`;

    //rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $Newcurvez;
    $numLength = (`arclen $Newcurvez`) +1;
    $StepZNum = $numLength;
    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    // rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s $StepZNum -d 3 -tol 0.001  $Newcurvez;
    $Newcurve = {$Newcurvez};
    rename $Newcurve $curves;
    $Newcurve = {$curves[0]};
    return $Newcurve;
    }


    proc string IteratCurve(float $step, string $paramlocatorpointOnCurvex, float $curveMin, int $FindSteps){

    $MasterCount = 0;
    $curve = "curve -d 3";



    while ($FindSteps < 4){
    $curve = "curve -d 3";

    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    $CircleCenter = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureCenter")`;
    $tan = `getAttr  ($paramlocatorpointOnCurvex +  ".normal")`;
    $norm = `getAttr  ($paramlocatorpointOnCurvex +  ".tangent")`;
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
    << ($norm.x), ($norm.y), ($norm.z) >>`;


    if ( $CurvatureRadi <=  $curveMin){
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
    if((fmod($CountSteps, 12))== 2){
    $circlesZ[`size($circlesZ)`] = Circles_Direction($CircleCenter, $bi, $CurvatureRadi);
    }
    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    if((fmod($CountSteps, 12))== 2){
    $circlesZ[`size($circlesZ)`] =Circles_Direction($CircleCenter, $bi, $CurvatureRadi);
    }
    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    if((fmod($CountSteps, 12))== 2){
    $circlesZ[`size($circlesZ)`] =Circles_Direction($CircleCenter, $bi, $CurvatureRadi);
    }
    $CountSteps++;
    }
    }
    $FindSteps = $CountSteps;
    if($FindSteps < 4){$curveMin += 8.0; $curve = "curve -d 3"; delete $circlesZ;}
    if($MasterCount== 4){break;}
    $MasterCount++;

    }

    return $curve;
    }

    proc string IteratCurve(float $step, string $paramlocatorpointOnCurvex, float $curveMin, int $FindSteps){

    $MasterCount = 0;
    $curve = "curve -d 3";


    while ($FindSteps < 4){
    $curve = "curve -d 3";

    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;

    if ( $CurvatureRadi <=  $curveMin){
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];

    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];

    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];

    $CountSteps++;
    }
    }
    $FindSteps = $CountSteps;
    if($FindSteps < 10){$curveMin += 18.0; $curve = "curve -d 3";  }
    if($MasterCount== 4){break;}
    $MasterCount++;

    }

    return $curve;
    }

    proc vector [] makeCurvePointDirectionLengthN(float $Length, float $Direction[], float $posA[]){
    $MultDirA = multiplyFloat(($Length/2.0),  $Direction);
    $DirectionN = multiplyFloatArray(-1.0,$Direction);
    $MultDirB = multiplyFloat(($Length/2.0),  $DirectionN);
    $FDirA = AddFloats($posA, $MultDirA);
    $FDirB = AddFloats($posA, $MultDirB);
    $Avec[0]= FloatToVec($FDirA);
    $Avec[1]= FloatToVec($FDirB);
    $CurveBetween = curve2points($FDirA,  $FDirB);
    return $Avec;
    }

    proc vector [] LockEndsAverageCurveVec( vector $newVec[]){

    $range = 3;
    $TotalS = `size($newVec)`;
    $indexState = 0;
    while($indexState<$TotalS){
    $countS=1;
    $Xs=0;
    while($countS<$range){
    $indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
    $indexRight = fmod(($indexState + $countS),$TotalS);
    $indexLeftS[$Xs] = $indexLeft;
    $indexRightS[$Xs]= $indexRight;
    $countS++;
    $Xs++;
    }

    if(($indexState<=2)||($indexState>=($TotalS-3))){
    if($indexState<=2){
    $Aver = (( ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec[$indexState])/2.5;
    $AVvects[$indexState] = $Aver;
    }
    if($indexState>=($TotalS-3)){
    $Aver = (( ($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0))+$newVec[$indexState])/2.5;
    $AVvects[$indexState] = $Aver;
    }
    }else{
    $Aver = ((($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0) + ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec [$indexState])/4.0;
    $AVvects[$indexState] = $Aver;
    }
    clear $indexLeftS;
    clear $indexRightS;
    $indexState++;
    }
    return $AVvects;
    }

    global int $SortDistanceIntG;
    proc vector [] CurvatureUtility(string $curvesZ, int $NumberofSteps, float $curvature[], int $C[], float $TotalCA){
    global int $SortDistanceIntG;
    $step = $NumberofSteps;
    $myCurve = $curvesZ;
    $ii = 0;
    $TotalCAX =0;
    $t=0.0;
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;


    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );

    $CIrceP = `xform -q -ws -t $curvesZ`;
    for($a = 0.0; $t < $numEPrealNum;$a++){

    $t =  $a/$step;
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
    $CRVRadi[$ii] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;



    $DistanceS[$ii] = distance2Pts($values,$CIrceP);

    $ii++;
    }
    $NewIndexN = SortNumbersIntIndex($DistanceS);
    $SortDistanceIntG = $NewIndexN[0];
    delete $paramlocatorpointOnCurvex;

    for($eachCURVA in $CRVRadi){
    $TotalCAX +=  $eachCURVA;
    }
    $TotalCA = $TotalCAX;
    $curvature = $CRVRadi;
    return $CurveVectors;
    }

    proc vector [] AverageCurveVec( vector $newVec[]){

    $range = 3;
    $TotalS = `size($newVec)`;
    $indexState = 0;
    while($indexState<$TotalS){

    $countS=1;
    $Xs=0;
    while($countS<$range){
    $indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
    $indexRight = fmod(($indexState + $countS),$TotalS);
    $indexLeftS[$Xs] = $indexLeft;
    $indexRightS[$Xs]= $indexRight;
    $countS++;
    $Xs++;
    }
    $Aver = ((($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0) + ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec [$indexState])/4.0;
    $AVvects[$indexState] = $Aver;
    clear $indexLeftS;
    clear $indexRightS;
    $indexState++;
    }
    return $AVvects;
    }


    proc string VecArrayToCurveB(vector $FixVec[]){
    $sIZes = `size $FixVec `;
    $NUmers = CreateIntIndex($sIZes);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $K += "\-k"+" "+ $sIZes+" ";
    $sIZes++;
    $K += "\-k"+" "+ $sIZes+" ";
    $curve = "curve -d 3";
    for ($eachVeCx in $FixVec){
    $valuesBi = $eachVeCx;
    $curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    }
    $Newcurvez = `eval($curve)`;
    return $Newcurvez;
    }


    proc vector TwoVecsOrFloats(float $p1p2[], float $p1p3[]){
    $Ui = FloatToVec($p1p2);
    $Vi = FloatToVec($p1p3);
    $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;
    return $VEcLine;
    }

    proc int MostRightClockWiseInt ( vector $Vecs[], int $Two[]){
    $ThreePoints = { "0", "1", "2"};
    $point1 = FloatToVec($Vecs[0]);
    $point2 = FloatToVec($Vecs[1]);
    $point3 = FloatToVec($Vecs[2]);
    $U1 = TwoVecsOrFloats($point2, $point1);
    $V1 = TwoVecsOrFloats($point3, $point1);
    $U2 = TwoVecsOrFloats($point3, $point1);
    $V2 = TwoVecsOrFloats($point2, $point1);
    $U3 = TwoVecsOrFloats($point1, $point3);
    $V3 = TwoVecsOrFloats($point2, $point3);
    clear $normalV;
    $normalV[0] = FloatToVec( crossProduct( $U1, $V1, 0, 1 ) );
    $normalV[1] = FloatToVec( crossProduct( $U2, $V2, 0, 1 ) );
    $normalA = `unit ($normalV[0])`;
    $normalB = `unit ($normalV[1])`;
    $normalAAdd = $normalA[0] + $normalA[1];
    $normalAAdd2 = $normalB[0] + $normalB[1];

    if( $normalAAdd< $normalAAdd2){
    $TwoNew ={$Two[1], $Two[0]};

    }else{
    $TwoNew ={$Two[0], $Two[1]};

    }
    //$Two = $TwoNew;
    return $TwoNew[0];
    }

    proc AppendFloat(float $A[] , float $B[]){
    for($eachF in $B){
    $A[`size($A)`]= $eachF;
    }
    }

    proc float [] CreateIntIndexF(int $ArraySize, float $Fstep){
    $iNdex = 0;
    $AddF = 0;
    while($iNdex < $ArraySize){
    $AddF+= $Fstep;
    $FArrayInex[$iNdex] = $AddF;
    $iNdex++;
    }
    return $FArrayInex;
    }

    proc vector [] calculateEllipseCurve(vector $FixVeci[], float $steps){

    // $a == Major Axis
    // $b == Minor Axis




    $x=8;
    $y=8;
    $z = 8;
    $Lengthi = distance2Pts ($FixVeci[0], $FixVeci[1]);
    $MidPt = MidPoint($FixVeci[0], $FixVeci[1]);
    $FloatDirMajor = DirectionFN($FixVeci[0], $FixVeci[1]);

    $Lengthiii = distance2Pts ($MidPt, $FixVeci[2]);
    $FDirNorAi = Normal3Points($FixVeci[0], $FixVeci[1], $FixVeci[2]);
    $DirNormi = FloatToVec ($FDirNorAi);
    $normal = crossProduct( $FloatDirMajor, $FDirNorAi, 0, 0 );

    matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $norm = FloatToVec($FloatDirMajor);
    $bi = FloatToVec($FDirNorAi);
    $tan = FloatToVec( $normal);
    $MidVec = FloatToVec( $MidPt);
    $LENGTH = $Lengthi/2.0;
    // length times direction add to Point to move it??
    $ABC[0] = $FixVeci[0];
    $ABC[1] = ($tan * $LENGTH)+ $MidVec;
    $ABC[2] = $FixVeci[1];

    $C_radius = Circle3PtsM($ABC[0], $ABC[1], $ABC[2]);
    $ObjsCirclesRad = $C_radius[3];

    $VecLineDir = PositiveDirectionLine($ABC[1],$MidVec);
    $PointN = ClosestPoint2Line($VecLineDir, $FixVeci[2], $MidVec);
    $Di = distance2Pts( $MidVec , $PointN);
    $DiffL = ($ObjsCirclesRad-$Di)*2.0;

    $returnValue = 1;
    if($Di<$ObjsCirclesRad){
    $returnValue =1;}
    if($Di==$ObjsCirclesRad){
    $returnValue =0;}
    if($Di>$ObjsCirclesRad){
    $returnValue =-1;}


    if($returnValue==1){
    $FloatDirXn = DirectionFN( $MidVec, $FixVeci[2]);
    $PointNii = MultLenToDirAddToPoint($Di, DirectionFN( $MidVec, $PointN), $PointN);
    $DistAddiR2 = $Di*2.0;
    $HightD = sqrt (abs ((`pow $Di 2`) - (`pow $ObjsCirclesRad 2`)));
    $PointNiii = MultLenToDirAddToPoint($HightD,($tan), $PointN);
    $PointNiiiB = MultLenToDirAddToPoint($HightD,($tan*-1), $PointN);
    }

    $DiX = distance2Pts( $FixVeci[2] , $PointNiii);
    $DiY = distance2Pts( $FixVeci[2] , $PointNiiiB);
    if($DiX<$DiY){
    $ClosestPoint=$PointNiii;
    }
    if($DiX>$DiY){
    $ClosestPoint=$PointNiiiB;
    }

    $RadiOfOuter = distance2Pts($MidVec, $ClosestPoint);
    $DirRaytoIntersectC  = DirectionFN($MidVec, $ClosestPoint);
    $CircleRayPointN = ClosestPoint2Line($DirRaytoIntersectC, $MidVec, $FixVeci[2]);
    $SecondIntersectCsmall = lineIntersection( $MidVec, $DirRaytoIntersectC, $FixVeci[2], $norm);


    $RadiOfInnerC = distance2Pts($MidVec,$SecondIntersectCsmall);

    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
    ($bi.x),   ($bi.y),   ($bi.z),   0.0;     // Y axis
    ($tan.x),  ($tan.y),  ($tan.z),  0.0;     // Z axis
    $MidPt[0], $MidPt[1], $MidPt[2],     1.0 >>;  // Position
    $MatrizFloati = MatrixToFloat($mI);
    $x = $MidPt[0];
    $y = $MidPt[2];
    $z = $MidPt[1];
    $a = $Lengthi/2.0;

    ////////////////////////
    $b = $RadiOfInnerC;
    ///////////////////////////

    $angle = 0;

    $DirecOfPointABi = FloatToVec ( DirectionFN($FixVeci[0], $FixVeci[1]));
    $curvei = "curve -d 3";
    clear $VecH;
    $vi = 0;
    $Pi = 3.1415926535;

    $VecAngle = VAnglesofThreeVec($MidPt, $FixVeci[1], $FixVeci[2]);

    $beta = `deg_to_rad ($angle)`;
    $sinbeta = sin($beta);
    $cosbeta = cos($beta);
    $valuesiiA = {$x,0.0,$y} ;
    $valuesiAi = {$x, 0, $y} ;
    $valuesiAi = {$x, 0, $y} ;


    for ( $i = 0; $i < 360; $i += 360.0/$steps)
    {
    $alpha = $i * ( $Pi / 180.00) ;
    $sinalpha =  sin($alpha);
    $cosalpha =  cos($alpha);

    $X = $x + ($a * $cosalpha * $cosbeta - $b * $sinalpha * $sinbeta);
    $Y = $y + ($a * $cosalpha * $sinbeta + $b * $sinalpha * $cosbeta);

    $valuesA = {$X, 0, $Y} ;
    $MidTwoDtoElPoint = distance2Pts ($valuesiiA, $valuesA);
    $FloatDirEpoint = DirectionFN($valuesiiA, $valuesA);
    $newLocP = pointMatrixMult(  $FloatDirEpoint, $MatrizFloati );
    $MultDii = multiplyFloat($MidTwoDtoElPoint, $newLocP);
    $AddMepi = AddFloats($MidPt, $MultDii);
    $aV = FloatToVec($valuesA);
    $bV = FloatToVec($valuesiAi);

    $VecH[`size($VecH)`]= `FloatToVec $AddMepi`;

    $curvei += " -p "+$AddMepi[0]+" "+$AddMepi[1]+" "+$AddMepi[2];
    }

    eval($curvei);
    ResetTransEachSL;
    return $VecH;
    }

    global int $TrackDirectionChange;

    proc vector [] CurvatureIsCircleData(string $curvesZ, int $NumberofSteps, float $angleZ[], float $TotalDeg[], int $low, float $C[], float $Ang[]){

    $myCurve = $curvesZ;
    //smoothCurve -ch 0 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($curvesZ);

    $AverageVecCurve = AverageVectorPoint($PositionsZ_A);

    $CIrceP = `xform -q -ws -t $myCurve`;
    $AverageVecCurve =$CIrceP;
    //Loc $AverageVecCurve;
    $VecAverage = FloatToVec($AverageVecCurve);


    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 4 );

    $numEPrealNum2 = $NumberofSteps;
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -top 1 -p $myCurve`;
    $SharpValuesTan[0] = $PositionsZ_A[0];
    $step = $NumberofSteps;
    $Par = 0;
    $StepCycle = 0;
    $ii = 0;
    $iX = 0;
    $Trigger = 0;
    $Lowest = 11110;
    $Past = 0;
    $pastA = 0.0;
    $AddAngles = 0.0;
    $allAngi[`size($allAngi)`] = 0;
    $allAngiX[`size($allAngiX)`] = 0;
    $TwoZeroOne = {0,1};
    $TwoZeroOneT = {0,1};
    $Ct[0] = 0.0;
    $C[0] = 0.0;
    $CN[0] = 0;
    $TF = 0;
    $CountEVEN = 0;
    global int $TrackDirectionChange;
    $TrackDirectionChange=0;

    for($a = 0; $a <= $step;$a++){

    $t =  $a/$step;
    $Par = ($a/$step);

    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $valuesTan[$ii]  = `getAttr  ($paramlocatorpointOnCurvex + ".tangent")`;

    $CurvatureRadi[$ii] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    $valuesXYZ  = {$values[0], $values[1], $values[2]};
    $CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
    $valuesTanSpace[$ii] = $CurveVectors[$ii]+$valuesTan[$ii];

    $FlushVectors[`size($FlushVectors)`] = <<$values[0], $values[1], $values[2]>>;
    $PresentV = FloatToVec($values);

    // creat a vator array thatclears every time it passes 360 deg.. so the last few steps are recored..
    // then take the last angle find the persect it is of 360  divide that by the number of septs then use that as a float step

    if($ii>0){$Past=$ii-1;

    $EachAngle = VAnglesofThreeVec($VecAverage, $PositionsZ_A[0], $CurveVectors[$ii]);
    $threeVecs[0] = $PositionsZ_A[0]; $threeVecs[1] = $VecAverage; $threeVecs[2] = $PresentV;
    $TFmostR = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);

    // for copy past  $valuesTanPastSpace = $valuesTanSpace[$ii];
    $threeVecsT[0] = $valuesTanPastSpace; $threeVecsT[1] = $PastV; $threeVecsT[2] = $PresentV;
    $TFmostRT = MostRightClockWiseInt ($threeVecsT, $TwoZeroOneT);
    $allAngiX[`size($allAngiX)`]= $EachAngle;

    $Ct[$iX] =  $TFmostRT;
    $C[$iX] = $TFmostR;
    if($ii==1){
    $C[$iX-1]= $C[$iX];
    $Ct[$iX-1]= $Ct[$iX];
    $CN[`size($CN)`-1]=$C[$iX];
    $DeepPastTan = $valuesTanPast;
    $DeepPast= $PastV;
    }

    $AngleB = EulerAngB($DeepPastTan, $valuesTan[$ii]);
    $AngleNine = $AngleB[3];
    //if((($AngleNine>82)&&($AngleNine<98))||(($AngleNine>39)&&($AngleNine<51))){

    if($Ct[$iX]==$Ct[$iX-1]){
    if(($AngleNine>82)&&($AngleNine<98)){
    //print ("direction Same "+$AngleNine+"\n");

    $CurrentVecT = $CurveVectors[$ii]+$valuesTan[$ii];
    //Loc $CurrentVecT;

    //Loc $valuesXYZ;
    $SharpValuesTan[`size($SharpValuesTan)`]= FloatToVec (lineIntersectionF($DeepPast, ($DeepPast+$DeepPastTan), $valuesXYZ, $CurrentVecT));
    //Loc $SharpValuesTan[`size($SharpValuesTan)`-1];
    $SharpValuesTan[`size($SharpValuesTan)`]= $CurveVectors[$ii];
    //$SharpValuesTan[`size($SharpValuesTan)`]= $CurrentVecT;

    $DeepPastTan =  $valuesTan[$ii];
    $DeepPast= $CurveVectors[$ii];
    }
    }

    $allAngi[$iX] =$EachAngle;

    if($Trigger== 1){
    $allAngi[$iX] = (abs($pastA - $EachAngle))+$allAngi[$iX-1];
    if($allAngi[$iX]> 360){ $allAngi[$iX]=$EachAngle; $allAngi[$iX-1]=0;  $Trigger= 0; $TF++; }
    }

    if($Ct[$iX]!=$Ct[$iX-1]){
    //means it changed direction left or right from past tangent ..exe: the road that was curved right is now starting to curve left
    $TrackDirectionChange++;
    //print ("Direction CHANGE! "+$AngleNine+"\n");
    $CurrentVecT = $CurveVectors[$ii]+$valuesTan[$ii];
    //Loc $CurrentVecT;
    //Loc $valuesXYZ;
    //Cube $valuesXYZ;


    //if(($AngleNine>82)&&($AngleNine<98)){

    if(!(($AngleNine>135)||($AngleNine==0))){
    $SharpValuesTan[`size($SharpValuesTan)`]= FloatToVec (lineIntersectionF($DeepPast, ($DeepPast+$DeepPastTan), $valuesXYZ, $CurrentVecT));}
    //Loc $SharpValuesTan[`size($SharpValuesTan)`-1];
    $SharpValuesTan[`size($SharpValuesTan)`]= $CurveVectors[$ii];
    $DeepPastTan =  $valuesTan[$ii];
    $DeepPast= $CurveVectors[$ii];

    //}else{ if($AngleNine>90){$SharpValuesTan[`size($SharpValuesTan)`]= $CurveVectors[$ii];
    //	$DeepPastTan =  $valuesTan[$ii];
    //	$DeepPast= $CurveVectors[$ii];
    //}


    }

    if($C[$iX]!=$C[$iX-1]){
    //Loc $valuesXYZ;
    //Loc $valuesTanPast;
    $CN[`size($CN)`]= $iX;
    $CN[`size($CN)`]=$C[$iX];
    $Even_Odd = fmod($CountEVEN,2);
    if($Even_Odd ==1){
    $DistancesCycle[`size($DistancesCycle)`]= distance2Pts ($PositionsZ_A[0], $PresentV);

    }

    $CountEVEN++;
    $angleTii = (180.00- $allAngi[$iX]) +(180.00- $allAngi[$iX-1]);
    $allAngi[$iX] =  $angleTii +$allAngi[$iX-1];
    $Trigger= 1;

    }

    $pastA = $EachAngle;
    $AddAngles+= abs($EachAngle - $allAngiX[`size($allAngiX)`-1]);


    if($allAngi[`size($allAngi)`-1]>=360){
    clear $FlushVectors;
    $StepCycle =  abs ($StepCycle -$a);
    $FXiI = $StepCycle;
    $Fnumbers = 100.0/$FXiI;
    $floatZ = CreateIntIndexF($FXiI, $Fnumbers);
    $StepCycle = $a;
    //Loc $CurveVectors[$ii];
    $AddAngles=0;
    }
    }

    if($StepCycle < $Lowest){
    if($StepCycle!=0){
    $Lowest = $StepCycle;
    }
    }

    $PastV = FloatToVec($values);
    $valuesTanPast = $valuesTan[$ii];
    $valuesTanPastSpace = $valuesTanSpace[$ii];

    $iX++;
    $ii++;



    }

    /////////END of Loop

    $SharpValuesTan[`size($SharpValuesTan)`]= $PastV;

    $CN[`size($CN)`]= $iX;
    $low = $TF;
    $angleZ = $DistancesCycle;
    delete $paramlocatorpointOnCurvex;
    $TotalDeg = $CurvatureRadi;
    $Ang = $allAngiX;

    VecArrayToCurve($SharpValuesTan);
    ResetTransEachSL;
    editDisplayLayerMembers -noRecurse VecToCurve `ls -selection`;
    toggle -editPoint;
    VecArrayToCurveB($SharpValuesTan);
    ResetTransEachSL;
    editDisplayLayerMembers -noRecurse VecToCurveB `ls -selection`;

    return $CurveVectors;

    }

    //////////////////////////////////////

    global float $x0W;
    global float $x1W;
    global float $LearningCoeff;
    global float $Threshold;
    global float $Out;

    proc CPerceptron_CPerceptron(){
    global float $LearningCoeff;
    global float $Threshold;
    global float $x0W;
    global float $x1W;
    //srand((unsigned)(time(NULL)));
    $LearningCoeff = 0.2;
    $Threshold = 0.5;
    $x0W =  (float)(rand(32007))/(32767/2) - 1;
    $x1W =  (float)(rand(32007))/(32767/2) - 1;


    $x0W = 0.1;
    $x1W = 0.1;

    }


    //Setting up parameters
    proc CPerceptron_SetValues(float $x0WeightPar, float $x1WeightPar, float $LearningC, float $Thresh)
    {
    global float $x0W;
    global float $x1W;
    $x0W = $x0WeightPar;
    $x1W = $x1WeightPar;
    $LearningCoeff = $LearningC;
    $Threshold = $Thresh;
    }


    //Training function
    proc float CPerceptron_Train(float $x0, float $x1, float $r)
    {
    global float $x0W;
    global float $x1W;
    global float $LearningCoeff;
    global float $Threshold;
    global float $Out;

    $Sum = ($x0*$x0W)+($x1*$x1W)+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result = Sigmoid($Sum);

    $Out = ($x0*$x0W)+($x1*$x1W);
    if($Out>$Threshold){ $Output = 1.0;
    }else{ $Output = 0.0;}

    $Error = ((float)$r)-($Output);
    $Correction = $LearningCoeff*$Error;

    if($x0==1){ $x0W += $Correction;}
    if($x1==1){ $x1W += $Correction;}
    return $Result;
    }

    //Sigmoid function
    proc float CPerceptron_Sigmoid(float $x){
    $S = (1.0/(1.0+`exp(-$x)`));
    return $S;
    }


    //Get current weight values function
    proc float CPerceptron_Getx0Weight()
    {
    global float $x0W;
    return $x0W;
    }
    proc float CPerceptron_Getx1Weight()
    {
    global float $x1W;
    return $x1W;
    }


    //Run function, return y value
    proc float CPerceptron_Run(float $x0, float $x1)
    {
    global float $x0W;
    global float $x1W;
    global float $Threshold;
    $Sum = ($x0*$x0W)+($x1*$x1W);
    if($Sum>$Threshold){ $Result = 1;
    }else{ $Result = 0;}
    $Result = Sigmoid($Sum);
    return $Result;
    }


    proc float CPerceptron_RunX(float $x0)
    {

    global float $Threshold;
    if($x0>$Threshold){ $Result = 1;
    }else{ $Result = 0;}
    //$Result = Sigmoid($Sum);
    return $Result;
    }

    proc int PrintMod(int $StepN, float $Mod ){
    if ( fmod($StepN, $Mod) == ($Mod-1)  ) {
    return 1;
    }else {return 0;}
    }



    proc float [] GatherDataR(float $Xt[], float $Av){
    for ($eachInt in $Xt){
    if($eachInt > $Av){
    $Vt[`size($Vt)`]= 0;
    }else{$Vt[`size($Vt)`]= 1;}}
    return $Vt;
    }



    proc float [] GatherDataDiff(float $Xt[], float $Av){

    for ($eachInt in $Xt){
    $Vt[`size($Vt)`]= `abs ($Av-$eachInt)`;
    }
    return $Vt;
    }


    proc float AverageFloats(float $FloatArray[]){
    $Ix = 0;
    $AddAll = 0;
    for($eachF in $FloatArray){
    $AddAll+= $eachF;
    $Ix++;
    }
    $Divide = $AddAll/$Ix;
    return $Divide;
    }


    proc float [] AverageFloatArrays(float $FloatArrayA[], float $FloatArrayB[]){
    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = ($eachF + $FloatArrayB[$Ix])/2.0;
    $Ix++;
    }
    return $AddAll;
    }

    proc float [] AddFloatArrays(float $FloatArrayA[], float $FloatArrayB[]){
    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = ($eachF + $FloatArrayB[$Ix]);
    $Ix++;
    }
    return $AddAll;
    }

    proc float [] DivideFloatArrays(float $FloatArrayA[], float $DivideX){
    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] =  $eachF/$DivideX;
    $Ix++;
    }
    return $AddAll;
    }

    proc float [] DiffFloatArrays(float $FloatArrayA[], float $FloatArrayB[]){
    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = abs (($eachF - $FloatArrayB[$Ix]));
    $Ix++;
    }
    return $AddAll;
    }


    proc float PercentDiffZeroOneArrays(float $FloatArrayA[], float $FloatArrayB[]){
    $Ix = 0;
    $Fx = 0.0;
    for($eachF in $FloatArrayA){
    if ($eachF != $FloatArrayB[$Ix]){
    $AddAll+= 1.0;
    }
    $Fx++;
    $Ix++;
    }

    //print ($AddAll +" "+$Fx+"\n");

    if($AddAll != 0){
    $DiffMathA =  $AddAll / ($Fx/100.0);
    }else{ $DiffMathA = 0;}

    return $DiffMathA;
    }




    proc float [] GatherDataC(float $Xt[]){

    $Count = 0;
    $CountP = 0;
    //$Vt[`size($Vt)`] =0;
    for ($eachInt in $Xt){

    if($Count>0){
    if($Xt[$Count-1]!=$Xt[$Count]){

    $Vt[`size($Vt)`]= $CountP;
    $CountP = 0;
    }
    }
    $CountP++;
    $Count++;
    }
    $Vt[`size($Vt)`]= $CountP;

    return $Vt;
    }

    proc int [] GatherData(int $Xt[]){

    if(`size($Xt)`>0){
    return $Xt;
    }
    }
    proc float [] GatherDataF(float $Xt[]){

    if(`size($Xt)`>0){
    return $Xt;
    }
    }


    proc float CPerceptron_TrainX(float $x0, float $x1)
    {

    global float $Threshold;
    $Sum = ($x0)+($x1)+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result = Sigmoid($Sum);
    return $Result;
    }


    //Sigmoid function
    proc float CPerceptron_Sigmoid(float $x){
    $S = (1.0/(1.0+`exp(-$x)`));
    return $S;
    }


    proc float [] GatherDataZeroOne(float $Xt[]){
    $count = 0;
    for ($eachF in $Xt){
    if($eachF == 1){
    $ZO[$count] = 1;
    }
    if($eachF == -1){
    $ZO[$count] = 0;
    }
    $count++;

    }
    return $ZO;
    }


    proc GatherDataRRV(float $Xt[], vector $Pts[]){
    $count = 0;
    for ($eachF in $Xt){
    if($eachF == 1){
    Loc $Pts[$count];
    }
    $count++;

    }
    }




    proc float [] GatherDataRR(float $Xt[], float $Av){
    $count = 0;

    for ($eachF in $Xt){

    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= -1;}

    if($count>0){

    if($PastF<$eachF){
    if($PastF<$Av){
    if(($PastF+$eachF/2.0)<$Av){
    $Vt[$count]= 1; }
    }
    }

    }

    $PastF = $eachF;
    $count++;
    }
    return $Vt;
    }

    proc float [] GatherDataRRZO(float $Xt[], float $Av){
    $count = 0;

    for ($eachF in $Xt){

    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= 0;}

    if($count>0){

    if($PastF<$eachF){
    if($PastF<$Av){
    if(($PastF+$eachF/2.0)<$Av){
    $Vt[$count]= 1; }
    }
    }

    }

    $PastF = $eachF;
    $count++;
    }
    return $Vt;
    }

    proc float [] GatherDataAboveBelowT(float $Xt[], float $Av){
    $count = 0;
    for ($eachF in $Xt){
    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= 0;}
    $count++;
    }
    return $Vt;
    }




    proc float [] CPerceptronZ_Train(float $x0[], float $x1[], float $r)
    {

    global float $x0WX[];
    global float $x1WX[];
    global float $LearningCoeff;
    global float $Threshold;
    global float $Out;


    $Size = size($x0);
    for($i=0; $i<$Size; $i++){
    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i])+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result[$i] = Sigmoid($Sum);

    $Out = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
    if($Out>$Threshold){ $Output = 1.0;
    }else{ $Output = 0.0;}

    $Error = ((float)$r)-($Output);
    $Correction = $LearningCoeff*$Error;

    if($x0[$i]==1){ $x0WX[$i] += $Correction;}
    if($x1[$i]==1){ $x1WX[$i] += $Correction;}

    }

    return $Result;
    }
    /*
    GatherDataF($x1WX);
    9.906

    $Out = (-1*3.01)+(1*3.01);
    if($Out>$Threshold){ $Output = 1.0;
    }else{ $Output = 0.0;}
    print $Output;
    $Error = ((float)0.99)-($Output);
    $Correction = $LearningCoeff*$Error;

    $Sum = (-1*3.01)+(1*3.01)+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    Sigmoid($Sum);

    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1
    print $x1WX[29];
    print $x0WX[29];
    */
    proc float [] CPerceptronZ_TrainX(float $x0[], float $x1[])
    {

    global float $Threshold;
    $Size = size($x0);
    for($i=0; $i<$Size; $i++){
    $Sum = ($x0[$i])+($x1[$i])+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result[$i] = Sigmoid($Sum);
    }
    return $Result;
    }




    proc float [] CPerceptronZ_RunXZ(float $x0[], float $x1[])
    {
    global float $x0WX[];
    global float $x1WX[];
    global float $Threshold;
    $Size = size($x0);

    for($i=0; $i<$Size; $i++){

    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
    if($Sum>$Threshold){ $Result[$i] = 1;
    }else{ $Result[$i] = 0;}
    $Result[$i] = Sigmoid($Sum);
    }
    return $Result;
    }

    proc float [] CPerceptronZ_RunXYZ(float $x0[], float $x1[])
    {
    global float $x0WX[];
    global float $x1WX[];
    global float $Threshold;
    $Size = size($x0);

    for($i=0; $i<$Size; $i++){

    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i])+((-1)*$Threshold);
    $Result[$i] = Sigmoid($Sum);
    }
    return $Result;
    }



    proc float [] CPerceptronZ_RunOUTPUT(float $x0[], float $x1[])
    {
    global float $x0WX[];
    global float $x1WX[];
    global float $Threshold;
    $Size = size($x0);

    for($i=0; $i<$Size; $i++){

    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
    if($Sum>$Threshold){ $Result[$i] = 1;
    }else{ $Result[$i] = 0;}
    $Result[$i] = Sigmoid($Sum);

    }
    return $Result;
    }

    proc float [] Sum_PerceptronZ_TrainX(float $x0[], float $x1[])
    {

    $ThresholdX = 1.5;
    $Size = size($x0);
    for($i=0; $i<$Size; $i++){
    $Sum = ($x0[$i] + $x1[$i] );
    //print ("Sum "+$Sum+"\n");
    if($Sum > $ThresholdX){ $Result[$i] = 1;
    }else{ $Result[$i] = -1;}
    }
    return $Result;
    }
    proc string [] VecArrayToSplitCurve(vector $FixVec[]){

    // the middle curve will always be even!

    $sIZes = `size $FixVec `;
    $evenOdd = fmod($sIZes, 2);

    $sIZesHalf = (($sIZes)/2)+1;
    $NUmers = CreateIntIndex($sIZesHalf);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $countN = 0;
    $curveA = "curve -d 1";
    for ($eachVeCx in $NUmers){
    $valuesBi  = $FixVec[$countN];
    $curveA += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    $countN++;
    }
    $curveA += " "+ $K;
    $curveB = "curve -d 1";
    $countN--;
    for ($eachVeCx in $NUmers){
    $valuesBi  = $FixVec[$countN];
    $curveB += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    $countN++;
    }
    $curveB += " "+ $K;
    $NewcurvezA = `eval($curveA)`;
    $NewcurvezB = `eval($curveB)`;
    $NewcurvezAB = {$NewcurvezA , $NewcurvezB};
    return $NewcurvezAB;
    }

    proc vector [] LineIntersectPlaneCam( vector $Vecii[], float $CamP[], vector $Vec[]){

    $pAv = AverageVectorPoint($Vec);
    $n = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    $CountVV = 0;
    for($eachVecLine in $Vecii){
    $FloatDirA  = DirectionF($eachVecLine, $CamP);
    $FloatDirNormalA = multiplyFloat(2, $FloatDirA);
    $MultDirA = AddFloats( $FloatDirNormalA, $eachVecLine);

    $DistanceLocA = distance2Pts(  $eachVecLine, $pAv);
    $MultDirCam  = multiplyFloat($DistanceLocA, $n);
    $FloatDirectionCamNormalA  = AddFloats($pAv, $MultDirCam);

    $PointN  = ClosestPoint2Line($n, $pAv, $eachVecLine);
    $FloatDirectionAi  = DirectionF($PointN, $pAv);
    $DistanceLoc = distance2Pts( $PointN, $pAv );

    $MultDirPC1  = multiplyFloat($DistanceLoc, $FloatDirectionAi);
    $FloatDirNormalDist  = AddFloats($eachVecLine, $MultDirPC1);
    $PointNii  = ClosestPoint2Line(DirectionF($PointN, $pAv), $eachVecLine, $MultDirA);
    $FloatDirectionAii  = DirectionF($PointNii, $MultDirA);

    $OnPlane[$CountVV] = FloatToVec (lineIntersection( $FloatDirNormalDist, $FloatDirectionAii, $eachVecLine, $FloatDirA));
    //Loc $OnPlane[$CountVV];
    $CountVV++;
    }
    return $OnPlane;
    }

    proc vector FindIfCurveIsOrthoEpipol(vector $EpipolD[], vector $CRV_ENDS[], float $DistEnds, vector $LineMid){

    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;


    // when working with the plane get the vanishing points directions


    if(`size($EpipolD)` == 3){

    //print "EpiPolar";

    $Xdirect = $EpipolD[0];
    $Ydirect = $EpipolD[1];
    $Zdirect = $EpipolD[2];
    }else{
    $Xdirect = << 1,0,0>>;
    $Ydirect = << 0,1,0>>;
    $Zdirect = << 0,0,1>>;
    }

    $XYZdirect[0] = $Xdirect;
    $XYZdirect[1] = $Ydirect;
    $XYZdirect[2] = $Zdirect;


    $LineAMain = PositiveDirectionLine($CRV_ENDS[0], $CRV_ENDS[1]);
    $EulerAngleA  = EulerAngB($Xdirect,$LineAMain);
    $EulerAngleB  = EulerAngB($Ydirect,$LineAMain);
    $EulerAngleC  = EulerAngB($Zdirect,$LineAMain);
    $EulerABCi[0]= $EulerAngleA[3];
    $EulerABCi[1]= $EulerAngleB[3];
    $EulerABCi[2]= $EulerAngleC[3];
    $stringF = FloatArrayToStringArray($EulerABCi);
    clear $EmptyIndx;
    $index = CreateIntIndex(3);
    $stringIndTr = IntArrayToStringArray($index);
    SortFloatArrayAndString( $EulerABCi, $stringIndTr, $EmptyIndx);
    $EmptyIndx = ReverseStringArray($EmptyIndx);
    $xyz = $EmptyIndx[0];
    $AxisOrthoLine = $xyz;
    $Anglei = $EulerABCi[$xyz];
    //print $Anglei;
    $NewDirectionZ = $XYZdirect[$xyz];
    $DistEnds= distance2Pts($CRV_ENDS[0], $CRV_ENDS[1]);
    $LineMid = ($CRV_ENDS[0] + $CRV_ENDS[1])/2.0;
    $AngleEpiPole = $Anglei;

    $isOrthoTrueZi = 0;
    if($Anglei < 8.55){
    $isOrthoTrueZi = 1;
    }
    $IsOrthoLineTrue = $isOrthoTrueZi;
    //print $IsOrthoLineTrue;
    return $NewDirectionZ;
    }




    /*
    $StereoCurveZ= `ls -sl`;
    $CurveItemZai = $StereoCurveZ[0];
    $CurveItemZbi = $StereoCurveZ[1];
    */

    global string $PlaneCurveS[];


    proc StereoCurveZ(string $CurveItemZai, string $CurveItemZbi){
    global string $StereoCurveZ[];
    global string $VanishingPointsLinesTempGuides[];
    global int $addNumbersA;
    global float $VanishingPointGlobal[];
    global string $PlaneCurveS[];
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;
    $SnapR = 1.55;
    $Smooth = 398;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 1 -tol 0.05 $CurveItemZai;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 1 -tol 0.05 $CurveItemZbi;
    clear $AllLocPositionsZi;
    $AllLocPositionsZi = VecCurveCvs( $CurveItemZai);
    $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    ResetTranslation({$newPlaneCurveA});
    delete $CurveItemZai;
    $CurveItemZai = $newPlaneCurveA;
    clear $AllLocPositionsZi;
    $AllLocPositionsZi = VecCurveCvs( $CurveItemZbi);
    $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    ResetTranslation({$newPlaneCurveA});
    delete $CurveItemZbi;
    $CurveItemZbi = $newPlaneCurveA;
    $VecCurEndsa = VecCurveEnds({$CurveItemZai});
    $VecCurEndsb = VecCurveEnds({$CurveItemZbi});
    $StereoCurveZ[0]= $CurveItemZai;
    $StereoCurveZ[1]= $CurveItemZbi;
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveCvs($CurveItemZai );
    clear $PositionsZ_B;
    $PositionsZ_B = VecCurveCvs($CurveItemZbi );
    clear $VecPtsMirrorA;
    clear $VecPtsMirrorB;
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
    $CamDirVecNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $MultDirCam = multiplyFloat(-1, $CamDirVecNormal);
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    clear $VecPtsMirrorEnds_A;

    clear $VecPtsMirrorEnds_B;
    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);
    $EpipolPosCamM = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;
    $MidPosFCam = $CamPlane1;
    $FloatDirEpipol = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    $FloatDirEpipolB = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
    $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
    $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);
    $DistTOEpipol_CurEndA = distance2Pts($PointN_Epi, $VecCurEndsb[0]);
    $DistTOEpipol_CurEndB = distance2Pts($PointN_EpiB, $VecCurEndsb[0]);
    $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
    $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
    $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;
    $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
    $BCDiff = abs($BCurEndB - $BCurEndBNN);
    $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd ;
    $BCDiffi = abs($BCurEndB - $BCurEndBNNi);

    $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);
    $FloatDirEndPtsA = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
    $EulerAngleA = EulerAngB($FloatDirEndPtsA, $FloatDirEpipol);
    $EulerAngle_A = $EulerAngleA[3];
    $FloatDirEndPtsB = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
    $EulerAngleB = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);
    $EulerAngle_B = $EulerAngleB[3];
    $FloatDirEndPtsAi = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
    $EulerAngleAi = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);
    $EulerAngle_Ai = $EulerAngleAi[3];
    $FloatDirEndPtsBi = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
    $EulerAngleBi = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);
    $EulerAngle_Bi = $EulerAngleBi[3];
    $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
    $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;
    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);

    $Vecbv  = $VecCurEndsa;
    $Vecbvi = $VecCurEndsb;
    $IfTrue = FindLineCross( $Vecbv , $Vecbvi );
    $weighedtFindings = 0;
    $weighedtFindingsZ = 0;
    $weighedtFindingsN = 0;
    if($IfTrue=1){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;
    }
    if($IntIfNearZero==1){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}
    if($EulerAngle_AB<$EulerAngle_AiBi){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}

    $LengCRV_a = `arclen $CurveItemZai`;
    $CRV_ENDSi = $VecCurEndsa;
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
    //float $DiffMathA = ($LengCRV_a-$DistEndsi) / ($DistEndsi/100.0);

    $LengCRV_b = `arclen $CurveItemZbi`;
    $CRV_ENDSii = $VecCurEndsb;
    $DistEndsii = distance2Pts($CRV_ENDSii[0], $CRV_ENDSii[1]);
    $DiffMathB = $DistEndsii / ($LengCRV_b/100.0);

    $PerDiffSum = ($DiffMathA+$DiffMathB)/2.0;

    //print (" DiffMathA " +$DiffMathA + " DiffMathB " +$DiffMathB +"\n");
    //if(($DiffMathA> 96.5) && ($DiffMathB > 96.5)){
    //$PerDiffSum =99;
    //}else{$PerDiffSum =1;}

    $triggerStraitCRV = 0;
    $triggerNoTransENDA = 0;
    $triggerNoTransENDB = 0;
    $First_Second_Both_None = 0;
    //print ("START FindIfCurveIsOrthoEpipol" +"\n");
    $XYZdirectL[0] = << 1,0,0>>;
    $XYZdirectL[1] = << 0,1,0>>;
    $XYZdirectL[2] = << 0,0,1>>;
    if( $PerDiffSum>97.05){
    print ("FIST IF : ENGAGED PerDiffSum" +$PerDiffSum +"\n");
    print ("ENGAGED FindIfCurveIsOrthoEpipol" +"\n");
    $triggerStraitCRV=1;
    $DDirEpipol = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
    $MidCurveA  = MidPoint($VecCurEndsa[0], $VecCurEndsa[1]);
    $MidCurveB  = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);
    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);

    $EpipolD = $DDirEpipolXYZ;
    $Trueii = 0;

    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    }


    if($weighedtFindingsZ<$weighedtFindingsN){
    /////////////////////////////REMOVED


    /////////////////////////////
    //if(($DistB<$DistA)||($weighedtFindingsZ<$weighedtFindingsN)){
    if( ($weighedtFindingsZ<$weighedtFindingsN)){

    cycleBackgroundColor;
    $PositionsZ_B = ReverseVectorArray($PositionsZ_B);
    $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);
    $VecCurEndsb = ReverseVectorArray($VecCurEndsb);
    $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
    }
    }


    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
    $queryLocCurveEnds3D = `sort $queryLocCurveEnds3D`;
    $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
    $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
    $TrackAllExisting3DCrv = CreatePairIntIndex($SizeCrvi);
    $LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;
    $SizeCrvR = `size($LayerCurvesRangeA)` ;
    clear $ExpandedString;
    $Cn = 0;
    for($eachIntCC in $TrackAllExisting3DCrv){
    $ExpandedString[$Cn] = $LayerCurvesRangeA[$eachIntCC];
    $Cn++;
    }
    $triggerNoTrans = 0;
    $triggerNoTransA = 0;
    $triggerNoTransB = 0;
    $triggerNoTrans = 0;

    clear $IntersectEnds_Ax;
    $iia = 0;


    $trigger_straitC = 0;
    if(!(`size($queryLocCurveEnds3D)` > 2)){
    print ("ENGAGED PerDiffSum " +$PerDiffSum +"\n");
    if($PerDiffSum >95.05){
    $iis = 0;
    for ($eachVecx in  $VecCurEndsb){
    $XIntersect_Ax[$iis] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsb[$iis], $CamPos_M, $VecPtsMirrorEnds_A[$iis]));
    $iis++;
    }
    $XIntersect_Ax[2] =  $XIntersect_Ax[1];
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    $XIntersect_Ax[0] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[0]);
    $XIntersect_Ax[2] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[2]);
    $PositionsZ_Bii= $XIntersect_Ax;
    $PositionsZ_Aii= VecPtsToZMirrorPts($PositionsZ_Bii);
    $ThefirstCurve = VecArrayToCurve($XIntersect_Ax);
    $PtsMirrorAi= VecPtsToZMirrorPts($XIntersect_Ax);
    $ThefirstCurvei = VecArrayToCurve($PtsMirrorAi);

    $trigger_straitC =1;
    }
    }

    ////////////
    if(`size( $queryLocCurveEnds3D)`>2){

    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);
    for ($eachVecx in  $VecCurEndsa)
    {
    $IntersectEnds_Ax[$iia] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsa[$iia], $CamPos_M, $VecPtsMirrorEnds_B[$iia]));
    $iia++;
    }

    $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[0]);
    $AllLocsi = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    $AllLocs_String = IntArrayToStringArray($AllLocsi);
    $newOrdersZA = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    $EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
    $New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
    $Near_index_A = $New_AllLocs_A[0];
    $Distance_A = $distToCurveE_A[$Near_index_A];
    $Found_pt_A = $LocCurveEndsVec3D[$Near_index_A];
    $newOrdersZAM = $Found_pt_A;
    $newOrdersZAM[0] = $Found_pt_A[0] *-1;
    $distToCurveE_B = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[1]);
    $newOrdersZB = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    $EmptyStringNewOrderB = ReverseStringArray($EmptyStringNewOrderB);
    $New_AllLocs_B = ArrayToIntList($EmptyStringNewOrderB);
    $Near_index_B = $New_AllLocs_B[0];
    $Distance_B = $distToCurveE_B[$Near_index_B];
    $Found_pt_B = $LocCurveEndsVec3D[$Near_index_B];
    $newOrdersZBM = $Found_pt_B;
    $newOrdersZBM[0] = $Found_pt_B[0] *-1;

    $PointsA[0] = FloatToVec($Found_pt_A);
    $PointsA[1] = FloatToVec($Found_pt_B);
    $PointsB[0] = FloatToVec($newOrdersZAM); // negative mirror of first endpoint of first curve
    $PointsB[1] = FloatToVec($newOrdersZBM);

    $VecOnPlaneA = VecPointsToCameraPlane($PointsA);
    $VecOnPlaneB = VecPointsToCameraPlane($PointsB);

    $NewFoundLocs[0] = $queryLocCurveEnds3D[$Near_index_A];
    $NewFoundLocs[1] = $queryLocCurveEnds3D[$Near_index_B];
    $arrayCurvesNear[0] = ("Plane"+$NewFoundLocs[0]);
    $arrayCurvesNear[1] = ("Plane"+$NewFoundLocs[1]);
    $NewFoundLocs = $arrayCurvesNear;
    $LocOnPlaneVec = PointArray($NewFoundLocs);
    $distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocOnPlaneVec[0]);
    $distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocOnPlaneVec[1]);
    $TXI = << -1.0 , 1.0, 1.0>>;
    $LoCz_3D[0] = MultVec($IntersectEnds_Ax[0],$TXI);
    $LoCz_3D[1] = MultVec($IntersectEnds_Ax[1], $TXI);

    ////////////////////////
    $DistToIntersectTOnear[0] = distance2Pts($IntersectEnds_Ax[0], $PointsA[0]);
    $DistToIntersectTOnear[1] = distance2Pts($IntersectEnds_Ax[1], $PointsA[1]);
    $DistToIntersectTOnear[2] = distance2Pts($LoCz_3D[0], $PointsB[0]);
    $DistToIntersectTOnear[3] = distance2Pts($LoCz_3D[1], $PointsB[1]);

    $distToPlaneLoc3D[0] = distance2Pts($VecCurEndsa[0], $PointsA[0]);
    $distToPlaneLoc3D[1] = distance2Pts($VecCurEndsa[1], $PointsA[1]);
    $distToPlaneLoc3D[2] = distance2Pts($VecCurEndsb[0], $PointsB[0]);
    $distToPlaneLoc3D[3] = distance2Pts($VecCurEndsb[1], $PointsB[1]);
    //////////////////////////

    $DiffMathA = $DistToIntersectTOnear[0]/ ($distToPlaneLoc3D[0]/100.0);
    $DiffMathB = $DistToIntersectTOnear[1] / ($distToPlaneLoc3D[1]/100.0);
    $DiffMathAm = $DistToIntersectTOnear[2]/ ($distToPlaneLoc3D[2]/100.0);
    $DiffMathBm = $DistToIntersectTOnear[3] / ($distToPlaneLoc3D[3]/100.0);

    $relativeDistanceA = ($DiffMathA+$DiffMathAm)/2.0;
    $relativeDistanceB = ( $DiffMathB+$DiffMathBm)/2.0;
    /*
    $relativeDistanceAi = ($Distance_A+$distToPlaneLoc[0])/2.0;
    $relativeDistanceBi = ($Distance_B+$distToPlaneLoc[1])/2.0;
    $relativeDistanceAZ = distance2Pts($VecOnPlaneA[0], $PointsA[0]);
    $relativeDistanceBZ = distance2Pts($VecOnPlaneB[0], $PointsB[0]);
    $DiffMathAi = $relativeDistanceAi/ ($relativeDistanceAZ/100.0);
    $DiffMathBi = $relativeDistanceBi / ($relativeDistanceBZ/100.0);
    $TimesMathAi = $relativeDistanceA*$relativeDistanceAZ/ ($distToPlaneLoc3D[0]/100.0);
    $TimesMathBi = $relativeDistanceB*$relativeDistanceBZ/ ($distToPlaneLoc3D[1]/100.0);
    //float $SnapR = 1.95;
    print ("\n");
    print ("relativeDistanceA "+"\n");
    print ($relativeDistanceA+"\n");
    print ("relativeDistanceB "+"\n");
    print ($relativeDistanceB+"\n");
    print ("\n");
    print ("TimesMathA "+"\n");
    print ($TimesMathA+"\n");
    print ("\n");
    print ("TimesMathB "+"\n");
    print ($TimesMathB+"\n");
    print ("\n");
    */

    if($relativeDistanceA<$SnapR){
    $triggerNoTransA++;
    }
    if($relativeDistanceA <$SnapR){
    $triggerNoTransB++;
    }
    if(!($relativeDistanceA<$SnapR)){
    $VecOnPlaneA[0] = $VecCurEndsa[0];
    $VecOnPlaneB[0] = $VecCurEndsb[0];
    $triggerNoTransENDA=1;
    }else{$triggerNoTrans++;
    $First_Second_Both_None =0;
    }		if(!($relativeDistanceB<$SnapR)){
    $VecOnPlaneA[1] = $VecCurEndsa[1];
    $VecOnPlaneB[1] = $VecCurEndsb[1];
    $triggerNoTransENDB=1;
    }else{$triggerNoTrans++;
    $First_Second_Both_None =1;

    if($triggerNoTransENDA==0){ $First_Second_Both_None =-2;}

    }

    if($triggerNoTrans==0){
    $First_Second_Both_None =-1;}

    //if(($triggerNoTransENDA +$triggerNoTransENDB)== 2){
    //}

    //if(($triggerNoTransENDA +$triggerNoTransENDB)== 0){
    //}


    $ConnectedEnds = $triggerNoTransENDA + $triggerNoTransENDB;
    if($triggerNoTransENDA==1){
    $UnconnectedEnds[0]= $VecOnPlaneA[0];
    $UnconnectedEnds[1]= $VecOnPlaneB[0];
    }else{$UnconnectedEnds[0]= $VecOnPlaneA[1];
    $UnconnectedEnds[1]= $VecOnPlaneB[1];}

    clear $arrayCurvesNearA;
    clear $arrayCurvesNearA;
    $AddAB = $triggerNoTransA+$triggerNoTransB;


    if($triggerNoTrans!=0){

    $PositionsZ_A = VecCurveCvs($CurveItemZai );
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEndsa,$VecOnPlaneA, $PositionsZ_A);
    $PositionsZ_Bi = Matrix_Curve_TranslationCC($VecCurEndsb, $VecOnPlaneB, $PositionsZ_B);
    clear $VecPtsMirrorA;
    $VecPtsMirrorA= VecPtsToZMirrorPts( $PositionsZ_Ai);
    clear $VecPtsMirrorB;
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_Bi);
    $PositionsZ_A = $PositionsZ_Ai;
    $PositionsZ_B = $PositionsZ_Bi;
    cycleBackgroundColor;
    }

    }

    //print (" IsOrthoTrueZi Eq  "+$IsOrthoLineTrue +"\n");

    if($triggerNoTrans==0){
    if($PerDiffSum >97.0){

    $iis = 0;
    for ($eachVecx in  $VecCurEndsb){
    $XIntersect_Ax[$iis] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsb[$iis], $CamPos_M, $VecPtsMirrorEnds_A[$iis]));
    $iis++;
    }
    $XIntersect_Ax[2] =  $XIntersect_Ax[1];
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    $XIntersect_Ax[0] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[0]);
    $XIntersect_Ax[2] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[2]);

    $PositionsZ_Bii= $XIntersect_Ax;
    $PositionsZ_Aii= VecPtsToZMirrorPts($PositionsZ_Bii);

    $ThefirstCurve = VecArrayToCurve($XIntersect_Ax);
    $PtsMirrorAi= VecPtsToZMirrorPts($XIntersect_Ax);
    $ThefirstCurvei = VecArrayToCurve($PtsMirrorAi);

    $trigger_straitC =1;
    }
    }


    if($triggerNoTrans!=0){

    //print ("triggerNoTrans Doesnt not Eq ZERO" +"\n");

    if($IsOrthoLineTrue==1){
    //print ("IsOrthoLineTrue Eq ONE" +"\n");

    if($AxisOrthoLine!=0){

    //print ("AxisOrthoLine Doesnt not Eq ZERO" +"\n");

    if($First_Second_Both_None>=0){
    //print ("First_Second_Both_None LESS then ZERO!" +"\n");

    //if($AxisOrthoLine==0){
    if($trigger_straitC==1){

    $FloatDirEpipol = DirectionFN($VecOnPlaneA[$First_Second_Both_None], $FoundEpipol);
    $FloatDirEpipolB= DirectionFN($VecOnPlaneB[$First_Second_Both_None], $FoundEpipol);
    if($AxisOrthoLine==0){
    //print ("AxisOrthoLine Eq ZERO!" +"\n");
    //print ("line ortho Direction same as CAM epipole");

    $lineEPointA = MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);

    $Xdirection = << 1.0,0.0,0.0>>;
    $Intersect_LineB_a = FloatToVec (lineIntersection($PointsA[$First_Second_Both_None], $Xdirection, $lineEPointA,(DirectionFN( $CamPos_A,$lineEPointA)) ));

    $Point3DA = $Intersect_LineB_a;
    $Point3DAM = {($Point3DA[0]*-1), $Point3DA[1],$Point3DA[2]};

    }


    if($First_Second_Both_None==1){
    //print ("First_Second_Both_None Eq ONE! " +"\n");
    $PairInt={0,1};

    }else{ $PairInt={2,3};
    //print ("First_Second_Both_None NOT Eq ONE! " +"\n");
    }

    $Intersect_BX= VecPtsToZMirrorPts($IntersectEnds_Ax);
    $PairVectors[0]=FloatToVec(FloatPointsToCamPlane($IntersectEnds_Ax[0]));
    $PairVectors[1]= FloatToVec(FloatPointsToCamPlane($Intersect_BX[0]));
    $PairVectors[2]=FloatToVec(FloatPointsToCamPlane($IntersectEnds_Ax[1]));
    $PairVectors[3]= FloatToVec(FloatPointsToCamPlane($Intersect_BX[1]));
    $EpipolXLine = DirectionFN( $MidEpipolPosFCam, $PairVectors[$PairInt[0]]) ;

    $Intersect_LineB_a = FloatToVec (lineIntersection($VecOnPlaneA[$First_Second_Both_None], $FloatDirEpipol, $MidEpipolPosFCam,$EpipolXLine));
    //Loc $Intersect_LineB_a;
    $Intersect_LineB_b = FloatToVec (lineIntersection($VecOnPlaneB[$First_Second_Both_None], $FloatDirEpipolB, $MidEpipolPosFCam,$EpipolXLine));
    //Loc $Intersect_LineB_b;

    clear $PositionsZ_A;
    clear $PositionsZ_B;
    clear $VecPtsMirrorEnds_A;
    clear $VecPtsMirrorEnds_B;
    clear $VecPtsMirrorA;
    clear $VecPtsMirrorB;
    $PositionsZ_A[0] =  $VecOnPlaneA[$First_Second_Both_None];
    $PositionsZ_A[1]= FloatToVec (MidPoint($VecOnPlaneA[$First_Second_Both_None],$Intersect_LineB_a));
    $PositionsZ_A[2] =  $Intersect_LineB_a;
    $PositionsZ_B[0] =  $VecOnPlaneB[$First_Second_Both_None];
    $PositionsZ_B[1]= FloatToVec (MidPoint($VecOnPlaneB[$First_Second_Both_None], $Intersect_LineB_b));
    $PositionsZ_B[2] =  $Intersect_LineB_b;
    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
    }
    }
    }
    }
    }


    if($trigger_straitC!=1){
    $iiz = 0;

    for ($eachVecx in  $VecPtsMirrorA)
    {
    $Intersect_A[`size($Intersect_A)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_B[$iiz], $CamPos_M, $VecPtsMirrorA[$iiz]));
    $iiz++;
    }

    $ThefirstCurve = VecArrayToCurve($Intersect_A);
    modifySelectedCurves smooth $Smooth 0;
    $Intersect_B= VecPtsToZMirrorPts($Intersect_A);
    $ThefirstCurvei = VecArrayToCurve($Intersect_B);
    modifySelectedCurves smooth $Smooth 0;
    $EndrEndsa = VecCurveEnds({$ThefirstCurvei});
    $EndsAtZero = isCurveEndAtZY($EndrEndsa);
    $STEPSZ = 200;
    $curvesZi = $ThefirstCurve;
    $curvesZi = CurvatureIsCircleData($curvesZi, $STEPSZ, $angleZi, $TotalDegii, $LowX, $TrackCi, $anglesMade);
    delete $ThefirstCurve;
    $ThefirstCurve = $curvesZi;
    $curvesZii = $ThefirstCurvei;
    $curvesZii = CurvatureIsCircleData($curvesZii, $STEPSZ, $angleZi, $TotalDegii, $LowX, $TrackCi, $anglesMade);
    delete $ThefirstCurvei;
    $ThefirstCurvei = $curvesZii;

    if($EndsAtZero>0){
    sets -include ZEdgeCurvesSet ({$ThefirstCurvei,$ThefirstCurve});
    }

    }
    delete $VanishingPointsLinesTempGuides;
    clear $VanishingPointsLinesTempGuides;
    delete $CurveItemZai $CurveItemZbi;
    clear $StereoCurveZ;
    $addNumbersA =0;
    clear $VanishingPointGlobal;

    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $ThefirstCurve;
    ResetTranslation({$ThefirstCurve});
    CurveIndexVecTracking({$ThefirstCurve});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ThefirstCurve;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $ThefirstCurvei;
    ResetTranslation({$ThefirstCurvei});
    CurveIndexVecTracking({$ThefirstCurvei});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ThefirstCurvei;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    }










    proc int isCurveEndAtZY(vector $EndVectors[]){
    $Number = 0;
    for($eachVec in $EndVectors){
    $ThreeFs = $eachVec;
    if($ThreeFs[0] == 0){
    $Number++;
    }}
    return $Number;
    }



    global int $ifSingleCurve;
    $ifSingleCurve =0;
    createDisplayLayer -name "VanishingPointsLines"  -empty;
    setAttr VanishingPointsLines.visibility 1; setAttr VanishingPointsLines.displayType 0; setAttr VanishingPointsLines.color 0;

    ////////////////////////////////////////////////


    /*
    $OneCurve = `ls -sl`;
    $OneCurveS = $OneCurve[0];
    $TFNS = 1;
    $CurveNS = IScircleTF($OneCurveS,$TFNS);
    print $TFNS;
    if($TFNS==1){
    $NewOneCurveS = EllipesSketchFitting($CurveNS, $EmptyVectorArrayA);
    }else{  $NewOneCurveS = $OneCurveS;}

    $NewArrayAEllipZ = NewVecOrderEllipZ($NewOneCurveS, $EmptyVectorArrayA, $MidEpipolPosFCam);
    $OneCurve = `ls -sl`;
    $NewOneCurveSB = EllipesSketchFitting($OneCurve[0], $EmptyVectorArrayB);
    $NewArrayBEllipZ = NewVecOrderEllipZ($NewOneCurveSB, $EmptyVectorArrayB, $MidEpipolPosFCam);
    $StereoCircle = Eval3DCircleStereo( $NewArrayBEllipZ  , $EmptyVectorArrayB ,  $NewArrayAEllipZ , $EmptyVectorArrayA );

    // print $EmptyVectorArrayA;
    $IndexTrackE = CreateIntIndex(`size($EmptyVectorArrayA)`);
    //select -r $NewOneCurveS;
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);
    // Loc $MidEpipolPosFCam;

    $EllipesPos_A = `xform -q -ws -t $NewOneCurveS`;
    $Dir_VecMAIN =  DirectionFN($MidEpipolPosFCam, $EllipesPos_A);

    $TwoZeroOne = {0,1};
    clear $allAngiX; clear $TFmostRArray;
    $threeVecs[0] = FloatToVec($MidEpipolPosFCam);
    $threeVecs[1] = FloatToVec($EllipesPos_A);

    for($EachVector in $EmptyVectorArrayA){
    $DIff = FindDirectionDiff($Dir_VecMAIN, $MidEpipolPosFCam, $EachVector);
    if($DIff!= 0){
    $allAngiX[`size($allAngiX)`]=  VAnglesofThreeVec($MidEpipolPosFCam, $EllipesPos_A, $EachVector);
    $threeVecs[2] = $EachVector;
    $TFmostRArray[`size($TFmostRArray)`] = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);
    }else{ $allAngiX[`size($allAngiX)`]= 0;  $TFmostRArray[`size($TFmostRArray)`] =0;}
    }

    clear $LargestIntR_KEY;
    clear $LargestIntL_KEY;
    clear $AllAngiX_LEFT;
    clear $AllAngiX_RIGHT;
    $COUNT_Nlr = 0;
    for($EachIntarray in $TFmostRArray){
    if($EachIntarray==1){
    $AllAngiX_RIGHT[`size($AllAngiX_RIGHT)`]= $allAngiX[$COUNT_Nlr];
    $LargestIntR_KEY[`size($LargestIntR_KEY)`]=$COUNT_Nlr;
    }
    if($EachIntarray==0){
    $AllAngiX_LEFT[`size($AllAngiX_LEFT)`]= $allAngiX[$COUNT_Nlr];
    $LargestIntL_KEY[`size($LargestIntL_KEY)`]=$COUNT_Nlr;
    }
    $COUNT_Nlr++;
    }


    $LargestIntR = SortNumbersIntIndex($AllAngiX_RIGHT);
    $LargestIntR = ReverseIntArray($LargestIntR);
    // Loc $EmptyVectorArrayA[$LargestIntR_KEY[$LargestIntR[0]]];
    $LargestIntL = SortNumbersIntIndex($AllAngiX_LEFT);
    $LargestIntL = ReverseIntArray($LargestIntL);
    // Loc $EmptyVectorArrayA[$LargestIntL_KEY[$LargestIntL[0]]];
    print $LargestIntR_KEY[$LargestIntR[0]];
    print $LargestIntL_KEY[$LargestIntL[0]];
    // test int $NewStartInt = $LargestIntL_KEY[$LargestIntL[0]];
    //  $IndexTrackE
    $SizeE = `size($EmptyVectorArrayA)`;
    $Add = 0;
    for($EachIntX in $IndexTrackE){
    $NewArrayIntX[`size($NewArrayIntX)`] = fmod(($NewStartInt+$Add),$SizeE);
    $Add++;
    }

    // just to see the result - $NewArrayIntX = ReverseIntArray($NewArrayIntX);

    $NewArrayAEllipZ = NewVecOrderEllipZ($NewOneCurveS, $EmptyVectorArrayA, $MidEpipolPosFCam);
    $OneCurve = `ls -sl`;
    $NewOneCurveSB = EllipesSketchFitting($OneCurve[0], $EmptyVectorArrayB);
    $NewArrayBEllipZ = NewVecOrderEllipZ($NewOneCurveSB, $EmptyVectorArrayB, $MidEpipolPosFCam);
    $StereoCircle = Eval3DCircleStereo( $NewArrayBEllipZ  , $EmptyVectorArrayB ,  $NewArrayAEllipZ , $EmptyVectorArrayA );



    */








    proc float  FindDirectionDiff(vector $Line_Y_zeroMain, vector $VecCurEndsA, vector $VecCurEndsB){
    $Dir_VecA =  DirectionFN($VecCurEndsA,$VecCurEndsB);
    $VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    return $AdditR;
    }

    global int $ForceOrthoOFFON;
    $ForceOrthoOFFON = 0;


    proc string [] ForceOrtho(string  $CurveItemAX[]){

    // string  $CurveItemAX[] =`ls -sl`;
    global string $StereoCurveZ[];
    global int $addNumbersA;
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;

    //string  $CurveItemAX[] =`ls -sl`;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemAX[0];

    /////////////////////
    $Positions = VecCurveEps($CurveItemAX[0]);
    $TempCrv = VecArrayToCurve($Positions);
    delete $CurveItemAX[0];
    $VecCurEnds = VecCurveEnds({$TempCrv});
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEndsOLD = $queryLocCurveEnds;
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );

    if(`size($queryLocCurveEnds)` >= 2){

    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $distancesEachToCurveB = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);

    $ReducedIndexA = floatArrayCountDuplicates($distancesEachToCurve);
    $ReducedIndexB = floatArrayCountDuplicates($distancesEachToCurveB);
    for($eachInt in $ReducedIndexA){
    $distAz[`size($distAz)`]= $distancesEachToCurve[$eachInt];
    }
    for($eachInt in $ReducedIndexB){
    $distBz[`size($distBz)`]= $distancesEachToCurveB[$eachInt];
    }

    //clear $NearestInt;
    //clear $NearestIntB;
    $NearestInt = SortNumbersIntIndex($distAz);
    $NearestIntB = SortNumbersIntIndex($distBz);

    $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];


    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$ReducedIndexA[$NearestInt[0]]];
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$ReducedIndexB[$NearestIntB[0]]];
    $NearestInt[0] =  $NewIntIndexAA;
    $NearestIntB[0] = $NewIntIndexBB;


    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];
    $LocA = $queryLocCurveEnds[$NearestInt[0]];
    $LocB = $queryLocCurveEnds[$NearestIntB[0]];

    //Loc $LocCurveEndsVec[$NearestInt[0]];
    //Loc $LocCurveEndsVec[$NearestIntB[0]];

    clear $EndSnapAndEndProject;
    $Loc_AorB = "";
    //////////////////////////////////////////
    if($NdistA<$NdistB){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    $Loc_AorB="B";
    }else{
    $Loc_AorB="A";
    $LocName =$LocB;
    $NearestIndex=$NearestIntB[0];
    $NearEndZ = $VecCurEnds[1];
    $endNotNearZ[0] = $VecCurEnds[0];}
    //////////////////////
    // very very rare event
    if($NdistA==$NdistB){
    $Loc_AorB="A";
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    }
    /////////////////////
    if($NearestInt[0]==$NearestIntB[0]){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    }
    //////////////////////////////////////////
    $newNames = stringArrayToString($queryLocCurveEnds, " ");
    $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    $AllarrayCurvesNear = stringToStringArray($newNamesResultAX, " ");
    $NewFoundLocs[0]  = $AllarrayCurvesNear[$NearestIndex];
    $arrayCurvesNear[0] = $queryLocCurveEnds[$NearestIndex];
    /*
    // needed for later for edgeCurves and dynamic local axis plane mirroring
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    */


    $LocOnPlaneVec = PointArray($arrayCurvesNear );
    $Loc3D_Vec = PointArray($NewFoundLocs );
    $ALLLoc3D_VecAB = PointArray($AllarrayCurvesNear);

    if($Loc_AorB == "A"){
    $ReducedIndexXAB = $ReducedIndexA;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexA,$ALLLoc3D_VecAB);
    }
    if($Loc_AorB == "B"){
    $ReducedIndexXAB = $ReducedIndexB;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexB,$ALLLoc3D_VecAB);
    }

    $ALLLoc3D_Vec = $ReducedVecAB;

    $MovedEndPointPlane = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    $CRV_ENDSi[0]= $LocOnPlaneVec[0];
    $CRV_ENDSi[1]= $MovedEndPointPlane[0];
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);
    $MidCurveA = MidPoint($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
    $EpipolD = $DDirEpipolXYZ;
    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);
    $XYZdirectL[0] = << 1,0,0>>;
    $XYZdirectL[1] = << 0,1,0>>;
    $XYZdirectL[2] = << 0,0,1>>;
    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    $AxisOrthoLineA = $AxisOrthoLine;
    // 3d start point $Loc3D_Vec[0]  free Endpoint of plane curve $MovedEndPointPlane[0]
    $Dir_CamRay =  DirectionFN($MovedEndPointPlane[0],$CamPos_A);

    // lineIntersection NOTE arguments are in this order: Point then Line ...Point then Line
    $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);

    $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);

    $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    $XYZi  = $PointN_LineC;
    $XYZadd  = $PointN_LineC;

    $XYZi[0] = $XYZadd[0]+$XYZadd[1];
    $XYZi[1] = $XYZadd[1]+$XYZadd[2];
    $XYZi[2] = $XYZadd[0]+$XYZadd[2];
    $iVc = 0;
    clear $TrackFoundN;
    if($AxisOrthoLineA ==2){
    $TwoPointsi[0] = 0;
    }
    if($AxisOrthoLineA ==1){
    $TwoPointsi[0] = 2;
    }
    if($AxisOrthoLineA ==0){
    $TwoPointsi[0] = 1;
    }
    $AXIS = $AxisOrthoLineA;

    clear $ALLlikeness;
    $i = 0;
    $Dist_3DNear = (($Dist_3D/3.0)*2.0);

    for ($each in $ALLLoc3D_Vec){

    $One = $ALLLoc3D_Vec[$i];
    $XY[0] = $Xx  = $One.x;
    $XY[1] = $Yy  = $One.y;
    $XY[2] = $Zz  = $One.z;

    if( $ReducedIndexXAB[$iVc]!= $NearestIndex ){

    $TriggerPoints=0;
    if( (equivalentTol($XYZadd[0], $Xx,  0.01) )==1){
    $All_X[$i] = $Xx;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[1], $Yy,  0.01) )==1){
    $All_Y[$i] = $Yy;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[2], $Zz,  0.01) )==1){
    $All_Z[$i] = $Zz;
    $TriggerPoints++;
    }

    if( $TriggerPoints<2){
    $diffXYZ = `abs ($XY[$AXIS] - $XYZadd[$AXIS])`;
    if(($diffXYZ< $Dist_3DNear)&&($diffXYZ!=0)){
    $All_ZYX[`size($All_ZYX)`] =$XY[$AXIS];
    $All_ZYXDiff[`size($All_ZYXDiff)`] = $diffXYZ;
    }
    }


    if( $TriggerPoints==2){

    $ALLlikeness[`size($ALLlikeness)`] = $ReducedIndexXAB[$i];
    }
    }
    $i++;
    $iVc++;
    }



    if(`size($All_ZYXDiff)`> 0){
    $SortedForce = SortNumbersIntIndex($All_ZYXDiff);
    $newOrderFloat = $All_ZYX[$SortedForce[0]];

    }


    if(`size($ALLlikeness)`> 0){


    select -cl;
    for($eachIn in $ALLlikeness){
    select -add $AllarrayCurvesNear[$eachIn];
    PAUSE;
    }


    clear $NearPointsXYZ;
    $iVc =0;
    for($eachIn in $ALLlikeness){
    if( $iVc!= $NearestIndex ){
    $NearPointsXYZ[`size($NearPointsXYZ )`] =  $ALLLoc3D_VecAB[$eachIn];
    }
    $iVc++;
    }


    $distTo3DCurveEnd = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    $Sorted = SortNumbersIntIndex($distTo3DCurveEnd);
    $NearPointsXYZ = NewVecOrderWithINTKey($Sorted,$NearPointsXYZ);

    clear $SdistTo3DCurveEnd;
    for($eachIn in $Sorted){
    $SdistTo3DCurveEnd[`size($SdistTo3DCurveEnd)`] = $distTo3DCurveEnd[$eachIn];
    }

    $ReducedIndex = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    $ReducedVec = NewVecOrderWithINTKey($ReducedIndex,$NearPointsXYZ);

    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    // if($AdditRi = 0.0){ then snap to point IF the direction is the same

    $OntheSameLine = 0;
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $OntheSameLine =1;
    }


    $CountN = 0;
    for($eachVec in $ReducedVec){


    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $eachVec);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $PointN_LineXYZ = $eachVec;
    print " on same Line ";
    }else{

    $PointN_LineXYZ  = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $eachVec);

    }

    if( (distance2Pts($PointN_LineXYZ, $PointN_LineC))>0.001){
    $LocsV[`size($LocsV)`] = `Loc $PointN_LineXYZ`;
    $CurvesV[`size($CurvesV)`] = curve2points($eachVec, $PointN_LineXYZ);
    PAUSE;
    }

    if($CountN==0){
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapN = $eachVec;
    $SnapPlaceN = $PointN_LineXYZ;
    }

    if($CountN!=0){
    print  $DistSnap;
    if((distance2Pts($PointN_LineXYZ, $PointN_LineC))<  $DistSnap){
    $SnapN = $eachVec;
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapPlaceN = $PointN_LineXYZ;

    }
    }
    $CountN++;
    }



    $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);

    delete $CurvesV;
    delete $LocsV;

    //$EulerAngleA  = EulerAngB($DirLineSnapXYZ,$LineDirect_3D);
    if(($EulerAngleA[3] >85)&&($EulerAngleA[3]<95)){



    $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    if($Dist_3DSnap<($Dist_3D/2.0)){
    cycleBackgroundColor;
    PAUSE;
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    $AddInt = $AdditR;
    if($AddInt == 0){
    $PointN_LineC = $SnapPlaceN;
    PAUSE; PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }else{

    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $FPointN_LineC =  $PointN_LineC;
    $FPointN_LineC[$AXIS] = $newOrderFloat;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }


    }

    }else{
    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }

    //}

    // $LocsV[`size($LocsV)`] = `Loc $First3dIntersect`;
    // $LocsV[`size($LocsV)`] = `Loc $PointN_LineC`;
    // $CurvesV[`size($CurvesV)`] = curve2points($First3dIntersect, $PointN_LineC);

    $Points3DPair_And_2DPair[0]= $Loc3D_Vec[0];
    $Points3DPair_And_2DPair[1]= $PointN_LineC;
    $Points3DPair_And_2DPair[2]= $LocOnPlaneVec[0];
    $Points3DPair_And_2DPair[3]= $NewPlanePoint;

    delete $TempCrv;
    $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 10 -d 3 -tol 0.05 $CurvesVi;

    $Crv_Pts = VecCurveEps($CurvesVi );
    $MirrorAcrossPlaneVecs = VecMultMatrixMirror($Crv_Pts);
    $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    //delete $CurvesV;
    //delete  $LocsV;
    clear $StereoCurveZ;
    $BothCurves[0] = $CurvesVi;
    $BothCurves[1] = $TheSecondCurve;
    $StereoCurveZ = $BothCurves;
    $addNumbersA =-3;
    ResetTranslation($BothCurves);
    CurveIndexVecTracking($BothCurves);
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $BothCurves;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    clear $StereoCurveZ;
    }
    return $BothCurves;
    }

    //////////////////////////////////////////////////////////

    proc int [] floatArrayCountDuplicates(float $listX[]){
    $list = $listX;
    $index = 0;
    $X = 0;
    $Xi = 0;
    $C = 0;
    $result = $list;
    for ($item in $list) {
    $NumberE[$X] = floatArrayCount($item, $result);
    if (1 == $NumberE[$X]) {
    $NoneDup[`size($NoneDup)`] = $Xi;
    }else{
    if (1 < $NumberE[$X]) {
    floatArrayRemoveAtIndex($X, $result);
    $X--;
    }
    }
    $Xi++;
    $X++;	}
    return $NoneDup;
    }

    //////////////////////////////////////////////////////

    proc int floatArrayCount(float $item, float $list[]){
    $result = 0;
    for ($listItem in $list) {
    if ($item == $listItem) $result++;	}
    return $result;
    }

    proc floatArrayRemoveToIndex(int $ix, float $floatArray[]){
    $ixX = 0;
    while($ixX<$ix){
    floatArrayRemoveAtIndex(0, $floatArray);
    $ixX++;
    }
    }



    proc int floatArrayRemoveAtIndex( int $index, float $list[] ){
    $len = size( $list );

    if( $index > $len  || $index < 0 ){
    return( false );
    }

    for( $i = 0; $i < $index; $i++ ){
    $result[$i] = $list[$i];
    }

    for( ; $i < $len - 1; $i++ ){
    $result[$i] = $list[$i + 1];
    }
    $list = $result;
    return( true );
    }




    ////////////////////////////////

    /*

    if(($XY[$TwoPointsi[0]] != $XYZadd[$TwoPointsi[0]])){
    print (" !!!yes TRIGGER two HERE!!"+"\n");

    }


    if( (equivalentTol($XYZadd[0], $Xx,  0.1) )==1){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }
    if( (equivalentTol($XYZadd[1], $Yy,  0.1) )==1){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }
    if( (equivalentTol($XYZadd[2], $Zz,  0.1) )==1){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }


    if (( $XYZadd[0] ==$Xx)&&( $XYZadd[1] ==$Yy)){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }

    if (( $XYZadd[1] ==$Yy)&&( $XYZadd[2] ==$Zz)){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }

    if (( $XYZadd[2] ==$Zz)&&( $XYZadd[0] ==$Xx)){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }

    }
    }
    $iVc++;
    }
    */

    //////////////////////////////////

    /*

    $XYZi  = $PointN_LineC;
    $XYZadd  = $PointN_LineC;
    $XYZi[0] = $XYZadd[0]+$XYZadd[1];
    $XYZi[1] = $XYZadd[1]+$XYZadd[2];
    $XYZi[2] = $XYZadd[0]+$XYZadd[2];
    $iVc = 0;
    clear $TrackFoundN;
    if($AxisOrthoLineA ==2){
    $TwoPointsi[0] = 0;
    }
    if($AxisOrthoLineA ==1){
    $TwoPointsi[0] = 2;
    }
    if($AxisOrthoLineA ==0){
    $TwoPointsi[0] = 1;
    }
    clear $ALLlikeness;

    for ($each in $ALLLoc3D_Vec){


    $One = $ALLLoc3D_Vec[$iVc];
    $XY[0] = $Xx  = $One.x;
    $XY[1] = $Yy  = $One.y;
    $XY[2] = $Zz  = $One.z;


    if  (( $XYZadd[0]!=0 )&&($Xx!=0)){
    if  (( $XYZadd[1]!=0 )&&($Yy!=0)){
    if  (( $XYZadd[2]!=0 )&&($Zz!=0)){
    if($iVc==0){
    $Xd =  ($XYZi[0] - ($Xx )) ;
    $Yd =  ($XYZi[1] - ($Yy )) ;
    $Zd =  ($XYZi[2] - ($Zz)) ;
    }

    if( $iVc!= $NearestIndex ){
    if(($XY[$TwoPointsi[0]] != $XYZadd[$TwoPointsi[0]])){



    //  if  ( (equivalentTol($XY[0], $XYZadd[0],  0.01) )==1 ){

    if (((equivalentTol( $XY[0], $XYZadd[0],  0.00001 ) )!=1 )  || ((equivalentTol($XY[1], $XYZadd[1],  0.00001))!=1) || ((equivalentTol($XY[2], $XYZadd[2],  0.00001))!=1 )){

    //equivalentTol($XY[0], $XYZadd[0],  0.01) equivalentTol($XY[1], $XYZadd[1],  0.01)
    //  if(  ($XY[0] == $XYZadd[0] )   ||   ($XY[1] == $XYZadd[1] )  ||   ($XY[2] == $XYZadd[2] )   ){
    //  if(  ($XY[0] == $XYZadd[0] )   ||   ($XY[1] == $XYZadd[1] )  ||   ($XY[2] == $XYZadd[2] )   ){
    print  " HERE PASSED ";
    if($iVc==13){
    print  " HERE PASSED ";
    }
    if($iVc==0){
    $Xd =  ($XYZi[0] - ($Xx )) ;
    $Yd =  ($XYZi[1] - ($Yy )) ;
    $Zd =  ($XYZi[2] - ($Zz)) ;
    $Dx =  `sqrt ($XYZi[0] + $Xx)`;
    $Dy =  `sqrt ($XYZi[1] + $Yy)`;
    $Dz =  `sqrt ($XYZi[2] + $Zz)`;
    }


    $ALLlikeness[`size($ALLlikeness)`] = $iVc;

    if( $iVc!= 0 ){

    if($Xd > ( `abs($XYZi[0] - ($Xx))` )){
    $Xd = $Xx;
    $TrackN[0]= $iVc;
    }
    if($Xd == ( `abs($XYZi[0] - ($Xx))` )){
    if(`sqrt ($XYZi[0] + $Xx)`< $Dx){
    $TrackN[0]= $iVc;
    $Dx =  `sqrt ($XYZi[0] + $Xx)`;
    }
    }

    if($Yd > ( `abs($XYZi[1] - ($Yy))` )){
    $Yd = $Yy;
    $TrackN[1]= $iVc;}

    if($Yd == ( `abs($XYZi[1] - ($Yy))` )){
    if(`sqrt ($XYZi[1] + $Yy)`< $Dy){
    $TrackN[1]= $iVc;
    $Dy =  `sqrt ($XYZi[1] + $Yy)`;
    }
    }

    if($Zd > ( `abs($XYZi[2] - ($Zz))` )){
    $Zd = $Zz;
    $TrackN[2]= $iVc;}

    if($Zd == ( `abs($XYZi[2] - ($Zz))` )){
    if(`sqrt ($XYZi[2] + $Zz)`< $Dz){
    $TrackN[2]= $iVc;
    $Dz =  `sqrt ($XYZi[2] + $Zz)`;
    }
    }

    }
    }



    ///////////////

    }

    }
    }
    }



    }
    $iVc++;
    }



    */



    //print $ALLlikeness;


    //print $ALLlikeness;
    //print $TrackN;
    //print $NearestIndex


    /*
    if($Xd >= ( ($XYZi[0] - ($Xx+$Yy)) )){
    $Xd = $Xx;
    $TrackN[0]= $iVc;
    if($iVc==13){
    print  " HERE1 ";
    }

    }


    if($Yd >= ( ($XYZi[1] - ($Yy+$Zz)) )){
    $Yd = $Yy;
    $TrackN[1]= $iVc;

    if($iVc==13){
    print  " HERE2 ";
    }
    }


    if($Zd >= ( ($XYZi[2] - ($Xx+$Zz)) )){
    $Zd = $Zz;
    $TrackN[2]= $iVc;
    if($iVc==13){
    print  " HERE3 ";
    }




    clear $NearPointsXYZ;
    for($eachIn in $ALLlikeness){
    $NearPointsXYZ[`size($NearPointsXYZ )`]=  $ALLLoc3D_Vec[$eachIn];

    }

    for($eachIn in $ALLlikeness){
    select -add $AllarrayCurvesNear[$eachIn];

    }
    */










    proc vector [] VecMultMatrixMirror(vector $pointZ[]){

    matrix $m2[4][4]= <<	-1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0>>;

    $MatrixB = `MatrixToFloat($m2)`;
    for($eachVec in $pointZ){
    $FLoatPointA[`size($FLoatPointA)`] = FloatToVec(pointMatrixMult( $eachVec, $MatrixB ));
    }
    return $FLoatPointA;
    }

    ////////////////////////////////

    ////////////////////////////////


    proc vector [] MoveVectors(vector $Pos_A, vector $VecLoc, vector $Crv_Pts[]){

    $DirLine = DirectionFN( $VecLoc, $Pos_A);
    $DistToPoint = distance2Pts($Pos_A, $VecLoc);

    // DISTANCE TIMES DIRECTION VEC PLUS POINT VECTOR To translate
    clear $TranstatedVecs;
    for($eachVector in $Crv_Pts){
    $TranstatedVecs[`size($TranstatedVecs)`] = ($eachVector+($DistToPoint*$DirLine));
    }
    return $TranstatedVecs;
    }

    ////////////////////////////////

    /*
    // playing around  used at the end of new force othro script
    $PointN_Line = ClosestPoint2LineVec($Dir_CamRay, $MovedEndPointPlane[0], $Loc3D_Vec[0]);
    $LocsV[`size($LocsV)`] = `Loc $PointN_Line`;
    $CurvesV[`size($CurvesV)`] = curve2points($MovedEndPointPlane[0], (($Dir_CamRay*$Dist2D3D)+$MovedEndPointPlane[0]));
    $CurvesV[`size($CurvesV)`] = curve2points($Loc3D_Vec[0], $PointN_Line);
    $PointN_LineB = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $PointN_Line);
    $LocsV[`size($LocsV)`] = `Loc $PointN_LineB`;
    $CurvesV[`size($CurvesV)`] = curve2points($PointN_LineB, $PointN_Line);
    */


    proc string [] VanishingCurves( string  $CurveItemA[]){

    //     string  $CurveItemA[] =`ls -sl`;
    global string $VanishingPointsLinesTempGuides[];
    global int $ifSingleCurve;
    //float $SnapD = 0.013;
    $SnapD = 0.003;
    global vector $TempVectorsCrv[];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemA[0];

    /////////////////////
    if(size($TempVectorsCrv)>0){
    clear $TempVectorsCrv;}
    $Positions = VecCurveCvs($CurveItemA[0]);
    $TempCrv = VecArrayToCurve($Positions);

    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $TempCrv;
    $PositionsZ_Ax = VecCurveEps($TempCrv);

    $ZYplaneMatrix[0] = <<0, 0, 0>>;
    $ZYplaneMatrix[1] = <<0, 1, 0>>;
    $ZYplaneMatrix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;

    $TempVectorsCrv  = LineIntersectPlaneCam( $PositionsZ_Ax, $CamPos1, $ZYplaneMatrix);
    delete $TempCrv;
    ////////////////////

    $Pi = 3.1415926535;
    $pi = 3.1415926535;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $CamerasDirectionVector = $CamerasDirectionVectorNormal;
    $MultDirForWard = multiplyFloat(-1, $CamerasDirectionVector);
    $MultDirCam = multiplyFloat(-3, $CamerasDirectionVector);
    $FloatDirectionCamNormalA = AddFloats($CamPos1, $MultDirCam);
    $DirectionVectorXn = {-2,0,0};
    $DirectionVectorX = {2,0,0};
    $DirectionVectorY = {0,-2,0};
    $DirectionVectorYn = {0,2,0};
    $DirectionVectorZn = {0,0,-2};
    $DirectionVectorZ = {0,0,2};
    $VecDirection_A_XYZ[0] = <<-2,0,0>>;
    $VecDirection_A_XYZ[1] = <<2,0,0>>;
    $VecDirection_A_XYZ[2] = <<0,2,0>>;
    $VecDirection_A_XYZ[3] = <<0,-2,0>>;
    $VecDirection_A_XYZ[4] = <<0,0,-2>>;
    $VecDirection_A_XYZ[5] = <<0,0,2>>;
    $VecDirectionXYZ[0] = <<-1,0,0>>;
    $VecDirectionXYZ[1] = <<1,0,0>>;
    $VecDirectionXYZ[2] = <<0,1,0>>;
    $VecDirectionXYZ[3] = <<0,-1,0>>;
    $VecDirectionXYZ[4] = <<0,0,-1>>;
    $VecDirectionXYZ[5] = <<0,0,1>>;
    $FloatPointDirectionXn = AddFloats($CamPos1, $DirectionVectorXn);
    $FloatPointDirectionX = AddFloats($CamPos1, $DirectionVectorX);
    $FloatPointDirectionY = AddFloats($CamPos1, $DirectionVectorY);
    $FloatPointDirectionYn = AddFloats($CamPos1, $DirectionVectorYn);
    $FloatPointDirectionZn = AddFloats($CamPos1, $DirectionVectorZn);
    $FloatPointDirectionZ = AddFloats($CamPos1, $DirectionVectorZ);
    clear $VecXYZs;
    $VecXYZs[0] = FloatToVec($FloatPointDirectionXn);
    $VecXYZs[1] = FloatToVec($FloatPointDirectionX);
    $VecXYZs[2] = FloatToVec($FloatPointDirectionY);
    $VecXYZs[3] = FloatToVec($FloatPointDirectionYn);
    $VecXYZs[4] = FloatToVec($FloatPointDirectionZn);
    $VecXYZs[5] = FloatToVec($FloatPointDirectionZ);
    $VecXYZsOnPlane = VecPointsToCameraPlane($VecXYZs);
    $AverageVecXYZsOnP = AverageVectorPoint($VecXYZsOnPlane);
    $DirectionsZ = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    $FloatDirxyz[0] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[0]));
    $FloatDirxyz[1] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[1]));
    $FloatDirxyz[2] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[3]));
    $FloatDirxyz[3] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[2]));
    $FloatDirxyz[4] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[4]));
    $FloatDirxyz[5] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[5]));
    $Alll = "";
    clear $AllStrings $AnglesAll ;
    for ($eachOrthD in $VecDirectionXYZ){
    $EulerAngleA = EulerAngB($eachOrthD, $CamerasDirectionVector);
    $AnglesAll[`size($AnglesAll)`]= $EulerAngleA[3];
    $stringFloat = FloatArrayToStringArray($EulerAngleA);
    $Alll  = stringArrayToString($stringFloat, " ");
    $AllStrings[`size($AllStrings)`]= $Alll;
    }
    clear $EmptyIndxNewOrder;
    $indexAx = CreateIntIndex(6);
    $stringIndTr = IntArrayToStringArray($indexAx);
    $ANgnew = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
    $EmptyIndxNewOrder = ReverseStringArray($EmptyIndxNewOrder);
    $BestThree = {$EmptyIndxNewOrder[0], $EmptyIndxNewOrder[1], $EmptyIndxNewOrder[2]};
    $BestThree = ReverseStringArray($BestThree);
    $BestThree = stringArrayRemoveDuplicates ($BestThree);
    $indexAxNew = ArrayToIntList( $BestThree);
    $VecCurEnds = VecCurveEnds($CurveItemA);

    $LengCRV_a = `arclen $CurveItemA`;
    $DistEndsi = distance2Pts($VecCurEnds[0], $VecCurEnds[1]);
    $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);

    $AverageVecCurEndsP = AverageVectorPoint($VecCurEnds);
    $Count = 0;
    $CurvePsD = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
    size($EmptyIndxNewOrder);
    $DirectionsZ = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    clear $colori;
    $iiX = 0;
    for($eachDirection in $indexAxNew){
    if($eachDirection ==0 || $eachDirection ==1){$colori[`size($colori)`] = 13;}
    if($eachDirection ==3 || $eachDirection ==2){$colori[`size($colori)`] = 14;}
    if($eachDirection ==4 || $eachDirection ==5){$colori[`size($colori)`] = 6;}
    }
    clear $CurvesV;
    $Cindex = 0;
    for ($eachDii in $indexAxNew){
    $IndexZ = $indexAxNew[$Count];

    $FloatPointDirectionZniY  = AddFloats( $VecCurEnds[1], $VecDirection_A_XYZ[$IndexZ]);
    $VecXYZsOnPlaneiY = VecPointsToCameraPlane($FloatPointDirectionZniY);
    $CurveDirectionZiY =  DirectionF($VecCurEnds[1],  $VecXYZsOnPlaneiY[0]);
    $FloatPointDirectionZniiY = AddFloats( $VecCurEnds[0], $VecDirection_A_XYZ[$IndexZ]);
    $VecXYZsOnPlaneiiY = VecPointsToCameraPlane($FloatPointDirectionZniiY);
    $CurveDirectionZiiY =  DirectionF($VecCurEnds[0],  $VecXYZsOnPlaneiiY[0]);
    $locsAi = lineIntersection($VecCurEnds[1], $CurveDirectionZiY, $VecCurEnds[0],  $CurveDirectionZiiY);

    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[0], $locsAi);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], $colori[$Cindex]);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[1], $locsAi);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], $colori[$Cindex]);
    editDisplayLayerMembers -noRecurse VanishingPointsLines $CurvesV;
    $Cindex++;
    $Count++;
    }

    $ifSingleCurve = 0;
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);

    DirectionFN($MidEpipolPosFCam,$VecCurEnds[1]);
    DirectionFN($VecCurEnds[0],$VecCurEnds[1]);
    $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
    $Dir_VecA =   PositiveDirectionLine($VecCurEnds[0],$VecCurEnds[1]);
    $VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];


    $VecPtsMirrorEnds_A= VecPtsToZMirrorPts( $VecCurEnds);
    $triggerMiddle = 0;
    $VIntersectEnds_A[0] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[1], $CamPos_M, $VecPtsMirrorEnds_A[0]));
    $VIntersectEnds_A[1] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[0], $CamPos_M, $VecPtsMirrorEnds_A[1]));
    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
    $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
    $IntersectEnds_Ai =  FloatPointsToCamPlane($VIntersectEnds_A[0]);
    $IntersectEnds_Bi = FloatPointsToCamPlane($VIntersectEnds_A[1]);
    $CurveItemAa[0] = $CurveItemA[0];
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEndsOLD = queryLocOnLivePlaneBLayer();
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );



    if(`size($queryLocCurveEnds)` > 2){

    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $NearestInt = SortNumbersIntIndex($distancesEachToCurve);
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[0]];
    $distancesEachToCurveB = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    $NearestIntB = SortNumbersIntIndex($distancesEachToCurveB);
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$NearestIntB[0]];


    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];

    if(($NdistA<$SnapD)||($NdistB<$SnapD)){

    $iv = -1;
    $distsA = $NdistA;
    $distsB = $NdistB;
    for (  $i = 1; $i < 5; $i++) {
    if( $distsA < $distsB){
    $NdistA = $distancesEachToCurve[$NearestInt[$i]];
    if($iv==-1){
    $iv++;
    $StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[0]];}
    if (equivalentTol($NdistA, $distsA, 0.001) == 1){
    $StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[$i]];
    }
    }


    }

    //print $StringAllNearA;
    //print ("NdistA :" +$NearestInt[$i]+" "+$NdistA+"  NdistB :"+$NearestIntB[$i]+" "+$NdistB+"\n");

    $newNames = stringArrayToString( $StringAllNearA, " ");
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    $arrayCurvesNearA = stringToStringArray($newNamesResultC, " ");
    $CRV_index_number = 0;
    $CRc = 0;
    $CRcT = 0;
    for($eachCurve in $arrayCurvesNearA){
    if(`sets -im ZEdgeCurvesSet $eachCurve` ==1){
    $CRV_index_number = $CRc;
    $CRcT++;
    break;
    }
    $CRc++;
    }

    if($CRcT ==1){
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[$CRc]];
    }
    }

    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];

    $newNames = stringArrayToString($EmptyStringNewOrderA, " ");
    $newNamesResultAx = substituteAllString($newNames, "Plane", "");
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    $arrayCurvesNear = stringToStringArray($newNamesResultC, " ");
    $NearCurvesEnds[0] = $arrayCurvesNear[0];
    $NearCurvesEnds[1] = $arrayCurvesNear[1];

    $arrayCurvesNearA1 = stringToStringArray($newNamesResultAx, " ");

    $LocCurveEndsVec_3D = PointArray($arrayCurvesNearA1);


    $LoCz_3D = $LocCurveEndsVec_3D;

    /*
    $FloatDirCam[0] = FloatToVec (DirectionF($CamPos1, $VecXYZs[0]));
    $FloatDirCam[1] = FloatToVec (DirectionF($CamPos1, $VecXYZs[1]));
    $PointN_LineA = ClosestPoint2LineVec($LineDirect_3D, $VecCurEnds[0], $LocCurveEndsVec_3D[0]);
    $distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocCurveEndsVec_3D[0]);
    $distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocCurveEndsVec_3D[1]);
    $relativeDistanceA = ($Distance_A+$distToPlaneLoc[0])/2.0;
    $relativeDistanceB = ($Distance_B+$distToPlaneLoc[1])/2.0;
    */



    $TXI = << -1.0 , 1.0, 1.0>>;
    $LoCz_3D[2] = MultVec($LoCz_3D[0],$TXI);
    $LoCz_3D[3] = MultVec($LoCz_3D[1], $TXI);
    for($eachItemVEC in $LoCz_3D){
    $VanishingLOC[`size($VanishingLOC)`] = Loc($eachItemVEC);
    $SetCol = `setAttr ($VanishingLOC[size($VanishingLOC)-1]+".overrideColor ") 6 `;
    setAttr ( $VanishingLOC[size($VanishingLOC)-1]+".scale") 5.0 5.0 5.0;
    }

    appendStringArray($CurvesV, $VanishingLOC, size($VanishingLOC));
    //string $edgeZsetAB[] = `sets -q ZEdgeCurvesSet`;
    //select -r $edgeZsetAB;
    $edgeZsetA = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[0]`;
    $edgeZsetB = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[1]`;
    $COuntN = 0;
    for($eachVec in $LocCurveEndsVec_3D){
    $ThreepointVecs = $eachVec;
    if (equivalentTol($ThreepointVecs[0], 0.00, 0.001) == 1){
    $EDGEpoints[$COuntN]= 1;
    }else{$EDGEpoints[$COuntN]= 0;}
    $COuntN++;
    }
    $edgeZsetA =$EDGEpoints[0];
    $edgeZsetB =$EDGEpoints[1];


    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    if(($NearCurvesEnds[0] == $NearCurvesEnds[1])&&( ($edgeZsetA+$edgeZsetB) ==2)){

    if($NdistA<$NdistB){
    $edgeZsetA =1;
    $edgeZsetB =0;
    }
    if($NdistA>$NdistB){
    $edgeZsetA =0;
    $edgeZsetB =1;
    }
    if($edgeZsetA==0){$NdistA=100;}
    if($edgeZsetB==0){$NdistB=100;}

    }
    }

    if(($NdistA>$SnapD)&&($NdistB>$SnapD)){
    $edgeZsetA =0;
    $edgeZsetB =0;
    }


    }



    if(($edgeZsetA==1)&&($NdistA<$SnapD)){
    $pointNearEdgeCurve[0]= 1;
    }
    if(($edgeZsetA==1)&&($NdistA>$SnapD)){
    $pointNearEdgeCurve[0]= 0;
    }
    if(($edgeZsetA==0)&&($NdistA>$SnapD)){
    $pointNearEdgeCurve[0]= 0;
    }
    if(($edgeZsetA==0)&&($NdistA<$SnapD)){
    $pointNearEdgeCurve[0]= 2;
    }

    if(($edgeZsetB==1)&&($NdistB<$SnapD)){
    $pointNearEdgeCurve[1]= 1;
    }
    if(($edgeZsetB==1)&&($NdistB>$SnapD)){
    $pointNearEdgeCurve[1]= 0;
    }
    if(($edgeZsetB==0)&&($NdistB>$SnapD)){
    $pointNearEdgeCurve[1]= 0;
    }
    if(($edgeZsetB==0)&&($NdistB<$SnapD)){
    $pointNearEdgeCurve[1]= 2;
    }



    /////////////////////////////////////////////

    if($edgeZsetA==1){
    $EdgeDist =$NdistA;
    }else{$EdgeDist=$NdistB;}

    $SnappingVector = 0;
    if($NdistA<$NdistB){
    $SnappingVector=0;
    }else{$SnappingVector=1;}

    if($NdistA>$SnapD){
    $edgeZsetA = 0;
    }
    if($NdistB>$SnapD){
    $edgeZsetB = 0;
    }
    $OneIsNotNearThePlane = 0;
    if(($NdistA>$SnapD)||($NdistB<$SnapD)){
    if(($NdistA<$SnapD)||($NdistB>$SnapD)){
    $OneIsNotNearThePlane =1;
    }
    }

    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    if(($edgeZsetA==1)||($edgeZsetB==1)){
    $EdgeDist =0.001;
    }
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




    if($pointNearEdgeCurve[0]+$pointNearEdgeCurve[1]== 1){



    $newNamesResultA1 = substituteAllString($newNames, "Plane", "");
    $ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
    $ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
    $A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
    $A= `MakeCleanFloats($A)`;
    $B= `MakeCleanFloats($B)`;
    if(($A[0] ==0)||($B[0] ==0)){

    $triggerMiddle =2;
    $ifSingleCurve=1;
    if($edgeZsetA==1){
    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
    $NearVecPts[1]= $VecCurEnds[1];
    }else{
    $NearVecPts[0]= $VecCurEnds[0];
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
    }
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    if($EdgeDist<2.5){

    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    $PositionsZ_Aii = $PositionsZ_Ai;
    }
    $PositionsZ_Aiix[0] = <<0, 0, 0>>;
    $PositionsZ_Aiix[1] = <<0, 1, 0>>;
    $PositionsZ_Aiix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    if($EdgeDist<2.5){
    $VecTest  = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
    }else{$VecTest  = LineIntersectPlaneCam($PositionsZ_A, $CamPos1, $PositionsZ_Aiix);
    }
    $CurveAv[0] = VecArrayToCurveB($VecTest);
    }

    }



    if( $pointNearEdgeCurve[1]==1){

    $newNamesResultA1 = substituteAllString($newNames, "Plane", "");
    $ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
    $ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
    $A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
    $A = MakeCleanFloatsZ($A);
    $B = MakeCleanFloatsZ($B);

    if(($A[0] ==0)&&($B[0] ==0)){

    // NOTE these two
    $triggerMiddle =2;
    $ifSingleCurve=1;

    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    delete $CurveItemA;
    $CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);

    $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    if($DiffMathA >95.0){
    $PositionsZ_Aii[0] = $NearVecPts[0];
    $PositionsZ_Aii[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
    $PositionsZ_Aii[2]= $NearVecPts[1];

    } else{
    $PositionsZ_Aii = $PositionsZ_Ai;}
    $PositionsZ_Aiix[0] = <<0, 0, 0>>;
    $PositionsZ_Aiix[1] = <<0, 1, 0>>;
    $PositionsZ_Aiix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $VecTest = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
    if($DiffMathA >95.0){	$CurveAv[0] = VecArrayToCurve($VecTest);}else{
    $CurveAv[0] = VecArrayToCurve($VecTest);}
    }
    }


    if($triggerMiddle==0){

    if($GetSizeOfCRV_ends>0){
    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);
    $distancesTo3DCurveEnd = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
    $Sorted = SortNumbersIntIndex($distancesTo3DCurveEnd);
    $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
    $distancesTo3DCurveEndi = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
    $Sortedi = SortNumbersIntIndex($distancesTo3DCurveEndi);
    $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
    $FistAndSecond[0]=$LocCurveEndsVec3D[$Sorted[0]];
    $FistAndSecond[1]=$LocCurveEndsVec3D[$Sortedi[0]];
    $LocNames[0]=$queryLocCurveEnds3D[$Sorted[0]];
    $LocNames[1]=$queryLocCurveEnds3D[$Sortedi[0]];
    $LocNames[2]=$queryLocCurveEnds3D[$Sorted[1]];
    $LocNames[3]=$queryLocCurveEnds3D[$Sortedi[1]];
    $VecA = $FistAndSecond[0];
    $VecB = $FistAndSecond[1];
    $XX = $VecA.x;
    $XXX = $VecB.x;
    if( ($XX*-1)==$XXX){
    if($NptsDist<2.5){

    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($VecA));
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($VecB));
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    delete $CurveItemA;
    $CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);
    $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    clear $PositionsZ_A;

    if($DiffMathA >95.0){

    $PositionsZ_Ai[0] = $NearVecPts[0];
    $PositionsZ_Ai[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
    $PositionsZ_Ai[2]= $NearVecPts[1];

    }else{
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    }
    $ReversePositionsZ_Ai = ReverseVectorArray($PositionsZ_Ai);
    clear $PtsMirrorAi;
    $PtsMirrorAi= VecPtsToZMirrorPts($ReversePositionsZ_Ai);
    $iiz = 0;
    clear $XIntersect_Ax;
    for ($eachVecx in  $ReversePositionsZ_Ai){
    $XIntersect_Ax[`size($XIntersect_Ax)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_Ai[$iiz], $CamPos_M, $PtsMirrorAi[$iiz]));
    $iiz++;
    }
    if($DiffMathA >95.0){
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    }

    $CurveAv =  VecArrayToSplitCurve($XIntersect_Ax);
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
    $evalSmoothi += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmoothi);
    $ifSingleCurve=1;
    }
    }
    }
    }

    $VanishingPointsLinesTempGuides = $CurvesV;
    if(( $ifSingleCurve == 1)&&($triggerMiddle ==0)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[1];
    sets -include ZEdgeCurvesSet $CurveAv;
    }else{
    if(( $ifSingleCurve == 1)&&($triggerMiddle ==1)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    }
    }

    if( ($ifSingleCurve == 1)&&($triggerMiddle ==2)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv;
    $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    sets -include ZEdgeCurvesSet $CurveAv;
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    }
    return $CurvesV;
    }

    proc vector [] VecPointsToCameraPlane(vector $V[]){
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+($D1*$F3);
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    return $O;
    }
}


/******************************************************************************
 * @procedure    AngleofTwoLines
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $vecA : vector
 *   $vecB : vector
 *   $vecC : vector
 *   $vecD : vector
 *
 * @returns      float
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float AngleofTwoLines(vector $vecA, vector $vecB, vector $vecC, vector $vecD)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $angleA;
    float $AngleB[] = EulerAngB((DirectionFN($vecA, $vecB)), (DirectionFN($vecC, $vecD)));

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $AngleB = EulerAngB((DirectionFN($vecA, $vecB)), (DirectionFN($vecC, $vecD)));
    $angleA = $AngleB[3];
    return $angleA;

}


/******************************************************************************
 * @procedure    CreateCrvInter
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $crv1 : string
 *   $crv2 : string
 *   $useDir : int
 *   $tolerance : float
 *   $intersections1 : float[]
 *   $intersections2 : float[]
 *
 * @returns      string
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string CreateCrvInter(string $crv1, string $crv2, int $useDir, float $tolerance, float $intersections1[], float $intersections2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numIparms = size($intersections1);
    string $intersectNode = `createNode curveIntersect`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    // Create the intersect node
    $intersectNode = `createNode curveIntersect`;
    setAttr ($intersectNode + ".tolerance") $tolerance;
    connectAttr ($crv1 + ".worldSpace") ($intersectNode + ".inputCurve1");
    connectAttr ($crv2 + ".worldSpace") ($intersectNode + ".inputCurve2");
    setAttr ($intersectNode + ".useDirection") $useDir;
    // Check if there are any intersections.  If not, then delete
    // the node and return nothing.
    //
    $intersections1 = `getAttr ($intersectNode + ".parameter1")`;
    $numIparms = size($intersections1);
    if( $numIparms == 0 ) {
    delete $intersectNode;
    $intersectNode = "";
    } else {
    $intersections2 = `getAttr ($intersectNode + ".parameter2")`;
    }
    // remenber to
    delete $intersectNode;
    return $intersectNode;

}


/******************************************************************************
 * @procedure    CreateCrvInterTF
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $crv1 : string
 *   $Allcrv2 : string[]
 *   $useDir : int
 *   $tolerance : float
 *   $intersections1 : float[]
 *   $intersections2 : float[]
 *
 * @returns      int []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] CreateCrvInterTF(string $crv1, string $Allcrv2[], int $useDir, float $tolerance, float $intersections1[], float $intersections2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $TF = 0;
    int $CurveIndexInter[];
    int $numIparms = size($intersectionsA);
    float $intersectionsA[];
    float $intersections1A[];
    float $intersections1B[];
    string $intersectNode = `createNode curveIntersect`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $TF = 0;
    // Create the intersect node
    for($eachCurve in $Allcrv2){
    $intersectNode = `createNode curveIntersect`;
    setAttr ($intersectNode + ".tolerance") $tolerance;
    connectAttr ($crv1 + ".worldSpace") ($intersectNode + ".inputCurve1");
    connectAttr ($eachCurve + ".worldSpace") ($intersectNode + ".inputCurve2");
    setAttr ($intersectNode + ".useDirection") $useDir;
    // Check if there are any intersections.  If not, then delete
    // the node and return nothing.
    $intersectionsA = `getAttr ($intersectNode + ".parameter1")`;
    $numIparms = size($intersectionsA);
    if( $numIparms == 0 ) {
    $TF=0;
    } else {
    $TF=1;
    $intersections1A = `getAttr ($intersectNode + ".parameter1")`;
    $intersections1B = `getAttr ($intersectNode + ".parameter2")`;
    AppendFloatArray($intersections1,$intersections1A);
    AppendFloatArray($intersections1,$intersections1B);
    print $eachCurve;
    }
    $CurveIndexInter[`size($CurveIndexInter)`] = $TF;
    delete $intersectNode;
    }
    // remenber to

    return $CurveIndexInter;

}


/******************************************************************************
 * @procedure    NewFloatOrderWithIndexKey
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $IndexTrack : int[]
 *   $NewFloat : float[]
 *
 * @returns      float[]
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] NewFloatOrderWithIndexKey(int $IndexTrack[], float $NewFloat[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $newOrderVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($eachV in $IndexTrack){
    $newOrderVec[`size($newOrderVec)`] = $NewFloat[$eachV];
    }
    return $newOrderVec;

}


/******************************************************************************
 * @procedure    FindEqualVec
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $VectorA : vector[]
 *   $Vec : vector
 *
 * @returns      int []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] FindEqualVec(vector $VectorA[], vector $Vec)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CountN = 0;
    int $foundN[];
    int $CombA;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CountN = 0;
    for($eachMvec in $VectorA){
    $CombA = PointsEquivalentTol ($eachMvec, $Vec);
    if($CombA ==3){
    $foundN[`size($foundN)`]= $CountN;
    }
    $CountN++;

    }

    return $foundN;

}


/******************************************************************************
 * @procedure    DistanceSortStereoCrv
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $distToCurveE_A : float[]
 *   $LocCurveEndsVec3D : vector[]
 *   $IntersectEnds_Ai : vector
 *   $New_AllLocs_AI : int[]
 *   $Distance_A : float
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] DistanceSortStereoCrv(float $distToCurveE_A[], vector $LocCurveEndsVec3D[], vector $IntersectEnds_Ai, int $New_AllLocs_AI[], float $Distance_A)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $AllLocsi[] = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    int $New_AllLocs_A[];
    int $Near_index_A = $New_AllLocs_A[0];
    float $newOrdersZA[] = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    float $Found_pt_A[] = $LocCurveEndsVec3D[$Near_index_A];
    string $AllLocs_String[] = IntArrayToStringArray($AllLocsi);
    string $EmptyStringNewOrderA[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ai);
    $AllLocsi = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    $AllLocs_String = IntArrayToStringArray($AllLocsi);
    $newOrdersZA = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    $EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
    $New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
    $Near_index_A = $New_AllLocs_A[0];
    $Distance_A = $distToCurveE_A[$Near_index_A];
    $Found_pt_A = $LocCurveEndsVec3D[$Near_index_A];
    $New_AllLocs_AI = $New_AllLocs_A;
    return $Found_pt_A;

}


/******************************************************************************
 * @procedure    isCurveEndAtZY
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $EndVectors : vector[]
 *
 * @returns      int
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int isCurveEndAtZY(vector $EndVectors[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Number = 0;
    float $ThreeFs[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Number = 0;
    for($eachVec in $EndVectors){
    $ThreeFs = $eachVec;
    if($ThreeFs[0] == 0){
    $Number++;
    }
    }
    return $Number;

}


/******************************************************************************
 * @procedure    ClosestPoint2LineVec
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $DirectionLineF : float[]
 *   $PointOnLine : float[]
 *   $PointN : float[]
 *
 * @returns      vector
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector ClosestPoint2LineVec(float $DirectionLineF[], float $PointOnLine[], float $PointN[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $locsA[];
    float $Addit[] = $VecLineDirM;
    float $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    float $MultDirOne[] = multiplyFloat(1.0, $DirectionLineF);
    float $AddMultF[] = AddFloats($PointOnLine, $MultDirOne);
    float $FDirNorA[] = Normal3Points($PointOnLine, $AddMultF, $PointN);
    float $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    float $MultDirMx[] = multiplyFloat($DistToLineSTart, $FDirNorA);
    float $AddMultMiiFx[] = AddFloats($PointOnLine, $MultDirMx);
    float $FDirNorB[] = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);
    float $MultDirMxz[] = multiplyFloat($DistToLineSTart,  $FDirNorB);
    float $AddMultMiiFxz[] = AddFloats($PointOnLine, $MultDirMxz);
    vector $VlocA;
    vector $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    vector $VecLineDir = PositiveDir($DirectionLineF);
    vector $VecLineDirM = $VecLineDiri-$VecLineDir;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
    $VecLineDir = PositiveDir($DirectionLineF);

    $VecLineDirM = $VecLineDiri-$VecLineDir;
    //if on line Result: <<1, 1, 1>>  a point on the line and the point in question directions vector Mult//

    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];

    if($AdditR != 0.0){
    $MultDirOne = multiplyFloat(1.0, $DirectionLineF);
    $AddMultF = AddFloats($PointOnLine, $MultDirOne);
    $FDirNorA = Normal3Points($PointOnLine, $AddMultF, $PointN);
    $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    $MultDirMx = multiplyFloat($DistToLineSTart, $FDirNorA);
    $AddMultMiiFx = AddFloats($PointOnLine, $MultDirMx);
    $FDirNorB = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);
    $MultDirMxz = multiplyFloat($DistToLineSTart,  $FDirNorB);
    $AddMultMiiFxz = AddFloats($PointOnLine, $MultDirMxz);
    $locsA = lineIntersection($PointN, $FDirNorB, $PointOnLine, $DirectionLineF);

    $VlocA = <<$locsA[0],$locsA[1],$locsA[2]>>;
    }else{$VlocA = FloatToVec($PointN);}

    return $VlocA;

}


/******************************************************************************
 * @procedure    PointDirTang2LineVec
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $DirectionLineF : float[]
 *   $PointOnLine : float[]
 *   $PointN : float[]
 *
 * @returns      vector
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector PointDirTang2LineVec(float $DirectionLineF[], float $PointOnLine[], float $PointN[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MultDirOne[] = multiplyFloat(1.0, $DirectionLineF);
    float $AddMultF[] = AddFloats($PointOnLine, $MultDirOne);
    float $FDirNorA[] = Normal3Points($PointOnLine, $AddMultF, $PointN);
    float $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    float $MultDirMx[] = multiplyFloat($DistToLineSTart, $FDirNorA);
    float $AddMultMiiFx[] = AddFloats($PointOnLine, $MultDirMx);
    float $FDirNorB[] = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);
    vector $VlocA = <<$FDirNorB[0],$FDirNorB[1],$FDirNorB[2]>>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MultDirOne = multiplyFloat(1.0, $DirectionLineF);
    $AddMultF = AddFloats($PointOnLine, $MultDirOne);
    $FDirNorA = Normal3Points($PointOnLine, $AddMultF, $PointN);
    $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    $MultDirMx = multiplyFloat($DistToLineSTart, $FDirNorA);
    $AddMultMiiFx = AddFloats($PointOnLine, $MultDirMx);
    $FDirNorB = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);

    $VlocA = <<$FDirNorB[0],$FDirNorB[1],$FDirNorB[2]>>;

    return $VlocA;

}


/******************************************************************************
 * @procedure    IteratCurve
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $step : float
 *   $paramlocatorpointOnCurvex : string
 *   $curveMin : float
 *   $FindSteps : int
 *
 * @returns      string
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string IteratCurve(float $step, string $paramlocatorpointOnCurvex, float $curveMin, int $FindSteps)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $MasterCount = 0;
    int $Par = 0;
    int $a;
    int $ii = 0;
    int $CountSteps;
    float $CircleCenter[];
    float $values[];
    float $CurvatureRadi;
    string $circlesZ[];
    vector $tan;
    vector $norm;
    vector $bi;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $MasterCount = 0;
    $curve = "curve -d 3";



    while ($FindSteps < 4){
    $curve = "curve -d 3";

    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    $CircleCenter = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureCenter")`;
    $tan = `getAttr  ($paramlocatorpointOnCurvex +  ".normal")`;
    $norm = `getAttr  ($paramlocatorpointOnCurvex +  ".tangent")`;
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
    << ($norm.x), ($norm.y), ($norm.z) >>`;


    if ( $CurvatureRadi <=  $curveMin){
    $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
    if((fmod($CountSteps, 12))== 2){
    $circlesZ[`size($circlesZ)`] = Circles_Direction($CircleCenter, $bi, $CurvatureRadi);
    }
    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    if((fmod($CountSteps, 12))== 2){
    $circlesZ[`size($circlesZ)`] =Circles_Direction($CircleCenter, $bi, $CurvatureRadi);
    }
    $CountSteps++;
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
    if((fmod($CountSteps, 12))== 2){
    $circlesZ[`size($circlesZ)`] =Circles_Direction($CircleCenter, $bi, $CurvatureRadi);
    }
    $CountSteps++;
    }
    }
    $FindSteps = $CountSteps;
    if($FindSteps < 4){$curveMin += 8.0; $curve = "curve -d 3"; delete $circlesZ;}
    if($MasterCount== 4){break;}
    $MasterCount++;

    }

    return $curve;

}


/******************************************************************************
 * @procedure    makeCurvePointDirectionLengthN
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Length : float
 *   $Direction : float[]
 *   $posA : float[]
 *
 * @returns      vector []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] makeCurvePointDirectionLengthN(float $Length, float $Direction[], float $posA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MultDirA[] = multiplyFloat(($Length/2.0),  $Direction);
    float $DirectionN[];
    float $MultDirB[] = multiplyFloat(($Length/2.0),  $DirectionN);
    float $FDirA[] = AddFloats($posA, $MultDirA);
    float $FDirB[] = AddFloats($posA, $MultDirB);
    string $CurveBetween;
    vector $Avec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MultDirA = multiplyFloat(($Length/2.0),  $Direction);
    $DirectionN = multiplyFloatArray(-1.0,$Direction);
    $MultDirB = multiplyFloat(($Length/2.0),  $DirectionN);
    $FDirA = AddFloats($posA, $MultDirA);
    $FDirB = AddFloats($posA, $MultDirB);
    $Avec[0]= FloatToVec($FDirA);
    $Avec[1]= FloatToVec($FDirB);
    $CurveBetween = curve2points($FDirA,  $FDirB);
    return $Avec;

}


/******************************************************************************
 * @procedure    LockEndsAverageCurveVec
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $newVec : vector[]
 *
 * @returns      vector []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] LockEndsAverageCurveVec(vector $newVec[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $AVvects[];
    vector $Aver;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $range = 3;
    $TotalS = `size($newVec)`;
    $indexState = 0;
    while($indexState<$TotalS){
    $countS=1;
    $Xs=0;
    while($countS<$range){
    $indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
    $indexRight = fmod(($indexState + $countS),$TotalS);
    $indexLeftS[$Xs] = $indexLeft;
    $indexRightS[$Xs]= $indexRight;
    $countS++;
    $Xs++;
    }

    if(($indexState<=2)||($indexState>=($TotalS-3))){
    if($indexState<=2){
    $Aver = (( ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec[$indexState])/2.5;
    $AVvects[$indexState] = $Aver;
    }
    if($indexState>=($TotalS-3)){
    $Aver = (( ($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0))+$newVec[$indexState])/2.5;
    $AVvects[$indexState] = $Aver;
    }
    }else{
    $Aver = ((($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0) + ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec [$indexState])/4.0;
    $AVvects[$indexState] = $Aver;
    }
    clear $indexLeftS;
    clear $indexRightS;
    $indexState++;
    }
    return $AVvects;

}


/******************************************************************************
 * @procedure    CurvatureUtility
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $curvesZ : string
 *   $NumberofSteps : int
 *   $curvature : float[]
 *   $C : int[]
 *   $TotalCA : float
 *
 * @returns      vector []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] CurvatureUtility(string $curvesZ, int $NumberofSteps, float $curvature[], int $C[], float $TotalCA)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $ii = 0;
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $NewIndexN[];
    float $step = $NumberofSteps;
    float $CRVRadi[];
    float $CIrceP[];
    float $DistanceS[];
    string $myCurve = $curvesZ;
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size ($CurveSelection);
    vector $CurveVectors[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global int $SortDistanceIntG;
    $step = $NumberofSteps;
    $myCurve = $curvesZ;
    $ii = 0;
    $TotalCAX =0;
    $t=0.0;
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;


    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );

    $CIrceP = `xform -q -ws -t $curvesZ`;
    for($a = 0.0; $t < $numEPrealNum;$a++){

    $t =  $a/$step;
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
    $CRVRadi[$ii] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;



    $DistanceS[$ii] = distance2Pts($values,$CIrceP);

    $ii++;
    }
    $NewIndexN = SortNumbersIntIndex($DistanceS);
    $SortDistanceIntG = $NewIndexN[0];
    delete $paramlocatorpointOnCurvex;

    for($eachCURVA in $CRVRadi){
    $TotalCAX +=  $eachCURVA;
    }
    $TotalCA = $TotalCAX;
    $curvature = $CRVRadi;
    return $CurveVectors;

}


/******************************************************************************
 * @procedure    AverageCurveVec
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $newVec : vector[]
 *
 * @returns      vector []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] AverageCurveVec(vector $newVec[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $AVvects[];
    vector $Aver;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $range = 3;
    $TotalS = `size($newVec)`;
    $indexState = 0;
    while($indexState<$TotalS){

    $countS=1;
    $Xs=0;
    while($countS<$range){
    $indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
    $indexRight = fmod(($indexState + $countS),$TotalS);
    $indexLeftS[$Xs] = $indexLeft;
    $indexRightS[$Xs]= $indexRight;
    $countS++;
    $Xs++;
    }
    $Aver = ((($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0) + ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec [$indexState])/4.0;
    $AVvects[$indexState] = $Aver;
    clear $indexLeftS;
    clear $indexRightS;
    $indexState++;
    }
    return $AVvects;

}


/******************************************************************************
 * @procedure    VecArrayToCurveB
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $FixVec : vector[]
 *
 * @returns      string
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string VecArrayToCurveB(vector $FixVec[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sIZes = `size $FixVec `;
    int $NUmers[] = CreateIntIndex($sIZes);
    float $valuesBi[] = $eachVeCx;
    string $K = "";
    string $curve = "curve -d 3";
    string $Newcurvez = `eval($curve)`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $sIZes = `size $FixVec `;
    $NUmers = CreateIntIndex($sIZes);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $K += "\-k"+" "+ $sIZes+" ";
    $sIZes++;
    $K += "\-k"+" "+ $sIZes+" ";
    $curve = "curve -d 3";
    for ($eachVeCx in $FixVec){
    $valuesBi = $eachVeCx;
    $curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    }
    $Newcurvez = `eval($curve)`;
    return $Newcurvez;

}


/******************************************************************************
 * @procedure    TwoVecsOrFloats
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $p1p2 : float[]
 *   $p1p3 : float[]
 *
 * @returns      vector
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector TwoVecsOrFloats(float $p1p2[], float $p1p3[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $Ui = FloatToVec($p1p2);
    vector $Vi = FloatToVec($p1p3);
    vector $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Ui = FloatToVec($p1p2);
    $Vi = FloatToVec($p1p3);
    $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;
    return $VEcLine;

}


/******************************************************************************
 * @procedure    MostRightClockWiseInt
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Vecs : vector[]
 *   $Two : int[]
 *
 * @returns      int
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int MostRightClockWiseInt(vector $Vecs[], int $Two[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $TwoNew[];
    float $point1[] = FloatToVec($Vecs[0]);
    float $point2[] = FloatToVec($Vecs[1]);
    float $point3[] = FloatToVec($Vecs[2]);
    float $normalA[] = `unit ($normalV[0])`;
    float $normalB[] = `unit ($normalV[1])`;
    float $normalAAdd = $normalA[0] + $normalA[1];
    float $normalAAdd2 = $normalB[0] + $normalB[1];
    string $ThreePoints[] = { "0", "1", "2"};
    vector $U1 = TwoVecsOrFloats($point2, $point1);
    vector $V1 = TwoVecsOrFloats($point3, $point1);
    vector $U2 = TwoVecsOrFloats($point3, $point1);
    vector $V2 = TwoVecsOrFloats($point2, $point1);
    vector $U3 = TwoVecsOrFloats($point1, $point3);
    vector $V3 = TwoVecsOrFloats($point2, $point3);
    vector $normalV[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $ThreePoints = { "0", "1", "2"};
    $point1 = FloatToVec($Vecs[0]);
    $point2 = FloatToVec($Vecs[1]);
    $point3 = FloatToVec($Vecs[2]);
    $U1 = TwoVecsOrFloats($point2, $point1);
    $V1 = TwoVecsOrFloats($point3, $point1);
    $U2 = TwoVecsOrFloats($point3, $point1);
    $V2 = TwoVecsOrFloats($point2, $point1);
    $U3 = TwoVecsOrFloats($point1, $point3);
    $V3 = TwoVecsOrFloats($point2, $point3);
    clear $normalV;
    $normalV[0] = FloatToVec( crossProduct( $U1, $V1, 0, 1 ) );
    $normalV[1] = FloatToVec( crossProduct( $U2, $V2, 0, 1 ) );
    $normalA = `unit ($normalV[0])`;
    $normalB = `unit ($normalV[1])`;
    $normalAAdd = $normalA[0] + $normalA[1];
    $normalAAdd2 = $normalB[0] + $normalB[1];

    if( $normalAAdd< $normalAAdd2){
    $TwoNew ={$Two[1], $Two[0]};

    }else{
    $TwoNew ={$Two[0], $Two[1]};

    }
    //$Two = $TwoNew;
    return $TwoNew[0];

}


/******************************************************************************
 * @procedure    CreateIntIndexF
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $ArraySize : int
 *   $Fstep : float
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] CreateIntIndexF(int $ArraySize, float $Fstep)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iNdex = 0;
    float $FArrayInex[];
    float $AddF = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $iNdex = 0;
    $AddF = 0;
    while($iNdex < $ArraySize){
    $AddF+= $Fstep;
    $FArrayInex[$iNdex] = $AddF;
    $iNdex++;
    }
    return $FArrayInex;

}


/******************************************************************************
 * @procedure    calculateEllipseCurve
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $FixVeci : vector[]
 *   $steps : float
 *
 * @returns      vector []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] calculateEllipseCurve(vector $FixVeci[], float $steps)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $returnValue = 1;
    int $vi = 0;
    float $z = 8;
    float $Lengthi = distance2Pts ($FixVeci[0], $FixVeci[1]);
    float $MidPt[] = MidPoint($FixVeci[0], $FixVeci[1]);
    float $FloatDirMajor[] = DirectionFN($FixVeci[0], $FixVeci[1]);
    float $Lengthiii = distance2Pts ($MidPt, $FixVeci[2]);
    float $FDirNorAi[] = Normal3Points($FixVeci[0], $FixVeci[1], $FixVeci[2]);
    float $LENGTH = $Lengthi/2.0;
    float $C_radius[] = Circle3PtsM($ABC[0], $ABC[1], $ABC[2]);
    float $ObjsCirclesRad = $C_radius[3];
    float $PointN[] = ClosestPoint2Line($VecLineDir, $FixVeci[2], $MidVec);
    float $Di = distance2Pts( $MidVec , $PointN);
    float $DiffL = ($ObjsCirclesRad-$Di)*2.0;
    float $PointNii[];
    float $PointNiii[];
    float $PointNiiiB[];
    float $FloatDirXn[] = DirectionFN( $MidVec, $FixVeci[2]);
    float $DistAddiR2 = $Di*2.0;
    float $HightD = sqrt (abs ((`pow $Di 2`) - (`pow $ObjsCirclesRad 2`)));
    float $DiX = distance2Pts( $FixVeci[2] , $PointNiii);
    float $DiY = distance2Pts( $FixVeci[2] , $PointNiiiB);
    float $ClosestPoint[];
    float $RadiOfOuter = distance2Pts($MidVec, $ClosestPoint);
    float $DirRaytoIntersectC[];
    float $CircleRayPointN[];
    float $SecondIntersectCsmall[] = lineIntersection( $MidVec, $DirRaytoIntersectC, $FixVeci[2], $norm);
    float $RadiOfInnerC = distance2Pts($MidVec,$SecondIntersectCsmall);
    float $MatrizFloati[] = MatrixToFloat($mI);
    float $x = $MidPt[0];
    float $y = $MidPt[2];
    float $a = $Lengthi/2.0;
    float $b = $RadiOfInnerC;
    float $angle = 0;
    float $points[];
    float $Pi = 3.1415926535;
    float $newLocP[];
    float $VecAngle = VAnglesofThreeVec($MidPt, $FixVeci[1], $FixVeci[2]);
    float $beta = `deg_to_rad ($angle)`;
    float $sinbeta = sin($beta);
    float $cosbeta = cos($beta);
    float $valuesiiA[] = {$x,0.0,$y};
    float $valuesiAi[] = {$x, 0, $y};
    float $i;
    float $X = $x + ($a * $cosalpha * $cosbeta - $b * $sinalpha * $sinbeta);
    float $Y = $y + ($a * $cosalpha * $sinbeta + $b * $sinalpha * $cosbeta);
    float $valuesA[] = {$X, 0, $Y};
    float $MidTwoDtoElPoint = distance2Pts ($valuesiiA, $valuesA);
    float $FloatDirEpoint[] = DirectionFN($valuesiiA, $valuesA);
    float $MultDii[] = multiplyFloat($MidTwoDtoElPoint, $newLocP);
    float $AddMepi[] = AddFloats($MidPt, $MultDii);
    string $curvei = "curve -d 3";
    vector $DirNormi = FloatToVec ($FDirNorAi);
    vector $norm = FloatToVec($FloatDirMajor);
    vector $bi = FloatToVec($FDirNorAi);
    vector $tan = FloatToVec( $normal);
    vector $MidVec = FloatToVec( $MidPt);
    vector $ABC[];
    vector $VecLineDir = PositiveDirectionLine($ABC[1],$MidVec);
    vector $DirecOfPointABi = FloatToVec ( DirectionFN($FixVeci[0], $FixVeci[1]));
    vector $VecH[];
    vector $aV = FloatToVec($valuesA);
    vector $bV = FloatToVec($valuesiAi);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    // $a == Major Axis
    // $b == Minor Axis




    $x=8;
    $y=8;
    $z = 8;
    $Lengthi = distance2Pts ($FixVeci[0], $FixVeci[1]);
    $MidPt = MidPoint($FixVeci[0], $FixVeci[1]);
    $FloatDirMajor = DirectionFN($FixVeci[0], $FixVeci[1]);

    $Lengthiii = distance2Pts ($MidPt, $FixVeci[2]);
    $FDirNorAi = Normal3Points($FixVeci[0], $FixVeci[1], $FixVeci[2]);
    $DirNormi = FloatToVec ($FDirNorAi);
    $normal = crossProduct( $FloatDirMajor, $FDirNorAi, 0, 0 );

    matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $norm = FloatToVec($FloatDirMajor);
    $bi = FloatToVec($FDirNorAi);
    $tan = FloatToVec( $normal);
    $MidVec = FloatToVec( $MidPt);
    $LENGTH = $Lengthi/2.0;
    // length times direction add to Point to move it??
    $ABC[0] = $FixVeci[0];
    $ABC[1] = ($tan * $LENGTH)+ $MidVec;
    $ABC[2] = $FixVeci[1];

    $C_radius = Circle3PtsM($ABC[0], $ABC[1], $ABC[2]);
    $ObjsCirclesRad = $C_radius[3];

    $VecLineDir = PositiveDirectionLine($ABC[1],$MidVec);
    $PointN = ClosestPoint2Line($VecLineDir, $FixVeci[2], $MidVec);
    $Di = distance2Pts( $MidVec , $PointN);
    $DiffL = ($ObjsCirclesRad-$Di)*2.0;

    $returnValue = 1;
    if($Di<$ObjsCirclesRad){
    $returnValue =1;}
    if($Di==$ObjsCirclesRad){
    $returnValue =0;}
    if($Di>$ObjsCirclesRad){
    $returnValue =-1;}


    if($returnValue==1){
    $FloatDirXn = DirectionFN( $MidVec, $FixVeci[2]);
    $PointNii = MultLenToDirAddToPoint($Di, DirectionFN( $MidVec, $PointN), $PointN);
    $DistAddiR2 = $Di*2.0;
    $HightD = sqrt (abs ((`pow $Di 2`) - (`pow $ObjsCirclesRad 2`)));
    $PointNiii = MultLenToDirAddToPoint($HightD,($tan), $PointN);
    $PointNiiiB = MultLenToDirAddToPoint($HightD,($tan*-1), $PointN);
    }

    $DiX = distance2Pts( $FixVeci[2] , $PointNiii);
    $DiY = distance2Pts( $FixVeci[2] , $PointNiiiB);
    if($DiX<$DiY){
    $ClosestPoint=$PointNiii;
    }
    if($DiX>$DiY){
    $ClosestPoint=$PointNiiiB;
    }

    $RadiOfOuter = distance2Pts($MidVec, $ClosestPoint);
    $DirRaytoIntersectC  = DirectionFN($MidVec, $ClosestPoint);
    $CircleRayPointN = ClosestPoint2Line($DirRaytoIntersectC, $MidVec, $FixVeci[2]);
    $SecondIntersectCsmall = lineIntersection( $MidVec, $DirRaytoIntersectC, $FixVeci[2], $norm);


    $RadiOfInnerC = distance2Pts($MidVec,$SecondIntersectCsmall);

    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
    ($bi.x),   ($bi.y),   ($bi.z),   0.0;     // Y axis
    ($tan.x),  ($tan.y),  ($tan.z),  0.0;     // Z axis
    $MidPt[0], $MidPt[1], $MidPt[2],     1.0 >>;  // Position
    $MatrizFloati = MatrixToFloat($mI);
    $x = $MidPt[0];
    $y = $MidPt[2];
    $z = $MidPt[1];
    $a = $Lengthi/2.0;

    ////////////////////////
    $b = $RadiOfInnerC;
    ///////////////////////////

    $angle = 0;

    $DirecOfPointABi = FloatToVec ( DirectionFN($FixVeci[0], $FixVeci[1]));
    $curvei = "curve -d 3";
    clear $VecH;
    $vi = 0;
    $Pi = 3.1415926535;

    $VecAngle = VAnglesofThreeVec($MidPt, $FixVeci[1], $FixVeci[2]);

    $beta = `deg_to_rad ($angle)`;
    $sinbeta = sin($beta);
    $cosbeta = cos($beta);
    $valuesiiA = {$x,0.0,$y} ;
    $valuesiAi = {$x, 0, $y} ;
    $valuesiAi = {$x, 0, $y} ;


    for ( $i = 0; $i < 360; $i += 360.0/$steps)
    {
    $alpha = $i * ( $Pi / 180.00) ;
    $sinalpha =  sin($alpha);
    $cosalpha =  cos($alpha);

    $X = $x + ($a * $cosalpha * $cosbeta - $b * $sinalpha * $sinbeta);
    $Y = $y + ($a * $cosalpha * $sinbeta + $b * $sinalpha * $cosbeta);

    $valuesA = {$X, 0, $Y} ;
    $MidTwoDtoElPoint = distance2Pts ($valuesiiA, $valuesA);
    $FloatDirEpoint = DirectionFN($valuesiiA, $valuesA);
    $newLocP = pointMatrixMult(  $FloatDirEpoint, $MatrizFloati );
    $MultDii = multiplyFloat($MidTwoDtoElPoint, $newLocP);
    $AddMepi = AddFloats($MidPt, $MultDii);
    $aV = FloatToVec($valuesA);
    $bV = FloatToVec($valuesiAi);

    $VecH[`size($VecH)`]= `FloatToVec $AddMepi`;

    $curvei += " -p "+$AddMepi[0]+" "+$AddMepi[1]+" "+$AddMepi[2];
    }

    eval($curvei);
    ResetTransEachSL;
    return $VecH;

}


/******************************************************************************
 * @procedure    CurvatureIsCircleData
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $curvesZ : string
 *   $NumberofSteps : int
 *   $angleZ : float[]
 *   $TotalDeg : float[]
 *   $low : int
 *   $C : float[]
 *   $Ang : float[]
 *
 * @returns      vector []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] CurvatureIsCircleData(string $curvesZ, int $NumberofSteps, float $angleZ[], float $TotalDeg[], int $low, float $C[], float $Ang[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 4 );
    int $Par = 0;
    int $a;
    int $ii = 0;
    int $iX = 0;
    int $Trigger = 0;
    int $Lowest = 11110;
    int $Past = 0;
    int $TF = 0;
    int $CountEVEN = 0;
    int $Even_Odd;
    int $Count = 0;
    int $CountP = 0;
    int $count = 0;
    int $Size = size($x0);
    int $sIZes = `size $FixVec `;
    int $evenOdd = fmod($sIZes, 2);
    int $sIZesHalf = (($sIZes)/2)+1;
    int $NUmers[] = CreateIntIndex($sIZesHalf);
    int $countN = 0;
    int $CountVV = 0;
    int $index[] = CreateIntIndex(3);
    int $xyz = $EmptyIndx[0];
    int $isOrthoTrueZi = 0;
    int $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);
    int $IfTrue;
    int $weighedtFindings = 0;
    int $weighedtFindingsZ = 0;
    int $weighedtFindingsN = 0;
    int $triggerStraitCRV = 0;
    int $triggerNoTransENDA = 0;
    int $triggerNoTransENDB = 0;
    int $First_Second_Both_None = 0;
    int $Trueii = 0;
    int $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
    int $TrackAllExisting3DCrv[] = CreatePairIntIndex($SizeCrvi);
    int $SizeCrvR = `size($LayerCurvesRangeA)`;
    int $Cn = 0;
    int $triggerNoTrans = 0;
    int $triggerNoTransA = 0;
    int $triggerNoTransB = 0;
    int $iia = 0;
    int $trigger_straitC = 0;
    int $iis = 0;
    int $AllLocsi[] = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    int $New_AllLocs_A[];
    int $Near_index_A = $New_AllLocs_A[0];
    int $New_AllLocs_B[];
    int $Near_index_B = $New_AllLocs_B[0];
    int $ConnectedEnds = $triggerNoTransENDA + $triggerNoTransENDB;
    int $AddAB = $triggerNoTransA+$triggerNoTransB;
    int $New_AllLocs_AB[];
    int $PairInt[];
    int $iiz = 0;
    int $EndsAtZero = isCurveEndAtZY($EndrEndsa);
    int $STEPSZ = 200;
    int $LowX;
    int $Number = 0;
    int $TFNS = 1;
    int $NewArrayAEllipZ[] = NewVecOrderEllipZ($NewOneCurveS, $EmptyVectorArrayA, $MidEpipolPosFCam);
    int $NewArrayBEllipZ[] = NewVecOrderEllipZ($NewOneCurveSB, $EmptyVectorArrayB, $MidEpipolPosFCam);
    int $IndexTrackE[];
    int $TwoZeroOne[] = {0,1};
    int $TFmostRArray[];
    int $LargestIntR_KEY[];
    int $LargestIntL_KEY[];
    int $COUNT_Nlr = 0;
    int $LargestIntR[] = SortNumbersIntIndex($AllAngiX_RIGHT);
    int $LargestIntL[] = SortNumbersIntIndex($AllAngiX_LEFT);
    int $SizeE = `size($EmptyVectorArrayA)`;
    int $NewArrayInt;
    int $NewArrayIntX[];
    int $Add = 0;
    int $edgeZsetA;
    int $edgeZsetB;
    int $ReducedIndexA[] = floatArrayCountDuplicates($distancesEachToCurve);
    int $ReducedIndexB[] = floatArrayCountDuplicates($distancesEachToCurveB);
    int $NearestInt[] = SortNumbersIntIndex($distAz);
    int $NearestIntB[] = SortNumbersIntIndex($distBz);
    int $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    int $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];
    int $NearestIndex;
    int $NearestIndexEach;
    int $ReducedIndexXAB[];
    int $AxisOrthoLineA = $AxisOrthoLine;
    int $iVc = 0;
    int $TrackFoundN[];
    int $TrackN[];
    int $TwoPointsi[];
    int $AXIS = $AxisOrthoLineA;
    int $ALLlikeness[];
    int $ALLlikenessForce[];
    int $i = 0;
    int $TriggerPoints;
    int $SortedForce[];
    int $Sorted[] = SortNumbersIntIndex($distTo3DCurveEnd);
    int $ReducedIndex[] = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    int $OntheSameLine = 0;
    int $CountN = 0;
    int $AddInt = $AdditR;
    int $X = 0;
    int $Xi = 0;
    int $C = 0;
    int $NumberE[];
    int $NoneDup[];
    int $result = 0;
    int $ixX = 0;
    int $len = size( $list );
    int $indexAx[] = CreateIntIndex(6);
    int $indexAxNew[] = ArrayToIntList( $BestThree);
    int $color;
    int $colori[];
    int $iiX = 0;
    int $Cindex = 0;
    int $IndexZ = $indexAxNew[$Count];
    int $triggerMiddle = 0;
    int $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
    int $iv = -1;
    int $CRV_index_number = 0;
    int $CRc = 0;
    int $CRcT = 0;
    int $COuntN = 0;
    int $EDGEpoints[];
    int $pointNearEdgeCurve[];
    int $SnappingVector = 0;
    int $OneIsNotNearThePlane = 0;
    int $Sortedi[] = SortNumbersIntIndex($distancesTo3DCurveEndi);
    int $C1;
    float $AverageVecCurve[] = AverageVectorPoint($PositionsZ_A);
    float $CIrceP[];
    float $CN[];
    float $step = $NumberofSteps;
    float $StepCycle = 0;
    float $pastA = 0.0;
    float $AddAngles = 0.0;
    float $allAngiX[];
    float $Ct[];
    float $DistancesCycle[];
    float $CurvatureRadi[];
    float $AngleB[];
    float $AngleNine = $AngleB[3];
    float $FXiI = $StepCycle;
    float $Fnumbers = 100.0/$FXiI;
    float $floatZ[];
    float $Sum;
    float $Result;
    float $Output;
    float $Correction;
    float $Error;
    float $S = (1.0/(1.0+`exp(-$x)`));
    float $Vt[];
    float $Ix = 0;
    float $AddAll = 0;
    float $Divide = $AddAll/$Ix;
    float $Fx = 0.0;
    float $DiffMathA;
    float $ZO[];
    float $PastF;
    float $ThresholdX = 1.5;
    float $valuesBi[];
    float $pAv[] = AverageVectorPoint($Vec);
    float $n[] = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    float $FloatDirA[];
    float $Anglei;
    float $SnapR = 1.55;
    float $Smooth = 398;
    float $CamPos_A[];
    float $CamPlane1[];
    float $CamDirVecNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $MultDirCam[] = multiplyFloat(-1, $CamDirVecNormal);
    float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;
    float $CamNormM[] = ` MirrorFloatXYZ 0 $MultDirCam`;
    float $MidEpipolZx[] = MidPoint($CamPos_M, $CamPos_A);
    float $MidEpipolPosFCam[] = FloatPointsToCamPlane($MidEpipolZx);
    float $EpipolPosCamM[] = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;
    float $MidPosFCam[] = $CamPlane1;
    float $FloatDirEpipol[] = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    float $FloatDirEpipolB[] = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
    float $DistTOEpipol_CurEndA;
    float $DistTOEpipol_CurEndB;
    float $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
    float $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
    float $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;
    float $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    float $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
    float $BCDiff = abs($BCurEndB - $BCurEndBNN);
    float $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd;
    float $BCDiffi = abs($BCurEndB - $BCurEndBNNi);
    float $FloatDirEndPtsA[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
    float $EulerAngleA[] = EulerAngB($FloatDirEndPtsA, $FloatDirEpipol);
    float $EulerAngle_A = $EulerAngleA[3];
    float $FloatDirEndPtsB[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
    float $EulerAngleB[] = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);
    float $EulerAngle_B = $EulerAngleB[3];
    float $FloatDirEndPtsAi[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
    float $EulerAngleAi[] = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);
    float $EulerAngle_Ai = $EulerAngleAi[3];
    float $FloatDirEndPtsBi[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
    float $EulerAngleBi[] = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);
    float $EulerAngle_Bi = $EulerAngleBi[3];
    float $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
    float $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;
    float $EpipolXx[] = {0.0,$CamPos_A[1],$CamPos_A[2]};
    float $PlaneEpipolXx[] = FloatPointsToCamPlane( $EpipolXx);
    float $EpipolYx[] = {$CamPos_A[0],0.0,$CamPos_A[2]};
    float $PlaneEpipolYx[] = FloatPointsToCamPlane( $EpipolYx);
    float $EpipolZx[] = {$CamPos_A[0],$CamPos_A[1],0.0};
    float $PlaneEpipolZx[] = FloatPointsToCamPlane( $EpipolZx);
    float $LengCRV_a = `arclen $CurveItemZai`;
    float $DistEndsi;
    float $LengCRV_b = `arclen $CurveItemZbi`;
    float $DistEndsii;
    float $DiffMathB = $DistEndsii / ($LengCRV_b/100.0);
    float $PerDiffSum = ($DiffMathA+$DiffMathB)/2.0;
    float $MidCurveA[];
    float $MidCurveB[];
    float $DDirEpipol[] = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
    float $AngleXi;
    float $PointToCamDir[];
    float $PointsClos[];
    float $distToCurveE_A[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[0]);
    float $newOrdersZA[] = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    float $Distance_A = $distToCurveE_A[$Near_index_A];
    float $Found_pt_A[] = $LocCurveEndsVec3D[$Near_index_A];
    float $newOrdersZAM[] = $Found_pt_A;
    float $distToCurveE_B[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[1]);
    float $newOrdersZB[] = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    float $Distance_B = $distToCurveE_B[$Near_index_B];
    float $Found_pt_B[] = $LocCurveEndsVec3D[$Near_index_B];
    float $newOrdersZBM[] = $Found_pt_B;
    float $distToPlaneLoc[];
    float $DistToIntersectTOnear[];
    float $distToPlaneLoc3D[];
    float $DiffMathAm = $DistToIntersectTOnear[2]/ ($distToPlaneLoc3D[2]/100.0);
    float $DiffMathBm = $DistToIntersectTOnear[3] / ($distToPlaneLoc3D[3]/100.0);
    float $relativeDistanceA = ($DiffMathA+$DiffMathAm)/2.0;
    float $relativeDistanceB = ( $DiffMathB+$DiffMathBm)/2.0;
    float $relativeDistanceAi = ($Distance_A+$distToPlaneLoc[0])/2.0;
    float $relativeDistanceBi = ($Distance_B+$distToPlaneLoc[1])/2.0;
    float $relativeDistanceAZ = distance2Pts($VecOnPlaneA[0], $PointsA[0]);
    float $relativeDistanceBZ = distance2Pts($VecOnPlaneB[0], $PointsB[0]);
    float $DiffMathAi = $relativeDistanceAi/ ($relativeDistanceAZ/100.0);
    float $DiffMathBi = $relativeDistanceBi / ($relativeDistanceBZ/100.0);
    float $TimesMathAi = $relativeDistanceA*$relativeDistanceAZ/ ($distToPlaneLoc3D[0]/100.0);
    float $TimesMathBi = $relativeDistanceB*$relativeDistanceBZ/ ($distToPlaneLoc3D[1]/100.0);
    float $distToCurveE_AB[];
    float $lineEPointA[] = MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);
    float $Point3DA[] = $Intersect_LineB_a;
    float $Point3DAM[] = {($Point3DA[0]*-1), $Point3DA[1],$Point3DA[2]};
    float $angleZi[];
    float $TotalDegii[];
    float $TrackCi[];
    float $anglesMade[];
    float $ThreeFs[];
    float $EllipesPos_A[];
    float $DIff;
    float $AllAngiX_RIGHT[];
    float $AllAngiX_LEFT[];
    float $Addit[];
    float $AdditR;
    float $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    float $distancesEachToCurve[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    float $distancesEachToCurveB[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    float $distAz[];
    float $distBz[];
    float $FPointN_LineC[];
    float $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);
    float $XY[];
    float $XYZi[];
    float $XYZadd[];
    float $Xd;
    float $Yd;
    float $Zd;
    float $All_X[];
    float $All_Y[];
    float $All_Z[];
    float $All_ZYX[];
    float $All_ZYXDiff[];
    float $diffXYZ;
    float $Dist_3DNear = (($Dist_3D/3.0)*2.0);
    float $newOrderFloat;
    float $distTo3DCurveEnd[] = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    float $SdistTo3DCurveEnd[];
    float $Additi[];
    float $AdditiB[];
    float $AdditRi;
    float $AdditRiX;
    float $DistSnap;
    float $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    float $list[] = $listX;
    float $listItem;
    float $MatrixB[] = `MatrixToFloat($m2)`;
    float $DistToPoint = distance2Pts($Pos_A, $VecLoc);
    float $SnapD = 0.003;
    float $CamPos1[];
    float $Pi = 3.1415926535;
    float $pi = 3.1415926535;
    float $CamerasDirectionVectorNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
    float $MultDirForWard[] = multiplyFloat(-1, $CamerasDirectionVector);
    float $FloatDirectionCamNormalA[] = AddFloats($CamPos1, $MultDirCam);
    float $DirectionVectorXn[] = {-2,0,0};
    float $DirectionVectorX[] = {2,0,0};
    float $DirectionVectorY[] = {0,-2,0};
    float $DirectionVectorYn[] = {0,2,0};
    float $DirectionVectorZn[] = {0,0,-2};
    float $DirectionVectorZ[] = {0,0,2};
    float $FloatPointDirectionXn[] = AddFloats($CamPos1, $DirectionVectorXn);
    float $FloatPointDirectionX[] = AddFloats($CamPos1, $DirectionVectorX);
    float $FloatPointDirectionY[] = AddFloats($CamPos1, $DirectionVectorY);
    float $FloatPointDirectionYn[] = AddFloats($CamPos1, $DirectionVectorYn);
    float $FloatPointDirectionZn[] = AddFloats($CamPos1, $DirectionVectorZn);
    float $FloatPointDirectionZ[] = AddFloats($CamPos1, $DirectionVectorZ);
    float $AverageVecXYZsOnP[] = AverageVectorPoint($VecXYZsOnPlane);
    float $AnglesAll[];
    float $ANgnew[] = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
    float $AverageVecCurEndsP[] = AverageVectorPoint($VecCurEnds);
    float $FloatPointDirectionZniY[];
    float $CurveDirectionZiY[];
    float $FloatPointDirectionZniiY[];
    float $CurveDirectionZiiY[];
    float $CurvePsD[] = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
    float $FloatPointDirectVpoint[];
    float $CurveDirectionVpoint[];
    float $locsAi[] = lineIntersection($VecCurEnds[1], $CurveDirectionZiY, $VecCurEnds[0],  $CurveDirectionZiiY);
    float $IntersectEnds_Ai[];
    float $IntersectEnds_Bi[];
    float $distsA = $NdistA;
    float $distsB = $NdistB;
    float $ThreepointVecs[];
    float $EdgeDist;
    float $smallestDistance;
    float $distancesTo3DCurveEnd[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
    float $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
    float $distancesTo3DCurveEndi[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
    float $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
    float $XX = $VecA.x;
    float $XXX = $VecB.x;
    string $myCurve = $curvesZ;
    string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size  ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -top 1 -p $myCurve`;
    string $K = "";
    string $curveA = "curve -d 1";
    string $curveB = "curve -d 1";
    string $NewcurvezA = `eval($curveA)`;
    string $NewcurvezB = `eval($curveB)`;
    string $NewcurvezAB[];
    string $stringF[];
    string $EmptyIndx[];
    string $stringIndTr[] = IntArrayToStringArray($index);
    string $CurveItemZai = $StereoCurveZ[0];
    string $CurveItemZbi = $StereoCurveZ[1];
    string $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    string $queryLocCurveEnds3D[];
    string $LayerCurvesRangeA[];
    string $ExpandedString[];
    string $ThefirstCurve;
    string $ThefirstCurvei;
    string $AllLocs_String[] = IntArrayToStringArray($AllLocsi);
    string $EmptyStringNewOrderA[];
    string $EmptyStringNewOrderB[];
    string $NewFoundLocs[];
    string $arrayCurvesNear[];
    string $arrayCurvesNearA[];
    string $arrayCurvesNearB[];
    string $curvesZi = $ThefirstCurve;
    string $curvesZii = $ThefirstCurvei;
    string $OneCurve[] = `ls -sl`;
    string $OneCurveS = $OneCurve[0];
    string $CurveNS;
    string $NewOneCurveS;
    string $NewOneCurveSB;
    string $StereoCircle[] = Eval3DCircleStereo( $NewArrayBEllipZ  , $EmptyVectorArrayB ,  $NewArrayAEllipZ , $EmptyVectorArrayA );
    string $queryLocCurveEnds[] = queryLocOnLivePlaneBLayer();
    string $queryLocCurveEndsOLD[] = $queryLocCurveEnds;
    string $newNames;
    string $NearCurvesEnds[];
    string $BothCurves[];
    string $LocA = $queryLocCurveEnds[$NearestInt[0]];
    string $LocB = $queryLocCurveEnds[$NearestIntB[0]];
    string $LocName;
    string $Loc_AorB = "";
    string $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    string $AllarrayCurvesNear[];
    string $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    string $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    string $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    string $CurvesV[];
    string $LocsV[];
    string $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    string $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    string $VanishingLOC[];
    string $DirectionsZ[] = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    string $Alll = "";
    string $AllStrings[];
    string $stringFloat[] = FloatArrayToStringArray($EulerAngleA);
    string $EmptyIndxNewOrder[];
    string $BestThree[];
    string $CirTemp[] = `ls -sl`;
    string $CirTempi[] = `ls -sl`;
    string $newCurveii;
    string $CurveAv[];
    string $newNamesResultA1;
    string $ThreeDCurvesNear[];
    string $CurveItemAa[];
    string $StringAllNearA[];
    string $newNamesResultAx = substituteAllString($newNames, "Plane", "");
    string $arrayCurvesNearA1[];
    string $SetCol = `setAttr ($VanishingLOC[size($VanishingLOC)-1]+".overrideColor ") 6 `;
    string $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    string $LocNames[];
    string $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
    vector $PositionsZ_A[];
    vector $VecAverage = FloatToVec($AverageVecCurve);
    vector $SharpValuesTan[];
    vector $CurveVectors[];
    vector $FlushVectors[];
    vector $valuesTan[];
    vector $valuesTanSpace[];
    vector $valuesTanPastSpace;
    vector $valuesTanPast;
    vector $DeepPastTan;
    vector $DeepPast;
    vector $threeVecsT[];
    vector $CurrentVecT;
    vector $OnPlane[];
    vector $eachVecLine;
    vector $Xdirect;
    vector $Ydirect;
    vector $Zdirect;
    vector $XYZdirect[];
    vector $NewDirectionZ;
    vector $AllLocPositionsZi[];
    vector $VecCurEndsa[] = VecCurveEnds({$CurveItemZai});
    vector $VecCurEndsb[] = VecCurveEnds({$CurveItemZbi});
    vector $PositionsZ_B[];
    vector $VecPtsMirrorA[];
    vector $VecPtsMirrorB[];
    vector $VecPtsMirrorEnds_A[];
    vector $VecPtsMirrorEnds_B[];
    vector $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
    vector $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);
    vector $Vecbv[];
    vector $Vecbvi[];
    vector $NewVecENDsi[];
    vector $CRV_ENDSi[];
    vector $CRV_ENDSii[];
    vector $FoundEpipol;
    vector $PointsA[];
    vector $PointsB[];
    vector $XYZdirectL[];
    vector $LineDirect_3D;
    vector $DDirEpipolXYZ[];
    vector $AllEpipolXYZ[];
    vector $EpipolD[];
    vector $LineMidi;
    vector $NewDirZi;
    vector $VecOnPlaneA[];
    vector $VecOnPlaneB[];
    vector $IntersectEnds_Ax[];
    vector $Intersect_A[];
    vector $PositionsZ_Ai[];
    vector $PositionsZ_Bi[];
    vector $PositionsZ_Bii[];
    vector $PositionsZ_Aii[];
    vector $PtsMirrorAi[];
    vector $LocCurveEndsVec3D[] = PointArray($queryLocCurveEnds3D);
    vector $LocOnPlaneVec[] = PointArray($NewFoundLocs);
    vector $LoCz_3D[];
    vector $TXI = << -1.0 , 1.0, 1.0>>;
    vector $UnconnectedEnds[];
    vector $Intersect_LineB_a;
    vector $Intersect_LineB_b;
    vector $Xdirection = << 1.0,0.0,0.0>>;
    vector $Intersect_BX[];
    vector $PairVectors[];
    vector $EpipolXLine = DirectionFN( $MidEpipolPosFCam, $PairVectors[$PairInt[0]]);
    vector $Intersect_B[];
    vector $EndrEndsa[] = VecCurveEnds({$ThefirstCurvei});
    vector $EmptyVectorArrayA[];
    vector $EmptyVectorArrayB[];
    vector $Dir_VecMAIN;
    vector $threeVecs[];
    vector $Dir_VecA;
    vector $Positions[];
    vector $VecCurEnds[] = VecCurveEnds({$TempCrv});
    vector $LocCurveEndsVec[] = PointArray($queryLocCurveEnds);
    vector $EndSnapAndEndProject[];
    vector $endNotNearZ[];
    vector $NearEndZ;
    vector $Loc3D_Vec[] = PointArray($NewFoundLocs );
    vector $ALLLoc3D_VecAB[] = PointArray($AllarrayCurvesNear);
    vector $ReducedVecAB[];
    vector $ALLLoc3D_Vec[];
    vector $MovedEndPointPlane[] = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    vector $Dir_CamRay;
    vector $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    vector $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);
    vector $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    vector $One;
    vector $each;
    vector $NearPointsXYZ[];
    vector $ReducedVec[];
    vector $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    vector $VecLineDirMi;
    vector $PointN_LineXYZ;
    vector $SnapN;
    vector $SnapPlaceN;
    vector $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);
    vector $VecLineDirM;
    vector $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    vector $Points3DPair_And_2DPair[];
    vector $Crv_Pts[];
    vector $MirrorAcrossPlaneVecs[] = VecMultMatrixMirror($Crv_Pts);
    vector $FLoatPointA[];
    vector $DirLine = DirectionFN( $VecLoc, $Pos_A);
    vector $TranstatedVecs[];
    vector $PointN_Line = ClosestPoint2LineVec($Dir_CamRay, $MovedEndPointPlane[0], $Loc3D_Vec[0]);
    vector $PointN_LineB = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $PointN_Line);
    vector $PositionsZ_Ax[];
    vector $ZYplaneMatrix[];
    vector $VecDirection_A_XYZ[];
    vector $VecDirectionXYZ[];
    vector $VecXYZsOnPlane[] = VecPointsToCameraPlane($VecXYZs);
    vector $VecXYZsOnPlaneiY[];
    vector $VecXYZsOnPlaneiiY[];
    vector $VecXYZsOnPlaneVpoint[];
    vector $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
    vector $VIntersectEnds_A[];
    vector $ObjLoc3DCurv[];
    vector $LocCurveEndsVec_3D[] = PointArray($arrayCurvesNearA1);
    vector $PointN_LineA = ClosestPoint2LineVec($LineDirect_3D, $VecCurEnds[0], $LocCurveEndsVec_3D[0]);
    vector $NearVecPts[];
    vector $PositionsZ_Aiix[];
    vector $VecTest[];
    vector $FistAndSecond[];
    vector $VecA = $FistAndSecond[0];
    vector $VecB = $FistAndSecond[1];
    vector $ReversePositionsZ_Ai[] = ReverseVectorArray($PositionsZ_Ai);
    vector $XIntersect_Ax[];
    vector $p = `xform -q -ws -t "LiveSurfaceB"`;
    vector $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $myCurve = $curvesZ;
    //smoothCurve -ch 0 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($curvesZ);

    $AverageVecCurve = AverageVectorPoint($PositionsZ_A);

    $CIrceP = `xform -q -ws -t $myCurve`;
    $AverageVecCurve =$CIrceP;
    //Loc $AverageVecCurve;
    $VecAverage = FloatToVec($AverageVecCurve);


    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size  ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 4 );

    $numEPrealNum2 = $NumberofSteps;
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -top 1 -p $myCurve`;
    $SharpValuesTan[0] = $PositionsZ_A[0];
    $step = $NumberofSteps;
    $Par = 0;
    $StepCycle = 0;
    $ii = 0;
    $iX = 0;
    $Trigger = 0;
    $Lowest = 11110;
    $Past = 0;
    $pastA = 0.0;
    $AddAngles = 0.0;
    $allAngi[`size($allAngi)`] = 0;
    $allAngiX[`size($allAngiX)`] = 0;
    $TwoZeroOne = {0,1};
    $TwoZeroOneT = {0,1};
    $Ct[0] = 0.0;
    $C[0] = 0.0;
    $CN[0] = 0;
    $TF = 0;
    $CountEVEN = 0;
    global int $TrackDirectionChange;
    $TrackDirectionChange=0;

    for($a = 0; $a <= $step;$a++){

    $t =  $a/$step;
    $Par = ($a/$step);

    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $valuesTan[$ii]  = `getAttr  ($paramlocatorpointOnCurvex + ".tangent")`;

    $CurvatureRadi[$ii] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
    $valuesXYZ  = {$values[0], $values[1], $values[2]};
    $CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
    $valuesTanSpace[$ii] = $CurveVectors[$ii]+$valuesTan[$ii];

    $FlushVectors[`size($FlushVectors)`] = <<$values[0], $values[1], $values[2]>>;
    $PresentV = FloatToVec($values);

    // creat a vator array thatclears every time it passes 360 deg.. so the last few steps are recored..
    // then take the last angle find the persect it is of 360  divide that by the number of septs then use that as a float step

    if($ii>0){$Past=$ii-1;

    $EachAngle = VAnglesofThreeVec($VecAverage, $PositionsZ_A[0], $CurveVectors[$ii]);
    $threeVecs[0] = $PositionsZ_A[0]; $threeVecs[1] = $VecAverage; $threeVecs[2] = $PresentV;
    $TFmostR = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);

    // for copy past  $valuesTanPastSpace = $valuesTanSpace[$ii];
    $threeVecsT[0] = $valuesTanPastSpace; $threeVecsT[1] = $PastV; $threeVecsT[2] = $PresentV;
    $TFmostRT = MostRightClockWiseInt ($threeVecsT, $TwoZeroOneT);
    $allAngiX[`size($allAngiX)`]= $EachAngle;

    $Ct[$iX] =  $TFmostRT;
    $C[$iX] = $TFmostR;
    if($ii==1){
    $C[$iX-1]= $C[$iX];
    $Ct[$iX-1]= $Ct[$iX];
    $CN[`size($CN)`-1]=$C[$iX];
    $DeepPastTan = $valuesTanPast;
    $DeepPast= $PastV;
    }

    $AngleB = EulerAngB($DeepPastTan, $valuesTan[$ii]);
    $AngleNine = $AngleB[3];
    //if((($AngleNine>82)&&($AngleNine<98))||(($AngleNine>39)&&($AngleNine<51))){

    if($Ct[$iX]==$Ct[$iX-1]){
    if(($AngleNine>82)&&($AngleNine<98)){
    //print ("direction Same "+$AngleNine+"\n");

    $CurrentVecT = $CurveVectors[$ii]+$valuesTan[$ii];
    //Loc $CurrentVecT;

    //Loc $valuesXYZ;
    $SharpValuesTan[`size($SharpValuesTan)`]= FloatToVec (lineIntersectionF($DeepPast, ($DeepPast+$DeepPastTan), $valuesXYZ, $CurrentVecT));
    //Loc $SharpValuesTan[`size($SharpValuesTan)`-1];
    $SharpValuesTan[`size($SharpValuesTan)`]= $CurveVectors[$ii];
    //$SharpValuesTan[`size($SharpValuesTan)`]= $CurrentVecT;

    $DeepPastTan =  $valuesTan[$ii];
    $DeepPast= $CurveVectors[$ii];
    }
    }

    $allAngi[$iX] =$EachAngle;

    if($Trigger== 1){
    $allAngi[$iX] = (abs($pastA - $EachAngle))+$allAngi[$iX-1];
    if($allAngi[$iX]> 360){ $allAngi[$iX]=$EachAngle; $allAngi[$iX-1]=0;  $Trigger= 0; $TF++; }
    }

    if($Ct[$iX]!=$Ct[$iX-1]){
    //means it changed direction left or right from past tangent ..exe: the road that was curved right is now starting to curve left
    $TrackDirectionChange++;
    //print ("Direction CHANGE! "+$AngleNine+"\n");
    $CurrentVecT = $CurveVectors[$ii]+$valuesTan[$ii];
    //Loc $CurrentVecT;
    //Loc $valuesXYZ;
    //Cube $valuesXYZ;


    //if(($AngleNine>82)&&($AngleNine<98)){

    if(!(($AngleNine>135)||($AngleNine==0))){
    $SharpValuesTan[`size($SharpValuesTan)`]= FloatToVec (lineIntersectionF($DeepPast, ($DeepPast+$DeepPastTan), $valuesXYZ, $CurrentVecT));}
    //Loc $SharpValuesTan[`size($SharpValuesTan)`-1];
    $SharpValuesTan[`size($SharpValuesTan)`]= $CurveVectors[$ii];
    $DeepPastTan =  $valuesTan[$ii];
    $DeepPast= $CurveVectors[$ii];

    //}else{ if($AngleNine>90){$SharpValuesTan[`size($SharpValuesTan)`]= $CurveVectors[$ii];
    //	$DeepPastTan =  $valuesTan[$ii];
    //	$DeepPast= $CurveVectors[$ii];
    //}


    }

    if($C[$iX]!=$C[$iX-1]){
    //Loc $valuesXYZ;
    //Loc $valuesTanPast;
    $CN[`size($CN)`]= $iX;
    $CN[`size($CN)`]=$C[$iX];
    $Even_Odd = fmod($CountEVEN,2);
    if($Even_Odd ==1){
    $DistancesCycle[`size($DistancesCycle)`]= distance2Pts ($PositionsZ_A[0], $PresentV);

    }

    $CountEVEN++;
    $angleTii = (180.00- $allAngi[$iX]) +(180.00- $allAngi[$iX-1]);
    $allAngi[$iX] =  $angleTii +$allAngi[$iX-1];
    $Trigger= 1;

    }

    $pastA = $EachAngle;
    $AddAngles+= abs($EachAngle - $allAngiX[`size($allAngiX)`-1]);


    if($allAngi[`size($allAngi)`-1]>=360){
    clear $FlushVectors;
    $StepCycle =  abs ($StepCycle -$a);
    $FXiI = $StepCycle;
    $Fnumbers = 100.0/$FXiI;
    $floatZ = CreateIntIndexF($FXiI, $Fnumbers);
    $StepCycle = $a;
    //Loc $CurveVectors[$ii];
    $AddAngles=0;
    }
    }

    if($StepCycle < $Lowest){
    if($StepCycle!=0){
    $Lowest = $StepCycle;
    }
    }

    $PastV = FloatToVec($values);
    $valuesTanPast = $valuesTan[$ii];
    $valuesTanPastSpace = $valuesTanSpace[$ii];

    $iX++;
    $ii++;



    }

    /////////END of Loop

    $SharpValuesTan[`size($SharpValuesTan)`]= $PastV;

    $CN[`size($CN)`]= $iX;
    $low = $TF;
    $angleZ = $DistancesCycle;
    delete $paramlocatorpointOnCurvex;
    $TotalDeg = $CurvatureRadi;
    $Ang = $allAngiX;

    VecArrayToCurve($SharpValuesTan);
    ResetTransEachSL;
    editDisplayLayerMembers -noRecurse VecToCurve `ls -selection`;
    toggle -editPoint;
    VecArrayToCurveB($SharpValuesTan);
    ResetTransEachSL;
    editDisplayLayerMembers -noRecurse VecToCurveB `ls -selection`;

    return $CurveVectors;

    }

    //////////////////////////////////////

    global float $x0W;
    global float $x1W;
    global float $LearningCoeff;
    global float $Threshold;
    global float $Out;

    proc CPerceptron_CPerceptron(){
    global float $LearningCoeff;
    global float $Threshold;
    global float $x0W;
    global float $x1W;
    //srand((unsigned)(time(NULL)));
    $LearningCoeff = 0.2;
    $Threshold = 0.5;
    $x0W =  (float)(rand(32007))/(32767/2) - 1;
    $x1W =  (float)(rand(32007))/(32767/2) - 1;


    $x0W = 0.1;
    $x1W = 0.1;

    }


    //Setting up parameters
    proc CPerceptron_SetValues(float $x0WeightPar, float $x1WeightPar, float $LearningC, float $Thresh)
    {
    global float $x0W;
    global float $x1W;
    $x0W = $x0WeightPar;
    $x1W = $x1WeightPar;
    $LearningCoeff = $LearningC;
    $Threshold = $Thresh;
    }


    //Training function
    proc float CPerceptron_Train(float $x0, float $x1, float $r)
    {
    global float $x0W;
    global float $x1W;
    global float $LearningCoeff;
    global float $Threshold;
    global float $Out;

    $Sum = ($x0*$x0W)+($x1*$x1W)+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result = Sigmoid($Sum);

    $Out = ($x0*$x0W)+($x1*$x1W);
    if($Out>$Threshold){ $Output = 1.0;
    }else{ $Output = 0.0;}

    $Error = ((float)$r)-($Output);
    $Correction = $LearningCoeff*$Error;

    if($x0==1){ $x0W += $Correction;}
    if($x1==1){ $x1W += $Correction;}
    return $Result;
    }

    //Sigmoid function
    proc float CPerceptron_Sigmoid(float $x){
    $S = (1.0/(1.0+`exp(-$x)`));
    return $S;
    }


    //Get current weight values function
    proc float CPerceptron_Getx0Weight()
    {
    global float $x0W;
    return $x0W;
    }
    proc float CPerceptron_Getx1Weight()
    {
    global float $x1W;
    return $x1W;
    }


    //Run function, return y value
    proc float CPerceptron_Run(float $x0, float $x1)
    {
    global float $x0W;
    global float $x1W;
    global float $Threshold;
    $Sum = ($x0*$x0W)+($x1*$x1W);
    if($Sum>$Threshold){ $Result = 1;
    }else{ $Result = 0;}
    $Result = Sigmoid($Sum);
    return $Result;
    }


    proc float CPerceptron_RunX(float $x0)
    {

    global float $Threshold;
    if($x0>$Threshold){ $Result = 1;
    }else{ $Result = 0;}
    //$Result = Sigmoid($Sum);
    return $Result;
    }

    proc int PrintMod(int $StepN, float $Mod ){
    if ( fmod($StepN, $Mod) == ($Mod-1)  ) {
    return 1;
    }else {return 0;}
    }



    proc float [] GatherDataR(float $Xt[], float $Av){
    for ($eachInt in $Xt){
    if($eachInt > $Av){
    $Vt[`size($Vt)`]= 0;
    }else{$Vt[`size($Vt)`]= 1;}}
    return $Vt;
    }



    proc float [] GatherDataDiff(float $Xt[], float $Av){

    for ($eachInt in $Xt){
    $Vt[`size($Vt)`]= `abs ($Av-$eachInt)`;
    }
    return $Vt;
    }


    proc float AverageFloats(float $FloatArray[]){
    $Ix = 0;
    $AddAll = 0;
    for($eachF in $FloatArray){
    $AddAll+= $eachF;
    $Ix++;
    }
    $Divide = $AddAll/$Ix;
    return $Divide;
    }


    proc float [] AverageFloatArrays(float $FloatArrayA[], float $FloatArrayB[]){
    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = ($eachF + $FloatArrayB[$Ix])/2.0;
    $Ix++;
    }
    return $AddAll;
    }

    proc float [] AddFloatArrays(float $FloatArrayA[], float $FloatArrayB[]){
    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = ($eachF + $FloatArrayB[$Ix]);
    $Ix++;
    }
    return $AddAll;
    }

    proc float [] DivideFloatArrays(float $FloatArrayA[], float $DivideX){
    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] =  $eachF/$DivideX;
    $Ix++;
    }
    return $AddAll;
    }

    proc float [] DiffFloatArrays(float $FloatArrayA[], float $FloatArrayB[]){
    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = abs (($eachF - $FloatArrayB[$Ix]));
    $Ix++;
    }
    return $AddAll;
    }


    proc float PercentDiffZeroOneArrays(float $FloatArrayA[], float $FloatArrayB[]){
    $Ix = 0;
    $Fx = 0.0;
    for($eachF in $FloatArrayA){
    if ($eachF != $FloatArrayB[$Ix]){
    $AddAll+= 1.0;
    }
    $Fx++;
    $Ix++;
    }

    //print ($AddAll +" "+$Fx+"\n");

    if($AddAll != 0){
    $DiffMathA =  $AddAll / ($Fx/100.0);
    }else{ $DiffMathA = 0;}

    return $DiffMathA;
    }




    proc float [] GatherDataC(float $Xt[]){

    $Count = 0;
    $CountP = 0;
    //$Vt[`size($Vt)`] =0;
    for ($eachInt in $Xt){

    if($Count>0){
    if($Xt[$Count-1]!=$Xt[$Count]){

    $Vt[`size($Vt)`]= $CountP;
    $CountP = 0;
    }
    }
    $CountP++;
    $Count++;
    }
    $Vt[`size($Vt)`]= $CountP;

    return $Vt;
    }

    proc int [] GatherData(int $Xt[]){

    if(`size($Xt)`>0){
    return $Xt;
    }
    }
    proc float [] GatherDataF(float $Xt[]){

    if(`size($Xt)`>0){
    return $Xt;
    }
    }


    proc float CPerceptron_TrainX(float $x0, float $x1)
    {

    global float $Threshold;
    $Sum = ($x0)+($x1)+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result = Sigmoid($Sum);
    return $Result;
    }


    //Sigmoid function
    proc float CPerceptron_Sigmoid(float $x){
    $S = (1.0/(1.0+`exp(-$x)`));
    return $S;
    }


    proc float [] GatherDataZeroOne(float $Xt[]){
    $count = 0;
    for ($eachF in $Xt){
    if($eachF == 1){
    $ZO[$count] = 1;
    }
    if($eachF == -1){
    $ZO[$count] = 0;
    }
    $count++;

    }
    return $ZO;
    }


    proc GatherDataRRV(float $Xt[], vector $Pts[]){
    $count = 0;
    for ($eachF in $Xt){
    if($eachF == 1){
    Loc $Pts[$count];
    }
    $count++;

    }
    }




    proc float [] GatherDataRR(float $Xt[], float $Av){
    $count = 0;

    for ($eachF in $Xt){

    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= -1;}

    if($count>0){

    if($PastF<$eachF){
    if($PastF<$Av){
    if(($PastF+$eachF/2.0)<$Av){
    $Vt[$count]= 1; }
    }
    }

    }

    $PastF = $eachF;
    $count++;
    }
    return $Vt;
    }

    proc float [] GatherDataRRZO(float $Xt[], float $Av){
    $count = 0;

    for ($eachF in $Xt){

    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= 0;}

    if($count>0){

    if($PastF<$eachF){
    if($PastF<$Av){
    if(($PastF+$eachF/2.0)<$Av){
    $Vt[$count]= 1; }
    }
    }

    }

    $PastF = $eachF;
    $count++;
    }
    return $Vt;
    }

    proc float [] GatherDataAboveBelowT(float $Xt[], float $Av){
    $count = 0;
    for ($eachF in $Xt){
    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= 0;}
    $count++;
    }
    return $Vt;
    }




    proc float [] CPerceptronZ_Train(float $x0[], float $x1[], float $r)
    {

    global float $x0WX[];
    global float $x1WX[];
    global float $LearningCoeff;
    global float $Threshold;
    global float $Out;


    $Size = size($x0);
    for($i=0; $i<$Size; $i++){
    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i])+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result[$i] = Sigmoid($Sum);

    $Out = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
    if($Out>$Threshold){ $Output = 1.0;
    }else{ $Output = 0.0;}

    $Error = ((float)$r)-($Output);
    $Correction = $LearningCoeff*$Error;

    if($x0[$i]==1){ $x0WX[$i] += $Correction;}
    if($x1[$i]==1){ $x1WX[$i] += $Correction;}

    }

    return $Result;
    }
    /*
    GatherDataF($x1WX);
    9.906

    $Out = (-1*3.01)+(1*3.01);
    if($Out>$Threshold){ $Output = 1.0;
    }else{ $Output = 0.0;}
    print $Output;
    $Error = ((float)0.99)-($Output);
    $Correction = $LearningCoeff*$Error;

    $Sum = (-1*3.01)+(1*3.01)+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    Sigmoid($Sum);

    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1
    print $x1WX[29];
    print $x0WX[29];
    */
    proc float [] CPerceptronZ_TrainX(float $x0[], float $x1[])
    {

    global float $Threshold;
    $Size = size($x0);
    for($i=0; $i<$Size; $i++){
    $Sum = ($x0[$i])+($x1[$i])+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result[$i] = Sigmoid($Sum);
    }
    return $Result;
    }




    proc float [] CPerceptronZ_RunXZ(float $x0[], float $x1[])
    {
    global float $x0WX[];
    global float $x1WX[];
    global float $Threshold;
    $Size = size($x0);

    for($i=0; $i<$Size; $i++){

    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
    if($Sum>$Threshold){ $Result[$i] = 1;
    }else{ $Result[$i] = 0;}
    $Result[$i] = Sigmoid($Sum);
    }
    return $Result;
    }

    proc float [] CPerceptronZ_RunXYZ(float $x0[], float $x1[])
    {
    global float $x0WX[];
    global float $x1WX[];
    global float $Threshold;
    $Size = size($x0);

    for($i=0; $i<$Size; $i++){

    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i])+((-1)*$Threshold);
    $Result[$i] = Sigmoid($Sum);
    }
    return $Result;
    }



    proc float [] CPerceptronZ_RunOUTPUT(float $x0[], float $x1[])
    {
    global float $x0WX[];
    global float $x1WX[];
    global float $Threshold;
    $Size = size($x0);

    for($i=0; $i<$Size; $i++){

    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
    if($Sum>$Threshold){ $Result[$i] = 1;
    }else{ $Result[$i] = 0;}
    $Result[$i] = Sigmoid($Sum);

    }
    return $Result;
    }

    proc float [] Sum_PerceptronZ_TrainX(float $x0[], float $x1[])
    {

    $ThresholdX = 1.5;
    $Size = size($x0);
    for($i=0; $i<$Size; $i++){
    $Sum = ($x0[$i] + $x1[$i] );
    //print ("Sum "+$Sum+"\n");
    if($Sum > $ThresholdX){ $Result[$i] = 1;
    }else{ $Result[$i] = -1;}
    }
    return $Result;
    }
    proc string [] VecArrayToSplitCurve(vector $FixVec[]){

    // the middle curve will always be even!

    $sIZes = `size $FixVec `;
    $evenOdd = fmod($sIZes, 2);

    $sIZesHalf = (($sIZes)/2)+1;
    $NUmers = CreateIntIndex($sIZesHalf);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $countN = 0;
    $curveA = "curve -d 1";
    for ($eachVeCx in $NUmers){
    $valuesBi  = $FixVec[$countN];
    $curveA += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    $countN++;
    }
    $curveA += " "+ $K;
    $curveB = "curve -d 1";
    $countN--;
    for ($eachVeCx in $NUmers){
    $valuesBi  = $FixVec[$countN];
    $curveB += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    $countN++;
    }
    $curveB += " "+ $K;
    $NewcurvezA = `eval($curveA)`;
    $NewcurvezB = `eval($curveB)`;
    $NewcurvezAB = {$NewcurvezA , $NewcurvezB};
    return $NewcurvezAB;
    }

    proc vector [] LineIntersectPlaneCam( vector $Vecii[], float $CamP[], vector $Vec[]){

    $pAv = AverageVectorPoint($Vec);
    $n = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    $CountVV = 0;
    for($eachVecLine in $Vecii){
    $FloatDirA  = DirectionF($eachVecLine, $CamP);
    $FloatDirNormalA = multiplyFloat(2, $FloatDirA);
    $MultDirA = AddFloats( $FloatDirNormalA, $eachVecLine);

    $DistanceLocA = distance2Pts(  $eachVecLine, $pAv);
    $MultDirCam  = multiplyFloat($DistanceLocA, $n);
    $FloatDirectionCamNormalA  = AddFloats($pAv, $MultDirCam);

    $PointN  = ClosestPoint2Line($n, $pAv, $eachVecLine);
    $FloatDirectionAi  = DirectionF($PointN, $pAv);
    $DistanceLoc = distance2Pts( $PointN, $pAv );

    $MultDirPC1  = multiplyFloat($DistanceLoc, $FloatDirectionAi);
    $FloatDirNormalDist  = AddFloats($eachVecLine, $MultDirPC1);
    $PointNii  = ClosestPoint2Line(DirectionF($PointN, $pAv), $eachVecLine, $MultDirA);
    $FloatDirectionAii  = DirectionF($PointNii, $MultDirA);

    $OnPlane[$CountVV] = FloatToVec (lineIntersection( $FloatDirNormalDist, $FloatDirectionAii, $eachVecLine, $FloatDirA));
    //Loc $OnPlane[$CountVV];
    $CountVV++;
    }
    return $OnPlane;
    }

    proc vector FindIfCurveIsOrthoEpipol(vector $EpipolD[], vector $CRV_ENDS[], float $DistEnds, vector $LineMid){

    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;


    // when working with the plane get the vanishing points directions


    if(`size($EpipolD)` == 3){

    //print "EpiPolar";

    $Xdirect = $EpipolD[0];
    $Ydirect = $EpipolD[1];
    $Zdirect = $EpipolD[2];
    }else{
    $Xdirect = << 1,0,0>>;
    $Ydirect = << 0,1,0>>;
    $Zdirect = << 0,0,1>>;
    }

    $XYZdirect[0] = $Xdirect;
    $XYZdirect[1] = $Ydirect;
    $XYZdirect[2] = $Zdirect;


    $LineAMain = PositiveDirectionLine($CRV_ENDS[0], $CRV_ENDS[1]);
    $EulerAngleA  = EulerAngB($Xdirect,$LineAMain);
    $EulerAngleB  = EulerAngB($Ydirect,$LineAMain);
    $EulerAngleC  = EulerAngB($Zdirect,$LineAMain);
    $EulerABCi[0]= $EulerAngleA[3];
    $EulerABCi[1]= $EulerAngleB[3];
    $EulerABCi[2]= $EulerAngleC[3];
    $stringF = FloatArrayToStringArray($EulerABCi);
    clear $EmptyIndx;
    $index = CreateIntIndex(3);
    $stringIndTr = IntArrayToStringArray($index);
    SortFloatArrayAndString( $EulerABCi, $stringIndTr, $EmptyIndx);
    $EmptyIndx = ReverseStringArray($EmptyIndx);
    $xyz = $EmptyIndx[0];
    $AxisOrthoLine = $xyz;
    $Anglei = $EulerABCi[$xyz];
    //print $Anglei;
    $NewDirectionZ = $XYZdirect[$xyz];
    $DistEnds= distance2Pts($CRV_ENDS[0], $CRV_ENDS[1]);
    $LineMid = ($CRV_ENDS[0] + $CRV_ENDS[1])/2.0;
    $AngleEpiPole = $Anglei;

    $isOrthoTrueZi = 0;
    if($Anglei < 8.55){
    $isOrthoTrueZi = 1;
    }
    $IsOrthoLineTrue = $isOrthoTrueZi;
    //print $IsOrthoLineTrue;
    return $NewDirectionZ;
    }




    /*
    $StereoCurveZ= `ls -sl`;
    $CurveItemZai = $StereoCurveZ[0];
    $CurveItemZbi = $StereoCurveZ[1];
    */

    global string $PlaneCurveS[];


    proc StereoCurveZ(string $CurveItemZai, string $CurveItemZbi){
    global string $StereoCurveZ[];
    global string $VanishingPointsLinesTempGuides[];
    global int $addNumbersA;
    global float $VanishingPointGlobal[];
    global string $PlaneCurveS[];
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;
    $SnapR = 1.55;
    $Smooth = 398;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 1 -tol 0.05 $CurveItemZai;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 1 -tol 0.05 $CurveItemZbi;
    clear $AllLocPositionsZi;
    $AllLocPositionsZi = VecCurveCvs( $CurveItemZai);
    $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    ResetTranslation({$newPlaneCurveA});
    delete $CurveItemZai;
    $CurveItemZai = $newPlaneCurveA;
    clear $AllLocPositionsZi;
    $AllLocPositionsZi = VecCurveCvs( $CurveItemZbi);
    $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
    ResetTranslation({$newPlaneCurveA});
    delete $CurveItemZbi;
    $CurveItemZbi = $newPlaneCurveA;
    $VecCurEndsa = VecCurveEnds({$CurveItemZai});
    $VecCurEndsb = VecCurveEnds({$CurveItemZbi});
    $StereoCurveZ[0]= $CurveItemZai;
    $StereoCurveZ[1]= $CurveItemZbi;
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveCvs($CurveItemZai );
    clear $PositionsZ_B;
    $PositionsZ_B = VecCurveCvs($CurveItemZbi );
    clear $VecPtsMirrorA;
    clear $VecPtsMirrorB;
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
    $CamDirVecNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $MultDirCam = multiplyFloat(-1, $CamDirVecNormal);
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    clear $VecPtsMirrorEnds_A;

    clear $VecPtsMirrorEnds_B;
    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);
    $EpipolPosCamM = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;
    $MidPosFCam = $CamPlane1;
    $FloatDirEpipol = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
    $FloatDirEpipolB = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
    $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
    $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);
    $DistTOEpipol_CurEndA = distance2Pts($PointN_Epi, $VecCurEndsb[0]);
    $DistTOEpipol_CurEndB = distance2Pts($PointN_EpiB, $VecCurEndsb[0]);
    $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
    $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
    $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;
    $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
    $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
    $BCDiff = abs($BCurEndB - $BCurEndBNN);
    $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd ;
    $BCDiffi = abs($BCurEndB - $BCurEndBNNi);

    $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);
    $FloatDirEndPtsA = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
    $EulerAngleA = EulerAngB($FloatDirEndPtsA, $FloatDirEpipol);
    $EulerAngle_A = $EulerAngleA[3];
    $FloatDirEndPtsB = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
    $EulerAngleB = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);
    $EulerAngle_B = $EulerAngleB[3];
    $FloatDirEndPtsAi = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
    $EulerAngleAi = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);
    $EulerAngle_Ai = $EulerAngleAi[3];
    $FloatDirEndPtsBi = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
    $EulerAngleBi = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);
    $EulerAngle_Bi = $EulerAngleBi[3];
    $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
    $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;
    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);

    $Vecbv  = $VecCurEndsa;
    $Vecbvi = $VecCurEndsb;
    $IfTrue = FindLineCross( $Vecbv , $Vecbvi );
    $weighedtFindings = 0;
    $weighedtFindingsZ = 0;
    $weighedtFindingsN = 0;
    if($IfTrue=1){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;
    }
    if($IntIfNearZero==1){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}
    if($EulerAngle_AB<$EulerAngle_AiBi){
    $weighedtFindings++;
    $weighedtFindingsZ++;
    }else{$weighedtFindings--;
    $weighedtFindingsN++;}

    $LengCRV_a = `arclen $CurveItemZai`;
    $CRV_ENDSi = $VecCurEndsa;
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
    //float $DiffMathA = ($LengCRV_a-$DistEndsi) / ($DistEndsi/100.0);

    $LengCRV_b = `arclen $CurveItemZbi`;
    $CRV_ENDSii = $VecCurEndsb;
    $DistEndsii = distance2Pts($CRV_ENDSii[0], $CRV_ENDSii[1]);
    $DiffMathB = $DistEndsii / ($LengCRV_b/100.0);

    $PerDiffSum = ($DiffMathA+$DiffMathB)/2.0;

    //print (" DiffMathA " +$DiffMathA + " DiffMathB " +$DiffMathB +"\n");
    //if(($DiffMathA> 96.5) && ($DiffMathB > 96.5)){
    //$PerDiffSum =99;
    //}else{$PerDiffSum =1;}

    $triggerStraitCRV = 0;
    $triggerNoTransENDA = 0;
    $triggerNoTransENDB = 0;
    $First_Second_Both_None = 0;
    //print ("START FindIfCurveIsOrthoEpipol" +"\n");
    $XYZdirectL[0] = << 1,0,0>>;
    $XYZdirectL[1] = << 0,1,0>>;
    $XYZdirectL[2] = << 0,0,1>>;
    if( $PerDiffSum>97.05){
    print ("FIST IF : ENGAGED PerDiffSum" +$PerDiffSum +"\n");
    print ("ENGAGED FindIfCurveIsOrthoEpipol" +"\n");
    $triggerStraitCRV=1;
    $DDirEpipol = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
    $MidCurveA  = MidPoint($VecCurEndsa[0], $VecCurEndsa[1]);
    $MidCurveB  = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);
    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);

    $EpipolD = $DDirEpipolXYZ;
    $Trueii = 0;

    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    //print ("FindIfCurveIsOrthoEpipol" +"\n");
    //print ($NewDirZi +"\n");
    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    }


    if($weighedtFindingsZ<$weighedtFindingsN){
    /////////////////////////////REMOVED


    /////////////////////////////
    //if(($DistB<$DistA)||($weighedtFindingsZ<$weighedtFindingsN)){
    if( ($weighedtFindingsZ<$weighedtFindingsN)){

    cycleBackgroundColor;
    $PositionsZ_B = ReverseVectorArray($PositionsZ_B);
    $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);
    $VecCurEndsb = ReverseVectorArray($VecCurEndsb);
    $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
    }
    }


    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
    $queryLocCurveEnds3D = `sort $queryLocCurveEnds3D`;
    $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
    $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
    $TrackAllExisting3DCrv = CreatePairIntIndex($SizeCrvi);
    $LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;
    $SizeCrvR = `size($LayerCurvesRangeA)` ;
    clear $ExpandedString;
    $Cn = 0;
    for($eachIntCC in $TrackAllExisting3DCrv){
    $ExpandedString[$Cn] = $LayerCurvesRangeA[$eachIntCC];
    $Cn++;
    }
    $triggerNoTrans = 0;
    $triggerNoTransA = 0;
    $triggerNoTransB = 0;
    $triggerNoTrans = 0;

    clear $IntersectEnds_Ax;
    $iia = 0;


    $trigger_straitC = 0;
    if(!(`size($queryLocCurveEnds3D)` > 2)){
    print ("ENGAGED PerDiffSum " +$PerDiffSum +"\n");
    if($PerDiffSum >95.05){
    $iis = 0;
    for ($eachVecx in  $VecCurEndsb){
    $XIntersect_Ax[$iis] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsb[$iis], $CamPos_M, $VecPtsMirrorEnds_A[$iis]));
    $iis++;
    }
    $XIntersect_Ax[2] =  $XIntersect_Ax[1];
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    $XIntersect_Ax[0] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[0]);
    $XIntersect_Ax[2] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[2]);
    $PositionsZ_Bii= $XIntersect_Ax;
    $PositionsZ_Aii= VecPtsToZMirrorPts($PositionsZ_Bii);
    $ThefirstCurve = VecArrayToCurve($XIntersect_Ax);
    $PtsMirrorAi= VecPtsToZMirrorPts($XIntersect_Ax);
    $ThefirstCurvei = VecArrayToCurve($PtsMirrorAi);

    $trigger_straitC =1;
    }
    }

    ////////////
    if(`size( $queryLocCurveEnds3D)`>2){

    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);
    for ($eachVecx in  $VecCurEndsa)
    {
    $IntersectEnds_Ax[$iia] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsa[$iia], $CamPos_M, $VecPtsMirrorEnds_B[$iia]));
    $iia++;
    }

    $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[0]);
    $AllLocsi = CreateIntIndex(`size($LocCurveEndsVec3D)`);
    $AllLocs_String = IntArrayToStringArray($AllLocsi);
    $newOrdersZA = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
    $EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
    $New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
    $Near_index_A = $New_AllLocs_A[0];
    $Distance_A = $distToCurveE_A[$Near_index_A];
    $Found_pt_A = $LocCurveEndsVec3D[$Near_index_A];
    $newOrdersZAM = $Found_pt_A;
    $newOrdersZAM[0] = $Found_pt_A[0] *-1;
    $distToCurveE_B = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[1]);
    $newOrdersZB = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
    $EmptyStringNewOrderB = ReverseStringArray($EmptyStringNewOrderB);
    $New_AllLocs_B = ArrayToIntList($EmptyStringNewOrderB);
    $Near_index_B = $New_AllLocs_B[0];
    $Distance_B = $distToCurveE_B[$Near_index_B];
    $Found_pt_B = $LocCurveEndsVec3D[$Near_index_B];
    $newOrdersZBM = $Found_pt_B;
    $newOrdersZBM[0] = $Found_pt_B[0] *-1;

    $PointsA[0] = FloatToVec($Found_pt_A);
    $PointsA[1] = FloatToVec($Found_pt_B);
    $PointsB[0] = FloatToVec($newOrdersZAM); // negative mirror of first endpoint of first curve
    $PointsB[1] = FloatToVec($newOrdersZBM);

    $VecOnPlaneA = VecPointsToCameraPlane($PointsA);
    $VecOnPlaneB = VecPointsToCameraPlane($PointsB);

    $NewFoundLocs[0] = $queryLocCurveEnds3D[$Near_index_A];
    $NewFoundLocs[1] = $queryLocCurveEnds3D[$Near_index_B];
    $arrayCurvesNear[0] = ("Plane"+$NewFoundLocs[0]);
    $arrayCurvesNear[1] = ("Plane"+$NewFoundLocs[1]);
    $NewFoundLocs = $arrayCurvesNear;
    $LocOnPlaneVec = PointArray($NewFoundLocs);
    $distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocOnPlaneVec[0]);
    $distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocOnPlaneVec[1]);
    $TXI = << -1.0 , 1.0, 1.0>>;
    $LoCz_3D[0] = MultVec($IntersectEnds_Ax[0],$TXI);
    $LoCz_3D[1] = MultVec($IntersectEnds_Ax[1], $TXI);

    ////////////////////////
    $DistToIntersectTOnear[0] = distance2Pts($IntersectEnds_Ax[0], $PointsA[0]);
    $DistToIntersectTOnear[1] = distance2Pts($IntersectEnds_Ax[1], $PointsA[1]);
    $DistToIntersectTOnear[2] = distance2Pts($LoCz_3D[0], $PointsB[0]);
    $DistToIntersectTOnear[3] = distance2Pts($LoCz_3D[1], $PointsB[1]);

    $distToPlaneLoc3D[0] = distance2Pts($VecCurEndsa[0], $PointsA[0]);
    $distToPlaneLoc3D[1] = distance2Pts($VecCurEndsa[1], $PointsA[1]);
    $distToPlaneLoc3D[2] = distance2Pts($VecCurEndsb[0], $PointsB[0]);
    $distToPlaneLoc3D[3] = distance2Pts($VecCurEndsb[1], $PointsB[1]);
    //////////////////////////

    $DiffMathA = $DistToIntersectTOnear[0]/ ($distToPlaneLoc3D[0]/100.0);
    $DiffMathB = $DistToIntersectTOnear[1] / ($distToPlaneLoc3D[1]/100.0);
    $DiffMathAm = $DistToIntersectTOnear[2]/ ($distToPlaneLoc3D[2]/100.0);
    $DiffMathBm = $DistToIntersectTOnear[3] / ($distToPlaneLoc3D[3]/100.0);

    $relativeDistanceA = ($DiffMathA+$DiffMathAm)/2.0;
    $relativeDistanceB = ( $DiffMathB+$DiffMathBm)/2.0;
    /*
    $relativeDistanceAi = ($Distance_A+$distToPlaneLoc[0])/2.0;
    $relativeDistanceBi = ($Distance_B+$distToPlaneLoc[1])/2.0;
    $relativeDistanceAZ = distance2Pts($VecOnPlaneA[0], $PointsA[0]);
    $relativeDistanceBZ = distance2Pts($VecOnPlaneB[0], $PointsB[0]);
    $DiffMathAi = $relativeDistanceAi/ ($relativeDistanceAZ/100.0);
    $DiffMathBi = $relativeDistanceBi / ($relativeDistanceBZ/100.0);
    $TimesMathAi = $relativeDistanceA*$relativeDistanceAZ/ ($distToPlaneLoc3D[0]/100.0);
    $TimesMathBi = $relativeDistanceB*$relativeDistanceBZ/ ($distToPlaneLoc3D[1]/100.0);
    //float $SnapR = 1.95;
    print ("\n");
    print ("relativeDistanceA "+"\n");
    print ($relativeDistanceA+"\n");
    print ("relativeDistanceB "+"\n");
    print ($relativeDistanceB+"\n");
    print ("\n");
    print ("TimesMathA "+"\n");
    print ($TimesMathA+"\n");
    print ("\n");
    print ("TimesMathB "+"\n");
    print ($TimesMathB+"\n");
    print ("\n");
    */

    if($relativeDistanceA<$SnapR){
    $triggerNoTransA++;
    }
    if($relativeDistanceA <$SnapR){
    $triggerNoTransB++;
    }
    if(!($relativeDistanceA<$SnapR)){
    $VecOnPlaneA[0] = $VecCurEndsa[0];
    $VecOnPlaneB[0] = $VecCurEndsb[0];
    $triggerNoTransENDA=1;
    }else{$triggerNoTrans++;
    $First_Second_Both_None =0;
    }		if(!($relativeDistanceB<$SnapR)){
    $VecOnPlaneA[1] = $VecCurEndsa[1];
    $VecOnPlaneB[1] = $VecCurEndsb[1];
    $triggerNoTransENDB=1;
    }else{$triggerNoTrans++;
    $First_Second_Both_None =1;

    if($triggerNoTransENDA==0){ $First_Second_Both_None =-2;}

    }

    if($triggerNoTrans==0){
    $First_Second_Both_None =-1;}

    //if(($triggerNoTransENDA +$triggerNoTransENDB)== 2){
    //}

    //if(($triggerNoTransENDA +$triggerNoTransENDB)== 0){
    //}


    $ConnectedEnds = $triggerNoTransENDA + $triggerNoTransENDB;
    if($triggerNoTransENDA==1){
    $UnconnectedEnds[0]= $VecOnPlaneA[0];
    $UnconnectedEnds[1]= $VecOnPlaneB[0];
    }else{$UnconnectedEnds[0]= $VecOnPlaneA[1];
    $UnconnectedEnds[1]= $VecOnPlaneB[1];}

    clear $arrayCurvesNearA;
    clear $arrayCurvesNearA;
    $AddAB = $triggerNoTransA+$triggerNoTransB;


    if($triggerNoTrans!=0){

    $PositionsZ_A = VecCurveCvs($CurveItemZai );
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEndsa,$VecOnPlaneA, $PositionsZ_A);
    $PositionsZ_Bi = Matrix_Curve_TranslationCC($VecCurEndsb, $VecOnPlaneB, $PositionsZ_B);
    clear $VecPtsMirrorA;
    $VecPtsMirrorA= VecPtsToZMirrorPts( $PositionsZ_Ai);
    clear $VecPtsMirrorB;
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_Bi);
    $PositionsZ_A = $PositionsZ_Ai;
    $PositionsZ_B = $PositionsZ_Bi;
    cycleBackgroundColor;
    }

    }

    //print (" IsOrthoTrueZi Eq  "+$IsOrthoLineTrue +"\n");

    if($triggerNoTrans==0){
    if($PerDiffSum >97.0){

    $iis = 0;
    for ($eachVecx in  $VecCurEndsb){
    $XIntersect_Ax[$iis] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsb[$iis], $CamPos_M, $VecPtsMirrorEnds_A[$iis]));
    $iis++;
    }
    $XIntersect_Ax[2] =  $XIntersect_Ax[1];
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    $XIntersect_Ax[0] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[0]);
    $XIntersect_Ax[2] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[2]);

    $PositionsZ_Bii= $XIntersect_Ax;
    $PositionsZ_Aii= VecPtsToZMirrorPts($PositionsZ_Bii);

    $ThefirstCurve = VecArrayToCurve($XIntersect_Ax);
    $PtsMirrorAi= VecPtsToZMirrorPts($XIntersect_Ax);
    $ThefirstCurvei = VecArrayToCurve($PtsMirrorAi);

    $trigger_straitC =1;
    }
    }


    if($triggerNoTrans!=0){

    //print ("triggerNoTrans Doesnt not Eq ZERO" +"\n");

    if($IsOrthoLineTrue==1){
    //print ("IsOrthoLineTrue Eq ONE" +"\n");

    if($AxisOrthoLine!=0){

    //print ("AxisOrthoLine Doesnt not Eq ZERO" +"\n");

    if($First_Second_Both_None>=0){
    //print ("First_Second_Both_None LESS then ZERO!" +"\n");

    //if($AxisOrthoLine==0){
    if($trigger_straitC==1){

    $FloatDirEpipol = DirectionFN($VecOnPlaneA[$First_Second_Both_None], $FoundEpipol);
    $FloatDirEpipolB= DirectionFN($VecOnPlaneB[$First_Second_Both_None], $FoundEpipol);
    if($AxisOrthoLine==0){
    //print ("AxisOrthoLine Eq ZERO!" +"\n");
    //print ("line ortho Direction same as CAM epipole");

    $lineEPointA = MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);

    $Xdirection = << 1.0,0.0,0.0>>;
    $Intersect_LineB_a = FloatToVec (lineIntersection($PointsA[$First_Second_Both_None], $Xdirection, $lineEPointA,(DirectionFN( $CamPos_A,$lineEPointA)) ));

    $Point3DA = $Intersect_LineB_a;
    $Point3DAM = {($Point3DA[0]*-1), $Point3DA[1],$Point3DA[2]};

    }


    if($First_Second_Both_None==1){
    //print ("First_Second_Both_None Eq ONE! " +"\n");
    $PairInt={0,1};

    }else{ $PairInt={2,3};
    //print ("First_Second_Both_None NOT Eq ONE! " +"\n");
    }

    $Intersect_BX= VecPtsToZMirrorPts($IntersectEnds_Ax);
    $PairVectors[0]=FloatToVec(FloatPointsToCamPlane($IntersectEnds_Ax[0]));
    $PairVectors[1]= FloatToVec(FloatPointsToCamPlane($Intersect_BX[0]));
    $PairVectors[2]=FloatToVec(FloatPointsToCamPlane($IntersectEnds_Ax[1]));
    $PairVectors[3]= FloatToVec(FloatPointsToCamPlane($Intersect_BX[1]));
    $EpipolXLine = DirectionFN( $MidEpipolPosFCam, $PairVectors[$PairInt[0]]) ;

    $Intersect_LineB_a = FloatToVec (lineIntersection($VecOnPlaneA[$First_Second_Both_None], $FloatDirEpipol, $MidEpipolPosFCam,$EpipolXLine));
    //Loc $Intersect_LineB_a;
    $Intersect_LineB_b = FloatToVec (lineIntersection($VecOnPlaneB[$First_Second_Both_None], $FloatDirEpipolB, $MidEpipolPosFCam,$EpipolXLine));
    //Loc $Intersect_LineB_b;

    clear $PositionsZ_A;
    clear $PositionsZ_B;
    clear $VecPtsMirrorEnds_A;
    clear $VecPtsMirrorEnds_B;
    clear $VecPtsMirrorA;
    clear $VecPtsMirrorB;
    $PositionsZ_A[0] =  $VecOnPlaneA[$First_Second_Both_None];
    $PositionsZ_A[1]= FloatToVec (MidPoint($VecOnPlaneA[$First_Second_Both_None],$Intersect_LineB_a));
    $PositionsZ_A[2] =  $Intersect_LineB_a;
    $PositionsZ_B[0] =  $VecOnPlaneB[$First_Second_Both_None];
    $PositionsZ_B[1]= FloatToVec (MidPoint($VecOnPlaneB[$First_Second_Both_None], $Intersect_LineB_b));
    $PositionsZ_B[2] =  $Intersect_LineB_b;
    $VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
    $VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
    $VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
    $VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
    }
    }
    }
    }
    }


    if($trigger_straitC!=1){
    $iiz = 0;

    for ($eachVecx in  $VecPtsMirrorA)
    {
    $Intersect_A[`size($Intersect_A)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_B[$iiz], $CamPos_M, $VecPtsMirrorA[$iiz]));
    $iiz++;
    }

    $ThefirstCurve = VecArrayToCurve($Intersect_A);
    modifySelectedCurves smooth $Smooth 0;
    $Intersect_B= VecPtsToZMirrorPts($Intersect_A);
    $ThefirstCurvei = VecArrayToCurve($Intersect_B);
    modifySelectedCurves smooth $Smooth 0;
    $EndrEndsa = VecCurveEnds({$ThefirstCurvei});
    $EndsAtZero = isCurveEndAtZY($EndrEndsa);
    $STEPSZ = 200;
    $curvesZi = $ThefirstCurve;
    $curvesZi = CurvatureIsCircleData($curvesZi, $STEPSZ, $angleZi, $TotalDegii, $LowX, $TrackCi, $anglesMade);
    delete $ThefirstCurve;
    $ThefirstCurve = $curvesZi;
    $curvesZii = $ThefirstCurvei;
    $curvesZii = CurvatureIsCircleData($curvesZii, $STEPSZ, $angleZi, $TotalDegii, $LowX, $TrackCi, $anglesMade);
    delete $ThefirstCurvei;
    $ThefirstCurvei = $curvesZii;

    if($EndsAtZero>0){
    sets -include ZEdgeCurvesSet ({$ThefirstCurvei,$ThefirstCurve});
    }

    }
    delete $VanishingPointsLinesTempGuides;
    clear $VanishingPointsLinesTempGuides;
    delete $CurveItemZai $CurveItemZbi;
    clear $StereoCurveZ;
    $addNumbersA =0;
    clear $VanishingPointGlobal;

    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $ThefirstCurve;
    ResetTranslation({$ThefirstCurve});
    CurveIndexVecTracking({$ThefirstCurve});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ThefirstCurve;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $ThefirstCurvei;
    ResetTranslation({$ThefirstCurvei});
    CurveIndexVecTracking({$ThefirstCurvei});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ThefirstCurvei;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    }










    proc int isCurveEndAtZY(vector $EndVectors[]){
    $Number = 0;
    for($eachVec in $EndVectors){
    $ThreeFs = $eachVec;
    if($ThreeFs[0] == 0){
    $Number++;
    }}
    return $Number;
    }



    global int $ifSingleCurve;
    $ifSingleCurve =0;
    createDisplayLayer -name "VanishingPointsLines"  -empty;
    setAttr VanishingPointsLines.visibility 1; setAttr VanishingPointsLines.displayType 0; setAttr VanishingPointsLines.color 0;

    ////////////////////////////////////////////////


    /*
    $OneCurve = `ls -sl`;
    $OneCurveS = $OneCurve[0];
    $TFNS = 1;
    $CurveNS = IScircleTF($OneCurveS,$TFNS);
    print $TFNS;
    if($TFNS==1){
    $NewOneCurveS = EllipesSketchFitting($CurveNS, $EmptyVectorArrayA);
    }else{  $NewOneCurveS = $OneCurveS;}

    $NewArrayAEllipZ = NewVecOrderEllipZ($NewOneCurveS, $EmptyVectorArrayA, $MidEpipolPosFCam);
    $OneCurve = `ls -sl`;
    $NewOneCurveSB = EllipesSketchFitting($OneCurve[0], $EmptyVectorArrayB);
    $NewArrayBEllipZ = NewVecOrderEllipZ($NewOneCurveSB, $EmptyVectorArrayB, $MidEpipolPosFCam);
    $StereoCircle = Eval3DCircleStereo( $NewArrayBEllipZ  , $EmptyVectorArrayB ,  $NewArrayAEllipZ , $EmptyVectorArrayA );

    // print $EmptyVectorArrayA;
    $IndexTrackE = CreateIntIndex(`size($EmptyVectorArrayA)`);
    //select -r $NewOneCurveS;
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);
    // Loc $MidEpipolPosFCam;

    $EllipesPos_A = `xform -q -ws -t $NewOneCurveS`;
    $Dir_VecMAIN =  DirectionFN($MidEpipolPosFCam, $EllipesPos_A);

    $TwoZeroOne = {0,1};
    clear $allAngiX; clear $TFmostRArray;
    $threeVecs[0] = FloatToVec($MidEpipolPosFCam);
    $threeVecs[1] = FloatToVec($EllipesPos_A);

    for($EachVector in $EmptyVectorArrayA){
    $DIff = FindDirectionDiff($Dir_VecMAIN, $MidEpipolPosFCam, $EachVector);
    if($DIff!= 0){
    $allAngiX[`size($allAngiX)`]=  VAnglesofThreeVec($MidEpipolPosFCam, $EllipesPos_A, $EachVector);
    $threeVecs[2] = $EachVector;
    $TFmostRArray[`size($TFmostRArray)`] = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);
    }else{ $allAngiX[`size($allAngiX)`]= 0;  $TFmostRArray[`size($TFmostRArray)`] =0;}
    }

    clear $LargestIntR_KEY;
    clear $LargestIntL_KEY;
    clear $AllAngiX_LEFT;
    clear $AllAngiX_RIGHT;
    $COUNT_Nlr = 0;
    for($EachIntarray in $TFmostRArray){
    if($EachIntarray==1){
    $AllAngiX_RIGHT[`size($AllAngiX_RIGHT)`]= $allAngiX[$COUNT_Nlr];
    $LargestIntR_KEY[`size($LargestIntR_KEY)`]=$COUNT_Nlr;
    }
    if($EachIntarray==0){
    $AllAngiX_LEFT[`size($AllAngiX_LEFT)`]= $allAngiX[$COUNT_Nlr];
    $LargestIntL_KEY[`size($LargestIntL_KEY)`]=$COUNT_Nlr;
    }
    $COUNT_Nlr++;
    }


    $LargestIntR = SortNumbersIntIndex($AllAngiX_RIGHT);
    $LargestIntR = ReverseIntArray($LargestIntR);
    // Loc $EmptyVectorArrayA[$LargestIntR_KEY[$LargestIntR[0]]];
    $LargestIntL = SortNumbersIntIndex($AllAngiX_LEFT);
    $LargestIntL = ReverseIntArray($LargestIntL);
    // Loc $EmptyVectorArrayA[$LargestIntL_KEY[$LargestIntL[0]]];
    print $LargestIntR_KEY[$LargestIntR[0]];
    print $LargestIntL_KEY[$LargestIntL[0]];
    // test int $NewStartInt = $LargestIntL_KEY[$LargestIntL[0]];
    //  $IndexTrackE
    $SizeE = `size($EmptyVectorArrayA)`;
    $Add = 0;
    for($EachIntX in $IndexTrackE){
    $NewArrayIntX[`size($NewArrayIntX)`] = fmod(($NewStartInt+$Add),$SizeE);
    $Add++;
    }

    // just to see the result - $NewArrayIntX = ReverseIntArray($NewArrayIntX);

    $NewArrayAEllipZ = NewVecOrderEllipZ($NewOneCurveS, $EmptyVectorArrayA, $MidEpipolPosFCam);
    $OneCurve = `ls -sl`;
    $NewOneCurveSB = EllipesSketchFitting($OneCurve[0], $EmptyVectorArrayB);
    $NewArrayBEllipZ = NewVecOrderEllipZ($NewOneCurveSB, $EmptyVectorArrayB, $MidEpipolPosFCam);
    $StereoCircle = Eval3DCircleStereo( $NewArrayBEllipZ  , $EmptyVectorArrayB ,  $NewArrayAEllipZ , $EmptyVectorArrayA );



    */








    proc float  FindDirectionDiff(vector $Line_Y_zeroMain, vector $VecCurEndsA, vector $VecCurEndsB){
    $Dir_VecA =  DirectionFN($VecCurEndsA,$VecCurEndsB);
    $VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    return $AdditR;
    }

    global int $ForceOrthoOFFON;
    $ForceOrthoOFFON = 0;


    proc string [] ForceOrtho(string  $CurveItemAX[]){

    // string  $CurveItemAX[] =`ls -sl`;
    global string $StereoCurveZ[];
    global int $addNumbersA;
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;

    //string  $CurveItemAX[] =`ls -sl`;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemAX[0];

    /////////////////////
    $Positions = VecCurveEps($CurveItemAX[0]);
    $TempCrv = VecArrayToCurve($Positions);
    delete $CurveItemAX[0];
    $VecCurEnds = VecCurveEnds({$TempCrv});
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEndsOLD = $queryLocCurveEnds;
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );

    if(`size($queryLocCurveEnds)` >= 2){

    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $distancesEachToCurveB = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);

    $ReducedIndexA = floatArrayCountDuplicates($distancesEachToCurve);
    $ReducedIndexB = floatArrayCountDuplicates($distancesEachToCurveB);
    for($eachInt in $ReducedIndexA){
    $distAz[`size($distAz)`]= $distancesEachToCurve[$eachInt];
    }
    for($eachInt in $ReducedIndexB){
    $distBz[`size($distBz)`]= $distancesEachToCurveB[$eachInt];
    }

    //clear $NearestInt;
    //clear $NearestIntB;
    $NearestInt = SortNumbersIntIndex($distAz);
    $NearestIntB = SortNumbersIntIndex($distBz);

    $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];


    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$ReducedIndexA[$NearestInt[0]]];
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$ReducedIndexB[$NearestIntB[0]]];
    $NearestInt[0] =  $NewIntIndexAA;
    $NearestIntB[0] = $NewIntIndexBB;


    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];
    $LocA = $queryLocCurveEnds[$NearestInt[0]];
    $LocB = $queryLocCurveEnds[$NearestIntB[0]];

    //Loc $LocCurveEndsVec[$NearestInt[0]];
    //Loc $LocCurveEndsVec[$NearestIntB[0]];

    clear $EndSnapAndEndProject;
    $Loc_AorB = "";
    //////////////////////////////////////////
    if($NdistA<$NdistB){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    $Loc_AorB="B";
    }else{
    $Loc_AorB="A";
    $LocName =$LocB;
    $NearestIndex=$NearestIntB[0];
    $NearEndZ = $VecCurEnds[1];
    $endNotNearZ[0] = $VecCurEnds[0];}
    //////////////////////
    // very very rare event
    if($NdistA==$NdistB){
    $Loc_AorB="A";
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    }
    /////////////////////
    if($NearestInt[0]==$NearestIntB[0]){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    }
    //////////////////////////////////////////
    $newNames = stringArrayToString($queryLocCurveEnds, " ");
    $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    $AllarrayCurvesNear = stringToStringArray($newNamesResultAX, " ");
    $NewFoundLocs[0]  = $AllarrayCurvesNear[$NearestIndex];
    $arrayCurvesNear[0] = $queryLocCurveEnds[$NearestIndex];
    /*
    // needed for later for edgeCurves and dynamic local axis plane mirroring
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    */


    $LocOnPlaneVec = PointArray($arrayCurvesNear );
    $Loc3D_Vec = PointArray($NewFoundLocs );
    $ALLLoc3D_VecAB = PointArray($AllarrayCurvesNear);

    if($Loc_AorB == "A"){
    $ReducedIndexXAB = $ReducedIndexA;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexA,$ALLLoc3D_VecAB);
    }
    if($Loc_AorB == "B"){
    $ReducedIndexXAB = $ReducedIndexB;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexB,$ALLLoc3D_VecAB);
    }

    $ALLLoc3D_Vec = $ReducedVecAB;

    $MovedEndPointPlane = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    $CRV_ENDSi[0]= $LocOnPlaneVec[0];
    $CRV_ENDSi[1]= $MovedEndPointPlane[0];
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);
    $MidCurveA = MidPoint($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
    $EpipolD = $DDirEpipolXYZ;
    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);
    $XYZdirectL[0] = << 1,0,0>>;
    $XYZdirectL[1] = << 0,1,0>>;
    $XYZdirectL[2] = << 0,0,1>>;
    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    $AxisOrthoLineA = $AxisOrthoLine;
    // 3d start point $Loc3D_Vec[0]  free Endpoint of plane curve $MovedEndPointPlane[0]
    $Dir_CamRay =  DirectionFN($MovedEndPointPlane[0],$CamPos_A);

    // lineIntersection NOTE arguments are in this order: Point then Line ...Point then Line
    $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);

    $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);

    $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    $XYZi  = $PointN_LineC;
    $XYZadd  = $PointN_LineC;

    $XYZi[0] = $XYZadd[0]+$XYZadd[1];
    $XYZi[1] = $XYZadd[1]+$XYZadd[2];
    $XYZi[2] = $XYZadd[0]+$XYZadd[2];
    $iVc = 0;
    clear $TrackFoundN;
    if($AxisOrthoLineA ==2){
    $TwoPointsi[0] = 0;
    }
    if($AxisOrthoLineA ==1){
    $TwoPointsi[0] = 2;
    }
    if($AxisOrthoLineA ==0){
    $TwoPointsi[0] = 1;
    }
    $AXIS = $AxisOrthoLineA;

    clear $ALLlikeness;
    $i = 0;
    $Dist_3DNear = (($Dist_3D/3.0)*2.0);

    for ($each in $ALLLoc3D_Vec){

    $One = $ALLLoc3D_Vec[$i];
    $XY[0] = $Xx  = $One.x;
    $XY[1] = $Yy  = $One.y;
    $XY[2] = $Zz  = $One.z;

    if( $ReducedIndexXAB[$iVc]!= $NearestIndex ){

    $TriggerPoints=0;
    if( (equivalentTol($XYZadd[0], $Xx,  0.01) )==1){
    $All_X[$i] = $Xx;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[1], $Yy,  0.01) )==1){
    $All_Y[$i] = $Yy;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[2], $Zz,  0.01) )==1){
    $All_Z[$i] = $Zz;
    $TriggerPoints++;
    }

    if( $TriggerPoints<2){
    $diffXYZ = `abs ($XY[$AXIS] - $XYZadd[$AXIS])`;
    if(($diffXYZ< $Dist_3DNear)&&($diffXYZ!=0)){
    $All_ZYX[`size($All_ZYX)`] =$XY[$AXIS];
    $All_ZYXDiff[`size($All_ZYXDiff)`] = $diffXYZ;
    }
    }


    if( $TriggerPoints==2){

    $ALLlikeness[`size($ALLlikeness)`] = $ReducedIndexXAB[$i];
    }
    }
    $i++;
    $iVc++;
    }



    if(`size($All_ZYXDiff)`> 0){
    $SortedForce = SortNumbersIntIndex($All_ZYXDiff);
    $newOrderFloat = $All_ZYX[$SortedForce[0]];

    }


    if(`size($ALLlikeness)`> 0){


    select -cl;
    for($eachIn in $ALLlikeness){
    select -add $AllarrayCurvesNear[$eachIn];
    PAUSE;
    }


    clear $NearPointsXYZ;
    $iVc =0;
    for($eachIn in $ALLlikeness){
    if( $iVc!= $NearestIndex ){
    $NearPointsXYZ[`size($NearPointsXYZ )`] =  $ALLLoc3D_VecAB[$eachIn];
    }
    $iVc++;
    }


    $distTo3DCurveEnd = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    $Sorted = SortNumbersIntIndex($distTo3DCurveEnd);
    $NearPointsXYZ = NewVecOrderWithINTKey($Sorted,$NearPointsXYZ);

    clear $SdistTo3DCurveEnd;
    for($eachIn in $Sorted){
    $SdistTo3DCurveEnd[`size($SdistTo3DCurveEnd)`] = $distTo3DCurveEnd[$eachIn];
    }

    $ReducedIndex = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    $ReducedVec = NewVecOrderWithINTKey($ReducedIndex,$NearPointsXYZ);

    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    // if($AdditRi = 0.0){ then snap to point IF the direction is the same

    $OntheSameLine = 0;
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $OntheSameLine =1;
    }


    $CountN = 0;
    for($eachVec in $ReducedVec){


    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $eachVec);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $PointN_LineXYZ = $eachVec;
    print " on same Line ";
    }else{

    $PointN_LineXYZ  = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $eachVec);

    }

    if( (distance2Pts($PointN_LineXYZ, $PointN_LineC))>0.001){
    $LocsV[`size($LocsV)`] = `Loc $PointN_LineXYZ`;
    $CurvesV[`size($CurvesV)`] = curve2points($eachVec, $PointN_LineXYZ);
    PAUSE;
    }

    if($CountN==0){
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapN = $eachVec;
    $SnapPlaceN = $PointN_LineXYZ;
    }

    if($CountN!=0){
    print  $DistSnap;
    if((distance2Pts($PointN_LineXYZ, $PointN_LineC))<  $DistSnap){
    $SnapN = $eachVec;
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapPlaceN = $PointN_LineXYZ;

    }
    }
    $CountN++;
    }



    $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);

    delete $CurvesV;
    delete $LocsV;

    //$EulerAngleA  = EulerAngB($DirLineSnapXYZ,$LineDirect_3D);
    if(($EulerAngleA[3] >85)&&($EulerAngleA[3]<95)){



    $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    if($Dist_3DSnap<($Dist_3D/2.0)){
    cycleBackgroundColor;
    PAUSE;
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    $AddInt = $AdditR;
    if($AddInt == 0){
    $PointN_LineC = $SnapPlaceN;
    PAUSE; PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }else{

    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $FPointN_LineC =  $PointN_LineC;
    $FPointN_LineC[$AXIS] = $newOrderFloat;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }


    }

    }else{
    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }

    //}

    // $LocsV[`size($LocsV)`] = `Loc $First3dIntersect`;
    // $LocsV[`size($LocsV)`] = `Loc $PointN_LineC`;
    // $CurvesV[`size($CurvesV)`] = curve2points($First3dIntersect, $PointN_LineC);

    $Points3DPair_And_2DPair[0]= $Loc3D_Vec[0];
    $Points3DPair_And_2DPair[1]= $PointN_LineC;
    $Points3DPair_And_2DPair[2]= $LocOnPlaneVec[0];
    $Points3DPair_And_2DPair[3]= $NewPlanePoint;

    delete $TempCrv;
    $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 10 -d 3 -tol 0.05 $CurvesVi;

    $Crv_Pts = VecCurveEps($CurvesVi );
    $MirrorAcrossPlaneVecs = VecMultMatrixMirror($Crv_Pts);
    $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    //delete $CurvesV;
    //delete  $LocsV;
    clear $StereoCurveZ;
    $BothCurves[0] = $CurvesVi;
    $BothCurves[1] = $TheSecondCurve;
    $StereoCurveZ = $BothCurves;
    $addNumbersA =-3;
    ResetTranslation($BothCurves);
    CurveIndexVecTracking($BothCurves);
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $BothCurves;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    clear $StereoCurveZ;
    }
    return $BothCurves;
    }

    //////////////////////////////////////////////////////////

    proc int [] floatArrayCountDuplicates(float $listX[]){
    $list = $listX;
    $index = 0;
    $X = 0;
    $Xi = 0;
    $C = 0;
    $result = $list;
    for ($item in $list) {
    $NumberE[$X] = floatArrayCount($item, $result);
    if (1 == $NumberE[$X]) {
    $NoneDup[`size($NoneDup)`] = $Xi;
    }else{
    if (1 < $NumberE[$X]) {
    floatArrayRemoveAtIndex($X, $result);
    $X--;
    }
    }
    $Xi++;
    $X++;	}
    return $NoneDup;
    }

    //////////////////////////////////////////////////////

    proc int floatArrayCount(float $item, float $list[]){
    $result = 0;
    for ($listItem in $list) {
    if ($item == $listItem) $result++;	}
    return $result;
    }

    proc floatArrayRemoveToIndex(int $ix, float $floatArray[]){
    $ixX = 0;
    while($ixX<$ix){
    floatArrayRemoveAtIndex(0, $floatArray);
    $ixX++;
    }
    }



    proc int floatArrayRemoveAtIndex( int $index, float $list[] ){
    $len = size( $list );

    if( $index > $len  || $index < 0 ){
    return( false );
    }

    for( $i = 0; $i < $index; $i++ ){
    $result[$i] = $list[$i];
    }

    for( ; $i < $len - 1; $i++ ){
    $result[$i] = $list[$i + 1];
    }
    $list = $result;
    return( true );
    }




    ////////////////////////////////

    /*

    if(($XY[$TwoPointsi[0]] != $XYZadd[$TwoPointsi[0]])){
    print (" !!!yes TRIGGER two HERE!!"+"\n");

    }


    if( (equivalentTol($XYZadd[0], $Xx,  0.1) )==1){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }
    if( (equivalentTol($XYZadd[1], $Yy,  0.1) )==1){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }
    if( (equivalentTol($XYZadd[2], $Zz,  0.1) )==1){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }


    if (( $XYZadd[0] ==$Xx)&&( $XYZadd[1] ==$Yy)){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }

    if (( $XYZadd[1] ==$Yy)&&( $XYZadd[2] ==$Zz)){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }

    if (( $XYZadd[2] ==$Zz)&&( $XYZadd[0] ==$Xx)){
    $ALLlikeness[`size($ALLlikeness)`] = $iVc;
    }

    }
    }
    $iVc++;
    }
    */

    //////////////////////////////////

    /*

    $XYZi  = $PointN_LineC;
    $XYZadd  = $PointN_LineC;
    $XYZi[0] = $XYZadd[0]+$XYZadd[1];
    $XYZi[1] = $XYZadd[1]+$XYZadd[2];
    $XYZi[2] = $XYZadd[0]+$XYZadd[2];
    $iVc = 0;
    clear $TrackFoundN;
    if($AxisOrthoLineA ==2){
    $TwoPointsi[0] = 0;
    }
    if($AxisOrthoLineA ==1){
    $TwoPointsi[0] = 2;
    }
    if($AxisOrthoLineA ==0){
    $TwoPointsi[0] = 1;
    }
    clear $ALLlikeness;

    for ($each in $ALLLoc3D_Vec){


    $One = $ALLLoc3D_Vec[$iVc];
    $XY[0] = $Xx  = $One.x;
    $XY[1] = $Yy  = $One.y;
    $XY[2] = $Zz  = $One.z;


    if  (( $XYZadd[0]!=0 )&&($Xx!=0)){
    if  (( $XYZadd[1]!=0 )&&($Yy!=0)){
    if  (( $XYZadd[2]!=0 )&&($Zz!=0)){
    if($iVc==0){
    $Xd =  ($XYZi[0] - ($Xx )) ;
    $Yd =  ($XYZi[1] - ($Yy )) ;
    $Zd =  ($XYZi[2] - ($Zz)) ;
    }

    if( $iVc!= $NearestIndex ){
    if(($XY[$TwoPointsi[0]] != $XYZadd[$TwoPointsi[0]])){



    //  if  ( (equivalentTol($XY[0], $XYZadd[0],  0.01) )==1 ){

    if (((equivalentTol( $XY[0], $XYZadd[0],  0.00001 ) )!=1 )  || ((equivalentTol($XY[1], $XYZadd[1],  0.00001))!=1) || ((equivalentTol($XY[2], $XYZadd[2],  0.00001))!=1 )){

    //equivalentTol($XY[0], $XYZadd[0],  0.01) equivalentTol($XY[1], $XYZadd[1],  0.01)
    //  if(  ($XY[0] == $XYZadd[0] )   ||   ($XY[1] == $XYZadd[1] )  ||   ($XY[2] == $XYZadd[2] )   ){
    //  if(  ($XY[0] == $XYZadd[0] )   ||   ($XY[1] == $XYZadd[1] )  ||   ($XY[2] == $XYZadd[2] )   ){
    print  " HERE PASSED ";
    if($iVc==13){
    print  " HERE PASSED ";
    }
    if($iVc==0){
    $Xd =  ($XYZi[0] - ($Xx )) ;
    $Yd =  ($XYZi[1] - ($Yy )) ;
    $Zd =  ($XYZi[2] - ($Zz)) ;
    $Dx =  `sqrt ($XYZi[0] + $Xx)`;
    $Dy =  `sqrt ($XYZi[1] + $Yy)`;
    $Dz =  `sqrt ($XYZi[2] + $Zz)`;
    }


    $ALLlikeness[`size($ALLlikeness)`] = $iVc;

    if( $iVc!= 0 ){

    if($Xd > ( `abs($XYZi[0] - ($Xx))` )){
    $Xd = $Xx;
    $TrackN[0]= $iVc;
    }
    if($Xd == ( `abs($XYZi[0] - ($Xx))` )){
    if(`sqrt ($XYZi[0] + $Xx)`< $Dx){
    $TrackN[0]= $iVc;
    $Dx =  `sqrt ($XYZi[0] + $Xx)`;
    }
    }

    if($Yd > ( `abs($XYZi[1] - ($Yy))` )){
    $Yd = $Yy;
    $TrackN[1]= $iVc;}

    if($Yd == ( `abs($XYZi[1] - ($Yy))` )){
    if(`sqrt ($XYZi[1] + $Yy)`< $Dy){
    $TrackN[1]= $iVc;
    $Dy =  `sqrt ($XYZi[1] + $Yy)`;
    }
    }

    if($Zd > ( `abs($XYZi[2] - ($Zz))` )){
    $Zd = $Zz;
    $TrackN[2]= $iVc;}

    if($Zd == ( `abs($XYZi[2] - ($Zz))` )){
    if(`sqrt ($XYZi[2] + $Zz)`< $Dz){
    $TrackN[2]= $iVc;
    $Dz =  `sqrt ($XYZi[2] + $Zz)`;
    }
    }

    }
    }



    ///////////////

    }

    }
    }
    }



    }
    $iVc++;
    }



    */



    //print $ALLlikeness;


    //print $ALLlikeness;
    //print $TrackN;
    //print $NearestIndex


    /*
    if($Xd >= ( ($XYZi[0] - ($Xx+$Yy)) )){
    $Xd = $Xx;
    $TrackN[0]= $iVc;
    if($iVc==13){
    print  " HERE1 ";
    }

    }


    if($Yd >= ( ($XYZi[1] - ($Yy+$Zz)) )){
    $Yd = $Yy;
    $TrackN[1]= $iVc;

    if($iVc==13){
    print  " HERE2 ";
    }
    }


    if($Zd >= ( ($XYZi[2] - ($Xx+$Zz)) )){
    $Zd = $Zz;
    $TrackN[2]= $iVc;
    if($iVc==13){
    print  " HERE3 ";
    }




    clear $NearPointsXYZ;
    for($eachIn in $ALLlikeness){
    $NearPointsXYZ[`size($NearPointsXYZ )`]=  $ALLLoc3D_Vec[$eachIn];

    }

    for($eachIn in $ALLlikeness){
    select -add $AllarrayCurvesNear[$eachIn];

    }
    */










    proc vector [] VecMultMatrixMirror(vector $pointZ[]){

    matrix $m2[4][4]= <<	-1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0>>;

    $MatrixB = `MatrixToFloat($m2)`;
    for($eachVec in $pointZ){
    $FLoatPointA[`size($FLoatPointA)`] = FloatToVec(pointMatrixMult( $eachVec, $MatrixB ));
    }
    return $FLoatPointA;
    }

    ////////////////////////////////

    ////////////////////////////////


    proc vector [] MoveVectors(vector $Pos_A, vector $VecLoc, vector $Crv_Pts[]){

    $DirLine = DirectionFN( $VecLoc, $Pos_A);
    $DistToPoint = distance2Pts($Pos_A, $VecLoc);

    // DISTANCE TIMES DIRECTION VEC PLUS POINT VECTOR To translate
    clear $TranstatedVecs;
    for($eachVector in $Crv_Pts){
    $TranstatedVecs[`size($TranstatedVecs)`] = ($eachVector+($DistToPoint*$DirLine));
    }
    return $TranstatedVecs;
    }

    ////////////////////////////////

    /*
    // playing around  used at the end of new force othro script
    $PointN_Line = ClosestPoint2LineVec($Dir_CamRay, $MovedEndPointPlane[0], $Loc3D_Vec[0]);
    $LocsV[`size($LocsV)`] = `Loc $PointN_Line`;
    $CurvesV[`size($CurvesV)`] = curve2points($MovedEndPointPlane[0], (($Dir_CamRay*$Dist2D3D)+$MovedEndPointPlane[0]));
    $CurvesV[`size($CurvesV)`] = curve2points($Loc3D_Vec[0], $PointN_Line);
    $PointN_LineB = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $PointN_Line);
    $LocsV[`size($LocsV)`] = `Loc $PointN_LineB`;
    $CurvesV[`size($CurvesV)`] = curve2points($PointN_LineB, $PointN_Line);
    */


    proc string [] VanishingCurves( string  $CurveItemA[]){

    //     string  $CurveItemA[] =`ls -sl`;
    global string $VanishingPointsLinesTempGuides[];
    global int $ifSingleCurve;
    //float $SnapD = 0.013;
    $SnapD = 0.003;
    global vector $TempVectorsCrv[];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemA[0];

    /////////////////////
    if(size($TempVectorsCrv)>0){
    clear $TempVectorsCrv;}
    $Positions = VecCurveCvs($CurveItemA[0]);
    $TempCrv = VecArrayToCurve($Positions);

    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $TempCrv;
    $PositionsZ_Ax = VecCurveEps($TempCrv);

    $ZYplaneMatrix[0] = <<0, 0, 0>>;
    $ZYplaneMatrix[1] = <<0, 1, 0>>;
    $ZYplaneMatrix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;

    $TempVectorsCrv  = LineIntersectPlaneCam( $PositionsZ_Ax, $CamPos1, $ZYplaneMatrix);
    delete $TempCrv;
    ////////////////////

    $Pi = 3.1415926535;
    $pi = 3.1415926535;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $CamerasDirectionVector = $CamerasDirectionVectorNormal;
    $MultDirForWard = multiplyFloat(-1, $CamerasDirectionVector);
    $MultDirCam = multiplyFloat(-3, $CamerasDirectionVector);
    $FloatDirectionCamNormalA = AddFloats($CamPos1, $MultDirCam);
    $DirectionVectorXn = {-2,0,0};
    $DirectionVectorX = {2,0,0};
    $DirectionVectorY = {0,-2,0};
    $DirectionVectorYn = {0,2,0};
    $DirectionVectorZn = {0,0,-2};
    $DirectionVectorZ = {0,0,2};
    $VecDirection_A_XYZ[0] = <<-2,0,0>>;
    $VecDirection_A_XYZ[1] = <<2,0,0>>;
    $VecDirection_A_XYZ[2] = <<0,2,0>>;
    $VecDirection_A_XYZ[3] = <<0,-2,0>>;
    $VecDirection_A_XYZ[4] = <<0,0,-2>>;
    $VecDirection_A_XYZ[5] = <<0,0,2>>;
    $VecDirectionXYZ[0] = <<-1,0,0>>;
    $VecDirectionXYZ[1] = <<1,0,0>>;
    $VecDirectionXYZ[2] = <<0,1,0>>;
    $VecDirectionXYZ[3] = <<0,-1,0>>;
    $VecDirectionXYZ[4] = <<0,0,-1>>;
    $VecDirectionXYZ[5] = <<0,0,1>>;
    $FloatPointDirectionXn = AddFloats($CamPos1, $DirectionVectorXn);
    $FloatPointDirectionX = AddFloats($CamPos1, $DirectionVectorX);
    $FloatPointDirectionY = AddFloats($CamPos1, $DirectionVectorY);
    $FloatPointDirectionYn = AddFloats($CamPos1, $DirectionVectorYn);
    $FloatPointDirectionZn = AddFloats($CamPos1, $DirectionVectorZn);
    $FloatPointDirectionZ = AddFloats($CamPos1, $DirectionVectorZ);
    clear $VecXYZs;
    $VecXYZs[0] = FloatToVec($FloatPointDirectionXn);
    $VecXYZs[1] = FloatToVec($FloatPointDirectionX);
    $VecXYZs[2] = FloatToVec($FloatPointDirectionY);
    $VecXYZs[3] = FloatToVec($FloatPointDirectionYn);
    $VecXYZs[4] = FloatToVec($FloatPointDirectionZn);
    $VecXYZs[5] = FloatToVec($FloatPointDirectionZ);
    $VecXYZsOnPlane = VecPointsToCameraPlane($VecXYZs);
    $AverageVecXYZsOnP = AverageVectorPoint($VecXYZsOnPlane);
    $DirectionsZ = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    $FloatDirxyz[0] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[0]));
    $FloatDirxyz[1] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[1]));
    $FloatDirxyz[2] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[3]));
    $FloatDirxyz[3] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[2]));
    $FloatDirxyz[4] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[4]));
    $FloatDirxyz[5] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[5]));
    $Alll = "";
    clear $AllStrings $AnglesAll ;
    for ($eachOrthD in $VecDirectionXYZ){
    $EulerAngleA = EulerAngB($eachOrthD, $CamerasDirectionVector);
    $AnglesAll[`size($AnglesAll)`]= $EulerAngleA[3];
    $stringFloat = FloatArrayToStringArray($EulerAngleA);
    $Alll  = stringArrayToString($stringFloat, " ");
    $AllStrings[`size($AllStrings)`]= $Alll;
    }
    clear $EmptyIndxNewOrder;
    $indexAx = CreateIntIndex(6);
    $stringIndTr = IntArrayToStringArray($indexAx);
    $ANgnew = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
    $EmptyIndxNewOrder = ReverseStringArray($EmptyIndxNewOrder);
    $BestThree = {$EmptyIndxNewOrder[0], $EmptyIndxNewOrder[1], $EmptyIndxNewOrder[2]};
    $BestThree = ReverseStringArray($BestThree);
    $BestThree = stringArrayRemoveDuplicates ($BestThree);
    $indexAxNew = ArrayToIntList( $BestThree);
    $VecCurEnds = VecCurveEnds($CurveItemA);

    $LengCRV_a = `arclen $CurveItemA`;
    $DistEndsi = distance2Pts($VecCurEnds[0], $VecCurEnds[1]);
    $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);

    $AverageVecCurEndsP = AverageVectorPoint($VecCurEnds);
    $Count = 0;
    $CurvePsD = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
    size($EmptyIndxNewOrder);
    $DirectionsZ = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    clear $colori;
    $iiX = 0;
    for($eachDirection in $indexAxNew){
    if($eachDirection ==0 || $eachDirection ==1){$colori[`size($colori)`] = 13;}
    if($eachDirection ==3 || $eachDirection ==2){$colori[`size($colori)`] = 14;}
    if($eachDirection ==4 || $eachDirection ==5){$colori[`size($colori)`] = 6;}
    }
    clear $CurvesV;
    $Cindex = 0;
    for ($eachDii in $indexAxNew){
    $IndexZ = $indexAxNew[$Count];

    $FloatPointDirectionZniY  = AddFloats( $VecCurEnds[1], $VecDirection_A_XYZ[$IndexZ]);
    $VecXYZsOnPlaneiY = VecPointsToCameraPlane($FloatPointDirectionZniY);
    $CurveDirectionZiY =  DirectionF($VecCurEnds[1],  $VecXYZsOnPlaneiY[0]);
    $FloatPointDirectionZniiY = AddFloats( $VecCurEnds[0], $VecDirection_A_XYZ[$IndexZ]);
    $VecXYZsOnPlaneiiY = VecPointsToCameraPlane($FloatPointDirectionZniiY);
    $CurveDirectionZiiY =  DirectionF($VecCurEnds[0],  $VecXYZsOnPlaneiiY[0]);
    $locsAi = lineIntersection($VecCurEnds[1], $CurveDirectionZiY, $VecCurEnds[0],  $CurveDirectionZiiY);

    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[0], $locsAi);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], $colori[$Cindex]);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[1], $locsAi);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], $colori[$Cindex]);
    editDisplayLayerMembers -noRecurse VanishingPointsLines $CurvesV;
    $Cindex++;
    $Count++;
    }

    $ifSingleCurve = 0;
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);

    DirectionFN($MidEpipolPosFCam,$VecCurEnds[1]);
    DirectionFN($VecCurEnds[0],$VecCurEnds[1]);
    $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
    $Dir_VecA =   PositiveDirectionLine($VecCurEnds[0],$VecCurEnds[1]);
    $VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];


    $VecPtsMirrorEnds_A= VecPtsToZMirrorPts( $VecCurEnds);
    $triggerMiddle = 0;
    $VIntersectEnds_A[0] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[1], $CamPos_M, $VecPtsMirrorEnds_A[0]));
    $VIntersectEnds_A[1] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[0], $CamPos_M, $VecPtsMirrorEnds_A[1]));
    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
    $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
    $IntersectEnds_Ai =  FloatPointsToCamPlane($VIntersectEnds_A[0]);
    $IntersectEnds_Bi = FloatPointsToCamPlane($VIntersectEnds_A[1]);
    $CurveItemAa[0] = $CurveItemA[0];
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEndsOLD = queryLocOnLivePlaneBLayer();
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );



    if(`size($queryLocCurveEnds)` > 2){

    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $NearestInt = SortNumbersIntIndex($distancesEachToCurve);
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[0]];
    $distancesEachToCurveB = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    $NearestIntB = SortNumbersIntIndex($distancesEachToCurveB);
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$NearestIntB[0]];


    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];

    if(($NdistA<$SnapD)||($NdistB<$SnapD)){

    $iv = -1;
    $distsA = $NdistA;
    $distsB = $NdistB;
    for (  $i = 1; $i < 5; $i++) {
    if( $distsA < $distsB){
    $NdistA = $distancesEachToCurve[$NearestInt[$i]];
    if($iv==-1){
    $iv++;
    $StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[0]];}
    if (equivalentTol($NdistA, $distsA, 0.001) == 1){
    $StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[$i]];
    }
    }


    }

    //print $StringAllNearA;
    //print ("NdistA :" +$NearestInt[$i]+" "+$NdistA+"  NdistB :"+$NearestIntB[$i]+" "+$NdistB+"\n");

    $newNames = stringArrayToString( $StringAllNearA, " ");
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    $arrayCurvesNearA = stringToStringArray($newNamesResultC, " ");
    $CRV_index_number = 0;
    $CRc = 0;
    $CRcT = 0;
    for($eachCurve in $arrayCurvesNearA){
    if(`sets -im ZEdgeCurvesSet $eachCurve` ==1){
    $CRV_index_number = $CRc;
    $CRcT++;
    break;
    }
    $CRc++;
    }

    if($CRcT ==1){
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[$CRc]];
    }
    }

    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];

    $newNames = stringArrayToString($EmptyStringNewOrderA, " ");
    $newNamesResultAx = substituteAllString($newNames, "Plane", "");
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    $arrayCurvesNear = stringToStringArray($newNamesResultC, " ");
    $NearCurvesEnds[0] = $arrayCurvesNear[0];
    $NearCurvesEnds[1] = $arrayCurvesNear[1];

    $arrayCurvesNearA1 = stringToStringArray($newNamesResultAx, " ");

    $LocCurveEndsVec_3D = PointArray($arrayCurvesNearA1);


    $LoCz_3D = $LocCurveEndsVec_3D;

    /*
    $FloatDirCam[0] = FloatToVec (DirectionF($CamPos1, $VecXYZs[0]));
    $FloatDirCam[1] = FloatToVec (DirectionF($CamPos1, $VecXYZs[1]));
    $PointN_LineA = ClosestPoint2LineVec($LineDirect_3D, $VecCurEnds[0], $LocCurveEndsVec_3D[0]);
    $distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocCurveEndsVec_3D[0]);
    $distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocCurveEndsVec_3D[1]);
    $relativeDistanceA = ($Distance_A+$distToPlaneLoc[0])/2.0;
    $relativeDistanceB = ($Distance_B+$distToPlaneLoc[1])/2.0;
    */



    $TXI = << -1.0 , 1.0, 1.0>>;
    $LoCz_3D[2] = MultVec($LoCz_3D[0],$TXI);
    $LoCz_3D[3] = MultVec($LoCz_3D[1], $TXI);
    for($eachItemVEC in $LoCz_3D){
    $VanishingLOC[`size($VanishingLOC)`] = Loc($eachItemVEC);
    $SetCol = `setAttr ($VanishingLOC[size($VanishingLOC)-1]+".overrideColor ") 6 `;
    setAttr ( $VanishingLOC[size($VanishingLOC)-1]+".scale") 5.0 5.0 5.0;
    }

    appendStringArray($CurvesV, $VanishingLOC, size($VanishingLOC));
    //string $edgeZsetAB[] = `sets -q ZEdgeCurvesSet`;
    //select -r $edgeZsetAB;
    $edgeZsetA = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[0]`;
    $edgeZsetB = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[1]`;
    $COuntN = 0;
    for($eachVec in $LocCurveEndsVec_3D){
    $ThreepointVecs = $eachVec;
    if (equivalentTol($ThreepointVecs[0], 0.00, 0.001) == 1){
    $EDGEpoints[$COuntN]= 1;
    }else{$EDGEpoints[$COuntN]= 0;}
    $COuntN++;
    }
    $edgeZsetA =$EDGEpoints[0];
    $edgeZsetB =$EDGEpoints[1];


    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    if(($NearCurvesEnds[0] == $NearCurvesEnds[1])&&( ($edgeZsetA+$edgeZsetB) ==2)){

    if($NdistA<$NdistB){
    $edgeZsetA =1;
    $edgeZsetB =0;
    }
    if($NdistA>$NdistB){
    $edgeZsetA =0;
    $edgeZsetB =1;
    }
    if($edgeZsetA==0){$NdistA=100;}
    if($edgeZsetB==0){$NdistB=100;}

    }
    }

    if(($NdistA>$SnapD)&&($NdistB>$SnapD)){
    $edgeZsetA =0;
    $edgeZsetB =0;
    }


    }



    if(($edgeZsetA==1)&&($NdistA<$SnapD)){
    $pointNearEdgeCurve[0]= 1;
    }
    if(($edgeZsetA==1)&&($NdistA>$SnapD)){
    $pointNearEdgeCurve[0]= 0;
    }
    if(($edgeZsetA==0)&&($NdistA>$SnapD)){
    $pointNearEdgeCurve[0]= 0;
    }
    if(($edgeZsetA==0)&&($NdistA<$SnapD)){
    $pointNearEdgeCurve[0]= 2;
    }

    if(($edgeZsetB==1)&&($NdistB<$SnapD)){
    $pointNearEdgeCurve[1]= 1;
    }
    if(($edgeZsetB==1)&&($NdistB>$SnapD)){
    $pointNearEdgeCurve[1]= 0;
    }
    if(($edgeZsetB==0)&&($NdistB>$SnapD)){
    $pointNearEdgeCurve[1]= 0;
    }
    if(($edgeZsetB==0)&&($NdistB<$SnapD)){
    $pointNearEdgeCurve[1]= 2;
    }



    /////////////////////////////////////////////

    if($edgeZsetA==1){
    $EdgeDist =$NdistA;
    }else{$EdgeDist=$NdistB;}

    $SnappingVector = 0;
    if($NdistA<$NdistB){
    $SnappingVector=0;
    }else{$SnappingVector=1;}

    if($NdistA>$SnapD){
    $edgeZsetA = 0;
    }
    if($NdistB>$SnapD){
    $edgeZsetB = 0;
    }
    $OneIsNotNearThePlane = 0;
    if(($NdistA>$SnapD)||($NdistB<$SnapD)){
    if(($NdistA<$SnapD)||($NdistB>$SnapD)){
    $OneIsNotNearThePlane =1;
    }
    }

    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    if(($edgeZsetA==1)||($edgeZsetB==1)){
    $EdgeDist =0.001;
    }
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




    if($pointNearEdgeCurve[0]+$pointNearEdgeCurve[1]== 1){



    $newNamesResultA1 = substituteAllString($newNames, "Plane", "");
    $ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
    $ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
    $A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
    $A= `MakeCleanFloats($A)`;
    $B= `MakeCleanFloats($B)`;
    if(($A[0] ==0)||($B[0] ==0)){

    $triggerMiddle =2;
    $ifSingleCurve=1;
    if($edgeZsetA==1){
    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
    $NearVecPts[1]= $VecCurEnds[1];
    }else{
    $NearVecPts[0]= $VecCurEnds[0];
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
    }
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    if($EdgeDist<2.5){

    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    $PositionsZ_Aii = $PositionsZ_Ai;
    }
    $PositionsZ_Aiix[0] = <<0, 0, 0>>;
    $PositionsZ_Aiix[1] = <<0, 1, 0>>;
    $PositionsZ_Aiix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    if($EdgeDist<2.5){
    $VecTest  = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
    }else{$VecTest  = LineIntersectPlaneCam($PositionsZ_A, $CamPos1, $PositionsZ_Aiix);
    }
    $CurveAv[0] = VecArrayToCurveB($VecTest);
    }

    }



    if( $pointNearEdgeCurve[1]==1){

    $newNamesResultA1 = substituteAllString($newNames, "Plane", "");
    $ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
    $ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
    $A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
    $A = MakeCleanFloatsZ($A);
    $B = MakeCleanFloatsZ($B);

    if(($A[0] ==0)&&($B[0] ==0)){

    // NOTE these two
    $triggerMiddle =2;
    $ifSingleCurve=1;

    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    delete $CurveItemA;
    $CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);

    $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    if($DiffMathA >95.0){
    $PositionsZ_Aii[0] = $NearVecPts[0];
    $PositionsZ_Aii[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
    $PositionsZ_Aii[2]= $NearVecPts[1];

    } else{
    $PositionsZ_Aii = $PositionsZ_Ai;}
    $PositionsZ_Aiix[0] = <<0, 0, 0>>;
    $PositionsZ_Aiix[1] = <<0, 1, 0>>;
    $PositionsZ_Aiix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $VecTest = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
    if($DiffMathA >95.0){	$CurveAv[0] = VecArrayToCurve($VecTest);}else{
    $CurveAv[0] = VecArrayToCurve($VecTest);}
    }
    }


    if($triggerMiddle==0){

    if($GetSizeOfCRV_ends>0){
    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);
    $distancesTo3DCurveEnd = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
    $Sorted = SortNumbersIntIndex($distancesTo3DCurveEnd);
    $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
    $distancesTo3DCurveEndi = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
    $Sortedi = SortNumbersIntIndex($distancesTo3DCurveEndi);
    $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
    $FistAndSecond[0]=$LocCurveEndsVec3D[$Sorted[0]];
    $FistAndSecond[1]=$LocCurveEndsVec3D[$Sortedi[0]];
    $LocNames[0]=$queryLocCurveEnds3D[$Sorted[0]];
    $LocNames[1]=$queryLocCurveEnds3D[$Sortedi[0]];
    $LocNames[2]=$queryLocCurveEnds3D[$Sorted[1]];
    $LocNames[3]=$queryLocCurveEnds3D[$Sortedi[1]];
    $VecA = $FistAndSecond[0];
    $VecB = $FistAndSecond[1];
    $XX = $VecA.x;
    $XXX = $VecB.x;
    if( ($XX*-1)==$XXX){
    if($NptsDist<2.5){

    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($VecA));
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($VecB));
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    delete $CurveItemA;
    $CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);
    $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    clear $PositionsZ_A;

    if($DiffMathA >95.0){

    $PositionsZ_Ai[0] = $NearVecPts[0];
    $PositionsZ_Ai[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
    $PositionsZ_Ai[2]= $NearVecPts[1];

    }else{
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    }
    $ReversePositionsZ_Ai = ReverseVectorArray($PositionsZ_Ai);
    clear $PtsMirrorAi;
    $PtsMirrorAi= VecPtsToZMirrorPts($ReversePositionsZ_Ai);
    $iiz = 0;
    clear $XIntersect_Ax;
    for ($eachVecx in  $ReversePositionsZ_Ai){
    $XIntersect_Ax[`size($XIntersect_Ax)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_Ai[$iiz], $CamPos_M, $PtsMirrorAi[$iiz]));
    $iiz++;
    }
    if($DiffMathA >95.0){
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    }

    $CurveAv =  VecArrayToSplitCurve($XIntersect_Ax);
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
    $evalSmoothi += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmoothi);
    $ifSingleCurve=1;
    }
    }
    }
    }

    $VanishingPointsLinesTempGuides = $CurvesV;
    if(( $ifSingleCurve == 1)&&($triggerMiddle ==0)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[1];
    sets -include ZEdgeCurvesSet $CurveAv;
    }else{
    if(( $ifSingleCurve == 1)&&($triggerMiddle ==1)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    }
    }

    if( ($ifSingleCurve == 1)&&($triggerMiddle ==2)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv;
    $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    sets -include ZEdgeCurvesSet $CurveAv;
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    }
    return $CurvesV;
    }

    proc vector [] VecPointsToCameraPlane(vector $V[]){
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+($D1*$F3);
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    return $O;
    }
}


/******************************************************************************
 * @procedure    CPerceptron_Train
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $x0 : float
 *   $x1 : float
 *   $r : float
 *
 * @returns      float
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float CPerceptron_Train(float $x0, float $x1, float $r)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Sum;
    float $Result;
    float $Output;
    float $Correction;
    float $Error;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global float $x0W;
    global float $x1W;
    global float $LearningCoeff;
    global float $Threshold;
    global float $Out;

    $Sum = ($x0*$x0W)+($x1*$x1W)+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result = Sigmoid($Sum);

    $Out = ($x0*$x0W)+($x1*$x1W);
    if($Out>$Threshold){ $Output = 1.0;
    }else{ $Output = 0.0;}

    $Error = ((float)$r)-($Output);
    $Correction = $LearningCoeff*$Error;

    if($x0==1){ $x0W += $Correction;}
    if($x1==1){ $x1W += $Correction;}
    return $Result;

}


/******************************************************************************
 * @procedure    CPerceptron_Sigmoid
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $x : float
 *
 * @returns      float
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float CPerceptron_Sigmoid(float $x)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $S = (1.0/(1.0+`exp(-$x)`));

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $S = (1.0/(1.0+`exp(-$x)`));
    return $S;

}


/******************************************************************************
 * @procedure    CPerceptron_Getx0Weight
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      float
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float CPerceptron_Getx0Weight()
{

    global float $x0W;
    return $x0W;

}


/******************************************************************************
 * @procedure    CPerceptron_Getx1Weight
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 *
 * @returns      float
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float CPerceptron_Getx1Weight()
{

    global float $x1W;
    return $x1W;

}


/******************************************************************************
 * @procedure    CPerceptron_Run
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $x0 : float
 *   $x1 : float
 *
 * @returns      float
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float CPerceptron_Run(float $x0, float $x1)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Sum;
    float $Result;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global float $x0W;
    global float $x1W;
    global float $Threshold;
    $Sum = ($x0*$x0W)+($x1*$x1W);
    if($Sum>$Threshold){ $Result = 1;
    }else{ $Result = 0;}
    $Result = Sigmoid($Sum);
    return $Result;

}


/******************************************************************************
 * @procedure    CPerceptron_RunX
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $x0 : float
 *
 * @returns      float
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float CPerceptron_RunX(float $x0)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Result;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    global float $Threshold;
    if($x0>$Threshold){ $Result = 1;
    }else{ $Result = 0;}
    //$Result = Sigmoid($Sum);
    return $Result;

}


/******************************************************************************
 * @procedure    PrintMod
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $StepN : int
 *   $Mod : float
 *
 * @returns      int
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int PrintMod(int $StepN, float $Mod)
{

    if ( fmod($StepN, $Mod) == ($Mod-1)  ) {
    return 1;
    }else {return 0;}

}


/******************************************************************************
 * @procedure    GatherDataR
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Xt : float[]
 *   $Av : float
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] GatherDataR(float $Xt[], float $Av)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Vt[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ($eachInt in $Xt){
    if($eachInt > $Av){
    $Vt[`size($Vt)`]= 0;
    }else{$Vt[`size($Vt)`]= 1;}}
    return $Vt;

}


/******************************************************************************
 * @procedure    GatherDataDiff
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Xt : float[]
 *   $Av : float
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] GatherDataDiff(float $Xt[], float $Av)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Vt[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    for ($eachInt in $Xt){
    $Vt[`size($Vt)`]= `abs ($Av-$eachInt)`;
    }
    return $Vt;

}


/******************************************************************************
 * @procedure    AverageFloats
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $FloatArray : float[]
 *
 * @returns      float
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float AverageFloats(float $FloatArray[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Ix = 0;
    float $AddAll = 0;
    float $Divide = $AddAll/$Ix;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Ix = 0;
    $AddAll = 0;
    for($eachF in $FloatArray){
    $AddAll+= $eachF;
    $Ix++;
    }
    $Divide = $AddAll/$Ix;
    return $Divide;

}


/******************************************************************************
 * @procedure    AverageFloatArrays
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $FloatArrayA : float[]
 *   $FloatArrayB : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] AverageFloatArrays(float $FloatArrayA[], float $FloatArrayB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Ix = 0;
    float $AddAll[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = ($eachF + $FloatArrayB[$Ix])/2.0;
    $Ix++;
    }
    return $AddAll;

}


/******************************************************************************
 * @procedure    AddFloatArrays
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $FloatArrayA : float[]
 *   $FloatArrayB : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] AddFloatArrays(float $FloatArrayA[], float $FloatArrayB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Ix = 0;
    float $AddAll[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = ($eachF + $FloatArrayB[$Ix]);
    $Ix++;
    }
    return $AddAll;

}


/******************************************************************************
 * @procedure    DivideFloatArrays
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $FloatArrayA : float[]
 *   $DivideX : float
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] DivideFloatArrays(float $FloatArrayA[], float $DivideX)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Ix = 0;
    float $AddAll[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] =  $eachF/$DivideX;
    $Ix++;
    }
    return $AddAll;

}


/******************************************************************************
 * @procedure    DiffFloatArrays
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $FloatArrayA : float[]
 *   $FloatArrayB : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] DiffFloatArrays(float $FloatArrayA[], float $FloatArrayB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Ix = 0;
    float $AddAll[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = abs (($eachF - $FloatArrayB[$Ix]));
    $Ix++;
    }
    return $AddAll;

}


/******************************************************************************
 * @procedure    PercentDiffZeroOneArrays
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $FloatArrayA : float[]
 *   $FloatArrayB : float[]
 *
 * @returns      float
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float PercentDiffZeroOneArrays(float $FloatArrayA[], float $FloatArrayB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Ix = 0;
    float $Fx = 0.0;
    float $AddAll;
    float $DiffMathA;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Ix = 0;
    $Fx = 0.0;
    for($eachF in $FloatArrayA){
    if ($eachF != $FloatArrayB[$Ix]){
    $AddAll+= 1.0;
    }
    $Fx++;
    $Ix++;
    }

    //print ($AddAll +" "+$Fx+"\n");

    if($AddAll != 0){
    $DiffMathA =  $AddAll / ($Fx/100.0);
    }else{ $DiffMathA = 0;}

    return $DiffMathA;

}


/******************************************************************************
 * @procedure    GatherDataC
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Xt : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] GatherDataC(float $Xt[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Count = 0;
    int $CountP = 0;
    float $Vt[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $Count = 0;
    $CountP = 0;
    //$Vt[`size($Vt)`] =0;
    for ($eachInt in $Xt){

    if($Count>0){
    if($Xt[$Count-1]!=$Xt[$Count]){

    $Vt[`size($Vt)`]= $CountP;
    $CountP = 0;
    }
    }
    $CountP++;
    $Count++;
    }
    $Vt[`size($Vt)`]= $CountP;

    return $Vt;

}


/******************************************************************************
 * @procedure    GatherData
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Xt : int[]
 *
 * @returns      int []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] GatherData(int $Xt[])
{


    if(`size($Xt)`>0){
    return $Xt;
    }

}


/******************************************************************************
 * @procedure    GatherDataF
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Xt : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] GatherDataF(float $Xt[])
{


    if(`size($Xt)`>0){
    return $Xt;
    }

}


/******************************************************************************
 * @procedure    CPerceptron_TrainX
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $x0 : float
 *   $x1 : float
 *
 * @returns      float
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float CPerceptron_TrainX(float $x0, float $x1)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Sum;
    float $Result;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    global float $Threshold;
    $Sum = ($x0)+($x1)+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result = Sigmoid($Sum);
    return $Result;

}


/******************************************************************************
 * @procedure    GatherDataZeroOne
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Xt : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] GatherDataZeroOne(float $Xt[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $count = 0;
    float $ZO[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $count = 0;
    for ($eachF in $Xt){
    if($eachF == 1){
    $ZO[$count] = 1;
    }
    if($eachF == -1){
    $ZO[$count] = 0;
    }
    $count++;

    }
    return $ZO;

}


/******************************************************************************
 * @procedure    GatherDataRR
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Xt : float[]
 *   $Av : float
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] GatherDataRR(float $Xt[], float $Av)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $count = 0;
    float $Vt[];
    float $PastF;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $count = 0;

    for ($eachF in $Xt){

    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= -1;}

    if($count>0){

    if($PastF<$eachF){
    if($PastF<$Av){
    if(($PastF+$eachF/2.0)<$Av){
    $Vt[$count]= 1; }
    }
    }

    }

    $PastF = $eachF;
    $count++;
    }
    return $Vt;

}


/******************************************************************************
 * @procedure    GatherDataRRZO
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Xt : float[]
 *   $Av : float
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] GatherDataRRZO(float $Xt[], float $Av)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $count = 0;
    float $Vt[];
    float $PastF;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $count = 0;

    for ($eachF in $Xt){

    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= 0;}

    if($count>0){

    if($PastF<$eachF){
    if($PastF<$Av){
    if(($PastF+$eachF/2.0)<$Av){
    $Vt[$count]= 1; }
    }
    }

    }

    $PastF = $eachF;
    $count++;
    }
    return $Vt;

}


/******************************************************************************
 * @procedure    GatherDataAboveBelowT
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Xt : float[]
 *   $Av : float
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] GatherDataAboveBelowT(float $Xt[], float $Av)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $count = 0;
    float $Vt[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $count = 0;
    for ($eachF in $Xt){
    if($eachF < $Av){
    $Vt[$count]= 1;
    }else{$Vt[$count]= 0;}
    $count++;
    }
    return $Vt;

}


/******************************************************************************
 * @procedure    CPerceptronZ_Train
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $x0 : float[]
 *   $x1 : float[]
 *   $r : float
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] CPerceptronZ_Train(float $x0[], float $x1[], float $r)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Size = size($x0);
    float $Sum;
    float $Result[];
    float $Output;
    float $Correction;
    float $Error;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    global float $x0WX[];
    global float $x1WX[];
    global float $LearningCoeff;
    global float $Threshold;
    global float $Out;


    $Size = size($x0);
    for($i=0; $i<$Size; $i++){
    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i])+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result[$i] = Sigmoid($Sum);

    $Out = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
    if($Out>$Threshold){ $Output = 1.0;
    }else{ $Output = 0.0;}

    $Error = ((float)$r)-($Output);
    $Correction = $LearningCoeff*$Error;

    if($x0[$i]==1){ $x0WX[$i] += $Correction;}
    if($x1[$i]==1){ $x1WX[$i] += $Correction;}

    }

    return $Result;

}


/******************************************************************************
 * @procedure    CPerceptronZ_TrainX
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $x0 : float[]
 *   $x1 : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] CPerceptronZ_TrainX(float $x0[], float $x1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Size = size($x0);
    float $Sum;
    float $Result[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    global float $Threshold;
    $Size = size($x0);
    for($i=0; $i<$Size; $i++){
    $Sum = ($x0[$i])+($x1[$i])+((-1)*$Threshold);
    //print ("Sum "+$Sum+"\n");
    $Result[$i] = Sigmoid($Sum);
    }
    return $Result;

}


/******************************************************************************
 * @procedure    CPerceptronZ_RunXZ
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $x0 : float[]
 *   $x1 : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] CPerceptronZ_RunXZ(float $x0[], float $x1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Size = size($x0);
    float $Sum;
    float $Result[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global float $x0WX[];
    global float $x1WX[];
    global float $Threshold;
    $Size = size($x0);

    for($i=0; $i<$Size; $i++){

    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
    if($Sum>$Threshold){ $Result[$i] = 1;
    }else{ $Result[$i] = 0;}
    $Result[$i] = Sigmoid($Sum);
    }
    return $Result;

}


/******************************************************************************
 * @procedure    CPerceptronZ_RunXYZ
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $x0 : float[]
 *   $x1 : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] CPerceptronZ_RunXYZ(float $x0[], float $x1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Size = size($x0);
    float $Sum;
    float $Result[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global float $x0WX[];
    global float $x1WX[];
    global float $Threshold;
    $Size = size($x0);

    for($i=0; $i<$Size; $i++){

    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i])+((-1)*$Threshold);
    $Result[$i] = Sigmoid($Sum);
    }
    return $Result;

}


/******************************************************************************
 * @procedure    CPerceptronZ_RunOUTPUT
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $x0 : float[]
 *   $x1 : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] CPerceptronZ_RunOUTPUT(float $x0[], float $x1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Size = size($x0);
    float $Sum;
    float $Result[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global float $x0WX[];
    global float $x1WX[];
    global float $Threshold;
    $Size = size($x0);

    for($i=0; $i<$Size; $i++){

    $Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
    if($Sum>$Threshold){ $Result[$i] = 1;
    }else{ $Result[$i] = 0;}
    $Result[$i] = Sigmoid($Sum);

    }
    return $Result;

}


/******************************************************************************
 * @procedure    Sum_PerceptronZ_TrainX
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $x0 : float[]
 *   $x1 : float[]
 *
 * @returns      float []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] Sum_PerceptronZ_TrainX(float $x0[], float $x1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Size = size($x0);
    float $ThresholdX = 1.5;
    float $Sum;
    float $Result[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $ThresholdX = 1.5;
    $Size = size($x0);
    for($i=0; $i<$Size; $i++){
    $Sum = ($x0[$i] + $x1[$i] );
    //print ("Sum "+$Sum+"\n");
    if($Sum > $ThresholdX){ $Result[$i] = 1;
    }else{ $Result[$i] = -1;}
    }
    return $Result;

}


/******************************************************************************
 * @procedure    VecArrayToSplitCurve
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $FixVec : vector[]
 *
 * @returns      string []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] VecArrayToSplitCurve(vector $FixVec[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sIZes = `size $FixVec `;
    int $evenOdd = fmod($sIZes, 2);
    int $sIZesHalf = (($sIZes)/2)+1;
    int $NUmers[] = CreateIntIndex($sIZesHalf);
    int $countN = 0;
    float $valuesBi[];
    string $K = "";
    string $curveA = "curve -d 1";
    string $curveB = "curve -d 1";
    string $NewcurvezA = `eval($curveA)`;
    string $NewcurvezB = `eval($curveB)`;
    string $NewcurvezAB[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    // the middle curve will always be even!

    $sIZes = `size $FixVec `;
    $evenOdd = fmod($sIZes, 2);

    $sIZesHalf = (($sIZes)/2)+1;
    $NUmers = CreateIntIndex($sIZesHalf);
    $K = "";
    for ($eachN in $NUmers){
    $K += "\-k"+" "+$eachN+" ";
    }
    $countN = 0;
    $curveA = "curve -d 1";
    for ($eachVeCx in $NUmers){
    $valuesBi  = $FixVec[$countN];
    $curveA += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    $countN++;
    }
    $curveA += " "+ $K;
    $curveB = "curve -d 1";
    $countN--;
    for ($eachVeCx in $NUmers){
    $valuesBi  = $FixVec[$countN];
    $curveB += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
    $countN++;
    }
    $curveB += " "+ $K;
    $NewcurvezA = `eval($curveA)`;
    $NewcurvezB = `eval($curveB)`;
    $NewcurvezAB = {$NewcurvezA , $NewcurvezB};
    return $NewcurvezAB;

}


/******************************************************************************
 * @procedure    LineIntersectPlaneCam
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Vecii : vector[]
 *   $CamP : float[]
 *   $Vec : vector[]
 *
 * @returns      vector []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] LineIntersectPlaneCam(vector $Vecii[], float $CamP[], vector $Vec[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CountVV = 0;
    float $pAv[] = AverageVectorPoint($Vec);
    float $n[] = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    float $FloatDirA[];
    vector $OnPlane[];
    vector $eachVecLine;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $pAv = AverageVectorPoint($Vec);
    $n = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
    $CountVV = 0;
    for($eachVecLine in $Vecii){
    $FloatDirA  = DirectionF($eachVecLine, $CamP);
    $FloatDirNormalA = multiplyFloat(2, $FloatDirA);
    $MultDirA = AddFloats( $FloatDirNormalA, $eachVecLine);

    $DistanceLocA = distance2Pts(  $eachVecLine, $pAv);
    $MultDirCam  = multiplyFloat($DistanceLocA, $n);
    $FloatDirectionCamNormalA  = AddFloats($pAv, $MultDirCam);

    $PointN  = ClosestPoint2Line($n, $pAv, $eachVecLine);
    $FloatDirectionAi  = DirectionF($PointN, $pAv);
    $DistanceLoc = distance2Pts( $PointN, $pAv );

    $MultDirPC1  = multiplyFloat($DistanceLoc, $FloatDirectionAi);
    $FloatDirNormalDist  = AddFloats($eachVecLine, $MultDirPC1);
    $PointNii  = ClosestPoint2Line(DirectionF($PointN, $pAv), $eachVecLine, $MultDirA);
    $FloatDirectionAii  = DirectionF($PointNii, $MultDirA);

    $OnPlane[$CountVV] = FloatToVec (lineIntersection( $FloatDirNormalDist, $FloatDirectionAii, $eachVecLine, $FloatDirA));
    //Loc $OnPlane[$CountVV];
    $CountVV++;
    }
    return $OnPlane;

}


/******************************************************************************
 * @procedure    FindIfCurveIsOrthoEpipol
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $EpipolD : vector[]
 *   $CRV_ENDS : vector[]
 *   $DistEnds : float
 *   $LineMid : vector
 *
 * @returns      vector
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector FindIfCurveIsOrthoEpipol(vector $EpipolD[], vector $CRV_ENDS[], float $DistEnds, vector $LineMid)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $index[] = CreateIntIndex(3);
    int $xyz = $EmptyIndx[0];
    int $isOrthoTrueZi = 0;
    float $Anglei;
    string $stringF[];
    string $EmptyIndx[];
    string $stringIndTr[] = IntArrayToStringArray($index);
    vector $Xdirect;
    vector $Ydirect;
    vector $Zdirect;
    vector $XYZdirect[];
    vector $NewDirectionZ;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;


    // when working with the plane get the vanishing points directions


    if(`size($EpipolD)` == 3){

    //print "EpiPolar";

    $Xdirect = $EpipolD[0];
    $Ydirect = $EpipolD[1];
    $Zdirect = $EpipolD[2];
    }else{
    $Xdirect = << 1,0,0>>;
    $Ydirect = << 0,1,0>>;
    $Zdirect = << 0,0,1>>;
    }

    $XYZdirect[0] = $Xdirect;
    $XYZdirect[1] = $Ydirect;
    $XYZdirect[2] = $Zdirect;


    $LineAMain = PositiveDirectionLine($CRV_ENDS[0], $CRV_ENDS[1]);
    $EulerAngleA  = EulerAngB($Xdirect,$LineAMain);
    $EulerAngleB  = EulerAngB($Ydirect,$LineAMain);
    $EulerAngleC  = EulerAngB($Zdirect,$LineAMain);
    $EulerABCi[0]= $EulerAngleA[3];
    $EulerABCi[1]= $EulerAngleB[3];
    $EulerABCi[2]= $EulerAngleC[3];
    $stringF = FloatArrayToStringArray($EulerABCi);
    clear $EmptyIndx;
    $index = CreateIntIndex(3);
    $stringIndTr = IntArrayToStringArray($index);
    SortFloatArrayAndString( $EulerABCi, $stringIndTr, $EmptyIndx);
    $EmptyIndx = ReverseStringArray($EmptyIndx);
    $xyz = $EmptyIndx[0];
    $AxisOrthoLine = $xyz;
    $Anglei = $EulerABCi[$xyz];
    //print $Anglei;
    $NewDirectionZ = $XYZdirect[$xyz];
    $DistEnds= distance2Pts($CRV_ENDS[0], $CRV_ENDS[1]);
    $LineMid = ($CRV_ENDS[0] + $CRV_ENDS[1])/2.0;
    $AngleEpiPole = $Anglei;

    $isOrthoTrueZi = 0;
    if($Anglei < 8.55){
    $isOrthoTrueZi = 1;
    }
    $IsOrthoLineTrue = $isOrthoTrueZi;
    //print $IsOrthoLineTrue;
    return $NewDirectionZ;

}


/******************************************************************************
 * @procedure    FindDirectionDiff
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Line_Y_zeroMain : vector
 *   $VecCurEndsA : vector
 *   $VecCurEndsB : vector
 *
 * @returns      float
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float FindDirectionDiff(vector $Line_Y_zeroMain, vector $VecCurEndsA, vector $VecCurEndsB)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Addit[];
    float $AdditR;
    vector $Dir_VecA;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Dir_VecA =  DirectionFN($VecCurEndsA,$VecCurEndsB);
    $VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    return $AdditR;

}


/******************************************************************************
 * @procedure    ForceOrtho
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $CurveItemAX : string[]
 *
 * @returns      string []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] ForceOrtho(string $CurveItemAX[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $edgeZsetA;
    int $edgeZsetB;
    int $ReducedIndexA[] = floatArrayCountDuplicates($distancesEachToCurve);
    int $ReducedIndexB[] = floatArrayCountDuplicates($distancesEachToCurveB);
    int $NearestInt[] = SortNumbersIntIndex($distAz);
    int $NearestIntB[] = SortNumbersIntIndex($distBz);
    int $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    int $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];
    int $NearestIndex;
    int $NearestIndexEach;
    int $ReducedIndexXAB[];
    int $AxisOrthoLineA = $AxisOrthoLine;
    int $iVc = 0;
    int $TrackFoundN[];
    int $TrackN[];
    int $TwoPointsi[];
    int $AXIS = $AxisOrthoLineA;
    int $ALLlikeness[];
    int $ALLlikenessForce[];
    int $i = 0;
    int $TriggerPoints;
    int $SortedForce[];
    int $Sorted[] = SortNumbersIntIndex($distTo3DCurveEnd);
    int $ReducedIndex[] = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    int $OntheSameLine = 0;
    int $CountN = 0;
    int $AddInt = $AdditR;
    float $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    float $distancesEachToCurve[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    float $distancesEachToCurveB[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    float $distAz[];
    float $distBz[];
    float $CamPos_A[];
    float $EpipolXx[] = {0.0,$CamPos_A[1],$CamPos_A[2]};
    float $PlaneEpipolXx[] = FloatPointsToCamPlane( $EpipolXx);
    float $EpipolYx[] = {$CamPos_A[0],0.0,$CamPos_A[2]};
    float $PlaneEpipolYx[] = FloatPointsToCamPlane( $EpipolYx);
    float $EpipolZx[] = {$CamPos_A[0],$CamPos_A[1],0.0};
    float $PlaneEpipolZx[] = FloatPointsToCamPlane( $EpipolZx);
    float $MidCurveA[] = MidPoint($CRV_ENDSi[0], $CRV_ENDSi[1]);
    float $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    float $FPointN_LineC[];
    float $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);
    float $XY[];
    float $XYZi[];
    float $XYZadd[];
    float $Xd;
    float $Yd;
    float $Zd;
    float $All_X[];
    float $All_Y[];
    float $All_Z[];
    float $All_ZYX[];
    float $All_ZYXDiff[];
    float $diffXYZ;
    float $Dist_3DNear = (($Dist_3D/3.0)*2.0);
    float $newOrderFloat;
    float $distTo3DCurveEnd[] = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    float $SdistTo3DCurveEnd[];
    float $Additi[];
    float $AdditiB[];
    float $AdditRi;
    float $AdditRiX;
    float $DistSnap;
    float $EulerAngleA[];
    float $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    float $Addit[];
    float $AdditR;
    string $queryLocCurveEnds[] = queryLocOnLivePlaneBLayer();
    string $queryLocCurveEndsOLD[] = $queryLocCurveEnds;
    string $newNames;
    string $NearCurvesEnds[];
    string $BothCurves[];
    string $EmptyStringNewOrderA[];
    string $LocA = $queryLocCurveEnds[$NearestInt[0]];
    string $LocB = $queryLocCurveEnds[$NearestIntB[0]];
    string $LocName;
    string $Loc_AorB = "";
    string $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    string $AllarrayCurvesNear[];
    string $NewFoundLocs[];
    string $arrayCurvesNear[];
    string $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    string $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    string $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    string $CurvesV[];
    string $LocsV[];
    string $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    string $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    vector $Positions[];
    vector $VecCurEnds[] = VecCurveEnds({$TempCrv});
    vector $LocCurveEndsVec[] = PointArray($queryLocCurveEnds);
    vector $EndSnapAndEndProject[];
    vector $endNotNearZ[];
    vector $NearEndZ;
    vector $LocOnPlaneVec[] = PointArray($arrayCurvesNear );
    vector $Loc3D_Vec[] = PointArray($NewFoundLocs );
    vector $ALLLoc3D_VecAB[] = PointArray($AllarrayCurvesNear);
    vector $ReducedVecAB[];
    vector $ALLLoc3D_Vec[];
    vector $MovedEndPointPlane[] = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    vector $CRV_ENDSi[];
    vector $DDirEpipolXYZ[];
    vector $EpipolD[];
    vector $AllEpipolXYZ[];
    vector $XYZdirectL[];
    vector $LineMidi;
    vector $NewDirZi;
    vector $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    vector $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    vector $Dir_CamRay;
    vector $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    vector $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);
    vector $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    vector $One;
    vector $each;
    vector $NearPointsXYZ[];
    vector $ReducedVec[];
    vector $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    vector $VecLineDirMi;
    vector $PointN_LineXYZ;
    vector $SnapN;
    vector $SnapPlaceN;
    vector $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);
    vector $VecLineDirM;
    vector $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    vector $Points3DPair_And_2DPair[];
    vector $Crv_Pts[];
    vector $MirrorAcrossPlaneVecs[] = VecMultMatrixMirror($Crv_Pts);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    // string  $CurveItemAX[] =`ls -sl`;
    global string $StereoCurveZ[];
    global int $addNumbersA;
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;

    //string  $CurveItemAX[] =`ls -sl`;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemAX[0];

    /////////////////////
    $Positions = VecCurveEps($CurveItemAX[0]);
    $TempCrv = VecArrayToCurve($Positions);
    delete $CurveItemAX[0];
    $VecCurEnds = VecCurveEnds({$TempCrv});
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEndsOLD = $queryLocCurveEnds;
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );

    if(`size($queryLocCurveEnds)` >= 2){

    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $distancesEachToCurveB = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);

    $ReducedIndexA = floatArrayCountDuplicates($distancesEachToCurve);
    $ReducedIndexB = floatArrayCountDuplicates($distancesEachToCurveB);
    for($eachInt in $ReducedIndexA){
    $distAz[`size($distAz)`]= $distancesEachToCurve[$eachInt];
    }
    for($eachInt in $ReducedIndexB){
    $distBz[`size($distBz)`]= $distancesEachToCurveB[$eachInt];
    }

    //clear $NearestInt;
    //clear $NearestIntB;
    $NearestInt = SortNumbersIntIndex($distAz);
    $NearestIntB = SortNumbersIntIndex($distBz);

    $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];


    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$ReducedIndexA[$NearestInt[0]]];
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$ReducedIndexB[$NearestIntB[0]]];
    $NearestInt[0] =  $NewIntIndexAA;
    $NearestIntB[0] = $NewIntIndexBB;


    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];
    $LocA = $queryLocCurveEnds[$NearestInt[0]];
    $LocB = $queryLocCurveEnds[$NearestIntB[0]];

    //Loc $LocCurveEndsVec[$NearestInt[0]];
    //Loc $LocCurveEndsVec[$NearestIntB[0]];

    clear $EndSnapAndEndProject;
    $Loc_AorB = "";
    //////////////////////////////////////////
    if($NdistA<$NdistB){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    $Loc_AorB="B";
    }else{
    $Loc_AorB="A";
    $LocName =$LocB;
    $NearestIndex=$NearestIntB[0];
    $NearEndZ = $VecCurEnds[1];
    $endNotNearZ[0] = $VecCurEnds[0];}
    //////////////////////
    // very very rare event
    if($NdistA==$NdistB){
    $Loc_AorB="A";
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    }
    /////////////////////
    if($NearestInt[0]==$NearestIntB[0]){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    }
    //////////////////////////////////////////
    $newNames = stringArrayToString($queryLocCurveEnds, " ");
    $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    $AllarrayCurvesNear = stringToStringArray($newNamesResultAX, " ");
    $NewFoundLocs[0]  = $AllarrayCurvesNear[$NearestIndex];
    $arrayCurvesNear[0] = $queryLocCurveEnds[$NearestIndex];
    /*
    // needed for later for edgeCurves and dynamic local axis plane mirroring
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    */


    $LocOnPlaneVec = PointArray($arrayCurvesNear );
    $Loc3D_Vec = PointArray($NewFoundLocs );
    $ALLLoc3D_VecAB = PointArray($AllarrayCurvesNear);

    if($Loc_AorB == "A"){
    $ReducedIndexXAB = $ReducedIndexA;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexA,$ALLLoc3D_VecAB);
    }
    if($Loc_AorB == "B"){
    $ReducedIndexXAB = $ReducedIndexB;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexB,$ALLLoc3D_VecAB);
    }

    $ALLLoc3D_Vec = $ReducedVecAB;

    $MovedEndPointPlane = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    $CRV_ENDSi[0]= $LocOnPlaneVec[0];
    $CRV_ENDSi[1]= $MovedEndPointPlane[0];
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);
    $MidCurveA = MidPoint($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
    $EpipolD = $DDirEpipolXYZ;
    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);
    $XYZdirectL[0] = << 1,0,0>>;
    $XYZdirectL[1] = << 0,1,0>>;
    $XYZdirectL[2] = << 0,0,1>>;
    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    $AxisOrthoLineA = $AxisOrthoLine;
    // 3d start point $Loc3D_Vec[0]  free Endpoint of plane curve $MovedEndPointPlane[0]
    $Dir_CamRay =  DirectionFN($MovedEndPointPlane[0],$CamPos_A);

    // lineIntersection NOTE arguments are in this order: Point then Line ...Point then Line
    $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);

    $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);

    $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    $XYZi  = $PointN_LineC;
    $XYZadd  = $PointN_LineC;

    $XYZi[0] = $XYZadd[0]+$XYZadd[1];
    $XYZi[1] = $XYZadd[1]+$XYZadd[2];
    $XYZi[2] = $XYZadd[0]+$XYZadd[2];
    $iVc = 0;
    clear $TrackFoundN;
    if($AxisOrthoLineA ==2){
    $TwoPointsi[0] = 0;
    }
    if($AxisOrthoLineA ==1){
    $TwoPointsi[0] = 2;
    }
    if($AxisOrthoLineA ==0){
    $TwoPointsi[0] = 1;
    }
    $AXIS = $AxisOrthoLineA;

    clear $ALLlikeness;
    $i = 0;
    $Dist_3DNear = (($Dist_3D/3.0)*2.0);

    for ($each in $ALLLoc3D_Vec){

    $One = $ALLLoc3D_Vec[$i];
    $XY[0] = $Xx  = $One.x;
    $XY[1] = $Yy  = $One.y;
    $XY[2] = $Zz  = $One.z;

    if( $ReducedIndexXAB[$iVc]!= $NearestIndex ){

    $TriggerPoints=0;
    if( (equivalentTol($XYZadd[0], $Xx,  0.01) )==1){
    $All_X[$i] = $Xx;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[1], $Yy,  0.01) )==1){
    $All_Y[$i] = $Yy;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[2], $Zz,  0.01) )==1){
    $All_Z[$i] = $Zz;
    $TriggerPoints++;
    }

    if( $TriggerPoints<2){
    $diffXYZ = `abs ($XY[$AXIS] - $XYZadd[$AXIS])`;
    if(($diffXYZ< $Dist_3DNear)&&($diffXYZ!=0)){
    $All_ZYX[`size($All_ZYX)`] =$XY[$AXIS];
    $All_ZYXDiff[`size($All_ZYXDiff)`] = $diffXYZ;
    }
    }


    if( $TriggerPoints==2){

    $ALLlikeness[`size($ALLlikeness)`] = $ReducedIndexXAB[$i];
    }
    }
    $i++;
    $iVc++;
    }



    if(`size($All_ZYXDiff)`> 0){
    $SortedForce = SortNumbersIntIndex($All_ZYXDiff);
    $newOrderFloat = $All_ZYX[$SortedForce[0]];

    }


    if(`size($ALLlikeness)`> 0){


    select -cl;
    for($eachIn in $ALLlikeness){
    select -add $AllarrayCurvesNear[$eachIn];
    PAUSE;
    }


    clear $NearPointsXYZ;
    $iVc =0;
    for($eachIn in $ALLlikeness){
    if( $iVc!= $NearestIndex ){
    $NearPointsXYZ[`size($NearPointsXYZ )`] =  $ALLLoc3D_VecAB[$eachIn];
    }
    $iVc++;
    }


    $distTo3DCurveEnd = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    $Sorted = SortNumbersIntIndex($distTo3DCurveEnd);
    $NearPointsXYZ = NewVecOrderWithINTKey($Sorted,$NearPointsXYZ);

    clear $SdistTo3DCurveEnd;
    for($eachIn in $Sorted){
    $SdistTo3DCurveEnd[`size($SdistTo3DCurveEnd)`] = $distTo3DCurveEnd[$eachIn];
    }

    $ReducedIndex = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    $ReducedVec = NewVecOrderWithINTKey($ReducedIndex,$NearPointsXYZ);

    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    // if($AdditRi = 0.0){ then snap to point IF the direction is the same

    $OntheSameLine = 0;
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $OntheSameLine =1;
    }


    $CountN = 0;
    for($eachVec in $ReducedVec){


    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $eachVec);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $PointN_LineXYZ = $eachVec;
    print " on same Line ";
    }else{

    $PointN_LineXYZ  = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $eachVec);

    }

    if( (distance2Pts($PointN_LineXYZ, $PointN_LineC))>0.001){
    $LocsV[`size($LocsV)`] = `Loc $PointN_LineXYZ`;
    $CurvesV[`size($CurvesV)`] = curve2points($eachVec, $PointN_LineXYZ);
    PAUSE;
    }

    if($CountN==0){
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapN = $eachVec;
    $SnapPlaceN = $PointN_LineXYZ;
    }

    if($CountN!=0){
    print  $DistSnap;
    if((distance2Pts($PointN_LineXYZ, $PointN_LineC))<  $DistSnap){
    $SnapN = $eachVec;
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapPlaceN = $PointN_LineXYZ;

    }
    }
    $CountN++;
    }



    $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);

    delete $CurvesV;
    delete $LocsV;

    //$EulerAngleA  = EulerAngB($DirLineSnapXYZ,$LineDirect_3D);
    if(($EulerAngleA[3] >85)&&($EulerAngleA[3]<95)){



    $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    if($Dist_3DSnap<($Dist_3D/2.0)){
    cycleBackgroundColor;
    PAUSE;
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    $AddInt = $AdditR;
    if($AddInt == 0){
    $PointN_LineC = $SnapPlaceN;
    PAUSE; PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }else{

    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $FPointN_LineC =  $PointN_LineC;
    $FPointN_LineC[$AXIS] = $newOrderFloat;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }


    }

    }else{
    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }

    //}

    // $LocsV[`size($LocsV)`] = `Loc $First3dIntersect`;
    // $LocsV[`size($LocsV)`] = `Loc $PointN_LineC`;
    // $CurvesV[`size($CurvesV)`] = curve2points($First3dIntersect, $PointN_LineC);

    $Points3DPair_And_2DPair[0]= $Loc3D_Vec[0];
    $Points3DPair_And_2DPair[1]= $PointN_LineC;
    $Points3DPair_And_2DPair[2]= $LocOnPlaneVec[0];
    $Points3DPair_And_2DPair[3]= $NewPlanePoint;

    delete $TempCrv;
    $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 10 -d 3 -tol 0.05 $CurvesVi;

    $Crv_Pts = VecCurveEps($CurvesVi );
    $MirrorAcrossPlaneVecs = VecMultMatrixMirror($Crv_Pts);
    $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    //delete $CurvesV;
    //delete  $LocsV;
    clear $StereoCurveZ;
    $BothCurves[0] = $CurvesVi;
    $BothCurves[1] = $TheSecondCurve;
    $StereoCurveZ = $BothCurves;
    $addNumbersA =-3;
    ResetTranslation($BothCurves);
    CurveIndexVecTracking($BothCurves);
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $BothCurves;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    clear $StereoCurveZ;
    }
    return $BothCurves;

}


/******************************************************************************
 * @procedure    floatArrayCountDuplicates
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $listX : float[]
 *
 * @returns      int []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] floatArrayCountDuplicates(float $listX[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $index = 0;
    int $X = 0;
    int $Xi = 0;
    int $C = 0;
    int $NumberE[];
    int $NoneDup[];
    float $list[] = $listX;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $list = $listX;
    $index = 0;
    $X = 0;
    $Xi = 0;
    $C = 0;
    $result = $list;
    for ($item in $list) {
    $NumberE[$X] = floatArrayCount($item, $result);
    if (1 == $NumberE[$X]) {
    $NoneDup[`size($NoneDup)`] = $Xi;
    }else{
    if (1 < $NumberE[$X]) {
    floatArrayRemoveAtIndex($X, $result);
    $X--;
    }
    }
    $Xi++;
    $X++;	}
    return $NoneDup;

}


/******************************************************************************
 * @procedure    floatArrayCount
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $item : float
 *   $list : float[]
 *
 * @returns      int
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int floatArrayCount(float $item, float $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = 0;
    float $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = 0;
    for ($listItem in $list) {
    if ($item == $listItem) $result++;	}
    return $result;

}


/******************************************************************************
 * @procedure    floatArrayRemoveAtIndex
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $index : int
 *   $list : float[]
 *
 * @returns      int
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int floatArrayRemoveAtIndex(int $index, float $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $len = size( $list );
    float $result[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $len = size( $list );

    if( $index > $len  || $index < 0 ){
    return( false );
    }

    for( $i = 0; $i < $index; $i++ ){
    $result[$i] = $list[$i];
    }

    for( ; $i < $len - 1; $i++ ){
    $result[$i] = $list[$i + 1];
    }
    $list = $result;
    return( true );

}


/******************************************************************************
 * @procedure    VecMultMatrixMirror
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $pointZ : vector[]
 *
 * @returns      vector []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecMultMatrixMirror(vector $pointZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MatrixB[] = `MatrixToFloat($m2)`;
    vector $FLoatPointA[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    matrix $m2[4][4]= <<	-1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0>>;

    $MatrixB = `MatrixToFloat($m2)`;
    for($eachVec in $pointZ){
    $FLoatPointA[`size($FLoatPointA)`] = FloatToVec(pointMatrixMult( $eachVec, $MatrixB ));
    }
    return $FLoatPointA;

}


/******************************************************************************
 * @procedure    MoveVectors
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $Pos_A : vector
 *   $VecLoc : vector
 *   $Crv_Pts : vector[]
 *
 * @returns      vector []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] MoveVectors(vector $Pos_A, vector $VecLoc, vector $Crv_Pts[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $DistToPoint = distance2Pts($Pos_A, $VecLoc);
    vector $DirLine = DirectionFN( $VecLoc, $Pos_A);
    vector $TranstatedVecs[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $DirLine = DirectionFN( $VecLoc, $Pos_A);
    $DistToPoint = distance2Pts($Pos_A, $VecLoc);

    // DISTANCE TIMES DIRECTION VEC PLUS POINT VECTOR To translate
    clear $TranstatedVecs;
    for($eachVector in $Crv_Pts){
    $TranstatedVecs[`size($TranstatedVecs)`] = ($eachVector+($DistToPoint*$DirLine));
    }
    return $TranstatedVecs;

}


/******************************************************************************
 * @procedure    VanishingCurves
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $CurveItemA : string[]
 *
 * @returns      string []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] VanishingCurves(string $CurveItemA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $indexAx[] = CreateIntIndex(6);
    int $indexAxNew[] = ArrayToIntList( $BestThree);
    int $Count = 0;
    int $color;
    int $colori[];
    int $iiX = 0;
    int $Cindex = 0;
    int $IndexZ = $indexAxNew[$Count];
    int $triggerMiddle = 0;
    int $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
    int $edgeZsetA;
    int $edgeZsetB;
    int $NearestInt[] = SortNumbersIntIndex($distancesEachToCurve);
    int $NearestIntB[] = SortNumbersIntIndex($distancesEachToCurveB);
    int $i;
    int $iv = -1;
    int $CRV_index_number = 0;
    int $CRc = 0;
    int $CRcT = 0;
    int $COuntN = 0;
    int $EDGEpoints[];
    int $pointNearEdgeCurve[];
    int $SnappingVector = 0;
    int $OneIsNotNearThePlane = 0;
    int $Sorted[] = SortNumbersIntIndex($distancesTo3DCurveEnd);
    int $Sortedi[] = SortNumbersIntIndex($distancesTo3DCurveEndi);
    int $iiz = 0;
    float $SnapD = 0.003;
    float $CamPos1[];
    float $Pi = 3.1415926535;
    float $pi = 3.1415926535;
    float $CamerasDirectionVectorNormal[] = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
    float $MultDirForWard[] = multiplyFloat(-1, $CamerasDirectionVector);
    float $MultDirCam[] = multiplyFloat(-3, $CamerasDirectionVector);
    float $FloatDirectionCamNormalA[] = AddFloats($CamPos1, $MultDirCam);
    float $DirectionVectorXn[] = {-2,0,0};
    float $DirectionVectorX[] = {2,0,0};
    float $DirectionVectorY[] = {0,-2,0};
    float $DirectionVectorYn[] = {0,2,0};
    float $DirectionVectorZn[] = {0,0,-2};
    float $DirectionVectorZ[] = {0,0,2};
    float $FloatPointDirectionXn[] = AddFloats($CamPos1, $DirectionVectorXn);
    float $FloatPointDirectionX[] = AddFloats($CamPos1, $DirectionVectorX);
    float $FloatPointDirectionY[] = AddFloats($CamPos1, $DirectionVectorY);
    float $FloatPointDirectionYn[] = AddFloats($CamPos1, $DirectionVectorYn);
    float $FloatPointDirectionZn[] = AddFloats($CamPos1, $DirectionVectorZn);
    float $FloatPointDirectionZ[] = AddFloats($CamPos1, $DirectionVectorZ);
    float $AverageVecXYZsOnP[] = AverageVectorPoint($VecXYZsOnPlane);
    float $AnglesAll[];
    float $EulerAngleA[] = EulerAngB($eachOrthD, $CamerasDirectionVector);
    float $ANgnew[] = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
    float $LengCRV_a = `arclen $CurveItemA`;
    float $DistEndsi;
    float $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
    float $AverageVecCurEndsP[] = AverageVectorPoint($VecCurEnds);
    float $FloatPointDirectionZniY[];
    float $CurveDirectionZiY[];
    float $FloatPointDirectionZniiY[];
    float $CurveDirectionZiiY[];
    float $CurvePsD[] = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
    float $FloatPointDirectVpoint[];
    float $CurveDirectionVpoint[];
    float $locsAi[] = lineIntersection($VecCurEnds[1], $CurveDirectionZiY, $VecCurEnds[0],  $CurveDirectionZiiY);
    float $CamPos_A[];
    float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;
    float $CamNormM[] = ` MirrorFloatXYZ 0 $MultDirCam`;
    float $MidEpipolZx[] = MidPoint($CamPos_M, $CamPos_A);
    float $MidEpipolPosFCam[] = FloatPointsToCamPlane($MidEpipolZx);
    float $Addit[];
    float $AdditR;
    float $IntersectEnds_Ai[];
    float $IntersectEnds_Bi[];
    float $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    float $distancesEachToCurve[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    float $distancesEachToCurveB[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    float $distsA = $NdistA;
    float $distsB = $NdistB;
    float $distToPlaneLoc[];
    float $relativeDistanceA = ($Distance_A+$distToPlaneLoc[0])/2.0;
    float $relativeDistanceB = ($Distance_B+$distToPlaneLoc[1])/2.0;
    float $ThreepointVecs[];
    float $EdgeDist;
    float $smallestDistance;
    float $distancesTo3DCurveEnd[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
    float $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
    float $distancesTo3DCurveEndi[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
    float $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
    float $XX = $VecA.x;
    float $XXX = $VecB.x;
    string $VanishingLOC[];
    string $DirectionsZ[] = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    string $Alll = "";
    string $AllStrings[];
    string $stringFloat[] = FloatArrayToStringArray($EulerAngleA);
    string $EmptyIndxNewOrder[];
    string $stringIndTr[] = IntArrayToStringArray($indexAx);
    string $BestThree[];
    string $CurvesV[];
    string $CirTemp[] = `ls -sl`;
    string $CirTempi[] = `ls -sl`;
    string $newCurveii;
    string $CurveAv[];
    string $newNamesResultA1;
    string $ThreeDCurvesNear[];
    string $queryLocCurveEnds3D[];
    string $CurveItemAa[];
    string $queryLocCurveEnds[] = queryLocOnLivePlaneBLayer();
    string $queryLocCurveEndsOLD[] = queryLocOnLivePlaneBLayer();
    string $newNames;
    string $NearCurvesEnds[];
    string $EmptyStringNewOrderA[];
    string $StringAllNearA[];
    string $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    string $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    string $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    string $arrayCurvesNearA[];
    string $newNamesResultAx = substituteAllString($newNames, "Plane", "");
    string $arrayCurvesNear[];
    string $arrayCurvesNearA1[];
    string $SetCol = `setAttr ($VanishingLOC[size($VanishingLOC)-1]+".overrideColor ") 6 `;
    string $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    string $LocNames[];
    string $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
    vector $Positions[];
    vector $PositionsZ_Ax[];
    vector $ZYplaneMatrix[];
    vector $VecDirection_A_XYZ[];
    vector $VecDirectionXYZ[];
    vector $VecXYZsOnPlane[] = VecPointsToCameraPlane($VecXYZs);
    vector $VecCurEnds[] = VecCurveEnds($CurveItemA);
    vector $VecXYZsOnPlaneiY[];
    vector $VecXYZsOnPlaneiiY[];
    vector $VecXYZsOnPlaneVpoint[];
    vector $PositionsZ_A[];
    vector $PositionsZ_Aii[];
    vector $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
    vector $Dir_VecA;
    vector $VecPtsMirrorEnds_A[];
    vector $VIntersectEnds_A[];
    vector $ObjLoc3DCurv[];
    vector $LocCurveEndsVec[] = PointArray($queryLocCurveEnds);
    vector $LocCurveEndsVec_3D[] = PointArray($arrayCurvesNearA1);
    vector $LoCz_3D[];
    vector $PointN_LineA = ClosestPoint2LineVec($LineDirect_3D, $VecCurEnds[0], $LocCurveEndsVec_3D[0]);
    vector $TXI = << -1.0 , 1.0, 1.0>>;
    vector $NearVecPts[];
    vector $PositionsZ_Aiix[];
    vector $VecTest[];
    vector $LocCurveEndsVec3D[] = PointArray($queryLocCurveEnds3D);
    vector $FistAndSecond[];
    vector $VecA = $FistAndSecond[0];
    vector $VecB = $FistAndSecond[1];
    vector $PositionsZ_Ai[];
    vector $ReversePositionsZ_Ai[] = ReverseVectorArray($PositionsZ_Ai);
    vector $PtsMirrorAi[];
    vector $XIntersect_Ax[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //     string  $CurveItemA[] =`ls -sl`;
    global string $VanishingPointsLinesTempGuides[];
    global int $ifSingleCurve;
    //float $SnapD = 0.013;
    $SnapD = 0.003;
    global vector $TempVectorsCrv[];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemA[0];

    /////////////////////
    if(size($TempVectorsCrv)>0){
    clear $TempVectorsCrv;}
    $Positions = VecCurveCvs($CurveItemA[0]);
    $TempCrv = VecArrayToCurve($Positions);

    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $TempCrv;
    $PositionsZ_Ax = VecCurveEps($TempCrv);

    $ZYplaneMatrix[0] = <<0, 0, 0>>;
    $ZYplaneMatrix[1] = <<0, 1, 0>>;
    $ZYplaneMatrix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;

    $TempVectorsCrv  = LineIntersectPlaneCam( $PositionsZ_Ax, $CamPos1, $ZYplaneMatrix);
    delete $TempCrv;
    ////////////////////

    $Pi = 3.1415926535;
    $pi = 3.1415926535;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $CamerasDirectionVector = $CamerasDirectionVectorNormal;
    $MultDirForWard = multiplyFloat(-1, $CamerasDirectionVector);
    $MultDirCam = multiplyFloat(-3, $CamerasDirectionVector);
    $FloatDirectionCamNormalA = AddFloats($CamPos1, $MultDirCam);
    $DirectionVectorXn = {-2,0,0};
    $DirectionVectorX = {2,0,0};
    $DirectionVectorY = {0,-2,0};
    $DirectionVectorYn = {0,2,0};
    $DirectionVectorZn = {0,0,-2};
    $DirectionVectorZ = {0,0,2};
    $VecDirection_A_XYZ[0] = <<-2,0,0>>;
    $VecDirection_A_XYZ[1] = <<2,0,0>>;
    $VecDirection_A_XYZ[2] = <<0,2,0>>;
    $VecDirection_A_XYZ[3] = <<0,-2,0>>;
    $VecDirection_A_XYZ[4] = <<0,0,-2>>;
    $VecDirection_A_XYZ[5] = <<0,0,2>>;
    $VecDirectionXYZ[0] = <<-1,0,0>>;
    $VecDirectionXYZ[1] = <<1,0,0>>;
    $VecDirectionXYZ[2] = <<0,1,0>>;
    $VecDirectionXYZ[3] = <<0,-1,0>>;
    $VecDirectionXYZ[4] = <<0,0,-1>>;
    $VecDirectionXYZ[5] = <<0,0,1>>;
    $FloatPointDirectionXn = AddFloats($CamPos1, $DirectionVectorXn);
    $FloatPointDirectionX = AddFloats($CamPos1, $DirectionVectorX);
    $FloatPointDirectionY = AddFloats($CamPos1, $DirectionVectorY);
    $FloatPointDirectionYn = AddFloats($CamPos1, $DirectionVectorYn);
    $FloatPointDirectionZn = AddFloats($CamPos1, $DirectionVectorZn);
    $FloatPointDirectionZ = AddFloats($CamPos1, $DirectionVectorZ);
    clear $VecXYZs;
    $VecXYZs[0] = FloatToVec($FloatPointDirectionXn);
    $VecXYZs[1] = FloatToVec($FloatPointDirectionX);
    $VecXYZs[2] = FloatToVec($FloatPointDirectionY);
    $VecXYZs[3] = FloatToVec($FloatPointDirectionYn);
    $VecXYZs[4] = FloatToVec($FloatPointDirectionZn);
    $VecXYZs[5] = FloatToVec($FloatPointDirectionZ);
    $VecXYZsOnPlane = VecPointsToCameraPlane($VecXYZs);
    $AverageVecXYZsOnP = AverageVectorPoint($VecXYZsOnPlane);
    $DirectionsZ = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    $FloatDirxyz[0] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[0]));
    $FloatDirxyz[1] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[1]));
    $FloatDirxyz[2] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[3]));
    $FloatDirxyz[3] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[2]));
    $FloatDirxyz[4] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[4]));
    $FloatDirxyz[5] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[5]));
    $Alll = "";
    clear $AllStrings $AnglesAll ;
    for ($eachOrthD in $VecDirectionXYZ){
    $EulerAngleA = EulerAngB($eachOrthD, $CamerasDirectionVector);
    $AnglesAll[`size($AnglesAll)`]= $EulerAngleA[3];
    $stringFloat = FloatArrayToStringArray($EulerAngleA);
    $Alll  = stringArrayToString($stringFloat, " ");
    $AllStrings[`size($AllStrings)`]= $Alll;
    }
    clear $EmptyIndxNewOrder;
    $indexAx = CreateIntIndex(6);
    $stringIndTr = IntArrayToStringArray($indexAx);
    $ANgnew = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
    $EmptyIndxNewOrder = ReverseStringArray($EmptyIndxNewOrder);
    $BestThree = {$EmptyIndxNewOrder[0], $EmptyIndxNewOrder[1], $EmptyIndxNewOrder[2]};
    $BestThree = ReverseStringArray($BestThree);
    $BestThree = stringArrayRemoveDuplicates ($BestThree);
    $indexAxNew = ArrayToIntList( $BestThree);
    $VecCurEnds = VecCurveEnds($CurveItemA);

    $LengCRV_a = `arclen $CurveItemA`;
    $DistEndsi = distance2Pts($VecCurEnds[0], $VecCurEnds[1]);
    $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);

    $AverageVecCurEndsP = AverageVectorPoint($VecCurEnds);
    $Count = 0;
    $CurvePsD = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
    size($EmptyIndxNewOrder);
    $DirectionsZ = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
    clear $colori;
    $iiX = 0;
    for($eachDirection in $indexAxNew){
    if($eachDirection ==0 || $eachDirection ==1){$colori[`size($colori)`] = 13;}
    if($eachDirection ==3 || $eachDirection ==2){$colori[`size($colori)`] = 14;}
    if($eachDirection ==4 || $eachDirection ==5){$colori[`size($colori)`] = 6;}
    }
    clear $CurvesV;
    $Cindex = 0;
    for ($eachDii in $indexAxNew){
    $IndexZ = $indexAxNew[$Count];

    $FloatPointDirectionZniY  = AddFloats( $VecCurEnds[1], $VecDirection_A_XYZ[$IndexZ]);
    $VecXYZsOnPlaneiY = VecPointsToCameraPlane($FloatPointDirectionZniY);
    $CurveDirectionZiY =  DirectionF($VecCurEnds[1],  $VecXYZsOnPlaneiY[0]);
    $FloatPointDirectionZniiY = AddFloats( $VecCurEnds[0], $VecDirection_A_XYZ[$IndexZ]);
    $VecXYZsOnPlaneiiY = VecPointsToCameraPlane($FloatPointDirectionZniiY);
    $CurveDirectionZiiY =  DirectionF($VecCurEnds[0],  $VecXYZsOnPlaneiiY[0]);
    $locsAi = lineIntersection($VecCurEnds[1], $CurveDirectionZiY, $VecCurEnds[0],  $CurveDirectionZiiY);

    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[0], $locsAi);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], $colori[$Cindex]);
    $CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[1], $locsAi);
    $CirTempi = `ls -sl`;
    SetItemColorString ($CirTempi[0], $colori[$Cindex]);
    editDisplayLayerMembers -noRecurse VanishingPointsLines $CurvesV;
    $Cindex++;
    $Count++;
    }

    $ifSingleCurve = 0;
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $CamPos_M = ` MirrorFloatXYZ 0 $CamPos_A`;
    $CamNormM = ` MirrorFloatXYZ 0 $MultDirCam`;
    $MidEpipolZx = MidPoint($CamPos_M, $CamPos_A);
    $MidEpipolPosFCam = FloatPointsToCamPlane($MidEpipolZx);

    DirectionFN($MidEpipolPosFCam,$VecCurEnds[1]);
    DirectionFN($VecCurEnds[0],$VecCurEnds[1]);
    $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
    $Dir_VecA =   PositiveDirectionLine($VecCurEnds[0],$VecCurEnds[1]);
    $VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];


    $VecPtsMirrorEnds_A= VecPtsToZMirrorPts( $VecCurEnds);
    $triggerMiddle = 0;
    $VIntersectEnds_A[0] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[1], $CamPos_M, $VecPtsMirrorEnds_A[0]));
    $VIntersectEnds_A[1] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[0], $CamPos_M, $VecPtsMirrorEnds_A[1]));
    $queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
    $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
    $IntersectEnds_Ai =  FloatPointsToCamPlane($VIntersectEnds_A[0]);
    $IntersectEnds_Bi = FloatPointsToCamPlane($VIntersectEnds_A[1]);
    $CurveItemAa[0] = $CurveItemA[0];
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEndsOLD = queryLocOnLivePlaneBLayer();
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );



    if(`size($queryLocCurveEnds)` > 2){

    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $NearestInt = SortNumbersIntIndex($distancesEachToCurve);
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[0]];
    $distancesEachToCurveB = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    $NearestIntB = SortNumbersIntIndex($distancesEachToCurveB);
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$NearestIntB[0]];


    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];

    if(($NdistA<$SnapD)||($NdistB<$SnapD)){

    $iv = -1;
    $distsA = $NdistA;
    $distsB = $NdistB;
    for (  $i = 1; $i < 5; $i++) {
    if( $distsA < $distsB){
    $NdistA = $distancesEachToCurve[$NearestInt[$i]];
    if($iv==-1){
    $iv++;
    $StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[0]];}
    if (equivalentTol($NdistA, $distsA, 0.001) == 1){
    $StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[$i]];
    }
    }


    }

    //print $StringAllNearA;
    //print ("NdistA :" +$NearestInt[$i]+" "+$NdistA+"  NdistB :"+$NearestIntB[$i]+" "+$NdistB+"\n");

    $newNames = stringArrayToString( $StringAllNearA, " ");
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    $arrayCurvesNearA = stringToStringArray($newNamesResultC, " ");
    $CRV_index_number = 0;
    $CRc = 0;
    $CRcT = 0;
    for($eachCurve in $arrayCurvesNearA){
    if(`sets -im ZEdgeCurvesSet $eachCurve` ==1){
    $CRV_index_number = $CRc;
    $CRcT++;
    break;
    }
    $CRc++;
    }

    if($CRcT ==1){
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[$CRc]];
    }
    }

    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];

    $newNames = stringArrayToString($EmptyStringNewOrderA, " ");
    $newNamesResultAx = substituteAllString($newNames, "Plane", "");
    $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
    $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
    $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
    $arrayCurvesNear = stringToStringArray($newNamesResultC, " ");
    $NearCurvesEnds[0] = $arrayCurvesNear[0];
    $NearCurvesEnds[1] = $arrayCurvesNear[1];

    $arrayCurvesNearA1 = stringToStringArray($newNamesResultAx, " ");

    $LocCurveEndsVec_3D = PointArray($arrayCurvesNearA1);


    $LoCz_3D = $LocCurveEndsVec_3D;

    /*
    $FloatDirCam[0] = FloatToVec (DirectionF($CamPos1, $VecXYZs[0]));
    $FloatDirCam[1] = FloatToVec (DirectionF($CamPos1, $VecXYZs[1]));
    $PointN_LineA = ClosestPoint2LineVec($LineDirect_3D, $VecCurEnds[0], $LocCurveEndsVec_3D[0]);
    $distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocCurveEndsVec_3D[0]);
    $distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocCurveEndsVec_3D[1]);
    $relativeDistanceA = ($Distance_A+$distToPlaneLoc[0])/2.0;
    $relativeDistanceB = ($Distance_B+$distToPlaneLoc[1])/2.0;
    */



    $TXI = << -1.0 , 1.0, 1.0>>;
    $LoCz_3D[2] = MultVec($LoCz_3D[0],$TXI);
    $LoCz_3D[3] = MultVec($LoCz_3D[1], $TXI);
    for($eachItemVEC in $LoCz_3D){
    $VanishingLOC[`size($VanishingLOC)`] = Loc($eachItemVEC);
    $SetCol = `setAttr ($VanishingLOC[size($VanishingLOC)-1]+".overrideColor ") 6 `;
    setAttr ( $VanishingLOC[size($VanishingLOC)-1]+".scale") 5.0 5.0 5.0;
    }

    appendStringArray($CurvesV, $VanishingLOC, size($VanishingLOC));
    //string $edgeZsetAB[] = `sets -q ZEdgeCurvesSet`;
    //select -r $edgeZsetAB;
    $edgeZsetA = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[0]`;
    $edgeZsetB = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[1]`;
    $COuntN = 0;
    for($eachVec in $LocCurveEndsVec_3D){
    $ThreepointVecs = $eachVec;
    if (equivalentTol($ThreepointVecs[0], 0.00, 0.001) == 1){
    $EDGEpoints[$COuntN]= 1;
    }else{$EDGEpoints[$COuntN]= 0;}
    $COuntN++;
    }
    $edgeZsetA =$EDGEpoints[0];
    $edgeZsetB =$EDGEpoints[1];


    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    if(($NearCurvesEnds[0] == $NearCurvesEnds[1])&&( ($edgeZsetA+$edgeZsetB) ==2)){

    if($NdistA<$NdistB){
    $edgeZsetA =1;
    $edgeZsetB =0;
    }
    if($NdistA>$NdistB){
    $edgeZsetA =0;
    $edgeZsetB =1;
    }
    if($edgeZsetA==0){$NdistA=100;}
    if($edgeZsetB==0){$NdistB=100;}

    }
    }

    if(($NdistA>$SnapD)&&($NdistB>$SnapD)){
    $edgeZsetA =0;
    $edgeZsetB =0;
    }


    }



    if(($edgeZsetA==1)&&($NdistA<$SnapD)){
    $pointNearEdgeCurve[0]= 1;
    }
    if(($edgeZsetA==1)&&($NdistA>$SnapD)){
    $pointNearEdgeCurve[0]= 0;
    }
    if(($edgeZsetA==0)&&($NdistA>$SnapD)){
    $pointNearEdgeCurve[0]= 0;
    }
    if(($edgeZsetA==0)&&($NdistA<$SnapD)){
    $pointNearEdgeCurve[0]= 2;
    }

    if(($edgeZsetB==1)&&($NdistB<$SnapD)){
    $pointNearEdgeCurve[1]= 1;
    }
    if(($edgeZsetB==1)&&($NdistB>$SnapD)){
    $pointNearEdgeCurve[1]= 0;
    }
    if(($edgeZsetB==0)&&($NdistB>$SnapD)){
    $pointNearEdgeCurve[1]= 0;
    }
    if(($edgeZsetB==0)&&($NdistB<$SnapD)){
    $pointNearEdgeCurve[1]= 2;
    }



    /////////////////////////////////////////////

    if($edgeZsetA==1){
    $EdgeDist =$NdistA;
    }else{$EdgeDist=$NdistB;}

    $SnappingVector = 0;
    if($NdistA<$NdistB){
    $SnappingVector=0;
    }else{$SnappingVector=1;}

    if($NdistA>$SnapD){
    $edgeZsetA = 0;
    }
    if($NdistB>$SnapD){
    $edgeZsetB = 0;
    }
    $OneIsNotNearThePlane = 0;
    if(($NdistA>$SnapD)||($NdistB<$SnapD)){
    if(($NdistA<$SnapD)||($NdistB>$SnapD)){
    $OneIsNotNearThePlane =1;
    }
    }

    if(($NdistA<$SnapD)||($NdistB<$SnapD)){
    if(($edgeZsetA==1)||($edgeZsetB==1)){
    $EdgeDist =0.001;
    }
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




    if($pointNearEdgeCurve[0]+$pointNearEdgeCurve[1]== 1){



    $newNamesResultA1 = substituteAllString($newNames, "Plane", "");
    $ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
    $ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
    $A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
    $A= `MakeCleanFloats($A)`;
    $B= `MakeCleanFloats($B)`;
    if(($A[0] ==0)||($B[0] ==0)){

    $triggerMiddle =2;
    $ifSingleCurve=1;
    if($edgeZsetA==1){
    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
    $NearVecPts[1]= $VecCurEnds[1];
    }else{
    $NearVecPts[0]= $VecCurEnds[0];
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
    }
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];

    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    if($EdgeDist<2.5){

    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    $PositionsZ_Aii = $PositionsZ_Ai;
    }
    $PositionsZ_Aiix[0] = <<0, 0, 0>>;
    $PositionsZ_Aiix[1] = <<0, 1, 0>>;
    $PositionsZ_Aiix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    if($EdgeDist<2.5){
    $VecTest  = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
    }else{$VecTest  = LineIntersectPlaneCam($PositionsZ_A, $CamPos1, $PositionsZ_Aiix);
    }
    $CurveAv[0] = VecArrayToCurveB($VecTest);
    }

    }



    if( $pointNearEdgeCurve[1]==1){

    $newNamesResultA1 = substituteAllString($newNames, "Plane", "");
    $ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
    $ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
    $A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
    $A = MakeCleanFloatsZ($A);
    $B = MakeCleanFloatsZ($B);

    if(($A[0] ==0)&&($B[0] ==0)){

    // NOTE these two
    $triggerMiddle =2;
    $ifSingleCurve=1;

    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    delete $CurveItemA;
    $CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);

    $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    clear $PositionsZ_A;
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    if($DiffMathA >95.0){
    $PositionsZ_Aii[0] = $NearVecPts[0];
    $PositionsZ_Aii[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
    $PositionsZ_Aii[2]= $NearVecPts[1];

    } else{
    $PositionsZ_Aii = $PositionsZ_Ai;}
    $PositionsZ_Aiix[0] = <<0, 0, 0>>;
    $PositionsZ_Aiix[1] = <<0, 1, 0>>;
    $PositionsZ_Aiix[2] = <<0, 0, 1>>;
    $CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
    $VecTest = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
    if($DiffMathA >95.0){	$CurveAv[0] = VecArrayToCurve($VecTest);}else{
    $CurveAv[0] = VecArrayToCurve($VecTest);}
    }
    }


    if($triggerMiddle==0){

    if($GetSizeOfCRV_ends>0){
    $LocCurveEndsVec3D = PointArray($queryLocCurveEnds3D);
    $distancesTo3DCurveEnd = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
    $Sorted = SortNumbersIntIndex($distancesTo3DCurveEnd);
    $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
    $distancesTo3DCurveEndi = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
    $Sortedi = SortNumbersIntIndex($distancesTo3DCurveEndi);
    $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
    $FistAndSecond[0]=$LocCurveEndsVec3D[$Sorted[0]];
    $FistAndSecond[1]=$LocCurveEndsVec3D[$Sortedi[0]];
    $LocNames[0]=$queryLocCurveEnds3D[$Sorted[0]];
    $LocNames[1]=$queryLocCurveEnds3D[$Sortedi[0]];
    $LocNames[2]=$queryLocCurveEnds3D[$Sorted[1]];
    $LocNames[3]=$queryLocCurveEnds3D[$Sortedi[1]];
    $VecA = $FistAndSecond[0];
    $VecB = $FistAndSecond[1];
    $XX = $VecA.x;
    $XXX = $VecB.x;
    if( ($XX*-1)==$XXX){
    if($NptsDist<2.5){

    $NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($VecA));
    $NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($VecB));
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    delete $CurveItemA;
    $CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);
    $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    clear $PositionsZ_A;

    if($DiffMathA >95.0){

    $PositionsZ_Ai[0] = $NearVecPts[0];
    $PositionsZ_Ai[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
    $PositionsZ_Ai[2]= $NearVecPts[1];

    }else{
    $PositionsZ_A = VecCurveEps($CurveItemA[0]);
    $PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
    }
    $ReversePositionsZ_Ai = ReverseVectorArray($PositionsZ_Ai);
    clear $PtsMirrorAi;
    $PtsMirrorAi= VecPtsToZMirrorPts($ReversePositionsZ_Ai);
    $iiz = 0;
    clear $XIntersect_Ax;
    for ($eachVecx in  $ReversePositionsZ_Ai){
    $XIntersect_Ax[`size($XIntersect_Ax)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_Ai[$iiz], $CamPos_M, $PtsMirrorAi[$iiz]));
    $iiz++;
    }
    if($DiffMathA >95.0){
    $XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
    }

    $CurveAv =  VecArrayToSplitCurve($XIntersect_Ax);
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
    $evalSmoothi += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmoothi);
    $ifSingleCurve=1;
    }
    }
    }
    }

    $VanishingPointsLinesTempGuides = $CurvesV;
    if(( $ifSingleCurve == 1)&&($triggerMiddle ==0)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[1];
    sets -include ZEdgeCurvesSet $CurveAv;
    }else{
    if(( $ifSingleCurve == 1)&&($triggerMiddle ==1)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    }
    }

    if( ($ifSingleCurve == 1)&&($triggerMiddle ==2)){
    delete $CurveItemA[0];
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv;
    $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
    $evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
    eval($evalSmooth);
    sets -include ZEdgeCurvesSet $CurveAv;
    ResetTranslation($CurveAv);
    CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
    }
    return $CurvesV;

}


/******************************************************************************
 * @procedure    VecPointsToCameraPlane
 * @category     sketch-modeling
 * @layer        projection (Camera->World)
 *
 * @param
 *   $V : vector[]
 *
 * @returns      vector []
 * @source       MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecPointsToCameraPlane(vector $V[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $C1;
    vector $p = `xform -q -ws -t "LiveSurfaceB"`;
    vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
    vector $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+($D1*$F3);
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    return $O;

}

