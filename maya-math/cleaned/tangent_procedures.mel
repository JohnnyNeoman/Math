/******************************************************************************
 * TANGENT PROCEDURES - CLEANED MEL PROCEDURES
 *
 * Category:    tangent-procedures
 * Layer:       utility (General)
 * Description: General Maya utilities and helpers
 * Procedures:  61
 *
 * All variable declarations moved to procedure start.
 * Generated by cleanup_mel_v2.py
 ******************************************************************************/


/******************************************************************************
 * @procedure    TANGENTSS
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 *
 * @returns      vector []
 * @source       TANGENTSSTracking (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] TANGENTSS()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $ArrayIndexTracki[] = CreateIntIndex(`size($circles)`);
    int $CirA;
    int $CirB;
    int $indexNumberZ[];
    float $normalAxis[] = CircNormal($circles[0]);
    float $ObjsCircles[] = CirclesRadiiPos($circles, $PosABs);
    float $R1 = $ObjsCircles[$CirA];
    float $R2 = $ObjsCircles[$CirB];
    float $FloatDirXn[] = DirectionF($PosABs[$CirA], $PosABs[$CirB]);
    float $Rn1 = (1.0/(`sqrt $R1`)) + (1.0/(`sqrt $R2` ));
    float $Rn = 1.0/$Rn1;
    float $R = `pow $Rn 2`;
    float $xc = `sqrt (4*$R1*$R)`;
    float $yc = `sqrt (4*$R2*$R)`;
    float $CurveL = $xc+$yc;
    float $pi = 3.1415926535;
    float $r1 = $R1;
    float $r2 = $R2;
    float $P = distance2Pts($PosABs[$CirA], $PosABs[$CirB]);
    float $DiCircleInBetween = `abs ($P -($R1 + $R2))`;
    float $RadiCircleInBetween = $DiCircleInBetween/2;
    float $DisCircBetweenFromR1 = $R1+$RadiCircleInBetween;
    float $MultDirMLine[] = multiplyFloat($R2-1.0,  $FloatDirXn);
    float $AddMultMLine[] = AddFloats($PosABs[$CirA], $MultDirMLine);
    float $MultDirMLinei[] = multiplyFloat($RadiCircleInBetween,  $FloatDirXn);
    float $AddMultMLinei[] = AddFloats($AddMultMLine, $MultDirMLinei);
    float $MultDirM[] = multiplyFloat($DisCircBetweenFromR1,  $FloatDirXn);
    float $AddMultM[] = AddFloats($PosABs[$CirA], $MultDirM);
    float $ts = acos ( (`abs ($r1 - $r2)`) /$P);
    float $tsD = (`rad_to_deg $ts`);
    float $tsDA = (`rad_to_deg $ts`)*1;
    float $tsDB = (`rad_to_deg $ts`)*-1;
    float $tsDAR = ( $ts)*1;
    float $tsDBR = ( $ts)*-1;
    float $rotatsA[] = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $r1, $normalAxis, $tsDAR);
    float $rotatsB[] = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $r1, $normalAxis, $tsDBR);
    float $rotatsC[] = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $r2, $normalAxis, $tsDBR);
    float $rotatsD[] = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $r2, $normalAxis, $tsDAR);
    float $rotatsAi[] = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $r1-1.0, $normalAxis, $tsDAR);
    float $rotatsBi[] = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $r1-1.0, $normalAxis, $tsDBR);
    float $rotatsCi[] = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $r2-1.0, $normalAxis, $tsDBR);
    float $rotatsDi[] = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $r2-1.0, $normalAxis, $tsDAR);
    float $mid1[] = MidPoint($rotatsA, $rotatsD);
    float $mid2[] = MidPoint($rotatsB, $rotatsC);
    float $midAD3[] = MidPoint($rotatsA, $mid1);
    float $midAD4[] = MidPoint($rotatsD, $mid1);
    float $midBC3[] = MidPoint($rotatsB, $mid2);
    float $midBC4[] = MidPoint($rotatsC, $mid2);
    float $FloatDirCentMidZ[] = DirectionF($PosABs[$CirA], $midAD3);
    float $MultDirMidzCirc[] = multiplyFloat($r1-1.0, $FloatDirCentMidZ);
    float $FAddMULTDcirc[] = AddFloats($MultDirMidzCirc, $PosABs[$CirA]);
    float $FloatDirCentMidZi[] = DirectionF($PosABs[$CirA], $midBC3);
    float $FloatDirCentMidZii[] = DirectionF($PosABs[$CirB], $midAD4);
    float $FloatDirCentMidZiii[] = DirectionF($PosABs[$CirB], $midBC4);
    string $circles[] = `ls -sl`;
    string $circlesShape[];
    string $stringIndexTracki[] = IntArrayToStringArray($ArrayIndexTracki);
    string $itemA[] = $circles;
    string $itemBackUp[] = $itemA;
    string $TwoItemsZ[];
    string $itemEach[] = { $itemA[0] };
    string $circlesM = Circles_Direction($AddMultM,$normalAxis, $RadiCircleInBetween);
    string $CirTemp[] = `ls -sl`;
    vector $TangZ[];
    vector $TangMidZ[];
    vector $directionABs[];
    vector $PosABs[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $circles = `ls -sl`;
    clear $circlesShape;
    for ($eachCir in $circles){
    $circlesShape[`size($circlesShape)`]  = stringArrayToString( `listRelatives $eachCir` , " ");
    }
    print $circlesShape;
    $normalAxis = CircNormal($circles[0]);

    ResetTransEachSL;
    clear $PosABs;
    $ObjsCircles = CirclesRadiiPos($circles, $PosABs);


    $ArrayIndexTracki = CreateIntIndex(`size($circles)`);
    $stringIndexTracki = IntArrayToStringArray($ArrayIndexTracki);



    $itemA = $circles;
    $itemBackUp = $itemA;
    for($each in $itemBackUp){
    //isolate one from list remove from list
    //itemA will be reduced to zero

    $itemEach = { $itemA[0] };
    $diff = stringArrayRemoveExact($itemEach, $itemA);
    for($eachOther in $diff){
    playButtonStepForward;
    // $eachOther $itemEach;


    $TwoItemsZ  = {$eachOther, $itemEach[0]};
    $indexNumberZ= stringArrayGmatchArrayIndex($TwoItemsZ, $circles);

    $CirA = $indexNumberZ[0];
    $CirB = $indexNumberZ[1];

    $R1 = $ObjsCircles[$CirA];
    $R2 = $ObjsCircles[$CirB];
    if($R1<$R2){$CirA = $indexNumberZ[1]; $CirB = $indexNumberZ[0];
    $R1=$ObjsCircles[$CirA];
    $R2=$ObjsCircles[$CirB];}

    ////////
    playButtonStepForward;
    select -r $circles[$CirA]; select -r $circles[$CirB];
    ///////

    $FloatDirXn = DirectionF($PosABs[$CirA], $PosABs[$CirB]);
    $R1 = $ObjsCircles[$CirA];
    $R2 = $ObjsCircles[$CirB];
    //RotMultLenToDirAddToPoint(float $PosA[], float $PosB[], float $Length, float $DirNormAx[], float $Radian)
    $R1 = $R1+1.0;
    $R2 =$R2+1.0;
    $Rn1 = (1.0/(`sqrt $R1`)) + (1.0/(`sqrt $R2` ));
    $Rn = 1.0/$Rn1;
    $R = `pow $Rn 2`;
    $xc = `sqrt (4*$R1*$R)`;
    $yc = `sqrt (4*$R2*$R)`;
    $CurveL = $xc+$yc;
    $pi = 3.1415926535;

    $r1 = $R1;
    $r2 = $R2;

    // P is the distance between 2 circles
    $P = distance2Pts($PosABs[$CirA], $PosABs[$CirB]);
    $FloatDirXn = DirectionF($PosABs[$CirA], $PosABs[$CirB]);



    $DiCircleInBetween = `abs ($P -($R1 + $R2))`;
    $RadiCircleInBetween = $DiCircleInBetween/2;
    $DisCircBetweenFromR1 = $R1+$RadiCircleInBetween ;
    //mult Direction Circ1 to Circ 2 by distance DisCircBetweenFromR1
    //add to Pos Circ R1

    $MultDirMLine = multiplyFloat($R2-1.0,  $FloatDirXn);
    $AddMultMLine = AddFloats($PosABs[$CirA], $MultDirMLine);
    $MultDirMLinei = multiplyFloat($RadiCircleInBetween,  $FloatDirXn);
    $AddMultMLinei = AddFloats($AddMultMLine, $MultDirMLinei);

    curve2points($AddMultMLine, $AddMultMLinei);

    $MultDirM = multiplyFloat($DisCircBetweenFromR1,  $FloatDirXn);
    $AddMultM = AddFloats($PosABs[$CirA], $MultDirM);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultM);
    $circlesM = Circles_Direction($AddMultM,$normalAxis, $RadiCircleInBetween);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);

    $ts = acos ( (`abs ($r1 - $r2)`) /$P);
    $tsD = (`rad_to_deg $ts`);
    $tsDA = (`rad_to_deg $ts`)*1;
    $tsDB = (`rad_to_deg $ts`)*-1;
    $tsDAR = ( $ts)*1;
    $tsDBR = ( $ts)*-1;

    //The first argument represents a point, the second an axis and the third an angle in radians
    //the normal $directionABs[2]
    //RotMultLenToDirAddToPoint(float $PosA[], float $PosB[], float $Length, float $DirNormAx[], float $Radian)


    $rotatsA = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $r1, $normalAxis, $tsDAR);
    $rotatsB = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $r1, $normalAxis, $tsDBR);
    $rotatsC = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $r2, $normalAxis, $tsDBR);
    $rotatsD = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $r2, $normalAxis, $tsDAR);


    $rotatsAi = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $r1-1.0, $normalAxis, $tsDAR);
    $rotatsBi = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $r1-1.0, $normalAxis, $tsDBR);
    $rotatsCi = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $r2-1.0, $normalAxis, $tsDBR);
    $rotatsDi = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $r2-1.0, $normalAxis, $tsDAR);


    spaceLocator -p 0 0 0;
    MoveObject2($rotatsA);
    spaceLocator -p 0 0 0;
    MoveObject2($rotatsB);
    spaceLocator -p 0 0 0;
    MoveObject2($rotatsC);
    spaceLocator -p 0 0 0;
    MoveObject2($rotatsD);

    spaceLocator -p 0 0 0;
    MoveObject2($rotatsAi);
    spaceLocator -p 0 0 0;
    MoveObject2($rotatsBi);
    spaceLocator -p 0 0 0;
    MoveObject2($rotatsCi);
    spaceLocator -p 0 0 0;
    MoveObject2($rotatsDi);

    curve2points($rotatsA, $rotatsAi);
    curve2points($rotatsB, $rotatsBi);
    curve2points($rotatsC, $rotatsCi);
    curve2points($rotatsD, $rotatsDi);



    $mid1 = MidPoint($rotatsA, $rotatsD);
    $mid2 = MidPoint($rotatsB, $rotatsC);

    Loc $mid1;
    Loc $mid2;
    curve2points($AddMultM, $mid1);
    curve2points($AddMultM, $mid2);

    $midAD3 = MidPoint($rotatsA, $mid1);
    $midAD4 = MidPoint($rotatsD, $mid1);

    $midBC3 = MidPoint($rotatsB, $mid2);
    $midBC4 = MidPoint($rotatsC, $mid2);

    $FloatDirCentMidZ = DirectionF($PosABs[$CirA], $midAD3);

    $MultDirMidzCirc = multiplyFloat($r1-1.0, $FloatDirCentMidZ);
    $FAddMULTDcirc = AddFloats($MultDirMidzCirc, $PosABs[$CirA]);
    Loc $FAddMULTDcirc;
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);

    curve2points($FAddMULTDcirc, $midAD3);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);


    $FloatDirCentMidZi = DirectionF($PosABs[$CirA], $midBC3);

    $MultDirMidzCirc = multiplyFloat($r1-1.0, $FloatDirCentMidZi);
    $FAddMULTDcirc = AddFloats($MultDirMidzCirc, $PosABs[$CirA]);
    Loc $FAddMULTDcirc;
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);

    curve2points($FAddMULTDcirc, $midBC3);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);


    $FloatDirCentMidZii = DirectionF($PosABs[$CirB], $midAD4);

    $MultDirMidzCirc = multiplyFloat($r2-1.0, $FloatDirCentMidZii);
    $FAddMULTDcirc = AddFloats($MultDirMidzCirc, $PosABs[$CirB]);
    Loc $FAddMULTDcirc;
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);

    curve2points($FAddMULTDcirc, $midAD4);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);

    $FloatDirCentMidZiii = DirectionF($PosABs[$CirB], $midBC4);

    $MultDirMidzCirc = multiplyFloat($r2-1.0, $FloatDirCentMidZiii);
    $FAddMULTDcirc = AddFloats($MultDirMidzCirc, $PosABs[$CirB]);
    Loc $FAddMULTDcirc;
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);

    curve2points($FAddMULTDcirc, $midBC4);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);

    //ClosestPoint2Line($FloatDirCentMidZiii, $PosABs[$CirB], $PosABs[$CirA]);
    //ClosestPoint2Line($FloatDirCentMidZii, $PosABs[$CirB], $PosABs[$CirA]);

    Loc $midAD3;
    Loc $midAD4;

    Loc $midBC3;
    Loc $midBC4;

    $TangMidZ[`size($TangMidZ)`]= FloatToVec($mid1);
    $TangMidZ[`size($TangMidZ)`]= FloatToVec($mid2);

    $TangZ[`size($TangZ)`]= FloatToVec($rotatsA);
    $TangZ[`size($TangZ)`]= FloatToVec($rotatsB);
    $TangZ[`size($TangZ)`]= FloatToVec($rotatsC);
    $TangZ[`size($TangZ)`]= FloatToVec($rotatsD);


    curve2points($rotatsA, $rotatsD);
    curve2points($rotatsB,$rotatsC);

    playButtonStepForward;
    }
    $itemA = $diff;

    }
    return $TangZ;

}


/******************************************************************************
 * @procedure    AnglesofTriangle
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $SideA : float
 *   $SideB : float
 *   $SideC : float
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] AnglesofTriangle(float $SideA, float $SideB, float $SideC)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Pi = 3.1415926535;
    float $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
    float $AngleNPi = ($Arcangle*180)/$Pi;
    float $AngleNA = $AngleNPi;
    float $ArcangleB = acos((((`pow $SideA 2.000`) + (`pow $SideC 2.000`) - (`pow $SideB 2.000`) )/(2.000*$SideA*$SideC)));
    float $AngleNPiB = ($ArcangleB*180)/$Pi;
    float $AngleNB = $AngleNPiB;
    float $ArcangleC = acos((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
    float $AngleNPiC = ($ArcangleC*180)/$Pi;
    float $AngleNC = $AngleNPiC;
    float $Angle_a = $AngleNA;
    float $Angle_b = $AngleNB;
    float $Angle_c = $AngleNC;
    float $Add = $Angle_a + $Angle_b + $Angle_c;
    float $Angle_ABC[] = {$Angle_a, $Angle_b, $Angle_c};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $Pi = 3.1415926535;
    $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
    $AngleNPi = ($Arcangle*180)/$Pi;
    $AngleNA = $AngleNPi;

    $ArcangleB = acos((((`pow $SideA 2.000`) + (`pow $SideC 2.000`) - (`pow $SideB 2.000`) )/(2.000*$SideA*$SideC)));
    $AngleNPiB = ($ArcangleB*180)/$Pi;
    $AngleNB = $AngleNPiB;

    $ArcangleC = acos((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
    $AngleNPiC = ($ArcangleC*180)/$Pi;
    $AngleNC = $AngleNPiC;

    // acos is the Arc Cos which is sometime called cos pow-1 which does not mean cos raised to the Neg One power but
    // is the opposite angle called acos if you move cos to the other side of the equal sign when solving an equation.
    //simple ass hell.. but wont find these answers any place but from me since reality is fucked. Luck has it the internet exists.
    //and knowledge WANTS to grow.
    // acos atan asin same thing

    $Angle_a = $AngleNA;
    $Angle_b = $AngleNB;
    $Angle_c = $AngleNC;
    $Add = $Angle_a + $Angle_b + $Angle_c;
    $Angle_ABC = {$Angle_a, $Angle_b, $Angle_c} ;
    return $Angle_ABC;

}


/******************************************************************************
 * @procedure    MultLenToDirAddToPoint
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Length : float
 *   $Dir : float[]
 *   $Pos : float[]
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] MultLenToDirAddToPoint(float $Length, float $Dir[], float $Pos[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MultLengthDir[] = multiplyFloat($Length, $Dir);
    float $AddMultDirPos[] = AddFloats($Pos, $MultLengthDir);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MultLengthDir = multiplyFloat($Length, $Dir);
    $AddMultDirPos = AddFloats($Pos, $MultLengthDir);
    return $AddMultDirPos;

}


/******************************************************************************
 * @procedure    RotMultLenToDirAddToPoint
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $PosA : float[]
 *   $PosB : float[]
 *   $PosOrNegOne : int
 *   $Length : float
 *   $DirNormAx : float[]
 *   $Radian : float
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] RotMultLenToDirAddToPoint(float $PosA[], float $PosB[], int $PosOrNegOne, float $Length, float $DirNormAx[], float $Radian)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $rotatsA[] = `rot $DirecOfPointAB $DirNorm $Radian`;
    float $MultLengthDir[] = multiplyFloat($Length, $rotatsA);
    float $AddMultDirPos[] = AddFloats($PosA, $MultLengthDir);
    vector $DirecOfPointAB = FloatToVec ( DirectionF($PosA, $PosB));
    vector $DirNorm = FloatToVec ($DirNormAx);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $DirecOfPointAB = FloatToVec ( DirectionF($PosA, $PosB));
    $DirecOfPointAB = FloatToVec ( multiplyFloat($PosOrNegOne, $DirecOfPointAB));
    $DirNorm = FloatToVec ($DirNormAx);
    $rotatsA = `rot $DirecOfPointAB $DirNorm $Radian`;
    $MultLengthDir = multiplyFloat($Length, $rotatsA);
    $AddMultDirPos = AddFloats($PosA, $MultLengthDir);
    return $AddMultDirPos;

}


/******************************************************************************
 * @procedure    RotDirToPoint
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $PosA : float[]
 *   $PosB : float[]
 *   $PosOrNegOne : int
 *   $DirNormAx : float[]
 *   $Radian : float
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] RotDirToPoint(float $PosA[], float $PosB[], int $PosOrNegOne, float $DirNormAx[], float $Radian)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Length = distance2Pts ($PosA, $PosB);
    float $rotatsA[] = `rot $DirecOfPointAB $DirNorm $Radian`;
    float $MultLengthDir[] = multiplyFloat($Length, $rotatsA);
    float $AddMultDirPos[] = AddFloats($PosA, $MultLengthDir);
    vector $DirecOfPointAB = FloatToVec ( DirectionF($PosA, $PosB));
    vector $DirNorm = FloatToVec ($DirNormAx);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $DirecOfPointAB = FloatToVec ( DirectionF($PosA, $PosB));
    $Length = distance2Pts ($PosA, $PosB);
    $DirecOfPointAB = FloatToVec ( multiplyFloat($PosOrNegOne, $DirecOfPointAB));
    $DirNorm = FloatToVec ($DirNormAx);
    $rotatsA = `rot $DirecOfPointAB $DirNorm $Radian`;
    $MultLengthDir = multiplyFloat($Length, $rotatsA);
    $AddMultDirPos = AddFloats($PosA, $MultLengthDir);
    return $AddMultDirPos;

}


/******************************************************************************
 * @procedure    ClosestPoint2Line
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $DirectionLineF : float[]
 *   $PointOnLine : float[]
 *   $PointN : float[]
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] ClosestPoint2Line(float $DirectionLineF[], float $PointOnLine[], float $PointN[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MultDirOne[] = multiplyFloat(1.0, $DirectionLineF);
    float $AddMultF[] = AddFloats($PointOnLine, $MultDirOne);
    float $FDirNorA[] = Normal3Points($PointOnLine, $AddMultF, $PointN);
    float $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
    float $MultDirMx[] = multiplyFloat($DistToLineSTart,  $FDirNorA);
    float $AddMultMiiFx[] = AddFloats($PointOnLine, $MultDirMx);
    float $FDirNorB[] = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);
    float $MultDirMxz[] = multiplyFloat($DistToLineSTart,  $FDirNorB);
    float $AddMultMiiFxz[] = AddFloats($PointOnLine, $MultDirMxz);
    float $locsA[] = lineIntersection($PointN, $FDirNorB, $PointOnLine, $DirectionLineF);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MultDirOne = multiplyFloat(1.0, $DirectionLineF);
    $AddMultF = AddFloats($PointOnLine, $MultDirOne);
    $FDirNorA = Normal3Points($PointOnLine, $AddMultF, $PointN);
    $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);

    $MultDirMx = multiplyFloat($DistToLineSTart,  $FDirNorA);
    $AddMultMiiFx = AddFloats($PointOnLine, $MultDirMx);
    $FDirNorB = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);

    $MultDirMxz = multiplyFloat($DistToLineSTart,  $FDirNorB);
    $AddMultMiiFxz = AddFloats($PointOnLine, $MultDirMxz);
    $locsA = lineIntersection($PointN, $FDirNorB, $PointOnLine, $DirectionLineF);
    Loc $locsA;
    curve2points($PointN,$locsA);
    return $locsA;

}


/******************************************************************************
 * @procedure    ArcLengthArray
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Objs : string[]
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] ArcLengthArray(string $Objs[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $ArcLengths[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($each in $Objs){
    $ArcLengths[`size($ArcLengths)`]= `arclen $each`;
    }
    return $ArcLengths;

}


/******************************************************************************
 * @procedure    TwoVecsOrFloats
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $p1p2 : float[]
 *   $p1p3 : float[]
 *
 * @returns      vector
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector TwoVecsOrFloats(float $p1p2[], float $p1p3[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $Ui = FloatToVec($p1p2);
    vector $Vi = FloatToVec($p1p3);
    vector $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Ui = FloatToVec($p1p2);
    $Vi = FloatToVec($p1p3);
    $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;
    return $VEcLine;

}


/******************************************************************************
 * @procedure    Vector3pt
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $p1 : float[]
 *   $p2 : float[]
 *   $p3 : float[]
 *
 * @returns      vector []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] Vector3pt(float $p1[], float $p2[], float $p3[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $Combined[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    // Get the vector p1-p2, p1-p3
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $Combined[0] = << $p1p2[0], $p1p2[1], $p1p2[2]>>;
    $Combined[1] = <<$p1p3[0], $p1p3[1], $p1p3[2]>>;
    return $Combined;

}


/******************************************************************************
 * @procedure    EulerAng
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $pointB1 : float[]
 *   $pointB2 : float[]
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] EulerAng(float $pointB1[], float $pointB2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $EulerAngleA[] = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $EulerAngleA = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
    return $EulerAngleA;

}


/******************************************************************************
 * @procedure    GetNearestINDEX
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Nn : int
 *   $index : string[]
 *   $pointA1 : float[]
 *   $objectListV : vector[]
 *
 * @returns      string []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] GetNearestINDEX(int $Nn, string $index[], float $pointA1[], vector $objectListV[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iX = 0;
    float $distanceA[];
    float $NewfloatsX[];
    float $NewfloatsXi[] = ReverseFloatArray($NewfloatsX);
    string $EmptyStringX[];
    string $returnZi[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ($eachVecs in $objectListV){
    $distanceA[`size($distanceA)`] = distance2Pts( $pointA1 , $eachVecs);
    }
    clear $EmptyStringX;
    $NewfloatsX = SortFloatArrayAndString($distanceA, $index, $EmptyStringX);
    $EmptyStringX = ReverseStringArray($EmptyStringX);
    $NewfloatsXi = ReverseFloatArray($NewfloatsX);
    $iX = 0;
    while ($Nn > $iX){
    $returnZi[`size($returnZi)`] = $EmptyStringX[$iX];
    $iX++;
    }
    return $returnZi;

}


/******************************************************************************
 * @procedure    GetNearest
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Nn : int
 *   $OneObject : string
 *   $diff : string[]
 *
 * @returns      string []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] GetNearest(int $Nn, string $OneObject, string $diff[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Indx = 0;
    int $iX = 0;
    float $pointA1[];
    float $distanceA[];
    float $pointA2[];
    float $NewfloatsX[];
    float $NewfloatsXi[] = ReverseFloatArray($NewfloatsX);
    string $objectList[] = $diff;
    string $EmptyStringX[];
    string $returnZi[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $objectList = $diff;
    $pointA1 = `xform -query -worldSpace - translation ($OneObject)`;
    clear  $distanceA;
    $Indx = 0;
    for ($eachZx in $objectList){
    if (catch($pointA2 = `xform -q -ws -t $objectList[$Indx]`)){
    $pointA2 = `pointPosition -w $objectList[$Indx]`;
    }

    $Indx++;
    $dAx = $pointA1[0] - $pointA2[0];
    $dAy = $pointA1[1] - $pointA2[1];
    $dAz = $pointA1[2] - $pointA2[2];
    $distanceA[`size($distanceA)`] = `sqrt( ($dAx * $dAx) + ($dAy * $dAy)  + ($dAz * $dAz) )`;
    }


    clear $EmptyStringX;
    $NewfloatsX = SortFloatArrayAndString($distanceA, $objectList, $EmptyStringX);
    $EmptyStringX = ReverseStringArray($EmptyStringX);
    $NewfloatsXi = ReverseFloatArray($NewfloatsX);

    $iX = 0;
    while ($Nn > $iX){
    $returnZi[`size($returnZi)`] = $EmptyStringX[$iX];
    $iX++;
    }

    return $returnZi;

}


/******************************************************************************
 * @procedure    Partition
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $a : float[]
 *   $Index : int[]
 *   $p : int
 *   $r : int
 *
 * @returns      int
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int Partition(float $a[], int $Index[], int $p, int $r)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $xIndex = $Index[$r];
    int $j = $p - 1;
    int $i;
    float $x = $a[$r];
    float $temp = $a[$j];
    float $tempIndex = $Index[$j];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $x = $a[$r];
    $xIndex = $Index[$r];
    $j = $p - 1;
    for (  $i = $p; $i < $r; $i++) {
    if ($x <= $a[$i]) {
    $j = $j + 1;

    $temp = $a[$j];
    $tempIndex = $Index[$j];

    $a[$j] = $a[$i];
    $Index[$j] = $Index[$i];

    $a[$i] = $temp;
    $Index[$i] = $tempIndex;
    }
    }
    $a[$r] = $a[$j + 1];
    $Index[$r] = $Index[$j + 1];

    $a[$j + 1] = $x;
    $Index[$j + 1] = $xIndex;

    return ($j + 1);

}


/******************************************************************************
 * @procedure    SortFloatArrayAndString
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $allFloatToSort : float[]
 *   $ObjsCurve : string[]
 *   $EmptyStringNewOrder : string[]
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] SortFloatArrayAndString(float $allFloatToSort[], string $ObjsCurve[], string $EmptyStringNewOrder[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sIze = `size($allFloatToSort)`-1;
    int $IndexTrack[] = CreateIntIndex(`size($aF)`);
    float $Floatlist[] = $allFloatToSort;
    float $aF[] = $allFloatToSort;
    string $stringIndexTrack[] = IntArrayToStringArray($IndexTrack);
    string $newOrderArray[] = NewArrayOrderWithIndexKey($stringIndexTrack, $ObjsCurve);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Floatlist = $allFloatToSort;
    $sIze = `size($allFloatToSort)`-1;

    //float $aF[] = { 1.0, 9.2, 0.445, 5.3, 0.6, 7.0, -0.8, -2.22, 4.133, 3.002};
    $aF = $allFloatToSort;
    $IndexTrack = CreateIntIndex(`size($aF)`);
    quickSort($aF, $IndexTrack, 0, $sIze);
    $stringIndexTrack = IntArrayToStringArray($IndexTrack);
    $newOrderArray = NewArrayOrderWithIndexKey($stringIndexTrack, $ObjsCurve);
    $EmptyStringNewOrder = $newOrderArray;
    return $aF;


}


/******************************************************************************
 * @procedure    SortFloatArrayAndStringN
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $n : int
 *   $allFloatToSort : float[]
 *   $ObjsCurve : string[]
 *   $EmptyStringNewOrder : string[]
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] SortFloatArrayAndStringN(int $n, float $allFloatToSort[], string $ObjsCurve[], string $EmptyStringNewOrder[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sIze = `size($allFloatToSort)`;
    int $IndexTrack[] = CreateIntIndex(`size($aF)`);
    float $Floatlist[] = $allFloatToSort;
    float $aF[] = $allFloatToSort;
    string $stringIndexTrack[] = IntArrayToStringArray($IndexTrack);
    string $newOrderArray[] = NewArrayOrderWithIndexKey($stringIndexTrack, $ObjsCurve);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Floatlist = $allFloatToSort;
    $sIze = `size($allFloatToSort)`;
    if (($n==$sIze)||($n>$sIze)){
    $n = $sIze-1;
    }
    //float $aF[] = { 1.0, 9.2, 0.445, 5.3, 0.6, 7.0, -0.8, -2.22, 4.133, 3.002};
    $aF = $allFloatToSort;
    $IndexTrack = CreateIntIndex(`size($aF)`);
    quickSort($aF, $IndexTrack, 0, $n);
    $stringIndexTrack = IntArrayToStringArray($IndexTrack);
    $newOrderArray = NewArrayOrderWithIndexKey($stringIndexTrack, $ObjsCurve);
    $EmptyStringNewOrder = $newOrderArray;
    return $aF;


}


/******************************************************************************
 * @procedure    greatestCommonDivisor
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $a : float
 *   $b : float
 *
 * @returns      float
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float greatestCommonDivisor(float $a, float $b)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $dividerA;
    float $dividendA;
    float $gdivisorA;
    float $divider;
    float $dividend;
    float $gdivisor = 1.0+ $divider+ $dividend;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if ($a < $b) {
    $divider = $a;
    $dividend = $b;
    $dividerA = $divider;
    $dividendA = $dividend;
    $gdivisor = 1.0+ $divider+ $dividend;
    $gdivisorA=$gdivisor;
    }
    else {
    $divider = $b;
    $dividend = $a;
    $dividerA = $divider;
    $dividendA = $dividend;
    $gdivisor = 1.0+ $divider+ $dividend;
    $gdivisorA=$gdivisor;
    }

    if ($dividendA % $dividerA == 0) {
    return $dividerA;
    }
    else {
    greatestCommonDivisor($dividerA, $dividendA % $dividerA);
    }
    return $gdivisorA;

}


/******************************************************************************
 * @procedure    EulerAngB
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $pointB1 : float[]
 *   $pointB2 : float[]
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] EulerAngB(float $pointB1[], float $pointB2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $EulerAngleA[] = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $EulerAngleA = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
    return $EulerAngleA;

}


/******************************************************************************
 * @procedure    MostRightClockWise
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $ObjectList : string[]
 *   $Vecs : vector[]
 *   $Two : int[]
 *
 * @returns      string []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] MostRightClockWise(string $ObjectList[], vector $Vecs[], int $Two[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $TwoNew[];
    float $point1[] = FloatToVec($Vecs[0]);
    float $point2[] = FloatToVec($Vecs[1]);
    float $point3[] = FloatToVec($Vecs[2]);
    float $normalA[] = `unit ($normalV[0])`;
    float $normalB[] = `unit ($normalV[1])`;
    float $normalAAdd = $normalA[0] + $normalA[1];
    float $normalAAdd2 = $normalB[0] + $normalB[1];
    string $ThreePoints[] = { "0", "1", "2"};
    string $ReturnObj[];
    vector $U1 = TwoVecsOrFloats($point2, $point1);
    vector $V1 = TwoVecsOrFloats($point3, $point1);
    vector $U2 = TwoVecsOrFloats($point3, $point1);
    vector $V2 = TwoVecsOrFloats($point2, $point1);
    vector $U3 = TwoVecsOrFloats($point1, $point3);
    vector $V3 = TwoVecsOrFloats($point2, $point3);
    vector $normalV[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $ThreePoints = { "0", "1", "2"};

    // Get the vector p1-p2, p3-p4
    // Get the vector  p3-p4
    //THREE POINTS get angel that is point 2 & 3 to point 1 (the V shape joining at first point)

    ///////////////////////////////////////////////////////////
    $point1 = FloatToVec($Vecs[0]);
    $point2 = FloatToVec($Vecs[1]);
    $point3 = FloatToVec($Vecs[2]);

    $U1 = TwoVecsOrFloats($point2, $point1);
    $V1 = TwoVecsOrFloats($point3, $point1);
    $U2 = TwoVecsOrFloats($point3, $point1);
    $V2 = TwoVecsOrFloats($point2, $point1);

    //vector $U2 = TwoVecsOrFloats($point3, $point2);
    //vector $V2 = TwoVecsOrFloats($point1, $point2);

    $U3 = TwoVecsOrFloats($point1, $point3);
    $V3 = TwoVecsOrFloats($point2, $point3);


    clear $normalV;
    $normalV[0] = FloatToVec( crossProduct( $U1, $V1, 0, 1 ) );
    $normalV[1] = FloatToVec( crossProduct( $U2, $V2, 0, 1 ) );

    //float $normal[] = `unit ($normalV[0])`;

    $normalA = `unit ($normalV[0])`;
    $normalB = `unit ($normalV[1])`;

    $normalAAdd = $normalA[0] + $normalA[1];
    $normalAAdd2 = $normalB[0] + $normalB[1];
    if( $normalAAdd< $normalAAdd2){
    //select -r $ObjectList[2];
    $TwoNew ={$Two[1], $Two[0]};
    $ReturnObj ={ $ObjectList[1], $ObjectList[0]};

    }else{
    //select -r $ObjectList[1];
    $TwoNew ={$Two[0], $Two[1]};
    $ReturnObj ={ $ObjectList[0], $ObjectList[1]};
    }

    $Two = $TwoNew;

    return $ReturnObj;

}


/******************************************************************************
 * @procedure    Circles_Direction
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Point : float[]
 *   $FloatDir : float[]
 *   $FloatNum : float
 *
 * @returns      string
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string Circles_Direction(float $Point[], float $FloatDir[], float $FloatNum)
{

    -nr $FloatDir[0] $FloatDir[1] $FloatDir[2]
    -sw 360
    -r $FloatNum
    -d 3 -ut 0 -tol 0.001 -s 8 -ch 1`;

    //setRotationAxisFloat(string $objectitem1[], float $rotationsA[])
    return $circleItem[0];

}


/******************************************************************************
 * @procedure    lineIntersectionF
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $PosA : float[]
 *   $PosB : float[]
 *   $PosC : float[]
 *   $PosD : float[]
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] lineIntersectionF(float $PosA[], float $PosB[], float $PosC[], float $PosD[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $DirAB[] = DirectionF ($PosA, $PosB);
    float $DirCD[] = DirectionF ($PosC, $PosD);
    float $locsA[] = lineIntersection($PosA, $DirAB, $PosC, $DirCD);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $DirAB = DirectionF ($PosA, $PosB);
    $DirCD = DirectionF ($PosC, $PosD);
    $locsA = lineIntersection($PosA, $DirAB, $PosC, $DirCD);
    return $locsA;

}


/******************************************************************************
 * @procedure    CirclesRadius
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $selectedObjects : string[]
 *
 * @returns      float
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float CirclesRadius(string $selectedObjects[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $FloatPointA[] = `pointPosition -w  $CurveSelectionA[0]`;
    float $worldPosA[];
    float $CircleRadiusA = getDistance($FloatPointA, $worldPosA);
    string $CurveSelectionA[] = `ls -fl ($selectedObjects[0]+".ep[0]")`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveSelectionA = `ls -fl ($selectedObjects[0]+".ep[0]")`;
    $FloatPointA = `pointPosition -w  $CurveSelectionA[0]`;
    $worldPosA = `xform -q -ws -a -rp $selectedObjects[0]`;
    $CircleRadiusA = getDistance($FloatPointA, $worldPosA);
    return $CircleRadiusA;

}


/******************************************************************************
 * @procedure    CirclesRadiusDirection
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $directionAB : vector[]
 *   $PosAB : vector[]
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] CirclesRadiusDirection(vector $directionAB[], vector $PosAB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $FloatPointa2[] = `pointPosition -w  $CurveSelection_a2[0]`;
    float $FloatPointb2[] = `pointPosition -w  $CurveSelection_b2[0]`;
    float $FloatPointA[] = `pointPosition -w  $CurveSelectionA[0]`;
    float $FloatPointB[] = `pointPosition -w  $CurveSelectionB[0]`;
    float $worldPosA[];
    float $CircleRadiusA = getDistance($FloatPointA, $worldPosA);
    float $worldPosB[];
    float $CirclesDistance = getDistance ($worldPosA, $worldPosB);
    float $FloatDirNormalCurveA[] = Normal3Points($worldPosA,$FloatPointa2,$FloatPointA);
    float $CircleRadiusB = getDistance ($FloatPointB, $worldPosB);
    float $RadiusAB[] = {$CircleRadiusA, $CircleRadiusB,$CirclesDistance};
    string $selectedObjects[];
    string $CurveSelectionA[] = `ls -fl ($selectedObjects[0]+".ep[0]")`;
    string $CurveSelection_a2[] = `ls -fl ($selectedObjects[0]+".ep[3]")`;
    string $CurveSelectionB[] = `ls -fl ($selectedObjects[1]+".ep[0]")`;
    string $CurveSelection_b2[] = `ls -fl ($selectedObjects[1]+".ep[3]")`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    clear $selectedObjects;
    $selectedObjects = `ls -sl`;
    $CurveSelectionA = `ls -fl ($selectedObjects[0]+".ep[0]")`;
    $CurveSelection_a2 = `ls -fl ($selectedObjects[0]+".ep[3]")`;

    $CurveSelectionB = `ls -fl ($selectedObjects[1]+".ep[0]")`;
    $CurveSelection_b2 = `ls -fl ($selectedObjects[1]+".ep[3]")`;

    $FloatPointa2 = `pointPosition -w  $CurveSelection_a2[0]`;

    $FloatPointb2 = `pointPosition -w  $CurveSelection_b2[0]`;
    $FloatPointA = `pointPosition -w  $CurveSelectionA[0]`;
    $FloatPointB = `pointPosition -w  $CurveSelectionB[0]`;

    $worldPosA = `xform -q -ws -a -rp $selectedObjects[0]`;
    $CircleRadiusA = getDistance($FloatPointA, $worldPosA);
    $worldPosB= `xform -q -ws -a -rp $selectedObjects[1]`;

    $directionAB[0] = FloatToVec (DirectionF($worldPosA,$worldPosB));
    $directionAB[1] = FloatToVec (DirectionF($worldPosB,$worldPosA));
    $PosAB[0] = FloatToVec ($worldPosA);
    $PosAB[1] = FloatToVec ($worldPosB);
    $CirclesDistance = getDistance ($worldPosA, $worldPosB);

    $FloatDirNormalCurveA = Normal3Points($worldPosA,$FloatPointa2,$FloatPointA);
    $directionAB[2] = FloatToVec ($FloatDirNormalCurveA);

    $CircleRadiusB = getDistance ($FloatPointB, $worldPosB);
    $RadiusAB = {$CircleRadiusA, $CircleRadiusB,$CirclesDistance};
    return $RadiusAB;

}


/******************************************************************************
 * @procedure    PointToCircleTangents
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $CircleRadiusA : float
 *   $worldPosA : float[]
 *   $worldPosB : float[]
 *   $FloatDirNormal : float[]
 *
 * @returns      vector []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] PointToCircleTangents(float $CircleRadiusA, float $worldPosA[], float $worldPosB[], float $FloatDirNormal[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $R1 = $CircleRadiusA;
    float $P = distance2Pts ($worldPosA, $worldPosB);
    float $r1 = $R1;
    float $r1Z = $R1*2;
    float $Pi = 3.1415926535;
    float $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1Z 2.000`) - (`pow $P 2.000`) )/(2.000*$P*$r1Z)));
    float $AngleNPi = ($Arcangle*180)/$Pi;
    float $AngleN = $AngleNPi;
    float $MultDirPC1[] = multiplyFloat($r1, $directionABs[0]);
    float $AddMultDirPCA1[] = AddFloats($worldPosA, $MultDirPC1);
    float $tsDAR = ( $AngleN)*-1;
    float $tsDBR = ( $AngleN)*1;
    float $rotatsA[] = `rot $directionABs[0] $FloatDirNormal $tsDAR`;
    float $rotatsB[] = `rot $directionABs[0] $FloatDirNormal $tsDBR`;
    float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
    float $AddMultDirPCA2[] = AddFloats($worldPosA, $MultDirPC2);
    vector $directionABs[];
    vector $pointsT[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $R1 = $CircleRadiusA;

    $directionABs[0] = FloatToVec (DirectionF($worldPosA,$worldPosB));
    $directionABs[1] = FloatToVec (DirectionF($worldPosB,$worldPosA));

    // P is the distance between 2 circles
    $P = distance2Pts ($worldPosA, $worldPosB);
    $r1 = $R1;
    $r1Z = $R1*2;
    //HightsOfIsoscelesTriangle($P, $r1Z, $P);
    $Pi = 3.1415926535;
    $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1Z 2.000`) - (`pow $P 2.000`) )/(2.000*$P*$r1Z)));
    $AngleNPi = ($Arcangle*180)/$Pi;
    $AngleN = $AngleNPi;
    //float $ts = atand( (`abs ($r1 - $r2)`) /$P);
    $MultDirPC1 = multiplyFloat($r1, $directionABs[0]);
    $AddMultDirPCA1 = AddFloats($worldPosA, $MultDirPC1);

    $AngleN = $Arcangle;
    $tsDAR = ( $AngleN)*-1;
    $tsDBR = ( $AngleN)*1;
    //The first argument represents a point, the second an axis and the third an angle in radians
    $rotatsA = `rot $directionABs[0] $FloatDirNormal $tsDAR`;
    $MultDirPC1 = multiplyFloat($r1, $rotatsA);
    $AddMultDirPCA1 = AddFloats($worldPosA, $MultDirPC1);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA1);
    $rotatsB = `rot $directionABs[0] $FloatDirNormal $tsDBR`;
    $MultDirPC2 = multiplyFloat($r1, $rotatsB);
    $AddMultDirPCA2 = AddFloats($worldPosA, $MultDirPC2);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA2);

    $pointsT[0] = FloatToVec ($AddMultDirPCA1);
    $pointsT[1] = FloatToVec ($AddMultDirPCA2);
    return $pointsT;

}


/******************************************************************************
 * @procedure    PointArrayT
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $ObjectList : string[]
 *
 * @returns      vector[]
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] PointArrayT(string $ObjectList[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $XiV = 0;
    float $pointAZ1[];
    vector $VecArray[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $XiV = 0;
    for ($each in $ObjectList){
    if (catch($pointAZ1 = `xform -q -ws -t ($each)`)){
    $pointAZ1 = `pointPosition -w ($each)`;
    }
    $VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
    $XiV++;
    }
    return $VecArray;

}


/******************************************************************************
 * @procedure    TangentPointCirVectors
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $ObjsCirclesRad : float[]
 *   $PosABs : vector[]
 *   $directionABs2 : vector[]
 *
 * @returns      vector []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] TangentPointCirVectors(float $ObjsCirclesRad[], vector $PosABs[], vector $directionABs2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $R1 = $ObjsCirclesRad[0];
    float $R2 = $ObjsCirclesRad[1];
    float $P = distance2Pts ($PosABs[0], $PosABs[1]);
    float $r1 = $R1;
    float $r2 = $R2;
    float $Pi = 3.1415926535;
    float $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1)));
    float $AngleNPi = ($Arcangle*180)/$Pi;
    float $AngleN = $AngleNPi;
    float $Lengths[] = HightsOfIsoscelesTriangle($P, $r1, $r2);
    float $MultDirPCR1[] = multiplyFloat($r1, $directionABs[0]);
    float $AddMultDirPCR1[] = AddFloats($PosABs[0], $MultDirPCR1);
    float $MultDirPCR2[] = multiplyFloat($r2, $directionABs[1]);
    float $AddMultDirPCR2[] = AddFloats($PosABs[1], $MultDirPCR2);
    float $MidPointsA[];
    float $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
    float $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
    float $tsDAR = ( $AngleN)*-1;
    float $tsDBR = ( $AngleN)*1;
    float $rotatsA[] = `rot $directionABs[0] $directionABs2[0] $tsDAR`;
    float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
    float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
    float $rotatsB[] = `rot $directionABs[0] $directionABs2[0] $tsDBR`;
    float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
    float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
    vector $CircIntersectABs[];
    vector $directionABs[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $R1 = $ObjsCirclesRad[0];
    $R2 = $ObjsCirclesRad[1];
    // P is the distance between 2 circles
    $P = distance2Pts ($PosABs[0], $PosABs[1]);
    $directionABs[0] = FloatToVec (DirectionF($PosABs[0],$PosABs[1]));
    $directionABs[1] = FloatToVec (DirectionF($PosABs[1],$PosABs[0]));
    $r1 = $R1;
    $r2 = $R2;
    $Pi = 3.1415926535;
    $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1)));
    $AngleNPi = ($Arcangle*180)/$Pi;
    $AngleN = $AngleNPi;
    $Lengths = HightsOfIsoscelesTriangle($P, $r1, $r2);
    $MultDirPCR1 = multiplyFloat($r1, $directionABs[0]);
    $AddMultDirPCR1 = AddFloats($PosABs[0], $MultDirPCR1);
    $MultDirPCR2 = multiplyFloat($r2, $directionABs[1]);
    $AddMultDirPCR2 = AddFloats($PosABs[1], $MultDirPCR2);
    $MidPointsA = MidPoint($AddMultDirPCR1, $AddMultDirPCR2);
    $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
    $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
    ////////////////////////////////////////////////
    ////////////////////////////////////////////////
    $AngleN = $Arcangle;
    $tsDAR = ( $AngleN)*-1;
    $tsDBR = ( $AngleN)*1;
    //The first argument represents a point, the second an axis and the third an angle in radians
    //the normal $directionABs[2]
    $rotatsA = `rot $directionABs[0] $directionABs2[0] $tsDAR`;
    $MultDirPC1 = multiplyFloat($r1, $rotatsA);
    $AddMultDirPCA1 = AddFloats($PosABs[0], $MultDirPC1);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA1);
    $rotatsB = `rot $directionABs[0] $directionABs2[0] $tsDBR`;
    $MultDirPC2 = multiplyFloat($r1, $rotatsB);
    $AddMultDirPCA2 = AddFloats($PosABs[0], $MultDirPC2);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA2);

    $CircIntersectABs[0] = << $AddMultDirPCA1[0], $AddMultDirPCA1[1], $AddMultDirPCA1[2] >>;
    $CircIntersectABs[1] = << $AddMultDirPCA2[0], $AddMultDirPCA2[1], $AddMultDirPCA2[2] >>;
    return $CircIntersectABs;

}


/******************************************************************************
 * @procedure    TangentPointCirclesVec2
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 *
 * @returns      vector []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] TangentPointCirclesVec2()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
    float $R1 = $ObjsCircles[0];
    float $R2 = $ObjsCircles[1];
    float $P = distance2Pts ($PosABs[0], $PosABs[1]);
    float $r1 = $R1;
    float $r2 = $R2;
    float $Pi = 3.1415926535;
    float $Arcangle = acos ((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1)));
    float $AngleNPi = ($Arcangle*180)/$Pi;
    float $AngleN = $AngleNPi;
    float $Lengths[] = HightsOfIsoscelesTriangle($P, $r1, $r2);
    float $MultDirPCR1[] = multiplyFloat($r1, $directionABs[0]);
    float $AddMultDirPCR1[] = AddFloats($PosABs[0], $MultDirPCR1);
    float $MultDirPCR2[] = multiplyFloat($r2, $directionABs[1]);
    float $AddMultDirPCR2[] = AddFloats($PosABs[1], $MultDirPCR2);
    float $MidPointsA[];
    float $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
    float $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
    float $tsDAR = ( $AngleN)*-1;
    float $tsDBR = ( $AngleN)*1;
    float $rotatsA[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
    float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
    float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
    float $rotatsB[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
    float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
    float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
    vector $CircIntersectABs[];
    vector $directionABs[];
    vector $PosABs[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    ResetTransEachSL;
    $ObjsCircles = CirclesRadiusDirection($directionABs, $PosABs);
    $R1 = $ObjsCircles[0];
    $R2 = $ObjsCircles[1];
    // P is the distance between 2 circles

    $P = distance2Pts ($PosABs[0], $PosABs[1]);
    $r1 = $R1;
    $r2 = $R2;
    $Pi = 3.1415926535;
    $Arcangle = acos ((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1))) ;
    $AngleNPi = ($Arcangle*180)/$Pi;
    $AngleN = $AngleNPi;
    $Lengths = HightsOfIsoscelesTriangle($P, $r1, $r2);
    $MultDirPCR1 = multiplyFloat($r1, $directionABs[0]);
    $AddMultDirPCR1 = AddFloats($PosABs[0], $MultDirPCR1);
    $MultDirPCR2 = multiplyFloat($r2, $directionABs[1]);
    $AddMultDirPCR2 = AddFloats($PosABs[1], $MultDirPCR2);
    $MidPointsA = MidPoint($AddMultDirPCR1, $AddMultDirPCR2);
    $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
    $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
    ////////////////////////////////////////////////
    ////////////////////////////////////////////////
    $AngleN = $Arcangle;
    $tsDAR = ( $AngleN)*-1;
    $tsDBR = ( $AngleN)*1;
    //The first argument represents a point, the second an axis and the third an angle in radians
    //the normal $directionABs[2]
    $rotatsA = `rot $directionABs[0] $directionABs[2] $tsDAR`;
    $MultDirPC1 = multiplyFloat($r1, $rotatsA);
    $AddMultDirPCA1 = AddFloats($PosABs[0], $MultDirPC1);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA1);
    $rotatsB = `rot $directionABs[0] $directionABs[2] $tsDBR`;
    $MultDirPC2 = multiplyFloat($r1, $rotatsB);
    $AddMultDirPCA2 = AddFloats($PosABs[0], $MultDirPC2);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultDirPCA2);

    $CircIntersectABs[0] = << $AddMultDirPCA1[0], $AddMultDirPCA1[1], $AddMultDirPCA1[2] >>;
    $CircIntersectABs[1] = << $AddMultDirPCA2[0], $AddMultDirPCA2[1], $AddMultDirPCA2[2] >>;
    return $CircIntersectABs;

}


/******************************************************************************
 * @procedure    EulerAngleofCurve
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 *
 * @returns      float[]
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] EulerAngleofCurve()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    int $Z = FindclosetTOcurveENDz($pointB1,  $pointB2, $vector_SubUnitMagVec2);
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $pointCVAB_MidPoint[] = MidPointBetween ($EACHCVposHigher, $EACHCVposLower);
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $curveArclenZ = `arclen $CurveItem`;
    float $DivideIt = $curveArclenZ / 2.0;
    float $DivideIt2 = $DivideIt * -1;
    float $pointB1[] = {0.0 , 0.0 , $DivideIt};
    float $pointB2[] = {0.0 , 0.0 , $DivideIt2};
    float $EulerAngleA[] = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2   $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2 [1] $vector_SubUnitMagVec2[2]`;
    float $EulerAngleB[] = `angleBetween -euler -v1  $pointB2[0] $pointB2[1] $pointB2[2] -v2  $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1 [1] $vector_SubUnitMagVec1[2]`;
    string $CurveItem[];
    string $CurveSelection[];
    vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher,  $pointCVAB_MidPoint);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposLower,  $pointCVAB_MidPoint);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveItem = `ls -sl`;
    $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA   )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    if ( $MagVectorZ1 > $MagVectorZ2 ){
    print (" posA is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposAZ;
    $EACHCVposLower = $EACHCVposBZ;
    }
    if ( $MagVectorZ1 < $MagVectorZ2  ){
    print (" posB is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    }
    $pointCVAB_MidPoint = MidPointBetween ($EACHCVposHigher, $EACHCVposLower);
    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher,  $pointCVAB_MidPoint);
    $vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]);
    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposLower,  $pointCVAB_MidPoint);
    $vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]);
    ///////////////////////////////////////////////// ////
    $curveArclenZ = `arclen $CurveItem`;
    $DivideIt = $curveArclenZ / 2.0;
    $DivideIt2 = $DivideIt * -1;
    $pointB1 = {0.0 , 0.0 , $DivideIt} ;
    $pointB2 = {0.0 , 0.0 , $DivideIt2} ;
    /// NOTE curve ENds will not allways Line up and  may be inverted
    //let $F1 be the first CV $F2 the last .. $F3  third point
    $Z = FindclosetTOcurveENDz($pointB1,  $pointB2, $vector_SubUnitMagVec2);
    if ($Z == 1){ print "new floats"; $pointB1 =  $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
    $EulerAngleA = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2   $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2 [1] $vector_SubUnitMagVec2[2]`;
    $EulerAngleB = `angleBetween -euler -v1  $pointB2[0] $pointB2[1] $pointB2[2] -v2  $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1 [1] $vector_SubUnitMagVec1[2]`;

    return $EulerAngleA;

}


/******************************************************************************
 * @procedure    CirclesRadiiPos
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $CirObjects : string[]
 *   $PosAB : vector[]
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] CirclesRadiiPos(string $CirObjects[], vector $PosAB[])
{



    for ($each in $CirObjects){
    $PointA= `ls -fl ($each+".ep[0]")`;
    $PointB = `ls -fl ($each+".ep[3]")`;
    $FloatPointA = `pointPosition -w  $PointA`;
    $FloatPointB = `pointPosition -w  $PointB`;
    $worldPosA = `xform -q -ws -a -rp $each`;
    $CircleRadii[`size($CircleRadii)`] = distance2Pts ($FloatPointA,$worldPosA) ;
    $PosAB[`size($PosAB)`]= FloatToVec ($worldPosA);
    }
    return $CircleRadii;

}


/******************************************************************************
 * @procedure    CircNormal
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $eachCirV : string
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] CircNormal(string $eachCirV)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $FloatDirNormalCurveA[] = Normal3Points($worldPosA, $FloatPointA, $FloatPointB);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $PointA = `ls -fl ($eachCirV+".ep[0]")`;
    $PointB = `ls -fl ($eachCirV+".ep[3]")`;
    $FloatPointA = `pointPosition -w  $PointA `;
    $FloatPointB = `pointPosition -w  $PointB`;
    $worldPosA = `xform -q -ws -a -rp $eachCirV`;
    $FloatDirNormalCurveA = Normal3Points($worldPosA, $FloatPointA, $FloatPointB);
    return $FloatDirNormalCurveA;

}


/******************************************************************************
 * @procedure    DoubleDeterminant
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $mat : matrix[]
 *
 * @returns      float
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float DoubleDeterminant(matrix $mat[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $valueA;
    float $valueB;
    float $valueC;
    float $valueD;
    float $valueE;
    float $valueF;
    float $valueG;
    float $value = $valueA - $valueB - $valueC - $valueD - $valueE - $valueF - $valueG;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $valueA = $mat[0][3] * $mat[1][2] * $mat[2][1] * $mat[3][0]-$mat[0][2] * $mat[1][3] * $mat[2][1] * $mat[3][0];
    $valueB = $mat[0][3] * $mat[1][1] * $mat[2][2] * $mat[3][0]+$mat[0][1] * $mat[1][3] * $mat[2][2] * $mat[3][0]+ $mat[0][2] * $mat[1][1] * $mat[2][3] * $mat[3][0]-$mat[0][1] * $mat[1][2] * $mat[2][3] * $mat[3][0];
    $valueC = $mat[0][3] * $mat[1][2] * $mat[2][0] * $mat[3][1]+$mat[0][2] * $mat[1][3] * $mat[2][0] * $mat[3][1]+ $mat[0][3] * $mat[1][0] * $mat[2][2] * $mat[3][1]-$mat[0][0] * $mat[1][3] * $mat[2][2] * $mat[3][1];
    $valueD = $mat[0][2] * $mat[1][0] * $mat[2][3] * $mat[3][1]+$mat[0][0] * $mat[1][2] * $mat[2][3] * $mat[3][1]+ $mat[0][3] * $mat[1][1] * $mat[2][0] * $mat[3][2]-$mat[0][1] * $mat[1][3] * $mat[2][0] * $mat[3][2];
    $valueE = $mat[0][3] * $mat[1][0] * $mat[2][1] * $mat[3][2]+$mat[0][0] * $mat[1][3] * $mat[2][1] * $mat[3][2]+ $mat[0][1] * $mat[1][0] * $mat[2][3] * $mat[3][2]-$mat[0][0] * $mat[1][1] * $mat[2][3] * $mat[3][2];
    $valueF = $mat[0][2] * $mat[1][1] * $mat[2][0] * $mat[3][3]+$mat[0][1] * $mat[1][2] * $mat[2][0] * $mat[3][3]+ $mat[0][2] * $mat[1][0] * $mat[2][1] * $mat[3][3]-$mat[0][0] * $mat[1][2] * $mat[2][1] * $mat[3][3];
    $valueG = $mat[0][1] * $mat[1][0] * $mat[2][2] * $mat[3][3]+$mat[0][0] * $mat[1][1] * $mat[2][2] * $mat[3][3];

    $value = $valueA - $valueB - $valueC - $valueD - $valueE - $valueF - $valueG;

    return $value;

}


/******************************************************************************
 * @procedure    Normal3Points
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $p1 : float[]
 *   $p2 : float[]
 *   $p3 : float[]
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] Normal3Points(float $p1[], float $p2[], float $p3[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $center[];
    float $normal[];
    vector $normalV[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    // Get the vector p1-p2, p1-p3
    //
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    // Get the normal to the plane formed by p1, p2, p3, which is the
    // cross prod of p1-p2 and p1-p3
    $normalV = crossProduct( $p1p2, $p1p3, 0, 0 );
    $normal = `unit $normalV[0]`;
    return $normal;

}


/******************************************************************************
 * @procedure    TotalArcLength
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 *
 * @returns      float
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float TotalArcLength()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $ArcLengths = 0.0;
    string $Objs[] = `ls -sl`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Objs = `ls -sl`;
    $ArcLengths = 0.0;
    for($each in $Objs){
    $ArcLengths += `arclen $each`;
    }
    return $ArcLengths;

}


/******************************************************************************
 * @procedure    makeCurvePointDirectionLength
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Length : float
 *   $Direction : float[]
 *   $posA : float[]
 *
 * @returns      string
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string makeCurvePointDirectionLength(float $Length, float $Direction[], float $posA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MultDir[] = multiplyFloat($Length,  $Direction);
    float $FloatDirectionNormalA[] = AddFloats($posA, $MultDir);
    string $CurveBetween;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MultDir = multiplyFloat($Length,  $Direction);
    $FloatDirectionNormalA = AddFloats($posA, $MultDir);
    $CurveBetween = curve2points($posA,  $FloatDirectionNormalA);
    return $CurveBetween;

}


/******************************************************************************
 * @procedure    PointArray
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $ObjectList : string[]
 *
 * @returns      vector[]
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] PointArray(string $ObjectList[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $XiV = 0;
    float $pointAZ1[];
    vector $VecArray[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $XiV = 0;
    for ($each in $ObjectList){
    if (catch($pointAZ1 = `pointPosition -w ($each)`)){
    $pointAZ1 = `xform -q -ws - rp ($each)`;
    }
    $VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
    $XiV++;
    }
    return $VecArray;

}


/******************************************************************************
 * @procedure    HightsOfIsoscelesTriangle
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $SideA : float
 *   $SideB : float
 *   $SideC : float
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] HightsOfIsoscelesTriangle(float $SideA, float $SideB, float $SideC)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $Pi = 3.1415926535;
    float $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
    float $AngleNPi = ($Arcangle*180)/$Pi;
    float $AngleN = $AngleNPi;
    float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
    float $ArcangleC2 = $ArcangleC*2.0;
    float $AngleNB = 180.00 -($ArcangleC2 + $AngleNPi);
    float $Angle_a = $ArcangleC2;
    float $Angle_b = $AngleN;
    float $Angle_c = $AngleNB;
    float $AngleN2 = 180.0 -($Angle_b + $Angle_c);
    float $Angle_A = $AngleN2;
    float $Angle_B = $AngleN;
    float $Angle_C = $AngleN;
    float $AngleOfRightAndA = (180.000 -($AngleN2 +90.000));
    float $AngleOfRightA = ($AngleOfRightAndA/180.000)*$Pi;
    float $AngleN2R = ($AngleN2/180.0000)*$Pi;
    float $HightfromB = sqrt ( ((`pow $SideA 2.000`) + (`pow $SideC 2.000`)) - ((2.000*$SideA*$SideC)*(`cos($AngleN2R+$AngleN2R )`)) )/2.000;
    float $HightfromC = sqrt ( ((`pow $SideA 2.000`) + (`pow $SideC 2.000`)) - ((2.000*$SideA*$SideC)*(`cos ($AngleOfRightA*2.000 )`)) )/2.000;
    float $HightsCandB[] = { $HightfromC, $HightfromB};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $Pi = 3.1415926535;
    $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
    $AngleNPi = ($Arcangle*180)/$Pi;
    $AngleN = $AngleNPi;
    print $AngleN;
    print "//";

    $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
    $ArcangleC2 = $ArcangleC*2.0;
    print $ArcangleC2;
    $AngleNB = 180.00 -($ArcangleC2 + $AngleNPi) ;
    $Angle_a = $ArcangleC2;
    $Angle_b = $AngleN;
    $Angle_c = $AngleNB;

    $AngleN2 = 180.0 -($Angle_b + $Angle_c) ;
    //Two are the same//
    $Angle_A = $AngleN2;
    $Angle_B = $AngleN;
    $Angle_C = $AngleN;
    //Angle of Right Tri in Isoceles
    $AngleOfRightAndA = (180.000 -($AngleN2 +90.000));
    $AngleOfRightA = ($AngleOfRightAndA/180.000)*$Pi;
    $AngleN2R = ($AngleN2/180.0000)*$Pi;
    $HightfromB = sqrt ( ((`pow $SideA 2.000`) + (`pow $SideC 2.000`)) - ((2.000*$SideA*$SideC)*(`cos($AngleN2R+$AngleN2R )`)) )/2.000 ;
    $AngleOfRightA = ($AngleOfRightAndA/180.0000)*$Pi;
    $HightfromC = sqrt ( ((`pow $SideA 2.000`) + (`pow $SideC 2.000`)) - ((2.000*$SideA*$SideC)*(`cos ($AngleOfRightA*2.000 )`)) )/2.000 ;
    $HightsCandB = { $HightfromC, $HightfromB};
    return $HightsCandB;


}


/******************************************************************************
 * @procedure    SteinerChain
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $RAa : float
 *   $RBb : float
 *
 * @returns      string []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] SteinerChain(float $RAa, float $RBb)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $NumberCs = $number3;
    int $n = $NumberCs;
    int $i;
    float $pi = 3.1415926535;
    float $Pi = 3.1415926535;
    float $RA;
    float $RB;
    float $R2 = $RA;
    float $R1 = $RB;
    float $DCircle = (($R2 - $R1)/2.0) + $R1;
    float $Rii = (($R2 - $R1)/2.0);
    float $SideA = $RB + $Rii;
    float $SideB = $Rii*2;
    float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    float $ArcangleC2 = $ArcangleC*2.0;
    float $Aii = (`asin ($RB/($RB + $Rii))`);
    float $number3 = 360.0/$ArcangleC2;
    float $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
    float $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    float $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    float $NofCirclesa = (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
    float $NofCirclesb = ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
    float $NofCirclesc = ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);
    float $dec = 1;
    float $val = $subtract*0.1;
    float $len = $DCircle;
    float $r = $DCircle;
    float $x[] = createRegularPolygonX( $n, $r );
    float $y[] = createRegularPolygonY( $n, $r );
    float $z = 0.0;
    string $circleA[];
    string $circleB[];
    string $circles[];
    string $circlesC[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //
    //float $RA = 22.0;
    //float $RB = 15.680;

    $pi = 3.1415926535;
    $Pi = 3.1415926535;



    if(!( $RAa==$RBb)){
    if( $RAa<$RBb){
    $RA = $RBb;
    $RB = $RAa;}else{ $RA = $RAa; $RB =  $RBb;}

    //float $RA = 22.0;
    //float $RB = 15.68;



    $circleA = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RA -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $circleB = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RB -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $R2 = $RA;
    $R1 = $RB;
    $DCircle = (($R2 - $R1)/2.0) + $R1 ;
    $Rii = (($R2 - $R1)/2.0);

    $SideA = $RB + $Rii;
    $SideB = $Rii*2;

    //GOT it for SURE
    //HightsOfIsoscelesTriangle($SideA, $SideB, $SideA)
    $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    $ArcangleC2 = $ArcangleC*2.0;

    $Aii = (`asin ($RB/($RB + $Rii))`);
    //float $Ni = $pi/$Aii;
    //  $Ni = (rad_to_deg($Aii)) ;


    $number3 = 360.0/$ArcangleC2;

    $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
    $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );

    $NofCirclesa = (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
    $NofCirclesb = ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
    $NofCirclesc = ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);

    //float $subtract = ($NofCirclesa -($NofCirclesb + $NofCirclesc))*4;
    //float $subtract = $NofCirclesB - $NofCirclesA;
    //float $subtract = ($subtract + $NofCirclesC)/2;
    //float $subtractA = (($NofCirclesB - $NofCirclesA)+ $NofCirclesC)/2;
    //float $subtractB = ($NofCirclesA - $NofCirclesC+$NofCirclesB)/2;
    //float $number3 = 360/$NofCirclesC;
    //
    //float $Ni = (rad_to_deg($subtract)) ;
    //float $Ni = $pi/ $subtract;
    //float $number3 = 360/$Ni;
    //$number3 = $subtract;

    //float $subtract = ($NofCirclesA - $NofCirclesC+$NofCirclesB)/2;
    /*
    $dec = 1;
    $val = $subtract*0.1;
    $sign = `sign $val`;
    $dec = `pow 10 $dec`;
    $val = (int) (($val + $sign*5/($dec*10))  * $dec);
    $val = ($val / $dec);
    $val = $val*10;
    $subtract = $val;
    //float $subtract = ($NofCirclesA - $NofCirclesC+$NofCirclesB)/2;
    */
    $NumberCs = $number3;
    $n = $NumberCs;
    $len = $DCircle;
    $r = $DCircle;
    $x = createRegularPolygonX( $n, $r ) ;
    $y = createRegularPolygonY( $n, $r ) ;
    // create the n-sided polygon.
    $z = 0.0 ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $circlesC = `circle -c $x[$i] $y[$i] $z -nr 0 0 1 -sw 360 -r $Rii -d 3 -ut 0 -tol 0.001 -s 16 -ch 1`;

    $circles[`size($circles)`] = $circlesC[0];
    makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $circles[0];
    xform -cp $circles[0];
    //rotate -r -os 0 0 45 $circles[0];
    //aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "scene" $circleB[0] $circles[0];

    }


    //$circles[`size($circles)`] = $circleA[0];
    //$circles[`size($circles)`] = $circleB[0];

    select -r $circleA $circleB $circles ;
    //select -r $circles ;
    return $circles;
    }

}


/******************************************************************************
 * @procedure    CycleNumberString
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $singleStringItemC : string[]
 *
 * @returns      string[]
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CycleNumberString(string $singleStringItemC[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArray;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArray = size($singleStringItemC) -1;
    string $last[0] = {$singleStringItemC [$SizeOfArray]};
    string $first[0] = {$singleStringItemC[0]};
    stringArrayRemoveAtIndex(0,  $singleStringItemC);
    appendStringArray($singleStringItemC, $first,  1);
    return $singleStringItemC;

}


/******************************************************************************
 * @procedure    round
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $val : float
 *   $dec : float
 *
 * @returns      float
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float round(float $val, float $dec)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Xn = 5;
    int $Dn = $dec;
    int $Dn2 = $dec;
    float $divideAs = $val/2;
    float $divideA = $val/5;
    float $divideB = $val/10;
    float $divideC = $val/100;
    float $divideD = $val/1000;
    float $dec = `pow 10 $dec`;
    float $divide = $val/$Xn;
    float $val2 = $divide;
    float $dec2 = $Dn2;
    float $times = $val2 * $Xn;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Xn = 5;
    //float $dec = 0;
    //float $val = 42.02;
    $Dn = $dec;
    $Dn2 = $dec;
    $divideAs = $val/2;
    $divideA = $val/5;
    $divideB = $val/10;
    $divideC = $val/100;
    $divideD = $val/1000;
    if ($divideAs < 1) { $Xn = 1; $Dn = 2; $Dn2 = 1; }
    if (($divideAs > 1) && ($divideA < 1)) { $Xn = 1; $Dn = 2; $Dn2 = 1;}
    if (($divideA > 1) && ($divideB < 1)) { $Xn = 5; }
    if (($divideB > 1) && ($divideC < 1)) { $Xn = 10; }
    if (($divideC > 1) && ($divideD < 1)) { $Xn = 50; }
    //print ($Xn + "\n");
    $dec = $Dn;
    $sign = `sign $val`;
    $dec = `pow 10 $dec`;
    $val = (int) (($val + $sign*5/($dec*10)) * $dec);
    $val = ($val / $dec);

    $divide = $val/$Xn;
    $val2 = $divide;
    $dec2 = $Dn2;
    $sign2 = `sign $val2`;
    $dec2 = `pow 10 $dec2`;
    $val2 = (int) (($val2 + $sign*5/($dec2*10)) * $dec2);
    $val2 = ($val2 / $dec2);
    $times = $val2 * $Xn;

    return $times;

}


/******************************************************************************
 * @procedure    roundFloatsInt
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $floatNumbZ : float[]
 *
 * @returns      float []
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] roundFloatsInt(float $floatNumbZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $floatNumbZi[] = MakeCleanFloatsZ($floatNumbZ);
    float $floatNumbZii[];
    float $One = roundInt($eachF,1.0);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $floatNumbZi = MakeCleanFloatsZ($floatNumbZ);
    for ($eachF in $floatNumbZi){
    $One = roundInt($eachF,1.0);

    $floatNumbZii[`size($floatNumbZii)`]= $One;
    }
    return $floatNumbZii;

}


/******************************************************************************
 * @procedure    roundInt
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $val : float
 *   $dec : float
 *
 * @returns      float
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float roundInt(float $val, float $dec)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $decB = `pow 10 $dec`;
    float $valB = ($val / $dec);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    if($dec==1){
    $val = $val/10;}
    $sign = `sign $val`;
    $decB = `pow 10 $dec`;
    $val = (int) (($val + $sign*5/($decB*10)) * $decB);
    $valB = ($val / $dec);
    if($dec==1){
    $valB = $valB *1;}
    return $valB ;

}


/******************************************************************************
 * @procedure    createRegularPolygonY
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $n : int
 *   $r : float
 *
 * @returns      float[]
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] createRegularPolygonY(int $n, float $r)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    float $x[];
    float $angle = 360.0 / $n;
    float $a = $i * $angle;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $angle = 360.0 / $n ;

    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * cos(deg_to_rad($a)) ;
    }
    return $x ;

}


/******************************************************************************
 * @procedure    createRegularPolygonX
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $n : int
 *   $r : float
 *
 * @returns      float[]
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] createRegularPolygonX(int $n, float $r)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    float $x[];
    float $angle = 360.0 / $n;
    float $a = $i * $angle;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * sin(deg_to_rad($a)) ;
    }
    return $x ;

}


/******************************************************************************
 * @procedure    stringArrayGmatchToArray
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      string[]
 * @source       TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] stringArrayGmatchToArray(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $listItem;
    string $MatchedItem[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    for ($listItem in $list) {
    if ( `gmatch $listItem $item` == 1){
    $result = true;
    if ($result == true ){ $MatchedItem = {$listItem};}
    break;	}
    }
    return $MatchedItem;

}


/******************************************************************************
 * @procedure    CreatePairIntIndex
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $ArraySize : int
 *
 * @returns      int []
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] CreatePairIntIndex(int $ArraySize)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iNdexi = 0;
    int $iNdex = 0;
    int $store;
    int $IntArrayInex[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $iNdexi = 0;
    $iNdex = 0;
    while($iNdex < $ArraySize){

    if($iNdexi == 0){
    $IntArrayInex[$iNdex] = $iNdex;
    $store =$iNdex;
    }
    if($iNdexi == 1){ $iNdexi = -1;
    $IntArrayInex[$iNdex] = $store;
    }

    $iNdexi++;
    $iNdex++;
    }
    return $IntArrayInex;

}


/******************************************************************************
 * @procedure    CreateIntIndexExpand
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $IndexArray : int[]
 *   $ExpandSize : int
 *
 * @returns      int []
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] CreateIntIndexExpand(int $IndexArray[], int $ExpandSize)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IntArrayInex[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ($eachNumber in $IndexArray){
    for ($i=0;$i<$ExpandSize; $i++){
    $IntArrayInex[`size($IntArrayInex)`] = $eachNumber;
    }
    }
    return $IntArrayInex;

}


/******************************************************************************
 * @procedure    attachCurveTangent
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $doAttach : int
 *
 * @returns      string
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string attachCurveTangent(int $doAttach)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCurves = size($curvesList);
    int $degree = eval("getAttr " + $curvesList[0] + ".degree");
    int $numSpans = eval("getAttr " + $curvesList[0] + ".spans");
    int $numCVs1 = $degree + $numSpans;
    int $numCVs2 = $degree + $numSpans;
    int $lastCV = $numCVs1 - 1;
    float $cvLastCurve1[] = `getAttr ($curvesList[0] + ".cp[" + $lastCV + "]")`;
    float $cv2ndLastCurve1[] = `getAttr ($curvesList[0] + ".cp[" + $lastCV + "]")`;
    float $cvOneCurve2[] = `getAttr ($curvesList[1] + ".cp[0]")`;
    float $cvTwoCurve2[] = `getAttr ($curvesList[1] + ".cp[1]")`;
    string $curvesList[] = `filterExpand -ex true -sm $gSelectNurbsCurvesBit`;
    string $resultCurve = eval("curve -p " + $cvLastCurve1[0] + " " + $cvLastCurve1[1] + " " + $cvLastCurve1[2] + " -p " + $cvNew1[0] + " " + $cvNew1[1] + " " + $cvNew1[2] + " -p " + $cvNew2[0] + " " + $cvNew2[1] + " " + $cvNew2[2] + " -p " + $cvOneCurve2[0] + " " + $cvOneCurve2[1] + " " + $cvOneCurve2[2] + " -k 0 -k 0 -k 0 -k 1 -k 1 -k 1");
    string $attachedCurve[] = eval("attachCurve -ch 0 -rpo 0 -kmk 1 " + $curvesList[0] + " " + $resultCurve);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global int $gSelectNurbsCurvesBit;
    $curvesList = `filterExpand -ex true -sm $gSelectNurbsCurvesBit`;

    $numCurves = size($curvesList);
    if ( $numCurves < 2 )
    {
    error((uiRes("m_attachCurveTangent.kErrorSelectTwoCurves")) );
    return "";
    }

    // get the last 2 cvs on the first curve and the first 2 cvs on the
    // second curve
    //
    $degree = eval("getAttr " + $curvesList[0] + ".degree");
    $numSpans = eval("getAttr " + $curvesList[0] + ".spans");
    $numCVs1 = $degree + $numSpans;
    $degree = eval("getAttr " + $curvesList[1] + ".degree");
    $numSpans = eval("getAttr " + $curvesList[1] + ".spans");
    $numCVs2 = $degree + $numSpans;
    if ( $numCVs1 < 2 || $numCVs2 < 2 )
    {
    error((uiRes("m_attachCurveTangent.kErrorTooFewCVs")) );
    return "";
    }

    $lastCV = $numCVs1 - 1;
    $cvLastCurve1 = `getAttr ($curvesList[0] + ".cp[" + $lastCV + "]")`;
    $lastCV--;
    $cv2ndLastCurve1 = `getAttr ($curvesList[0] + ".cp[" + $lastCV + "]")`;
    $cvOneCurve2 = `getAttr ($curvesList[1] + ".cp[0]")`;
    $cvTwoCurve2 = `getAttr ($curvesList[1] + ".cp[1]")`;

    // this is the vector between the two cvs on the first curve
    //
    $vector[0] = $cvLastCurve1[0] - $cv2ndLastCurve1[0];
    $vector[1] = $cvLastCurve1[1] - $cv2ndLastCurve1[1];
    $vector[2] = $cvLastCurve1[2] - $cv2ndLastCurve1[2];

    // calculate a cv on the line between the two end cvs so that it will
    // be tangent
    //
    $cvNew1[0] = $cvLastCurve1[0] + $vector[0];
    $cvNew1[1] = $cvLastCurve1[1] + $vector[1];
    $cvNew1[2] = $cvLastCurve1[2] + $vector[2];

    // this is the vector between the two cvs on the second curve
    //
    $vector[0] = $cvOneCurve2[0] - $cvTwoCurve2[0];
    $vector[1] = $cvOneCurve2[1] - $cvTwoCurve2[1];
    $vector[2] = $cvOneCurve2[2] - $cvTwoCurve2[2];

    // calculate a cv on the line between the two start cvs so that it will
    // be tangent
    //
    $cvNew2[0] = $cvOneCurve2[0] + $vector[0];
    $cvNew2[1] = $cvOneCurve2[1] + $vector[1];
    $cvNew2[2] = $cvOneCurve2[2] + $vector[2];

    // create the degree 3 curve
    //
    $resultCurve = eval("curve -p " + $cvLastCurve1[0] + " " + $cvLastCurve1[1] + " " + $cvLastCurve1[2] + " -p " + $cvNew1[0] + " " + $cvNew1[1] + " " + $cvNew1[2] + " -p " + $cvNew2[0] + " " + $cvNew2[1] + " " + $cvNew2[2] + " -p " + $cvOneCurve2[0] + " " + $cvOneCurve2[1] + " " + $cvOneCurve2[2] + " -k 0 -k 0 -k 0 -k 1 -k 1 -k 1");

    // attach all 3 curves if required
    //
    if ( $doAttach == 1 )
    {
    // attach curve1 to the new curve
    //
    $attachedCurve = eval("attachCurve -ch 0 -rpo 0 -kmk 1 " + $curvesList[0] + " " + $resultCurve);

    // the tangent curve is no longer needed
    //
    delete $resultCurve;

    // attach curve2 to the previously attached curves
    //
    $attachedCurve = eval("attachCurve -ch 0 -rpo 1 -kmk 1 " + $attachedCurve[0] + " " + $curvesList[1]);
    $resultCurve = $attachedCurve[0];
    }

    select -r $resultCurve;
    return $resultCurve;

}


/******************************************************************************
 * @procedure    ct_extrude
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $crv : string
 *   $radius : float
 *   $min : float
 *   $max : float
 *   $spans : int
 *   $degree : int
 *   $rotate : float
 *
 * @returns      string[]
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] ct_extrude(string $crv, float $radius, float $min, float $max, int $spans, int $degree, float $rotate)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $periodic = `getAttr ($crv + ".form")`;
    float $pos[] = `pointOnCurve -pr .00001 -position $crv`;
    float $tan[] = `pointOnCurve -pr .00001 -tangent $crv`;
    string $crvGrp = `group -n $profile[0]`;
    string $tc[] = `tangentConstraint -weight 1 -aimVector 0 1 0 -upVector 0 1 0 $crv $crvGrp`;
    string $form;
    string $tube[] = `eval ( "extrude -fixedPath true -range true -ucp true -upn " + $form + " -et 2 " + $profile[0] + " " + $crv )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    // get start pos and tan of curve in world space
    $pos = `pointOnCurve -pr .00001 -position $crv`;
    $tan = `pointOnCurve -pr .00001 -tangent $crv`;
    $periodic = `getAttr ($crv + ".form")`;

    // make circle at start matching curve tangent
    -nr 0 1 0
    -r $radius
    -degree $degree
    -sections $spans`;

    // put curve under new transform node
    $crvGrp = `group -n $profile[0]`;
    $crvGrp = `rename $crvGrp "tubeConstruction#"`;

    // move circle to curve start point
    xform -cp $profile[0];

    // rotate circle into position once before extruding
    $tc = `tangentConstraint -weight 1 -aimVector 0 1 0 -upVector 0 1 0 $crv $crvGrp`;

    // get form (open/periodic)
    if (($periodic == 0) || ($min != 0) || ($max != 1))
    $form = "true";
    else
    $form = "false";

    // extrude spiral
    $tube = `eval ( "extrude -fixedPath true -range true -ucp true -upn " + $form + " -et 2 " + $profile[0] + " " + $crv )`;

    // delete tangentConstraint
    delete $tc[0];

    // rotate circle into position
    setAttr ($profile[0] + ".ry") $rotate;

    // return	(0) profile transform node
    //		(1) make nurbs circle node
    //		(2) tube transform node
    //		(3) extrude node
    //		(4) curve form (open/periodic)
    //		(5) curve group transform node
    return {$profile[0], $profile[1], $tube[0], $tube[1], string($periodic), $crvGrp};

}


/******************************************************************************
 * @procedure    GetRotationFromDirection
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $P : float[]
 *   $T : float[]
 *   $N : float[]
 *
 * @returns      float []
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] GetRotationFromDirection(float $P[], float $T[], float $N[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $rotation[] = `getAttr ($locator[0]+".rotate")`;
    string $locator[];
    string $AllLocatorZi[];
    vector $tan;
    vector $norm;
    vector $bi;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    matrix $m[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;

    $p = $P;
    $t = $T;
    $n = $N;

    $p[0] = linearToInternal( $p[0] );
    $p[1] = linearToInternal( $p[1] );
    $p[2] = linearToInternal( $p[2] );

    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
    $norm = `unit << $n[0], $n[1], $n[2] >>`;

    // Calculate the binormal.
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
    << ($norm.x), ($norm.y), ($norm.z) >>`;

    $bi = `unit $bi`;

    // Create a matrix, using normal for the X axis and
    // tangent for the Z axis.
    $m = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
    ($bi.x),   ($bi.y),   ($bi.z),   0.0;     // Y axis
    ($tan.x),  ($tan.y),  ($tan.z),  0.0;     // Z axis
    $p[0],     $p[1],     $p[2],     1.0 >>;  // Position

    // Create a locator and assign its world-space matrix.
    $locator = `spaceLocator`;
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $locator[0];


    $rotation = `getAttr ($locator[0]+".rotate")`;

    return $rotation;


}


/******************************************************************************
 * @procedure    screenSpaceGetMatrix
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $attr : string
 *
 * @returns      matrix
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix screenSpaceGetMatrix(string $attr)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $v[] = `getAttr $attr`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $v = `getAttr $attr`;
    matrix $mat[4][4]=<<$v[0], $v[1], $v[2], $v[3];
    $v[4], $v[5], $v[6], $v[7];
    $v[8], $v[9], $v[10], $v[11];
    $v[12], $v[13], $v[14], $v[15]>>;
    return $mat;

}


/******************************************************************************
 * @procedure    screenSpaceVecMult
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $v : vector
 *   $m : matrix
 *
 * @returns      vector
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector screenSpaceVecMult(vector $v, matrix $m)
{

    matrix $v1[1][4]=<<$v.x, $v.y, $v.z, 1>>;
    matrix $v2[1][4]=$v1*$m;
    return <<$v2[0][0], $v2[0][1],  $v2[0][2]>>;

}


/******************************************************************************
 * @procedure    angle_to_internal
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $angle : float
 *   $anglePoint : float
 *
 * @returns      float
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float angle_to_internal(float $angle, float $anglePoint)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $pref = `currentUnit -q -a`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pref = `currentUnit -q -a`;
    if ( "deg" == $pref )
    {
    $angle = $angle * $anglePoint;
    }

    return $angle;

}


/******************************************************************************
 * @procedure    linear_to_internal
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $linear : float
 *
 * @returns      float
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float linear_to_internal(float $linear)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $factor = 1.0;
    string $pref = `currentUnit -q -l`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $factor = 1.0;
    $pref = `currentUnit -q -l`;
    if ( "mm" == $pref ) $factor = 0.1;
    if ( "m" == $pref ) $factor = 100.0;
    if ( "inch" == $pref ) $factor = 2.54;
    if ( "ft" == $pref ) $factor = 30.48;
    if ( "yard" == $pref ) $factor = 91.44;

    return ( $linear * $factor );

}


/******************************************************************************
 * @procedure    linear_to_ui
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $linear : float
 *
 * @returns      float
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float linear_to_ui(float $linear)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $factor = 1.0;
    string $pref = `currentUnit -q -l`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $factor = 1.0;
    $pref = `currentUnit -q -l`;
    if ( "mm" == $pref ) $factor = 10.0;
    if ( "m" == $pref ) $factor = 0.01;
    if ( "inch" == $pref ) $factor = 0.3937007874;
    if ( "ft" == $pref ) $factor = 0.03280839895;
    if ( "yard" == $pref ) $factor = 0.01093613298;

    return ( $linear * $factor );

}


/******************************************************************************
 * @procedure    be_plot_locators
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $curve : string
 *
 * @returns      string[]
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] be_plot_locators(string $curve)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $u;
    float $span = 0.1;
    float $maxU = `getAttr ( $curve + ".maxValue" )`;
    string $locator[];
    string $AllLocatorZi[];
    vector $tan;
    vector $norm;
    vector $bi;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    matrix $m[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;

    $span = 0.1;
    $maxU = `getAttr ( $curve + ".maxValue" )`;
    for ( $u = 0.0; $u <= $maxU; $u += $span )
    {
    // Query the position,
    //tangent and normal.
    //
    //-p: -position  -position(-p)
    //nn: -normalizedNormal
    //nt: -normalizedTangent


    $p = `pointOnCurve -ch off -pr $u -p $curve`;
    //$t is just a direction....
    $t = `pointOnCurve -ch off -pr $u -nt $curve`;
    $n = `pointOnCurve -ch off -pr $u -nn $curve`;

    // Translational coordinates in a Maya matrix are always represented
    // in Maya's internal units. Convert position to (cm) units.
    $p[0] = linearToInternal( $p[0] );
    $p[1] = linearToInternal( $p[1] );
    $p[2] = linearToInternal( $p[2] );

    // Maya promises normalized tangent and normal,
    // but they really aren't.
    //
    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
    $norm = `unit << $n[0], $n[1], $n[2] >>`;

    // Calculate the binormal.
    //
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
    << ($norm.x), ($norm.y), ($norm.z) >>`;

    // Normalize our vector.
    //
    $bi = `unit $bi`;

    // Create a matrix, using normal for the X axis and
    // tangent for the Z axis.
    //
    $m = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
    ($bi.x),   ($bi.y),   ($bi.z),   0.0;     // Y axis
    ($tan.x),  ($tan.y),  ($tan.z),  0.0;     // Z axis
    $p[0],     $p[1],     $p[2],     1.0 >>;  // Position

    // Create a locator and assign its world-space matrix.
    //curve -d 1 -p -0.0870275 0 0.00556599 -p 0 0 5 -k 0 -k 4.995192 ;
    $locator[0] = `curve -d 1 -p -0.0870275 0 0.00556599 -p 0 0 5 -k 0 -k 4.995192`;
    //$locator = `spaceLocator`;
    appendAll($AllLocatorZi, $locator);


    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $locator[0];


    }
    return $AllLocatorZi;

}


/******************************************************************************
 * @procedure    NumberOFSurf
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Zeachboundry : string
 *
 * @returns      int
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int NumberOFSurf(string $Zeachboundry)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $XnumOFcurveConnections;
    int $historyShapes = `size($ZfirstcurveConnectionsz)`;
    string $ZfirstcurveRelatives[];
    string $ZfirstcurveConnectionsz[];
    string $Zfirstcurveshapes[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $ZfirstcurveRelatives = `listRelatives -shapes $Zeachboundry`;
    $ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
    $historyShapes = `size($ZfirstcurveConnectionsz)`;
    if ($historyShapes > 0){
    $ZfirstcurveshapesA = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;
    $ZfirstcurveshapesB = `listConnections -shapes 1  -type mesh $ZfirstcurveConnectionsz`;
    $XnumOFcurveConnections = (`size($ZfirstcurveshapesA)`) + (`size($ZfirstcurveshapesB)`) ;
    }else{ $XnumOFcurveConnections = 0;}

    return $XnumOFcurveConnections;

}


/******************************************************************************
 * @procedure    ForAllCurvesFindSurfaceEdges
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $newallCurves : string[]
 *
 * @returns      string[]
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] ForAllCurvesFindSurfaceEdges(string $newallCurves[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Zfirstcurveshapesi = `NumberOFSurf($Zeachboundry)`;
    string $ZnewfoundEdge[];
    string $ZselectedCurve[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ( $Zeachboundry in $newallCurves ) {
    $ZselectedCurve[0] = $Zeachboundry;
    $Zfirstcurveshapesi = `NumberOFSurf($Zeachboundry)`;
    if ($Zfirstcurveshapesi == 1){
    appendStringArray($ZnewfoundEdge, $ZselectedCurve, 1);
    }
    if ($Zfirstcurveshapesi == 0){
    appendStringArray($ZnewfoundEdge,  $ZselectedCurve, 1);
    }
    }
    return $ZnewfoundEdge;

}


/******************************************************************************
 * @procedure    GetVectorArrayBetweenCurveEnds
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $CurveItem : string[]
 *
 * @returns      vector[]
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] GetVectorArrayBetweenCurveEnds(string $CurveItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    float $EACHCVposAZ[];
    float $eachCVpos[];
    string $CurveSelection[];
    vector $CurveA = << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $CurveB = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $CurveAB[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
    $EACHCVposAZ = 0; string $MakeXBetweenB[];
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA   )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){$EACHCVposAZ = $eachCVpos;}
    if ( $numIntZB == 2 ){$EACHCVposBZ = $eachCVpos;}
    }
    $CurveA = << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    $CurveB = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    $CurveAB = $CurveA; $CurveAB[1] = $CurveB;
    return $CurveAB;

}


/******************************************************************************
 * @procedure    PointsEquivalentTol
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      int
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int PointsEquivalentTol(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $pX = equivalentTol($posA[0], $posB[0],  0.01);
    int $pY = equivalentTol($posA[1], $posB[1],  0.01);
    int $pZ = equivalentTol($posA[2], $posB[2],  0.01);
    int $addedResults = $pX + $pY + $pZ;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pX = equivalentTol($posA[0], $posB[0],  0.01);
    $pY = equivalentTol($posA[1], $posB[1],  0.01);
    $pZ = equivalentTol($posA[2], $posB[2],  0.01);
    $addedResults = $pX + $pY + $pZ;
    if ($addedResults == 3 ){ print "Points  equivalent";
    }
    return $addedResults;

}


/******************************************************************************
 * @procedure    FindifCurveEndsMeet
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $CurveA1 : vector[]
 *   $CurveA2 : vector[]
 *
 * @returns      int
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindifCurveEndsMeet(vector $CurveA1[], vector $CurveA2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CurveMeetsTrue = 0;
    int $indexN = 0;
    int $indexN2 = 0;
    int $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    int $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);
    float $firstC[];
    float $SecondCA[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveMeetsTrue = 0;
    $indexN = 0;
    $indexN2 = 0;
    while ($indexN < 2){
    $firstC = $CurveA1[$indexN];
    $SecondC = $CurveA2[0];
    $SecondCA = $CurveA2[1];
    $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);
    if (($NumberE == 3)||($NumberE2 == 3)){$CurveMeetsTrue = $CurveMeetsTrue +1; }
    if ($indexN==1){$indexN1 = 1;}
    $indexN++;
    }
    return $CurveMeetsTrue;

}


/******************************************************************************
 * @procedure    ValueOfCurveSurfInterConnections
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $Zeachboundry : string[]
 *
 * @returns      int
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ValueOfCurveSurfInterConnections(string $Zeachboundry[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $NumberofConnectionZ = 0;
    int $historyShapes = `size($ZfirstcurveConnectionsz)`;
    int $CA = `size($ZfirstcurveshapesA)`;
    int $CB = `size($ZfirstcurveshapesB)`;
    int $XnumOFcurveConnections = `size($Intersectboundarycurves)`;
    string $myIntersector = `stringArrayIntersector`;
    string $ZfirstcurveRelatives[];
    string $ZfirstcurveConnectionsz[];
    string $Zfirstcurveshapes[];
    string $Intersectboundarycurves[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $NumberofConnectionZ = 0;
    $myIntersector = `stringArrayIntersector`;
    for ( $eachboundry in $Zeachboundry ) {
    $ZfirstcurveRelatives = `listRelatives -shapes $eachboundry`;
    $ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
    $historyShapes = `size($ZfirstcurveConnectionsz)`;

    if ($historyShapes > 0){
    $ZfirstcurveshapesA = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;
    $ZfirstcurveshapesB = `listConnections -shapes 1  -type mesh $ZfirstcurveConnectionsz`;
    $CA = `size($ZfirstcurveshapesA)`;
    $CB = `size($ZfirstcurveshapesB)`;

    if (($CA > 0) || ($CB > 0)){
    if ($CA > 0){
    $NumberofConnectionZ++;
    stringArrayIntersector -edit -allowDuplicates  false -intersect $ZfirstcurveshapesA $myIntersector;
    }
    if ($CB > 0){
    $NumberofConnectionZ++;
    stringArrayIntersector -edit -allowDuplicates  false -intersect $ZfirstcurveshapesB $myIntersector;
    }
    }else{ //no shapes connections of anytype Exist ZERO
    $NumberofConnectionZ = 0;
    }
    }
    }
    $Intersectboundarycurves =  `stringArrayIntersector -query $myIntersector`;
    stringArrayIntersector -edit -reset  $myIntersector;
    $XnumOFcurveConnections = `size($Intersectboundarycurves)`;
    return $XnumOFcurveConnections;

}


/******************************************************************************
 * @procedure    IfCurvesTouch
 * @category     tangent-procedures
 * @layer        utility (General)
 *
 * @param
 *   $curveA : string
 *   $curveB : string
 *
 * @returns      int
 * @source       Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int IfCurvesTouch(string $curveA, string $curveB)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $intIfTrue = FindifCurveEndsMeet($CurveOne, $CurveTwo);
    string $Acurve[];
    string $Bcurve[];
    vector $CurveOne[] = GetVectorArrayBetweenCurveEnds($Acurve);
    vector $CurveTwo[] = GetVectorArrayBetweenCurveEnds($Bcurve);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Acurve = {$curveA};
    $Bcurve = {$curveB};
    $CurveOne = GetVectorArrayBetweenCurveEnds($Acurve);
    $CurveTwo = GetVectorArrayBetweenCurveEnds($Bcurve);
    $intIfTrue = FindifCurveEndsMeet($CurveOne, $CurveTwo);
    return $intIfTrue;

}

