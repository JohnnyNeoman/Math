/******************************************************************************
 * POLYGON OPS - CLEANED MEL PROCEDURES
 *
 * Category:    polygon-ops
 * Layer:       affine (Mesh)
 * Description: Polygon mesh operations - bevel, bridge, chamfer, etc.
 * Procedures:  132
 *
 * All variable declarations moved to procedure start.
 * Generated by cleanup_mel_v2.py
 ******************************************************************************/


/******************************************************************************
 * @procedure    triangleArea
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $v1 : float[]
 *   $v2 : float[]
 *   $v3 : float[]
 *
 * @returns      float
 * @source       computePolysetVolume (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
global proc float triangleArea(float $v1[], float $v2[], float $v3[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $c1[] = crossProduct( $v1, $v2, 0, 0 );
    float $c2[] = crossProduct( $v2, $v3, 0, 0 );
    float $c3[] = crossProduct( $v3, $v1, 0, 0 );
    float $area = sqrt( $vec[0]*$vec[0] + $vec[1]*$vec[1] + $vec[2] * $vec[2])/2.0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $c1 = crossProduct( $v1, $v2, 0, 0 );
    $c2 = crossProduct( $v2, $v3, 0, 0 );
    $c3 = crossProduct( $v3, $v1, 0, 0 );
    $vec[0] = $c1[0] + $c2[0] + $c3[0];
    $vec[1] = $c1[1] + $c2[1] + $c3[1];
    $vec[2] = $c1[2] + $c2[2] + $c3[2];
    $area = sqrt( $vec[0]*$vec[0] + $vec[1]*$vec[1] + $vec[2] * $vec[2])/2.0;
    return( $area );

}


/******************************************************************************
 * @procedure    quadArea
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $v1 : float[]
 *   $v2 : float[]
 *   $v3 : float[]
 *   $v4 : float[]
 *
 * @returns      float
 * @source       computePolysetVolume (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
global proc float quadArea(float $v1[], float $v2[], float $v3[], float $v4[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $a1 = triangleArea( $v1,$v2,$v3 );
    float $a2 = triangleArea( $v3,$v4,$v2 );

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $a1 = triangleArea( $v1,$v2,$v3 );
    // float $a2 = triangleArea( $v3,$v4,$v1 );
    $a2 = triangleArea( $v3,$v4,$v2 );
    return( $a1 + $a2 );

}


/******************************************************************************
 * @procedure    computePolysetVolume
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      float
 * @source       computePolysetVolume (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
global proc float computePolysetVolume()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $nz;
    float $A;
    float $totalVolume = 0;
    float $val;
    string $normalInfo[];
    string $curFace;
    string $ni[];
    string $verts[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $pobjList = `ls -dag -sl -type mesh`;
    if(size( $pobjList ) < 1 ){
    error( (uiRes("m_computePolysetVolume.kNoPolyObjectsSelected")));
    return 0.0;
    }
    $pobjListDup = `duplicate -rr $pobjList`;

    select -r $pobjListDup;
    FreezeTransformations;

    $totalVolume = 0;
    for( $obj = 0; $obj < size($pobjListDup); $obj++ ) {
    $pobj = $pobjListDup[$obj];
    $numFaces = `polyEvaluate -f $pobj`;
    print( "// " + $pobj + " faces = " +$numFaces[0]+ " //\n" );
    for( $i = 0; $i < $numFaces[0]; $i++ ){
    $curFace = ($pobj + ".f[" + $i + "]");
    $normalInfo = `polyInfo -faceNormals $curFace`;
    tokenize $normalInfo[0] $ni;
    $nz = $ni[4];
    $verts = `listAttr $curFace`;
    $nVerts = size( $verts )/4;
    if( $nVerts == 3 ){
    $v1 = pointPosition( $pobj + "." + $verts[0] );
    $v2 = pointPosition( $pobj + "." + $verts[4] );
    $v3 = pointPosition( $pobj + "." + $verts[8] );
    $A = triangleArea($v1,$v2,$v3);
    $val = $A * $nz * ( $v1[2] + $v2[2] + $v3[2] )/3.0;
    } else if( $nVerts == 4 ){
    $v1 = pointPosition( $pobj + "." + $verts[0] );
    $v2 = pointPosition( $pobj + "." + $verts[4] );
    $v3 = pointPosition( $pobj + "." + $verts[8] );
    $v4 = pointPosition( $pobj + "." + $verts[12] );
    $A = quadArea($v1,$v2,$v3, $v4);

    $val = $A * $nz * ( $v1[2] + $v2[2] + $v3[2] + $v4[2])/4.0;
    }
    $totalVolume += $val;
    }
    }
    print ("// TOTAL VOLUME = " +$totalVolume+ " //\n");
    delete $pobjListDup;
    select -r $pobjList;
    return $totalVolume;

}


/******************************************************************************
 * @procedure    ConvertPolyFacesIntoNurbSurface
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      string
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string ConvertPolyFacesIntoNurbSurface()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sizeBorderEdges = size($SelectedPolyBorderEdges) -1;
    int $Xi = 1;
    int $ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
    int $iix = 0;
    int $iiV = 0;
    float $valuesP[];
    float $values[];
    string $PolyFaceslist[] = `ls -sl`;
    string $NewPolyFaces[] = ` polyChipOff -ch 1 -kft 1 -dup 0 -off 0 $PolyFaceslist`;
    string $HistoryConnections[] = ` listHistory -future true -pruneDagObjects false $NewPolyFaces`;
    string $polySep[] = `polySeparate -rs 1 -ch 0 $HistoryConnections[1]`;
    string $PolyFaces = ( $PolygonNew[0] +".f[*]");
    string $AllPolyFaces[] = `ls -fl $PolyFaces`;
    string $AllPolyFaces2[] = `ls $PolyFaces`;
    string $diffEdgeVertz[] = GetEdgeVertex($PolygonNew);
    string $ReturnObjects = "";
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorCX`;
    string $DiffPolyBorderEdges[] = GetdiffEdgesOfBorder($PolygonNew);
    string $SelectedPolyBorderEdges[] = PolyBorderEdges($PolygonNew);
    string $NearEdges[] = GetNearEdges($EdgeVertzStart);
    string $diffA[] = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdges);
    string $NearEdgesA[] = GetNearEdges($NearEdgesOne);
    string $diffB[] = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdgesA);
    string $EdgesVertex[] = ls("-fl",polyListComponentConversion("-toVertex",$diffB[0]));
    string $bufferList[];
    string $EdgeCurves[];
    string $EdgesVertexEach[];
    string $ListA[];
    string $EdgesVertexEachOrder[] = VertLoopEdgeLoop($ListA);
    string $Newcurvez = `eval($curve)`;
    string $NewcurveX[];
    string $NurbSurfaceFromPolyFaces = `alternativeBoundry`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyFaceslist = `ls -sl`;
    $NewPolyFaces = ` polyChipOff -ch 1 -kft 1 -dup 0 -off 0 $PolyFaceslist`;
    print $NewPolyFaces;
    $HistoryConnections = ` listHistory -future true -pruneDagObjects false $NewPolyFaces`;
    $polySep = `polySeparate -rs 1 -ch 0 $HistoryConnections[1]`;
    select -r $polySep[1];
    string $PolygonNew[0] = {$polySep[1]};
    parent -w $PolygonNew;
    $PolyFaces = ( $PolygonNew[0] +".f[*]");
    $AllPolyFaces = `ls -fl $PolyFaces`;
    $AllPolyFaces2 = `ls $PolyFaces`;

    $diffEdgeVertz = GetEdgeVertex($PolygonNew);
    $ReturnObjects = "";

    for ($eachP in $diffEdgeVertz){
    $valuesP = `pointPosition -w ($eachP)`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorCX`;
    move -ws $valuesP[0] $valuesP[1] $valuesP[2] $spaceLocatorB;
    $ReturnObjects += $spaceLocatorB[0]+" ";
    }
    $DiffPolyBorderEdges = GetdiffEdgesOfBorder($PolygonNew);
    $SelectedPolyBorderEdges = PolyBorderEdges($PolygonNew);

    $sizeBorderEdges = size($SelectedPolyBorderEdges) -1;
    string $EdgeVertzStart[0] = {$diffEdgeVertz[0]};
    stringArrayRemoveAtIndex(0, $diffEdgeVertz);
    $NearEdges = GetNearEdges($EdgeVertzStart);
    string $NearEdgesOne[0] = {$NearEdges[0]};
    string $NearEdgesSecond[0] = {$NearEdges[1]};
    appendStringArray($DiffPolyBorderEdges, $NearEdgesSecond, 1);
    $diffA = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdges);
    string $orderedArray[0] = {$NearEdgesOne[0]};
    $Xi = 1;
    while ($Xi < $sizeBorderEdges){
    $Xi++;
    $NearEdgesA = GetNearEdges($NearEdgesOne);
    appendStringArray($DiffPolyBorderEdges, $NearEdgesOne, 1);
    $diffB = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdgesA);

    $EdgesVertex = ls("-fl",polyListComponentConversion("-toVertex",$diffB[0]));
    $ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
    appendStringArray($orderedArray, $diffB, 1);
    $NearEdgesOne = $diffB;
    }
    appendStringArray($orderedArray, $NearEdgesSecond, 1);

    $EdgeLists = "";
    $iix = 0;
    $iiV = 0;
    for ($each in $orderedArray){
    string $oneItem[0] = {$each};
    $EdgesVertex = ls("-fl",polyListComponentConversion("-toVertex", $oneItem[0]));
    if ( $iix > 0){
    $ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
    if ( $ifTrue == 1){ $iiV++; if ( $iiV == 1){
    $EdgeLists += " "+$oneItem[0]+" "+"VERT";} if ( $iiV == 2){ $EdgeLists += " "+$oneItem[0]; $iiV = 0; } }
    if ( $ifTrue == 0){ $EdgeLists += " "+$oneItem[0]; }
    }
    if ( $iix == 0){  $EdgeLists += $oneItem[0]; }
    $iix++;
    }

    $numTokens = `tokenize $EdgeLists "VERT" $bufferList`;
    clear $EdgeCurves;
    for($eachBuffer in $bufferList){
    $ListA = `stringToStringArray $eachBuffer " "`;
    //string $EdgesVertexEach[] = ls("-fl",polyListComponentConversion("-toVertex", $ListA));
    $EdgesVertexEachOrder = VertLoopEdgeLoop($ListA);
    $curve = "curve -d 1";
    for($eachVert in $EdgesVertexEachOrder){
    $values = `pointPosition -w ($eachVert)`;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    $Newcurvez = `eval($curve)`;
    $NewcurveX = {$Newcurvez};
    appendStringArray($EdgeCurves, $NewcurveX, 1);

    }
    select -r $EdgeCurves;
    $NurbSurfaceFromPolyFaces = `alternativeBoundry`;
    delete -ch $EdgeCurves;
    delete $PolygonNew;
    $ReturnObjects += $NurbSurfaceFromPolyFaces;
    $ReturnObjects += " "+$EdgeCurves[0] +" "+$EdgeCurves[1] +" "+$EdgeCurves[2] +" "+$EdgeCurves[3] ;
    select -r $EdgeCurves;
    print $ReturnObjects;
    return $ReturnObjects;

}


/******************************************************************************
 * @procedure    CreatePolyFromFloats
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $BoxPointsX : float[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CreatePolyFromFloats(float $BoxPointsX[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sizeVecBox = size($BoxPointZ);
    int $ZiI = 0;
    float $bbox[] = $BoxPointsX;
    float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox[2]};
    float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox[5]};
    float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox[2]};
    float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox[5]};
    float $values[] = $BoxPointZ[$ZiI];
    string $polyZ = "polyCreateFacet";
    vector $BoxPointZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $bbox = $BoxPointsX;
    $BoxPointA = {$bbox[0], $bbox[1], $bbox[2]};
    $BoxPointB = {$bbox[3], $bbox[4], $bbox[5]};
    $BoxPointC = {$bbox[3], $bbox[1], $bbox[2]};
    $BoxPointD = {$bbox[0], $bbox[4], $bbox[5]};
    ///
    $BoxPointZ[0] = <<$bbox[0], $bbox[4], $bbox[2]>>;
    $BoxPointZ[1] = <<$bbox[3], $bbox[4], $bbox[2]>>;
    $BoxPointZ[2] = <<$bbox[3], $bbox[4], $bbox[5]>>;
    $BoxPointZ[3] = <<$bbox[0], $bbox[4], $bbox[5]>>;

    $sizeVecBox = size($BoxPointZ);
    $polyZ = "polyCreateFacet";
    $ZiI = 0;
    progressWindow -ii true -title "Working" -status "Moving Verts" -max (size($BoxPointZ)) -progress 0;
    while ($ZiI < $sizeVecBox){
    $values = $BoxPointZ[$ZiI];
    $polyZ += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    $ZiI++;
    progressWindow -e -s 1;
    if(`progressWindow -q -ic`)
    {
    progressWindow -endProgress;
    error "User Interupt.";
    }


    }
    print $polyZ;
    string $NewPolyZz[0] = `eval($polyZ)`;
    progressWindow -endProgress;
    select -r $NewPolyZz;
    ResetTranslation($NewPolyZz);
    return $NewPolyZz;

}


/******************************************************************************
 * @procedure    GetDistancePointPositionFLOAT
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $objectFirst : string
 *   $objectSecond : string
 *
 * @returns      float
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc float GetDistancePointPositionFLOAT(string $objectFirst, string $objectSecond)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $pointAZ1[];
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pointAZ1 = `pointPosition -w ($objectFirst)`;
    $pointAZ2 = `pointPosition -w ($objectSecond)`;
    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    ConvertPolyPlaneIntoNurbSurfaceZ
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $PolygonNew : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] ConvertPolyPlaneIntoNurbSurfaceZ(string $PolygonNew[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sizeBorderEdges = size($SelectedPolyBorderEdges) -1;
    int $Xi = 1;
    int $ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
    int $iix = 0;
    int $iiV = 0;
    float $valuesP[];
    float $values[];
    string $PolyFaces = ( $PolygonNew[0] +".f[*]");
    string $AllPolyFaces[] = `ls -fl $PolyFaces`;
    string $AllPolyFaces2[] = `ls $PolyFaces`;
    string $diffEdgeVertz[] = GetEdgeVertex($PolygonNew);
    string $ReturnObjects = "";
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorCX`;
    string $DiffPolyBorderEdges[] = GetdiffEdgesOfBorder($PolygonNew);
    string $SelectedPolyBorderEdges[] = PolyBorderEdges($PolygonNew);
    string $NearEdges[] = GetNearEdges($EdgeVertzStart);
    string $diffA[] = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdges);
    string $NearEdgesA[] = GetNearEdges($NearEdgesOne);
    string $diffB[] = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdgesA);
    string $EdgesVertex[] = ls("-fl",polyListComponentConversion("-toVertex",$diffB[0]));
    string $bufferList[];
    string $EdgeCurves[];
    string $EdgesVertexEach[];
    string $ListA[];
    string $EdgesVertexEachOrder[] = VertLoopEdgeLoop($ListA);
    string $Newcurvez = `eval($curve)`;
    string $NewcurveX[];
    string $ListofItemConvert[] = `stringToStringArray $ReturnObjects " "`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $PolyFaces = ( $PolygonNew[0] +".f[*]");
    $AllPolyFaces = `ls -fl $PolyFaces`;
    $AllPolyFaces2 = `ls $PolyFaces`;

    $diffEdgeVertz = GetEdgeVertex($PolygonNew);
    $ReturnObjects = "";

    for ($eachP in $diffEdgeVertz){
    $valuesP = `pointPosition -w ($eachP)`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorCX`;
    move -ws $valuesP[0] $valuesP[1] $valuesP[2] $spaceLocatorB;
    $ReturnObjects += $spaceLocatorB[0]+" ";
    }
    $DiffPolyBorderEdges = GetdiffEdgesOfBorder($PolygonNew);
    $SelectedPolyBorderEdges = PolyBorderEdges($PolygonNew);

    $sizeBorderEdges = size($SelectedPolyBorderEdges) -1;
    string $EdgeVertzStart[0] = {$diffEdgeVertz[0]};
    stringArrayRemoveAtIndex(0, $diffEdgeVertz);
    $NearEdges = GetNearEdges($EdgeVertzStart);
    string $NearEdgesOne[0] = {$NearEdges[0]};
    string $NearEdgesSecond[0] = {$NearEdges[1]};
    appendStringArray($DiffPolyBorderEdges, $NearEdgesSecond, 1);
    $diffA = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdges);
    string $orderedArray[0] = {$NearEdgesOne[0]};
    $Xi = 1;
    while ($Xi < $sizeBorderEdges){
    $Xi++;
    $NearEdgesA = GetNearEdges($NearEdgesOne);
    select -r $NearEdgesA;
    appendStringArray($DiffPolyBorderEdges, $NearEdgesOne, 1);
    $diffB = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdgesA);
    select -r $diffB;
    $EdgesVertex = ls("-fl",polyListComponentConversion("-toVertex",$diffB[0]));
    $ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
    appendStringArray($orderedArray, $diffB, 1);
    $NearEdgesOne = $diffB;
    }
    appendStringArray($orderedArray, $NearEdgesSecond, 1);

    $EdgeLists = "";

    $iix = 0;
    $iiV = 0;
    for ($each in $orderedArray){
    string $oneItem[0] = {$each};
    $EdgesVertex = ls("-fl",polyListComponentConversion("-toVertex", $oneItem[0]));
    playButtonStepForward;
    select -r $EdgesVertex;
    playButtonStepForward;
    if ( $iix > 0){
    $ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
    if ( $ifTrue == 1){ $iiV++; if ( $iiV == 1){
    $EdgeLists += " "+$oneItem[0]+" "+"VERT";} if ( $iiV == 2){ $EdgeLists += " "+$oneItem[0]; $iiV = 0; } }
    if ( $ifTrue == 0){ $EdgeLists += " "+$oneItem[0]; }
    }
    if ( $iix == 0){  $EdgeLists += $oneItem[0]; }
    $iix++;
    }

    $numTokens = `tokenize $EdgeLists "VERT" $bufferList`;
    clear $EdgeCurves;
    for($eachBuffer in $bufferList){
    $ListA = `stringToStringArray $eachBuffer " "`;
    //string $EdgesVertexEach[] = ls("-fl",polyListComponentConversion("-toVertex", $ListA));
    $EdgesVertexEachOrder = VertLoopEdgeLoop($ListA);
    $curve = "curve -d 1";
    for($eachVert in $EdgesVertexEachOrder){ playButtonStepForward;
    select -r $eachVert; playButtonStepForward;
    $values = `pointPosition -w ($eachVert)`;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    $Newcurvez = `eval($curve)`;
    $NewcurveX = {$Newcurvez};
    appendStringArray($EdgeCurves, $NewcurveX, 1);

    }
    select -r $EdgeCurves;
    string $NurbSurfaceFromPolyFaces[0] = {`alternativeBoundry`};
    delete -ch $NurbSurfaceFromPolyFaces;
    delete -ch $EdgeCurves;
    delete $PolygonNew;
    $ListofItemConvert = `stringToStringArray $ReturnObjects " "`;
    delete $ListofItemConvert;
    return $NurbSurfaceFromPolyFaces;

}


/******************************************************************************
 * @procedure    GetNearEdges
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $edgeArray : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] GetNearEdges(string $edgeArray[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $PolyVertexFromEdges[] = ls("-fl",polyListComponentConversion("-toVertex",$edgeArray[0]));
    string $PolyEdgesFromVertex[] = ls("-fl",polyListComponentConversion("-toEdge", $PolyVertexFromEdges));

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyVertexFromEdges = ls("-fl",polyListComponentConversion("-toVertex",$edgeArray[0]));
    $PolyEdgesFromVertex = ls("-fl",polyListComponentConversion("-toEdge", $PolyVertexFromEdges));
    return $PolyEdgesFromVertex;

}


/******************************************************************************
 * @procedure    alternativeBoundry
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      string
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string alternativeBoundry()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $hist = `constructionHistory -q -tgl`;
    int $n = size($curves);
    int $i;
    string $curves[] = `filterExpand -ex true -sm $gSelectNurbsCurvesBit -sm $gSelectIsoparmsBit -sm $gSelectCurvesOnSurfacesBit -sm $gSelectSurfaceEdgeBit`;
    string $surface = "";
    string $cmd = "boundary -or 0 -ep 0 -rn 1 -po 0 -ept 0.001 -ch  " + $hist + " ";
    string $now[] = `rebuildCurve -ch 0 -rpo 1 -kcp on -d 1 -rt 0 $curves[$i]`;
    string $res[] = eval($cmd);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $hist = `constructionHistory -q -tgl`;
    global int $gSelectNurbsCurvesBit;
    global int $gSelectIsoparmsBit;
    global int $gSelectCurvesOnSurfacesBit;
    global int $gSelectSurfaceEdgeBit;
    $curves = `filterExpand -ex true -sm $gSelectNurbsCurvesBit -sm $gSelectIsoparmsBit -sm $gSelectCurvesOnSurfacesBit -sm $gSelectSurfaceEdgeBit`;
    $surface = "";
    $n = size($curves);
    if( $n < 4 ) return $surface;
    $cmd = "boundary -or 0 -ep 0 -rn 1 -po 0 -ept 0.001 -ch  " + $hist + " ";
    // Rebuild them into linears (keep cvs):
    for( $i=0; $i<$n; $i+=1 ) {
    $now = `rebuildCurve -ch 0 -rpo 1 -kcp on -d 1 -rt 0 $curves[$i]`;
    $curves[$i] = $now[0];
    $cmd = $cmd + $curves[$i] + " ";
    }

    // Convert back into cubic:
    $res = eval($cmd);
    if( size($res) > 0 ) {
    $surface = $res[0];
    rebuildSurface -ch $hist -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kc 0 -su 0 -du 3 -sv 0 -dv 3 -tol 0.001 -fr 0  -dir 2 $surface;
    }

    if( !$hist ) {
    for( $i=0; $i<$n; $i+=1 ) {
    delete $curves[$i];
    }
    }

    select -r $curves;
    return $surface;

}


/******************************************************************************
 * @procedure    VertLoopEdgeLoop
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $edgeZ : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] VertLoopEdgeLoop(string $edgeZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $verts[];
    string $v0[] = `polyListComponentConversion -tv $edgeZ[0]`;
    string $v1[] = `polyListComponentConversion -tv $edgeZ[1]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $v0 = `polyListComponentConversion -tv $edgeZ[0]`;
    $v0=`ls -fl $v0`;
    $v1 = `polyListComponentConversion -tv $edgeZ[1]`;
    $v1=`ls -fl $v1`;
    $v0=`stringArrayRemove $v1 $v0`;
    $verts[0]=$v0[0];

    for($i=0;$i<size($edgeZ);$i++)
    {
    $v0 = `polyListComponentConversion -tv $edgeZ[$i]`;

    $v0=`ls -fl $v0`;
    $v0=`stringArrayRemove $verts $v0`;
    $verts[size($verts)]=$v0[0];
    }

    return	$verts;

}


/******************************************************************************
 * @procedure    FindifArraysContain
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $FirstList : string[]
 *   $array2 : string[]
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc int FindifArraysContain(string $FirstList[], string $array2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $found;
    int $Trigger;
    string $oneItemz = $each;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ($each in $FirstList){
    $oneItemz = $each;
    $found = stringArrayContains($oneItemz, $array2);
    if ( $found == 1 ){ $Trigger = 1; break; }
    }
    return $Trigger;

}


/******************************************************************************
 * @procedure    IfIntersect
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $ArrayA : string[]
 *   $ArrayB : string[]
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc int IfIntersect(string $ArrayA[], string $ArrayB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sizeofItems = size($findIntersection);
    string $myIntersector = `stringArrayIntersector`;
    string $findIntersection[] = `stringArrayIntersector -query $myIntersector`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $myIntersector = `stringArrayIntersector`;
    stringArrayIntersector -edit -intersect $ArrayA $myIntersector;
    stringArrayIntersector -edit -intersect $ArrayB $myIntersector;
    $findIntersection = `stringArrayIntersector -query $myIntersector`;
    stringArrayIntersector -edit -reset $myIntersector;
    $sizeofItems = size($findIntersection);
    return $sizeofItems;

}


/******************************************************************************
 * @procedure    PolyBorderEdges
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $polyZ : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] PolyBorderEdges(string $polyZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $PolyFaceZ = ( $polyZ[0] +".f[*]");
    string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
    string $PolyEdgesFromFaceZ[] = ls("-fl",polyListComponentConversion("-toEdge",$AllPolyFaceZ));
    string $SelectedPolyBorderEdgeZ[] = `ls -sl -fl`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyFaceZ = ( $polyZ[0] +".f[*]");
    $AllPolyFaceZ = `ls -fl $PolyFaceZ`;
    $PolyEdgesFromFaceZ = ls("-fl",polyListComponentConversion("-toEdge",$AllPolyFaceZ));
    select -r $PolyEdgesFromFaceZ;
    polyConvertToShellBorder;
    $SelectedPolyBorderEdgeZ = `ls -sl -fl`;
    return $SelectedPolyBorderEdgeZ;

}


/******************************************************************************
 * @procedure    GetdiffEdgesOfBorder
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $poly : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] GetdiffEdgesOfBorder(string $poly[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $PolyFaceZ = ( $poly[0] +".f[*]");
    string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
    string $PolyEdgesFromFaceZ[] = ls("-fl",polyListComponentConversion("-toEdge",$AllPolyFaceZ));
    string $SelectedPolyBorderEdgeZ[] = `ls -sl -fl`;
    string $diffEdgeZ[] = stringArrayRemoveExact($SelectedPolyBorderEdgeZ, $PolyEdgesFromFaceZ);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyFaceZ = ( $poly[0] +".f[*]");
    $AllPolyFaceZ = `ls -fl $PolyFaceZ`;
    $PolyEdgesFromFaceZ = ls("-fl",polyListComponentConversion("-toEdge",$AllPolyFaceZ));
    select -r $PolyEdgesFromFaceZ;
    polyConvertToShellBorder;
    $SelectedPolyBorderEdgeZ = `ls -sl -fl`;
    $diffEdgeZ = stringArrayRemoveExact($SelectedPolyBorderEdgeZ, $PolyEdgesFromFaceZ);
    select -r $diffEdgeZ;
    return $diffEdgeZ;

}


/******************************************************************************
 * @procedure    GetEdgeVertex
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $poly : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] GetEdgeVertex(string $poly[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $PolyFaceZ = ( $poly[0] +".f[*]");
    string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
    string $EdgePolyFaceZ[] = `ls -sl -fl`;
    string $PolyEdgelistA[] = ls("-fl",polyListComponentConversion("-border", "-toVertex", "-fromFace", $EdgePolyFaceZ));
    string $PolyEdgelistB[] = ls("-fl",polyListComponentConversion( "-toVertex", "-fromFace", $EdgePolyFaceZ));
    string $diffEdgeZ[] = stringArrayRemoveExact($PolyEdgelistA, $PolyEdgelistB);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyFaceZ = ( $poly[0] +".f[*]");
    $AllPolyFaceZ = `ls -fl $PolyFaceZ`;
    select -r $AllPolyFaceZ;
    polyConvertToShellBorder;
    ConvertSelectionToContainedEdges;
    ConvertSelectionToContainedFaces;
    $EdgePolyFaceZ = `ls -sl -fl`;
    $PolyEdgelistA = ls("-fl",polyListComponentConversion("-border", "-toVertex", "-fromFace", $EdgePolyFaceZ));
    select -r $PolyEdgelistA;
    $PolyEdgelistB = ls("-fl",polyListComponentConversion( "-toVertex", "-fromFace", $EdgePolyFaceZ));
    select -r $PolyEdgelistB;
    $diffEdgeZ = stringArrayRemoveExact($PolyEdgelistA, $PolyEdgelistB);
    select -r $diffEdgeZ;
    return $diffEdgeZ;

}


/******************************************************************************
 * @procedure    stringArrayGmatchIndex
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $itemA : string[]
 *   $list : string[]
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc int stringArrayGmatchIndex(string $itemA[], string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    int $ResultIndex = 0;
    int $Index = 0;
    string $item = $itemA[0];
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $item = $itemA[0];
    $result = false;
    $ResultIndex = 0;
    $Index = 0;
    for ($EachlistItem in $list) {
    if ( $EachlistItem == $item ){
    $result = true; $ResultIndex = $Index;
    break;	}
    $Index++;
    }
    return $ResultIndex;

}


/******************************************************************************
 * @procedure    mm_curveFromEdges
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] mm_curveFromEdges()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $len = size($edges);
    int $orderedEdgesIDs[];
    int $currentEdgePos = $firstHeadPos;
    int $jump = 0, $counter = 0, $max = size($edges)*size($edges);
    int $forstOrLast = 0, $orderedVerts[], $oeLen = size($orderedEdgesIDs);
    int $ovLen = size($orderedVerts);
    float $vertPos[] = `xform -a -ws -q -t ($sel[0]+".vtx["+$orderedVerts[0]+"]")`;
    string $sel[] = `selectedNodes`;
    string $edges[] = `filterExpand -sm 32`;
    string $infoVerts[];
    string $ret[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $sel = `selectedNodes`;
    if(size($sel)!=1)
    error "Select some contiguous edges, on one poly object";
    $edges = `filterExpand -sm 32`;
    $len = size($edges);
    if(!$len)
    error "Select some contiguous edges";
    for($i=0; $i<$len; $i++)
    {
    $infoVerts = `polyInfo -ev $edges[$i]`;
    $infoVerts = `stringToStringArray $infoVerts[0] " "`;
    $fVerts[$i] = $infoVerts[2];
    $lVerts[$i] = $infoVerts[3];
    }
    for($i=0; $i<$len; $i++)
    {
    $sticks[$i] = 0;
    for($j=0; $j<$len; $j++)
    {
    if(($j!=$i))
    {
    if(($fVerts[$i]==$fVerts[$j]) || ($lVerts[$i]==$lVerts[$j]) || ($fVerts[$i]==$lVerts[$j]) || ($lVerts[$i]==$fVerts[$j]))
    $sticks[$i]+=1;
    }
    }
    if(($sticks[$i]<1) || ($sticks[$i]>2))
    error "Select some contiguous edges";
    }
    $firstHeadPos = 0;
    $headsNr = 0;
    for($i=0; $i<$len; $i++)
    {
    if($sticks[$i] == 1)
    {
    $headsNr++;
    if($headsNr>2)
    error "Select some contiguous edges";
    $firstHeadPos = $i;
    }
    }
    $orderedEdgesIDs[0] = $firstHeadPos;
    $currentEdgePos = $firstHeadPos;
    $jump = 0, $counter = 0, $max = size($edges)*size($edges);
    while(size($orderedEdgesIDs)<$len)
    {
    for($i=0; $i<$len; $i++)
    {
    for($j=0; $j<size($orderedEdgesIDs); $j++)
    if($orderedEdgesIDs[$j] == $i)
    {
    $jump = 1;
    break;
    }
    if(!$jump)
    {
    if(($fVerts[$i]==$fVerts[$currentEdgePos]) || ($lVerts[$i]==$lVerts[$currentEdgePos]) || ($fVerts[$i]==$lVerts[$currentEdgePos]) || ($lVerts[$i]==$fVerts[$currentEdgePos]))
    {
    $currentEdgePos = $i;
    $orderedEdgesIDs[size($orderedEdgesIDs)] = $i;
    }
    }
    $jump = 0;
    $counter++;
    }
    if($counter>=$max)
    break;
    }
    $forstOrLast = 0, $orderedVerts[], $oeLen = size($orderedEdgesIDs);

    if(($fVerts[$orderedEdgesIDs[0]] == $fVerts[$orderedEdgesIDs[1]]) || ($fVerts[$orderedEdgesIDs[0]] == $lVerts[$orderedEdgesIDs[1]]))
    $orderedVerts[0] = $lVerts[$orderedEdgesIDs[0]];
    else if(($lVerts[$orderedEdgesIDs[0]] == $fVerts[$orderedEdgesIDs[1]]) || ($lVerts[$orderedEdgesIDs[0]] == $lVerts[$orderedEdgesIDs[1]]))
    $orderedVerts[0] = $fVerts[$orderedEdgesIDs[0]];

    for($i=0; $i<$oeLen-1; $i++)
    {
    if(($fVerts[$orderedEdgesIDs[$i]] == $fVerts[$orderedEdgesIDs[$i+1]]) || ($fVerts[$orderedEdgesIDs[$i]] == $lVerts[$orderedEdgesIDs[$i+1]]))
    $orderedVerts[size($orderedVerts)] = $fVerts[$orderedEdgesIDs[$i]];
    else if(($lVerts[$orderedEdgesIDs[$i]] == $fVerts[$orderedEdgesIDs[$i+1]]) || ($lVerts[$orderedEdgesIDs[$i]] == $lVerts[$orderedEdgesIDs[$i+1]]))
    $orderedVerts[size($orderedVerts)] = $lVerts[$orderedEdgesIDs[$i]];
    }
    $ovLen = size($orderedVerts);
    if($fVerts[$orderedEdgesIDs[$oeLen-1]] == $orderedVerts[$ovLen-1])
    {
    $orderedVerts[$ovLen] = $lVerts[$orderedEdgesIDs[$oeLen-1]];
    $ovLen++;
    }
    else if($lVerts[$orderedEdgesIDs[$oeLen-1]] == $orderedVerts[$ovLen-1])
    {
    $orderedVerts[$ovLen] = $fVerts[$orderedEdgesIDs[$oeLen-1]];
    $ovLen++;
    }

    $vertPos = `xform -a -ws -q -t ($sel[0]+".vtx["+$orderedVerts[0]+"]")`;
    $curve = `curve -d 1 -p $vertPos[0] $vertPos[1] $vertPos[2]`;
    if($orderedVerts[0] != $orderedVerts[$ovLen-1])
    {
    for($i=1; $i<$ovLen; $i++)
    {
    $vertPos = `xform -a -ws -q -t ($sel[0]+".vtx["+$orderedVerts[$i]+"]")`;
    curve -a -p $vertPos[0] $vertPos[1] $vertPos[2] $curve;
    }
    $ret[1] = "open";
    }
    else
    {
    for($i=1; $i<$ovLen-1; $i++)
    {
    $vertPos = `xform -a -ws -q -t ($sel[0]+".vtx["+$orderedVerts[$i]+"]")`;
    curve -a -p $vertPos[0] $vertPos[1] $vertPos[2] $curve;
    }
    closeCurve -ch 0 -ps 0 -rpo 1 -bb 0.5 -bki 0 -p 0.1 $curve;
    $ret[1] = "closed";
    }
    $ret[0] = $curve;
    return $ret;

}


/******************************************************************************
 * @procedure    mm_extractCurveFromEdges
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $degree : int
 *
 * @returns      string
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string mm_extractCurveFromEdges(int $degree)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $curve[] = `mm_curveFromEdges`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $curve = `mm_curveFromEdges`;
    if($degree == 1)
    {
    select -r $curve[0];
    return $curve[0];
    }
    else if($degree == 3)
    {
    if($curve[1] == "open")
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 1 -kep 1 -kt 0 -s 4 -d 3 -tol 0 $curve[0];
    if($curve[1] == "closed")
    {
    closeCurve -ch 1 -ps 0 -rpo 1 -bb 0.5 -bki 0 -p 0.1 $curve[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 1 -kep 1 -kt 0 -s 4 -d 3 -tol 0 $curve[0];
    closeCurve -ch 1 -ps 0 -rpo 1 -bb 0.5 -bki 0 -p 0.1 $curve[0];
    }
    select -r $curve[0];
    return $curve[0];
    }
    else
    error ("Degree not suported: "+$degree+". Use only 1 or 3.");

}


/******************************************************************************
 * @procedure    SortEvenArrays
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $ArrayItems : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SortEvenArrays(string $ArrayItems[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $getsize = size($ArrayItems);
    int $i = 0;
    string $newItemsList[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $getsize = size($ArrayItems);
    $i = 0;
    $iX = 0;
    while($i < $getsize){
    $iX++;
    if ( $iX == 2){
    string $oneitem[0] = {$ArrayItems[$i]};
    appendStringArray($newItemsList, $oneitem, 1);
    $iX = 0;
    }
    $i++;
    }
    return $newItemsList;

}


/******************************************************************************
 * @procedure    ArrayFromAllinString
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $list : string
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] ArrayFromAllinString(string $list)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i = 0;
    int $Indexi = 0;
    int $triggerends = 0;
    string $singleStringItemB[];
    string $singleStringItemA[];
    string $listA = $list;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $i = 0;
    $Indexi = 0;
    $triggerends = 0;
    $listA = $list;
    while ( $triggerends < 1 ) {
    $i++;
    $singleStringItemA = {`substring $listA $i $i`};
    if (size($singleStringItemA[0]) == 0){
    $triggerends = 2; } else {
    appendStringArray($singleStringItemB, $singleStringItemA, 1);
    }
    $Indexi++;
    if ($Indexi == 20){ $triggerends = 2;}
    }
    return $singleStringItemB;

}


/******************************************************************************
 * @procedure    ArrayToIntList
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $singleStringItemB : string[]
 *
 * @returns      int[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int[] ArrayToIntList(string $singleStringItemB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Numberlist[];
    int $triggerendsB = 0;
    int $newlistSize = size($singleStringItemB);
    int $ci = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $triggerendsB = 0;
    $newlistSize = size($singleStringItemB);
    $ci = 0;
    while ( $triggerendsB < $newlistSize ) {
    $Numberlist[$ci] = $singleStringItemB[$ci];
    $ci++;
    $triggerendsB = $triggerendsB + 1;
    }
    print $Numberlist;
    return $Numberlist;

}


/******************************************************************************
 * @procedure    CycleNumberString
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $singleStringItemC : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CycleNumberString(string $singleStringItemC[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArray;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArray = size($singleStringItemC) -1;
    string $last[0] = {$singleStringItemC[$SizeOfArray]};
    string $first[0] = {$singleStringItemC[0]};
    stringArrayRemoveAtIndex(0, $singleStringItemC);
    appendStringArray($singleStringItemC, $first, 1);
    return $singleStringItemC;

}


/******************************************************************************
 * @procedure    SortPatternArrays
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $ArrayItems : string[]
 *   $NumberlistA : int[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SortPatternArrays(string $ArrayItems[], int $NumberlistA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $getsizeNlist = size($NumberlistA);
    int $iN = 0;
    int $getsize = size($ArrayItems);
    int $i = 0;
    string $newItemsList[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $getsizeNlist = size($NumberlistA);
    $iN = 0;
    $getsize = size($ArrayItems);
    $i = 0;
    $iX = 0;
    while($i < $getsize){
    $iX++;
    if ( $NumberlistA[$iN] == 0){
    string $oneitem[0] = {$ArrayItems[$i]};
    appendStringArray($newItemsList, $oneitem, 1);
    if ( $iN == $getsizeNlist){ $iN = -1;}
    $iX = 0;
    }

    $iN++;
    $i++;
    }
    return $newItemsList;

}


/******************************************************************************
 * @procedure    CompareCurveIntersect
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $objectLoc : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersect(string $objectLoc[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectLocZ) -1;
    int $Z = size($objectLocZ);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    string $objectLocZ[];
    string $CurveintersectZ;
    string $ItemLists[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $objectLocZ = $objectLoc;
    $X = size($objectLocZ) -1;
    $Z = size($objectLocZ);
    $i = 1;
    $n = -1;
    $n2 = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){
    $CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2]`;
    if (size($CurveintersectZ) > 0) {
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
    } else { print "no Intersect"; }
    $n2++;
    }
    }
    return $ItemLists;

}


/******************************************************************************
 * @procedure    CompareCurveIntersectTwoCurves
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $objectLocA : string[]
 *   $objectAll : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersectTwoCurves(string $objectLocA[], string $objectAll[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Z = size($objectLocA) -1;
    int $X = size( $objectAll) -1;
    int $ix = 0;
    int $n2 = 0;
    string $CurveintersectZA;
    string $CurveintersectZB;
    string $ItemLists[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $Z = size($objectLocA) -1;
    $X = size( $objectAll) -1;
    $ix = 0;
    $n2 = 0;

    while ($X > $ix++){
    $CurveintersectZA = `curveIntersect -ch 0 -tolerance 0.001 $objectLocA[0] $objectAll[$n2]`;
    if (size($CurveintersectZA) > 0) {
    $CurveintersectZB = `curveIntersect -ch 0 -tolerance 0.001 $objectLocA[1] $objectAll[$n2]`;
    if (size($CurveintersectZB) > 0) {
    ArrayInsertAtEnd( $ItemLists, $objectAll[$n2]);
    }
    } else { print "no Intersect"; }
    $n2++;

    }
    return $ItemLists;

}


/******************************************************************************
 * @procedure    CompareCurveIntersect4
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $objectLoc : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersect4(string $objectLoc[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectLocZ) -1;
    int $Z = size($objectLocZ);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    string $objectLocZ[];
    string $CurveintersectZ;
    string $ItemLists[];
    string $shorterList[] = stringArrayRemoveDuplicates($ItemLists);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $objectLocZ = $objectLoc;
    $X = size($objectLocZ) -1;
    $Z = size($objectLocZ);
    $i = 1;
    $n = -1;
    $n2 = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){
    $CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2]`;
    if (size($CurveintersectZ) > 0) {
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
    } else { print "no Intersect"; }
    $n2++;
    }
    }

    $shorterList = stringArrayRemoveDuplicates($ItemLists);
    $ItemLists = $shorterList;
    return $ItemLists;

}


/******************************************************************************
 * @procedure    CompareCurveIntersect2
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $object : string[]
 *   $objectlist : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersect2(string $object[], string $objectlist[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectlist);
    string $ItemListsA[];
    string $CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $object[0] $objectlist[$ix]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $X = size($objectlist);

    $ix = 0;
    $iz = 1;
    while ($X > $ix++){

    $CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $object[0] $objectlist[$ix]`;
    if (size($CurveintersectZ) > 0) {
    ArrayInsertAtEnd( $ItemListsA, $objectlist[$ix]);
    }
    }
    return $ItemListsA;

}


/******************************************************************************
 * @procedure    CompareCurveIntersect5
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $objectLoc : string[]
 *   $objectLocB : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersect5(string $objectLoc[], string $objectLocB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectLocZ);
    int $Z = size($objectLocB);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    string $objectLocZ[];
    string $CurveintersectZ;
    string $ItemLists[];
    string $shorterList[] = stringArrayRemoveDuplicates($ItemLists);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $objectLocZ = $objectLoc;

    $X = size($objectLocZ) ;

    $Z = size($objectLocB);
    $i = 1;
    $n = -1;
    $n2 = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){
    $CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $objectLocZ[$n] $objectLocB[$n2]`;
    if (size($CurveintersectZ) > 0) {
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
    } else { print "no Intersect"; }
    $n2++;
    }
    }

    $shorterList = stringArrayRemoveDuplicates($ItemLists);
    $ItemLists = $shorterList;
    return $ItemLists;

}


/******************************************************************************
 * @procedure    CIRCLESCRIPTZ
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $ObjectCurve : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CIRCLESCRIPTZ(string $ObjectCurve[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $squareA;
    int $squareB;
    float $rotationz[];
    float $translationz[];
    float $bbox[] = `exactWorldBoundingBox $ObjectCurveduplicate`;
    float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox[2]};
    float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox[5]};
    float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox[2]};
    float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox[5]};
    float $BoxMPointAC[] = MidPointBetween($BoxPointA, $BoxPointC);
    float $BoxMPointBD[] = MidPointBetween($BoxPointB, $BoxPointD);
    float $BoxMPointAD[] = MidPointBetween($BoxPointA, $BoxPointD);
    float $BoxMPointBC[] = MidPointBetween($BoxPointB, $BoxPointC);
    float $CrossMPointAB[] = MidPointBetween($BoxPointA, $BoxPointB);
    float $translationzMiddle[];
    float $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    float $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);
    float $squarePercentA;
    float $squarePercentB;
    string $CIRCLEX[];
    string $ObjectCurveduplicate[] = `duplicate -rr $ObjectCurve`;
    string $NewNameZ = `rename $CIRCLEX "Curve"`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //CIRCLE SCRIPT


    //string $newCircle[] = `CIRCLESCRIPTZ($drawcurve)`;
    //string $ObjectCurve[] = $drawcurve;

    $ObjectCurveduplicate = `duplicate -rr $ObjectCurve`;
    setAttr ($ObjectCurveduplicate[0] + ".translate") 0 0 0;
    setAttr ($ObjectCurveduplicate[0] + ".rotate") 0 0 0;
    select -cl  ;
    $rotationz = `xform -q -rotation $ObjectCurve`;
    $translationz = `xform -q -translation $ObjectCurve`;
    $bbox = `exactWorldBoundingBox $ObjectCurveduplicate`;
    //print("Bounding box ranges from: " +
    //      $bbox[0] + "," + $bbox[1] + "," + $bbox[2] + ", to " +
    //      $bbox[3] + "," + $bbox[4] + "," + $bbox[5] + ".\n");
    spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
    move -ws $bbox[0] $bbox[1] $bbox[2] BoxspaceLocatorA;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
    move -ws $bbox[3] $bbox[4] $bbox[5] BoxspaceLocatorB;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
    move -ws $bbox[3] $bbox[1] $bbox[2] BoxspaceLocatorC;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
    move -ws $bbox[0] $bbox[4] $bbox[5] BoxspaceLocatorD;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;
    // xform -query -worldSpace -translation;
    /////////////////////////////////////////
    $BoxPointA = {$bbox[0], $bbox[1], $bbox[2]};
    $BoxPointB = {$bbox[3], $bbox[4], $bbox[5]};
    $BoxPointC = {$bbox[3], $bbox[1], $bbox[2]};
    $BoxPointD = {$bbox[0], $bbox[4], $bbox[5]};

    $BoxPointA = `MakeCleanFloats($BoxPointA)`;
    $BoxPointB = `MakeCleanFloats($BoxPointB)`;
    $BoxPointC = `MakeCleanFloats($BoxPointC)`;
    $BoxPointD = `MakeCleanFloats($BoxPointD)`;

    $BoxMPointAC = MidPointBetween($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween($BoxPointB, $BoxPointC);
    //   MoveObjectSelection($BoxMPointAC);

    $BoxMPointAC = MidPointBetween($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween($BoxPointB, $BoxPointC);

    $CrossMPointAB = MidPointBetween($BoxPointA, $BoxPointB);
    move -ws $bbox[0] $bbox[4] $bbox[5] BoxspaceLocatorD;
    $translationzMiddle = `xform -q -translation BoxspaceLocatorMiddle`;

    $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);
    $distanceAverage =  (($distanceA + $distanceB) * (0.5)) ;
    $radiusX = ( $distanceAverage / 2);
    //if / then
    if ( $distanceA > $distanceAverage) {
    $squarePercentA = (( $distanceAverage / $distanceA ) * (100));
    }
    if ( $distanceA < $distanceAverage) {
    $squarePercentA = (( $distanceA / $distanceAverage ) * (100));
    }
    if ( $distanceB > $distanceAverage) {
    $squarePercentB = (( $distanceAverage / $distanceB ) * (100));
    }
    if ( $distanceB < $distanceAverage) {
    $squarePercentB = (( $distanceB / $distanceAverage ) * (100));
    }
    /////////////////////
    $squareA = 0;
    $squareB = 0;
    print $squarePercentA ;
    if ( $squarePercentA > 55)  {
    $squareA = (0 + 1);
    } else {
    $squareA = (0);
    }
    print $squareA;
    print $squarePercentB ;
    if ( $squarePercentB > 55)  {
    $squareB = ($squareB + 1);
    } else {
    $squareB = (0);
    }
    $addSquareResults = ($squareA + $squareB);
    if ( $addSquareResults == 2 ){
    circle -nr 0 1 0 -c $translationzMiddle[0] $translationzMiddle[1] $translationzMiddle[2] -r $radiusX;
    $CIRCLEX = `ls -sl`;
    $rotationz = `xform -q -rotation $ObjectCurve`;
    setAttr ($CIRCLEX[0] + ".rotateX") $rotationz[0];
    setAttr ($CIRCLEX[0] + ".rotateY") $rotationz[1];
    setAttr ($CIRCLEX[0] + ".rotateZ") $rotationz[2];
    $translationz = `xform -q -translation $ObjectCurve[0]`;
    setAttr ($CIRCLEX[0] + ".translateX") $translationz[0];
    setAttr ($CIRCLEX[0] + ".translateY") $translationz[1];
    setAttr ($CIRCLEX[0] + ".translateZ") $translationz[2];
    //TEMP CHANGE
    //string $currPanel = `getPanel -withFocus` , $camera ;
    //$camera = `modelPanel -q -camera $currPanel`;
    //setAttr ($CIRCLEX[0] + ".rotate") `getAttr ($ObjectCurve[0] + ".rotate")`;
    delete $ObjectCurve $ObjectCurveduplicate BoxspaceLocatorA BoxspaceLocatorB BoxspaceLocatorC BoxspaceLocatorD BoxspaceLocatorMiddle;
    }
    else {
    delete $ObjectCurveduplicate BoxspaceLocatorA BoxspaceLocatorB BoxspaceLocatorC BoxspaceLocatorD BoxspaceLocatorMiddle;
    }
    $NewNameZ = `rename $CIRCLEX "Curve"`;
    $CIRCLEX = {$NewNameZ};
    return $CIRCLEX;


}


/******************************************************************************
 * @procedure    Make_Middle_of_Curve_ParamlocatorZ
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $objectCurveSelected : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Make_Middle_of_Curve_ParamlocatorZ(string $objectCurveSelected[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $a = 1;
    float $arclenghtzALL = `arclen $objectCurveSelected`;
    float $arclenghtzDivide = $arclenghtzALL / 2.0;
    float $step = 10;
    float $t = $a/$step;
    float $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    float $divZZ = $arclenghtzDivide / $arclenghtzparamZ;
    float $divZZ2 = $t * $divZZ;
    float $posA[];
    float $posB[];
    float $posC[];
    string $paramlocatorZARC[];
    string $paramANDCurve[] = `paramToCurvePts( $paramlocatorZARC )`;
    string $CircularArcFromCurve[];
    string $ArcCurve[];
    string $ParentArc[];
    string $MakeArcLocator[];
    string $ArcZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $arclenghtzALL = `arclen $objectCurveSelected`;
    $arclenghtzDivide = $arclenghtzALL / 2.0;

    $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectCurveSelected[0] + ".cv[0]") ;
    $CurveSelection[1] = ($objectCurveSelected[0] + ".cv[" + $numCVrealNum + "]") ;
    $paramlocatorZARC[0] = eval("paramLocator " +  $objectCurveSelected[0] + ".u[" + 0.0 + "]");

    $step = 10;
    $a = 1;
    $t = $a/$step;

    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $t;
    $paramANDCurve = `paramToCurvePts( $paramlocatorZARC )`;
    $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;

    $divZZ = $arclenghtzDivide / $arclenghtzparamZ ;
    $divZZ2 = $t * $divZZ ;
    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $divZZ2;
    ////////////////////// Moved ParamLoc to middle

    $posA = `pointPosition -w $CurveSelection[0]`;
    $posB = `pointPosition -w $paramlocatorZARC[0]`;
    $posC = `pointPosition -w $CurveSelection[1]`;
    $CircularArcFromCurve[0] = `createNode makeThreePointCircularArc`;
    setAttr ($CircularArcFromCurve[0] + ".pt1") $posA[0] $posA[1] $posA[2] ;
    setAttr ($CircularArcFromCurve[0] + ".pt2") $posB[0] $posB[1] $posB[2];
    setAttr ($CircularArcFromCurve[0] + ".pt3") $posC[0] $posC[1] $posC[2];
    setAttr ($CircularArcFromCurve[0] + ".d") 3;
    setAttr ($CircularArcFromCurve[0] + ".s") 8;
    $ArcCurve[0] = `createNode nurbsCurve` ;
    connectAttr ($CircularArcFromCurve[0] + ".oc") ($ArcCurve[0] +".cr");
    //delete $objectCurveSelected;
    $ParentArc = `listRelatives -parent $ArcCurve`;
    ResetTranlation($ParentArc);
    $MakeArcLocator = `spaceLocator -p 0 0 0 -n ArcLocator`;
    move -ws $posB[0] $posB[1] $posB[2] $MakeArcLocator;
    $ConnectLocToPoint2 = `connectAttr -f ($MakeArcLocator[0] + ".translate") ( $CircularArcFromCurve[0] + ".pt2")`;

    $ArcZ[0] = `rename $ParentArc $objectCurveSelected`;
    delete $paramlocatorZARC;
    select -r $ArcZ;
    return $ArcZ;


}


/******************************************************************************
 * @procedure    Strait_ARC_or_FreeForm
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $renamed : string[]
 *   $ArcN : float
 *   $StraitN : float
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Strait_ARC_or_FreeForm(string $renamed[], float $ArcN, float $StraitN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $free = 0;
    int $straitTrigger = 0;
    int $Cvz = $objectAcurveD01;
    int $Cvz2 = $objectAcurveD02;
    float $objectAcurve01 = arclen ($renamed);
    float $curveEndsDis01 = GetDistanceBetweenCurveEnds($renamed);
    float $PercentENDsDiffL = XpercentLess_thenY($objectAcurve01, $curveEndsDis01);
    float $objectAcurveD01 = $objectAcurve01 / 1.5;
    float $PercentDiffS;
    float $posA[] = $VectorCurveEndZ[0];
    float $posB[] = $VectorCurveEndZ[1];
    float $objectAcurveL = arclen ($renamed);
    float $objectBcurveL = arclen ($objectB);
    float $PercentDiffL = XpercentLess_thenY($objectBcurveL, $objectAcurveL);
    float $objectAcurve02 = arclen ($renamed);
    float $objectAcurveD02 = $objectAcurve02 / 1.5;
    string $nameString = $renamed[0];
    string $ParentArc[];
    string $objectB[];
    string $objectC[];
    string $DeleteCurveA[];
    string $DeleteCurveB[];
    string $CurveBetween[];
    vector $VectorCurveEndZ[] = VecCurveEnds($renamed);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $free = 0;
    $nameString = $renamed[0];
    //smoothCurve -ch 1 -rpo 1 -s 6.60 ($nameString +".cv[*]");
    $objectAcurve01 = arclen ($renamed);

    $curveEndsDis01 = GetDistanceBetweenCurveEnds($renamed);
    $PercentENDsDiffL = XpercentLess_thenY($objectAcurve01, $curveEndsDis01);
    $straitTrigger = 0;

    if ( $PercentENDsDiffL < 2 ){ $straitTrigger = 1; }

    $objectAcurveD01 = $objectAcurve01 / 1.5;
    $Cvz = $objectAcurveD01;
    if( $objectAcurve01 < 1.0){ $Cvz = 4; }
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001 $renamed;




    if ($straitTrigger == 1){
    $VectorCurveEndZ = VecCurveEnds($renamed);
    $posA = $VectorCurveEndZ[0];
    $posB = $VectorCurveEndZ[1];
    $CurveBetween = MakeCurveBetweenFloats($posA, $posB);
    ResetTranlation($CurveBetween);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001 $CurveBetween;
    $ParentArc = $CurveBetween; $DeleteCurveA = $renamed; $DeleteCurveB = $objectB;
    }


    if ( $straitTrigger == 0 ){
    $objectB = Make_Middle_of_Curve_ParamlocatorZ($renamed);
    ResetTranlation($objectB);
    $objectC = {$renamed[0], $objectB[0]};
    ResetTranlationEach($objectC);
    $objectAcurveL = arclen ($renamed);
    $objectBcurveL = arclen ($objectB);
    $PercentDiffL = XpercentLess_thenY($objectBcurveL, $objectAcurveL);
    if ($PercentDiffL  < $ArcN){

    $ParentArc = $objectB;  $DeleteCurveA = $renamed;
    }else{

    $free = 1;
    $ParentArc = $renamed; $DeleteCurveA = $objectB; }

    }

    delete $DeleteCurveA;
    rename $ParentArc $nameString;
    $ParentArc[0] = $nameString;


    if ( $free == 1 ){ select -r $ParentArc; EvalSmoothCurves;
    $nameString = $ParentArc[0];
    $objectAcurve02 = arclen ($renamed);
    $objectAcurveD02 = $objectAcurve02 / 1.5;
    $Cvz2 = $objectAcurveD02;
    if( $objectAcurve01 < 1.0){ $Cvz2 = 4; }
    //rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001 $renamed;
    }

    return $ParentArc;


}


/******************************************************************************
 * @procedure    SmoothCurvature4
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $curveM : float
 *   $Steps : int
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvature4(float $curveM, int $Steps)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 3 );
    int $trigger = 0;
    int $Par = 0;
    int $a;
    int $ii = 0;
    int $CVpoints = 0;
    float $curveMin = $curveM;
    float $step = $numEPrealNum2;
    float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = {$Newcurvez};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $myCurve = $curves[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp 1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv[*]");
    $CurveSelection = `ls -fl ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 3 );
    if ($Steps > 8 ){ $numEPrealNum2 = $Steps; }

    $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
    $trigger = 0;
    $curve = "";
    $curveMin = $curveM;
    while ( $trigger < 1 ){
    $step = $numEPrealNum2;
    $curve = "curve -d 3";

    $Par = 0;
    $ii = 0;
    $CVpoints = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
    $values = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    if ( $CurvatureRadi <= $curveMin){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    if (( $CurvatureRadi > $curveMin) && ( $ii == 1 )){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par == 1.0 )){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    }
    if ( $CVpoints < 8 ){ $curveMin++; }
    if ( $CVpoints >= 8 ){ $trigger = 1; }

    }

    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    rename $Newcurve $myCurve;
    $Newcurve = {$myCurve};

    return $Newcurve;

}


/******************************************************************************
 * @procedure    SmoothCurvature13
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $curveM : float
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvature13(float $curveM)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 1 );
    int $trigger = 0;
    int $Par = 0;
    int $b = 0;
    int $ii = 0;
    int $a = 0;
    int $CVpoints = 0;
    float $arcL1 = `arclen $curves[0]`;
    float $arcL1B = ( $arcL1 + ((-1) * ( $arcL1 / 10 )));
    float $curveMin = $curveM;
    float $CurvatureRadi2;
    float $step = $numEPrealNum2;
    float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    float $AverageCurvatureRadi = (($CurvatureRadi + $CurvatureRadi2) / 2);
    float $arcL2 = `arclen $Newcurve[0]`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $crShape[] = `listRelatives -s $curves[0]`;
    string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size ($CurveSelection);
    string $Newcurve[];
    string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`;
    string $Newcurvez;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $arcL1 = `arclen $curves[0]`;
    $arcL1B = ( $arcL1 + ((-1) * ( $arcL1 / 10 )));
    $myCurve = $curves[0];
    $crShape = `listRelatives -s $curves[0]`;
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp 1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv[*]");
    $CurveSelection = `ls -fl ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 1 );
    $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
    $trigger = 0;
    $curve = "";
    $Par = 0;
    $b = 0;
    $ii = 0;
    $a = 0;
    $curveMin = $curveM;
    while ( $trigger < 1 ){
    $step = $numEPrealNum2;
    $curve = "curve -d 3";
    $CVpoints = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = $a/$step;
    setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
    if ( $Par > 0.0 ){ $b = $a -1; $Par2 = $b/$step;
    $CurvatureRadi2 = `pointOnCurve -top 1 -pr $Par2 -cr $crShape[0]`; }
    $values = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;

    $AverageCurvatureRadi = (($CurvatureRadi + $CurvatureRadi2) / 2);

    if ( $AverageCurvatureRadi <= $curveMin){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    if (( $CurvatureRadi > $curveMin) && ( $ii == 1 )){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par == 1.0 )){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    }
    if ( $CVpoints < 8 ){ $curveMin++; }
    if ( $CVpoints > 2 ){
    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    $arcL2 = `arclen $Newcurve[0]`;
    if ( $arcL2 < $arcL1B ){ delete $Newcurve; $trigger = 0; $numEPrealNum2 = $numEPrealNum2 + 3;   }
    if (( $CVpoints >= 8 )&& ( $arcL2 > $arcL1B )){ $trigger = 1; }
    }
    }

    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    rename $Newcurve $myCurve;
    $Newcurve = {$myCurve};

    return $Newcurve;

}


/******************************************************************************
 * @procedure    SmoothCurvature3
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $curveM : float
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvature3(float $curveM)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 2 );
    int $Par = 0;
    int $a;
    int $ii = 0;
    float $step = $numEPrealNum2;
    float $curveMin = $curveM;
    float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = {$Newcurvez};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $myCurve = $curves[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp 1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv[*]");
    $CurveSelection = `ls -fl ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 2 );
    //Above was Times * 4

    $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
    $step = $numEPrealNum2;
    $curve = "curve -d 3";
    $curveMin = $curveM;
    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
    $values = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    if ( $CurvatureRadi <= $curveMin){ PAUSE;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    if (( $CurvatureRadi > $curveMin) && ( $ii == 1 )){
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }


    if (( $CurvatureRadi > $curveMin) && ( $Par == 1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    }

    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    rename $Newcurve $myCurve;
    $Newcurve = {$myCurve};

    return $Newcurve;

}


/******************************************************************************
 * @procedure    SmoothCurvatureReverse6
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $curveM : float
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvatureReverse6(float $curveM)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 2 );
    int $Par = 0;
    int $a;
    int $ii = 0;
    float $step = $numEPrealNum2;
    float $curveMin = $curveM;
    float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = {$Newcurvez};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $myCurve = $curves[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp 1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv[*]");
    $CurveSelection = `ls -fl ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 2 );
    //Above was Times * 4

    $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
    $step = $numEPrealNum2;
    $curve = "curve -d 3";
    $curveMin = $curveM;
    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
    $values = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    if ( $CurvatureRadi >= $curveMin){
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    if (( $CurvatureRadi < $curveMin) && ( $ii == 1 )){
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }


    if (( $CurvatureRadi < $curveMin) && ( $Par == 1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    }

    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    rename $Newcurve $myCurve;
    $Newcurve = {$myCurve};

    return $Newcurve;

}


/******************************************************************************
 * @procedure    XpercentLess_thenY
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $Ix : float
 *   $Iy : float
 *
 * @returns      float
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float XpercentLess_thenY(float $Ix, float $Iy)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $N;
    float $Ni;
    float $PercentA;
    float $PercentB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if ( $Ix > $Iy){
    $Ni = $Ix; $N = $Iy; } else { $N = $Ix;  $Ni = $Iy; }
    $PercentA = ((float($N) / $Ni) * (100) );
    $PercentB = 100 - $PercentA;
    return $PercentB;

}


/******************************************************************************
 * @procedure    Strait_ARC_or_FreeFormFind
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $renamed : string[]
 *   $ArcN : float
 *   $StraitN : float
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int Strait_ARC_or_FreeFormFind(string $renamed[], float $ArcN, float $StraitN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SAF = 0;
    float $objectAcurve = GET_AREA_OF_CURVE ($renamed);
    float $objectBcurve = GET_AREA_OF_CURVE ($objectB);
    float $PercentDiff = XpercentLess_thenY($objectBcurve, $objectAcurve);
    float $objectAcurveL = arclen ($renamed);
    float $objectBcurveL = arclen ($objectB);
    float $PercentDiffL = XpercentLess_thenY($objectBcurveL, $objectAcurveL);
    float $PercentAverage = ($PercentDiff + $PercentDiffL) /2;
    float $posA[] = $VectorCurveEndZ[0];
    float $posB[] = $VectorCurveEndZ[1];
    float $objectCcurveL = arclen ($CurveBetween);
    float $PercentDiffS = XpercentLess_thenY($objectCcurveL, $objectAcurveL);
    string $nameString = $renamed[0];
    string $ParentArc[];
    string $objectB[] = Make_Middle_of_Curve_ParamlocatorZ($renamed);
    string $objectC[] = {$renamed[0], $objectB[0]};
    string $CurveBetween[] = MakeCurveBetweenFloats($posA, $posB);
    string $DeleteCurveA[];
    string $DeleteCurveB[];
    vector $VectorCurveEndZ[] = VecCurveEnds($renamed);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $SAF = 0;
    $nameString = $renamed[0];
    //rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001 $renamed;
    $objectB = Make_Middle_of_Curve_ParamlocatorZ($renamed);
    ResetTranlation($objectB);
    $objectC = {$renamed[0], $objectB[0]};
    ResetTranlationEach($objectC);
    $objectAcurve = GET_AREA_OF_CURVE ($renamed);
    $objectBcurve = GET_AREA_OF_CURVE ($objectB);
    /////////////////////////

    $PercentDiff = XpercentLess_thenY($objectBcurve, $objectAcurve);

    $objectAcurveL = arclen ($renamed);
    $objectBcurveL = arclen ($objectB);
    $PercentDiffL = XpercentLess_thenY($objectBcurveL, $objectAcurveL);
    $PercentAverage = ($PercentDiff + $PercentDiffL) /2;

    $VectorCurveEndZ = VecCurveEnds($renamed);
    $posA = $VectorCurveEndZ[0];
    $posB = $VectorCurveEndZ[1];
    $CurveBetween = MakeCurveBetweenFloats($posA, $posB);
    ResetTranlation($CurveBetween);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001 $CurveBetween;
    $objectCcurveL = arclen ($CurveBetween);
    $PercentDiffS = XpercentLess_thenY($objectCcurveL, $objectAcurveL);
    print ("PercentDiff_Curve_to_Arc AREA "+$PercentDiff + "\n");
    print ("PercentDiff_Curve_to_Arc L "+$PercentDiffL + "\n");
    print (" " + "\n");
    print ("PercentDiff_Curve_to_Arc Average "+$PercentAverage + "\n");
    print (" " + "\n");
    print ("PercentDiff_Curve_to_STRAIT "+$PercentDiffS + "\n");


    if (($PercentAverage< $ArcN) && ($PercentDiffS > $StraitN)){
    print ("ARC Curve"+ "\n"); $SAF = 0;

    }else if ($PercentDiffS < $StraitN){
    print ("STRAIT Curve"+ "\n"); $SAF = 1;

    } else {
    print ("FREEFORM Curve"+ "\n"); $SAF = 2;
    }

    delete $CurveBetween  $objectB;

    return $SAF;


}


/******************************************************************************
 * @procedure    AddorSubtract
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $Number : int
 *   $AorS : int
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int AddorSubtract(int $Number, int $AorS)
{


    if ($AorS == 1){ $Number++; return $Number;}
    if ($AorS == 0){ $Number--; return $Number;}
    if ($AorS == 2){ $Number = 0; return $Number;}


}


/******************************************************************************
 * @procedure    RoundFloat
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $val : float
 *   $dec : float
 *
 * @returns      float
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float RoundFloat(float $val, float $dec)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $dec = `pow 10 $dec`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $sign = `sign $val`;
    $dec = `pow 10 $dec`;
    $val = (int) (($val + $sign*5/($dec*10)) * $dec);
    $val = ($val / $dec);
    return $val;

}


/******************************************************************************
 * @procedure    IsCircle
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int IsCircle()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IsCircle = 0;
    int $pA1 = PointsEquivalentTol($CurveCVzero,$BoxPointA);
    int $pA2 = PointsEquivalentTol($CurveCVLast,$BoxPointA);
    int $pC1 = PointsEquivalentTol($CurveCVzero,$BoxPointC);
    int $pC2 = PointsEquivalentTol($CurveCVLast,$BoxPointC);
    int $AorC = 0;
    int $squareA = 0;
    int $squareB = 0;
    float $rotationz[];
    float $translationz[];
    float $ArcLength = `arclen $ObjectCurve[0]`;
    float $bbox[] = `exactWorldBoundingBox $ObjectCurveduplicate`;
    float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox[2]};
    float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox[5]};
    float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox[2]};
    float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox[5]};
    float $BoxMPointAC[] = MidPointBetween($BoxPointA, $BoxPointC);
    float $BoxMPointBD[] = MidPointBetween($BoxPointB, $BoxPointD);
    float $BoxMPointAD[] = MidPointBetween($BoxPointA, $BoxPointD);
    float $BoxMPointBC[] = MidPointBetween($BoxPointB, $BoxPointC);
    float $CrossMPointAB[] = MidPointBetween($BoxPointA, $BoxPointB);
    float $translationzMiddle[];
    float $CurveCVzero[] = GetCurveCVposENDS($ObjectCurveduplicate, 0);
    float $CurveCVLast[] = GetCurveCVposENDS($ObjectCurveduplicate, 1);
    float $distanceBetween = PointsGetDistanceFLOAT($CurveCVzero, $CurveCVLast);
    float $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    float $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);
    float $distanceC = PointsGetDistanceFLOAT($BoxPointA, $BoxPointD);
    float $distanceAverage = (($distanceA + $distanceB) * (0.5));
    float $radiusX = ( $distanceAverage / 2.0);
    float $distanceAverageA = $distanceC;
    float $radiusXA = (($distanceC) * (0.5));
    float $Pi = 3.141593;
    float $circleArc = (($Pi) * ($distanceC));
    float $percentLess = XpercentLess_thenY( $circleArc, $ArcLength);
    float $squarePercentA;
    float $squarePercentB;
    string $ObjectCurve[];
    string $StraitCurve[];
    string $ObjectCurveduplicate[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //StraitCurves SCRIPT

    $IsCircle = 0;

    $ObjectCurve = `ls -selection`;
    xform -cp;
    resetPivot;
    duplicatePreset(1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1);

    $ObjectCurveduplicate = `ls -selection`;
    setAttr ($ObjectCurveduplicate[0] + ".translate") 0 0 0;
    setAttr ($ObjectCurveduplicate[0] + ".rotate") 0 0 0;
    playButtonStepForward; select -cl  ;

    $rotationz = `xform -q -rotation $ObjectCurve`;
    $translationz = `xform -q -translation $ObjectCurve`;
    $ArcLength = `arclen $ObjectCurve[0]`;

    $bbox = `exactWorldBoundingBox $ObjectCurveduplicate`;
    print("Bounding box ranges from: " +
    $bbox[0] + "," + $bbox[1] + "," + $bbox[2] + ", to " +
    $bbox[3] + "," + $bbox[4] + "," + $bbox[5] + ".\n");


    spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
    move -ws $bbox[0] $bbox[1] $bbox[2] BoxspaceLocatorA;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
    move -ws $bbox[3] $bbox[4] $bbox[5] BoxspaceLocatorB;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
    move -ws $bbox[3] $bbox[1] $bbox[2] BoxspaceLocatorC;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
    move -ws $bbox[0] $bbox[4] $bbox[5] BoxspaceLocatorD;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;

    // xform -query -worldSpace -translation;


    $BoxPointA = {$bbox[0], $bbox[1], $bbox[2]};
    $BoxPointB = {$bbox[3], $bbox[4], $bbox[5]};
    $BoxPointC = {$bbox[3], $bbox[1], $bbox[2]};
    $BoxPointD = {$bbox[0], $bbox[4], $bbox[5]};

    $BoxPointA = `MakeCleanFloats($BoxPointA)`;
    $BoxPointB = `MakeCleanFloats($BoxPointB)`;
    $BoxPointC = `MakeCleanFloats($BoxPointC)`;
    $BoxPointD = `MakeCleanFloats($BoxPointD)`;

    $BoxMPointAC = MidPointBetween($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween($BoxPointB, $BoxPointC);
    //   MoveObjectSelection($BoxMPointAC);

    ///////////////////////////////
    ///////////////////////////////

    $CrossMPointAB = MidPointBetween($BoxPointA, $BoxPointB);

    // BoxspaceLocatorMiddle CHANGES need here in the future

    $translationzMiddle = $CrossMPointAB;


    $CurveCVzero = GetCurveCVposENDS($ObjectCurveduplicate, 0);
    $CurveCVLast = GetCurveCVposENDS($ObjectCurveduplicate, 1);
    $distanceBetween = PointsGetDistanceFLOAT($CurveCVzero, $CurveCVLast);

    $pA1 = PointsEquivalentTol($CurveCVzero,$BoxPointA);
    $pA2 = PointsEquivalentTol($CurveCVLast,$BoxPointA);
    $pC1 = PointsEquivalentTol($CurveCVzero,$BoxPointC);
    $pC2 = PointsEquivalentTol($CurveCVLast,$BoxPointC);

    $AorC = 0;
    if (($pA1 == 3) || ($pA2 == 3)){
    $AorC = 1;
    }
    if (($pC1 == 3) || ($pC2 == 3)){
    $AorC = 2;
    }
    $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);

    $distanceC = PointsGetDistanceFLOAT($BoxPointA, $BoxPointD);

    $distanceAverage = (($distanceA + $distanceB) * (0.5)) ;
    $radiusX = ( $distanceAverage / 2.0);

    $distanceAverageA = $distanceC ;
    $radiusXA = (($distanceC) * (0.5)) ;
    // Result: 38.390151 //

    $Pi = 3.141593;
    $circleArc = (($Pi) * ($distanceC));

    $percentLess = XpercentLess_thenY( $circleArc, $ArcLength);


    if ( $distanceA > $distanceAverage) {
    $squarePercentA = (( $distanceAverage / $distanceA ) * (100));
    }

    if ( $distanceA < $distanceAverage) {
    $squarePercentA = (( $distanceA / $distanceAverage ) * (100));
    }

    if ( $distanceB > $distanceAverage) {
    $squarePercentB = (( $distanceAverage / $distanceB ) * (100));
    }
    if ( $distanceB < $distanceAverage) {
    $squarePercentB = (( $distanceB / $distanceAverage ) * (100));
    }
    /////////////////////


    $squareA = 0;
    $squareB = 0;
    if ( $squarePercentA > 55){
    $squareA = 1;
    }
    if ( $squarePercentB > 55){
    $squareB =  1;
    }


    $addSquareResults = ($squareA + $squareB);
    if (( $addSquareResults == 2 ) && ( $percentLess < 12.0 )) {
    $IsCircle = 1;

    } else {
    // Not Diagonal curves
    $IsCircle = 0;
    }

    /*
    setAttr ($StraitCurve[0] + ".rotateX") $rotationz[0];
    setAttr ($StraitCurve[0] + ".rotateY") $rotationz[1];
    setAttr ($StraitCurve[0] + ".rotateZ") $rotationz[2];
    setAttr ($StraitCurve[0] + ".translateX") $translationz[0];
    setAttr ($StraitCurve[0] + ".translateY") $translationz[1];
    setAttr ($StraitCurve[0] + ".translateZ") $translationz[2];
    */

    select -r $ObjectCurveduplicate BoxspaceLocatorA BoxspaceLocatorB BoxspaceLocatorC BoxspaceLocatorD BoxspaceLocatorMiddle;
    delete;
    print ("IsCircle " + $IsCircle);
    print ("percentLess " + $percentLess);
    print ("addSquareResults " + $addSquareResults);
    return $IsCircle;


}


/******************************************************************************
 * @procedure    EulerAngleofTwoPoints
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $EACHCVposAZ : float[]
 *   $EACHCVposBZ : float[]
 *
 * @returns      float[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] EulerAngleofTwoPoints(float $EACHCVposAZ[], float $EACHCVposBZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Z = FindclosetTOcurveENDz($pointB1, $pointB2, $vector_SubUnitMagVec2);
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $pointCVAB_MidPoint[] = MidPointBetween($EACHCVposHigher, $EACHCVposLower);
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $curveArclenZ = PointsGetDistanceFLOAT($EACHCVposAZ, $EACHCVposBZ);
    float $DivideIt = $curveArclenZ / 2.0;
    float $DivideIt2 = $DivideIt * -1;
    float $pointB1[] = {0.0 , 0.0 , $DivideIt};
    float $pointB2[] = {0.0 , 0.0 , $DivideIt2};
    float $EulerAngleA[] = `angleBetween -euler -v1 $pointB1[0] $pointB1[1] $pointB1[2] -v2  $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2[1]   $vector_SubUnitMagVec2[2]`;
    float $EulerAngleB[] = `angleBetween -euler -v1 $pointB2[0] $pointB2[1] $pointB2[2] -v2 $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1[1]   $vector_SubUnitMagVec1[2]`;
    vector $vectorZ1 = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $pointCVAB_MidPoint);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposLower, $pointCVAB_MidPoint);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $vectorZ1 = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    if ( $MagVectorZ1 > $MagVectorZ2 ){
    print (" posA is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposAZ;
    $EACHCVposLower = $EACHCVposBZ;
    }
    if ( $MagVectorZ1 < $MagVectorZ2  ){
    print (" posB is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    }
    $pointCVAB_MidPoint = MidPointBetween($EACHCVposHigher, $EACHCVposLower);
    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher, $pointCVAB_MidPoint);
    $vector_SubUnitMagVec1 = SubtractFloats($EACHCVposHigher,$UnitVectorMagPosHigher[1]);
    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposLower, $pointCVAB_MidPoint);
    $vector_SubUnitMagVec2 = SubtractFloats($EACHCVposLower,$UnitVectorMagPosLower[1]);
    /////////////////////////////////////////////////////
    $curveArclenZ = PointsGetDistanceFLOAT($EACHCVposAZ, $EACHCVposBZ);
    $DivideIt = $curveArclenZ / 2.0;
    $DivideIt2 = $DivideIt * -1;
    $pointB1 = {0.0 , 0.0 , $DivideIt} ;
    $pointB2 = {0.0 , 0.0 , $DivideIt2} ;
    /// NOTE curve ENds will not allways Line up and may be inverted
    //let $F1 be the first CV $F2 the last .. $F3 third point
    $Z = FindclosetTOcurveENDz($pointB1, $pointB2, $vector_SubUnitMagVec2);
    if ($Z == 1){ print "new floats"; $pointB1 = $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
    $EulerAngleA = `angleBetween -euler -v1 $pointB1[0] $pointB1[1] $pointB1[2] -v2  $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2[1]   $vector_SubUnitMagVec2[2]`;
    $EulerAngleB = `angleBetween -euler -v1 $pointB2[0] $pointB2[1] $pointB2[2] -v2 $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1[1]   $vector_SubUnitMagVec1[2]`;

    return $EulerAngleA;

}


/******************************************************************************
 * @procedure    getYrotationOFcam
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      float[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] getYrotationOFcam()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $CamerasDirectionVector[];
    float $CamerasPositionz[];
    float $CamLengthVector[];
    float $CP[] = $CamerasPositionz;
    float $CamEulerAngleN[] = {$CamLengthVector[0], 0.0, $CamLengthVector[2]};
    float $CamEulerAngleNi[] = {$CamerasPositionz[0], 0.0, $CamerasPositionz[2]};
    float $CamEulerAngle[] = EulerAngleofTwoPoints($CamEulerAngleN, $CamEulerAngleNi);
    string $currPanel = `getPanel -withFocus` , $camera;
    string $Camera = `modelEditor -q -camera $currPanel`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    //============================================
    $CamerasDirectionVector = nurbsViewDirectionVector(0);
    //============================================ ;) nurbsViewDirectionVector =====
    $currPanel = `getPanel -withFocus` , $camera ;
    $Camera = `modelEditor -q -camera $currPanel`;
    $CamerasPositionz = `camera -q -position $Camera`;
    $CP = $CamerasPositionz;

    $CamLengthVector = AddFloats($CamerasDirectionVector, $CP);

    $CamEulerAngleN = {$CamLengthVector[0], 0.0, $CamLengthVector[2]};
    $CamEulerAngleNi = {$CamerasPositionz[0], 0.0, $CamerasPositionz[2]};
    $CamEulerAngle = EulerAngleofTwoPoints($CamEulerAngleN, $CamEulerAngleNi);

    return $CamEulerAngle;

}


/******************************************************************************
 * @procedure    ZplainFlatten
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ZplainFlatten()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Y = 0;
    float $CamEulerAngle[] = `getYrotationOFcam`;
    float $CamEulerAngleY = `abs $CamEulerAngle[1]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Y = 0;
    $CamEulerAngle = `getYrotationOFcam`;
    $CamEulerAngleY = `abs $CamEulerAngle[1]`;
    if ($CamEulerAngleY < 22.0){
    $Y = 1; print "Less then 22";
    }
    return $Y;

}


/******************************************************************************
 * @procedure    EulerAngleofCurve
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      float[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] EulerAngleofCurve()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    int $Z = FindclosetTOcurveENDz($pointB1, $pointB2, $vector_SubUnitMagVec2);
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $pointCVAB_MidPoint[] = MidPointBetween($EACHCVposHigher, $EACHCVposLower);
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $curveArclenZ = `arclen $CurveItem`;
    float $DivideIt = $curveArclenZ / 2.0;
    float $DivideIt2 = $DivideIt * -1;
    float $pointB1[] = {0.0 , 0.0 , $DivideIt};
    float $pointB2[] = {0.0 , 0.0 , $DivideIt2};
    float $EulerAngleA[] = `angleBetween -euler -v1 $pointB1[0] $pointB1[1] $pointB1[2] -v2  $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2[1]   $vector_SubUnitMagVec2[2]`;
    float $EulerAngleB[] = `angleBetween -euler -v1 $pointB2[0] $pointB2[1] $pointB2[2] -v2 $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1[1]   $vector_SubUnitMagVec1[2]`;
    string $CurveItem[];
    string $CurveSelection[];
    vector $vectorZ1 = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $pointCVAB_MidPoint);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposLower, $pointCVAB_MidPoint);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveItem = `ls -sl`;
    $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA  )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    $vectorZ1 = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    if ( $MagVectorZ1 > $MagVectorZ2 ){
    print (" posA is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposAZ;
    $EACHCVposLower = $EACHCVposBZ;
    }
    if ( $MagVectorZ1 < $MagVectorZ2  ){
    print (" posB is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    }
    $pointCVAB_MidPoint = MidPointBetween($EACHCVposHigher, $EACHCVposLower);
    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher, $pointCVAB_MidPoint);
    $vector_SubUnitMagVec1 = SubtractFloats($EACHCVposHigher,$UnitVectorMagPosHigher[1]);
    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposLower, $pointCVAB_MidPoint);
    $vector_SubUnitMagVec2 = SubtractFloats($EACHCVposLower,$UnitVectorMagPosLower[1]);
    /////////////////////////////////////////////////////
    $curveArclenZ = `arclen $CurveItem`;
    $DivideIt = $curveArclenZ / 2.0;
    $DivideIt2 = $DivideIt * -1;
    $pointB1 = {0.0 , 0.0 , $DivideIt} ;
    $pointB2 = {0.0 , 0.0 , $DivideIt2} ;
    /// NOTE curve ENds will not allways Line up and may be inverted
    //let $F1 be the first CV $F2 the last .. $F3 third point
    $Z = FindclosetTOcurveENDz($pointB1, $pointB2, $vector_SubUnitMagVec2);
    if ($Z == 1){ print "new floats"; $pointB1 = $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
    $EulerAngleA = `angleBetween -euler -v1 $pointB1[0] $pointB1[1] $pointB1[2] -v2  $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2[1]   $vector_SubUnitMagVec2[2]`;
    $EulerAngleB = `angleBetween -euler -v1 $pointB2[0] $pointB2[1] $pointB2[2] -v2 $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1[1]   $vector_SubUnitMagVec1[2]`;

    return $EulerAngleA;

}


/******************************************************************************
 * @procedure    MidPointBetween
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $loc1 : float[]
 *   $loc2 : float[]
 *
 * @returns      float []
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] MidPointBetween(float $loc1[], float $loc2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $a = ($loc2[0] + $loc1[0]) * (0.5);
    float $b = ($loc2[1] + $loc1[1]) * (0.5);
    float $c = ($loc2[2] + $loc1[2]) * (0.5);
    float $MidPoint[] = {$a , $b , $c};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $a = ($loc2[0] + $loc1[0]) * (0.5);
    $b = ($loc2[1] + $loc1[1]) * (0.5);
    $c = ($loc2[2] + $loc1[2]) * (0.5);

    $MidPoint = {$a , $b , $c};
    return $MidPoint;

}


/******************************************************************************
 * @procedure    PointsEquivalentTol
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int PointsEquivalentTol(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $pX = equivalentTol($posA[0], $posB[0], 0.001);
    int $pY = equivalentTol($posA[1], $posB[1], 0.001);
    int $pZ = equivalentTol($posA[2], $posB[2], 0.001);
    int $addedResults = $pX + $pY + $pZ;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pX = equivalentTol($posA[0], $posB[0], 0.001);
    $pY = equivalentTol($posA[1], $posB[1], 0.001);
    $pZ = equivalentTol($posA[2], $posB[2], 0.001);
    $addedResults = $pX + $pY + $pZ;
    if ($addedResults == 3 ){ print "Points equivalent";
    }
    return $addedResults;

}


/******************************************************************************
 * @procedure    MagTimesUnitVecs
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $vectorZFlatYHigher : vector
 *   $vectorZFlatYLower : vector
 *
 * @returns      vector[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] MagTimesUnitVecs(vector $vectorZFlatYHigher, vector $vectorZFlatYLower)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MagVectorZYHigher = mag($vectorZFlatYHigher);
    float $MagVectorZYLower = mag($vectorZFlatYLower);
    vector $unitVectormagZYHL[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MagVectorZYHigher = mag($vectorZFlatYHigher);
    $MagVectorZYLower = mag($vectorZFlatYLower);
    $unitVectormagZYHL[0] = $MagVectorZYHigher * unit($vectorZFlatYHigher);
    $unitVectormagZYHL[1] = $MagVectorZYLower * unit($vectorZFlatYLower);
    print $unitVectormagZYHL;
    return $unitVectormagZYHL;

}


/******************************************************************************
 * @procedure    AppendFloatsZ
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *   $XYZ : int
 *
 * @returns      float[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] AppendFloatsZ(float $posA[], float $posB[], int $XYZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if($XYZ == 0){ $AddposA_AND_posB_float = {$posB[0], $posA[1], $posA[2]} ; }
    if($XYZ == 1){ $AddposA_AND_posB_float = {$posA[0], $posB[1], $posA[2]} ; }
    if($XYZ == 2){ $AddposA_AND_posB_float = {$posA[0], $posA[1], $posB[2]} ; }
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    CycleFloatsZ
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *   $XYZ1 : int
 *   $XYZ2 : int
 *
 * @returns      float[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] CycleFloatsZ(float $posA[], float $posB[], int $XYZ1, int $XYZ2)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if(($XYZ1 == 0) && ($XYZ2 == 1)){ $AddposA_AND_posB_float = {$posA[1], $posA[0], $posA[2]} ; } //01 xy
    if(($XYZ1 == 0) && ($XYZ2 == 2)){ $AddposA_AND_posB_float = {$posA[2], $posB[1], $posA[0]} ; } //02 xz
    if(($XYZ1 == 1) && ($XYZ2 == 2)){ $AddposA_AND_posB_float = {$posA[0], $posA[2], $posB[1]} ; } //12 yz
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    AddFloats
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] AddFloats(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $AddposA_AND_posB_float = {($posA[0] + $posB[0]), ($posA[1] + $posB[1]), ($posA[2] + $posB[2])} ;
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    SubtractFloats
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] SubtractFloats(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $SubtractposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SubtractposA_AND_posB_float = {($posA[0] - $posB[0]), ($posA[1] - $posB[1]), ($posA[2] - $posB[2])} ;
    return $SubtractposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    Add_Float_to_3PointFloats
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $posA : float
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] Add_Float_to_3PointFloats(float $posA, float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $AddposA_AND_posB_float = {($posA + $posB[0]), ($posA + $posB[1]), ($posA + $posB[2])} ;
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    SubtractFloat_to_3PointFloats
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $posA : float
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] SubtractFloat_to_3PointFloats(float $posA, float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $SubtractposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SubtractposA_AND_posB_float = {($posA - $posB[0]), ($posA - $posB[1]), ($posA - $posB[2])} ;
    return $SubtractposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    GetDegreesFromFloat
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      float
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float GetDegreesFromFloat(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $xy_angle = angle ($xvex, $yvex);
    float $Some_degrees = `rad_to_deg $xy_angle`;
    vector $xvex = << $posA[0], $posA[1], $posA[2] >>;
    vector $yvex = << $posB[0], $posB[1], $posB[2] >>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $xvex = << $posA[0], $posA[1], $posA[2] >> ;
    $yvex = << $posB[0], $posB[1], $posB[2] >> ;
    $xy_angle = angle ($xvex, $yvex) ;
    $Some_degrees = `rad_to_deg $xy_angle`;
    print $Some_degrees;
    return $Some_degrees;

}


/******************************************************************************
 * @procedure    GetDistanceBetweenCurveEnds
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $CurveItem : string[]
 *
 * @returns      float
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float GetDistanceBetweenCurveEnds(string $CurveItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    string $CurveSelection[];
    string $MakeXBetweenB[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA  )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    $dAx = $EACHCVposAZ[0] - $EACHCVposBZ[0]; $dAy = $EACHCVposAZ[1] - $EACHCVposBZ[1];
    $dAz = $EACHCVposAZ[2] - $EACHCVposBZ[2]; float $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    GetDistanceFLOAT
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $objectFirst : string
 *   $objectSecond : string
 *
 * @returns      float
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float GetDistanceFLOAT(string $objectFirst, string $objectSecond)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $pointAZ1[];
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pointAZ1 = `xform -query -worldSpace -translation ($objectFirst)`;
    $pointAZ2 = `xform -query -worldSpace -translation ($objectSecond)`;
    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    PointsGetDistanceFLOAT
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $pointAZ1 : float[]
 *   $pointAZ2 : float[]
 *
 * @returns      float
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float PointsGetDistanceFLOAT(float $pointAZ1[], float $pointAZ2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    ZeroOrONE
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $objectLoc : string[]
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ZeroOrONE(string $objectLoc[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectLocZ) -1;
    int $Z = size($objectLocZ);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    int $Zero0rOne = 0;
    float $SubtractAB[];
    float $posA[];
    float $posB[];
    string $objectLocZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $objectLocZ = $objectLoc;
    $X = size($objectLocZ) -1;
    $Z = size($objectLocZ);
    $i = 1;
    $n = -1;
    $n2 = 0;
    $Zero0rOne = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){

    $posA = `xform -q -wd -translation $objectLocZ[$n]`;
    $posB = `xform -q -wd -translation $objectLocZ[$n2]`;
    $n2++;
    $SubtractAB = SubtractFloats($posA, $posB);
    if (($SubtractAB[0] == 0) && ($SubtractAB[1] == 0) && ($SubtractAB[2] == 0 )){
    print "yes AB";
    $Zero0rOne = 1;
    }
    }
    }
    return $Zero0rOne;

}


/******************************************************************************
 * @procedure    GetCurveCVposENDS
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $CurveItem : string[]
 *   $ix : int
 *
 * @returns      float[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] GetCurveCVposENDS(string $CurveItem[], int $ix)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    string $CurveSelection[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA  )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    if ($ix == 0){
    return $EACHCVposAZ; }
    if ($ix == 1){
    return $EACHCVposBZ; }

}


/******************************************************************************
 * @procedure    VecCurveEnds
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $CurveItem : string[]
 *
 * @returns      vector[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] VecCurveEnds(string $CurveItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    string $CurveSelection[];
    vector $VectorCurveEnds[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA  )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    $VectorCurveEnds[0] = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $VectorCurveEnds[1] = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;

    return $VectorCurveEnds;

}


/******************************************************************************
 * @procedure    MakeCurveBetweenFloats
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] MakeCurveBetweenFloats(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $ZBetween[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $ZBetween[0] = `curve -d 1 -p $posA[0] $posA[1] $posA[2] -p $posB[0] $posB[1] $posB[2] -k 0 -k 2 -n ZCurveBetween`;
    return $ZBetween;

}


/******************************************************************************
 * @procedure    MakeCleanFloats
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $FloatZ : float[]
 *
 * @returns      float[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] MakeCleanFloats(float $FloatZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroORZe1 = `gmatch "e" $nameAe`;
    int $zeroORZe2 = `gmatch "e" $nameBe`;
    int $zeroORZe3 = `gmatch "e" $nameCe`;
    string $POSAe = $FloatZ[0];
    string $POSCe = $FloatZ[2];
    string $nameAe;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $POSAe = $FloatZ[0]; string $POSBe = $FloatZ[1];
    $POSCe = $FloatZ[2];
    $nameAe = `match "e" $POSAe`;
    $nameBe = `match "e" $POSBe`;
    $nameCe = `match "e" $POSCe`;
    $zeroORZe1 = `gmatch "e" $nameAe`;
    $zeroORZe2 = `gmatch "e" $nameBe`;
    $zeroORZe3 = `gmatch "e" $nameCe`;
    if ( $zeroORZe1 == 1){ $FloatZ[0] = 0.0; }
    if ( $zeroORZe2 == 1){ $FloatZ[1] = 0.0; }
    if ( $zeroORZe3 == 1){ $FloatZ[2] = 0.0; }
    return $FloatZ;

}


/******************************************************************************
 * @procedure    MakeCleanFloat1
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $FloatZ : float
 *
 * @returns      float
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float MakeCleanFloat1(float $FloatZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroORZe1 = `gmatch "e" $nameAe`;
    string $POSAe = $FloatZ;
    string $nameAe;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $POSAe = $FloatZ;
    $nameAe = `match "e" $POSAe`;
    $zeroORZe1 = `gmatch "e" $nameAe`;
    if ( $zeroORZe1 == 1){ $FloatZ = 0.0; }
    return $FloatZ;

}


/******************************************************************************
 * @procedure    PercentDiff_Curve_to_Arc
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $arclenghtzARC : float
 *   $arclenghtzDRAWN : float
 *
 * @returns      float
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float PercentDiff_Curve_to_Arc(float $arclenghtzARC, float $arclenghtzDRAWN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $PercentA;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PercentA = ((float($arclenghtzARC) / $arclenghtzDRAWN) * (100) );
    return $PercentA;

}


/******************************************************************************
 * @procedure    paramToCurvePts3
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $locatorShapes : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] paramToCurvePts3(string $locatorShapes[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $numLocators = size($locatorShapes);
    string $curveName[];
    string $parent1[] = `listRelatives -p $locatorShapes[$i]`;
    string $parent2[] = `listRelatives -p $parent1[0]`;
    string $parent3[] = `listRelatives -p $parent2[0]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numLocators = size($locatorShapes);
    for( $i = 0; $i < $numLocators; $i ++ ) {
    // Get the parent transform above the locator shape
    $parent1 = `listRelatives -p $locatorShapes[$i]`;
    $parent2 = `listRelatives -p $parent1[0]`;
    $parent3 = `listRelatives -p $parent2[0]`;
    $curveName[ size($curveName) ] = $parent3[0];
    }
    return $curveName;

}


/******************************************************************************
 * @procedure    paramToCurvePts2
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $locatorShapes : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] paramToCurvePts2(string $locatorShapes[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroORZA;
    int $zeroORZB;
    int $i;
    int $numLocators = size($locatorShapes);
    float $parm;
    float $pos[] = `getAttr ($locatorShapes[$i] + ".localPosition")`;
    float $result[] = `getAttr ($pmm+".output")`;
    string $parent2A[];
    string $selectionList[];
    string $curveName;
    string $nameA;
    string $parent1[];
    string $parent2[];
    string $ObjectParZ1[];
    string $bufferCutCurveA[];
    string $numTokensZA;
    string $ObjectParZ2[];
    string $bufferCutCurveB[];
    string $numTokensZB;
    string $nameB;
    string $pmm;
    string $selectionItem = $curveName + ".u[" + $parm + "]";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════






    $numLocators = size($locatorShapes);
    for( $i = 0; $i < $numLocators; $i ++ ) {
    // Get the parent transform above the locator shape
    $parent1 = `listRelatives -p $locatorShapes[$i]`;

    $parent2 = `listRelatives -p $parent1[0]`;

    $ObjectParZ1 = `ls -tl 1 $parent2`;
    $numTokensZA = `tokenize $ObjectParZ1[0] "|" $bufferCutCurveA`;
    print $bufferCutCurveA[0];
    $ObjectParZ2 = ` ls -head 1 $parent2`;

    $numTokensZB = `tokenize $ObjectParZ2[0] "|" $bufferCutCurveB`;
    print $bufferCutCurveB[0];
    $nameA = `match "ACurve" $bufferCutCurveA[0]`;
    $zeroORZA = `gmatch "ACurve" $nameA`;
    $nameB = `match "ACurve" $bufferCutCurveB[0]`;
    $zeroORZB = `gmatch "ACurve" $nameB`;

    if ( $zeroORZA == 1){ $parent2A = {$bufferCutCurveA[0]};  }
    if ( $zeroORZB == 1){ $parent2A = {$bufferCutCurveA[0]};  }

    $curveName = $parent2A[0];
    if( `nodeType $curveName` != "nurbsCurve" ) continue;

    if( !catch($pmm = `createNode pointMatrixMult`) ) {
    $pos = `getAttr ($locatorShapes[$i] + ".localPosition")`;
    $parm = `getAttr ($parent1[0] + ".translateX")`;
    setAttr ($pmm +".inPoint") -type double3  $pos[0] $pos[1] $pos[2];
    setAttr ($pmm +".vectorMultiply") true ;
    connectAttr ($parent1[0]+".worldMatrix[0]") ($pmm+".inMatrix") ;
    $result = `getAttr ($pmm+".output")` ;
    $parm = $result[0];

    $selectionItem = $curveName + ".u[" + $parm + "]";
    $selectionList[ size($selectionList) ] = $selectionItem;

    delete $pmm;
    }
    }
    return $selectionList;

}


/******************************************************************************
 * @procedure    paramToCurvePts
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $locatorShapes : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] paramToCurvePts(string $locatorShapes[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $numLocators = size($locatorShapes);
    float $parm;
    float $pos[] = `getAttr ($locatorShapes[$i] + ".localPosition")`;
    float $result[] = `getAttr ($pmm+".output")`;
    string $selectionList[];
    string $curveName;
    string $parent1[] = `listRelatives -p $locatorShapes[$i]`;
    string $parent2[] = `listRelatives -p $parent1[0]`;
    string $pmm;
    string $selectionItem = $curveName + ".u["  + "0.0" + ":" + $parm + "]";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $numLocators = size($locatorShapes);
    for( $i = 0; $i < $numLocators; $i ++ ) {
    // Get the parent transform above the locator shape
    $parent1 = `listRelatives -p $locatorShapes[$i]`;

    $parent2 = `listRelatives -p $parent1[0]`;
    $curveName = $parent2[0];
    if( `nodeType $curveName` != "nurbsCurve" ) continue;

    if( !catch($pmm = `createNode pointMatrixMult`) ) {
    $pos = `getAttr ($locatorShapes[$i] + ".localPosition")`;
    $parm = `getAttr ($parent1[0] + ".translateX")`;
    setAttr ($pmm +".inPoint") -type double3  $pos[0] $pos[1] $pos[2];
    setAttr ($pmm +".vectorMultiply") true ;
    connectAttr ($parent1[0]+".worldMatrix[0]") ($pmm+".inMatrix") ;
    $result = `getAttr ($pmm+".output")` ;
    $parm = $result[0];

    $selectionItem = $curveName + ".u["  + "0.0" + ":" + $parm + "]";
    $selectionList[ size($selectionList) ] = $selectionItem;

    delete $pmm;
    }
    }
    return $selectionList;

}


/******************************************************************************
 * @procedure    tokenizeparam
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $paramANDCurveZ : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] tokenizeparam(string $paramANDCurveZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $num = size($paramANDCurveZ);
    string $selectionList[];
    string $bufferA[];
    string $selectionItem = $bufferA[0];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $num = size($paramANDCurveZ);
    for( $i = 0; $i < $num; $i ++ ) {
    $numTokensA = `tokenize $paramANDCurveZ[$i] "." $bufferA`;
    $selectionItem = $bufferA[0];
    $selectionList[ size($selectionList) ] = $selectionItem;
    }
    return $selectionList;

}


/******************************************************************************
 * @procedure    EvalMoveCurvesTOend
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $paramANDCurveZ : string[]
 *   $paramCurveNAMEZ : string[]
 *   $paramANDCurve3 : string[]
 *   $AllparamlocatorZ : string[]
 *   $set : string
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] EvalMoveCurvesTOend(string $paramANDCurveZ[], string $paramCurveNAMEZ[], string $paramANDCurve3[], string $AllparamlocatorZ[], string $set)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $iX;
    int $numparamANDCurveNAMEZ = size($paramCurveNAMEZ);
    int $arclenghtzIntTIMES = ($arclenghtzIntersectZ * 1000);
    int $arclenghtzTOTALnumTIMEZ = ($arclenghtzALL *1000);
    int $PercentA;
    int $numCVs = `getAttr -size ($paramCurveNAMEZ[$i] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    float $arclenghtzIntersectZ = `eval("arclen" + " " + $paramANDCurveZ[$i])`;
    float $arclenghtzALL = `arclen $paramCurveNAMEZ[$i]`;
    string $SEspaceLocSet;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $iX = -1;
    $numparamANDCurveNAMEZ = size($paramCurveNAMEZ);

    for( $i = 0; $i < $numparamANDCurveNAMEZ; $i ++ ) {

    $arclenghtzIntersectZ = `eval("arclen" + " " + $paramANDCurveZ[$i])`;
    $arclenghtzALL = `arclen $paramCurveNAMEZ[$i]`;

    $arclenghtzIntTIMES = ($arclenghtzIntersectZ * 1000) ;
    $arclenghtzTOTALnumTIMEZ = ($arclenghtzALL *1000) ;
    //asume there is only one curve intersect
    $PercentA = ((float($arclenghtzIntTIMES) / $arclenghtzTOTALnumTIMEZ) * (100) );

    if (( $PercentA > 85 ) || ( $PercentA < 15 )){
    $numCVs = `getAttr -size ($paramCurveNAMEZ[$i] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($paramCurveNAMEZ[$i] + ".cv[0]") ;
    $CurveSelection[1] = ($paramCurveNAMEZ[$i] + ".cv[" + $numCVrealNum + "]") ;

    if ( $PercentA > 85 ) {
    // move to curve end
    $MakespaceLocatorEND = `spaceLocator -p 0 0 0 -n SEspaceLocatorEND3DZ`;
    $eachCVposEND = `pointPosition -w ($CurveSelection[1])`;
    move  -ws $eachCVposEND[0] $eachCVposEND[1] $eachCVposEND[2] $MakespaceLocatorEND[0];
    appendStringArray($MakespaceLocatorSE, $MakespaceLocatorEND, 1);
    }

    if ( $PercentA < 15 ) {
    $MakespaceLocatorSTART = `spaceLocator -p 0 0 0 -n SEspaceLocatorSTART3DZ`;
    $eachCVposSTART = `pointPosition -w ($CurveSelection[0])`;
    move  -ws $eachCVposSTART[0] $eachCVposSTART[1] $eachCVposSTART[2] $MakespaceLocatorSTART;
    appendStringArray($MakespaceLocatorSE, $MakespaceLocatorSTART, 1);

    }
    }

    if (( $PercentA < 85 ) && ( $PercentA > 15 )){
    $iX = $iX +1;
    select -cl;
    print $AllparamlocatorZ[$i];
    print ("_____not near ends_____" + "\n");
    $SEspaceLocSet = `sets -name SEisnotLocSESet[$iX]`;
    sets -include $SEspaceLocSet $paramANDCurve3[$i];
    sets -include $SEspaceLocSet $AllparamlocatorZ[$i];
    sets -include $set $SEspaceLocSet;
    }
    }
    return $MakespaceLocatorSE;

}


/******************************************************************************
 * @procedure    GET_AREA_OF_CURVE
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $obj : string[]
 *
 * @returns      float
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float GET_AREA_OF_CURVE(string $obj[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numcvs = size($numcvnames);
    float $area = 0;
    float $centroid[] = `xform -q -ws -t ($obj[0])`;
    float $pos0[] = `eval $getpos0`;
    float $pos1[] = `eval $getpos1`;
    float $aP = `distanceBetween {$centroid[0],$centroid[1],$centroid[2]} {$pos0[0],$pos0[1],$pos0[2]}`;
    float $bP = `distanceBetween {$pos0[0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1[2]}`;
    float $cP = `distanceBetween {$pos1[0],$pos1[1],$pos1[2]} {$centroid[0],$centroid[1],$centroid[2]}`;
    float $triarea = 0.25* sqrt ( ($aP+$bP+$cP) * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP) );
    string $CurveItemA = $obj[0];
    string $numcvnames[] = `ls -fl ($CurveItemA+".cv[*]")`;
    string $cvname0 = $obj[0] + ".cv[" + $iC + "]";
    string $getpos0 = "pointPosition " + $cvname0;
    string $cvname1 = $obj[0] + ".cv[" + ($iC+1) + "]";
    string $getpos1 = "pointPosition " + $cvname1;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $area = 0;
    $centroid = `xform -q -ws -t ($obj[0])`;
    $CurveItemA = $obj[0];
    $numcvnames = `ls -fl ($CurveItemA+".cv[*]")`;
    $numcvs = size($numcvnames);

    for ($iC=0;$iC<$numcvs;$iC++){
    if ($iC<($numcvs-1)){
    $cvname0 = $obj[0] + ".cv[" + $iC + "]";
    $getpos0 = "pointPosition " + $cvname0;
    $pos0 = `eval $getpos0`;
    $cvname1 = $obj[0] + ".cv[" + ($iC+1) + "]";
    $getpos1 = "pointPosition " + $cvname1;
    $pos1 = `eval $getpos1`;
    $pos0 = `MakeCleanFloats($pos0)`;
    $pos1 = `MakeCleanFloats($pos1)`;

    $aP = `distanceBetween {$centroid[0],$centroid[1],$centroid[2]} {$pos0[0],$pos0[1],$pos0[2]}`;
    $bP = `distanceBetween {$pos0[0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1[2]}`;
    $cP = `distanceBetween {$pos1[0],$pos1[1],$pos1[2]} {$centroid[0],$centroid[1],$centroid[2]}`;
    $triarea = 0.25* sqrt ( ($aP+$bP+$cP) * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP) );
    clear $pos0;
    clear $pos1;
    $area = $area + $triarea;


    } else{
    $cvname0 = $obj[0] + ".cv[" + $iC + "]";
    $getpos0 = "pointPosition " + $cvname0;
    $pos0 = `eval $getpos0`;
    $cvname1 = $obj[0] + ".cv[" + ($iC+1) + "]";
    $getpos1 = "pointPosition " + $cvname1;
    $pos1 = `eval $getpos1`;
    $pos0 = `MakeCleanFloats($pos0)`;
    $pos1 = `MakeCleanFloats($pos1)`;
    $aP = `distanceBetween {$centroid[0],$centroid[1],$centroid[2]} {$pos0[0],$pos0[1],$pos0[2]}`;
    $bP = `distanceBetween {$pos0[0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1[2]}`;
    $cP = `distanceBetween {$pos1[0],$pos1[1],$pos1[2]} {$centroid[0],$centroid[1],$centroid[2]}`;
    $triarea = 0.25* sqrt ( ($aP+$bP+$cP) * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP) );
    clear $pos0;
    clear $pos1;
    $area = $area + $triarea;
    }
    }
    clear $numcvnames;
    return $area;

}


/******************************************************************************
 * @procedure    Make_Middle_of_Curve_ParamlocatorZ002
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $objectCurveSelected : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Make_Middle_of_Curve_ParamlocatorZ002(string $objectCurveSelected[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numCVrealNumDivide = $numCVrealNum / 2;
    int $i = 1;
    float $arclenghtzALL = `arclen $objectCurveSelected`;
    float $arclenghtzDivide = $arclenghtzALL / 2.0;
    float $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;
    float $arclenghtzHalf = `arclen ($objectCurveSelected[0] + ".u[0.0:" + $numCVrealNumDivide + "]")`;
    float $arclenghtzHalfROUNDED = `RoundfloatingPointoff($arclenghtzHalf)`;
    float $iz = 0.0;
    float $iX = float($numCVrealNumDivide);
    float $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    float $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
    float $posA[];
    float $posB[];
    float $posC[];
    string $paramANDCurve[] = `paramToCurvePts( $paramlocatorZARC )`;
    string $CircularArcFromCurve[];
    string $ArcCurve[];
    string $ParentArc[];
    string $ArcZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $arclenghtzALL = `arclen $objectCurveSelected`;
    $arclenghtzDivide = $arclenghtzALL / 2.0;
    $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;
    $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectCurveSelected[0] + ".cv[0]") ;
    $CurveSelection[1] = ($objectCurveSelected[0] + ".cv[" + $numCVrealNum + "]") ;
    $numCVrealNumDivide = $numCVrealNum / 2;
    if ($numCVrealNumDivide > 2){ $numCVrealNumDivide = $numCVrealNumDivide -1; }
    $arclenghtzHalf = `arclen ($objectCurveSelected[0] + ".u[0.0:" + $numCVrealNumDivide + "]")`;
    $arclenghtzHalfROUNDED = `RoundfloatingPointoff($arclenghtzHalf)`;
    $iz = 0.0; int $M;
    if ( $arclenghtzDivideROUNDED > $arclenghtzHalfROUNDED){
    print "Greater_then"; $M = 0;  $iz = 0.01;}
    if ( $arclenghtzDivideROUNDED < $arclenghtzHalfROUNDED){
    print "Less_then"; $M = 1; $iz = -0.01;}
    $paramlocatorZARC[0] = eval("paramLocator " +  $objectCurveSelected[0] + ".u[" + $numCVrealNumDivide + "]");
    $iX = float($numCVrealNumDivide);
    $i = 1;
    while ($i > 0){
    $iX = $iX + $iz;
    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $iX;
    $paramANDCurve = `paramToCurvePts( $paramlocatorZARC )`;
    $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
    if($M == 0){
    if (($arclenghtzparamZROUNDED == $arclenghtzDivideROUNDED) || ($arclenghtzparamZROUNDED > $arclenghtzDivideROUNDED)){
    $i = 0; }
    }
    if($M == 1){
    if (($arclenghtzparamZROUNDED == $arclenghtzDivideROUNDED) || ($arclenghtzparamZROUNDED < $arclenghtzDivideROUNDED)){
    $i = 0; }
    }
    }
    $posA = `pointPosition -w $CurveSelection[0]`;
    $posB = `pointPosition -w $paramlocatorZARC[0]`;
    $posC = `pointPosition -w $CurveSelection[1]`;
    $CircularArcFromCurve[0] = `createNode makeThreePointCircularArc`;
    setAttr ($CircularArcFromCurve[0] + ".pt1") $posA[0] $posA[1] $posA[2] ;
    setAttr ($CircularArcFromCurve[0] + ".pt2") $posB[0] $posB[1] $posB[2];
    setAttr ($CircularArcFromCurve[0] + ".pt3") $posC[0] $posC[1] $posC[2];
    setAttr ($CircularArcFromCurve[0] + ".d") 3;
    setAttr ($CircularArcFromCurve[0] + ".s") 8;
    $ArcCurve[0] = `createNode nurbsCurve` ;
    connectAttr ($CircularArcFromCurve[0] + ".oc") ($ArcCurve[0] +".cr");
    //delete $objectCurveSelected;
    $ParentArc = `listRelatives -parent $ArcCurve`;
    ResetTranlation($ParentArc);

    $ArcZ[0] = `rename $ParentArc $objectCurveSelected`;
    delete $paramlocatorZARC;
    select -r $ArcZ;
    return $ArcZ;


}


/******************************************************************************
 * @procedure    RoundfloatingPointoff
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $floatingPointNumZ : float
 *
 * @returns      float
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float RoundfloatingPointoff(float $floatingPointNumZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $roundoff = $floatingPointNumZ *100;
    float $roundoff2 = float($roundoff) * 0.01;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $roundoff = $floatingPointNumZ *100;
    $roundoff2 = float($roundoff) * 0.01;
    return $roundoff2;

}


/******************************************************************************
 * @procedure    Make_Middle_of_Curve_ParamlocatorFloat
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $objectCurveSelected : string[]
 *
 * @returns      float[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] Make_Middle_of_Curve_ParamlocatorFloat(string $objectCurveSelected[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i = 1;
    float $arclenghtzALL = `arclen $objectCurveSelected`;
    float $arclenghtzDivide = $arclenghtzALL / 2.0;
    float $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;
    float $iX = 0.00;
    float $posB[];
    float $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    float $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
    string $posALL[];
    string $paramANDCurve[] = `paramToCurvePts( $paramlocatorZARC )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $arclenghtzALL = `arclen $objectCurveSelected`;
    $arclenghtzDivide = $arclenghtzALL / 2.0;
    $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;
    $paramlocatorZARC[0] = eval("paramLocator " +  $objectCurveSelected[0] + ".u[" + 0.00 + "]");
    $iX = 0.00;
    $i = 1;
    while ($i > 0){
    $iX = $iX + 0.01;
    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $iX;
    $paramANDCurve = `paramToCurvePts( $paramlocatorZARC )`;
    $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
    if (($arclenghtzparamZROUNDED == $arclenghtzDivideROUNDED) || ($arclenghtzparamZROUNDED > $arclenghtzDivideROUNDED)){
    $i = 0;
    }
    }
    $posB = `pointPosition -w $paramlocatorZARC[0]`;
    delete $paramlocatorZARC;
    return $posB ;

}


/******************************************************************************
 * @procedure    distanceBetween
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $loc1 : float[]
 *   $loc2 : float[]
 *
 * @returns      float
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float distanceBetween(float $loc1[], float $loc2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $a = `pow ($loc2[0] - $loc1[0]) 2`;
    float $b = `pow ($loc2[1] - $loc1[1]) 2`;
    float $c = `pow ($loc2[2] - $loc1[2]) 2`;
    float $distance = `sqrt ( $a+$b+$c )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $a = `pow ($loc2[0] - $loc1[0]) 2`;
    $b = `pow ($loc2[1] - $loc1[1]) 2`;
    $c = `pow ($loc2[2] - $loc1[2]) 2`;
    $distance = `sqrt ( $a+$b+$c )`;
    return $distance;

}


/******************************************************************************
 * @procedure    FindIfCurveCrossesZ
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $rebuildit : string[]
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindIfCurveCrossesZ(string $rebuildit[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $ZeroOneORTwo;
    int $numCVs = `getAttr -size ($rebuildit[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $zeroOR1Z = `gmatch "-" $nameA`;
    int $zeroOR2Z = `gmatch "-" $nameB`;
    int $zeroOR1Ze = `gmatch "e" $nameAe`;
    int $zeroOR2Ze = `gmatch "e" $nameBe`;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    string $CurveSelection[];
    string $POSA = $EACHCVposAZ[0];
    string $nameA;
    string $POSB = $EACHCVposBZ[0];
    string $nameB;
    string $POSAe = `abs $EACHCVposAZ[0]`;
    string $POSBe = `abs $EACHCVposBZ[0]`;
    string $nameAe;
    string $nameBe;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($rebuildit[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;
    $CurveSelection[1] = ($rebuildit[0] + ".cv[" + $numCVrealNum + "]") ;
    $EACHCVposAZ = `pointPosition -w ( $CurveSelection[0]  )`;
    $EACHCVposBZ = `pointPosition -w ( $CurveSelection[1]  )`;
    $POSA = $EACHCVposAZ[0];
    $nameA = `match "-" $POSA`;
    $zeroOR1Z = `gmatch "-" $nameA`;
    $POSB = $EACHCVposBZ[0];
    $nameB = `match "-" $POSB`;
    $zeroOR2Z = `gmatch "-" $nameB`;
    $ZeroOneORTwo = $zeroOR1Z + $zeroOR2Z;
    $POSAe = `abs $EACHCVposAZ[0]`;
    $POSBe = `abs $EACHCVposBZ[0]`;
    $nameAe = `match "e" $POSAe`;
    $nameBe = `match "e" $POSBe`;
    $zeroOR1Ze = `gmatch "e" $nameAe`;
    $zeroOR2Ze = `gmatch "e" $nameBe`;
    if (($zeroOR1Ze == 1 ) || ($zeroOR2Ze == 1 )){
    print "is Zero";
    $ZeroOneORTwo = 0;
    print $ZeroOneORTwo;
    }
    return $ZeroOneORTwo;

}


/******************************************************************************
 * @procedure    GetDistance
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $objectFirst : string
 *   $objectSecond : string
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int GetDistance(string $objectFirst, string $objectSecond)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $distanceA2roundoff;
    float $pointAZ1[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pointAZ1 = `xform -query -worldSpace -translation ($objectFirst)`;
    $pointAZ2 = `xform -query -worldSpace -translation ($objectSecond)`;
    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    $distanceA2roundoff = $distanceA2;
    return $distanceA2roundoff;

}


/******************************************************************************
 * @procedure    CutCurveIFConditionTRUETransitZ
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $rebuildit : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CutCurveIFConditionTRUETransitZ(string $rebuildit[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $XiScaleTimes;
    int $XiScale;
    int $ZeroOneORTwoZ = FindIfCurveCrossesZ($rebuildit);
    int $numTokensZa;
    int $X = 0;
    int $zeroOR1Z = `gmatch "-" $nameA`;
    int $zeroOR2Z = `gmatch "-" $nameB`;
    float $CURVEAposA[];
    float $CURVEA_AREA = `GET_AREA_OF_CURVE($rebuildit)`;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    string $remainingCurve[];
    string $ZcutingplaneZZ[];
    string $curveIntersectZ[];
    string $intersectZZCUT[];
    string $iSurfZ[] = `extrude -ch 1 -et 0 -l 0.5 -n AxisSelectionZ ( $rebuildit )`;
    string $buffer[];
    string $paramlocatorZ[];
    string $paramANDCurve[];
    string $curvesZ[];
    string $curveZ0[];
    string $curveZ1[];
    string $POSA = $EACHCVposAZ[0];
    string $nameA;
    string $POSB = $EACHCVposBZ[0];
    string $nameB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $ZeroOneORTwoZ = FindIfCurveCrossesZ($rebuildit);
    if ($ZeroOneORTwoZ == 1){
    $CURVEAposA = `xform -query -worldSpace -translation $rebuildit[0]`;
    $CURVEA_AREA = `GET_AREA_OF_CURVE($rebuildit)`;
    $ZcutingplaneZZ = `nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr 1 -n "ZcutingplaneZZ"`;
    setAttr "ZcutingplaneZZ.rotateZ" 90;
    $XiScale = GetDistance($rebuildit[0], $ZcutingplaneZZ[0]);
    $XiScaleTimes = ($XiScale * 3) + $CURVEA_AREA;
    scale -r $XiScaleTimes $XiScaleTimes $XiScaleTimes $ZcutingplaneZZ;
    $iSurfZ = `extrude -ch 1 -et 0 -l 0.5 -n AxisSelectionZ ( $rebuildit )`;
    $intersectZZCUT = `intersect -ch 0 -cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ $iSurfZ[0] $ZcutingplaneZZ[0]`;
    select -r $intersectZZCUT;
    $curveIntersectZ[0] = `curveIntersect -ch 0 -tolerance 0.00001 $intersectZZCUT $rebuildit[0]`;
    $numTokensZa = `tokenize $curveIntersectZ[0] " " $buffer`;
    $paramlocatorZ[0] = `eval("paramLocator " +  $rebuildit[0] + ".u[" + $buffer[1] + "]")`;
    $X = 0;
    $paramANDCurve  = `paramToCurvePts2( $paramlocatorZ)`;
    $curvesZ = `detachCurve -ch 1 -cos on -rpo 1 $paramANDCurve`;
    $curveZ0[0] = $curvesZ[0];
    $curveZ1[0] = $curvesZ[1];
    ResetTranlation($curveZ0);
    ResetTranlation($curveZ1);
    $EACHCVposAZ = `xform -query -worldSpace -translation ( $curvesZ[0]  )`;
    $EACHCVposBZ = `xform -query -worldSpace -translation ( $curvesZ[1]  )`;
    $POSA = $EACHCVposAZ[0];
    $nameA = `match "-" $POSA`;
    $zeroOR1Z = `gmatch "-" $nameA`;
    $POSB = $EACHCVposBZ[0];
    $nameB = `match "-" $POSB`;
    $zeroOR2Z = `gmatch "-" $nameB`;
    if ($zeroOR1Z == 1){
    delete $curvesZ[0];
    $X = 1; }
    if ($zeroOR2Z == 1){
    delete $curvesZ[1];
    $X = 2;}
    if ($X == 2){
    select -r $curvesZ[0]; }
    if ($X == 1){
    select -r $curvesZ[1]; }
    $remainingCurve = `ls -sl`;
    delete $intersectZZCUT $ZcutingplaneZZ AxisSelectionZ ;
    }
    $rebuildit = $remainingCurve;
    return $remainingCurve;

}


/******************************************************************************
 * @procedure    FindIfCurveISonZ
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $rebuildit : string[]
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindIfCurveISonZ(string $rebuildit[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iZ = 0;
    int $numCVs = `getAttr -size ($rebuildit[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $zeroOR1Z = `gmatch "e" $ScientNotationNameA`;
    int $zeroOR2Z = `gmatch "e" $ScientNotationNameB`;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    string $CurveSelection[];
    string $POSA = $EACHCVposAZ[0];
    string $ScientNotationNameA;
    string $POSB = $EACHCVposBZ[0];
    string $ScientNotationNameB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $iZ = 0;
    $numCVs = `getAttr -size ($rebuildit[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;
    $CurveSelection[1] = ($rebuildit[0] + ".cv[" + $numCVrealNum + "]") ;
    $EACHCVposAZ = `pointPosition -w ( $CurveSelection[0]  )`;
    $EACHCVposBZ = `pointPosition -w ( $CurveSelection[1]  )`;
    $POSA = $EACHCVposAZ[0];
    $ScientNotationNameA = `match "e" $POSA`;
    $zeroOR1Z = `gmatch "e" $ScientNotationNameA`;
    if (($EACHCVposAZ[0] == 0) || ($zeroOR1Z == 1)){
    print "yes";
    $iZ = $iZ + 1;
    }
    $POSB = $EACHCVposBZ[0];
    $ScientNotationNameB = `match "e" $POSB`;
    $zeroOR2Z = `gmatch "e" $ScientNotationNameB`;
    if (($EACHCVposBZ[0] == 0) || ($zeroOR2Z == 1)){
    print "yes";
    $iZ = $iZ + 1;
    }
    return $iZ;

}


/******************************************************************************
 * @procedure    ArrayInsertAtEnd
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $INarray : string[]
 *   $NewItem : string
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ArrayInsertAtEnd(string $INarray[], string $NewItem)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArray;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArray = size($INarray);
    $INarray[$SizeOfArray] = ( $NewItem );
    return $SizeOfArray;

}


/******************************************************************************
 * @procedure    positionOne
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $eachZA : string
 *
 * @returns      float[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] positionOne(string $eachZA)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $eachCVpos[] = `pointPosition -w $eachZA`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $eachCVpos = `pointPosition -w $eachZA`;
    return $eachCVpos;

}


/******************************************************************************
 * @procedure    stringArrayGmatch
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int stringArrayGmatch(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    for ($listItem in $list) {
    if ( `gmatch $listItem $item` == 1){
    $result = true;
    break;	}
    }
    return $result;

}


/******************************************************************************
 * @procedure    FindclosetTOcurveENDz
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $a1 : float[]
 *   $a2 : float[]
 *   $b1 : float[]
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindclosetTOcurveENDz(float $a1[], float $a2[], float $b1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $binaryAnswer;
    float $distance1;
    float $distance2;
    float $pointA1[];
    float $pointA2[];
    float $pointB1[];
    float $dAx;
    float $dAy;
    float $dAz;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pointA1 = $a1;
    $pointA2 = $b1;
    $dAx = $pointA1[0] - $pointA2[0];
    $dAy = $pointA1[1] - $pointA2[1];
    $dAz = $pointA1[2] - $pointA2[2];
    $distanceA = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    $distance1 = $distanceA;
    $pointB1 = $a2;
    $dAx = $pointB1[0] - $pointA2[0];
    $dAy = $pointB1[1] - $pointA2[1];
    $dAz = $pointB1[2] - $pointA2[2];
    $distanceB = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    $distance2 = $distanceB;
    if ($distance1 < $distance2){
    $binaryAnswer = 0;
    return $binaryAnswer;
    }
    if ( $distance2 < $distance1 ){
    $binaryAnswer = 1;
    return $binaryAnswer;
    }


}


/******************************************************************************
 * @procedure    NearestObjectArray
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $n : int
 *   $ItemsSelectedinArray : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] NearestObjectArray(int $n, string $ItemsSelectedinArray[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $NearestObjectN = $n;
    int $indexN = 0;
    int $NearestObjectNumbers = $NearestObjectN;
    int $array1Number = $array1Count;
    int $curvenumbers = $CompareAllShapesCount;
    float $pointA1[];
    float $pointA2[];
    float $distanceA;
    float $pointB1[];
    float $pointB2[];
    float $distanceB;
    string $NearestCurvesZ[];
    string $array1[] = $ItemsSelectedinArray;
    string $array2[] = $ItemsSelectedinArray;
    string $arrayMainObject1[] = $ItemsSelectedinArray;
    string $array1Count = size ($array1) -1;
    string $diff[] = stringArrayRemoveExact($array1, $arrayMainObject1);
    string $CompareAllShapesCount = size ($array1);
    string $oneitem[];
    string $arrayLast[] = stringArrayRemoveExact($oneitem, $arrayMainObject1);
    string $return[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $NearestObjectN = $n;
    $numIntx = size($NearestCurvesZ);
    if ( $numIntx > 0 ){
    clear $NearestCurvesZ;
    }
    $array1 = $ItemsSelectedinArray;
    $array2 = $ItemsSelectedinArray;
    $arrayMainObject1 = $ItemsSelectedinArray;
    $indexN = 0;
    $NearestObjectNumbers = $NearestObjectN;
    $ObjN = 0;
    $ObjN2 = 0;
    while($ObjN++ < $NearestObjectNumbers ){
    $array1Count = size ($array1) -1;
    $array1Number = $array1Count;
    stringArrayRemoveAtIndex($array1Count, $array1);
    $diff = stringArrayRemoveExact($array1, $arrayMainObject1);
    $CompareAllShapesCount = size ($array1);
    $curvenumbers = $CompareAllShapesCount;
    $i = 1;
    while($i++ < $curvenumbers ){
    //DISTANCE A
    $pointA1 = `xform -query -worldSpace -translation ( $diff)`;
    $pointA2 = `xform -query -worldSpace -translation ($array1[0])`;
    $dAx = $pointA1[0] - $pointA2[0];
    $dAy = $pointA1[1] - $pointA2[1];
    $dAz = $pointA1[2] - $pointA2[2];
    $distanceA = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    //DISTANCE B
    $pointB1 = `xform -query -worldSpace -translation ( $diff)`;
    $pointB2 = `xform -query -worldSpace -translation ( $array1[1])`;
    $dBx = $pointB1[0] - $pointB2[0];
    $dBy = $pointB1[1] - $pointB2[1];
    $dBz = $pointB1[2] - $pointB2[2];
    $distanceB = `sqrt( ($dBx * $dBx) + ($dBy * $dBy) + ($dBz * $dBz) )`;
    if( $distanceA < $distanceB ){
    stringArrayRemoveAtIndex(1, $array1);
    }
    if( $distanceA > $distanceB ){
    stringArrayRemoveAtIndex(0, $array1);
    }
    }
    appendStringArray($NearestCurvesZ, $array1, 1);
    $oneitem[0] = $array1[0];
    $arrayLast = stringArrayRemoveExact($oneitem, $arrayMainObject1);
    $array1 = $arrayLast;
    $array2 = $arrayLast;
    $arrayMainObject1 = $arrayLast;
    $indexN++;
    stringArrayInsertAtIndex(($indexN), $ArrayTwoObjectX, $arrayLast[0]);
    }
    clear $array1;
    clear $array2;
    clear $arrayMainObject1;
    $return = $NearestCurvesZ;
    return $return;

}


/******************************************************************************
 * @procedure    CreateCAMforIntCurveScript
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CreateCAMforIntCurveScript()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectZcurv[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $LocatorLoop = 0;
    float $eachCVpos[];
    string $CamConeLocator[];
    string $CurveSelection[];
    string $each;
    string $MakespaceLocator[];
    string $objectZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    CreateCameraOnly;
    rename ZCURVEModelingCAM;
    lookThroughModelPanelClipped ZCURVEModelingCAM modelPanel4 0.001 1000;
    nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr 1 -n "LiveSurfaceB";
    editDisplayLayerMembers -noRecurse layerYZYXPlains "LiveSurfaceB";


    //////////////////
    clear $CamConeLocator;
    curve -d 3 -p 0 0 0 -p 0 0 -4 -p 0 0 -8 -p 0 0 -12 -k 0 -k 0 -k 0 -k 12 -k 12 -k 12 -n Deletethiscurve ;
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    $objectZcurv = `ls -sl`;
    $numCVs = `getAttr -size ($objectZcurv[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectZcurv[0] + ".cv[0]") ;
    $CurveSelection[1] = ($objectZcurv[0] + ".cv[" + $numCVrealNum + "]") ;
    for ($each in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $each  )`;
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n LocatorA`;
    ArrayInsertAtEnd($CamConeLocator, $MakespaceLocator[0]);
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos[2] $MakespaceLocator[0];
    }
    $LocatorLoop = 0; int $LocatorLoopA = -1;
    while ($LocatorLoop++ < 7) {
    $LocatorLoopA = $LocatorLoopA +1;
    if ($LocatorLoopA == 0){
    clear $objectZ;
    stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
    stringArrayInsertAtIndex(1, $objectZ, "LocatorA1");
    }
    if ($LocatorLoopA > 0){
    clear $objectZ;
    stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
    stringArrayInsertAtIndex(1, $objectZ, $MakespaceLocator[0]);
    }
    if ($LocatorLoopA < 7){
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n LocatorMiddleDistance`;
    ArrayInsertAtEnd($CamConeLocator, $MakespaceLocator[0]);
    averagingNode($objectZ[0], $MakespaceLocator[0], $objectZ[1]);
    }
    }
    ArrayInsertAtEnd( $CamConeLocator, $CamConeLocator[0]);
    stringArrayRemoveAtIndex(0, $CamConeLocator);
    parentConstraint -mo -weight 1 ZCURVEModelingCAM LocatorA1 ;
    parentConstraint -mo -weight 1 ZCURVEModelingCAM LocatorA;
    delete  Deletethiscurve;
    align -atl -x Mid -y Mid -z Mid LiveSurfaceB ZCURVEModelingCAM;
    move -r -os -wd 0 5 5 ZCURVEModelingCAM ;
    setAttr "ZCURVEModelingCAM.rotateX" -45;
    setAttr "LiveSurfaceB.rotateX" (`getAttr ("ZCURVEModelingCAM" + ".rotateX")`+90);
    setAttr "LiveSurfaceB.rotateY" `getAttr ("ZCURVEModelingCAM" + ".rotateY")`;
    setAttr "LiveSurfaceB.rotateZ" `getAttr ("ZCURVEModelingCAM" + ".rotateZ")`;
    align -atl -x Mid -y Mid -z Mid LiveSurfaceB ZCURVEModelingCAM;
    move -r -os -wd 0 -1 0 LiveSurfaceB ;
    parentConstraint -mo -weight 1 ZCURVEModelingCAM LiveSurfaceB;
    setAttr "ZCURVEModelingCAM.translateX" 48 ;
    setAttr "ZCURVEModelingCAM.translateY" 41 ;
    setAttr "ZCURVEModelingCAM.translateZ" 48 ;
    setAttr "ZCURVEModelingCAM.rotateX" -25 ;
    setAttr "ZCURVEModelingCAM.rotateY" 45;
    setAttr "ZCURVEModelingCAM.rotateZ" 0;
    return $CamConeLocator;

}


/******************************************************************************
 * @procedure    StartofCurveScriptIntersectZX
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] StartofCurveScriptIntersectZX()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectcurv[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    float $EACHCVposA[];
    float $EACHCVposB[];
    float $eachCVpos[];
    string $digitalSkeleton[];
    string $objectcurv[];
    string $CurveSelection[];
    string $AllIntersectCurveZ[];
    string $IntersectCurves[];
    string $MakeExtrudeSurface[];
    string $MakeBirailSurface[];
    string $MakeXBetween[];
    string $MakeIntersectCurvez[];
    string $MakespaceLocator[];
    string $each;
    string $curveFromSurfaceDup[] = `duplicateCurve -ch 1 -rn 0 -local 0  "SurfaceinterectCurves.u[1]"`;
    string $curveFromSurfaceLoft[] = `loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 4 -rn 1 -po 0 -rsn true -n IntersectLoftZ $curveFromSurfaceDup[0]   $objectcurv`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    Removefromsurface;

    //
    $numInts = size($digitalSkeleton);
    if ( $numInts > 0 ){
    clear $digitalSkeleton;
    }
    $objectcurv = `ls -sl`;
    ///////////////GATHER ALL BUILDING STRUCTURE/////////##
    appendStringArray($digitalSkeleton, $objectcurv, 1);
    /////////////////////////////////////////////////////##
    $numCVs = `getAttr -size ($objectcurv[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectcurv[0] + ".cv[0]") ;
    $CurveSelection[1] = ($objectcurv[0] + ".cv[" + $numCVrealNum + "]") ;

    $numInts = size($AllIntersectCurveZ);
    if ( $numInts > 0 ){
    clear $AllIntersectCurveZ;
    }

    for ($each in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $each  )`;
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n IntersectZLocaterZ3D`;
    $MakeIntersectCurvez[0] = `curve -d 1 -p 0 0 0 -p 12 0 0 -k 0 -k 1 -n IntersectCurve` ;
    appendStringArray($AllIntersectCurveZ, $MakeIntersectCurvez, 1);
    appendStringArray($digitalSkeleton, $MakespaceLocator, 1);
    $numInts = size($AllIntersectCurveZ);
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos[2] $MakespaceLocator[0];
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos[2] $MakeIntersectCurvez[0];
    aimConstraint -offset 0 0 0 -weight 0.5 -aimVector -1 0 0 -upVector 0 0 -1 -worldUpType "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM   $MakeIntersectCurvez[0];
    if ( $numInts == 1 ){
    $EACHCVposA = $eachCVpos;
    }
    if ( $numInts == 2 ){
    $EACHCVposB = $eachCVpos;
    $MakeXBetween[0] = `curve -d 1 -p $EACHCVposA[0] $EACHCVposA[1] $EACHCVposA[2] -p $EACHCVposB[0] $EACHCVposB[1] $EACHCVposB[2] -k 0 -k 2 -n   XCurveBetween`;
    appendStringArray($digitalSkeleton, $MakeXBetween, 1);
    }
    }

    $MakeExtrudeSurface = `extrude -ch true -rn 0 -po 0 -et 0 -upn 0 -fixedPath 1 -d 0 0 0 -length 3 -rotation 0 -scale 1 -dl 3 -n CURVEZextrude   $objectcurv` ;

    $MakeBirailSurface = `singleProfileBirailSurface -ch 1 -po 0 -tm 1 -tp1 0 -n SurfaceinterectCurves CURVEZextrude.v[0] $AllIntersectCurveZ[0]   $AllIntersectCurveZ[1]`;

    $curveFromSurfaceDup = `duplicateCurve -ch 1 -rn 0 -local 0  "SurfaceinterectCurves.u[1]"` ;
    $curveFromSurfaceLoft = `loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 4 -rn 1 -po 0 -rsn true -n IntersectLoftZ $curveFromSurfaceDup[0]   $objectcurv` ;

    // Result: duplicatedCurve1 curveFromSurfaceIso2 //


    // GATHER ALL BUILDING STRUCTURE//
    appendStringArray($digitalSkeleton, $curveFromSurfaceDup, 1);
    appendStringArray($digitalSkeleton, $curveFromSurfaceLoft, 1);
    appendStringArray($digitalSkeleton, $MakeExtrudeSurface, 1);
    appendStringArray($digitalSkeleton, $MakeBirailSurface, 1);
    appendStringArray($digitalSkeleton, $AllIntersectCurveZ, 2);
    ////
    return $digitalSkeleton;

}


/******************************************************************************
 * @procedure    SecondArrayInsertAtEndofArray
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $INarray : string[]
 *   $NewItem : string[]
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int SecondArrayInsertAtEndofArray(string $INarray[], string $NewItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArray;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArray = size($INarray);
    $INarray[$SizeOfArray] = ( $NewItem[0] );
    return $SizeOfArray;

}


/******************************************************************************
 * @procedure    RemoveNoLongerExistingFromArray
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $EdgeCurveZ1 : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] RemoveNoLongerExistingFromArray(string $EdgeCurveZ1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArrayA = size($EdgeCurveZ1);
    int $SizeOfArray = size($EdgeCurveZ1) -1;
    int $i = -1;
    int $E = -1;
    int $SizeOfArrayB = size($EdgeCurveZ1);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArrayA = size($EdgeCurveZ1);
    if ( $SizeOfArrayA > 0){
    $SizeOfArray = size($EdgeCurveZ1) -1;
    $i = -1;
    $E = -1;
    while( $E < $SizeOfArray ){
    $i++;
    $E++;

    if ( `objExists $EdgeCurveZ1[$i]` == 0  ) {
    stringArrayRemoveAtIndex($i, $EdgeCurveZ1);
    if ($i == 0) { $i = -1;} else { $i = $i -1;}
    }

    }
    print $EdgeCurveZ1;
    $SizeOfArrayB = size($EdgeCurveZ1);

    return $EdgeCurveZ1;
    }

}


/******************************************************************************
 * @procedure    stringArrayMatch
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int stringArrayMatch(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $item $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ISobjectSelectedTypeCurve2
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ISobjectSelectedTypeCurve2()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    int $zeroOR1A = stringArrayMatch($names1, $nametypeZ);
    int $zeroOR1B = stringArrayMatch($names2, $nametypeZ);
    int $zeroOR1C = stringArrayMatch($names3, $nametypeZ);
    int $zeroOR1D = stringArrayMatch($names4, $nametypeZ);
    string $C[];
    string $nametypeZ[] = `ls -showType $C`;
    string $names1 = "curve";
    string $names2 = "Curve";
    string $names3 = "cv";
    string $names4 = "ep";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    $C = `ls -sl`;
    $nametypeZ = `ls -showType $C`;
    $names1 = "curve";
    $names2 = "Curve";
    $names3 = "cv";
    $names4 = "ep";
    $zeroOR1A = stringArrayMatch($names1, $nametypeZ);
    $zeroOR1B = stringArrayMatch($names2, $nametypeZ);
    $zeroOR1C = stringArrayMatch($names3, $nametypeZ);
    $zeroOR1D = stringArrayMatch($names4, $nametypeZ);
    $zeroOR1B = stringArrayMatch($names1, $nametypeZ);
    if (( $zeroOR1A == 1) || ( $zeroOR1B == 1)){
    if (( $zeroOR1C == 1) || ( $zeroOR1D == 1)){
    $result = false;
    } else { $result = true; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ISobjectSelectedTypeCurve
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ISobjectSelectedTypeCurve()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroOR1Z = `gmatch "Curve" $nameA`;
    string $C[];
    string $nametypeZ[] = `ls -showType $C`;
    string $nameA;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $C = `ls -sl`;
    $nametypeZ = `ls -showType $C`;
    $nameA = `match "[a-zA-Z]+" $nametypeZ[0]`;
    $zeroOR1Z = `gmatch "Curve" $nameA`;
    print $zeroOR1Z;
    return $zeroOR1Z;

}


/******************************************************************************
 * @procedure    ifCurveToolsCTX1
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ifCurveToolsCTX1()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $whichCtx;
    string $list[] = { "pencilContext"};
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $whichCtx = `currentCtx`;
    $list = { "pencilContext"};
    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $whichCtx $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ifCurveToolsCTX2
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ifCurveToolsCTX2()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $whichCtx;
    string $list[] = {"curveContextEP", "curveAddPtContext"};
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $whichCtx = `currentCtx`;
    $list = {"curveContextEP", "curveAddPtContext"};
    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $whichCtx $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ifCurveToolsCTX3
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ifCurveToolsCTX3()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $whichCtx;
    string $list[] = {"threePointArcContext"};
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $whichCtx = `currentCtx`;
    $list = {"threePointArcContext"};
    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $whichCtx $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ifCurveToolsCTX4
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ifCurveToolsCTX4()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $whichCtx;
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $whichCtx = `currentCtx`;
    "scaleSuperContext", "xformManipContext", "softModContext" };
    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $whichCtx $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    addNumbers
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int addNumbers()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CreatedObjectCurve = `ISobjectSelectedTypeCurve`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CreatedObjectCurve = `ISobjectSelectedTypeCurve`;
    return $CreatedObjectCurve;

}


/******************************************************************************
 * @procedure    addedNumbers
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $addNumbersA : int
 *
 * @returns      int
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int addedNumbers(int $addNumbersA)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numerOfCreatedCurve = `addNumbers`;
    int $numerOfCreated = $numerOfCreatedCurve;
    int $addNumberZ = $addNumbersA + $numerOfCreatedCurve;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numerOfCreatedCurve = `addNumbers`;
    $numerOfCreated = $numerOfCreatedCurve;
    if ($numerOfCreated == 1){
    $addNumberZ = $addNumbersA + $numerOfCreatedCurve;
    $addNumbersA = $addNumberZ;
    print $addNumbersA;
    }
    return $addNumbersA;

}


/******************************************************************************
 * @procedure    queryLayerRangeMembers
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] queryLayerRangeMembers()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $query[];
    string $queryOutofRangeLayer[];
    string $queryINRangeLayer[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $queryOutofRangeLayer = `editDisplayLayerMembers -q layerCurvesOutofRange1`;
    $queryINRangeLayer = `editDisplayLayerMembers -q layerCurvesINRange1`;
    if (size($queryOutofRangeLayer) > 0){
    appendStringArray($query, $queryOutofRangeLayer, size($queryOutofRangeLayer));
    }
    if (size($queryINRangeLayer) > 0){
    appendStringArray($query, $queryINRangeLayer, size($queryINRangeLayer));
    }
    return $query;

}


/******************************************************************************
 * @procedure    AutoBoundryScript
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $everyFirstCurveShapeset : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] AutoBoundryScript(string $everyFirstCurveShapeset[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $EndAll = 0;
    int $everycurveSize = size($everyFirstCurveShapeset);
    int $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
    int $numberofconnections = size($firstcurveConn);
    int $divide;
    int $switchNumber;
    int $n;
    int $n2 = $n * 2;
    int $ISTRUE0A1;
    int $numIntZZ;
    int $numIntAX1 = size($TEMPzCurveAAb);
    int $switchNumberA;
    int $ISTRUE0B = catchQuiet($intersectCurveZ1 = `curveIntersect -ch 0 -ud 0 -tol 0.01 $FirstCurvesZ $eachAB`);
    int $numIntZZZ = size($intersectCurveZ1);
    int $numInts2a;
    int $numIntxZB;
    int $X = 1;
    int $ENDLOOPA;
    int $i = 1;
    int $ENDLOOP;
    int $B = 0;
    int $ISTRUE0A001;
    int $numIntZZA;
    int $numIntZZAB;
    int $ISTRUE0B002;
    int $endtrigger = 0;
    int $NEARsize;
    int $XendtriggerSearch = 1;
    int $numsizeNearest = size($NearestCurvesZ);
    int $numsizediffX = size($diffX);
    int $boundaryCurvessize = size($boundaryCurves);
    int $numberofconnectionsFIRST = size($firstcurveConn);
    string $EdgeCurveZ[];
    string $EdgeCurveZ2[];
    string $EdgeCurveZ3[];
    string $newallCurves[];
    string $FirstCurvesZ[];
    string $firstcurveRelatives[];
    string $firstcurveConnectionsz[];
    string $firstcurveConn[] = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;
    string $NearestCurvesZ[] = (NearestObjectArray($n, $everyFirstCurveShapeset));
    string $NearestCurvesZn2[] = (NearestObjectArray($n2, $everyFirstCurveShapeset));
    string $TEMPzCurveAAb[];
    string $removeoneFromeveryFirstA[];
    string $diff[];
    string $NearestCurvesZA[];
    string $diffremove[];
    string $TEMPAlldiffCurveZBBBB[];
    string $diffX[];
    string $boundaryCurvesAA[];
    string $boundaryCurves[];
    string $boundaryCurves1[];
    string $removecurveAz2[];
    string $Intersectboundarycurves[];
    string $myIntersector = `stringArrayIntersector`;
    string $Foundboundarycurves[];
    string $selectedCurve[];
    string $firstcurveshapes[];
    string $objectA[] = `ls -sl`;
    string $removecurveAz[];
    string $removeoneFromeveryFirst[];
    string $newfoundEdge[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    clear $EdgeCurveZ2;
    $newallCurves = $everyFirstCurveShapeset;

    $EndAll = 0;

    $everycurveSize = size($everyFirstCurveShapeset);
    while( size($everyFirstCurveShapeset) > 2 ){
    $EndAll++;

    if ( $EndAll == 1000 ){
    clear $everyFirstCurveShapeset;
    }
    if (size($everyFirstCurveShapeset) == 3 ){
    stringArrayInsertAtIndex(0, $EdgeCurveZ2, $everyFirstCurveShapeset[0]);
    stringArrayInsertAtIndex(0, $EdgeCurveZ2, $everyFirstCurveShapeset[1]);
    stringArrayInsertAtIndex(0, $EdgeCurveZ2, $everyFirstCurveShapeset[2]);
    }

    $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
    $FirstCurvesZ[0] = $everyFirstCurveShapeset[$everycurveSizeIndex];

    $firstcurveRelatives = `listRelatives -shapes $FirstCurvesZ`;
    $firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
    $firstcurveConn = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;
    $numberofconnections = size($firstcurveConn);

    if ( $numberofconnections >= 2 ) {
    stringArrayRemoveAtIndex($everycurveSizeIndex, $everyFirstCurveShapeset);
    $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
    $FirstCurvesZ[0] = $everyFirstCurveShapeset[$everycurveSizeIndex];
    }
    $everycurveSize = size($everyFirstCurveShapeset);
    if (( $everycurveSize < 1000 ) && ( $everycurveSize >= 500 )){
    $divide = $everycurveSize / 50;
    $switchNumber = 0;
    print $divide;}
    if (( $everycurveSize < 500 ) && ( $everycurveSize >= 250 )){
    $divide = $everycurveSize / 25;
    $switchNumber = 0;}
    if (( $everycurveSize < 250 ) && ( $everycurveSize >= 100 )){
    $divide = $everycurveSize / 12; }
    if (( $everycurveSize < 100 ) && ( $everycurveSize >= 50 )){
    $divide = $everycurveSize / 5;
    $switchNumber = 0;}
    if (( $everycurveSize < 50 ) && ( $everycurveSize >= 20 )){
    $divide =$everycurveSize / 4;
    $switchNumber = 0;}
    if (( $everycurveSize < 20 ) && ( $everycurveSize > 18 )){
    $divide = $everycurveSize / 2;
    $switchNumber = 0;
    print $divide;
    }
    if ( $everycurveSize <= 18 ){
    $switchNumber = 1;
    }


    switch($switchNumber)

    {
    case 0:
    $n = $divide;
    $NearestCurvesZ = (NearestObjectArray($n, $everyFirstCurveShapeset));
    $n2 = $n * 2;
    $NearestCurvesZn2 = (NearestObjectArray($n2, $everyFirstCurveShapeset));
    break;

    case 1:
    $NearestCurvesZ = $everyFirstCurveShapeset;
    $NearestCurvesZn2 = $everyFirstCurveShapeset;
    break;

    }

    print $NearestCurvesZ;

    if ( size($TEMPzCurveAAb) > 0){
    clear $TEMPzCurveAAb;
    }
    for ( $eachZ in $NearestCurvesZ ) {

    $ISTRUE0A1 = catchQuiet($intersectCurveZ0 = `curveIntersect -ch 0 -ud 0 -tol 0.01 $FirstCurvesZ $eachZ`);
    $numIntZZ = size($intersectCurveZ0);
    if (($ISTRUE0A1 > 0) || ($numIntZZ > 0)) {
    stringArrayInsertAtIndex(0, $TEMPzCurveAAb, $eachZ);
    }
    }


    $NearestCurvesZ = $TEMPzCurveAAb;
    $numIntAX1 = size($TEMPzCurveAAb);

    if ( $numIntAX1 == 0 ){
    $removeoneFromeveryFirstA = stringArrayRemove($FirstCurvesZ, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset = $removeoneFromeveryFirstA;
    $switchNumberA = 0;
    }


    $numInts2 = size($TEMPzCurveA);
    if ( $numInts2 > 0 ){
    clear $TEMPzCurveA;
    }


    if ( $numIntAX1 == 0 ){
    $switchNumberA = 0;
    }


    if ( size($diff) > 0){
    clear $diff;
    }
    $diff = stringArrayRemove($NearestCurvesZ, $NearestCurvesZn2);


    if( size($diff) == 0 ) {
    clear $everyFirstCurveShapeset;
    clear $NearestCurvesZ;
    $switchNumberA = 1;
    } else if( size($diff) > 0 ){
    $switchNumberA = 2;
    }

    if(( size($NearestCurvesZ) == 3 ) && ($everycurveSize == 3)) {
    $switchNumberA = 1; }

    switch($switchNumberA)

    {
    case 0:

    stringArrayRemoveAtIndex($everycurveSizeIndex, $everyFirstCurveShapeset);
    $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
    $FirstCurvesZ[0] = $everyFirstCurveShapeset[$everycurveSizeIndex];

    print "next";
    break;

    case 1:
    print "done";
    stringArrayInsertAtIndex(0, $EdgeCurveZ, $NearestCurvesZ[0]);
    stringArrayInsertAtIndex(0, $EdgeCurveZ, $NearestCurvesZ[1]);
    stringArrayInsertAtIndex(0, $EdgeCurveZ, $NearestCurvesZ[2]);
    break;

    case 2:

    for ( $eachAB in $diff ) {
    $ISTRUE0B = catchQuiet($intersectCurveZ1 = `curveIntersect -ch 0 -ud 0 -tol 0.01 $FirstCurvesZ $eachAB`);
    $numIntZZZ = size($intersectCurveZ1);
    if (($ISTRUE0B > 0) || ($numIntZZZ > 0)) {
    stringArrayInsertAtIndex(0, $TEMPzCurveA, $eachAB);
    }
    }
    $numInts2a = size($NearestCurvesZA);
    if ( $numInts2a > 0 ){
    clear $NearestCurvesZA;
    }
    $NearestCurvesZA = stringArrayCatenate($NearestCurvesZ, $TEMPzCurveA);
    $NearestCurvesZ = $NearestCurvesZA;
    $numInts2a = size($diffremove);
    if ( $numInts2a > 0 ){
    clear $diffremove;
    }
    $diffremove = stringArrayRemove($TEMPzCurveA, $diff);
    $numInts = size($TEMPAlldiffCurveZBBBB);
    if ( $numInts > 0 ){
    clear $TEMPAlldiffCurveZBBBB;
    }
    $TEMPAlldiffCurveZBBBB = $diffremove;
    //////////////////////////////////////////////////////

    clear $boundaryCurves;
    clear $boundaryCurves1;
    $X = 1;
    $i = 1;
    $B = 0;
    $endtrigger = 0;

    while (size($NearestCurvesZ) > 0 ){
    if ( $endtrigger == 2 ){
    clear $NearestCurvesZ;
    size($NearestCurvesZ); }
    $NEARsize = size($NearestCurvesZ);
    if ( $NEARsize == 1 ){
    clear $NearestCurvesZ;
    }
    for ( $each in $NearestCurvesZ ) {
    stringArrayInsertAtIndex(0, $boundaryCurves1, $each);
    clear $oneboundaryCurve;
    stringArrayInsertAtIndex(0, $oneboundaryCurve, $boundaryCurves1[0]);
    $X = 1;
    $ENDLOOPA = size($TEMPAlldiffCurveZBBBB);
    for ( $eachA in $TEMPAlldiffCurveZBBBB ) {
    stringArrayInsertAtIndex(0, $boundaryCurves1, $each);
    clear $oneboundaryCurve;
    stringArrayInsertAtIndex(0, $oneboundaryCurve, $boundaryCurves1[0]);
    $ISTRUE0A001 = catchQuiet($intersectCurveZ0A = `curveIntersect -ch 0 -ud 0 -tol 1.0 $each $eachA`);
    $ENDLOOPA = size($TEMPAlldiffCurveZBBBB);
    $X++;
    $numIntZZA = size($intersectCurveZ0A);
    if ((($ISTRUE0A001 == 0) && ( $X == $ENDLOOPA)) || (($numIntZZA == 0) && ( $X == $ENDLOOPA))) {
    $removecurveAz2[0] = $each;
    $NearestCurvesZ = stringArrayRemove($removecurveAz2, $NearestCurvesZ);
    $NEARsize = size($NearestCurvesZ);

    } else if (($ISTRUE0A001 > 0) || ($numIntZZA > 0)){
    clear $diffX;
    $diffX = stringArrayRemoveExact($oneboundaryCurve, $NearestCurvesZ);
    $ENDLOOP = size($diffX);

    $XendtriggerSearch = 1;

    for ( $eachB in $diffX ) {
    $XendtriggerSearch++;
    PAUSE;
    select -r $eachB ;
    PAUSE;

    if ( $endtrigger == 2 ){
    clear $NearestCurvesZ; }

    $ISTRUE0B002 = catchQuiet($intersectCurveZAB = `curveIntersect -ch 0 -ud 0 -tol 0.001 $eachA $eachB`);

    $numIntZZAB = size($intersectCurveZAB);
    $numsizeNearest = size($NearestCurvesZ);
    $numsizediffX = size($diffX);
    //
    //

    if (( $endtrigger == 0 ) && ( $numsizeNearest < 2 )){
    $removeoneFromeveryFirstA = stringArrayRemove($FirstCurvesZ, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset = $removeoneFromeveryFirstA;
    }
    if (($ISTRUE0B002 > 0) || ($numIntZZAB > 0)) {
    $myIntersector = `stringArrayIntersector`;
    clear $Foundboundarycurves;
    stringArrayInsertAtIndex(0, $Foundboundarycurves, $FirstCurvesZ[0]);
    stringArrayInsertAtIndex(0, $Foundboundarycurves, $each);
    stringArrayInsertAtIndex(0, $Foundboundarycurves, $eachA);
    stringArrayInsertAtIndex(0, $Foundboundarycurves, $eachB);
    for ( $eachboundry in $Foundboundarycurves ) {
    PAUSE;
    select -r $eachboundry;
    PAUSE;
    clear $selectedCurve;
    $selectedCurve[0] = $eachboundry;
    $firstcurveRelatives = `listRelatives -shapes $selectedCurve`;
    $firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
    $firstcurveshapes = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;
    stringArrayIntersector -edit -allowDuplicates false -intersect $firstcurveshapes $myIntersector;
    }
    $Intersectboundarycurves = `stringArrayIntersector -query $myIntersector`;
    if (size($Intersectboundarycurves) == 1){
    clear $NearestCurvesZ;
    }



    stringArrayIntersector -edit -reset $myIntersector;
    PAUSE; PAUSE;
    select -r $FirstCurvesZ $each $eachA $eachB;

    boundary -ch 1 -or 0 -ep 1 -rn 1 -po 0 -ept 0.1 $FirstCurvesZ $each $eachA $eachB;
    $objectA = `ls -sl`;
    MirrorANDrename($objectA);
    PAUSE; PAUSE;
    $endtrigger = $endtrigger +1;

    if ((size($Intersectboundarycurves) == 0)&&($endtrigger == 1)&&(size($everyFirstCurveShapeset)<= 4)) {
    clear $NearestCurvesZ; clear $everyFirstCurveShapeset; break;
    }

    if ( $endtrigger == 1 || $endtrigger == 2 ) {
    stringArrayInsertAtIndex(0, $boundaryCurves, $each);
    stringArrayInsertAtIndex(0, $boundaryCurves, $eachB);
    stringArrayInsertAtIndex(0, $boundaryCurves, $eachA);
    }
    if ( $endtrigger < 2 ){
    $removecurveAz[0] = $each;
    $removecurveBz[0] = $eachB;
    $removecurveCz[0] = $eachA;
    $NearestCurvesZ = stringArrayRemove($removecurveAz, $NearestCurvesZ);
    $NearestCurvesZ = stringArrayRemove($removecurveBz, $NearestCurvesZ);
    $TEMPAlldiffCurveZBBBB = stringArrayRemove($removecurveCz, $TEMPAlldiffCurveZBBBB);
    else if ( $endtrigger == 2 ){
    clear $NearestCurvesZ; }

    }
    }
    //end of if
    }
    //end of For
    }
    }
    }

    PAUSE; PAUSE;
    select -r $boundaryCurves;
    PAUSE; PAUSE;
    $boundaryCurvessize = size($boundaryCurves);
    if( $boundaryCurvessize > 0 ) {
    for ( $eachboundry in $boundaryCurves ) {
    clear $selectedCurve;
    $selectedCurve[0] = $eachboundry;
    $firstcurveRelatives = `listRelatives -shapes $selectedCurve`;
    $firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
    $firstcurveConn = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;
    $numberofconnectionsFIRST = size($firstcurveConn);

    if (( $endtrigger == 1 ) && ( $numberofconnectionsFIRST == 1 )) {

    stringArrayInsertAtIndex(0, $EdgeCurveZ3, $FirstCurvesZ[0]); }

    if ( $numberofconnectionsFIRST == 2 ) {
    $firstcurveConn = stringArrayRemove($selectedCurve, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset = $firstcurveConn;

    }
    }

    }


    clear $selectedCurve;
    $selectedCurve[0] = $FirstCurvesZ[0];
    $firstcurveRelatives = `listRelatives -shapes $selectedCurve`;
    $firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
    $firstcurveConn = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;
    $numberofconnectionsFIRST = size($firstcurveConn);

    if (( $endtrigger == 1 ) && ( $numberofconnectionsFIRST == 1 )) {

    stringArrayInsertAtIndex(0, $EdgeCurveZ2, $FirstCurvesZ[0]); }

    if ( $endtrigger == 0 ){
    stringArrayInsertAtIndex(0, $EdgeCurveZ2, $FirstCurvesZ[0]); }

    $removeoneFromeveryFirst = stringArrayRemove($FirstCurvesZ, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset = $removeoneFromeveryFirst;
    clear $FirstCurvesZ;
    break;
    }
    }


    for ( $eachboundry in $newallCurves ) {
    clear $selectedCurve;
    $selectedCurve[0] = $eachboundry;
    $firstcurveRelatives = `listRelatives -shapes $selectedCurve`;
    $firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
    $firstcurveshapes = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;

    if (size($firstcurveshapes) == 1){
    appendStringArray($newfoundEdge, $selectedCurve, 1);
    }
    if (size($firstcurveshapes) == 0){
    appendStringArray($newfoundEdge, $selectedCurve, 1);
    }
    }

    select -r $newfoundEdge;
    return $newfoundEdge;


}


/******************************************************************************
 * @procedure    Make_Middle_of_Curve_ParamlocatorZMirror
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $objectCurveSelected : string[]
 *   $MakeArcLocatorZ : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Make_Middle_of_Curve_ParamlocatorZMirror(string $objectCurveSelected[], string $MakeArcLocatorZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $a = 1;
    float $arclenghtzALL = `arclen $objectCurveSelected`;
    float $arclenghtzDivide = $arclenghtzALL / 2.0;
    float $step = 10;
    float $t = $a/$step;
    float $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    float $divZZ = $arclenghtzDivide / $arclenghtzparamZ;
    float $divZZ2 = $t * $divZZ;
    float $posA[];
    float $posB[];
    float $posC[];
    string $paramlocatorZARC[];
    string $paramANDCurve[] = `paramToCurvePts( $paramlocatorZARC )`;
    string $CircularArcFromCurve[];
    string $ArcCurve[];
    string $ParentArc[];
    string $ArcZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $arclenghtzALL = `arclen $objectCurveSelected`;
    $arclenghtzDivide = $arclenghtzALL / 2.0;

    $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectCurveSelected[0] + ".cv[0]") ;
    $CurveSelection[1] = ($objectCurveSelected[0] + ".cv[" + $numCVrealNum + "]") ;
    $paramlocatorZARC[0] = eval("paramLocator " +  $objectCurveSelected[0] + ".u[" + 0.0 + "]");

    $step = 10;
    $a = 1;
    $t = $a/$step;

    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $t;
    $paramANDCurve = `paramToCurvePts( $paramlocatorZARC )`;
    $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;

    $divZZ = $arclenghtzDivide / $arclenghtzparamZ ;
    $divZZ2 = $t * $divZZ ;
    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $divZZ2;
    ////////////////////// Moved ParamLoc to middle

    $posA = `pointPosition -w $CurveSelection[0]`;
    $posB = `pointPosition -w $paramlocatorZARC[0]`;
    $posC = `pointPosition -w $CurveSelection[1]`;
    $CircularArcFromCurve[0] = `createNode makeThreePointCircularArc`;
    setAttr ($CircularArcFromCurve[0] + ".pt1") $posA[0] $posA[1] $posA[2] ;
    setAttr ($CircularArcFromCurve[0] + ".pt2") $posB[0] $posB[1] $posB[2];
    setAttr ($CircularArcFromCurve[0] + ".pt3") $posC[0] $posC[1] $posC[2];
    setAttr ($CircularArcFromCurve[0] + ".d") 3;
    setAttr ($CircularArcFromCurve[0] + ".s") 8;
    $ArcCurve[0] = `createNode nurbsCurve` ;
    connectAttr ($CircularArcFromCurve[0] + ".oc") ($ArcCurve[0] +".cr");
    //delete $objectCurveSelected;
    $ParentArc = `listRelatives -parent $ArcCurve`;
    ResetTranlation($ParentArc);

    $ConnectLocToPoint2 = `connectAttr -f ($MakeArcLocatorZ[0] + ".translate") ( $CircularArcFromCurve[0] + ".pt2")`;

    $ArcZ[0] = `rename $ParentArc $objectCurveSelected`;
    delete $paramlocatorZARC;
    delete $objectCurveSelected;

    return $ArcZ;


}


/******************************************************************************
 * @procedure    stringArrayGmatchToArray
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] stringArrayGmatchToArray(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $listItem;
    string $MatchedItem[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    for ($listItem in $list) {
    if ( `gmatch $listItem $item` == 1){
    $result = true;
    if ($result == true ){ $MatchedItem = {$listItem};}
    break;	}
    }
    return $MatchedItem;

}


/******************************************************************************
 * @procedure    StraitCurvesSCRIPTZ
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      string[]
 * @source       ConvertPolyFacesIntoNurbSurface (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] StraitCurvesSCRIPTZ()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $pA1 = PointsEquivalentTol($CurveCVzero,$BoxPointA);
    int $pA2 = PointsEquivalentTol($CurveCVLast,$BoxPointA);
    int $pC1 = PointsEquivalentTol($CurveCVzero,$BoxPointC);
    int $pC2 = PointsEquivalentTol($CurveCVLast,$BoxPointC);
    int $AorC = 0;
    int $squareA = 0;
    int $squareB = 0;
    int $XZ = 0;
    float $rotationz[];
    float $translationz[];
    float $bbox[] = `exactWorldBoundingBox $ObjectCurveduplicate`;
    float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox[2]};
    float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox[5]};
    float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox[2]};
    float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox[5]};
    float $BoxMPointAC[] = MidPointBetween($BoxPointA, $BoxPointC);
    float $BoxMPointBD[] = MidPointBetween($BoxPointB, $BoxPointD);
    float $BoxMPointAD[] = MidPointBetween($BoxPointA, $BoxPointD);
    float $BoxMPointBC[] = MidPointBetween($BoxPointB, $BoxPointC);
    float $CrossMPointAB[] = MidPointBetween($BoxPointA, $BoxPointB);
    float $translationzMiddle[];
    float $CurveCVzero[] = GetCurveCVposENDS($ObjectCurveduplicate, 0);
    float $CurveCVLast[] = GetCurveCVposENDS($ObjectCurveduplicate, 1);
    float $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    float $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);
    float $distanceAverage = (($distanceA + $distanceB) * (0.5));
    float $radiusX = ( $distanceAverage / 2.0);
    float $squarePercentA;
    float $squarePercentB;
    string $ObjectCurve[];
    string $StraitCurve[];
    string $ObjectCurveduplicate[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //StraitCurves SCRIPT 5000

    $ObjectCurve = `ls -selection`;
    xform -cp;
    resetPivot;
    duplicatePreset(1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1);

    $ObjectCurveduplicate = `ls -selection`;
    setAttr ($ObjectCurveduplicate[0] + ".translate") 0 0 0;
    setAttr ($ObjectCurveduplicate[0] + ".rotate") 0 0 0;
    playButtonStepForward; select -cl  ;

    $rotationz = `xform -q -rotation $ObjectCurve`;
    $translationz = `xform -q -translation $ObjectCurve`;

    $bbox = `exactWorldBoundingBox $ObjectCurveduplicate`;
    print("Bounding box ranges from: " +
    $bbox[0] + "," + $bbox[1] + "," + $bbox[2] + ", to " +
    $bbox[3] + "," + $bbox[4] + "," + $bbox[5] + ".\n");

    spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
    move -ws $bbox[0] $bbox[1] $bbox[2] BoxspaceLocatorA;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
    move -ws $bbox[3] $bbox[4] $bbox[5] BoxspaceLocatorB;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
    move -ws $bbox[3] $bbox[1] $bbox[2] BoxspaceLocatorC;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
    move -ws $bbox[0] $bbox[4] $bbox[5] BoxspaceLocatorD;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;

    // xform -query -worldSpace -translation;


    $BoxPointA = {$bbox[0], $bbox[1], $bbox[2]};
    $BoxPointB = {$bbox[3], $bbox[4], $bbox[5]};
    $BoxPointC = {$bbox[3], $bbox[1], $bbox[2]};
    $BoxPointD = {$bbox[0], $bbox[4], $bbox[5]};

    $BoxPointA = `MakeCleanFloats($BoxPointA)`;
    $BoxPointB = `MakeCleanFloats($BoxPointB)`;
    $BoxPointC = `MakeCleanFloats($BoxPointC)`;
    $BoxPointD = `MakeCleanFloats($BoxPointD)`;

    $BoxMPointAC = MidPointBetween($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween($BoxPointB, $BoxPointC);
    //   MoveObjectSelection($BoxMPointAC);

    ///////////////////////////////
    ///////////////////////////////

    $CrossMPointAB = MidPointBetween($BoxPointA, $BoxPointB);

    // BoxspaceLocatorMiddle CHANGES need here in the future

    $translationzMiddle = $CrossMPointAB;



    $CurveCVzero = GetCurveCVposENDS($ObjectCurveduplicate, 0);
    $CurveCVLast = GetCurveCVposENDS($ObjectCurveduplicate, 1);

    $pA1 = PointsEquivalentTol($CurveCVzero,$BoxPointA);
    $pA2 = PointsEquivalentTol($CurveCVLast,$BoxPointA);
    $pC1 = PointsEquivalentTol($CurveCVzero,$BoxPointC);
    $pC2 = PointsEquivalentTol($CurveCVLast,$BoxPointC);

    $AorC = 0;
    if (($pA1 == 3) || ($pA2 == 3)){
    $AorC = 1;
    }
    if (($pC1 == 3) || ($pC2 == 3)){
    $AorC = 2;
    }
    $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);

    $distanceAverage = (($distanceA + $distanceB) * (0.5)) ;
    $radiusX = ( $distanceAverage / 2.0);

    if ( $distanceA > $distanceAverage) {
    $squarePercentA = (( $distanceAverage / $distanceA ) * (100));
    }
    if ( $distanceA < $distanceAverage) {
    $squarePercentA = (( $distanceA / $distanceAverage ) * (100));
    }
    if ( $distanceB > $distanceAverage) {
    $squarePercentB = (( $distanceAverage / $distanceB ) * (100));
    }
    if ( $distanceB < $distanceAverage) {
    $squarePercentB = (( $distanceB / $distanceAverage ) * (100));
    }
    /////////////////////

    print $squarePercentA ;
    print $squarePercentB ;

    $squareA = 0;
    $squareB = 0;
    if ( $squarePercentA > 55){
    $squareA = 1;
    }
    if ( $squarePercentB > 55){
    $squareB =  1;
    }


    $addSquareResults = ($squareA + $squareB);
    if ( $addSquareResults == 2 ){

    //Eval Diaginal curve

    // USE $radiusX for curve points


    if ( $AorC == 1){
    $StraitCurve[0] = `curve -d 1 -p $BoxPointA[0] $BoxPointA[1] $BoxPointA[2] -p $BoxPointB[0] $BoxPointB[1] $BoxPointB[2]`;
    }
    if ( $AorC == 2){
    $StraitCurve[0] = `curve -d 1 -p $BoxPointC[0] $BoxPointC[1] $BoxPointC[2] -p $BoxPointD[0] $BoxPointD[1] $BoxPointD[2]`;
    }

    } else {


    // Not Diagonal curves


    $XZ = 0;
    if ( $distanceA > $distanceB) {
    $XZ = 1;
    }
    if ( $distanceA < $distanceB) {
    $XZ = 2;
    }

    if ($XZ == 1){
    //$BoxMPointAD  $BoxMPointBC
    $StraitCurve[0] = `curve -d 1 -p $BoxMPointAD[0] $BoxMPointAD[1] $BoxMPointAD[2] -p $BoxMPointBC[0] $BoxMPointBC[1] $BoxMPointBC[2]`;
    }
    if ($XZ == 2){
    //$BoxMPointAC $BoxMPointBD
    $StraitCurve[0] = `curve -d 1 -p $BoxMPointAC[0] $BoxMPointAC[1] $BoxMPointAC[2] -p $BoxMPointBD[0] $BoxMPointBD[1] $BoxMPointBD[2]`;
    }
    }

    setAttr ($StraitCurve[0] + ".rotateX") $rotationz[0];
    setAttr ($StraitCurve[0] + ".rotateY") $rotationz[1];
    setAttr ($StraitCurve[0] + ".rotateZ") $rotationz[2];
    setAttr ($StraitCurve[0] + ".translateX") $translationz[0];
    setAttr ($StraitCurve[0] + ".translateY") $translationz[1];
    setAttr ($StraitCurve[0] + ".translateZ") $translationz[2];


    select -r $ObjectCurve $ObjectCurveduplicate BoxspaceLocatorA BoxspaceLocatorB BoxspaceLocatorC BoxspaceLocatorD BoxspaceLocatorMiddle;
    delete;
    select -r $StraitCurve;

    return $StraitCurve;


}


/******************************************************************************
 * @procedure    createRegularPolygonY
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $n : int
 *   $r : float
 *
 * @returns      float[]
 * @source       makeRegularPolygon (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc float[] createRegularPolygonY(int $n, float $r)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    float $x[];
    float $angle = 360.0 / $n;
    float $a = $i * $angle;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $angle = 360.0 / $n ;

    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * cos(deg_to_rad($a)) ;
    }
    return $x ;

}


/******************************************************************************
 * @procedure    createRegularPolygonX
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $n : int
 *   $r : float
 *
 * @returns      float[]
 * @source       makeRegularPolygon (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc float[] createRegularPolygonX(int $n, float $r)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    float $x[];
    float $angle = 360.0 / $n;
    float $a = $i * $angle;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * sin(deg_to_rad($a)) ;
    }
    return $x ;

}


/******************************************************************************
 * @procedure    makeRegularPolygon
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $n : int
 *   $len : float
 *
 * @returns      int
 * @source       makeRegularPolygon (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
global proc int makeRegularPolygon(int $n, float $len)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    float $r = boundingCircleRadius( $n, $len );
    float $x[] = createRegularPolygonX( $n, $r );
    float $y[] = createRegularPolygonY( $n, $r );
    float $z = 0.0;
    string $facet[];
    string $cmd = "polyCreateFacet -ch 0  ";
    string $vertStr;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    if( $n <= 2 ) {
    error (uiRes("m_makeRegularPolygon.kErrorNeed3Sides")) ;
    return 1 ;
    }

    $r = boundingCircleRadius( $n, $len ) ;

    $x = createRegularPolygonX( $n, $r ) ;
    $y = createRegularPolygonY( $n, $r ) ;

    // create the n-sided polygon.
    //
    $cmd = "polyCreateFacet -ch 0  ";
    $z = 0.0 ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $vertStr += " -p " ;
    $vertStr += $x[$i] ;
    $vertStr += " " ;
    $vertStr += $y[$i] ;
    $vertStr += " " ;
    $vertStr += $z ;
    }
    $cmd += $vertStr ;
    $cmd += " ";

    // do the polyCreateFacet cmd.
    //
    $facet = eval($cmd) ;
    select -r $facet[0] ;
    return 0 ;


}


/******************************************************************************
 * @procedure    polyChamferVtx
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $doHistory : int
 *   $width : float
 *   $deleteFace : int
 *
 * @returns      string
 * @source       polyChamferVtx (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
global proc string polyChamferVtx(int $doHistory, float $width, int $deleteFace)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $cmd = "polyExtrudeVertex -ch " + $doHistory + " ";
    string $newNode = "";
    string $result[] = eval($cmd);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $cmd = "polyExtrudeVertex -ch " + $doHistory + " ";
    $cmd += "-divisions 1 -width " + $width + ";";
    $newNode = "";
    $result = eval($cmd);
    if (size($result) > 0) {
    setAttr -lock on ($result[0]+".divisions");
    setAttr -lock on ($result[0]+".length");
    $newNode = `rename $result[0] "polyChamfer#"`;
    }
    if (1 == $deleteFace) {
    getFaces;
    delete;
    } else {
    DeleteVertex;
    }
    return $newNode;

}


/******************************************************************************
 * @procedure    extractShapesWithPath
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $in : string[]
 *   $type : string
 *
 * @returns      string[]
 * @source       polyCheckSelection (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc string[] extractShapesWithPath(string $in[], string $type)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $vis = `getAttr ($i + ".visibility")`;
    string $res[];
    string $curlevel[] = `listRelatives -c -pa $i`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ($i in $in) {
    // first test that the visibility exists for the object

    string $vis_exists[1]=`listAttr -s -st visibility $i`;
    if (size($vis_exists) == 0) continue;
    // then check if the object is visible (or it will mess up the
    // unite/separate implementation)
    $vis = `getAttr ($i + ".visibility")`;
    if ($vis != 1) continue;

    // now check if the object is not an intermediate object...
    $vis_exists=`listAttr -s -st intermediateObject $i`;
    if (size($vis_exists) != 0) {
    $vis=`getAttr ($i + ".intermediateObject")`;
    if ($vis != 0) continue;
    }

    if ($type == `nodeType $i`) $res[size($res)]=$i;
    else {
    // this means that if a top level object is selected
    // its children are selected too...
    $curlevel = `listRelatives -c -pa $i`;
    if (size($curlevel) != 0)
    concatArray $res `extractShapesWithPath $curlevel $type`;
    }
    }
    return $res;

}


/******************************************************************************
 * @procedure    polyCheckSelection
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $fun : string
 *   $funtype : string
 *   $expandInstances : int
 *
 * @returns      string[]
 * @source       polyCheckSelection (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
global proc string[] polyCheckSelection(string $fun, string $funtype, int $expandInstances)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $res = 0;
    int $isInstalled = 0;
    string $tmp[];
    string $sres[];
    string $sel[];
    string $hllist[] = `ls -hl`;
    string $fmt = (uiRes("m_polyCheckSelection.kOnlyWorksForPolygons"));

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    // first set up various attributes & selection constraints
    // to allow the action to show up clearly

    // extract command name
    tokenize($fun, $tmp);
    $fun = $tmp[0];

    $res = 0;
    $isInstalled = 0;

    if ($funtype == "o") {
    // for function that work on objects, we need to do the job ourselves...
    polyInstallAction -uc -ud; // remove any pending constraint.

    // unite, separate and boolean ops want all the shapes,
    // but with their correct path information.
    // Note bool ops need to take the lead object separately...
    $sel=`ls -sl`;
    $hllist = `ls -hl`;
    if (size($hllist) != 0)
    concatArray $sel $hllist;
    $sres=`extractShapesWithPath $sel "mesh"`;
    $res=size($sres);

    clear $sel;
    if ($res == 0) {
    $fmt = (uiRes("m_polyCheckSelection.kOnlyWorksForPolygons"));
    warning `format -s $fun $fmt`;
    }
    } else {
    if (`optionVar -q polyAutoConvertAction`)
    {
    if ($expandInstances) {
    $sres = `polyInstallAction -keepInstances -cs $fun`;
    } else {
    $sres = `polyInstallAction -cs $fun`;
    }
    if (! `optionVar -q polyAutoInstallAction`)
    polyInstallAction; // Remove settings
    }
    else if (`optionVar -q polyAutoInstallAction`)
    if ($expandInstances) {
    $sres = `polyInstallAction -keepInstances $fun`;
    } else {
    $sres = `polyInstallAction $fun`;
    }
    else
    {
    polyInstallAction;				// Remove prev settings
    $sres = `ls -sl`;
    }
    // usually polyInstallAction of a poly command provides
    // the list of all matching items
    $res = size($sres);
    $isInstalled = `polyInstallAction -q -cn` != "";
    }

    global string $polyLastTool;
    global string $gSelect;

    if ($res == 0) {
    if (! `optionVar -q polyAutoInstallAction`) {
    if ($isInstalled)
    polyInstallAction -uc $fun;
    // no last tool to store
    $polyLastTool="";
    } else {
    // *** should show in setSelectMode that the mode is for $fun
    // *** should set a script job to remove the sel. constraints.
    // when the selectMode or selectType is changed.
    $polyLastTool=`currentCtx`;
    setToolTo $gSelect;
    }
    } else {
    if (`optionVar -q polyAutoInstallAction` &&
    (`getModifiers` % 2) == 1) { // shift is down
    $fmt = (uiRes("m_polyCheckSelection.kSetupWarning"));
    warning `format -s $fun $fmt`;

    // setup for action: don't do the action, just prepare for it...
    clear $sres;
    // *** should show in setSelectMode that the mode is for $fun
    // *** should set a script job to remove the sel. constraints.
    // when the selectMode or selectType is changed.
    } else {
    // uninstall selection constraints
    if ($isInstalled)
    polyInstallAction -uc $fun;
    }
    // store last tool
    $polyLastTool=`currentCtx`;
    setToolTo $gSelect;
    }
    // return array of objs to process
    return $sres;

}


/******************************************************************************
 * @procedure    cornerOfTri
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 *
 * @returns      int
 * @source       polyDeleteVertex (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc int cornerOfTri()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $result[];
    string $vertC[] = `filterExpand -ex true -sm 31`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    // If this border vertex is a corner of a TRI...
    $result=`polyListComponentConversion -tf`;
    if (size($result) > 1) return 0; // Not _a_ Tri
    select -r $result;
    select -r `polyListComponentConversion -tv`;
    $vertC = `filterExpand -ex true -sm 31`;
    if (size($vertC) == 3) return 1;
    return 0;

}


/******************************************************************************
 * @procedure    IndexPairFunc
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $XNum : int
 *
 * @returns      int []
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IndexPairFunc(int $XNum)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Zss = $XNum*2;
    int $Yss = $Zss+1;
    int $pair[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Zss = $XNum*2;
    $Yss = $Zss+1;
    $pair={$Zss,$Yss};
    return $pair;

}


/******************************************************************************
 * @procedure    IndexPairFuncN
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $XNum : int
 *   $XNumV : int
 *
 * @returns      int
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int IndexPairFuncN(int $XNum, int $XNumV)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Zss = $XNum*2;
    int $Yss = $Zss+1;
    int $AB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Zss = $XNum*2;
    $Yss = $Zss+1;
    if($XNumV==0){
    $AB=$Zss;
    }else{$AB=$Yss;}
    return $AB;

}


/******************************************************************************
 * @procedure    ReturnVectorPair
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $AllVec : vector[]
 *   $NumX : int
 *
 * @returns      vector []
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] ReturnVectorPair(vector $AllVec[], int $NumX)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $PairI[] = IndexPairFunc($NumX);
    vector $vecPa[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PairI = IndexPairFunc($NumX);
    $vecPa[0] = $AllVec[$PairI[0]];
    $vecPa[1] = $AllVec[$PairI[1]];
    return $vecPa;

}


/******************************************************************************
 * @procedure    ReturnOneVectorPair
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $AllVec : vector[]
 *   $NumX : int
 *
 * @returns      vector
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector ReturnOneVectorPair(vector $AllVec[], int $NumX)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $vecPa;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $vecPa= $AllVec[$NumX];
    return $vecPa;

}


/******************************************************************************
 * @procedure    PointInCircle
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $pos : vector[]
 *   $posA : vector
 *   $radius : float
 *
 * @returns      int[]
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int[] PointInCircle(vector $pos[], vector $posA, float $radius)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $AllInside[];
    int $indexR;
    float $Di = distance2Pts($eachVecc, $posA);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($eachVecc in $pos){
    $Di = distance2Pts($eachVecc, $posA);
    if($Di < $radius){
    $AllInside[`size($AllInside)`]= $indexR;
    }
    $indexR++;
    }
    return $AllInside;

}


/******************************************************************************
 * @procedure    MostRightLeft
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $oneVec : vector
 *   $allV : vector[]
 *
 * @returns      int []
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] MostRightLeft(vector $oneVec, vector $allV[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $best = 0;
    int $Left = 0;
    int $Si = `size($allV)`-1;
    int $RightLeft[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $best = 0;
    $Left = 0;
    $Si = `size($allV)`-1;
    for( $i = 0 ; $i < $Si ; $i++ ) {

    $Xi[0] =$best;
    $Xi[1] = $i+1;
    $zeroORone = MostRightClockWiseINT($oneVec, $allV[$best], $allV[$Xi[1]]);
    $best = $Xi[$zeroORone];
    $Xi[0] =$Left;
    $zeroORone = MostRightClockWiseINT($oneVec , $allV[$Left], $allV[$Xi[1]]);
    $Li = fmod($zeroORone+1,2);
    $Left = $Xi[$Li];
    }

    $RightLeft[0] =$best;
    $RightLeft[1] =$Left;
    return $RightLeft;

}


/******************************************************************************
 * @procedure    MostRightClockWiseINT
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $VecA : vector
 *   $VecB : vector
 *   $Vec : vector
 *
 * @returns      int
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int MostRightClockWiseINT(vector $VecA, vector $VecB, vector $Vec)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $TwoNew;
    float $pt1[] = FloatToVec($VecA);
    float $pt2[] = FloatToVec($VecB);
    float $pt3[] = FloatToVec($Vec);
    float $NA[] = `unit ($normalV[0])`;
    float $NB[] = `unit ($normalV[1])`;
    float $NAD = $NA[0] + $NA[1];
    float $NAD2 = $NB[0] + $NB[1];
    string $ReturnObj[];
    vector $U1 = TwoVecsOrFloats($pt2, $pt1);
    vector $V1 = TwoVecsOrFloats($pt3, $pt1);
    vector $U2 = TwoVecsOrFloats($pt3, $pt1);
    vector $V2 = TwoVecsOrFloats($pt2, $pt1);
    vector $normalV[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    // Get the vector p1-p2, p3-p4
    // Get the vector  p3-p4
    //THREE ptS get angel that is pt 2 & 3 to pt 1 (the V shape joining at first pt)
    ///////////////////////////////////////////////////////////
    $pt1 = FloatToVec($VecA);
    $pt2 = FloatToVec($VecB);
    $pt3 = FloatToVec($Vec);
    $U1 = TwoVecsOrFloats($pt2, $pt1);
    $V1 = TwoVecsOrFloats($pt3, $pt1);
    $U2 = TwoVecsOrFloats($pt3, $pt1);
    $V2 = TwoVecsOrFloats($pt2, $pt1);
    clear $normalV;
    $normalV[0] = FloatToVec( crossProduct( $U1, $V1, 0, 1 ) );
    $normalV[1] = FloatToVec( crossProduct( $U2, $V2, 0, 1 ) );
    $normalV[0]= `unit ($normalV[0])`;
    $normalV[1]= `unit ($normalV[1])`;
    $NA = `unit ($normalV[0])`;
    $NB = `unit ($normalV[1])`;
    $NAD = $NA[0] + $NA[1];
    $NAD2 = $NB[0] + $NB[1];
    if( $NAD< $NAD2){
    $TwoNew =1;

    }else{
    $TwoNew =0;

    }

    return $TwoNew;

}


/******************************************************************************
 * @procedure    makePolygonQUAD
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $VecPts : vector[]
 *
 * @returns      string
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string makePolygonQUAD(vector $VecPts[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $n = `size($VecPts)`;
    int $i;
    float $z = 0.0;
    string $facet[];
    string $cmd = "polyCreateFacet -ch 0  ";
    string $vertStr;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $n = `size($VecPts)`;
    // create the n-sided polygon.
    //
    $cmd = "polyCreateFacet -ch 0  ";
    $z = 0.0 ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $vertStr += " -p " ;
    $vertStr += $VecPts[$i] ;

    }
    $cmd += $vertStr ;
    $cmd += " ";
    $facet = eval($cmd) ;
    return $facet[0] ;

}


/******************************************************************************
 * @procedure    Angel2DirectionR
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $Da : vector
 *   $Db : vector
 *
 * @returns      float
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float Angel2DirectionR(vector $Da, vector $Db)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $A = acos(dot($Da, $Db));

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $A = acos(dot($Da, $Db));
    return $A;

}


/******************************************************************************
 * @procedure    Angel2Direction
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $Da : vector
 *   $Db : vector
 *
 * @returns      float
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float Angel2Direction(vector $Da, vector $Db)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $A = `rad_to_deg(acos(dot($Da, $Db)))`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $A = `rad_to_deg(acos(dot($Da, $Db)))`;
    return $A;

}


/******************************************************************************
 * @procedure    IntArrayReturnClosedLoop
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $listX : int[]
 *   $listTD : int[]
 *
 * @returns      int []
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IntArrayReturnClosedLoop(int $listX[], int $listTD[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Ct;
    int $ModNn;
    int $index = 0;
    int $X = 0;
    int $CountD = 0;
    int $CountDX = 0;
    int $NumberE[];
    int $NumberER[];
    int $IndexDup[];
    int $result = 0;
    int $indexArray[];
    int $CurveMeetsTrue = 0;
    int $indexN = 0;
    int $indexN2 = 0;
    int $IndexEnds[];
    int $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);
    int $TF = 0;
    int $intIfTrue[] = FindifCurveEndsMeetIndex($CurveOne, $CurveTwo, $TF);
    int $numCVs;
    int $num;
    int $count = 0;
    int $i = 0;
    int $Cindex = 0;
    int $NumberCs = $number3;
    int $n = $number3;
    int $SizeV = size($c);
    float $FDirNorA[] = Normal3Points($PtsVec[0], $PtsVec[1],$PtsVec[2]);
    float $ObjsCirclesE = `arclen`*2.0;
    float $ObjsCirclesEi = `arclen`;
    float $ObjsCirclesEii = `arclen`;
    float $Di = distance2Pts( $CircPos , $PointN);
    float $PointN[] = ClosestPoint2Line($VecLineDir, $PosA, $CircPos);
    float $DiffL = ($ObjsCirclesRad-$Di)*2.0;
    float $FloatDirXn[] = DirectionF( $Vec[2], $Vec[0]);
    float $PointNii[] = MultLenToDirAddToPoint($Di, DirectionF( $Vec[2], $PointN), $PointN);
    float $DistAddiR2 = $Di*2.0;
    float $HightD = sqrt (abs ((`pow $Di 2.0`) - (`pow $ObjsCirclesRad 2.0`)));
    float $PointNiii[] = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[1], $Vec[0]), $PointN);
    float $PointNiiiB[] = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[0], $Vec[1]), $PointN);
    float $ObjsCirclesEiii = `arclen`;
    float $Dii = distance2Pts(  $AVecArrayPos_MC[0] ,  $AVecArrayPos_MC[1]);
    float $DiX = distance2Pts(  $AVecArrayPos_MC[0] ,  $VecCamPos_A);
    float $DiffMathAz = $ObjsCirclesEii/$DiX;
    float $DiffMathBz = $DiffMathAz*$Dii;
    float $TESTx = $ObjsCirclesEii +$DiffMathBz;
    float $DiffMathA = $DiX / (($Dii+$DiX)/100.0);
    float $DiffMathAi = (($DiffMathA/100.0) * $ObjsCirclesEiii);
    float $DiffMathB = $Dii / (($Dii+$DiX)/100.0);
    float $DiffMathBi = $DiffMathB / 100.0;
    float $Testri = ($Dii/$DiX)+1.000;
    float $DiffMathAiX = ($Testri * $ObjsCirclesEii);
    float $Testr = ($ObjsCirclesEiii / $ObjsCirclesEii);
    float $DiffMathAx = $ObjsCirclesEii/ (($ObjsCirclesEiii)/100.0);
    float $Testrii = ($ObjsCirclesEiii - $ObjsCirclesEii)/$Dii;
    float $PerDiffX = percent_of( $ObjsCirclesEii ,$ObjsCirclesEiii);
    float $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
    float $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    float $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    float $NofCirclesa = (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
    float $NofCirclesb = ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
    float $NofCirclesc = ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);
    float $PI = 3.1415926535;
    float $Cir = ($PI *$r )*2.00;
    float $Seg = $Cir/8.0;
    float $LengAngle = 360.000/$Seg;
    float $DiffMathAB = 360.0/(100.0/$DiffMathA);
    float $angle = $LengAngle / $sides;
    float $a = $i * $angle;
    float $AstepF = 0.035;
    float $TstepF = 1.025;
    float $Step = 120;
    float $LSS = 0.050;
    float $FoundRadii[];
    float $CurveSizeFloat = logN(logN(logN(`log (5.605099)`)));
    float $LS = 0.050;
    float $XLOOG = abs  (((logN(`log ($FoundRadii[$Cindex]/8.0)`))));
    float $pi = 3.1415926535;
    float $Pi = 3.1415926535;
    float $RA;
    float $RB;
    float $R2 = $RA;
    float $R1 = $RB;
    float $DCircle = (($R2 - $R1)/2.0) + $R1;
    float $Rii = (($R2 - $R1)/2.0);
    float $SideA = $RB + $Rii;
    float $SideB = $Rii*2;
    float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    float $ArcangleC2 = $ArcangleC*2.0;
    float $Aii = (`asin ($RB/($RB + $Rii))`);
    float $number3 = 360.0/$ArcangleC2;
    float $len = $DCircle;
    float $r = $DCircle;
    float $x[] = createRegularPolygonX( $n, $r );
    float $y[] = createRegularPolygonY( $n, $r );
    float $z = 0.0;
    float $rotatsB[] = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($angle)) );
    float $rotatsA[] = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($a)) );
    float $Templast[];
    float $center[];
    float $normal[];
    float $p1[] = `xform -q -ws -t $selectionList[0]`;
    float $p2[] = `xform -q -ws -t $selectionList[1]`;
    float $p3[] = `xform -q -ws -t $selectionList[2]`;
    float $FloatPosZero[] = {0, 0, 0};
    float $FloatDirection[] = DirectionF($FloatPosZero, $normal);
    float $MultDirP[] = multiplyFloat(2, $FloatDirection);
    float $FloatDirPerpCenter[] = DirectionF($center, $mid3);
    float $FloatDirPerpCenterB[] = DirectionF($center,$mid1);
    float $FloatDirPerpCenterC[] = DirectionF($center,$mid2);
    float $FloatDirPointAB[] = DirectionF($p1, $p2);
    float $FloatDirPointBC[] = DirectionF($p2, $p3);
    float $FloatDirPointAC[] = DirectionF($p1, $p3);
    float $center6[] = lineIntersection( $p1, $FloatDirPerpCenter, $p2, $FloatDirPointBC );
    float $center7[] = lineIntersection( $p3,  $FloatDirPerpCenterB, $p1, $FloatDirPointAB );
    float $center8[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    float $center9[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPerpCenter );
    float $OrthoCenterCir[] = midPoint2Pts( $center9, $center );
    float $Radius2HalfTimes2 = (distance2Pts( $center9, $center ))*2;
    float $Radius2BHalf = (distance2Pts( $center9, $center ));
    float $radiusZ = distance2Pts( $p1, $center );
    float $Radius3Half = $radiusZ/2;
    float $radius;
    float $Start_angle = (90.0);
    float $End_angle;
    float $LengthsT[] = ArcLengthArray(`ls -sl`);
    float $LengthsM[] = ArcLengthArray(`ls -sl`);
    float $Lengths[] = ArcLengthArray(`ls -sl`);
    float $LengthsSub[];
    float $PerDiff = percent_of($LengthsM[0], $Lengths[3]);
    float $LengthsC[] = ArcLengthArray(`ls -sl`);
    float $Distance = 0;
    float $DistanceMM = 0;
    float $Arc = 0;
    float $p1x = 0, $p1y = 0, $p2x = 0, $p2y = 0;
    float $triarea = 0;
    float $tri_areaM = 0;
    float $aP;
    float $bP;
    float $cP;
    float $N;
    float $TWO_PI = 3.1415926535;
    float $AverageVecCurve[] = AverageVectorPoint($Positions);
    float $DDistPt_toC = distance2Pts($VCrvPos_A, $VLocPos_A);
    float $DDist = $Distance/float($TotalS);
    float $DDistX = $Distance+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    float $DDistMM = $DistanceMM+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    float $MathA = $DDistMM/$DDist;
    float $MathB = $DDistPt_toC/$MathA;
    string $list[];
    string $listItem;
    string $CurveSelection[];
    string $selItemz[] = `ls-sl`;
    string $selLocz[];
    string $itemD[];
    string $CurveItemZ[] = `ls -sl`;
    string $initial_string;
    string $rules[];
    string $tmp;
    string $ThefirstCurve = VecArrayToCurve($Xs);
    string $CurvesV[];
    string $circleA[];
    string $circleB[];
    string $circles[];
    string $circlesC[];
    string $LItem[] = `ls -sl`;
    string $selectionList[];
    string $circlesItem[];
    string $Locs[];
    string $CurveItemAXX[] = `ls -sl`;
    string $CurveItemAX[] = `ls -sl`;
    vector $CurveOne[] = GetVectorArrayBetweenCurveEnds({$curveA});
    vector $CurveTwo[] = GetVectorArrayBetweenCurveEnds({$curveB});
    vector $CurveAB[];
    vector $eachCVposV;
    vector $VecLi[];
    vector $NewVeci;
    vector $VecCamPos_A;
    vector $VecArrayPos_MC[];
    vector $ThreeEllipVecP[];
    vector $PtsVec[] = PointArrayT(`ls -sl`);
    vector $NewEllipesCurve[];
    vector $AVecArrayPos_MC[];
    vector $CircPos = $VecArrayPos_MC[1];
    vector $PosA = $VecCamPos_A;
    vector $PosB = $AVecArrayPos_MC[0];
    vector $VecLineDir = PositiveDirectionLine($PosA, $PosB);
    vector $Vec[];
    vector $A_CrvCentroidA = FloatToVec(AverageVectorPoint( $AVecArrayPos_MC));
    vector $Xs[];
    vector $Normal = << 0.0,1.0,0.0>>;
    vector $HighCurvePoints[];
    vector $NormalCurvePoints[];
    vector $DirecAB = ((unit(`rot $Direc $DirNorm $Radian`))*$Length)+$Vecpt;
    vector $VCirPosX;
    vector $VecPairA[];
    vector $EmptyVecA[];
    vector $DirectionStart = <<$matrixA[0][0], $matrixA[0][1], $matrixA[0][2] >>;
    vector $DirectionStartB = <<$rotatsB[0], $rotatsB[1], $rotatsB[2] >>;
    vector $VrotatsA[];
    vector $VrotatsCiH[];
    vector $VrotatsBiH[];
    vector $VrotatsCi[];
    vector $VrotatsBi[];
    vector $VrotatsAi[];
    vector $CirclePts = <<$rotatsA[0], $rotatsA[1], $rotatsA[2] >>;
    vector $DirLine = DirectionFN($CirclePts, $VCirPosX);
    vector $Vperp = crossProduct( $DirLine, $Normal, 0, 0 );
    vector $VperpN = crossProduct( $DirLine, ($Normal*-1.0), 0, 0 );
    vector $VperpA = ($Rii/2.0)* $VperpN*-1.0;
    vector $VperpC = ($Rii/2.0)*$DirLine;
    vector $VperpB = ( $Rii/2.0)*$Vperp*-1.0;
    vector $VperpD = (-1*$Rii/2.0)*$DirLine;
    vector $veCPos1[];
    vector $VecCurEndsa[] = VecCurveEnds({$ThefirstCurve});
    vector $Positions[];
    vector $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM`;
    vector $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM`;
    vector $Plane_Trans = `xform -q -ws -t LiveSurfaceB`;
    vector $Plane = `xform -q -ws -ro LiveSurfaceB`;
    vector $VCrvPos_AA;
    vector $VCrvPos_A;
    vector $VLocPosX;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $list = IntArrayToStringArray($listX);
    $index = 0;
    $X = 0;
    $CountD = 0;
    $CountDX = 0;
    $result = $list;
    //for ($item in $result) {

    while(`size($result)`> 0 ) {
    $item = $result[0];
    $CountD = stringArrayCount($item, $result);

    $IndexDup = StringArrayCountIndexDup($item, $list, $CountDX);
    if($CountDX >1){
    for($eachINT in $IndexDup){
    $listTD[$eachINT] = $CountDX;
    }
    clear $IndexDup;
    }
    if ($CountD>1) {
    $NumberE[$index]=$CountD;
    print ($item+" "+$CountD+"\n");
    $NumberER[$index] =$NumberE[$index];
    $CollectR[$index] = $item;
    $index++;
    $result = stringArrayRemove({$item},$result);
    }
    $X++;
    if($X ==200){break;}
    }

    return $NumberER;
    }



    proc int[] StringArrayCountIndexDup(string $item, string $list[], int $Count)
    {
    $result = 0;
    $index = 0;

    for ($listItem in $list) {

    if ($item == $listItem){
    $indexArray[$result] = $index;
    $result++;}

    $index++;
    }
    $Count = $result;
    return $indexArray;
    }


    proc int [] FindifCurveEndsMeetIndex(vector $CurveA1[], vector $CurveA2[], int $TF){
    $CurveMeetsTrue = 0;
    $indexN = 0;
    $indexN2 = 0;

    while ($indexN < 2){

    $firstC = $CurveA1[$indexN];
    $SecondC = $CurveA2[0];
    $SecondCA = $CurveA2[1];

    $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);

    if ($NumberE == 3){
    if($indexN==0){
    $IndexEnds[0]=1; $IndexEnds[1]=0; $IndexEnds[2]=1; $IndexEnds[3]=0;

    }else{
    $IndexEnds[0]=0; $IndexEnds[1]=1; $IndexEnds[2]=1; $IndexEnds[3]=0;

    }
    $CurveMeetsTrue = 1;
    break; }

    if ($NumberE2 == 3){

    if($indexN==0){
    $IndexEnds[0]=1; $IndexEnds[1]=0; $IndexEnds[2]=0; $IndexEnds[3]=1;

    }else{

    $IndexEnds[0]=0; $IndexEnds[1]=1; $IndexEnds[2]=0; $IndexEnds[3]=1;}
    $CurveMeetsTrue = 1;
    break; }

    if ($indexN==1){$indexN1 = 1;}
    $indexN++;
    }

    $TF = $CurveMeetsTrue;
    return $IndexEnds;
    }


    proc int [] IfCurvesTouchIndex(string $curveA, string $curveB,int $TFa){
    $CurveOne = GetVectorArrayBetweenCurveEnds({$curveA});
    $CurveTwo = GetVectorArrayBetweenCurveEnds({$curveB});
    $TF = 0;
    $intIfTrue = FindifCurveEndsMeetIndex($CurveOne, $CurveTwo, $TF);
    $TFa = $TF;
    return $intIfTrue;
    }


    proc int [] IfCurvesTouchIndexZ(string $curveA, string $curveB,int $TFa){
    $CurveOne = GetVectorArrayBetweenCurveEnds({$curveA});
    $CurveTwo = GetVectorArrayBetweenCurveEnds({$curveB});
    $TF = 0;
    $intIfTrue = FindifCurveEndsMeetIndexZ($CurveOne, $CurveTwo, $TF);
    $TFa = $TF;
    return $intIfTrue;
    }



    proc int [] FindifCurveEndsMeetIndexZ(vector $CurveA1[], vector $CurveA2[], int $TF){
    $CurveMeetsTrue = 0;
    $indexN = 0;
    $indexN2 = 0;

    while ($indexN < 2){

    $firstC = $CurveA1[$indexN];
    $SecondC = $CurveA2[0];
    $SecondCA = $CurveA2[1];

    $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);

    if ($NumberE == 3){
    if($indexN==0){
    $IndexEnds[0]=0; $IndexEnds[1]=0;

    }else{
    $IndexEnds[0]=1; $IndexEnds[1]=0;
    }
    $CurveMeetsTrue = 1;
    break; }

    if ($NumberE2 == 3){

    if($indexN==0){
    $IndexEnds[0]=0; $IndexEnds[1]=1;
    }else{

    $IndexEnds[0]=1; $IndexEnds[1]=1; }
    $CurveMeetsTrue = 1;
    break; }

    if ($indexN==1){$indexN1 = 1;}
    $indexN++;
    }

    $TF = $CurveMeetsTrue;
    return $IndexEnds;
    }





    proc vector[] GetVectorArrayCRVEnds(string $CurveItemZ[]){

    for ($CurveItem in $CurveItemZ) {
    $numCVs = `getAttr -size ($CurveItem +  ".controlPoints")`;
    $num = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem + ".cv[" +  $num + "]") ;
    for ($eachZA in $CurveSelection) {
    $eachCVposV = `pointPosition -w ($eachZA)`;
    $CurveAB[`size($CurveAB)`] = $eachCVposV;
    }
    }
    return $CurveAB;
    }


    $selItemz = `ls-sl`;

    $NewAMatrix = GetMatrix($selItemz[0]);

    $NewBMatrix = GetMatrix($selItemz[1]);




    clear $selLocz;
    for($eachVec in  $VecArrayPos_MC){
    $selLocz[`size($selLocz)`] = `Loc $eachVec`;
    }

    select -r $selLocz[0];

    TransformRelByMatrixXformMX($NewBMatrix, $selLocz)




    TransformRelByMatrixXform($NewBMatrix, $selItemz[0]);
    TransformItemByMatrixXform($NewBMatrix, $selItemz[0]);





    proc TransformRelByMatrixXformMX(matrix $m[][], string $itemA[]){
    $VecLi = PointArrayT($itemA);
    $count = 0;
    for($item in $itemA){
    $itemD  = `duplicate -rr $item`;
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $itemD[0];
    select -r $itemD ; PAUSE;
    //$NewVeci = VecMultMatrix($NewVeci, $m);
    //xform -ws -t ($NewVeci.x) ($NewVeci.y) ($NewVeci.z) $itemD[0];
    $count++;
    }
    }

    proc TransformItemByMatrixXform(matrix $m[][], string $item){
    $itemD = `duplicate -rr $item`;
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $itemD[0];
    }

    $VecCamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $VecArrayPos_MC = PointArrayT(`ls-sl -fl`);



    $ThreeEllipVecP = PointArrayT(`ls-sl`);
    //////////////////

    $PtsVec = PointArrayT(`ls -sl`);
    $FDirNorA = Normal3Points($PtsVec[0], $PtsVec[1],$PtsVec[2]);
    //////////


    //	$ThreeEllipVecP[0] = $CurveCollectVec[$NewIndexAi[0]] ;
    //	$ThreeEllipVecP[1] = $NewPvec;
    //	$ThreeEllipVecP[2] = $CurveCollectVec[$ChangeOver];
    $NewEllipesCurve = calculateEllipseCurve($ThreeEllipVecP, 300);


    //LineIntersectCirTF(  $ObjsCirclesRad , $VecArrayPos_MC[1], $VecCamPos_A ,$VecArrayPos_MC[0])

    // circle pos, circle radius, line direction, line pos
    //proc int LineIntersectCirTFZ(float $ObjsCirclesRad, vector $CircPos[], vector $PosA,vector $PosB){


    $AVecArrayPos_MC = PointArrayT(`ls-sl`);


    LineIntersectCirTFZ(float $ObjsCirclesRad, vector $CircPos, vector $PosB){


    $AVecArrayPos_MC = PointArrayT(`ls-sl`);

    $VecCamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;

    $CircPos = $VecArrayPos_MC[1];
    $PosA = $VecCamPos_A;
    $PosB = $AVecArrayPos_MC[0];
    $ObjsCirclesE = `arclen`*2.0;


    $ObjsCirclesEi = `arclen`;
    $ObjsCirclesEii = `arclen`;
    // Result: 0.41585 //
    // Result: 14.251443 //

    // Result: 23.164589 //
    // Result: 0.191253 //

    $Di = distance2Pts( $CircPos , $PointN);

    $VecLineDir = PositiveDirectionLine($PosA, $PosB);
    //float $ObjsCirclesRad = `arclen`*2.0;
    // $ObjsCirclesRad = $ObjsCirclesRad/2.0;

    $PointN = ClosestPoint2Line($VecLineDir, $PosA, $CircPos);
    Loc $PointN;
    curve2points($PosB, $PointN);
    print  $ObjsCirclesRad;

    $Di = distance2Pts( $CircPos , $PointN);
    $DiffL = ($ObjsCirclesRad-$Di)*2.0;

    //$Di = $ObjsCirclesRad;

    $Vec[0] = $PosA;
    $Vec[1] = $PosB;
    $Vec[2] = $CircPos;


    $FloatDirXn = DirectionF( $Vec[2], $Vec[0]);
    $PointNii = MultLenToDirAddToPoint($Di, DirectionF( $Vec[2], $PointN), $PointN);
    Loc $PointNii;
    $DistAddiR2 = $Di*2.0;
    $HightD = sqrt (abs ((`pow $Di 2.0`) - (`pow $ObjsCirclesRad 2.0`)));
    $PointNiii = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[1], $Vec[0]), $PointN);
    Loc $PointNiii;

    $PointNiiiB = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[0], $Vec[1]), $PointN);
    Loc $PointNiiiB;
    curve2points($PointNiii,$PointNiiiB);



    if($Di<$eachObjsCirclesRad){
    $returnValue =1; break;}
    if($Di==$eachObjsCirclesRad){
    $returnValue =0;}
    if($Di>$eachObjsCirclesRad){
    $returnValue =-1;}
    $IndexI++;
    }

    return $returnValue;
    }


    $AVecArrayPos_MC = PointArrayT(`ls-sl`);

    //distance2Pts(  $AVecArrayPos_MC[0] ,  $AVecArrayPos_MC[2]);
    //distance2Pts(  $AVecArrayPos_MC[1] ,  $AVecArrayPos_MC[2]);

    $A_CrvCentroidA = FloatToVec(AverageVectorPoint( $AVecArrayPos_MC));
    Loc $A_CrvCentroidA;


    $CurveItemZ = `ls -sl`;


    PointCurvesToPlaneCurve($CurveItemZ);


    $ObjsCirclesEi = `arclen`;
    $ObjsCirclesEii = `arclen`;
    $ObjsCirclesEiii = `arclen`;

    $Dii = distance2Pts(  $AVecArrayPos_MC[0] ,  $AVecArrayPos_MC[1]);
    $DiX = distance2Pts(  $AVecArrayPos_MC[0] ,  $VecCamPos_A);

    $DiffMathAz = $ObjsCirclesEii/$DiX;
    $DiffMathBz = $DiffMathAz*$Dii;
    $TESTx = $ObjsCirclesEii +$DiffMathBz ;


    // Result: -2.134459 //
    print $ObjsCirclesEiii;
    2.268188


    $DiffMathA = $DiX / (($Dii+$DiX)/100.0);

    // Result: 2.94791 //
    $Testr = ($ObjsCirclesEii / $ObjsCirclesEiii);
    // Result: 0.0294791 //


    $DiffMathAi = (($DiffMathA/100.0) * $ObjsCirclesEiii);


    $DiffMathA = $DiX / (($Dii+$DiX)/100.0);
    $DiffMathB = $Dii / (($Dii+$DiX)/100.0);

    $DiffMathBi = $DiffMathB / 100.0;

    $Testri = ($Dii/$DiX)+1.000;
    $DiffMathAiX = ($Testri * $ObjsCirclesEii);
    $TESTx = $ObjsCirclesEiii -$DiffMathAiX ;

    $Testr = ($ObjsCirclesEiii / $ObjsCirclesEii);
    $TESTx = $Testr -$Testri;

    $TESTx = $Testr -$Testri;


    $DiffMathAx = $ObjsCirclesEii/ (($ObjsCirclesEiii)/100.0);

    $DiffMathAi = (($DiffMathAx/100.0) * $ObjsCirclesEii);

    $Testr = ($ObjsCirclesEii / $ObjsCirclesEiii);

    // 1.167526

    // Result: 0.0668641 //
    // Result: 2.268188 //

    print $Dii;
    print $ObjsCirclesEi;
    print $ObjsCirclesEii;
    print $ObjsCirclesEiii;

    $Testrii = ($ObjsCirclesEiii - $ObjsCirclesEii)/$Dii;

    $Testr = ($ObjsCirclesEiii / $ObjsCirclesEii);
    $Testri = ($Dii/$Testr);

    $PerDiffX = percent_of( $ObjsCirclesEii ,$ObjsCirclesEiii);

    //start with a simple string
    $initial_string = "a";

    //define some rules of replacement and put them in an array
    $rules[0] = "aab->abbaaa";

    //iteratively replace and return the final result into the variable $tmp
    $tmp = aa_lsystem_replace("a",$rules,3);

    //print the result
    print($tmp);


    $drawrules[0] = "a->move 10";
    $drawrules[1] = "b->turn 90 0";

    //draw a line using the rules and an lsystem string (using the $tmp string
    // from the aa_lsystem_replace example)
    aa_lsystem_draw($tmp,$drawrules,<<0,0,0>>,0,0);

    /*
    $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
    $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    $NofCirclesa = (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
    $NofCirclesb = ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
    $NofCirclesc = ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);

    */


    clear $Xs;
    $centerX = $centerY = 0.0;
    $sides = 22.000;
    $PI = 3.1415926535;
    $away =15.00;
    $Yp=0.0;

    $r =  $away;
    $Cir = ($PI *$r )*2.00 ;
    $Seg = $Cir/8.0;
    $LengAngle = 360.000/$Seg;

    $DiffMathA = $Seg / ($Cir/100.0);
    $DiffMathAB = 360.0/(100.0/$DiffMathA);


    $angle = $LengAngle / $sides;

    for( $i=0; $i <= $sides; $i++ ){
    // How far around the center.
    $a = $i * $angle ;
    $x = (($centerX + cos( deg_to_rad($a) ) * $away));
    $y =  (($centerY + sin( deg_to_rad($a) ) * $away));
    $Xs[$i] =<<$x, $Yp, $y>>;
    }
    $ThefirstCurve = VecArrayToCurve($Xs);




    proc LogCurveDetail(vector $Direction, vector $startV, float $L){
    //vector $Direction =<< 1.0,0.0,0.0>>;
    $Normal = << 0.0,1.0,0.0>>;
    $angle = 0.00;
    $i = 0;
    $Xs[$i] = $startV;

    $AstepF = 0.035;
    $TstepF = 1.025;
    $Step = 120;
    $LSS = 0.050;

    $a = 1.0;
    for( $i=1; $i <= $Step; $i++ ){

    $angle +=$AstepF;
    $angle*=1.025;
    // $a = `logN ($angle)` ;
    $a =  ($angle);
    $Xs[$i] = RotMultLenPts($Xs[$i-1], $Direction, $Normal, $L, deg_to_rad($a) );
    $Direction= `unit (FloatToVec(DirectionFN($Xs[$i],$Xs[$i-1])))`;
    }
    $ThefirstCurve = VecArrayToCurve($Xs);
    }

    ////////////////////////////////////////////



    clear $HighCurvePoints;
    clear $NormalCurvePoints;
    clear $FoundRadii;

    $HighCurvePoints = CurvatureUtilityDetailCurvature($CurveItemA[0], 260,$NormalCurvePoints,$FoundRadii);

    print $FoundRadii;
    $CurveSizeFloat = logN(logN(logN(`log (5.605099)`)));

    clear $CurvesV;
    $LS = 0.050;
    $Cindex = 0;
    if(`size($HighCurvePoints)`>0){
    for ($eachVec in $HighCurvePoints){
    LogCurveDetail(`unit $NormalCurvePoints[$Cindex]`*-1, $eachVec, 0.005 );

    $Cindex++;

    }
    }


    clear $CurvesV;
    $LS = 0.050;
    $Cindex = 0;
    if(`size($HighCurvePoints)`>0){
    for ($eachVec in $HighCurvePoints){
    LogCurveDetail(`unit $NormalCurvePoints[$Cindex]`*-1, $eachVec, abs (((logN(`log ($FoundRadii[$Cindex]/9.0)`)))));

    $Cindex++;

    }
    }


    $Cindex = 0;
    for ($eachVec in $HighCurvePoints){

    $XLOOG = abs  (((logN(`log ($FoundRadii[$Cindex]/8.0)`))));
    print ($XLOOG +"\n");
    $Cindex++;
    }

    //$a = $angle;
    //$Xs[$i] = $Xs[$i-1]+($L*( (FloatToVec(RotDirToPoint($Xs[$i-1],$Direction,$L,$Normal, deg_to_rad($a)) ))));
    // $Xs[$i] = $Xs[$i-1]+($L*(`unit(FloatToVec(RotDirToPoint($Xs[$i-1],$Direction,$L,$Normal, deg_to_rad($a)) ))`));
    //$Xs[$i] = $Xs[$i-1]+($L*(`unit(FloatToVec(RotDirToPoint($Xs[$i-1],$Direction,$L,$Normal, atan($a) )))`));



    proc vector RotMultLenPts(vector $Vecpt, vector $Direc, vector $DirNorm, float $Length, float $Radian){
    $DirecAB = ((unit(`rot $Direc $DirNorm $Radian`))*$Length)+$Vecpt;
    return $DirecAB;
    }


    proc float logN(float $x){
    $a = (`log (abs($x))`)*(`sign($x)`) ;
    return $a;
    }


    SteinerChain(22,5);
    SteinerChain(22, 3.2);

    proc string [] SteinerChain(float $RAa, float $RBb){
    //
    // float $RAa = 22.0;
    // float $RBb = 3.2;

    $pi = 3.1415926535;
    $Pi = 3.1415926535;
    if(!( $RAa==$RBb)){
    if( $RAa<$RBb){
    $RA = $RBb;
    $RB = $RAa;}else{ $RA = $RAa; $RB =  $RBb;}

    //float $RA = 22.0;
    //float $RB = 15.68;
    $circleA = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RA -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $circleB = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RB -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $R2 = $RA;
    $R1 = $RB;
    $DCircle = (($R2 - $R1)/2.0) + $R1 ;
    $Rii = (($R2 - $R1)/2.0);
    $SideA = $RB + $Rii;
    $SideB = $Rii*2;
    //GOT it for SURE
    //HightsOfIsoscelesTriangle($SideA, $SideB, $SideA)
    $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    $ArcangleC2 = $ArcangleC*2.0;
    $Aii = (`asin ($RB/($RB + $Rii))`);
    $number3 = 360.0/$ArcangleC2;

    ////////////////####
    ///////////////###
    $NumberCs = $number3;

    $n = $number3;
    $len = $DCircle;
    $r = $DCircle;
    $angle = 360.0 / $n ;
    print $angle;

    $x = createRegularPolygonX( $n, $r ) ;
    $y = createRegularPolygonY( $n, $r ) ;

    // create the n-sided polygon.
    $z = 0.0 ;




    $LItem = `ls -sl`;
    $VCirPosX = `xform -q -ws -t $LItem[0]`;


    matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;

    $Normal = <<0.0, 1.0, 0.0>>;


    $VecPairA[0]= <<0.0, 1.0, 0.0>>;
    $VecPairA[1]= $VecPairA[0]*2;

    $matrixA = TwoPointMatrixPlusAxisWorld($VecPairA, $EmptyVecA, 1);
    $matrixA  = TwoPointMatrixB($VecPairA);
    $DirectionStart = <<$matrixA[0][0], $matrixA[0][1], $matrixA[0][2] >>;
    $angle = 360.0 / ($n*2) ;
    $rotatsB = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($angle)) );
    $DirectionStartB = <<$rotatsB[0], $rotatsB[1], $rotatsB[2] >>;
    $DirectionStartB = `unit($DirectionStartB)`;
    Loc $DirectionStartB;

    //RotMultLenToDirAddToPoint(float $PosA[], float $PosB[], float $Length, float $DirNormAx[], float $Radian)
    // float $rotatsA[] = RotDirToPoint($DirectionStart, $VCirPosX,$RA, $Normal, $a );
    $angle = 360.0 / $n ;




    for( $i = 0 ; $i < ($n) ; $i++ ) {
    $a = $i * $angle ;
    $rotatsA = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($a)) );
    Loc $rotatsA;

    }


    for( $i = 0 ; $i < ($n) ; $i++ ) {
    $a = $i * $angle ;
    $rotatsA = RotDirToPoint($VCirPosX,$DirectionStart, $RB, $Normal, (deg_to_rad($a)) );
    Loc $rotatsA;

    }


    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < ($n) ; $i++ ) {
    $a = $i * $angle ;
    $rotatsA = RotDirToPoint($VCirPosX,$DirectionStartB, $r, $Normal, (deg_to_rad($a)) );
    $VrotatsA[$i] =   FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $r, $Normal, (deg_to_rad($a)) ));

    Loc $rotatsA;

    }
    //////////////////////////////////


    for( $i = 0 ; $i < $n ; $i++ ) {

    $a = $i * $angle ;
    $rotatsA = RotDirToPoint($VCirPosX,$DirectionStart, $r, $Normal, (deg_to_rad($a)) );

    $VrotatsCiH[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $RA, $Normal, (deg_to_rad(($a))) ));
    $VrotatsBiH[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $RB, $Normal, (deg_to_rad(($a))) ));
    Loc $VrotatsCiH[$i];

    $VrotatsCi[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($a)) ));
    $VrotatsBi[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $r, $Normal, (deg_to_rad($a)) ));

    $VrotatsAi[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStart, $RB, $Normal, (deg_to_rad($a)) ));


    $CirclePts = <<$rotatsA[0], $rotatsA[1], $rotatsA[2] >>;

    $DirLine = DirectionFN($CirclePts, $VCirPosX);
    $Vperp = crossProduct( $DirLine, $Normal, 0, 0 );
    $Vperp = `unit($Vperp + $DirLine)`;
    $VperpN = crossProduct( $DirLine, ($Normal*-1.0), 0, 0 );
    $VperpN = `unit( ($VperpN) + ($DirLine))`;

    $VperpA = ($Rii/2.0)* $VperpN*-1.0;
    $VperpA = $CirclePts+$VperpA;
    Loc $VperpA;


    curve2points($VrotatsBi[$i],$VrotatsCiH[$i]);

    if($i>0){

    curve2points($VrotatsBi[$i-1],$VperpA);


    }
    if($i==0){
    $Templast= $VperpA;}

    $VperpC = ($Rii/2.0)*$DirLine;
    $VperpC = $CirclePts+$VperpC;
    Loc $VperpC;
    curve2points($VrotatsCi[$i],$VperpC);
    /////////////

    $VperpB = ( $Rii/2.0)*$Vperp*-1.0;
    $VperpB = $CirclePts+$VperpB;
    Loc $VperpB;
    curve2points($VrotatsBi[$i],$VperpB);

    /////////////////////

    $VperpD = (-1*$Rii/2.0)*$DirLine;
    $VperpD = $CirclePts+$VperpD;
    Loc $VperpD;

    curve2points($VrotatsAi[$i],$VperpD);
    curve2points($VrotatsBi[$i],$VrotatsBiH[$i]);

    if($i==($n-1)){
    curve2points($VrotatsBi[$i],$Templast);
    }

    $circlesC = `circle -c $rotatsA[0] $rotatsA[1] $rotatsA[2] -nr 0 0 1 -sw 360 -r ($Rii/2.0) -d 3 -ut 0 -tol 0.001 -s 16 -ch 1`;
    $circles[$i] = $circlesC[0];
    makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $circles[0];
    xform -cp $circles[$i];
    }



    //$circles[`size($circles)`] = $circleA[0];
    //$circles[`size($circles)`] = $circleB[0];
    select -r $circleA $circleB $circles ;
    //select -r $circles ;
    return $circles;
    }
    }


    proc  Circle3PtZB(){
    ResetTransEachSL;



    $selectionList = `ls -sl`;

    $veCPos1[0] = `xform -q -ws -t $selectionList[0]`;
    $veCPos1[1] = `xform -q -ws -t $selectionList[1]`;
    $veCPos1[2] = `xform -q -ws -t $selectionList[2]`;

    $p1 = `xform -q -ws -t $selectionList[0]`;
    $p2 = `xform -q -ws -t $selectionList[1]`;
    $p3 = `xform -q -ws -t $selectionList[2]`;

    // Get the vector p1-p2, p1-p3
    //
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $p1p4[0] = $p2[0]-$p3[0]; 		$p1p4[1] = $p2[1]-$p3[1]; 		$p1p4[2]= $p2[2]-$p3[2];

    // Get the normal to the plane formed by p1, p2, p3, which is the
    // cross prod of p1-p2 and p1-p3

    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );


    //float $OrthoCenterC = midPoint2Pts( $FloatPos1, $p3 );
    $FloatPosZero = {0, 0, 0};
    $FloatDirection = DirectionF($FloatPosZero, $normal);
    $MultDirP = multiplyFloat(2, $FloatDirection);
    //float $FloatDirectionPoint[] = AddFloats($MultDirP, $FloatPos1);


    // Get the mid pts on each vector (the average of two pts)
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $mid3 = midPoint2Pts( $p2, $p3 );

    //$mid1 a-b $mid2 a-c $mid3 b-c


    // Get the perp. vectors to p1-p2 and p1-p3, which is the
    // cross prod of the normal vector with p1-p2 and p1-p3. Get these
    // as normalized vectors before sending them to lineIntersection

    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $perp_p1p4 = crossProduct( $normal, $p1p4, 0, 1 );



    // Intersect the persp. vectors going through the mid pts.
    // The intersection is the center of the arc.
    //
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    //spaceLocator -p 0 0 0;
    //MoveObject2($center);

    //FloatDirPerpCenter is FloatDirPerpCenterA
    $FloatDirPerpCenter = DirectionF($center, $mid3);
    $FloatDirPerpCenterB = DirectionF($center,$mid1);
    $FloatDirPerpCenterC = DirectionF($center,$mid2);

    $FloatDirPointAB = DirectionF($p1, $p2);
    $FloatDirPointBC = DirectionF($p2, $p3);
    $FloatDirPointAC = DirectionF($p1, $p3);


    //MidPoint of Iso Tri
    $center6 = lineIntersection( $p1, $FloatDirPerpCenter, $p2, $FloatDirPointBC );


    $center7 = lineIntersection( $p3,  $FloatDirPerpCenterB, $p1, $FloatDirPointAB );


    $center8 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );

    $center9 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPerpCenter );

    $OrthoCenterCir = midPoint2Pts( $center9, $center );


    $Radius2HalfTimes2 = (distance2Pts( $center9, $center ))*2;
    $Radius2BHalf = (distance2Pts( $center9, $center ));

    // Find the radius for the circle and return the radius.
    //

    $radiusZ = distance2Pts( $p1, $center );
    $Radius3Half = $radiusZ/2;

    //string $circlesItemB[];
    //$circlesItemB[0] = Circles_Direction($OrthoCenterCir, $FloatDirection, $Radius2HalfTimes2);

    //string $circlesItemC[];
    //$circlesItemC[0] = Circles_Direction($OrthoCenterCir, $FloatDirection,  $Radius2BHalf);

    $circlesItem[0] = Circles_Direction($center, $FloatDirection, $radiusZ);


    }

    Circle3PtZB;




    clear $Xs;
    $centerX = $centerY = 0.0;
    $sides = 22.000;
    $PI = 3.1415926535;
    $away =22.0;
    $Yp=0.0;

    $r =  $away;
    $Cir = ($PI *$r )*2.00 ;
    $Seg = $Cir/8.0;

    $LengAngle = 360.000/$n;
    $angle = $LengAngle / $sides;

    $Start_angle = (90.0);

    for( $k=0; $k < $n; $k++ ){


    for( $i=0; $i <= $sides; $i++ ){
    // How far around the center.
    $a = ($i * $angle)+$Start_angle ;
    $End_angle=$a;
    $x = (($centerX + cos( deg_to_rad($a) ) * $away));
    $y =  (($centerY + sin( deg_to_rad($a) ) * $away));
    $Xs[$i] =<<$x, $Yp, $y>>;
    }
    $ThefirstCurve = VecArrayToCurve($Xs);
    $Start_angle = $End_angle;


    $VecCurEndsa = VecCurveEnds({$ThefirstCurve});
    for($eachV in $VecCurEndsa){
    $Locs[0] = `Loc ($eachV)`;
    SetItemColorString ($Locs[0], 6);
    }
    }



    $centerX = $centerY = 0.0;
    $sides = 22.000;
    $PI = 3.1415926535;
    $away =15.00;
    $Yp=0.0;

    $r =  $away;
    $Cir = ($PI *$r )*2.00 ;
    $Seg = $Cir/8.0;
    $LengAngle = 360.000/$Seg;

    $angle = $LengAngle / $sides;

    for( $i=0; $i <= $sides; $i++ ){
    // How far around the center.
    $a = $i * $angle ;
    $x = (($centerX + cos( deg_to_rad($a) ) * $away));
    $y =  (($centerY + sin( deg_to_rad($a) ) * $away));
    $Xs[$i] =<<$x, $Yp, $y>>;
    }
    $ThefirstCurve = VecArrayToCurve($Xs);







    clear $Xs;
    $centerX = $centerY = 0.0;
    $sides = 22.000;
    $PI = 3.1415926535;
    $away =15.00;
    $Yp=0.0;

    $r =  $away;
    $Cir = ($PI *$r )*2.00 ;
    $Seg = $Cir/8.0;
    $LengAngle = 360.000/$Seg;

    $DiffMathA = $Seg / ($Cir/100.0);
    $DiffMathAB = 360.0/(100.0/$DiffMathA);


    $angle = $LengAngle / $sides;

    for( $i=0; $i <= $sides; $i++ ){
    // How far around the center.
    $a = $i * $angle ;
    $x = (($centerX + cos( deg_to_rad($a) ) * $away));
    $y =  (($centerY + sin( deg_to_rad($a) ) * $away));
    $Xs[$i] =<<$x, $Yp, $y>>;
    }
    $ThefirstCurve = VecArrayToCurve($Xs);




    proc float[] createRegularPolygonY( int $n, float $r )
    {
    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * cos(deg_to_rad($a)) ;
    }
    return $x ;
    }
    proc float[] createRegularPolygonX( int $n,float $r )
    {
    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * sin(deg_to_rad($a)) ;
    }
    return $x ;
    }


    //arclen

    // 159.434902 = C of circle    .. 12.000  = bounding Box of object

    $DiffMathA = 12.000 / (159.434902/100.0);
    $LengAngle = 360.000/$DiffMathA;
    $angle = 180.000/$sides;

    clear $Xs;
    $centerX = $centerY = 0;
    $sides = 22.000;
    $PI = 3.1415926535;
    $away =25.378;
    $Yp=0.0;
    $DiffMathA = 12.0 / (159.434902/100.0);

    //float $DiffMathAB = 360.0/(100.0/$DiffMathA);

    $LengAngle = 360.0/(100.0/$DiffMathA);


    $angle = $LengAngle / $sides;

    for( $i=0; $i <= $sides; $i++ ){
    // How far around the center.
    $a = $i * $angle ;
    $x = (($centerX + cos( deg_to_rad($a) ) * $away));
    $y =  (($centerY + sin( deg_to_rad($a) ) * $away));
    $Xs[$i] =<<$x, $Yp, $y>>;
    }
    $ThefirstCurve = VecArrayToCurveB($Xs);




    SteinerChain(22,5);

    proc string [] SteinerChain(float $RAa, float $RBb){
    //
    //float $RA = 22.0;
    //float $RB = 15.680;
    $pi = 3.1415926535;
    $Pi = 3.1415926535;
    if(!( $RAa==$RBb)){
    if( $RAa<$RBb){
    $RA = $RBb;
    $RB = $RAa;}else{ $RA = $RAa; $RB =  $RBb;}
    //float $RA = 22.0;
    //float $RB = 15.68;
    $circleA = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RA -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $circleB = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RB -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $R2 = $RA;
    $R1 = $RB;
    $DCircle = (($R2 - $R1)/2.0) + $R1 ;
    $Rii = (($R2 - $R1)/2.0);
    $SideA = $RB + $Rii;
    $SideB = $Rii*2;
    //GOT it for SURE

    $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    $ArcangleC2 = $ArcangleC*2.0;
    //float $Aii =  (`asin ($RB/($RB + $Rii))`);
    $number3 = 360.0/$ArcangleC2;
    $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
    $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    $NofCirclesa = (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
    $NofCirclesb = ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
    $NofCirclesc = ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);

    $NumberCs = $number3;
    $n = $NumberCs;
    $len = $DCircle;
    $r = $DCircle;
    $x = createRegularPolygonX( $n, $r ) ;
    $y = createRegularPolygonY( $n, $r ) ;
    // create the n-sided polygon.
    $z = 0.0 ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $circlesC = `circle -c $x[$i] $y[$i] $z -nr 0 0 1 -sw 360 -r $Rii -d 3 -ut 0 -tol 0.001 -s 16 -ch 1`;
    $circles[`size($circles)`] = $circlesC[0];
    makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $circles[0];
    xform -cp $circles[0];
    //rotate -r -os 0 0 45 $circles[0];
    //aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "scene" $circleB[0] $circles[0];

    }
    //$circles[`size($circles)`] = $circleA[0];
    //$circles[`size($circles)`] = $circleB[0];
    select -r $circleA $circleB $circles ;
    //select -r $circles ;
    return $circles;
    }
    }









    $CurveItemAXX = `ls -sl`;


    $CurveItemAX = `ls -sl`;
    CurvesToPlane( $CurveItemAX);

    $CurveItemAX = `ls -sl`;
    VanishingCurvesS({$CurveItemAX[0]})



    $LengthsT = ArcLengthArray(`ls -sl`);
    AnglesofTriangle($LengthsT[0], $LengthsT[1], $LengthsT[2]);


    $LengthsM = ArcLengthArray(`ls -sl`);
    // Result: 41.305301 //

    $Lengths = ArcLengthArray(`ls -sl`);
    // Result: 48.907858 46.767741 35.03743 37.820183 //
    1          2          3     4

    for($eachF in $Lengths){
    $LengthsSub[`size($LengthsSub)`] = $eachF - $LengthsM[0];

    }
    print $LengthsSub;
    7.602557
    5.46244
    -6.267871
    -3.485118

    0.115505
    0.15301
    0.163837
    0.183377

    $PerDiff = percent_of($LengthsM[0], $Lengths[3]);
    // Result: 1.184058 //
    // Result: 1.132245 //
    // Result: 1.178891 //
    // Result: 1.09215 //

    $LengthsC = ArcLengthArray(`ls -sl`);
    // Result: 0.115 0.153 0.163 0.183 //
    4       3      2       1
    print $LengthsC;



    $Positions = VecCurveEps($CurveItemAX[0]);



    //GetworldMatrix(string $object)

    $CamMatrix = GetMatrix("ZCURVEModelingCAM");

    $SbMatrix= GetMatrix("LiveSurfaceB");

    PrintMatrix($CamMatrix , 4);
    |   0.7071067812              0  -0.7071067812              0|
    |  -0.2988362387    0.906307787  -0.2988362387              0|
    |   0.6408563821   0.4226182617   0.6408563821              0|
    |             48             41             48              1|

    PrintMatrix($SbMatrix , 4);
    |   0.7071067812              0  -0.7071067812              0|
    |   0.6408563821   0.4226182617   0.6408563821              0|
    |   0.2988362387   -0.906307787   0.2988362387              0|
    |    47.51487706    40.68008189    47.51487706              1|


    $CamMatrixR = GetMatrix("ZCURVEModelingCAM");
    $SbMatrixR= GetMatrix("LiveSurfaceB");

    PrintMatrix($CamMatrixR , 4);
    |   0.3971478906              0  -0.9177546257              0|
    |  -0.2713874308   0.9552783621  -0.1174398283              0|
    |   0.8767111357     0.29570805   0.3793867865              0|
    |    65.68910652    31.48173412    28.38978033              1|

    PrintMatrix($SbMatrixR , 4);
    |   0.3971478906              0  -0.9177546257              0|
    |   0.8767111357     0.29570805   0.3793867865              0|
    |   0.2713874308  -0.9552783621   0.1174398283              0|
    |    65.02544355    31.25788598    28.10258772              1|


    $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM`;
    $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM`;
    // Result: <<48, 41, 48>>  //
    // Result: <<-25, 45, 0>>  //


    Loc $Cam_Trans;

    $Plane_Trans = `xform -q -ws -t LiveSurfaceB`;
    $Plane = `xform -q -ws -ro LiveSurfaceB`;


    setAttr "ZCURVEModelingCAM.rotateX" -25;
    setAttr "ZCURVEModelingCAM.rotateY" 45;
    setAttr "ZCURVEModelingCAM.rotateZ" 0;

    setAttr "ZCURVEModelingCAM.translate" 48 41 48;

    $PtsVec = PointArrayT(`ls -sl`);
    $FDirNorA = Normal3Points($PtsVec[0], $PtsVec[1],$PtsVec[2]);
    $VCrvPos_AA =  FloatToVec(AverageVectorPoint($PtsVec));

    makeCurvePointDirectionLength(22, $FDirNorA, $VCrvPos_AA);


    ////////////

    $PtsVec = PointArrayT(`ls -sl`);
    AnglesofTriangleThreeVec($PtsVec[0], $PtsVec[1],$PtsVec[2]);
    /////////////////



    $VCrvPos_A =  FloatToVec(AverageVectorPoint($PtsVec));
    Loc $VCrvPos_A;

    $LItem = `ls -sl`;
    $VLocPosX = `xform -q -ws -t $LItem[0]`;


    InsidePolygon($Positions,$VLocPosX);

    proc int InsidePolygon(vector $c[],vector $VLocPos_A)
    {

    $VCrvPos_A =  FloatToVec(AverageVectorPoint($c));

    $x = VecCom($VLocPos_A, 0);
    $y = VecCom($VLocPos_A, 1);

    // Convex is just a collection of points for the polygon
    // just replace that code in the for-loop to loop through the points in your polygon

    $PI = 3.1415926535;
    $angle = 0;
    $Distance = 0;
    $DistanceMM = 0;
    $Arc = 0;
    $p1x = 0, $p1y = 0, $p2x = 0, $p2y = 0;
    $SizeV = size($c);
    $TotalS = $SizeV;
    $triarea = 0;
    $tri_areaM = 0;
    $countS =1;

    for ($i=0;$i< $SizeV; $i++) {

    $indexState = $i;
    $indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
    $indexRight = fmod(($indexState + $countS),$TotalS);
    $DistA = distance2Pts($c[$i], $c[$indexLeft]);
    $DistB = distance2Pts($c[$i], $c[$indexRight]);
    if($DistA<$DistB){
    $nearestIndex = $indexLeft;
    }else{$NearIndex = $indexRight;}
    /*
    $p1x = ( (VecCom($c[$i], 0)) - $x ); // point A X - X
    $p1y = ( (VecCom($c[$i], 1)) - $y ); // point A Y - Y
    $p2x = ( (VecCom($c[$NearIndex], 0)) - $x ); // point A's nearest neighbor X - X
    $p2y = ( (VecCom($c[$NearIndex], 1)) - $y ); // point A's nearest neighbor Y - Y
    */
    $aP = distance2Pts($c[$i], $c[$indexRight]);
    $bP = distance2Pts($VLocPos_A, $c[$indexRight]);
    $cP = distance2Pts($c[$i], $VLocPos_A);
    $triarea += 0.25* (sqrt ( ($aP+$bP+$cP)  * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP)  ));
    $aPm = distance2Pts($c[$i], $c[$indexRight]);
    $bPm = distance2Pts($VCrvPos_A, $c[$indexRight]);
    $cPm = distance2Pts($c[$i], $VCrvPos_A);
    $tri_areaM += 0.25* (sqrt ( ($aPm+$bPm+$cPm)  * ($bPm+$cPm-$aPm) * ($cPm+$aPm-$bPm) * ($aPm+$bPm-$cPm)  ));
    $DistanceMM += distance2Pts($c[$i], $VCrvPos_A);
    $Distance += distance2Pts($c[$i], $VLocPos_A);
    //$angle += Angle2D($p1x,$p1y,$p2x,$p2y);
    $Arc += distance2Pts($c[$i], $c[$indexRight]);
    }

    //print ("Tri_area: "+$triarea + "\n");
    //print ("Tri_areaM: "+$tri_areaM+ "\n");
    /*
    if (abs($angle) < $PI){
    print (" INSIDE " + "\n");
    }else{ print (" OUTSIDE! " + "\n");}
    */

    // if (equivalentTol($triarea, $tri_areaM,  0.00001) ==1){
    //print ("Tri_area INSIDE " + "\n");
    //}else{ print ("Tri_area OUTSIDE! " + "\n");}

    //   if (abs($angle) < $PI){//
    if (equivalentTol($triarea, $tri_areaM,  0.00001) ==1){
    return 1;
    }else{
    return 0;}

    }


    proc float VecCom(vector $Vai, int $XYZ){
    $x = $Vai.x;
    $y = $Vai.y;
    $z = $Vai.z;
    if($XYZ==0){$N=$x;} if($XYZ==1){$N=$y;} if($XYZ==2){$N=$z;}
    return $N;
    }


    proc float Angle2D(float $x1, float $y1, float $x2, float $y2)
    {
    $PI = 3.1415926535;
    $TWO_PI = 3.1415926535;


    $theta1 = atan2($y1,$x1);
    $theta2 = atan2($y2,$x2);
    $dtheta = $theta2 - $theta1;

    while ($dtheta > $PI)
    $dtheta -= $TWO_PI;
    while ($dtheta < -$PI)
    $dtheta += $TWO_PI;


    return $dtheta;
    }

    /*


    $Arc = `arclen $CurveItemAX[0]`;
    $AverageVecCurve = AverageVectorPoint($Positions);

    //////////

    $DDistPt_toC = distance2Pts($VCrvPos_A, $VLocPos_A);
    $DDist = $Distance/float($TotalS);
    print ("Dist_each/SIZE: "+$DDist + "\n");
    //Dist_each/SIZE: 18.31929743
    print (" dist_to_M: "+ $DDistPt_toC+"  dist_each: "+$DDist + "\n");
    $DDistX = $Distance+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    $DDistMM = $DistanceMM+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    $DDistMM = $DistanceMM/float($TotalS);
    $MathA = $DDistMM/$DDist;
    $MathB = $DDistPt_toC/$MathA;
    print $Arc;
    outside
    dist_to_M: 8.210088295  dist_each: 10.678618
    dist_to_M: 10.98501803  dist_each: 19.20895454
    inside
    dist_to_M: 4.491177258  dist_each: 10.90761121
    dist_to_M: 2.733438324  dist_each: 15.81548968
    print (" distance to crv middle "+ $DDistPt_toC+" dist to each crv div "+$DDist + "\n");
    //float $Xpi = $PI/$angle;
    //float $XTpi = $Xpi*$angle;
    print ($angle + "\n");
    */

}


/******************************************************************************
 * @procedure    StringArrayCountIndexDup
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *   $Count : int
 *
 * @returns      int[]
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int[] StringArrayCountIndexDup(string $item, string $list[], int $Count)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = 0;
    int $index = 0;
    int $indexArray[];
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = 0;
    $index = 0;

    for ($listItem in $list) {

    if ($item == $listItem){
    $indexArray[$result] = $index;
    $result++;}

    $index++;
    }
    $Count = $result;
    return $indexArray;

}


/******************************************************************************
 * @procedure    FindifCurveEndsMeetIndex
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $CurveA1 : vector[]
 *   $CurveA2 : vector[]
 *   $TF : int
 *
 * @returns      int []
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] FindifCurveEndsMeetIndex(vector $CurveA1[], vector $CurveA2[], int $TF)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CurveMeetsTrue = 0;
    int $indexN = 0;
    int $indexN2 = 0;
    int $IndexEnds[];
    int $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    int $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveMeetsTrue = 0;
    $indexN = 0;
    $indexN2 = 0;

    while ($indexN < 2){

    $firstC = $CurveA1[$indexN];
    $SecondC = $CurveA2[0];
    $SecondCA = $CurveA2[1];

    $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);

    if ($NumberE == 3){
    if($indexN==0){
    $IndexEnds[0]=1; $IndexEnds[1]=0; $IndexEnds[2]=1; $IndexEnds[3]=0;

    }else{
    $IndexEnds[0]=0; $IndexEnds[1]=1; $IndexEnds[2]=1; $IndexEnds[3]=0;

    }
    $CurveMeetsTrue = 1;
    break; }

    if ($NumberE2 == 3){

    if($indexN==0){
    $IndexEnds[0]=1; $IndexEnds[1]=0; $IndexEnds[2]=0; $IndexEnds[3]=1;

    }else{

    $IndexEnds[0]=0; $IndexEnds[1]=1; $IndexEnds[2]=0; $IndexEnds[3]=1;}
    $CurveMeetsTrue = 1;
    break; }

    if ($indexN==1){$indexN1 = 1;}
    $indexN++;
    }

    $TF = $CurveMeetsTrue;
    return $IndexEnds;

}


/******************************************************************************
 * @procedure    IfCurvesTouchIndex
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $curveA : string
 *   $curveB : string
 *   $TFa : int
 *
 * @returns      int []
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IfCurvesTouchIndex(string $curveA, string $curveB, int $TFa)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $TF = 0;
    int $intIfTrue[] = FindifCurveEndsMeetIndex($CurveOne, $CurveTwo, $TF);
    vector $CurveOne[] = GetVectorArrayBetweenCurveEnds({$curveA});
    vector $CurveTwo[] = GetVectorArrayBetweenCurveEnds({$curveB});

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveOne = GetVectorArrayBetweenCurveEnds({$curveA});
    $CurveTwo = GetVectorArrayBetweenCurveEnds({$curveB});
    $TF = 0;
    $intIfTrue = FindifCurveEndsMeetIndex($CurveOne, $CurveTwo, $TF);
    $TFa = $TF;
    return $intIfTrue;

}


/******************************************************************************
 * @procedure    IfCurvesTouchIndexZ
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $curveA : string
 *   $curveB : string
 *   $TFa : int
 *
 * @returns      int []
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IfCurvesTouchIndexZ(string $curveA, string $curveB, int $TFa)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $TF = 0;
    int $intIfTrue[] = FindifCurveEndsMeetIndexZ($CurveOne, $CurveTwo, $TF);
    vector $CurveOne[] = GetVectorArrayBetweenCurveEnds({$curveA});
    vector $CurveTwo[] = GetVectorArrayBetweenCurveEnds({$curveB});

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveOne = GetVectorArrayBetweenCurveEnds({$curveA});
    $CurveTwo = GetVectorArrayBetweenCurveEnds({$curveB});
    $TF = 0;
    $intIfTrue = FindifCurveEndsMeetIndexZ($CurveOne, $CurveTwo, $TF);
    $TFa = $TF;
    return $intIfTrue;

}


/******************************************************************************
 * @procedure    FindifCurveEndsMeetIndexZ
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $CurveA1 : vector[]
 *   $CurveA2 : vector[]
 *   $TF : int
 *
 * @returns      int []
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] FindifCurveEndsMeetIndexZ(vector $CurveA1[], vector $CurveA2[], int $TF)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CurveMeetsTrue = 0;
    int $indexN = 0;
    int $indexN2 = 0;
    int $IndexEnds[];
    int $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    int $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveMeetsTrue = 0;
    $indexN = 0;
    $indexN2 = 0;

    while ($indexN < 2){

    $firstC = $CurveA1[$indexN];
    $SecondC = $CurveA2[0];
    $SecondCA = $CurveA2[1];

    $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);

    if ($NumberE == 3){
    if($indexN==0){
    $IndexEnds[0]=0; $IndexEnds[1]=0;

    }else{
    $IndexEnds[0]=1; $IndexEnds[1]=0;
    }
    $CurveMeetsTrue = 1;
    break; }

    if ($NumberE2 == 3){

    if($indexN==0){
    $IndexEnds[0]=0; $IndexEnds[1]=1;
    }else{

    $IndexEnds[0]=1; $IndexEnds[1]=1; }
    $CurveMeetsTrue = 1;
    break; }

    if ($indexN==1){$indexN1 = 1;}
    $indexN++;
    }

    $TF = $CurveMeetsTrue;
    return $IndexEnds;

}


/******************************************************************************
 * @procedure    GetVectorArrayCRVEnds
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $CurveItemZ : string[]
 *
 * @returns      vector[]
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] GetVectorArrayCRVEnds(string $CurveItemZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs;
    int $num;
    string $CurveSelection[];
    vector $CurveAB[];
    vector $eachCVposV;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    for ($CurveItem in $CurveItemZ) {
    $numCVs = `getAttr -size ($CurveItem +  ".controlPoints")`;
    $num = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem + ".cv[" +  $num + "]") ;
    for ($eachZA in $CurveSelection) {
    $eachCVposV = `pointPosition -w ($eachZA)`;
    $CurveAB[`size($CurveAB)`] = $eachCVposV;
    }
    }
    return $CurveAB;

}


/******************************************************************************
 * @procedure    LineIntersectCirTFZ
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $ObjsCirclesRad : float
 *   $CircPos : vector[]
 *   $PosA : vector
 *   $PosB : vector
 *
 * @returns      int
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int LineIntersectCirTFZ(float $ObjsCirclesRad, vector $CircPos[], vector $PosA, vector $PosB)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $ObjsCirclesE = `arclen`*2.0;
    float $ObjsCirclesEi = `arclen`;
    float $ObjsCirclesEii = `arclen`;
    float $Di = distance2Pts( $CircPos , $PointN);
    float $PointN[] = ClosestPoint2Line($VecLineDir, $PosA, $CircPos);
    float $DiffL = ($ObjsCirclesRad-$Di)*2.0;
    float $FloatDirXn[] = DirectionF( $Vec[2], $Vec[0]);
    float $PointNii[] = MultLenToDirAddToPoint($Di, DirectionF( $Vec[2], $PointN), $PointN);
    float $DistAddiR2 = $Di*2.0;
    float $HightD = sqrt (abs ((`pow $Di 2.0`) - (`pow $ObjsCirclesRad 2.0`)));
    float $PointNiii[] = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[1], $Vec[0]), $PointN);
    float $PointNiiiB[] = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[0], $Vec[1]), $PointN);
    vector $AVecArrayPos_MC[];
    vector $VecCamPos_A;
    vector $CircPos = $VecArrayPos_MC[1];
    vector $PosA = $VecCamPos_A;
    vector $PosB = $AVecArrayPos_MC[0];
    vector $VecLineDir = PositiveDirectionLine($PosA, $PosB);
    vector $Vec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $AVecArrayPos_MC = PointArrayT(`ls-sl`);


    LineIntersectCirTFZ(float $ObjsCirclesRad, vector $CircPos, vector $PosB){


    $AVecArrayPos_MC = PointArrayT(`ls-sl`);

    $VecCamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;

    $CircPos = $VecArrayPos_MC[1];
    $PosA = $VecCamPos_A;
    $PosB = $AVecArrayPos_MC[0];
    $ObjsCirclesE = `arclen`*2.0;


    $ObjsCirclesEi = `arclen`;
    $ObjsCirclesEii = `arclen`;
    // Result: 0.41585 //
    // Result: 14.251443 //

    // Result: 23.164589 //
    // Result: 0.191253 //

    $Di = distance2Pts( $CircPos , $PointN);

    $VecLineDir = PositiveDirectionLine($PosA, $PosB);
    //float $ObjsCirclesRad = `arclen`*2.0;
    // $ObjsCirclesRad = $ObjsCirclesRad/2.0;

    $PointN = ClosestPoint2Line($VecLineDir, $PosA, $CircPos);
    Loc $PointN;
    curve2points($PosB, $PointN);
    print  $ObjsCirclesRad;

    $Di = distance2Pts( $CircPos , $PointN);
    $DiffL = ($ObjsCirclesRad-$Di)*2.0;

    //$Di = $ObjsCirclesRad;

    $Vec[0] = $PosA;
    $Vec[1] = $PosB;
    $Vec[2] = $CircPos;


    $FloatDirXn = DirectionF( $Vec[2], $Vec[0]);
    $PointNii = MultLenToDirAddToPoint($Di, DirectionF( $Vec[2], $PointN), $PointN);
    Loc $PointNii;
    $DistAddiR2 = $Di*2.0;
    $HightD = sqrt (abs ((`pow $Di 2.0`) - (`pow $ObjsCirclesRad 2.0`)));
    $PointNiii = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[1], $Vec[0]), $PointN);
    Loc $PointNiii;

    $PointNiiiB = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[0], $Vec[1]), $PointN);
    Loc $PointNiiiB;
    curve2points($PointNiii,$PointNiiiB);



    if($Di<$eachObjsCirclesRad){
    $returnValue =1; break;}
    if($Di==$eachObjsCirclesRad){
    $returnValue =0;}
    if($Di>$eachObjsCirclesRad){
    $returnValue =-1;}
    $IndexI++;
    }

    return $returnValue;

}


/******************************************************************************
 * @procedure    RotMultLenPts
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $Vecpt : vector
 *   $Direc : vector
 *   $DirNorm : vector
 *   $Length : float
 *   $Radian : float
 *
 * @returns      vector
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector RotMultLenPts(vector $Vecpt, vector $Direc, vector $DirNorm, float $Length, float $Radian)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $DirecAB = ((unit(`rot $Direc $DirNorm $Radian`))*$Length)+$Vecpt;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $DirecAB = ((unit(`rot $Direc $DirNorm $Radian`))*$Length)+$Vecpt;
    return $DirecAB;

}


/******************************************************************************
 * @procedure    logN
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $x : float
 *
 * @returns      float
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float logN(float $x)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $a;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $a = (`log (abs($x))`)*(`sign($x)`) ;
    return $a;

}


/******************************************************************************
 * @procedure    SteinerChain
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $RAa : float
 *   $RBb : float
 *
 * @returns      string []
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] SteinerChain(float $RAa, float $RBb)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $NumberCs = $number3;
    int $n = $number3;
    int $i;
    float $pi = 3.1415926535;
    float $Pi = 3.1415926535;
    float $RA;
    float $RB;
    float $R2 = $RA;
    float $R1 = $RB;
    float $DCircle = (($R2 - $R1)/2.0) + $R1;
    float $Rii = (($R2 - $R1)/2.0);
    float $SideA = $RB + $Rii;
    float $SideB = $Rii*2;
    float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    float $ArcangleC2 = $ArcangleC*2.0;
    float $Aii = (`asin ($RB/($RB + $Rii))`);
    float $number3 = 360.0/$ArcangleC2;
    float $len = $DCircle;
    float $r = $DCircle;
    float $angle = 360.0 / $n;
    float $x[] = createRegularPolygonX( $n, $r );
    float $y[] = createRegularPolygonY( $n, $r );
    float $z = 0.0;
    float $rotatsB[] = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($angle)) );
    float $a = $i * $angle;
    float $rotatsA[] = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($a)) );
    float $Templast[];
    string $circleA[];
    string $circleB[];
    string $circles[];
    string $circlesC[];
    string $LItem[] = `ls -sl`;
    vector $VCirPosX;
    vector $Normal = <<0.0, 1.0, 0.0>>;
    vector $VecPairA[];
    vector $EmptyVecA[];
    vector $DirectionStart = <<$matrixA[0][0], $matrixA[0][1], $matrixA[0][2] >>;
    vector $DirectionStartB = <<$rotatsB[0], $rotatsB[1], $rotatsB[2] >>;
    vector $VrotatsA[];
    vector $VrotatsCiH[];
    vector $VrotatsBiH[];
    vector $VrotatsCi[];
    vector $VrotatsBi[];
    vector $VrotatsAi[];
    vector $CirclePts = <<$rotatsA[0], $rotatsA[1], $rotatsA[2] >>;
    vector $DirLine = DirectionFN($CirclePts, $VCirPosX);
    vector $Vperp = crossProduct( $DirLine, $Normal, 0, 0 );
    vector $VperpN = crossProduct( $DirLine, ($Normal*-1.0), 0, 0 );
    vector $VperpA = ($Rii/2.0)* $VperpN*-1.0;
    vector $VperpC = ($Rii/2.0)*$DirLine;
    vector $VperpB = ( $Rii/2.0)*$Vperp*-1.0;
    vector $VperpD = (-1*$Rii/2.0)*$DirLine;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    //
    // float $RAa = 22.0;
    // float $RBb = 3.2;

    $pi = 3.1415926535;
    $Pi = 3.1415926535;
    if(!( $RAa==$RBb)){
    if( $RAa<$RBb){
    $RA = $RBb;
    $RB = $RAa;}else{ $RA = $RAa; $RB =  $RBb;}

    //float $RA = 22.0;
    //float $RB = 15.68;
    $circleA = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RA -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $circleB = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RB -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $R2 = $RA;
    $R1 = $RB;
    $DCircle = (($R2 - $R1)/2.0) + $R1 ;
    $Rii = (($R2 - $R1)/2.0);
    $SideA = $RB + $Rii;
    $SideB = $Rii*2;
    //GOT it for SURE
    //HightsOfIsoscelesTriangle($SideA, $SideB, $SideA)
    $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    $ArcangleC2 = $ArcangleC*2.0;
    $Aii = (`asin ($RB/($RB + $Rii))`);
    $number3 = 360.0/$ArcangleC2;

    ////////////////####
    ///////////////###
    $NumberCs = $number3;

    $n = $number3;
    $len = $DCircle;
    $r = $DCircle;
    $angle = 360.0 / $n ;
    print $angle;

    $x = createRegularPolygonX( $n, $r ) ;
    $y = createRegularPolygonY( $n, $r ) ;

    // create the n-sided polygon.
    $z = 0.0 ;




    $LItem = `ls -sl`;
    $VCirPosX = `xform -q -ws -t $LItem[0]`;


    matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;

    $Normal = <<0.0, 1.0, 0.0>>;


    $VecPairA[0]= <<0.0, 1.0, 0.0>>;
    $VecPairA[1]= $VecPairA[0]*2;

    $matrixA = TwoPointMatrixPlusAxisWorld($VecPairA, $EmptyVecA, 1);
    $matrixA  = TwoPointMatrixB($VecPairA);
    $DirectionStart = <<$matrixA[0][0], $matrixA[0][1], $matrixA[0][2] >>;
    $angle = 360.0 / ($n*2) ;
    $rotatsB = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($angle)) );
    $DirectionStartB = <<$rotatsB[0], $rotatsB[1], $rotatsB[2] >>;
    $DirectionStartB = `unit($DirectionStartB)`;
    Loc $DirectionStartB;

    //RotMultLenToDirAddToPoint(float $PosA[], float $PosB[], float $Length, float $DirNormAx[], float $Radian)
    // float $rotatsA[] = RotDirToPoint($DirectionStart, $VCirPosX,$RA, $Normal, $a );
    $angle = 360.0 / $n ;




    for( $i = 0 ; $i < ($n) ; $i++ ) {
    $a = $i * $angle ;
    $rotatsA = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($a)) );
    Loc $rotatsA;

    }


    for( $i = 0 ; $i < ($n) ; $i++ ) {
    $a = $i * $angle ;
    $rotatsA = RotDirToPoint($VCirPosX,$DirectionStart, $RB, $Normal, (deg_to_rad($a)) );
    Loc $rotatsA;

    }


    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < ($n) ; $i++ ) {
    $a = $i * $angle ;
    $rotatsA = RotDirToPoint($VCirPosX,$DirectionStartB, $r, $Normal, (deg_to_rad($a)) );
    $VrotatsA[$i] =   FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $r, $Normal, (deg_to_rad($a)) ));

    Loc $rotatsA;

    }
    //////////////////////////////////


    for( $i = 0 ; $i < $n ; $i++ ) {

    $a = $i * $angle ;
    $rotatsA = RotDirToPoint($VCirPosX,$DirectionStart, $r, $Normal, (deg_to_rad($a)) );

    $VrotatsCiH[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $RA, $Normal, (deg_to_rad(($a))) ));
    $VrotatsBiH[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $RB, $Normal, (deg_to_rad(($a))) ));
    Loc $VrotatsCiH[$i];

    $VrotatsCi[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($a)) ));
    $VrotatsBi[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $r, $Normal, (deg_to_rad($a)) ));

    $VrotatsAi[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStart, $RB, $Normal, (deg_to_rad($a)) ));


    $CirclePts = <<$rotatsA[0], $rotatsA[1], $rotatsA[2] >>;

    $DirLine = DirectionFN($CirclePts, $VCirPosX);
    $Vperp = crossProduct( $DirLine, $Normal, 0, 0 );
    $Vperp = `unit($Vperp + $DirLine)`;
    $VperpN = crossProduct( $DirLine, ($Normal*-1.0), 0, 0 );
    $VperpN = `unit( ($VperpN) + ($DirLine))`;

    $VperpA = ($Rii/2.0)* $VperpN*-1.0;
    $VperpA = $CirclePts+$VperpA;
    Loc $VperpA;


    curve2points($VrotatsBi[$i],$VrotatsCiH[$i]);

    if($i>0){

    curve2points($VrotatsBi[$i-1],$VperpA);


    }
    if($i==0){
    $Templast= $VperpA;}

    $VperpC = ($Rii/2.0)*$DirLine;
    $VperpC = $CirclePts+$VperpC;
    Loc $VperpC;
    curve2points($VrotatsCi[$i],$VperpC);
    /////////////

    $VperpB = ( $Rii/2.0)*$Vperp*-1.0;
    $VperpB = $CirclePts+$VperpB;
    Loc $VperpB;
    curve2points($VrotatsBi[$i],$VperpB);

    /////////////////////

    $VperpD = (-1*$Rii/2.0)*$DirLine;
    $VperpD = $CirclePts+$VperpD;
    Loc $VperpD;

    curve2points($VrotatsAi[$i],$VperpD);
    curve2points($VrotatsBi[$i],$VrotatsBiH[$i]);

    if($i==($n-1)){
    curve2points($VrotatsBi[$i],$Templast);
    }

    $circlesC = `circle -c $rotatsA[0] $rotatsA[1] $rotatsA[2] -nr 0 0 1 -sw 360 -r ($Rii/2.0) -d 3 -ut 0 -tol 0.001 -s 16 -ch 1`;
    $circles[$i] = $circlesC[0];
    makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $circles[0];
    xform -cp $circles[$i];
    }



    //$circles[`size($circles)`] = $circleA[0];
    //$circles[`size($circles)`] = $circleB[0];
    select -r $circleA $circleB $circles ;
    //select -r $circles ;
    return $circles;
    }

}


/******************************************************************************
 * @procedure    InsidePolygon
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $c : vector[]
 *   $VLocPos_A : vector
 *
 * @returns      int
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int InsidePolygon(vector $c[], vector $VLocPos_A)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $SizeV = size($c);
    float $x = VecCom($VLocPos_A, 0);
    float $y = VecCom($VLocPos_A, 1);
    float $PI = 3.1415926535;
    float $angle = 0;
    float $Distance = 0;
    float $DistanceMM = 0;
    float $Arc = 0;
    float $p1x = 0, $p1y = 0, $p2x = 0, $p2y = 0;
    float $triarea = 0;
    float $tri_areaM = 0;
    float $aP;
    float $bP;
    float $cP;
    float $N;
    float $TWO_PI = 3.1415926535;
    float $AverageVecCurve[] = AverageVectorPoint($Positions);
    float $DDistPt_toC = distance2Pts($VCrvPos_A, $VLocPos_A);
    float $DDist = $Distance/float($TotalS);
    float $DDistX = $Distance+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    float $DDistMM = $DistanceMM+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    float $MathA = $DDistMM/$DDist;
    float $MathB = $DDistPt_toC/$MathA;
    vector $VCrvPos_A;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $VCrvPos_A =  FloatToVec(AverageVectorPoint($c));

    $x = VecCom($VLocPos_A, 0);
    $y = VecCom($VLocPos_A, 1);

    // Convex is just a collection of points for the polygon
    // just replace that code in the for-loop to loop through the points in your polygon

    $PI = 3.1415926535;
    $angle = 0;
    $Distance = 0;
    $DistanceMM = 0;
    $Arc = 0;
    $p1x = 0, $p1y = 0, $p2x = 0, $p2y = 0;
    $SizeV = size($c);
    $TotalS = $SizeV;
    $triarea = 0;
    $tri_areaM = 0;
    $countS =1;

    for ($i=0;$i< $SizeV; $i++) {

    $indexState = $i;
    $indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
    $indexRight = fmod(($indexState + $countS),$TotalS);
    $DistA = distance2Pts($c[$i], $c[$indexLeft]);
    $DistB = distance2Pts($c[$i], $c[$indexRight]);
    if($DistA<$DistB){
    $nearestIndex = $indexLeft;
    }else{$NearIndex = $indexRight;}
    /*
    $p1x = ( (VecCom($c[$i], 0)) - $x ); // point A X - X
    $p1y = ( (VecCom($c[$i], 1)) - $y ); // point A Y - Y
    $p2x = ( (VecCom($c[$NearIndex], 0)) - $x ); // point A's nearest neighbor X - X
    $p2y = ( (VecCom($c[$NearIndex], 1)) - $y ); // point A's nearest neighbor Y - Y
    */
    $aP = distance2Pts($c[$i], $c[$indexRight]);
    $bP = distance2Pts($VLocPos_A, $c[$indexRight]);
    $cP = distance2Pts($c[$i], $VLocPos_A);
    $triarea += 0.25* (sqrt ( ($aP+$bP+$cP)  * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP)  ));
    $aPm = distance2Pts($c[$i], $c[$indexRight]);
    $bPm = distance2Pts($VCrvPos_A, $c[$indexRight]);
    $cPm = distance2Pts($c[$i], $VCrvPos_A);
    $tri_areaM += 0.25* (sqrt ( ($aPm+$bPm+$cPm)  * ($bPm+$cPm-$aPm) * ($cPm+$aPm-$bPm) * ($aPm+$bPm-$cPm)  ));
    $DistanceMM += distance2Pts($c[$i], $VCrvPos_A);
    $Distance += distance2Pts($c[$i], $VLocPos_A);
    //$angle += Angle2D($p1x,$p1y,$p2x,$p2y);
    $Arc += distance2Pts($c[$i], $c[$indexRight]);
    }

    //print ("Tri_area: "+$triarea + "\n");
    //print ("Tri_areaM: "+$tri_areaM+ "\n");
    /*
    if (abs($angle) < $PI){
    print (" INSIDE " + "\n");
    }else{ print (" OUTSIDE! " + "\n");}
    */

    // if (equivalentTol($triarea, $tri_areaM,  0.00001) ==1){
    //print ("Tri_area INSIDE " + "\n");
    //}else{ print ("Tri_area OUTSIDE! " + "\n");}

    //   if (abs($angle) < $PI){//
    if (equivalentTol($triarea, $tri_areaM,  0.00001) ==1){
    return 1;
    }else{
    return 0;}

    }


    proc float VecCom(vector $Vai, int $XYZ){
    $x = $Vai.x;
    $y = $Vai.y;
    $z = $Vai.z;
    if($XYZ==0){$N=$x;} if($XYZ==1){$N=$y;} if($XYZ==2){$N=$z;}
    return $N;
    }


    proc float Angle2D(float $x1, float $y1, float $x2, float $y2)
    {
    $PI = 3.1415926535;
    $TWO_PI = 3.1415926535;


    $theta1 = atan2($y1,$x1);
    $theta2 = atan2($y2,$x2);
    $dtheta = $theta2 - $theta1;

    while ($dtheta > $PI)
    $dtheta -= $TWO_PI;
    while ($dtheta < -$PI)
    $dtheta += $TWO_PI;


    return $dtheta;
    }

    /*


    $Arc = `arclen $CurveItemAX[0]`;
    $AverageVecCurve = AverageVectorPoint($Positions);

    //////////

    $DDistPt_toC = distance2Pts($VCrvPos_A, $VLocPos_A);
    $DDist = $Distance/float($TotalS);
    print ("Dist_each/SIZE: "+$DDist + "\n");
    //Dist_each/SIZE: 18.31929743
    print (" dist_to_M: "+ $DDistPt_toC+"  dist_each: "+$DDist + "\n");
    $DDistX = $Distance+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    $DDistMM = $DistanceMM+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    $DDistMM = $DistanceMM/float($TotalS);
    $MathA = $DDistMM/$DDist;
    $MathB = $DDistPt_toC/$MathA;
    print $Arc;
    outside
    dist_to_M: 8.210088295  dist_each: 10.678618
    dist_to_M: 10.98501803  dist_each: 19.20895454
    inside
    dist_to_M: 4.491177258  dist_each: 10.90761121
    dist_to_M: 2.733438324  dist_each: 15.81548968
    print (" distance to crv middle "+ $DDistPt_toC+" dist to each crv div "+$DDist + "\n");
    //float $Xpi = $PI/$angle;
    //float $XTpi = $Xpi*$angle;
    print ($angle + "\n");
    */

}


/******************************************************************************
 * @procedure    VecCom
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $Vai : vector
 *   $XYZ : int
 *
 * @returns      float
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float VecCom(vector $Vai, int $XYZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $N;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $x = $Vai.x;
    $y = $Vai.y;
    $z = $Vai.z;
    if($XYZ==0){$N=$x;} if($XYZ==1){$N=$y;} if($XYZ==2){$N=$z;}
    return $N;

}


/******************************************************************************
 * @procedure    Angle2D
 * @category     polygon-ops
 * @layer        affine (Mesh)
 *
 * @param
 *   $x1 : float
 *   $y1 : float
 *   $x2 : float
 *   $y2 : float
 *
 * @returns      float
 * @source       working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float Angle2D(float $x1, float $y1, float $x2, float $y2)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $PI = 3.1415926535;
    float $TWO_PI = 3.1415926535;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PI = 3.1415926535;
    $TWO_PI = 3.1415926535;


    $theta1 = atan2($y1,$x1);
    $theta2 = atan2($y2,$x2);
    $dtheta = $theta2 - $theta1;

    while ($dtheta > $PI)
    $dtheta -= $TWO_PI;
    while ($dtheta < -$PI)
    $dtheta += $TWO_PI;


    return $dtheta;

}

