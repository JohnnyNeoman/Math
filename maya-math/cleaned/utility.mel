/******************************************************************************
 * UTILITY - CLEANED MEL PROCEDURES
 *
 * Category:    utility
 * Layer:       utility (General)
 * Description: General Maya utilities and helpers
 * Procedures:  240
 *
 * All variable declarations moved to procedure start.
 * Generated by cleanup_mel_v2.py
 ******************************************************************************/


/******************************************************************************
 * @procedure    connectNodeToNodeOverride
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $srcNode : string
 *   $dstNode : string
 *
 * @returns      int
 * @source       connectNodeToNodeOverride (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
global proc int connectNodeToNodeOverride(string $srcNode, string $dstNode)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $rDoNormalOperation = 1;
    string $dstNodeType = `nodeType($dstNode)`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    //	print(
    //		"connectNodeToNodeOverride("
    //		+ $srcNode
    //		+ ", "
    //		+ $dstNode
    //		+ ") called\n");

    // By default the return value of this procedure is 1, so that Maya
    // will perform the normal operation for a connection between these
    // two nodes.
    //
    $rDoNormalOperation = 1;

    //
    // If you wish to change the behaviour of drag and drop of a node onto
    // another node in Maya, you should implement the behaviour you wish
    // here.
    //
    // Typically this procedure would get called when a node is dragged onto a
    // node in the multilister, hypershade or hypergraph (when not in DAG
    // view).
    //

    // mentalrayTexture to mentalray shaders
    // This case is better to be handled in mel,
    // because "tex" attr in mental ray shader node is of "message" type.
    // Maya does not have any information that this "tex" attr is any different from other message type attrs.
    if( `nodeType($srcNode)` == "mentalrayTexture" )
    {
    // mentalray shaders and its tex arg.
    //	mib_bump_map.tex
    //	mib_passthrough_bump_map.tex
    //	mib_lookup_spherical.tex
    //	mib_lookup_cube1.tex
    //	mib_lookup_cube6.tex_mx
    //	mib_lookup_cube6.tex_px
    //	mib_lookup_cube6.tex_my
    //	mib_lookup_cube6.tex_py
    //	mib_lookup_cube6.tex_mz
    //	mib_lookup_cube6.tex_pz
    //	mib_lookup_background.tex
    //	mib_lookup_cylindrical.tex
    //	mib_texture_lookup.tex
    //	mib_texture_filter_lookup.tex
    //	mib_lightmap_write.texture
    //	mib_lightmap_write.coord
    //	mib_lightmap_write.input

    $dstNodeType = `nodeType($dstNode)`;
    if( $dstNodeType == "mib_bump_map" ||
    $dstNodeType == "mib_passthrough_bump_map" ||
    $dstNodeType == "mib_lookup_spherical" ||
    $dstNodeType == "mib_lookup_cube1" ||
    $dstNodeType == "mib_lookup_background" ||
    $dstNodeType == "mib_lookup_cylindrical" ||
    $dstNodeType == "mib_texture_lookup" ||
    $dstNodeType == "mib_texture_filter_lookup"
    )
    {
    connectAttr -f ($srcNode + ".message" )  ($dstNode + ".tex");
    $rDoNormalOperation = 0;
    }
    else if( $dstNodeType == "mib_lightmap_write" )
    {
    // mib_lightmap_write has 3 tex attr.
    // the default connection will use "texture"
    connectAttr -f ($srcNode + ".message" )  ($dstNode + ".texture");
    $rDoNormalOperation = 0;
    }
    else if( $dstNodeType == "mib_lookup_cube6" )
    {
    // mib_lookup_cube6 has 6 tex attr.
    // the default connection will use "tex_mx"
    connectAttr -f ($srcNode + ".message" )  ($dstNode + ".tex_mx");
    $rDoNormalOperation = 0;
    }
    }

    // light profile to light shader
    // This case is also better to be handled in mel, for the same reason as above.
    if( `nodeType($srcNode)` == "mentalrayLightProfile" )
    {
    // there are only 2 shaders that support light profile
    $dstNodeType = `nodeType($dstNode)`;
    if( $dstNodeType == "mib_light_photometric" )
    {
    connectAttr -f ($srcNode + ".message" )  ($dstNode + ".profile");
    $rDoNormalOperation = 0;
    }
    else if( $dstNodeType == "pointLight" )
    {
    connectAttr -f ($srcNode + ".message" )  ($dstNode + ".miLightProfile");
    $rDoNormalOperation = 0;
    }

    }

    return $rDoNormalOperation;

}


/******************************************************************************
 * @procedure    getTheTransform
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $item : string
 *
 * @returns      string
 * @source       cycleIntermediateObjectSibling (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc string getTheTransform(string $item)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $result = $item;
    string $tmp[] = `ls -tr $result`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = $item;
    $tmp = `ls -tr $result`;
    if( size($tmp) == 0 ) {
    $tmp = `listRelatives -p $result`;
    if( size($tmp) > 0 ) {
    $result = $tmp[0];
    }
    }
    return $result;

}


/******************************************************************************
 * @procedure    needTheLeadTransform
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      string
 * @source       cycleIntermediateObjectSibling (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc string needTheLeadTransform()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $result = "";
    string $tmp[] = `ls -l -sl -tail 1 -type dagNode`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = "";
    $tmp = `ls -l -sl -tail 1 -type dagNode`;
    if( size($tmp) > 0 ) {
    $result = getTheTransform( $tmp[0] );
    }
    else {
    $tmp = `ls -l -sl -tail 1`;
    if( size($tmp) > 0 ) {
    $tmp = `listRelatives -p $tmp[0]`;
    if( size($tmp) > 0 ) {
    $result = getTheTransform( $tmp[0] );
    }
    }
    }
    return $result;

}


/******************************************************************************
 * @procedure    IndexPairFunc
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $XNum : int
 *
 * @returns      int []
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IndexPairFunc(int $XNum)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Zss = $XNum*2;
    int $Yss = $Zss+1;
    int $pair[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Zss = $XNum*2;
    $Yss = $Zss+1;
    $pair={$Zss,$Yss};
    return $pair;

}


/******************************************************************************
 * @procedure    IndexPairFuncN
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $XNum : int
 *   $XNumV : int
 *
 * @returns      int
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int IndexPairFuncN(int $XNum, int $XNumV)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Zss = $XNum*2;
    int $Yss = $Zss+1;
    int $AB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Zss = $XNum*2;
    $Yss = $Zss+1;
    if($XNumV==0){
    $AB=$Zss;
    }else{$AB=$Yss;}
    return $AB;

}


/******************************************************************************
 * @procedure    ReturnVectorPair
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $AllVec : vector[]
 *   $NumX : int
 *
 * @returns      vector []
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] ReturnVectorPair(vector $AllVec[], int $NumX)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $PairI[] = IndexPairFunc($NumX);
    vector $vecPa[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PairI = IndexPairFunc($NumX);
    $vecPa[0] = $AllVec[$PairI[0]];
    $vecPa[1] = $AllVec[$PairI[1]];
    return $vecPa;

}


/******************************************************************************
 * @procedure    ReturnOneVectorPair
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $AllVec : vector[]
 *   $NumX : int
 *
 * @returns      vector
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector ReturnOneVectorPair(vector $AllVec[], int $NumX)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $vecPa;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $vecPa= $AllVec[$NumX];
    return $vecPa;

}


/******************************************************************************
 * @procedure    PointInCircle
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $pos : vector[]
 *   $posA : vector
 *   $radius : float
 *
 * @returns      int[]
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int[] PointInCircle(vector $pos[], vector $posA, float $radius)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $AllInside[];
    int $indexR;
    float $Di = distance2Pts($eachVecc, $posA);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($eachVecc in $pos){
    $Di = distance2Pts($eachVecc, $posA);
    if($Di < $radius){
    $AllInside[`size($AllInside)`]= $indexR;
    }
    $indexR++;
    }
    return $AllInside;

}


/******************************************************************************
 * @procedure    MostRightLeft
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $oneVec : vector
 *   $allV : vector[]
 *
 * @returns      int []
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] MostRightLeft(vector $oneVec, vector $allV[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $best = 0;
    int $Left = 0;
    int $Si = `size($allV)`-1;
    int $RightLeft[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $best = 0;
    $Left = 0;
    $Si = `size($allV)`-1;
    for( $i = 0 ; $i < $Si ; $i++ ) {

    $Xi[0] =$best;
    $Xi[1] = $i+1;
    $zeroORone = MostRightClockWiseINT($oneVec, $allV[$best], $allV[$Xi[1]]);
    $best = $Xi[$zeroORone];
    $Xi[0] =$Left;
    $zeroORone = MostRightClockWiseINT($oneVec , $allV[$Left], $allV[$Xi[1]]);
    $Li = fmod($zeroORone+1,2);
    $Left = $Xi[$Li];
    }

    $RightLeft[0] =$best;
    $RightLeft[1] =$Left;
    return $RightLeft;

}


/******************************************************************************
 * @procedure    MostRightClockWiseINT
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $VecA : vector
 *   $VecB : vector
 *   $Vec : vector
 *
 * @returns      int
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int MostRightClockWiseINT(vector $VecA, vector $VecB, vector $Vec)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $TwoNew;
    float $pt1[] = FloatToVec($VecA);
    float $pt2[] = FloatToVec($VecB);
    float $pt3[] = FloatToVec($Vec);
    float $NA[] = `unit ($normalV[0])`;
    float $NB[] = `unit ($normalV[1])`;
    float $NAD = $NA[0] + $NA[1];
    float $NAD2 = $NB[0] + $NB[1];
    string $ReturnObj[];
    vector $U1 = TwoVecsOrFloats($pt2, $pt1);
    vector $V1 = TwoVecsOrFloats($pt3, $pt1);
    vector $U2 = TwoVecsOrFloats($pt3, $pt1);
    vector $V2 = TwoVecsOrFloats($pt2, $pt1);
    vector $normalV[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    // Get the vector p1-p2, p3-p4
    // Get the vector  p3-p4
    //THREE ptS get angel that is pt 2 & 3 to pt 1 (the V shape joining at first pt)
    ///////////////////////////////////////////////////////////
    $pt1 = FloatToVec($VecA);
    $pt2 = FloatToVec($VecB);
    $pt3 = FloatToVec($Vec);
    $U1 = TwoVecsOrFloats($pt2, $pt1);
    $V1 = TwoVecsOrFloats($pt3, $pt1);
    $U2 = TwoVecsOrFloats($pt3, $pt1);
    $V2 = TwoVecsOrFloats($pt2, $pt1);
    clear $normalV;
    $normalV[0] = FloatToVec( crossProduct( $U1, $V1, 0, 1 ) );
    $normalV[1] = FloatToVec( crossProduct( $U2, $V2, 0, 1 ) );
    $normalV[0]= `unit ($normalV[0])`;
    $normalV[1]= `unit ($normalV[1])`;
    $NA = `unit ($normalV[0])`;
    $NB = `unit ($normalV[1])`;
    $NAD = $NA[0] + $NA[1];
    $NAD2 = $NB[0] + $NB[1];
    if( $NAD< $NAD2){
    $TwoNew =1;

    }else{
    $TwoNew =0;

    }

    return $TwoNew;

}


/******************************************************************************
 * @procedure    makePolygonQUAD
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $VecPts : vector[]
 *
 * @returns      string
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string makePolygonQUAD(vector $VecPts[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $n = `size($VecPts)`;
    int $i;
    float $z = 0.0;
    string $facet[];
    string $cmd = "polyCreateFacet -ch 0  ";
    string $vertStr;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $n = `size($VecPts)`;
    // create the n-sided polygon.
    //
    $cmd = "polyCreateFacet -ch 0  ";
    $z = 0.0 ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $vertStr += " -p " ;
    $vertStr += $VecPts[$i] ;

    }
    $cmd += $vertStr ;
    $cmd += " ";
    $facet = eval($cmd) ;
    return $facet[0] ;

}


/******************************************************************************
 * @procedure    Angel2DirectionR
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Da : vector
 *   $Db : vector
 *
 * @returns      float
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float Angel2DirectionR(vector $Da, vector $Db)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $A = acos(dot($Da, $Db));

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $A = acos(dot($Da, $Db));
    return $A;

}


/******************************************************************************
 * @procedure    Angel2Direction
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Da : vector
 *   $Db : vector
 *
 * @returns      float
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float Angel2Direction(vector $Da, vector $Db)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $A = `rad_to_deg(acos(dot($Da, $Db)))`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $A = `rad_to_deg(acos(dot($Da, $Db)))`;
    return $A;

}


/******************************************************************************
 * @procedure    IntArrayReturnClosedLoop
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $listX : int[]
 *   $listTD : int[]
 *
 * @returns      int []
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IntArrayReturnClosedLoop(int $listX[], int $listTD[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Ct;
    int $ModNn;
    int $index = 0;
    int $X = 0;
    int $CountD = 0;
    int $CountDX = 0;
    int $NumberE[];
    int $NumberER[];
    int $IndexDup[];
    int $result = 0;
    int $indexArray[];
    int $CurveMeetsTrue = 0;
    int $indexN = 0;
    int $indexN2 = 0;
    int $IndexEnds[];
    int $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);
    int $TF = 0;
    int $intIfTrue[] = FindifCurveEndsMeetIndex($CurveOne, $CurveTwo, $TF);
    int $numCVs;
    int $num;
    int $count = 0;
    int $i = 0;
    int $Cindex = 0;
    int $NumberCs = $number3;
    int $n = $number3;
    int $SizeV = size($c);
    float $FDirNorA[] = Normal3Points($PtsVec[0], $PtsVec[1],$PtsVec[2]);
    float $ObjsCirclesE = `arclen`*2.0;
    float $ObjsCirclesEi = `arclen`;
    float $ObjsCirclesEii = `arclen`;
    float $Di = distance2Pts( $CircPos , $PointN);
    float $PointN[] = ClosestPoint2Line($VecLineDir, $PosA, $CircPos);
    float $DiffL = ($ObjsCirclesRad-$Di)*2.0;
    float $FloatDirXn[] = DirectionF( $Vec[2], $Vec[0]);
    float $PointNii[] = MultLenToDirAddToPoint($Di, DirectionF( $Vec[2], $PointN), $PointN);
    float $DistAddiR2 = $Di*2.0;
    float $HightD = sqrt (abs ((`pow $Di 2.0`) - (`pow $ObjsCirclesRad 2.0`)));
    float $PointNiii[] = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[1], $Vec[0]), $PointN);
    float $PointNiiiB[] = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[0], $Vec[1]), $PointN);
    float $ObjsCirclesEiii = `arclen`;
    float $Dii = distance2Pts(  $AVecArrayPos_MC[0] ,  $AVecArrayPos_MC[1]);
    float $DiX = distance2Pts(  $AVecArrayPos_MC[0] ,  $VecCamPos_A);
    float $DiffMathAz = $ObjsCirclesEii/$DiX;
    float $DiffMathBz = $DiffMathAz*$Dii;
    float $TESTx = $ObjsCirclesEii +$DiffMathBz;
    float $DiffMathA = $DiX / (($Dii+$DiX)/100.0);
    float $DiffMathAi = (($DiffMathA/100.0) * $ObjsCirclesEiii);
    float $DiffMathB = $Dii / (($Dii+$DiX)/100.0);
    float $DiffMathBi = $DiffMathB / 100.0;
    float $Testri = ($Dii/$DiX)+1.000;
    float $DiffMathAiX = ($Testri * $ObjsCirclesEii);
    float $Testr = ($ObjsCirclesEiii / $ObjsCirclesEii);
    float $DiffMathAx = $ObjsCirclesEii/ (($ObjsCirclesEiii)/100.0);
    float $Testrii = ($ObjsCirclesEiii - $ObjsCirclesEii)/$Dii;
    float $PerDiffX = percent_of( $ObjsCirclesEii ,$ObjsCirclesEiii);
    float $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
    float $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    float $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    float $NofCirclesa = (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
    float $NofCirclesb = ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
    float $NofCirclesc = ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);
    float $PI = 3.1415926535;
    float $Cir = ($PI *$r )*2.00;
    float $Seg = $Cir/8.0;
    float $LengAngle = 360.000/$Seg;
    float $DiffMathAB = 360.0/(100.0/$DiffMathA);
    float $angle = $LengAngle / $sides;
    float $a = $i * $angle;
    float $AstepF = 0.035;
    float $TstepF = 1.025;
    float $Step = 120;
    float $LSS = 0.050;
    float $FoundRadii[];
    float $CurveSizeFloat = logN(logN(logN(`log (5.605099)`)));
    float $LS = 0.050;
    float $XLOOG = abs  (((logN(`log ($FoundRadii[$Cindex]/8.0)`))));
    float $pi = 3.1415926535;
    float $Pi = 3.1415926535;
    float $RA;
    float $RB;
    float $R2 = $RA;
    float $R1 = $RB;
    float $DCircle = (($R2 - $R1)/2.0) + $R1;
    float $Rii = (($R2 - $R1)/2.0);
    float $SideA = $RB + $Rii;
    float $SideB = $Rii*2;
    float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    float $ArcangleC2 = $ArcangleC*2.0;
    float $Aii = (`asin ($RB/($RB + $Rii))`);
    float $number3 = 360.0/$ArcangleC2;
    float $len = $DCircle;
    float $r = $DCircle;
    float $x[] = createRegularPolygonX( $n, $r );
    float $y[] = createRegularPolygonY( $n, $r );
    float $z = 0.0;
    float $rotatsB[] = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($angle)) );
    float $rotatsA[] = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($a)) );
    float $Templast[];
    float $center[];
    float $normal[];
    float $p1[] = `xform -q -ws -t $selectionList[0]`;
    float $p2[] = `xform -q -ws -t $selectionList[1]`;
    float $p3[] = `xform -q -ws -t $selectionList[2]`;
    float $FloatPosZero[] = {0, 0, 0};
    float $FloatDirection[] = DirectionF($FloatPosZero, $normal);
    float $MultDirP[] = multiplyFloat(2, $FloatDirection);
    float $FloatDirPerpCenter[] = DirectionF($center, $mid3);
    float $FloatDirPerpCenterB[] = DirectionF($center,$mid1);
    float $FloatDirPerpCenterC[] = DirectionF($center,$mid2);
    float $FloatDirPointAB[] = DirectionF($p1, $p2);
    float $FloatDirPointBC[] = DirectionF($p2, $p3);
    float $FloatDirPointAC[] = DirectionF($p1, $p3);
    float $center6[] = lineIntersection( $p1, $FloatDirPerpCenter, $p2, $FloatDirPointBC );
    float $center7[] = lineIntersection( $p3,  $FloatDirPerpCenterB, $p1, $FloatDirPointAB );
    float $center8[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    float $center9[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPerpCenter );
    float $OrthoCenterCir[] = midPoint2Pts( $center9, $center );
    float $Radius2HalfTimes2 = (distance2Pts( $center9, $center ))*2;
    float $Radius2BHalf = (distance2Pts( $center9, $center ));
    float $radiusZ = distance2Pts( $p1, $center );
    float $Radius3Half = $radiusZ/2;
    float $radius;
    float $Start_angle = (90.0);
    float $End_angle;
    float $LengthsT[] = ArcLengthArray(`ls -sl`);
    float $LengthsM[] = ArcLengthArray(`ls -sl`);
    float $Lengths[] = ArcLengthArray(`ls -sl`);
    float $LengthsSub[];
    float $PerDiff = percent_of($LengthsM[0], $Lengths[3]);
    float $LengthsC[] = ArcLengthArray(`ls -sl`);
    float $Distance = 0;
    float $DistanceMM = 0;
    float $Arc = 0;
    float $p1x = 0, $p1y = 0, $p2x = 0, $p2y = 0;
    float $triarea = 0;
    float $tri_areaM = 0;
    float $aP;
    float $bP;
    float $cP;
    float $N;
    float $TWO_PI = 3.1415926535;
    float $AverageVecCurve[] = AverageVectorPoint($Positions);
    float $DDistPt_toC = distance2Pts($VCrvPos_A, $VLocPos_A);
    float $DDist = $Distance/float($TotalS);
    float $DDistX = $Distance+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    float $DDistMM = $DistanceMM+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    float $MathA = $DDistMM/$DDist;
    float $MathB = $DDistPt_toC/$MathA;
    string $list[];
    string $listItem;
    string $CurveSelection[];
    string $selItemz[] = `ls-sl`;
    string $selLocz[];
    string $itemD[];
    string $CurveItemZ[] = `ls -sl`;
    string $initial_string;
    string $rules[];
    string $tmp;
    string $ThefirstCurve = VecArrayToCurve($Xs);
    string $CurvesV[];
    string $circleA[];
    string $circleB[];
    string $circles[];
    string $circlesC[];
    string $LItem[] = `ls -sl`;
    string $selectionList[];
    string $circlesItem[];
    string $Locs[];
    string $CurveItemAXX[] = `ls -sl`;
    string $CurveItemAX[] = `ls -sl`;
    vector $CurveOne[] = GetVectorArrayBetweenCurveEnds({$curveA});
    vector $CurveTwo[] = GetVectorArrayBetweenCurveEnds({$curveB});
    vector $CurveAB[];
    vector $eachCVposV;
    vector $VecLi[];
    vector $NewVeci;
    vector $VecCamPos_A;
    vector $VecArrayPos_MC[];
    vector $ThreeEllipVecP[];
    vector $PtsVec[] = PointArrayT(`ls -sl`);
    vector $NewEllipesCurve[];
    vector $AVecArrayPos_MC[];
    vector $CircPos = $VecArrayPos_MC[1];
    vector $PosA = $VecCamPos_A;
    vector $PosB = $AVecArrayPos_MC[0];
    vector $VecLineDir = PositiveDirectionLine($PosA, $PosB);
    vector $Vec[];
    vector $A_CrvCentroidA = FloatToVec(AverageVectorPoint( $AVecArrayPos_MC));
    vector $Xs[];
    vector $Normal = << 0.0,1.0,0.0>>;
    vector $HighCurvePoints[];
    vector $NormalCurvePoints[];
    vector $DirecAB = ((unit(`rot $Direc $DirNorm $Radian`))*$Length)+$Vecpt;
    vector $VCirPosX;
    vector $VecPairA[];
    vector $EmptyVecA[];
    vector $DirectionStart = <<$matrixA[0][0], $matrixA[0][1], $matrixA[0][2] >>;
    vector $DirectionStartB = <<$rotatsB[0], $rotatsB[1], $rotatsB[2] >>;
    vector $VrotatsA[];
    vector $VrotatsCiH[];
    vector $VrotatsBiH[];
    vector $VrotatsCi[];
    vector $VrotatsBi[];
    vector $VrotatsAi[];
    vector $CirclePts = <<$rotatsA[0], $rotatsA[1], $rotatsA[2] >>;
    vector $DirLine = DirectionFN($CirclePts, $VCirPosX);
    vector $Vperp = crossProduct( $DirLine, $Normal, 0, 0 );
    vector $VperpN = crossProduct( $DirLine, ($Normal*-1.0), 0, 0 );
    vector $VperpA = ($Rii/2.0)* $VperpN*-1.0;
    vector $VperpC = ($Rii/2.0)*$DirLine;
    vector $VperpB = ( $Rii/2.0)*$Vperp*-1.0;
    vector $VperpD = (-1*$Rii/2.0)*$DirLine;
    vector $veCPos1[];
    vector $VecCurEndsa[] = VecCurveEnds({$ThefirstCurve});
    vector $Positions[];
    vector $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM`;
    vector $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM`;
    vector $Plane_Trans = `xform -q -ws -t LiveSurfaceB`;
    vector $Plane = `xform -q -ws -ro LiveSurfaceB`;
    vector $VCrvPos_AA;
    vector $VCrvPos_A;
    vector $VLocPosX;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $list = IntArrayToStringArray($listX);
    $index = 0;
    $X = 0;
    $CountD = 0;
    $CountDX = 0;
    $result = $list;
    //for ($item in $result) {

    while(`size($result)`> 0 ) {
    $item = $result[0];
    $CountD = stringArrayCount($item, $result);

    $IndexDup = StringArrayCountIndexDup($item, $list, $CountDX);
    if($CountDX >1){
    for($eachINT in $IndexDup){
    $listTD[$eachINT] = $CountDX;
    }
    clear $IndexDup;
    }
    if ($CountD>1) {
    $NumberE[$index]=$CountD;
    print ($item+" "+$CountD+"\n");
    $NumberER[$index] =$NumberE[$index];
    $CollectR[$index] = $item;
    $index++;
    $result = stringArrayRemove({$item},$result);
    }
    $X++;
    if($X ==200){break;}
    }

    return $NumberER;
    }



    proc int[] StringArrayCountIndexDup(string $item, string $list[], int $Count)
    {
    $result = 0;
    $index = 0;

    for ($listItem in $list) {

    if ($item == $listItem){
    $indexArray[$result] = $index;
    $result++;}

    $index++;
    }
    $Count = $result;
    return $indexArray;
    }


    proc int [] FindifCurveEndsMeetIndex(vector $CurveA1[], vector $CurveA2[], int $TF){
    $CurveMeetsTrue = 0;
    $indexN = 0;
    $indexN2 = 0;

    while ($indexN < 2){

    $firstC = $CurveA1[$indexN];
    $SecondC = $CurveA2[0];
    $SecondCA = $CurveA2[1];

    $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);

    if ($NumberE == 3){
    if($indexN==0){
    $IndexEnds[0]=1; $IndexEnds[1]=0; $IndexEnds[2]=1; $IndexEnds[3]=0;

    }else{
    $IndexEnds[0]=0; $IndexEnds[1]=1; $IndexEnds[2]=1; $IndexEnds[3]=0;

    }
    $CurveMeetsTrue = 1;
    break; }

    if ($NumberE2 == 3){

    if($indexN==0){
    $IndexEnds[0]=1; $IndexEnds[1]=0; $IndexEnds[2]=0; $IndexEnds[3]=1;

    }else{

    $IndexEnds[0]=0; $IndexEnds[1]=1; $IndexEnds[2]=0; $IndexEnds[3]=1;}
    $CurveMeetsTrue = 1;
    break; }

    if ($indexN==1){$indexN1 = 1;}
    $indexN++;
    }

    $TF = $CurveMeetsTrue;
    return $IndexEnds;
    }


    proc int [] IfCurvesTouchIndex(string $curveA, string $curveB,int $TFa){
    $CurveOne = GetVectorArrayBetweenCurveEnds({$curveA});
    $CurveTwo = GetVectorArrayBetweenCurveEnds({$curveB});
    $TF = 0;
    $intIfTrue = FindifCurveEndsMeetIndex($CurveOne, $CurveTwo, $TF);
    $TFa = $TF;
    return $intIfTrue;
    }


    proc int [] IfCurvesTouchIndexZ(string $curveA, string $curveB,int $TFa){
    $CurveOne = GetVectorArrayBetweenCurveEnds({$curveA});
    $CurveTwo = GetVectorArrayBetweenCurveEnds({$curveB});
    $TF = 0;
    $intIfTrue = FindifCurveEndsMeetIndexZ($CurveOne, $CurveTwo, $TF);
    $TFa = $TF;
    return $intIfTrue;
    }



    proc int [] FindifCurveEndsMeetIndexZ(vector $CurveA1[], vector $CurveA2[], int $TF){
    $CurveMeetsTrue = 0;
    $indexN = 0;
    $indexN2 = 0;

    while ($indexN < 2){

    $firstC = $CurveA1[$indexN];
    $SecondC = $CurveA2[0];
    $SecondCA = $CurveA2[1];

    $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);

    if ($NumberE == 3){
    if($indexN==0){
    $IndexEnds[0]=0; $IndexEnds[1]=0;

    }else{
    $IndexEnds[0]=1; $IndexEnds[1]=0;
    }
    $CurveMeetsTrue = 1;
    break; }

    if ($NumberE2 == 3){

    if($indexN==0){
    $IndexEnds[0]=0; $IndexEnds[1]=1;
    }else{

    $IndexEnds[0]=1; $IndexEnds[1]=1; }
    $CurveMeetsTrue = 1;
    break; }

    if ($indexN==1){$indexN1 = 1;}
    $indexN++;
    }

    $TF = $CurveMeetsTrue;
    return $IndexEnds;
    }





    proc vector[] GetVectorArrayCRVEnds(string $CurveItemZ[]){

    for ($CurveItem in $CurveItemZ) {
    $numCVs = `getAttr -size ($CurveItem +  ".controlPoints")`;
    $num = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem + ".cv[" +  $num + "]") ;
    for ($eachZA in $CurveSelection) {
    $eachCVposV = `pointPosition -w ($eachZA)`;
    $CurveAB[`size($CurveAB)`] = $eachCVposV;
    }
    }
    return $CurveAB;
    }


    $selItemz = `ls-sl`;

    $NewAMatrix = GetMatrix($selItemz[0]);

    $NewBMatrix = GetMatrix($selItemz[1]);




    clear $selLocz;
    for($eachVec in  $VecArrayPos_MC){
    $selLocz[`size($selLocz)`] = `Loc $eachVec`;
    }

    select -r $selLocz[0];

    TransformRelByMatrixXformMX($NewBMatrix, $selLocz)




    TransformRelByMatrixXform($NewBMatrix, $selItemz[0]);
    TransformItemByMatrixXform($NewBMatrix, $selItemz[0]);





    proc TransformRelByMatrixXformMX(matrix $m[][], string $itemA[]){
    $VecLi = PointArrayT($itemA);
    $count = 0;
    for($item in $itemA){
    $itemD  = `duplicate -rr $item`;
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $itemD[0];
    select -r $itemD ; PAUSE;
    //$NewVeci = VecMultMatrix($NewVeci, $m);
    //xform -ws -t ($NewVeci.x) ($NewVeci.y) ($NewVeci.z) $itemD[0];
    $count++;
    }
    }

    proc TransformItemByMatrixXform(matrix $m[][], string $item){
    $itemD = `duplicate -rr $item`;
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $itemD[0];
    }

    $VecCamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $VecArrayPos_MC = PointArrayT(`ls-sl -fl`);



    $ThreeEllipVecP = PointArrayT(`ls-sl`);
    //////////////////

    $PtsVec = PointArrayT(`ls -sl`);
    $FDirNorA = Normal3Points($PtsVec[0], $PtsVec[1],$PtsVec[2]);
    //////////


    //	$ThreeEllipVecP[0] = $CurveCollectVec[$NewIndexAi[0]] ;
    //	$ThreeEllipVecP[1] = $NewPvec;
    //	$ThreeEllipVecP[2] = $CurveCollectVec[$ChangeOver];
    $NewEllipesCurve = calculateEllipseCurve($ThreeEllipVecP, 300);


    //LineIntersectCirTF(  $ObjsCirclesRad , $VecArrayPos_MC[1], $VecCamPos_A ,$VecArrayPos_MC[0])

    // circle pos, circle radius, line direction, line pos
    //proc int LineIntersectCirTFZ(float $ObjsCirclesRad, vector $CircPos[], vector $PosA,vector $PosB){


    $AVecArrayPos_MC = PointArrayT(`ls-sl`);


    LineIntersectCirTFZ(float $ObjsCirclesRad, vector $CircPos, vector $PosB){


    $AVecArrayPos_MC = PointArrayT(`ls-sl`);

    $VecCamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;

    $CircPos = $VecArrayPos_MC[1];
    $PosA = $VecCamPos_A;
    $PosB = $AVecArrayPos_MC[0];
    $ObjsCirclesE = `arclen`*2.0;


    $ObjsCirclesEi = `arclen`;
    $ObjsCirclesEii = `arclen`;
    // Result: 0.41585 //
    // Result: 14.251443 //

    // Result: 23.164589 //
    // Result: 0.191253 //

    $Di = distance2Pts( $CircPos , $PointN);

    $VecLineDir = PositiveDirectionLine($PosA, $PosB);
    //float $ObjsCirclesRad = `arclen`*2.0;
    // $ObjsCirclesRad = $ObjsCirclesRad/2.0;

    $PointN = ClosestPoint2Line($VecLineDir, $PosA, $CircPos);
    Loc $PointN;
    curve2points($PosB, $PointN);
    print  $ObjsCirclesRad;

    $Di = distance2Pts( $CircPos , $PointN);
    $DiffL = ($ObjsCirclesRad-$Di)*2.0;

    //$Di = $ObjsCirclesRad;

    $Vec[0] = $PosA;
    $Vec[1] = $PosB;
    $Vec[2] = $CircPos;


    $FloatDirXn = DirectionF( $Vec[2], $Vec[0]);
    $PointNii = MultLenToDirAddToPoint($Di, DirectionF( $Vec[2], $PointN), $PointN);
    Loc $PointNii;
    $DistAddiR2 = $Di*2.0;
    $HightD = sqrt (abs ((`pow $Di 2.0`) - (`pow $ObjsCirclesRad 2.0`)));
    $PointNiii = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[1], $Vec[0]), $PointN);
    Loc $PointNiii;

    $PointNiiiB = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[0], $Vec[1]), $PointN);
    Loc $PointNiiiB;
    curve2points($PointNiii,$PointNiiiB);



    if($Di<$eachObjsCirclesRad){
    $returnValue =1; break;}
    if($Di==$eachObjsCirclesRad){
    $returnValue =0;}
    if($Di>$eachObjsCirclesRad){
    $returnValue =-1;}
    $IndexI++;
    }

    return $returnValue;
    }


    $AVecArrayPos_MC = PointArrayT(`ls-sl`);

    //distance2Pts(  $AVecArrayPos_MC[0] ,  $AVecArrayPos_MC[2]);
    //distance2Pts(  $AVecArrayPos_MC[1] ,  $AVecArrayPos_MC[2]);

    $A_CrvCentroidA = FloatToVec(AverageVectorPoint( $AVecArrayPos_MC));
    Loc $A_CrvCentroidA;


    $CurveItemZ = `ls -sl`;


    PointCurvesToPlaneCurve($CurveItemZ);


    $ObjsCirclesEi = `arclen`;
    $ObjsCirclesEii = `arclen`;
    $ObjsCirclesEiii = `arclen`;

    $Dii = distance2Pts(  $AVecArrayPos_MC[0] ,  $AVecArrayPos_MC[1]);
    $DiX = distance2Pts(  $AVecArrayPos_MC[0] ,  $VecCamPos_A);

    $DiffMathAz = $ObjsCirclesEii/$DiX;
    $DiffMathBz = $DiffMathAz*$Dii;
    $TESTx = $ObjsCirclesEii +$DiffMathBz ;


    // Result: -2.134459 //
    print $ObjsCirclesEiii;
    2.268188


    $DiffMathA = $DiX / (($Dii+$DiX)/100.0);

    // Result: 2.94791 //
    $Testr = ($ObjsCirclesEii / $ObjsCirclesEiii);
    // Result: 0.0294791 //


    $DiffMathAi = (($DiffMathA/100.0) * $ObjsCirclesEiii);


    $DiffMathA = $DiX / (($Dii+$DiX)/100.0);
    $DiffMathB = $Dii / (($Dii+$DiX)/100.0);

    $DiffMathBi = $DiffMathB / 100.0;

    $Testri = ($Dii/$DiX)+1.000;
    $DiffMathAiX = ($Testri * $ObjsCirclesEii);
    $TESTx = $ObjsCirclesEiii -$DiffMathAiX ;

    $Testr = ($ObjsCirclesEiii / $ObjsCirclesEii);
    $TESTx = $Testr -$Testri;

    $TESTx = $Testr -$Testri;


    $DiffMathAx = $ObjsCirclesEii/ (($ObjsCirclesEiii)/100.0);

    $DiffMathAi = (($DiffMathAx/100.0) * $ObjsCirclesEii);

    $Testr = ($ObjsCirclesEii / $ObjsCirclesEiii);

    // 1.167526

    // Result: 0.0668641 //
    // Result: 2.268188 //

    print $Dii;
    print $ObjsCirclesEi;
    print $ObjsCirclesEii;
    print $ObjsCirclesEiii;

    $Testrii = ($ObjsCirclesEiii - $ObjsCirclesEii)/$Dii;

    $Testr = ($ObjsCirclesEiii / $ObjsCirclesEii);
    $Testri = ($Dii/$Testr);

    $PerDiffX = percent_of( $ObjsCirclesEii ,$ObjsCirclesEiii);

    //start with a simple string
    $initial_string = "a";

    //define some rules of replacement and put them in an array
    $rules[0] = "aab->abbaaa";

    //iteratively replace and return the final result into the variable $tmp
    $tmp = aa_lsystem_replace("a",$rules,3);

    //print the result
    print($tmp);


    $drawrules[0] = "a->move 10";
    $drawrules[1] = "b->turn 90 0";

    //draw a line using the rules and an lsystem string (using the $tmp string
    // from the aa_lsystem_replace example)
    aa_lsystem_draw($tmp,$drawrules,<<0,0,0>>,0,0);

    /*
    $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
    $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    $NofCirclesa = (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
    $NofCirclesb = ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
    $NofCirclesc = ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);

    */


    clear $Xs;
    $centerX = $centerY = 0.0;
    $sides = 22.000;
    $PI = 3.1415926535;
    $away =15.00;
    $Yp=0.0;

    $r =  $away;
    $Cir = ($PI *$r )*2.00 ;
    $Seg = $Cir/8.0;
    $LengAngle = 360.000/$Seg;

    $DiffMathA = $Seg / ($Cir/100.0);
    $DiffMathAB = 360.0/(100.0/$DiffMathA);


    $angle = $LengAngle / $sides;

    for( $i=0; $i <= $sides; $i++ ){
    // How far around the center.
    $a = $i * $angle ;
    $x = (($centerX + cos( deg_to_rad($a) ) * $away));
    $y =  (($centerY + sin( deg_to_rad($a) ) * $away));
    $Xs[$i] =<<$x, $Yp, $y>>;
    }
    $ThefirstCurve = VecArrayToCurve($Xs);




    proc LogCurveDetail(vector $Direction, vector $startV, float $L){
    //vector $Direction =<< 1.0,0.0,0.0>>;
    $Normal = << 0.0,1.0,0.0>>;
    $angle = 0.00;
    $i = 0;
    $Xs[$i] = $startV;

    $AstepF = 0.035;
    $TstepF = 1.025;
    $Step = 120;
    $LSS = 0.050;

    $a = 1.0;
    for( $i=1; $i <= $Step; $i++ ){

    $angle +=$AstepF;
    $angle*=1.025;
    // $a = `logN ($angle)` ;
    $a =  ($angle);
    $Xs[$i] = RotMultLenPts($Xs[$i-1], $Direction, $Normal, $L, deg_to_rad($a) );
    $Direction= `unit (FloatToVec(DirectionFN($Xs[$i],$Xs[$i-1])))`;
    }
    $ThefirstCurve = VecArrayToCurve($Xs);
    }

    ////////////////////////////////////////////



    clear $HighCurvePoints;
    clear $NormalCurvePoints;
    clear $FoundRadii;

    $HighCurvePoints = CurvatureUtilityDetailCurvature($CurveItemA[0], 260,$NormalCurvePoints,$FoundRadii);

    print $FoundRadii;
    $CurveSizeFloat = logN(logN(logN(`log (5.605099)`)));

    clear $CurvesV;
    $LS = 0.050;
    $Cindex = 0;
    if(`size($HighCurvePoints)`>0){
    for ($eachVec in $HighCurvePoints){
    LogCurveDetail(`unit $NormalCurvePoints[$Cindex]`*-1, $eachVec, 0.005 );

    $Cindex++;

    }
    }


    clear $CurvesV;
    $LS = 0.050;
    $Cindex = 0;
    if(`size($HighCurvePoints)`>0){
    for ($eachVec in $HighCurvePoints){
    LogCurveDetail(`unit $NormalCurvePoints[$Cindex]`*-1, $eachVec, abs (((logN(`log ($FoundRadii[$Cindex]/9.0)`)))));

    $Cindex++;

    }
    }


    $Cindex = 0;
    for ($eachVec in $HighCurvePoints){

    $XLOOG = abs  (((logN(`log ($FoundRadii[$Cindex]/8.0)`))));
    print ($XLOOG +"\n");
    $Cindex++;
    }

    //$a = $angle;
    //$Xs[$i] = $Xs[$i-1]+($L*( (FloatToVec(RotDirToPoint($Xs[$i-1],$Direction,$L,$Normal, deg_to_rad($a)) ))));
    // $Xs[$i] = $Xs[$i-1]+($L*(`unit(FloatToVec(RotDirToPoint($Xs[$i-1],$Direction,$L,$Normal, deg_to_rad($a)) ))`));
    //$Xs[$i] = $Xs[$i-1]+($L*(`unit(FloatToVec(RotDirToPoint($Xs[$i-1],$Direction,$L,$Normal, atan($a) )))`));



    proc vector RotMultLenPts(vector $Vecpt, vector $Direc, vector $DirNorm, float $Length, float $Radian){
    $DirecAB = ((unit(`rot $Direc $DirNorm $Radian`))*$Length)+$Vecpt;
    return $DirecAB;
    }


    proc float logN(float $x){
    $a = (`log (abs($x))`)*(`sign($x)`) ;
    return $a;
    }


    SteinerChain(22,5);
    SteinerChain(22, 3.2);

    proc string [] SteinerChain(float $RAa, float $RBb){
    //
    // float $RAa = 22.0;
    // float $RBb = 3.2;

    $pi = 3.1415926535;
    $Pi = 3.1415926535;
    if(!( $RAa==$RBb)){
    if( $RAa<$RBb){
    $RA = $RBb;
    $RB = $RAa;}else{ $RA = $RAa; $RB =  $RBb;}

    //float $RA = 22.0;
    //float $RB = 15.68;
    $circleA = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RA -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $circleB = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RB -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $R2 = $RA;
    $R1 = $RB;
    $DCircle = (($R2 - $R1)/2.0) + $R1 ;
    $Rii = (($R2 - $R1)/2.0);
    $SideA = $RB + $Rii;
    $SideB = $Rii*2;
    //GOT it for SURE
    //HightsOfIsoscelesTriangle($SideA, $SideB, $SideA)
    $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    $ArcangleC2 = $ArcangleC*2.0;
    $Aii = (`asin ($RB/($RB + $Rii))`);
    $number3 = 360.0/$ArcangleC2;

    ////////////////####
    ///////////////###
    $NumberCs = $number3;

    $n = $number3;
    $len = $DCircle;
    $r = $DCircle;
    $angle = 360.0 / $n ;
    print $angle;

    $x = createRegularPolygonX( $n, $r ) ;
    $y = createRegularPolygonY( $n, $r ) ;

    // create the n-sided polygon.
    $z = 0.0 ;




    $LItem = `ls -sl`;
    $VCirPosX = `xform -q -ws -t $LItem[0]`;


    matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;

    $Normal = <<0.0, 1.0, 0.0>>;


    $VecPairA[0]= <<0.0, 1.0, 0.0>>;
    $VecPairA[1]= $VecPairA[0]*2;

    $matrixA = TwoPointMatrixPlusAxisWorld($VecPairA, $EmptyVecA, 1);
    $matrixA  = TwoPointMatrixB($VecPairA);
    $DirectionStart = <<$matrixA[0][0], $matrixA[0][1], $matrixA[0][2] >>;
    $angle = 360.0 / ($n*2) ;
    $rotatsB = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($angle)) );
    $DirectionStartB = <<$rotatsB[0], $rotatsB[1], $rotatsB[2] >>;
    $DirectionStartB = `unit($DirectionStartB)`;
    Loc $DirectionStartB;

    //RotMultLenToDirAddToPoint(float $PosA[], float $PosB[], float $Length, float $DirNormAx[], float $Radian)
    // float $rotatsA[] = RotDirToPoint($DirectionStart, $VCirPosX,$RA, $Normal, $a );
    $angle = 360.0 / $n ;




    for( $i = 0 ; $i < ($n) ; $i++ ) {
    $a = $i * $angle ;
    $rotatsA = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($a)) );
    Loc $rotatsA;

    }


    for( $i = 0 ; $i < ($n) ; $i++ ) {
    $a = $i * $angle ;
    $rotatsA = RotDirToPoint($VCirPosX,$DirectionStart, $RB, $Normal, (deg_to_rad($a)) );
    Loc $rotatsA;

    }


    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < ($n) ; $i++ ) {
    $a = $i * $angle ;
    $rotatsA = RotDirToPoint($VCirPosX,$DirectionStartB, $r, $Normal, (deg_to_rad($a)) );
    $VrotatsA[$i] =   FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $r, $Normal, (deg_to_rad($a)) ));

    Loc $rotatsA;

    }
    //////////////////////////////////


    for( $i = 0 ; $i < $n ; $i++ ) {

    $a = $i * $angle ;
    $rotatsA = RotDirToPoint($VCirPosX,$DirectionStart, $r, $Normal, (deg_to_rad($a)) );

    $VrotatsCiH[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $RA, $Normal, (deg_to_rad(($a))) ));
    $VrotatsBiH[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $RB, $Normal, (deg_to_rad(($a))) ));
    Loc $VrotatsCiH[$i];

    $VrotatsCi[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($a)) ));
    $VrotatsBi[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $r, $Normal, (deg_to_rad($a)) ));

    $VrotatsAi[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStart, $RB, $Normal, (deg_to_rad($a)) ));


    $CirclePts = <<$rotatsA[0], $rotatsA[1], $rotatsA[2] >>;

    $DirLine = DirectionFN($CirclePts, $VCirPosX);
    $Vperp = crossProduct( $DirLine, $Normal, 0, 0 );
    $Vperp = `unit($Vperp + $DirLine)`;
    $VperpN = crossProduct( $DirLine, ($Normal*-1.0), 0, 0 );
    $VperpN = `unit( ($VperpN) + ($DirLine))`;

    $VperpA = ($Rii/2.0)* $VperpN*-1.0;
    $VperpA = $CirclePts+$VperpA;
    Loc $VperpA;


    curve2points($VrotatsBi[$i],$VrotatsCiH[$i]);

    if($i>0){

    curve2points($VrotatsBi[$i-1],$VperpA);


    }
    if($i==0){
    $Templast= $VperpA;}

    $VperpC = ($Rii/2.0)*$DirLine;
    $VperpC = $CirclePts+$VperpC;
    Loc $VperpC;
    curve2points($VrotatsCi[$i],$VperpC);
    /////////////

    $VperpB = ( $Rii/2.0)*$Vperp*-1.0;
    $VperpB = $CirclePts+$VperpB;
    Loc $VperpB;
    curve2points($VrotatsBi[$i],$VperpB);

    /////////////////////

    $VperpD = (-1*$Rii/2.0)*$DirLine;
    $VperpD = $CirclePts+$VperpD;
    Loc $VperpD;

    curve2points($VrotatsAi[$i],$VperpD);
    curve2points($VrotatsBi[$i],$VrotatsBiH[$i]);

    if($i==($n-1)){
    curve2points($VrotatsBi[$i],$Templast);
    }

    $circlesC = `circle -c $rotatsA[0] $rotatsA[1] $rotatsA[2] -nr 0 0 1 -sw 360 -r ($Rii/2.0) -d 3 -ut 0 -tol 0.001 -s 16 -ch 1`;
    $circles[$i] = $circlesC[0];
    makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $circles[0];
    xform -cp $circles[$i];
    }



    //$circles[`size($circles)`] = $circleA[0];
    //$circles[`size($circles)`] = $circleB[0];
    select -r $circleA $circleB $circles ;
    //select -r $circles ;
    return $circles;
    }
    }


    proc  Circle3PtZB(){
    ResetTransEachSL;



    $selectionList = `ls -sl`;

    $veCPos1[0] = `xform -q -ws -t $selectionList[0]`;
    $veCPos1[1] = `xform -q -ws -t $selectionList[1]`;
    $veCPos1[2] = `xform -q -ws -t $selectionList[2]`;

    $p1 = `xform -q -ws -t $selectionList[0]`;
    $p2 = `xform -q -ws -t $selectionList[1]`;
    $p3 = `xform -q -ws -t $selectionList[2]`;

    // Get the vector p1-p2, p1-p3
    //
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $p1p4[0] = $p2[0]-$p3[0]; 		$p1p4[1] = $p2[1]-$p3[1]; 		$p1p4[2]= $p2[2]-$p3[2];

    // Get the normal to the plane formed by p1, p2, p3, which is the
    // cross prod of p1-p2 and p1-p3

    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );


    //float $OrthoCenterC = midPoint2Pts( $FloatPos1, $p3 );
    $FloatPosZero = {0, 0, 0};
    $FloatDirection = DirectionF($FloatPosZero, $normal);
    $MultDirP = multiplyFloat(2, $FloatDirection);
    //float $FloatDirectionPoint[] = AddFloats($MultDirP, $FloatPos1);


    // Get the mid pts on each vector (the average of two pts)
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $mid3 = midPoint2Pts( $p2, $p3 );

    //$mid1 a-b $mid2 a-c $mid3 b-c


    // Get the perp. vectors to p1-p2 and p1-p3, which is the
    // cross prod of the normal vector with p1-p2 and p1-p3. Get these
    // as normalized vectors before sending them to lineIntersection

    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $perp_p1p4 = crossProduct( $normal, $p1p4, 0, 1 );



    // Intersect the persp. vectors going through the mid pts.
    // The intersection is the center of the arc.
    //
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    //spaceLocator -p 0 0 0;
    //MoveObject2($center);

    //FloatDirPerpCenter is FloatDirPerpCenterA
    $FloatDirPerpCenter = DirectionF($center, $mid3);
    $FloatDirPerpCenterB = DirectionF($center,$mid1);
    $FloatDirPerpCenterC = DirectionF($center,$mid2);

    $FloatDirPointAB = DirectionF($p1, $p2);
    $FloatDirPointBC = DirectionF($p2, $p3);
    $FloatDirPointAC = DirectionF($p1, $p3);


    //MidPoint of Iso Tri
    $center6 = lineIntersection( $p1, $FloatDirPerpCenter, $p2, $FloatDirPointBC );


    $center7 = lineIntersection( $p3,  $FloatDirPerpCenterB, $p1, $FloatDirPointAB );


    $center8 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );

    $center9 = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPerpCenter );

    $OrthoCenterCir = midPoint2Pts( $center9, $center );


    $Radius2HalfTimes2 = (distance2Pts( $center9, $center ))*2;
    $Radius2BHalf = (distance2Pts( $center9, $center ));

    // Find the radius for the circle and return the radius.
    //

    $radiusZ = distance2Pts( $p1, $center );
    $Radius3Half = $radiusZ/2;

    //string $circlesItemB[];
    //$circlesItemB[0] = Circles_Direction($OrthoCenterCir, $FloatDirection, $Radius2HalfTimes2);

    //string $circlesItemC[];
    //$circlesItemC[0] = Circles_Direction($OrthoCenterCir, $FloatDirection,  $Radius2BHalf);

    $circlesItem[0] = Circles_Direction($center, $FloatDirection, $radiusZ);


    }

    Circle3PtZB;




    clear $Xs;
    $centerX = $centerY = 0.0;
    $sides = 22.000;
    $PI = 3.1415926535;
    $away =22.0;
    $Yp=0.0;

    $r =  $away;
    $Cir = ($PI *$r )*2.00 ;
    $Seg = $Cir/8.0;

    $LengAngle = 360.000/$n;
    $angle = $LengAngle / $sides;

    $Start_angle = (90.0);

    for( $k=0; $k < $n; $k++ ){


    for( $i=0; $i <= $sides; $i++ ){
    // How far around the center.
    $a = ($i * $angle)+$Start_angle ;
    $End_angle=$a;
    $x = (($centerX + cos( deg_to_rad($a) ) * $away));
    $y =  (($centerY + sin( deg_to_rad($a) ) * $away));
    $Xs[$i] =<<$x, $Yp, $y>>;
    }
    $ThefirstCurve = VecArrayToCurve($Xs);
    $Start_angle = $End_angle;


    $VecCurEndsa = VecCurveEnds({$ThefirstCurve});
    for($eachV in $VecCurEndsa){
    $Locs[0] = `Loc ($eachV)`;
    SetItemColorString ($Locs[0], 6);
    }
    }



    $centerX = $centerY = 0.0;
    $sides = 22.000;
    $PI = 3.1415926535;
    $away =15.00;
    $Yp=0.0;

    $r =  $away;
    $Cir = ($PI *$r )*2.00 ;
    $Seg = $Cir/8.0;
    $LengAngle = 360.000/$Seg;

    $angle = $LengAngle / $sides;

    for( $i=0; $i <= $sides; $i++ ){
    // How far around the center.
    $a = $i * $angle ;
    $x = (($centerX + cos( deg_to_rad($a) ) * $away));
    $y =  (($centerY + sin( deg_to_rad($a) ) * $away));
    $Xs[$i] =<<$x, $Yp, $y>>;
    }
    $ThefirstCurve = VecArrayToCurve($Xs);







    clear $Xs;
    $centerX = $centerY = 0.0;
    $sides = 22.000;
    $PI = 3.1415926535;
    $away =15.00;
    $Yp=0.0;

    $r =  $away;
    $Cir = ($PI *$r )*2.00 ;
    $Seg = $Cir/8.0;
    $LengAngle = 360.000/$Seg;

    $DiffMathA = $Seg / ($Cir/100.0);
    $DiffMathAB = 360.0/(100.0/$DiffMathA);


    $angle = $LengAngle / $sides;

    for( $i=0; $i <= $sides; $i++ ){
    // How far around the center.
    $a = $i * $angle ;
    $x = (($centerX + cos( deg_to_rad($a) ) * $away));
    $y =  (($centerY + sin( deg_to_rad($a) ) * $away));
    $Xs[$i] =<<$x, $Yp, $y>>;
    }
    $ThefirstCurve = VecArrayToCurve($Xs);




    proc float[] createRegularPolygonY( int $n, float $r )
    {
    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * cos(deg_to_rad($a)) ;
    }
    return $x ;
    }
    proc float[] createRegularPolygonX( int $n,float $r )
    {
    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * sin(deg_to_rad($a)) ;
    }
    return $x ;
    }


    //arclen

    // 159.434902 = C of circle    .. 12.000  = bounding Box of object

    $DiffMathA = 12.000 / (159.434902/100.0);
    $LengAngle = 360.000/$DiffMathA;
    $angle = 180.000/$sides;

    clear $Xs;
    $centerX = $centerY = 0;
    $sides = 22.000;
    $PI = 3.1415926535;
    $away =25.378;
    $Yp=0.0;
    $DiffMathA = 12.0 / (159.434902/100.0);

    //float $DiffMathAB = 360.0/(100.0/$DiffMathA);

    $LengAngle = 360.0/(100.0/$DiffMathA);


    $angle = $LengAngle / $sides;

    for( $i=0; $i <= $sides; $i++ ){
    // How far around the center.
    $a = $i * $angle ;
    $x = (($centerX + cos( deg_to_rad($a) ) * $away));
    $y =  (($centerY + sin( deg_to_rad($a) ) * $away));
    $Xs[$i] =<<$x, $Yp, $y>>;
    }
    $ThefirstCurve = VecArrayToCurveB($Xs);




    SteinerChain(22,5);

    proc string [] SteinerChain(float $RAa, float $RBb){
    //
    //float $RA = 22.0;
    //float $RB = 15.680;
    $pi = 3.1415926535;
    $Pi = 3.1415926535;
    if(!( $RAa==$RBb)){
    if( $RAa<$RBb){
    $RA = $RBb;
    $RB = $RAa;}else{ $RA = $RAa; $RB =  $RBb;}
    //float $RA = 22.0;
    //float $RB = 15.68;
    $circleA = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RA -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $circleB = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RB -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $R2 = $RA;
    $R1 = $RB;
    $DCircle = (($R2 - $R1)/2.0) + $R1 ;
    $Rii = (($R2 - $R1)/2.0);
    $SideA = $RB + $Rii;
    $SideB = $Rii*2;
    //GOT it for SURE

    $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    $ArcangleC2 = $ArcangleC*2.0;
    //float $Aii =  (`asin ($RB/($RB + $Rii))`);
    $number3 = 360.0/$ArcangleC2;
    $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
    $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    $NofCirclesa = (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
    $NofCirclesb = ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
    $NofCirclesc = ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);

    $NumberCs = $number3;
    $n = $NumberCs;
    $len = $DCircle;
    $r = $DCircle;
    $x = createRegularPolygonX( $n, $r ) ;
    $y = createRegularPolygonY( $n, $r ) ;
    // create the n-sided polygon.
    $z = 0.0 ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $circlesC = `circle -c $x[$i] $y[$i] $z -nr 0 0 1 -sw 360 -r $Rii -d 3 -ut 0 -tol 0.001 -s 16 -ch 1`;
    $circles[`size($circles)`] = $circlesC[0];
    makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $circles[0];
    xform -cp $circles[0];
    //rotate -r -os 0 0 45 $circles[0];
    //aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "scene" $circleB[0] $circles[0];

    }
    //$circles[`size($circles)`] = $circleA[0];
    //$circles[`size($circles)`] = $circleB[0];
    select -r $circleA $circleB $circles ;
    //select -r $circles ;
    return $circles;
    }
    }









    $CurveItemAXX = `ls -sl`;


    $CurveItemAX = `ls -sl`;
    CurvesToPlane( $CurveItemAX);

    $CurveItemAX = `ls -sl`;
    VanishingCurvesS({$CurveItemAX[0]})



    $LengthsT = ArcLengthArray(`ls -sl`);
    AnglesofTriangle($LengthsT[0], $LengthsT[1], $LengthsT[2]);


    $LengthsM = ArcLengthArray(`ls -sl`);
    // Result: 41.305301 //

    $Lengths = ArcLengthArray(`ls -sl`);
    // Result: 48.907858 46.767741 35.03743 37.820183 //
    1          2          3     4

    for($eachF in $Lengths){
    $LengthsSub[`size($LengthsSub)`] = $eachF - $LengthsM[0];

    }
    print $LengthsSub;
    7.602557
    5.46244
    -6.267871
    -3.485118

    0.115505
    0.15301
    0.163837
    0.183377

    $PerDiff = percent_of($LengthsM[0], $Lengths[3]);
    // Result: 1.184058 //
    // Result: 1.132245 //
    // Result: 1.178891 //
    // Result: 1.09215 //

    $LengthsC = ArcLengthArray(`ls -sl`);
    // Result: 0.115 0.153 0.163 0.183 //
    4       3      2       1
    print $LengthsC;



    $Positions = VecCurveEps($CurveItemAX[0]);



    //GetworldMatrix(string $object)

    $CamMatrix = GetMatrix("ZCURVEModelingCAM");

    $SbMatrix= GetMatrix("LiveSurfaceB");

    PrintMatrix($CamMatrix , 4);
    |   0.7071067812              0  -0.7071067812              0|
    |  -0.2988362387    0.906307787  -0.2988362387              0|
    |   0.6408563821   0.4226182617   0.6408563821              0|
    |             48             41             48              1|

    PrintMatrix($SbMatrix , 4);
    |   0.7071067812              0  -0.7071067812              0|
    |   0.6408563821   0.4226182617   0.6408563821              0|
    |   0.2988362387   -0.906307787   0.2988362387              0|
    |    47.51487706    40.68008189    47.51487706              1|


    $CamMatrixR = GetMatrix("ZCURVEModelingCAM");
    $SbMatrixR= GetMatrix("LiveSurfaceB");

    PrintMatrix($CamMatrixR , 4);
    |   0.3971478906              0  -0.9177546257              0|
    |  -0.2713874308   0.9552783621  -0.1174398283              0|
    |   0.8767111357     0.29570805   0.3793867865              0|
    |    65.68910652    31.48173412    28.38978033              1|

    PrintMatrix($SbMatrixR , 4);
    |   0.3971478906              0  -0.9177546257              0|
    |   0.8767111357     0.29570805   0.3793867865              0|
    |   0.2713874308  -0.9552783621   0.1174398283              0|
    |    65.02544355    31.25788598    28.10258772              1|


    $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM`;
    $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM`;
    // Result: <<48, 41, 48>>  //
    // Result: <<-25, 45, 0>>  //


    Loc $Cam_Trans;

    $Plane_Trans = `xform -q -ws -t LiveSurfaceB`;
    $Plane = `xform -q -ws -ro LiveSurfaceB`;


    setAttr "ZCURVEModelingCAM.rotateX" -25;
    setAttr "ZCURVEModelingCAM.rotateY" 45;
    setAttr "ZCURVEModelingCAM.rotateZ" 0;

    setAttr "ZCURVEModelingCAM.translate" 48 41 48;

    $PtsVec = PointArrayT(`ls -sl`);
    $FDirNorA = Normal3Points($PtsVec[0], $PtsVec[1],$PtsVec[2]);
    $VCrvPos_AA =  FloatToVec(AverageVectorPoint($PtsVec));

    makeCurvePointDirectionLength(22, $FDirNorA, $VCrvPos_AA);


    ////////////

    $PtsVec = PointArrayT(`ls -sl`);
    AnglesofTriangleThreeVec($PtsVec[0], $PtsVec[1],$PtsVec[2]);
    /////////////////



    $VCrvPos_A =  FloatToVec(AverageVectorPoint($PtsVec));
    Loc $VCrvPos_A;

    $LItem = `ls -sl`;
    $VLocPosX = `xform -q -ws -t $LItem[0]`;


    InsidePolygon($Positions,$VLocPosX);

    proc int InsidePolygon(vector $c[],vector $VLocPos_A)
    {

    $VCrvPos_A =  FloatToVec(AverageVectorPoint($c));

    $x = VecCom($VLocPos_A, 0);
    $y = VecCom($VLocPos_A, 1);

    // Convex is just a collection of points for the polygon
    // just replace that code in the for-loop to loop through the points in your polygon

    $PI = 3.1415926535;
    $angle = 0;
    $Distance = 0;
    $DistanceMM = 0;
    $Arc = 0;
    $p1x = 0, $p1y = 0, $p2x = 0, $p2y = 0;
    $SizeV = size($c);
    $TotalS = $SizeV;
    $triarea = 0;
    $tri_areaM = 0;
    $countS =1;

    for ($i=0;$i< $SizeV; $i++) {

    $indexState = $i;
    $indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
    $indexRight = fmod(($indexState + $countS),$TotalS);
    $DistA = distance2Pts($c[$i], $c[$indexLeft]);
    $DistB = distance2Pts($c[$i], $c[$indexRight]);
    if($DistA<$DistB){
    $nearestIndex = $indexLeft;
    }else{$NearIndex = $indexRight;}
    /*
    $p1x = ( (VecCom($c[$i], 0)) - $x ); // point A X - X
    $p1y = ( (VecCom($c[$i], 1)) - $y ); // point A Y - Y
    $p2x = ( (VecCom($c[$NearIndex], 0)) - $x ); // point A's nearest neighbor X - X
    $p2y = ( (VecCom($c[$NearIndex], 1)) - $y ); // point A's nearest neighbor Y - Y
    */
    $aP = distance2Pts($c[$i], $c[$indexRight]);
    $bP = distance2Pts($VLocPos_A, $c[$indexRight]);
    $cP = distance2Pts($c[$i], $VLocPos_A);
    $triarea += 0.25* (sqrt ( ($aP+$bP+$cP)  * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP)  ));
    $aPm = distance2Pts($c[$i], $c[$indexRight]);
    $bPm = distance2Pts($VCrvPos_A, $c[$indexRight]);
    $cPm = distance2Pts($c[$i], $VCrvPos_A);
    $tri_areaM += 0.25* (sqrt ( ($aPm+$bPm+$cPm)  * ($bPm+$cPm-$aPm) * ($cPm+$aPm-$bPm) * ($aPm+$bPm-$cPm)  ));
    $DistanceMM += distance2Pts($c[$i], $VCrvPos_A);
    $Distance += distance2Pts($c[$i], $VLocPos_A);
    //$angle += Angle2D($p1x,$p1y,$p2x,$p2y);
    $Arc += distance2Pts($c[$i], $c[$indexRight]);
    }

    //print ("Tri_area: "+$triarea + "\n");
    //print ("Tri_areaM: "+$tri_areaM+ "\n");
    /*
    if (abs($angle) < $PI){
    print (" INSIDE " + "\n");
    }else{ print (" OUTSIDE! " + "\n");}
    */

    // if (equivalentTol($triarea, $tri_areaM,  0.00001) ==1){
    //print ("Tri_area INSIDE " + "\n");
    //}else{ print ("Tri_area OUTSIDE! " + "\n");}

    //   if (abs($angle) < $PI){//
    if (equivalentTol($triarea, $tri_areaM,  0.00001) ==1){
    return 1;
    }else{
    return 0;}

    }


    proc float VecCom(vector $Vai, int $XYZ){
    $x = $Vai.x;
    $y = $Vai.y;
    $z = $Vai.z;
    if($XYZ==0){$N=$x;} if($XYZ==1){$N=$y;} if($XYZ==2){$N=$z;}
    return $N;
    }


    proc float Angle2D(float $x1, float $y1, float $x2, float $y2)
    {
    $PI = 3.1415926535;
    $TWO_PI = 3.1415926535;


    $theta1 = atan2($y1,$x1);
    $theta2 = atan2($y2,$x2);
    $dtheta = $theta2 - $theta1;

    while ($dtheta > $PI)
    $dtheta -= $TWO_PI;
    while ($dtheta < -$PI)
    $dtheta += $TWO_PI;


    return $dtheta;
    }

    /*


    $Arc = `arclen $CurveItemAX[0]`;
    $AverageVecCurve = AverageVectorPoint($Positions);

    //////////

    $DDistPt_toC = distance2Pts($VCrvPos_A, $VLocPos_A);
    $DDist = $Distance/float($TotalS);
    print ("Dist_each/SIZE: "+$DDist + "\n");
    //Dist_each/SIZE: 18.31929743
    print (" dist_to_M: "+ $DDistPt_toC+"  dist_each: "+$DDist + "\n");
    $DDistX = $Distance+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    $DDistMM = $DistanceMM+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    $DDistMM = $DistanceMM/float($TotalS);
    $MathA = $DDistMM/$DDist;
    $MathB = $DDistPt_toC/$MathA;
    print $Arc;
    outside
    dist_to_M: 8.210088295  dist_each: 10.678618
    dist_to_M: 10.98501803  dist_each: 19.20895454
    inside
    dist_to_M: 4.491177258  dist_each: 10.90761121
    dist_to_M: 2.733438324  dist_each: 15.81548968
    print (" distance to crv middle "+ $DDistPt_toC+" dist to each crv div "+$DDist + "\n");
    //float $Xpi = $PI/$angle;
    //float $XTpi = $Xpi*$angle;
    print ($angle + "\n");
    */

}


/******************************************************************************
 * @procedure    StringArrayCountIndexDup
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *   $Count : int
 *
 * @returns      int[]
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int[] StringArrayCountIndexDup(string $item, string $list[], int $Count)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = 0;
    int $index = 0;
    int $indexArray[];
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = 0;
    $index = 0;

    for ($listItem in $list) {

    if ($item == $listItem){
    $indexArray[$result] = $index;
    $result++;}

    $index++;
    }
    $Count = $result;
    return $indexArray;

}


/******************************************************************************
 * @procedure    FindifCurveEndsMeetIndex
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $CurveA1 : vector[]
 *   $CurveA2 : vector[]
 *   $TF : int
 *
 * @returns      int []
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] FindifCurveEndsMeetIndex(vector $CurveA1[], vector $CurveA2[], int $TF)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CurveMeetsTrue = 0;
    int $indexN = 0;
    int $indexN2 = 0;
    int $IndexEnds[];
    int $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    int $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveMeetsTrue = 0;
    $indexN = 0;
    $indexN2 = 0;

    while ($indexN < 2){

    $firstC = $CurveA1[$indexN];
    $SecondC = $CurveA2[0];
    $SecondCA = $CurveA2[1];

    $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);

    if ($NumberE == 3){
    if($indexN==0){
    $IndexEnds[0]=1; $IndexEnds[1]=0; $IndexEnds[2]=1; $IndexEnds[3]=0;

    }else{
    $IndexEnds[0]=0; $IndexEnds[1]=1; $IndexEnds[2]=1; $IndexEnds[3]=0;

    }
    $CurveMeetsTrue = 1;
    break; }

    if ($NumberE2 == 3){

    if($indexN==0){
    $IndexEnds[0]=1; $IndexEnds[1]=0; $IndexEnds[2]=0; $IndexEnds[3]=1;

    }else{

    $IndexEnds[0]=0; $IndexEnds[1]=1; $IndexEnds[2]=0; $IndexEnds[3]=1;}
    $CurveMeetsTrue = 1;
    break; }

    if ($indexN==1){$indexN1 = 1;}
    $indexN++;
    }

    $TF = $CurveMeetsTrue;
    return $IndexEnds;

}


/******************************************************************************
 * @procedure    IfCurvesTouchIndex
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $curveA : string
 *   $curveB : string
 *   $TFa : int
 *
 * @returns      int []
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IfCurvesTouchIndex(string $curveA, string $curveB, int $TFa)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $TF = 0;
    int $intIfTrue[] = FindifCurveEndsMeetIndex($CurveOne, $CurveTwo, $TF);
    vector $CurveOne[] = GetVectorArrayBetweenCurveEnds({$curveA});
    vector $CurveTwo[] = GetVectorArrayBetweenCurveEnds({$curveB});

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveOne = GetVectorArrayBetweenCurveEnds({$curveA});
    $CurveTwo = GetVectorArrayBetweenCurveEnds({$curveB});
    $TF = 0;
    $intIfTrue = FindifCurveEndsMeetIndex($CurveOne, $CurveTwo, $TF);
    $TFa = $TF;
    return $intIfTrue;

}


/******************************************************************************
 * @procedure    IfCurvesTouchIndexZ
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $curveA : string
 *   $curveB : string
 *   $TFa : int
 *
 * @returns      int []
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IfCurvesTouchIndexZ(string $curveA, string $curveB, int $TFa)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $TF = 0;
    int $intIfTrue[] = FindifCurveEndsMeetIndexZ($CurveOne, $CurveTwo, $TF);
    vector $CurveOne[] = GetVectorArrayBetweenCurveEnds({$curveA});
    vector $CurveTwo[] = GetVectorArrayBetweenCurveEnds({$curveB});

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveOne = GetVectorArrayBetweenCurveEnds({$curveA});
    $CurveTwo = GetVectorArrayBetweenCurveEnds({$curveB});
    $TF = 0;
    $intIfTrue = FindifCurveEndsMeetIndexZ($CurveOne, $CurveTwo, $TF);
    $TFa = $TF;
    return $intIfTrue;

}


/******************************************************************************
 * @procedure    FindifCurveEndsMeetIndexZ
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $CurveA1 : vector[]
 *   $CurveA2 : vector[]
 *   $TF : int
 *
 * @returns      int []
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] FindifCurveEndsMeetIndexZ(vector $CurveA1[], vector $CurveA2[], int $TF)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CurveMeetsTrue = 0;
    int $indexN = 0;
    int $indexN2 = 0;
    int $IndexEnds[];
    int $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    int $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveMeetsTrue = 0;
    $indexN = 0;
    $indexN2 = 0;

    while ($indexN < 2){

    $firstC = $CurveA1[$indexN];
    $SecondC = $CurveA2[0];
    $SecondCA = $CurveA2[1];

    $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);

    if ($NumberE == 3){
    if($indexN==0){
    $IndexEnds[0]=0; $IndexEnds[1]=0;

    }else{
    $IndexEnds[0]=1; $IndexEnds[1]=0;
    }
    $CurveMeetsTrue = 1;
    break; }

    if ($NumberE2 == 3){

    if($indexN==0){
    $IndexEnds[0]=0; $IndexEnds[1]=1;
    }else{

    $IndexEnds[0]=1; $IndexEnds[1]=1; }
    $CurveMeetsTrue = 1;
    break; }

    if ($indexN==1){$indexN1 = 1;}
    $indexN++;
    }

    $TF = $CurveMeetsTrue;
    return $IndexEnds;

}


/******************************************************************************
 * @procedure    GetVectorArrayCRVEnds
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $CurveItemZ : string[]
 *
 * @returns      vector[]
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] GetVectorArrayCRVEnds(string $CurveItemZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs;
    int $num;
    string $CurveSelection[];
    vector $CurveAB[];
    vector $eachCVposV;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    for ($CurveItem in $CurveItemZ) {
    $numCVs = `getAttr -size ($CurveItem +  ".controlPoints")`;
    $num = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem + ".cv[" +  $num + "]") ;
    for ($eachZA in $CurveSelection) {
    $eachCVposV = `pointPosition -w ($eachZA)`;
    $CurveAB[`size($CurveAB)`] = $eachCVposV;
    }
    }
    return $CurveAB;

}


/******************************************************************************
 * @procedure    LineIntersectCirTFZ
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $ObjsCirclesRad : float
 *   $CircPos : vector[]
 *   $PosA : vector
 *   $PosB : vector
 *
 * @returns      int
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int LineIntersectCirTFZ(float $ObjsCirclesRad, vector $CircPos[], vector $PosA, vector $PosB)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $ObjsCirclesE = `arclen`*2.0;
    float $ObjsCirclesEi = `arclen`;
    float $ObjsCirclesEii = `arclen`;
    float $Di = distance2Pts( $CircPos , $PointN);
    float $PointN[] = ClosestPoint2Line($VecLineDir, $PosA, $CircPos);
    float $DiffL = ($ObjsCirclesRad-$Di)*2.0;
    float $FloatDirXn[] = DirectionF( $Vec[2], $Vec[0]);
    float $PointNii[] = MultLenToDirAddToPoint($Di, DirectionF( $Vec[2], $PointN), $PointN);
    float $DistAddiR2 = $Di*2.0;
    float $HightD = sqrt (abs ((`pow $Di 2.0`) - (`pow $ObjsCirclesRad 2.0`)));
    float $PointNiii[] = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[1], $Vec[0]), $PointN);
    float $PointNiiiB[] = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[0], $Vec[1]), $PointN);
    vector $AVecArrayPos_MC[];
    vector $VecCamPos_A;
    vector $CircPos = $VecArrayPos_MC[1];
    vector $PosA = $VecCamPos_A;
    vector $PosB = $AVecArrayPos_MC[0];
    vector $VecLineDir = PositiveDirectionLine($PosA, $PosB);
    vector $Vec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $AVecArrayPos_MC = PointArrayT(`ls-sl`);


    LineIntersectCirTFZ(float $ObjsCirclesRad, vector $CircPos, vector $PosB){


    $AVecArrayPos_MC = PointArrayT(`ls-sl`);

    $VecCamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;

    $CircPos = $VecArrayPos_MC[1];
    $PosA = $VecCamPos_A;
    $PosB = $AVecArrayPos_MC[0];
    $ObjsCirclesE = `arclen`*2.0;


    $ObjsCirclesEi = `arclen`;
    $ObjsCirclesEii = `arclen`;
    // Result: 0.41585 //
    // Result: 14.251443 //

    // Result: 23.164589 //
    // Result: 0.191253 //

    $Di = distance2Pts( $CircPos , $PointN);

    $VecLineDir = PositiveDirectionLine($PosA, $PosB);
    //float $ObjsCirclesRad = `arclen`*2.0;
    // $ObjsCirclesRad = $ObjsCirclesRad/2.0;

    $PointN = ClosestPoint2Line($VecLineDir, $PosA, $CircPos);
    Loc $PointN;
    curve2points($PosB, $PointN);
    print  $ObjsCirclesRad;

    $Di = distance2Pts( $CircPos , $PointN);
    $DiffL = ($ObjsCirclesRad-$Di)*2.0;

    //$Di = $ObjsCirclesRad;

    $Vec[0] = $PosA;
    $Vec[1] = $PosB;
    $Vec[2] = $CircPos;


    $FloatDirXn = DirectionF( $Vec[2], $Vec[0]);
    $PointNii = MultLenToDirAddToPoint($Di, DirectionF( $Vec[2], $PointN), $PointN);
    Loc $PointNii;
    $DistAddiR2 = $Di*2.0;
    $HightD = sqrt (abs ((`pow $Di 2.0`) - (`pow $ObjsCirclesRad 2.0`)));
    $PointNiii = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[1], $Vec[0]), $PointN);
    Loc $PointNiii;

    $PointNiiiB = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[0], $Vec[1]), $PointN);
    Loc $PointNiiiB;
    curve2points($PointNiii,$PointNiiiB);



    if($Di<$eachObjsCirclesRad){
    $returnValue =1; break;}
    if($Di==$eachObjsCirclesRad){
    $returnValue =0;}
    if($Di>$eachObjsCirclesRad){
    $returnValue =-1;}
    $IndexI++;
    }

    return $returnValue;

}


/******************************************************************************
 * @procedure    RotMultLenPts
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Vecpt : vector
 *   $Direc : vector
 *   $DirNorm : vector
 *   $Length : float
 *   $Radian : float
 *
 * @returns      vector
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector RotMultLenPts(vector $Vecpt, vector $Direc, vector $DirNorm, float $Length, float $Radian)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $DirecAB = ((unit(`rot $Direc $DirNorm $Radian`))*$Length)+$Vecpt;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $DirecAB = ((unit(`rot $Direc $DirNorm $Radian`))*$Length)+$Vecpt;
    return $DirecAB;

}


/******************************************************************************
 * @procedure    logN
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $x : float
 *
 * @returns      float
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float logN(float $x)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $a;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $a = (`log (abs($x))`)*(`sign($x)`) ;
    return $a;

}


/******************************************************************************
 * @procedure    SteinerChain
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $RAa : float
 *   $RBb : float
 *
 * @returns      string []
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] SteinerChain(float $RAa, float $RBb)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $NumberCs = $number3;
    int $n = $number3;
    int $i;
    float $pi = 3.1415926535;
    float $Pi = 3.1415926535;
    float $RA;
    float $RB;
    float $R2 = $RA;
    float $R1 = $RB;
    float $DCircle = (($R2 - $R1)/2.0) + $R1;
    float $Rii = (($R2 - $R1)/2.0);
    float $SideA = $RB + $Rii;
    float $SideB = $Rii*2;
    float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    float $ArcangleC2 = $ArcangleC*2.0;
    float $Aii = (`asin ($RB/($RB + $Rii))`);
    float $number3 = 360.0/$ArcangleC2;
    float $len = $DCircle;
    float $r = $DCircle;
    float $angle = 360.0 / $n;
    float $x[] = createRegularPolygonX( $n, $r );
    float $y[] = createRegularPolygonY( $n, $r );
    float $z = 0.0;
    float $rotatsB[] = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($angle)) );
    float $a = $i * $angle;
    float $rotatsA[] = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($a)) );
    float $Templast[];
    string $circleA[];
    string $circleB[];
    string $circles[];
    string $circlesC[];
    string $LItem[] = `ls -sl`;
    vector $VCirPosX;
    vector $Normal = <<0.0, 1.0, 0.0>>;
    vector $VecPairA[];
    vector $EmptyVecA[];
    vector $DirectionStart = <<$matrixA[0][0], $matrixA[0][1], $matrixA[0][2] >>;
    vector $DirectionStartB = <<$rotatsB[0], $rotatsB[1], $rotatsB[2] >>;
    vector $VrotatsA[];
    vector $VrotatsCiH[];
    vector $VrotatsBiH[];
    vector $VrotatsCi[];
    vector $VrotatsBi[];
    vector $VrotatsAi[];
    vector $CirclePts = <<$rotatsA[0], $rotatsA[1], $rotatsA[2] >>;
    vector $DirLine = DirectionFN($CirclePts, $VCirPosX);
    vector $Vperp = crossProduct( $DirLine, $Normal, 0, 0 );
    vector $VperpN = crossProduct( $DirLine, ($Normal*-1.0), 0, 0 );
    vector $VperpA = ($Rii/2.0)* $VperpN*-1.0;
    vector $VperpC = ($Rii/2.0)*$DirLine;
    vector $VperpB = ( $Rii/2.0)*$Vperp*-1.0;
    vector $VperpD = (-1*$Rii/2.0)*$DirLine;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    //
    // float $RAa = 22.0;
    // float $RBb = 3.2;

    $pi = 3.1415926535;
    $Pi = 3.1415926535;
    if(!( $RAa==$RBb)){
    if( $RAa<$RBb){
    $RA = $RBb;
    $RB = $RAa;}else{ $RA = $RAa; $RB =  $RBb;}

    //float $RA = 22.0;
    //float $RB = 15.68;
    $circleA = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RA -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $circleB = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RB -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $R2 = $RA;
    $R1 = $RB;
    $DCircle = (($R2 - $R1)/2.0) + $R1 ;
    $Rii = (($R2 - $R1)/2.0);
    $SideA = $RB + $Rii;
    $SideB = $Rii*2;
    //GOT it for SURE
    //HightsOfIsoscelesTriangle($SideA, $SideB, $SideA)
    $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    $ArcangleC2 = $ArcangleC*2.0;
    $Aii = (`asin ($RB/($RB + $Rii))`);
    $number3 = 360.0/$ArcangleC2;

    ////////////////####
    ///////////////###
    $NumberCs = $number3;

    $n = $number3;
    $len = $DCircle;
    $r = $DCircle;
    $angle = 360.0 / $n ;
    print $angle;

    $x = createRegularPolygonX( $n, $r ) ;
    $y = createRegularPolygonY( $n, $r ) ;

    // create the n-sided polygon.
    $z = 0.0 ;




    $LItem = `ls -sl`;
    $VCirPosX = `xform -q -ws -t $LItem[0]`;


    matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;

    $Normal = <<0.0, 1.0, 0.0>>;


    $VecPairA[0]= <<0.0, 1.0, 0.0>>;
    $VecPairA[1]= $VecPairA[0]*2;

    $matrixA = TwoPointMatrixPlusAxisWorld($VecPairA, $EmptyVecA, 1);
    $matrixA  = TwoPointMatrixB($VecPairA);
    $DirectionStart = <<$matrixA[0][0], $matrixA[0][1], $matrixA[0][2] >>;
    $angle = 360.0 / ($n*2) ;
    $rotatsB = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($angle)) );
    $DirectionStartB = <<$rotatsB[0], $rotatsB[1], $rotatsB[2] >>;
    $DirectionStartB = `unit($DirectionStartB)`;
    Loc $DirectionStartB;

    //RotMultLenToDirAddToPoint(float $PosA[], float $PosB[], float $Length, float $DirNormAx[], float $Radian)
    // float $rotatsA[] = RotDirToPoint($DirectionStart, $VCirPosX,$RA, $Normal, $a );
    $angle = 360.0 / $n ;




    for( $i = 0 ; $i < ($n) ; $i++ ) {
    $a = $i * $angle ;
    $rotatsA = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($a)) );
    Loc $rotatsA;

    }


    for( $i = 0 ; $i < ($n) ; $i++ ) {
    $a = $i * $angle ;
    $rotatsA = RotDirToPoint($VCirPosX,$DirectionStart, $RB, $Normal, (deg_to_rad($a)) );
    Loc $rotatsA;

    }


    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < ($n) ; $i++ ) {
    $a = $i * $angle ;
    $rotatsA = RotDirToPoint($VCirPosX,$DirectionStartB, $r, $Normal, (deg_to_rad($a)) );
    $VrotatsA[$i] =   FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $r, $Normal, (deg_to_rad($a)) ));

    Loc $rotatsA;

    }
    //////////////////////////////////


    for( $i = 0 ; $i < $n ; $i++ ) {

    $a = $i * $angle ;
    $rotatsA = RotDirToPoint($VCirPosX,$DirectionStart, $r, $Normal, (deg_to_rad($a)) );

    $VrotatsCiH[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $RA, $Normal, (deg_to_rad(($a))) ));
    $VrotatsBiH[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $RB, $Normal, (deg_to_rad(($a))) ));
    Loc $VrotatsCiH[$i];

    $VrotatsCi[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($a)) ));
    $VrotatsBi[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $r, $Normal, (deg_to_rad($a)) ));

    $VrotatsAi[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStart, $RB, $Normal, (deg_to_rad($a)) ));


    $CirclePts = <<$rotatsA[0], $rotatsA[1], $rotatsA[2] >>;

    $DirLine = DirectionFN($CirclePts, $VCirPosX);
    $Vperp = crossProduct( $DirLine, $Normal, 0, 0 );
    $Vperp = `unit($Vperp + $DirLine)`;
    $VperpN = crossProduct( $DirLine, ($Normal*-1.0), 0, 0 );
    $VperpN = `unit( ($VperpN) + ($DirLine))`;

    $VperpA = ($Rii/2.0)* $VperpN*-1.0;
    $VperpA = $CirclePts+$VperpA;
    Loc $VperpA;


    curve2points($VrotatsBi[$i],$VrotatsCiH[$i]);

    if($i>0){

    curve2points($VrotatsBi[$i-1],$VperpA);


    }
    if($i==0){
    $Templast= $VperpA;}

    $VperpC = ($Rii/2.0)*$DirLine;
    $VperpC = $CirclePts+$VperpC;
    Loc $VperpC;
    curve2points($VrotatsCi[$i],$VperpC);
    /////////////

    $VperpB = ( $Rii/2.0)*$Vperp*-1.0;
    $VperpB = $CirclePts+$VperpB;
    Loc $VperpB;
    curve2points($VrotatsBi[$i],$VperpB);

    /////////////////////

    $VperpD = (-1*$Rii/2.0)*$DirLine;
    $VperpD = $CirclePts+$VperpD;
    Loc $VperpD;

    curve2points($VrotatsAi[$i],$VperpD);
    curve2points($VrotatsBi[$i],$VrotatsBiH[$i]);

    if($i==($n-1)){
    curve2points($VrotatsBi[$i],$Templast);
    }

    $circlesC = `circle -c $rotatsA[0] $rotatsA[1] $rotatsA[2] -nr 0 0 1 -sw 360 -r ($Rii/2.0) -d 3 -ut 0 -tol 0.001 -s 16 -ch 1`;
    $circles[$i] = $circlesC[0];
    makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $circles[0];
    xform -cp $circles[$i];
    }



    //$circles[`size($circles)`] = $circleA[0];
    //$circles[`size($circles)`] = $circleB[0];
    select -r $circleA $circleB $circles ;
    //select -r $circles ;
    return $circles;
    }

}


/******************************************************************************
 * @procedure    createRegularPolygonY
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $n : int
 *   $r : float
 *
 * @returns      float[]
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] createRegularPolygonY(int $n, float $r)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    float $x[];
    float $angle = 360.0 / $n;
    float $a = $i * $angle;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * cos(deg_to_rad($a)) ;
    }
    return $x ;

}


/******************************************************************************
 * @procedure    createRegularPolygonX
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $n : int
 *   $r : float
 *
 * @returns      float[]
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] createRegularPolygonX(int $n, float $r)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    float $x[];
    float $angle = 360.0 / $n;
    float $a = $i * $angle;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * sin(deg_to_rad($a)) ;
    }
    return $x ;

}


/******************************************************************************
 * @procedure    InsidePolygon
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $c : vector[]
 *   $VLocPos_A : vector
 *
 * @returns      int
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int InsidePolygon(vector $c[], vector $VLocPos_A)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $SizeV = size($c);
    float $x = VecCom($VLocPos_A, 0);
    float $y = VecCom($VLocPos_A, 1);
    float $PI = 3.1415926535;
    float $angle = 0;
    float $Distance = 0;
    float $DistanceMM = 0;
    float $Arc = 0;
    float $p1x = 0, $p1y = 0, $p2x = 0, $p2y = 0;
    float $triarea = 0;
    float $tri_areaM = 0;
    float $aP;
    float $bP;
    float $cP;
    float $N;
    float $TWO_PI = 3.1415926535;
    float $AverageVecCurve[] = AverageVectorPoint($Positions);
    float $DDistPt_toC = distance2Pts($VCrvPos_A, $VLocPos_A);
    float $DDist = $Distance/float($TotalS);
    float $DDistX = $Distance+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    float $DDistMM = $DistanceMM+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    float $MathA = $DDistMM/$DDist;
    float $MathB = $DDistPt_toC/$MathA;
    vector $VCrvPos_A;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $VCrvPos_A =  FloatToVec(AverageVectorPoint($c));

    $x = VecCom($VLocPos_A, 0);
    $y = VecCom($VLocPos_A, 1);

    // Convex is just a collection of points for the polygon
    // just replace that code in the for-loop to loop through the points in your polygon

    $PI = 3.1415926535;
    $angle = 0;
    $Distance = 0;
    $DistanceMM = 0;
    $Arc = 0;
    $p1x = 0, $p1y = 0, $p2x = 0, $p2y = 0;
    $SizeV = size($c);
    $TotalS = $SizeV;
    $triarea = 0;
    $tri_areaM = 0;
    $countS =1;

    for ($i=0;$i< $SizeV; $i++) {

    $indexState = $i;
    $indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
    $indexRight = fmod(($indexState + $countS),$TotalS);
    $DistA = distance2Pts($c[$i], $c[$indexLeft]);
    $DistB = distance2Pts($c[$i], $c[$indexRight]);
    if($DistA<$DistB){
    $nearestIndex = $indexLeft;
    }else{$NearIndex = $indexRight;}
    /*
    $p1x = ( (VecCom($c[$i], 0)) - $x ); // point A X - X
    $p1y = ( (VecCom($c[$i], 1)) - $y ); // point A Y - Y
    $p2x = ( (VecCom($c[$NearIndex], 0)) - $x ); // point A's nearest neighbor X - X
    $p2y = ( (VecCom($c[$NearIndex], 1)) - $y ); // point A's nearest neighbor Y - Y
    */
    $aP = distance2Pts($c[$i], $c[$indexRight]);
    $bP = distance2Pts($VLocPos_A, $c[$indexRight]);
    $cP = distance2Pts($c[$i], $VLocPos_A);
    $triarea += 0.25* (sqrt ( ($aP+$bP+$cP)  * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP)  ));
    $aPm = distance2Pts($c[$i], $c[$indexRight]);
    $bPm = distance2Pts($VCrvPos_A, $c[$indexRight]);
    $cPm = distance2Pts($c[$i], $VCrvPos_A);
    $tri_areaM += 0.25* (sqrt ( ($aPm+$bPm+$cPm)  * ($bPm+$cPm-$aPm) * ($cPm+$aPm-$bPm) * ($aPm+$bPm-$cPm)  ));
    $DistanceMM += distance2Pts($c[$i], $VCrvPos_A);
    $Distance += distance2Pts($c[$i], $VLocPos_A);
    //$angle += Angle2D($p1x,$p1y,$p2x,$p2y);
    $Arc += distance2Pts($c[$i], $c[$indexRight]);
    }

    //print ("Tri_area: "+$triarea + "\n");
    //print ("Tri_areaM: "+$tri_areaM+ "\n");
    /*
    if (abs($angle) < $PI){
    print (" INSIDE " + "\n");
    }else{ print (" OUTSIDE! " + "\n");}
    */

    // if (equivalentTol($triarea, $tri_areaM,  0.00001) ==1){
    //print ("Tri_area INSIDE " + "\n");
    //}else{ print ("Tri_area OUTSIDE! " + "\n");}

    //   if (abs($angle) < $PI){//
    if (equivalentTol($triarea, $tri_areaM,  0.00001) ==1){
    return 1;
    }else{
    return 0;}

    }


    proc float VecCom(vector $Vai, int $XYZ){
    $x = $Vai.x;
    $y = $Vai.y;
    $z = $Vai.z;
    if($XYZ==0){$N=$x;} if($XYZ==1){$N=$y;} if($XYZ==2){$N=$z;}
    return $N;
    }


    proc float Angle2D(float $x1, float $y1, float $x2, float $y2)
    {
    $PI = 3.1415926535;
    $TWO_PI = 3.1415926535;


    $theta1 = atan2($y1,$x1);
    $theta2 = atan2($y2,$x2);
    $dtheta = $theta2 - $theta1;

    while ($dtheta > $PI)
    $dtheta -= $TWO_PI;
    while ($dtheta < -$PI)
    $dtheta += $TWO_PI;


    return $dtheta;
    }

    /*


    $Arc = `arclen $CurveItemAX[0]`;
    $AverageVecCurve = AverageVectorPoint($Positions);

    //////////

    $DDistPt_toC = distance2Pts($VCrvPos_A, $VLocPos_A);
    $DDist = $Distance/float($TotalS);
    print ("Dist_each/SIZE: "+$DDist + "\n");
    //Dist_each/SIZE: 18.31929743
    print (" dist_to_M: "+ $DDistPt_toC+"  dist_each: "+$DDist + "\n");
    $DDistX = $Distance+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    $DDistMM = $DistanceMM+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    $DDistMM = $DistanceMM/float($TotalS);
    $MathA = $DDistMM/$DDist;
    $MathB = $DDistPt_toC/$MathA;
    print $Arc;
    outside
    dist_to_M: 8.210088295  dist_each: 10.678618
    dist_to_M: 10.98501803  dist_each: 19.20895454
    inside
    dist_to_M: 4.491177258  dist_each: 10.90761121
    dist_to_M: 2.733438324  dist_each: 15.81548968
    print (" distance to crv middle "+ $DDistPt_toC+" dist to each crv div "+$DDist + "\n");
    //float $Xpi = $PI/$angle;
    //float $XTpi = $Xpi*$angle;
    print ($angle + "\n");
    */

}


/******************************************************************************
 * @procedure    VecCom
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Vai : vector
 *   $XYZ : int
 *
 * @returns      float
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float VecCom(vector $Vai, int $XYZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $N;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $x = $Vai.x;
    $y = $Vai.y;
    $z = $Vai.z;
    if($XYZ==0){$N=$x;} if($XYZ==1){$N=$y;} if($XYZ==2){$N=$z;}
    return $N;

}


/******************************************************************************
 * @procedure    Angle2D
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $x1 : float
 *   $y1 : float
 *   $x2 : float
 *   $y2 : float
 *
 * @returns      float
 * @source       fixedITColockwise (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float Angle2D(float $x1, float $y1, float $x2, float $y2)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $PI = 3.1415926535;
    float $TWO_PI = 3.1415926535;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PI = 3.1415926535;
    $TWO_PI = 3.1415926535;


    $theta1 = atan2($y1,$x1);
    $theta2 = atan2($y2,$x2);
    $dtheta = $theta2 - $theta1;

    while ($dtheta > $PI)
    $dtheta -= $TWO_PI;
    while ($dtheta < -$PI)
    $dtheta += $TWO_PI;


    return $dtheta;

}


/******************************************************************************
 * @procedure    getFlyThroughCamera
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      string
 * @source       flyThroughContextSetup (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc string getFlyThroughCamera()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $camera = "";
    string $panel = `getPanel -underPointer`;
    string $type = `getPanel -typeOf $panel`;
    string $editors[] = `lsUI -editors -type scriptedPanel`;
    string $parents[] = `listRelatives -parent $camera`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $camera = "";
    $panel = `getPanel -underPointer`;
    if ($panel != "") {
    //
    //	Make sure the panel is a model view and contains a
    //	perspective camera.
    //
    $type = `getPanel -typeOf $panel`;
    if ($type == "modelPanel" ) {
    $camera = `modelPanel -query -camera $panel`;
    } else {
    // Look for stereo panels
    $editors = `lsUI -editors -type scriptedPanel`;
    for ($i=0 ; $i<size($editors) ; $i++) {
    if ($panel == `editor -query -panel $editors[$i]`) {
    $camera = `modelEditor -q -camera $editors[$i]`;
    break;
    }
    }
    }
    }

    if ($camera != "") {
    if (`camera -query -orthographic $camera`) {
    warning ( (uiRes("m_flyThroughContextSetup.kToolOnlyPerspective")) );
    $camera = "";
    } else if (! `objectType -isa transform $camera`) {
    // Make sure we point to the transform
    $parents = `listRelatives -parent $camera`;
    $camera = $parents[0];
    }
    }
    return $camera;

}


/******************************************************************************
 * @procedure    itemComponentInfo
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $item : string
 *   $info : string[]
 *
 * @returns      int
 * @source       itemComponentInfo (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
global proc int itemComponentInfo(string $item, string $info[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numTokens = `tokenize $item ".[]" $buffer`;
    string $buffer[];
    string $t = $buffer[1];
    string $fmt = (uiRes("m_itemComponentInfo.kUnknownToken"));

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numTokens = `tokenize $item ".[]" $buffer`;
    $info[0] = $buffer[0];
    if( $numTokens == 1 ){
    return( 6 ); // surface
    } else if( $numTokens == 3 ){
    $info[1] = $buffer[2];
    $t = $buffer[1];
    if( $t == "vtx" ){
    return( 2 ); // point
    }else if( $t == "e" ){
    return( 3 ); // edge
    }else if( $t == "f" ){
    return( 4 ); // face
    }else if( $t == "pt" ){
    return( 7 ); // particle
    }else{
    $fmt = (uiRes("m_itemComponentInfo.kUnknownToken"));
    warning( `format -s $t $fmt` );
    return( 0 );
    }
    } else {
    $fmt = (uiRes("m_itemComponentInfo.kBadNumTokens"));
    warning( `format -s $numTokens $fmt` );
    return( 0 );
    }

}


/******************************************************************************
 * @procedure    GetDistancePointPositionFLOAT
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $objectFirst : string
 *   $objectSecond : string
 *
 * @returns      float
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc float GetDistancePointPositionFLOAT(string $objectFirst, string $objectSecond)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $pointAZ1[];
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pointAZ1 = `pointPosition -w ($objectFirst)`;
    $pointAZ2 = `pointPosition -w ($objectSecond)`;
    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    ConvertPolyFacesIntoNurbSurface
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      string
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string ConvertPolyFacesIntoNurbSurface()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sizeBorderEdges = size($SelectedPolyBorderEdges) -1;
    int $Xi = 1;
    int $ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
    int $iix = 0;
    int $iiV = 0;
    float $valuesP[];
    float $values[];
    string $PolyFaceslist[] = `ls -sl`;
    string $NewPolyFaces[] = ` polyChipOff -ch 1 -kft 1 -dup 0 -off 0 $PolyFaceslist`;
    string $HistoryConnections[] = ` listHistory -future true -pruneDagObjects false $NewPolyFaces`;
    string $polySep[] = `polySeparate -rs 1 -ch 0 $HistoryConnections[1]`;
    string $PolyFaces = ( $PolygonNew[0] +".f[*]");
    string $AllPolyFaces[] = `ls -fl $PolyFaces`;
    string $AllPolyFaces2[] = `ls $PolyFaces`;
    string $diffEdgeVertz[] = GetEdgeVertex($PolygonNew);
    string $ReturnObjects = "";
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorCX`;
    string $DiffPolyBorderEdges[] = GetdiffEdgesOfBorder($PolygonNew);
    string $SelectedPolyBorderEdges[] = PolyBorderEdges($PolygonNew);
    string $NearEdges[] = GetNearEdges($EdgeVertzStart);
    string $diffA[] = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdges);
    string $NearEdgesA[] = GetNearEdges($NearEdgesOne);
    string $diffB[] = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdgesA);
    string $EdgesVertex[] = ls("-fl",polyListComponentConversion("-toVertex",$diffB[0]));
    string $bufferList[];
    string $EdgeCurves[];
    string $EdgesVertexEach[];
    string $ListA[];
    string $EdgesVertexEachOrder[] = VertLoopEdgeLoop($ListA);
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $PolyFaceslist = `ls -sl`;
    $NewPolyFaces = ` polyChipOff -ch 1 -kft 1 -dup 0 -off 0 $PolyFaceslist`;
    print $NewPolyFaces;
    $HistoryConnections = ` listHistory -future true -pruneDagObjects false $NewPolyFaces`;
    $polySep = `polySeparate -rs 1 -ch 0 $HistoryConnections[1]`;
    select -r $polySep[1];
    string $PolygonNew[0] = {$polySep[1]};
    parent -w $PolygonNew;
    select -r $PolygonNew;
    print $PolygonNew ;
    $PolyFaces = ( $PolygonNew[0] +".f[*]");
    $AllPolyFaces = `ls -fl $PolyFaces`;
    $AllPolyFaces2 = `ls $PolyFaces`;

    $diffEdgeVertz = GetEdgeVertex($PolygonNew);
    $ReturnObjects = "";

    for ($eachP in $diffEdgeVertz){
    $valuesP = `pointPosition -w ($eachP)`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorCX`;
    move -ws $valuesP[0] $valuesP[1] $valuesP[2] $spaceLocatorB;
    $ReturnObjects += $spaceLocatorB[0]+" ";
    }
    $DiffPolyBorderEdges = GetdiffEdgesOfBorder($PolygonNew);
    $SelectedPolyBorderEdges = PolyBorderEdges($PolygonNew);

    $sizeBorderEdges = size($SelectedPolyBorderEdges) -1;
    string $EdgeVertzStart[0] = {$diffEdgeVertz[0]};
    stringArrayRemoveAtIndex(0, $diffEdgeVertz);
    $NearEdges = GetNearEdges($EdgeVertzStart);
    string $NearEdgesOne[0] = {$NearEdges[0]};
    string $NearEdgesSecond[0] = {$NearEdges[1]};
    appendStringArray($DiffPolyBorderEdges, $NearEdgesSecond, 1);
    $diffA = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdges);
    string $orderedArray[0] = {$NearEdgesOne[0]};
    $Xi = 1;
    while ($Xi < $sizeBorderEdges){
    $Xi++;
    $NearEdgesA = GetNearEdges($NearEdgesOne);
    select -r $NearEdgesA;
    appendStringArray($DiffPolyBorderEdges, $NearEdgesOne, 1);
    $diffB = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdgesA);
    select -r $diffB;
    $EdgesVertex = ls("-fl",polyListComponentConversion("-toVertex",$diffB[0]));
    $ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
    appendStringArray($orderedArray, $diffB, 1);
    $NearEdgesOne = $diffB;
    }
    appendStringArray($orderedArray, $NearEdgesSecond, 1);

    $EdgeLists = "";

    $iix = 0;
    $iiV = 0;
    for ($each in $orderedArray){
    string $oneItem[0] = {$each};
    $EdgesVertex = ls("-fl",polyListComponentConversion("-toVertex", $oneItem[0]));
    playButtonStepForward;
    select -r $EdgesVertex;
    playButtonStepForward;
    if ( $iix > 0){
    $ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
    if ( $ifTrue == 1){ $iiV++; if ( $iiV == 1){
    $EdgeLists += " "+$oneItem[0]+" "+"VERT";} if ( $iiV == 2){ $EdgeLists += " "+$oneItem[0]; $iiV = 0; } }
    if ( $ifTrue == 0){ $EdgeLists += " "+$oneItem[0]; }
    }
    if ( $iix == 0){  $EdgeLists += $oneItem[0]; }
    $iix++;
    }

    $numTokens = `tokenize $EdgeLists "VERT" $bufferList`;
    clear $EdgeCurves;
    for($eachBuffer in $bufferList){
    $ListA = `stringToStringArray $eachBuffer " "`;
    //string $EdgesVertexEach[] = ls("-fl",polyListComponentConversion("-toVertex", $ListA));
    $EdgesVertexEachOrder = VertLoopEdgeLoop($ListA);
    $curve = "curve -d 1";
    for($eachVert in $EdgesVertexEachOrder){ playButtonStepForward;
    select -r $eachVert; playButtonStepForward;
    $values = `pointPosition -w ($eachVert)`;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    $Newcurvez = `eval($curve)`;
    clear $Newcurve;
    $Newcurve = {$Newcurvez};
    appendStringArray($EdgeCurves, $Newcurve, 1);

    }

    string $NurbSurfaceFromPolyFaces[0] = {`alternativeBoundry`};
    delete -ch $NurbSurfaceFromPolyFaces;
    delete -ch $EdgeCurves;
    delete $PolygonNew;
    $ReturnObjects += $NurbSurfaceFromPolyFaces[0];
    select -r $EdgeCurves;
    return $ReturnObjects;

}


/******************************************************************************
 * @procedure    GetNearEdges
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $edgeArray : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] GetNearEdges(string $edgeArray[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $PolyVertexFromEdges[] = ls("-fl",polyListComponentConversion("-toVertex",$edgeArray[0]));
    string $PolyEdgesFromVertex[] = ls("-fl",polyListComponentConversion("-toEdge", $PolyVertexFromEdges));

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyVertexFromEdges = ls("-fl",polyListComponentConversion("-toVertex",$edgeArray[0]));
    $PolyEdgesFromVertex = ls("-fl",polyListComponentConversion("-toEdge", $PolyVertexFromEdges));
    return $PolyEdgesFromVertex;

}


/******************************************************************************
 * @procedure    alternativeBoundry
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      string
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string alternativeBoundry()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $hist = `constructionHistory -q -tgl`;
    int $n = size($curves);
    int $i;
    string $curves[] = `filterExpand -ex true -sm $gSelectNurbsCurvesBit -sm $gSelectIsoparmsBit -sm $gSelectCurvesOnSurfacesBit -sm $gSelectSurfaceEdgeBit`;
    string $surface = "";
    string $cmd = "boundary -or 0 -ep 0 -rn 1 -po 0 -ept 0.001 -ch  " + $hist + " ";
    string $now[] = `rebuildCurve -ch 0 -rpo 1 -kcp on -d 1 -rt 0 $curves[$i]`;
    string $res[] = eval($cmd);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $hist = `constructionHistory -q -tgl`;
    global int $gSelectNurbsCurvesBit;
    global int $gSelectIsoparmsBit;
    global int $gSelectCurvesOnSurfacesBit;
    global int $gSelectSurfaceEdgeBit;
    $curves = `filterExpand -ex true -sm $gSelectNurbsCurvesBit -sm $gSelectIsoparmsBit -sm $gSelectCurvesOnSurfacesBit -sm $gSelectSurfaceEdgeBit`;
    $surface = "";
    $n = size($curves);
    if( $n < 4 ) return $surface;
    $cmd = "boundary -or 0 -ep 0 -rn 1 -po 0 -ept 0.001 -ch  " + $hist + " ";
    // Rebuild them into linears (keep cvs):
    for( $i=0; $i<$n; $i+=1 ) {
    $now = `rebuildCurve -ch 0 -rpo 1 -kcp on -d 1 -rt 0 $curves[$i]`;
    $curves[$i] = $now[0];
    $cmd = $cmd + $curves[$i] + " ";
    }

    // Convert back into cubic:
    $res = eval($cmd);
    if( size($res) > 0 ) {
    $surface = $res[0];
    rebuildSurface -ch $hist -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kc 0 -su 0 -du 3 -sv 0 -dv 3 -tol 0.001 -fr 0  -dir 2 $surface;
    }

    if( !$hist ) {
    for( $i=0; $i<$n; $i+=1 ) {
    delete $curves[$i];
    }
    }

    select -r $curves;
    return $surface;

}


/******************************************************************************
 * @procedure    VertLoopEdgeLoop
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $edgeZ : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] VertLoopEdgeLoop(string $edgeZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $verts[];
    string $v0[] = `polyListComponentConversion -tv $edgeZ[0]`;
    string $v1[] = `polyListComponentConversion -tv $edgeZ[1]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $v0 = `polyListComponentConversion -tv $edgeZ[0]`;
    $v0=`ls -fl $v0`;
    $v1 = `polyListComponentConversion -tv $edgeZ[1]`;
    $v1=`ls -fl $v1`;
    $v0=`stringArrayRemove $v1 $v0`;
    $verts[0]=$v0[0];

    for($i=0;$i<size($edgeZ);$i++)
    {
    $v0 = `polyListComponentConversion -tv $edgeZ[$i]`;

    $v0=`ls -fl $v0`;
    $v0=`stringArrayRemove $verts $v0`;
    $verts[size($verts)]=$v0[0];
    }

    return	$verts;

}


/******************************************************************************
 * @procedure    FindifArraysContain
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $FirstList : string[]
 *   $array2 : string[]
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc int FindifArraysContain(string $FirstList[], string $array2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $found;
    int $Trigger;
    string $oneItemz = $each;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ($each in $FirstList){
    $oneItemz = $each;
    $found = stringArrayContains($oneItemz, $array2);
    if ( $found == 1 ){ $Trigger = 1; break; }
    }
    return $Trigger;

}


/******************************************************************************
 * @procedure    IfIntersect
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $ArrayA : string[]
 *   $ArrayB : string[]
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc int IfIntersect(string $ArrayA[], string $ArrayB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sizeofItems = size($findIntersection);
    string $myIntersector = `stringArrayIntersector`;
    string $findIntersection[] = `stringArrayIntersector -query $myIntersector`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $myIntersector = `stringArrayIntersector`;
    stringArrayIntersector -edit -intersect $ArrayA $myIntersector;
    stringArrayIntersector -edit -intersect $ArrayB $myIntersector;
    $findIntersection = `stringArrayIntersector -query $myIntersector`;
    stringArrayIntersector -edit -reset $myIntersector;
    $sizeofItems = size($findIntersection);
    return $sizeofItems;

}


/******************************************************************************
 * @procedure    PolyBorderEdges
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $polyZ : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] PolyBorderEdges(string $polyZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $PolyFaceZ = ( $polyZ[0] +".f[*]");
    string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
    string $PolyEdgesFromFaceZ[] = ls("-fl",polyListComponentConversion("-toEdge",$AllPolyFaceZ));
    string $SelectedPolyBorderEdgeZ[] = `ls -sl -fl`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyFaceZ = ( $polyZ[0] +".f[*]");
    $AllPolyFaceZ = `ls -fl $PolyFaceZ`;
    $PolyEdgesFromFaceZ = ls("-fl",polyListComponentConversion("-toEdge",$AllPolyFaceZ));
    select -r $PolyEdgesFromFaceZ;
    polyConvertToShellBorder;
    $SelectedPolyBorderEdgeZ = `ls -sl -fl`;
    return $SelectedPolyBorderEdgeZ;

}


/******************************************************************************
 * @procedure    GetdiffEdgesOfBorder
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $poly : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] GetdiffEdgesOfBorder(string $poly[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $PolyFaceZ = ( $poly[0] +".f[*]");
    string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
    string $PolyEdgesFromFaceZ[] = ls("-fl",polyListComponentConversion("-toEdge",$AllPolyFaceZ));
    string $SelectedPolyBorderEdgeZ[] = `ls -sl -fl`;
    string $diffEdgeZ[] = stringArrayRemoveExact($SelectedPolyBorderEdgeZ, $PolyEdgesFromFaceZ);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyFaceZ = ( $poly[0] +".f[*]");
    $AllPolyFaceZ = `ls -fl $PolyFaceZ`;
    $PolyEdgesFromFaceZ = ls("-fl",polyListComponentConversion("-toEdge",$AllPolyFaceZ));
    select -r $PolyEdgesFromFaceZ;
    polyConvertToShellBorder;
    $SelectedPolyBorderEdgeZ = `ls -sl -fl`;
    $diffEdgeZ = stringArrayRemoveExact($SelectedPolyBorderEdgeZ, $PolyEdgesFromFaceZ);
    select -r $diffEdgeZ;
    return $diffEdgeZ;

}


/******************************************************************************
 * @procedure    GetEdgeVertex
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $poly : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] GetEdgeVertex(string $poly[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $PolyFaceZ = ( $poly[0] +".f[*]");
    string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
    string $EdgePolyFaceZ[] = `ls -sl -fl`;
    string $PolyEdgelistA[] = ls("-fl",polyListComponentConversion("-border", "-toVertex", "-fromFace", $EdgePolyFaceZ));
    string $PolyEdgelistB[] = ls("-fl",polyListComponentConversion( "-toVertex", "-fromFace", $EdgePolyFaceZ));
    string $diffEdgeZ[] = stringArrayRemoveExact($PolyEdgelistA, $PolyEdgelistB);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PolyFaceZ = ( $poly[0] +".f[*]");
    $AllPolyFaceZ = `ls -fl $PolyFaceZ`;
    select -r $AllPolyFaceZ;
    polyConvertToShellBorder;
    ConvertSelectionToContainedEdges;
    ConvertSelectionToContainedFaces;
    $EdgePolyFaceZ = `ls -sl -fl`;
    $PolyEdgelistA = ls("-fl",polyListComponentConversion("-border", "-toVertex", "-fromFace", $EdgePolyFaceZ));
    select -r $PolyEdgelistA;
    $PolyEdgelistB = ls("-fl",polyListComponentConversion( "-toVertex", "-fromFace", $EdgePolyFaceZ));
    select -r $PolyEdgelistB;
    $diffEdgeZ = stringArrayRemoveExact($PolyEdgelistA, $PolyEdgelistB);
    select -r $diffEdgeZ;
    return $diffEdgeZ;

}


/******************************************************************************
 * @procedure    stringArrayGmatchIndex
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $itemA : string[]
 *   $list : string[]
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc int stringArrayGmatchIndex(string $itemA[], string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    int $ResultIndex = 0;
    int $Index = 0;
    string $item = $itemA[0];
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $item = $itemA[0];
    $result = false;
    $ResultIndex = 0;
    $Index = 0;
    for ($EachlistItem in $list) {
    if ( $EachlistItem == $item ){
    $result = true; $ResultIndex = $Index;
    break;	}
    $Index++;
    }
    return $ResultIndex;

}


/******************************************************************************
 * @procedure    mm_curveFromEdges
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] mm_curveFromEdges()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $len = size($edges);
    int $orderedEdgesIDs[];
    int $currentEdgePos = $firstHeadPos;
    int $jump = 0, $counter = 0, $max = size($edges)*size($edges);
    int $forstOrLast = 0, $orderedVerts[], $oeLen = size($orderedEdgesIDs);
    int $ovLen = size($orderedVerts);
    float $vertPos[] = `xform -a -ws -q -t ($sel[0]+".vtx["+$orderedVerts[0]+"]")`;
    string $sel[] = `selectedNodes`;
    string $edges[] = `filterExpand -sm 32`;
    string $infoVerts[];
    string $ret[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $sel = `selectedNodes`;
    if(size($sel)!=1)
    error "Select some contiguous edges, on one poly object";
    $edges = `filterExpand -sm 32`;
    $len = size($edges);
    if(!$len)
    error "Select some contiguous edges";
    for($i=0; $i<$len; $i++)
    {
    $infoVerts = `polyInfo -ev $edges[$i]`;
    $infoVerts = `stringToStringArray $infoVerts[0] " "`;
    $fVerts[$i] = $infoVerts[2];
    $lVerts[$i] = $infoVerts[3];
    }
    for($i=0; $i<$len; $i++)
    {
    $sticks[$i] = 0;
    for($j=0; $j<$len; $j++)
    {
    if(($j!=$i))
    {
    if(($fVerts[$i]==$fVerts[$j]) || ($lVerts[$i]==$lVerts[$j]) || ($fVerts[$i]==$lVerts[$j]) || ($lVerts[$i]==$fVerts[$j]))
    $sticks[$i]+=1;
    }
    }
    if(($sticks[$i]<1) || ($sticks[$i]>2))
    error "Select some contiguous edges";
    }
    $firstHeadPos = 0;
    $headsNr = 0;
    for($i=0; $i<$len; $i++)
    {
    if($sticks[$i] == 1)
    {
    $headsNr++;
    if($headsNr>2)
    error "Select some contiguous edges";
    $firstHeadPos = $i;
    }
    }
    $orderedEdgesIDs[0] = $firstHeadPos;
    $currentEdgePos = $firstHeadPos;
    $jump = 0, $counter = 0, $max = size($edges)*size($edges);
    while(size($orderedEdgesIDs)<$len)
    {
    for($i=0; $i<$len; $i++)
    {
    for($j=0; $j<size($orderedEdgesIDs); $j++)
    if($orderedEdgesIDs[$j] == $i)
    {
    $jump = 1;
    break;
    }
    if(!$jump)
    {
    if(($fVerts[$i]==$fVerts[$currentEdgePos]) || ($lVerts[$i]==$lVerts[$currentEdgePos]) || ($fVerts[$i]==$lVerts[$currentEdgePos]) || ($lVerts[$i]==$fVerts[$currentEdgePos]))
    {
    $currentEdgePos = $i;
    $orderedEdgesIDs[size($orderedEdgesIDs)] = $i;
    }
    }
    $jump = 0;
    $counter++;
    }
    if($counter>=$max)
    break;
    }
    $forstOrLast = 0, $orderedVerts[], $oeLen = size($orderedEdgesIDs);

    if(($fVerts[$orderedEdgesIDs[0]] == $fVerts[$orderedEdgesIDs[1]]) || ($fVerts[$orderedEdgesIDs[0]] == $lVerts[$orderedEdgesIDs[1]]))
    $orderedVerts[0] = $lVerts[$orderedEdgesIDs[0]];
    else if(($lVerts[$orderedEdgesIDs[0]] == $fVerts[$orderedEdgesIDs[1]]) || ($lVerts[$orderedEdgesIDs[0]] == $lVerts[$orderedEdgesIDs[1]]))
    $orderedVerts[0] = $fVerts[$orderedEdgesIDs[0]];

    for($i=0; $i<$oeLen-1; $i++)
    {
    if(($fVerts[$orderedEdgesIDs[$i]] == $fVerts[$orderedEdgesIDs[$i+1]]) || ($fVerts[$orderedEdgesIDs[$i]] == $lVerts[$orderedEdgesIDs[$i+1]]))
    $orderedVerts[size($orderedVerts)] = $fVerts[$orderedEdgesIDs[$i]];
    else if(($lVerts[$orderedEdgesIDs[$i]] == $fVerts[$orderedEdgesIDs[$i+1]]) || ($lVerts[$orderedEdgesIDs[$i]] == $lVerts[$orderedEdgesIDs[$i+1]]))
    $orderedVerts[size($orderedVerts)] = $lVerts[$orderedEdgesIDs[$i]];
    }
    $ovLen = size($orderedVerts);
    if($fVerts[$orderedEdgesIDs[$oeLen-1]] == $orderedVerts[$ovLen-1])
    {
    $orderedVerts[$ovLen] = $lVerts[$orderedEdgesIDs[$oeLen-1]];
    $ovLen++;
    }
    else if($lVerts[$orderedEdgesIDs[$oeLen-1]] == $orderedVerts[$ovLen-1])
    {
    $orderedVerts[$ovLen] = $fVerts[$orderedEdgesIDs[$oeLen-1]];
    $ovLen++;
    }

    $vertPos = `xform -a -ws -q -t ($sel[0]+".vtx["+$orderedVerts[0]+"]")`;
    $curve = `curve -d 1 -p $vertPos[0] $vertPos[1] $vertPos[2]`;
    if($orderedVerts[0] != $orderedVerts[$ovLen-1])
    {
    for($i=1; $i<$ovLen; $i++)
    {
    $vertPos = `xform -a -ws -q -t ($sel[0]+".vtx["+$orderedVerts[$i]+"]")`;
    curve -a -p $vertPos[0] $vertPos[1] $vertPos[2] $curve;
    }
    $ret[1] = "open";
    }
    else
    {
    for($i=1; $i<$ovLen-1; $i++)
    {
    $vertPos = `xform -a -ws -q -t ($sel[0]+".vtx["+$orderedVerts[$i]+"]")`;
    curve -a -p $vertPos[0] $vertPos[1] $vertPos[2] $curve;
    }
    closeCurve -ch 0 -ps 0 -rpo 1 -bb 0.5 -bki 0 -p 0.1 $curve;
    $ret[1] = "closed";
    }
    $ret[0] = $curve;
    return $ret;

}


/******************************************************************************
 * @procedure    mm_extractCurveFromEdges
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $degree : int
 *
 * @returns      string
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string mm_extractCurveFromEdges(int $degree)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $curve[] = `mm_curveFromEdges`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $curve = `mm_curveFromEdges`;
    if($degree == 1)
    {
    select -r $curve[0];
    return $curve[0];
    }
    else if($degree == 3)
    {
    if($curve[1] == "open")
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 1 -kep 1 -kt 0 -s 4 -d 3 -tol 0 $curve[0];
    if($curve[1] == "closed")
    {
    closeCurve -ch 1 -ps 0 -rpo 1 -bb 0.5 -bki 0 -p 0.1 $curve[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 1 -kep 1 -kt 0 -s 4 -d 3 -tol 0 $curve[0];
    closeCurve -ch 1 -ps 0 -rpo 1 -bb 0.5 -bki 0 -p 0.1 $curve[0];
    }
    select -r $curve[0];
    return $curve[0];
    }
    else
    error ("Degree not suported: "+$degree+". Use only 1 or 3.");

}


/******************************************************************************
 * @procedure    SortEvenArrays
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $ArrayItems : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SortEvenArrays(string $ArrayItems[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $getsize = size($ArrayItems);
    int $i = 0;
    string $newItemsList[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $getsize = size($ArrayItems);
    $i = 0;
    $iX = 0;
    while($i < $getsize){
    $iX++;
    if ( $iX == 2){
    string $oneitem[0] = {$ArrayItems[$i]};
    appendStringArray($newItemsList, $oneitem, 1);
    $iX = 0;
    }
    $i++;
    }
    return $newItemsList;

}


/******************************************************************************
 * @procedure    ArrayFromAllinString
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $list : string
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] ArrayFromAllinString(string $list)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i = 0;
    int $Indexi = 0;
    int $triggerends = 0;
    string $singleStringItemB[];
    string $singleStringItemA[];
    string $listA = $list;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $i = 0;
    $Indexi = 0;
    $triggerends = 0;
    $listA = $list;
    while ( $triggerends < 1 ) {
    $i++;
    $singleStringItemA = {`substring $listA $i $i`};
    if (size($singleStringItemA[0]) == 0){
    $triggerends = 2; } else {
    appendStringArray($singleStringItemB, $singleStringItemA, 1);
    }
    $Indexi++;
    if ($Indexi == 20){ $triggerends = 2;}
    }
    return $singleStringItemB;

}


/******************************************************************************
 * @procedure    ArrayToIntList
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $singleStringItemB : string[]
 *
 * @returns      int[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int[] ArrayToIntList(string $singleStringItemB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Numberlist[];
    int $triggerendsB = 0;
    int $newlistSize = size($singleStringItemB);
    int $ci = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $triggerendsB = 0;
    $newlistSize = size($singleStringItemB);
    $ci = 0;
    while ( $triggerendsB < $newlistSize ) {
    $Numberlist[$ci] = $singleStringItemB[$ci];
    $ci++;
    $triggerendsB = $triggerendsB + 1;
    }
    print $Numberlist;
    return $Numberlist;

}


/******************************************************************************
 * @procedure    CycleNumberString
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $singleStringItemC : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CycleNumberString(string $singleStringItemC[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArray;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArray = size($singleStringItemC) -1;
    string $last[0] = {$singleStringItemC[$SizeOfArray]};
    string $first[0] = {$singleStringItemC[0]};
    stringArrayRemoveAtIndex(0, $singleStringItemC);
    appendStringArray($singleStringItemC, $first, 1);
    return $singleStringItemC;

}


/******************************************************************************
 * @procedure    SortPatternArrays
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $ArrayItems : string[]
 *   $NumberlistA : int[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SortPatternArrays(string $ArrayItems[], int $NumberlistA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $getsizeNlist = size($NumberlistA);
    int $iN = 0;
    int $getsize = size($ArrayItems);
    int $i = 0;
    string $newItemsList[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $getsizeNlist = size($NumberlistA);
    $iN = 0;
    $getsize = size($ArrayItems);
    $i = 0;
    $iX = 0;
    while($i < $getsize){
    $iX++;
    if ( $NumberlistA[$iN] == 0){
    string $oneitem[0] = {$ArrayItems[$i]};
    appendStringArray($newItemsList, $oneitem, 1);
    if ( $iN == $getsizeNlist){ $iN = -1;}
    $iX = 0;
    }

    $iN++;
    $i++;
    }
    return $newItemsList;

}


/******************************************************************************
 * @procedure    CompareCurveIntersect
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $objectLoc : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersect(string $objectLoc[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectLocZ) -1;
    int $Z = size($objectLocZ);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    string $objectLocZ[];
    string $CurveintersectZ;
    string $ItemLists[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $objectLocZ = $objectLoc;
    $X = size($objectLocZ) -1;
    $Z = size($objectLocZ);
    $i = 1;
    $n = -1;
    $n2 = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){
    $CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2]`;
    if (size($CurveintersectZ) > 0) {
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
    } else { print "no Intersect"; }
    $n2++;
    }
    }
    return $ItemLists;

}


/******************************************************************************
 * @procedure    CompareCurveIntersectTwoCurves
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $objectLocA : string[]
 *   $objectAll : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersectTwoCurves(string $objectLocA[], string $objectAll[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Z = size($objectLocA) -1;
    int $X = size( $objectAll) -1;
    int $ix = 0;
    int $n2 = 0;
    string $CurveintersectZA;
    string $CurveintersectZB;
    string $ItemLists[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $Z = size($objectLocA) -1;
    $X = size( $objectAll) -1;
    $ix = 0;
    $n2 = 0;

    while ($X > $ix++){
    $CurveintersectZA = `curveIntersect -ch 0 -tolerance 0.001 $objectLocA[0] $objectAll[$n2]`;
    if (size($CurveintersectZA) > 0) {
    $CurveintersectZB = `curveIntersect -ch 0 -tolerance 0.001 $objectLocA[1] $objectAll[$n2]`;
    if (size($CurveintersectZB) > 0) {
    ArrayInsertAtEnd( $ItemLists, $objectAll[$n2]);
    }
    } else { print "no Intersect"; }
    $n2++;

    }
    return $ItemLists;

}


/******************************************************************************
 * @procedure    CompareCurveIntersect4
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $objectLoc : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersect4(string $objectLoc[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectLocZ) -1;
    int $Z = size($objectLocZ);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    string $objectLocZ[];
    string $CurveintersectZ;
    string $ItemLists[];
    string $shorterList[] = stringArrayRemoveDuplicates($ItemLists);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $objectLocZ = $objectLoc;
    $X = size($objectLocZ) -1;
    $Z = size($objectLocZ);
    $i = 1;
    $n = -1;
    $n2 = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){
    $CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2]`;
    if (size($CurveintersectZ) > 0) {
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
    } else { print "no Intersect"; }
    $n2++;
    }
    }

    $shorterList = stringArrayRemoveDuplicates($ItemLists);
    $ItemLists = $shorterList;
    return $ItemLists;

}


/******************************************************************************
 * @procedure    CompareCurveIntersect2
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $object : string[]
 *   $objectlist : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersect2(string $object[], string $objectlist[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectlist);
    string $ItemListsA[];
    string $CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $object[0] $objectlist[$ix]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $X = size($objectlist);

    $ix = 0;
    $iz = 1;
    while ($X > $ix++){

    $CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $object[0] $objectlist[$ix]`;
    if (size($CurveintersectZ) > 0) {
    ArrayInsertAtEnd( $ItemListsA, $objectlist[$ix]);
    }
    }
    return $ItemListsA;

}


/******************************************************************************
 * @procedure    CompareCurveIntersect5
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $objectLoc : string[]
 *   $objectLocB : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CompareCurveIntersect5(string $objectLoc[], string $objectLocB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectLocZ);
    int $Z = size($objectLocB);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    string $objectLocZ[];
    string $CurveintersectZ;
    string $ItemLists[];
    string $shorterList[] = stringArrayRemoveDuplicates($ItemLists);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $objectLocZ = $objectLoc;

    $X = size($objectLocZ) ;

    $Z = size($objectLocB);
    $i = 1;
    $n = -1;
    $n2 = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){
    $CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $objectLocZ[$n] $objectLocB[$n2]`;
    if (size($CurveintersectZ) > 0) {
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
    ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
    } else { print "no Intersect"; }
    $n2++;
    }
    }

    $shorterList = stringArrayRemoveDuplicates($ItemLists);
    $ItemLists = $shorterList;
    return $ItemLists;

}


/******************************************************************************
 * @procedure    CIRCLESCRIPTZ
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $ObjectCurve : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CIRCLESCRIPTZ(string $ObjectCurve[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $squareA;
    int $squareB;
    float $rotationz[];
    float $translationz[];
    float $bbox[] = `exactWorldBoundingBox $ObjectCurveduplicate`;
    float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox[2]};
    float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox[5]};
    float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox[2]};
    float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox[5]};
    float $BoxMPointAC[] = MidPointBetween($BoxPointA, $BoxPointC);
    float $BoxMPointBD[] = MidPointBetween($BoxPointB, $BoxPointD);
    float $BoxMPointAD[] = MidPointBetween($BoxPointA, $BoxPointD);
    float $BoxMPointBC[] = MidPointBetween($BoxPointB, $BoxPointC);
    float $CrossMPointAB[] = MidPointBetween($BoxPointA, $BoxPointB);
    float $translationzMiddle[];
    float $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    float $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);
    float $squarePercentA;
    float $squarePercentB;
    string $CIRCLEX[];
    string $ObjectCurveduplicate[] = `duplicate -rr $ObjectCurve`;
    string $NewNameZ = `rename $CIRCLEX "Curve"`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //CIRCLE SCRIPT


    //string $newCircle[] = `CIRCLESCRIPTZ($drawcurve)`;
    //string $ObjectCurve[] = $drawcurve;

    $ObjectCurveduplicate = `duplicate -rr $ObjectCurve`;
    setAttr ($ObjectCurveduplicate[0] + ".translate") 0 0 0;
    setAttr ($ObjectCurveduplicate[0] + ".rotate") 0 0 0;
    select -cl  ;
    $rotationz = `xform -q -rotation $ObjectCurve`;
    $translationz = `xform -q -translation $ObjectCurve`;
    $bbox = `exactWorldBoundingBox $ObjectCurveduplicate`;
    //print("Bounding box ranges from: " +
    //      $bbox[0] + "," + $bbox[1] + "," + $bbox[2] + ", to " +
    //      $bbox[3] + "," + $bbox[4] + "," + $bbox[5] + ".\n");
    spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
    move -ws $bbox[0] $bbox[1] $bbox[2] BoxspaceLocatorA;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
    move -ws $bbox[3] $bbox[4] $bbox[5] BoxspaceLocatorB;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
    move -ws $bbox[3] $bbox[1] $bbox[2] BoxspaceLocatorC;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
    move -ws $bbox[0] $bbox[4] $bbox[5] BoxspaceLocatorD;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;
    // xform -query -worldSpace -translation;
    /////////////////////////////////////////
    $BoxPointA = {$bbox[0], $bbox[1], $bbox[2]};
    $BoxPointB = {$bbox[3], $bbox[4], $bbox[5]};
    $BoxPointC = {$bbox[3], $bbox[1], $bbox[2]};
    $BoxPointD = {$bbox[0], $bbox[4], $bbox[5]};

    $BoxPointA = `MakeCleanFloats($BoxPointA)`;
    $BoxPointB = `MakeCleanFloats($BoxPointB)`;
    $BoxPointC = `MakeCleanFloats($BoxPointC)`;
    $BoxPointD = `MakeCleanFloats($BoxPointD)`;

    $BoxMPointAC = MidPointBetween($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween($BoxPointB, $BoxPointC);
    //   MoveObjectSelection($BoxMPointAC);

    $BoxMPointAC = MidPointBetween($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween($BoxPointB, $BoxPointC);

    $CrossMPointAB = MidPointBetween($BoxPointA, $BoxPointB);
    move -ws $bbox[0] $bbox[4] $bbox[5] BoxspaceLocatorD;
    $translationzMiddle = `xform -q -translation BoxspaceLocatorMiddle`;

    $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);
    $distanceAverage =  (($distanceA + $distanceB) * (0.5)) ;
    $radiusX = ( $distanceAverage / 2);
    //if / then
    if ( $distanceA > $distanceAverage) {
    $squarePercentA = (( $distanceAverage / $distanceA ) * (100));
    }
    if ( $distanceA < $distanceAverage) {
    $squarePercentA = (( $distanceA / $distanceAverage ) * (100));
    }
    if ( $distanceB > $distanceAverage) {
    $squarePercentB = (( $distanceAverage / $distanceB ) * (100));
    }
    if ( $distanceB < $distanceAverage) {
    $squarePercentB = (( $distanceB / $distanceAverage ) * (100));
    }
    /////////////////////
    $squareA = 0;
    $squareB = 0;
    print $squarePercentA ;
    if ( $squarePercentA > 55)  {
    $squareA = (0 + 1);
    } else {
    $squareA = (0);
    }
    print $squareA;
    print $squarePercentB ;
    if ( $squarePercentB > 55)  {
    $squareB = ($squareB + 1);
    } else {
    $squareB = (0);
    }
    $addSquareResults = ($squareA + $squareB);
    if ( $addSquareResults == 2 ){
    circle -nr 0 1 0 -c $translationzMiddle[0] $translationzMiddle[1] $translationzMiddle[2] -r $radiusX;
    $CIRCLEX = `ls -sl`;
    $rotationz = `xform -q -rotation $ObjectCurve`;
    setAttr ($CIRCLEX[0] + ".rotateX") $rotationz[0];
    setAttr ($CIRCLEX[0] + ".rotateY") $rotationz[1];
    setAttr ($CIRCLEX[0] + ".rotateZ") $rotationz[2];
    $translationz = `xform -q -translation $ObjectCurve[0]`;
    setAttr ($CIRCLEX[0] + ".translateX") $translationz[0];
    setAttr ($CIRCLEX[0] + ".translateY") $translationz[1];
    setAttr ($CIRCLEX[0] + ".translateZ") $translationz[2];
    //TEMP CHANGE
    //string $currPanel = `getPanel -withFocus` , $camera ;
    //$camera = `modelPanel -q -camera $currPanel`;
    //setAttr ($CIRCLEX[0] + ".rotate") `getAttr ($ObjectCurve[0] + ".rotate")`;
    delete $ObjectCurve $ObjectCurveduplicate BoxspaceLocatorA BoxspaceLocatorB BoxspaceLocatorC BoxspaceLocatorD BoxspaceLocatorMiddle;
    }
    else {
    delete $ObjectCurveduplicate BoxspaceLocatorA BoxspaceLocatorB BoxspaceLocatorC BoxspaceLocatorD BoxspaceLocatorMiddle;
    }
    $NewNameZ = `rename $CIRCLEX "Curve"`;
    $CIRCLEX = {$NewNameZ};
    return $CIRCLEX;


}


/******************************************************************************
 * @procedure    Make_Middle_of_Curve_ParamlocatorZ
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $objectCurveSelected : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Make_Middle_of_Curve_ParamlocatorZ(string $objectCurveSelected[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $a = 1;
    float $arclenghtzALL = `arclen $objectCurveSelected`;
    float $arclenghtzDivide = $arclenghtzALL / 2.0;
    float $step = 10;
    float $t = $a/$step;
    float $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    float $divZZ = $arclenghtzDivide / $arclenghtzparamZ;
    float $divZZ2 = $t * $divZZ;
    float $posA[];
    float $posB[];
    float $posC[];
    string $paramlocatorZARC[];
    string $paramANDCurve[] = `paramToCurvePts( $paramlocatorZARC )`;
    string $CircularArcFromCurve[];
    string $ArcCurve[];
    string $ParentArc[];
    string $MakeArcLocator[];
    string $ArcZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $arclenghtzALL = `arclen $objectCurveSelected`;
    $arclenghtzDivide = $arclenghtzALL / 2.0;

    $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectCurveSelected[0] + ".cv[0]") ;
    $CurveSelection[1] = ($objectCurveSelected[0] + ".cv[" + $numCVrealNum + "]") ;
    $paramlocatorZARC[0] = eval("paramLocator " +  $objectCurveSelected[0] + ".u[" + 0.0 + "]");

    $step = 10;
    $a = 1;
    $t = $a/$step;

    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $t;
    $paramANDCurve = `paramToCurvePts( $paramlocatorZARC )`;
    $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;

    $divZZ = $arclenghtzDivide / $arclenghtzparamZ ;
    $divZZ2 = $t * $divZZ ;
    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $divZZ2;
    ////////////////////// Moved ParamLoc to middle

    $posA = `pointPosition -w $CurveSelection[0]`;
    $posB = `pointPosition -w $paramlocatorZARC[0]`;
    $posC = `pointPosition -w $CurveSelection[1]`;
    $CircularArcFromCurve[0] = `createNode makeThreePointCircularArc`;
    setAttr ($CircularArcFromCurve[0] + ".pt1") $posA[0] $posA[1] $posA[2] ;
    setAttr ($CircularArcFromCurve[0] + ".pt2") $posB[0] $posB[1] $posB[2];
    setAttr ($CircularArcFromCurve[0] + ".pt3") $posC[0] $posC[1] $posC[2];
    setAttr ($CircularArcFromCurve[0] + ".d") 3;
    setAttr ($CircularArcFromCurve[0] + ".s") 8;
    $ArcCurve[0] = `createNode nurbsCurve` ;
    connectAttr ($CircularArcFromCurve[0] + ".oc") ($ArcCurve[0] +".cr");
    //delete $objectCurveSelected;
    $ParentArc = `listRelatives -parent $ArcCurve`;
    ResetTranlation($ParentArc);
    $MakeArcLocator = `spaceLocator -p 0 0 0 -n ArcLocator`;
    move -ws $posB[0] $posB[1] $posB[2] $MakeArcLocator;
    $ConnectLocToPoint2 = `connectAttr -f ($MakeArcLocator[0] + ".translate") ( $CircularArcFromCurve[0] + ".pt2")`;

    $ArcZ[0] = `rename $ParentArc $objectCurveSelected`;
    delete $paramlocatorZARC;
    select -r $ArcZ;
    return $ArcZ;


}


/******************************************************************************
 * @procedure    Strait_ARC_or_FreeForm
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $renamed : string[]
 *   $ArcN : float
 *   $StraitN : float
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Strait_ARC_or_FreeForm(string $renamed[], float $ArcN, float $StraitN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $free = 0;
    int $straitTrigger = 0;
    int $Cvz = $objectAcurveD01;
    int $Cvz2 = $objectAcurveD02;
    float $objectAcurve01 = arclen ($renamed);
    float $curveEndsDis01 = GetDistanceBetweenCurveEnds($renamed);
    float $PercentENDsDiffL = XpercentLess_thenY($objectAcurve01, $curveEndsDis01);
    float $objectAcurveD01 = $objectAcurve01 / 1.5;
    float $PercentDiffS;
    float $posA[] = $VectorCurveEndZ[0];
    float $posB[] = $VectorCurveEndZ[1];
    float $objectAcurveL = arclen ($renamed);
    float $objectBcurveL = arclen ($objectB);
    float $PercentDiffL = XpercentLess_thenY($objectBcurveL, $objectAcurveL);
    float $objectAcurve02 = arclen ($renamed);
    float $objectAcurveD02 = $objectAcurve02 / 1.5;
    string $nameString = $renamed[0];
    string $ParentArc[];
    string $objectB[];
    string $objectC[];
    string $DeleteCurveA[];
    string $DeleteCurveB[];
    string $CurveBetween[];
    vector $VectorCurveEndZ[] = VecCurveEnds($renamed);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    $free = 0;
    $nameString = $renamed[0];
    //smoothCurve -ch 1 -rpo 1 -s 6.60 ($nameString +".cv[*]");
    $objectAcurve01 = arclen ($renamed);

    $curveEndsDis01 = GetDistanceBetweenCurveEnds($renamed);
    $PercentENDsDiffL = XpercentLess_thenY($objectAcurve01, $curveEndsDis01);
    $straitTrigger = 0;

    if ( $PercentENDsDiffL < 2 ){ $straitTrigger = 1; }

    $objectAcurveD01 = $objectAcurve01 / 1.5;
    $Cvz = $objectAcurveD01;
    if( $objectAcurve01 < 1.0){ $Cvz = 4; }
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001 $renamed;




    if ($straitTrigger == 1){
    $VectorCurveEndZ = VecCurveEnds($renamed);
    $posA = $VectorCurveEndZ[0];
    $posB = $VectorCurveEndZ[1];
    $CurveBetween = MakeCurveBetweenFloats($posA, $posB);
    ResetTranlation($CurveBetween);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001 $CurveBetween;
    $ParentArc = $CurveBetween; $DeleteCurveA = $renamed; $DeleteCurveB = $objectB;
    }


    if ( $straitTrigger == 0 ){
    $objectB = Make_Middle_of_Curve_ParamlocatorZ($renamed);
    ResetTranlation($objectB);
    $objectC = {$renamed[0], $objectB[0]};
    ResetTranlationEach($objectC);
    $objectAcurveL = arclen ($renamed);
    $objectBcurveL = arclen ($objectB);
    $PercentDiffL = XpercentLess_thenY($objectBcurveL, $objectAcurveL);
    if ($PercentDiffL  < $ArcN){

    $ParentArc = $objectB;  $DeleteCurveA = $renamed;
    }else{

    $free = 1;
    $ParentArc = $renamed; $DeleteCurveA = $objectB; }

    }

    delete $DeleteCurveA;
    rename $ParentArc $nameString;
    $ParentArc[0] = $nameString;


    if ( $free == 1 ){ select -r $ParentArc; EvalSmoothCurves;
    $nameString = $ParentArc[0];
    $objectAcurve02 = arclen ($renamed);
    $objectAcurveD02 = $objectAcurve02 / 1.5;
    $Cvz2 = $objectAcurveD02;
    if( $objectAcurve01 < 1.0){ $Cvz2 = 4; }
    //rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001 $renamed;
    }

    return $ParentArc;


}


/******************************************************************************
 * @procedure    SmoothCurvature4
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $curveM : float
 *   $Steps : int
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvature4(float $curveM, int $Steps)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 3 );
    int $trigger = 0;
    int $Par = 0;
    int $a;
    int $ii = 0;
    int $CVpoints = 0;
    float $curveMin = $curveM;
    float $step = $numEPrealNum2;
    float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = {$Newcurvez};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $myCurve = $curves[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp 1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv[*]");
    $CurveSelection = `ls -fl ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 3 );
    if ($Steps > 8 ){ $numEPrealNum2 = $Steps; }

    $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
    $trigger = 0;
    $curve = "";
    $curveMin = $curveM;
    while ( $trigger < 1 ){
    $step = $numEPrealNum2;
    $curve = "curve -d 3";

    $Par = 0;
    $ii = 0;
    $CVpoints = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
    $values = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    if ( $CurvatureRadi <= $curveMin){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    if (( $CurvatureRadi > $curveMin) && ( $ii == 1 )){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par == 1.0 )){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    }
    if ( $CVpoints < 8 ){ $curveMin++; }
    if ( $CVpoints >= 8 ){ $trigger = 1; }

    }

    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    rename $Newcurve $myCurve;
    $Newcurve = {$myCurve};

    return $Newcurve;

}


/******************************************************************************
 * @procedure    SmoothCurvature13
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $curveM : float
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvature13(float $curveM)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 1 );
    int $trigger = 0;
    int $Par = 0;
    int $b = 0;
    int $ii = 0;
    int $a = 0;
    int $CVpoints = 0;
    float $arcL1 = `arclen $curves[0]`;
    float $arcL1B = ( $arcL1 + ((-1) * ( $arcL1 / 10 )));
    float $curveMin = $curveM;
    float $CurvatureRadi2;
    float $step = $numEPrealNum2;
    float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    float $AverageCurvatureRadi = (($CurvatureRadi + $CurvatureRadi2) / 2);
    float $arcL2 = `arclen $Newcurve[0]`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $crShape[] = `listRelatives -s $curves[0]`;
    string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size ($CurveSelection);
    string $Newcurve[];
    string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`;
    string $Newcurvez;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $arcL1 = `arclen $curves[0]`;
    $arcL1B = ( $arcL1 + ((-1) * ( $arcL1 / 10 )));
    $myCurve = $curves[0];
    $crShape = `listRelatives -s $curves[0]`;
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp 1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv[*]");
    $CurveSelection = `ls -fl ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 1 );
    $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
    $trigger = 0;
    $curve = "";
    $Par = 0;
    $b = 0;
    $ii = 0;
    $a = 0;
    $curveMin = $curveM;
    while ( $trigger < 1 ){
    $step = $numEPrealNum2;
    $curve = "curve -d 3";
    $CVpoints = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = $a/$step;
    setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
    if ( $Par > 0.0 ){ $b = $a -1; $Par2 = $b/$step;
    $CurvatureRadi2 = `pointOnCurve -top 1 -pr $Par2 -cr $crShape[0]`; }
    $values = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;

    $AverageCurvatureRadi = (($CurvatureRadi + $CurvatureRadi2) / 2);

    if ( $AverageCurvatureRadi <= $curveMin){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    if (( $CurvatureRadi > $curveMin) && ( $ii == 1 )){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    if (( $CurvatureRadi > $curveMin) && ( $Par == 1.0 )){
    $CVpoints++;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }
    }
    if ( $CVpoints < 8 ){ $curveMin++; }
    if ( $CVpoints > 2 ){
    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    $arcL2 = `arclen $Newcurve[0]`;
    if ( $arcL2 < $arcL1B ){ delete $Newcurve; $trigger = 0; $numEPrealNum2 = $numEPrealNum2 + 3;   }
    if (( $CVpoints >= 8 )&& ( $arcL2 > $arcL1B )){ $trigger = 1; }
    }
    }

    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    rename $Newcurve $myCurve;
    $Newcurve = {$myCurve};

    return $Newcurve;

}


/******************************************************************************
 * @procedure    SmoothCurvature3
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $curveM : float
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvature3(float $curveM)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 2 );
    int $Par = 0;
    int $a;
    int $ii = 0;
    float $step = $numEPrealNum2;
    float $curveMin = $curveM;
    float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = {$Newcurvez};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $myCurve = $curves[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp 1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv[*]");
    $CurveSelection = `ls -fl ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 2 );
    //Above was Times * 4

    $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
    $step = $numEPrealNum2;
    $curve = "curve -d 3";
    $curveMin = $curveM;
    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
    $values = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    if ( $CurvatureRadi <= $curveMin){ PAUSE;
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    if (( $CurvatureRadi > $curveMin) && ( $ii == 1 )){
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }


    if (( $CurvatureRadi > $curveMin) && ( $Par == 1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    }

    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    rename $Newcurve $myCurve;
    $Newcurve = {$myCurve};

    return $Newcurve;

}


/******************************************************************************
 * @procedure    SmoothCurvatureReverse6
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $curveM : float
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] SmoothCurvatureReverse6(float $curveM)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $numEPrealNum2 = ($numEPrealNum * 2 );
    int $Par = 0;
    int $a;
    int $ii = 0;
    float $step = $numEPrealNum2;
    float $curveMin = $curveM;
    float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    float $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    string $curves[] = `ls -sl`;
    string $myCurve = $curves[0];
    string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size ($CurveSelection);
    string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`;
    string $Newcurvez = `eval($curve)`;
    string $Newcurve[] = {$Newcurvez};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curves = `ls -sl`;
    $myCurve = $curves[0];
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp 1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
    smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv[*]");
    $CurveSelection = `ls -fl ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );
    $numEPrealNum2 = ($numEPrealNum * 2 );
    //Above was Times * 4

    $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
    $spaceLocatorB = `spaceLocator -p 0 0 0 -n LocatorX`;
    $connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
    $step = $numEPrealNum2;
    $curve = "curve -d 3";
    $curveMin = $curveM;
    $Par = 0;
    $ii = 0;
    for($a = 0; $a <= $step;$a++){
    $ii = $ii + 1;
    $t =  $a/$step;
    $Par = ($a/$step);
    setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
    $values = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
    $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
    if ( $CurvatureRadi >= $curveMin){
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    if (( $CurvatureRadi < $curveMin) && ( $ii == 1 )){
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }


    if (( $CurvatureRadi < $curveMin) && ( $Par == 1.0 )){
    $curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
    }

    }

    $Newcurvez = `eval($curve)`;
    $Newcurve = {$Newcurvez};
    delete $paramlocatorpointOnCurvex $spaceLocatorB;
    delete $curves;
    rename $Newcurve $myCurve;
    $Newcurve = {$myCurve};

    return $Newcurve;

}


/******************************************************************************
 * @procedure    XpercentLess_thenY
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Ix : float
 *   $Iy : float
 *
 * @returns      float
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float XpercentLess_thenY(float $Ix, float $Iy)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $N;
    float $Ni;
    float $PercentA;
    float $PercentB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if ( $Ix > $Iy){
    $Ni = $Ix; $N = $Iy; } else { $N = $Ix;  $Ni = $Iy; }
    $PercentA = ((float($N) / $Ni) * (100) );
    $PercentB = 100 - $PercentA;
    return $PercentB;

}


/******************************************************************************
 * @procedure    Strait_ARC_or_FreeFormFind
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $renamed : string[]
 *   $ArcN : float
 *   $StraitN : float
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int Strait_ARC_or_FreeFormFind(string $renamed[], float $ArcN, float $StraitN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SAF = 0;
    float $objectAcurve = GET_AREA_OF_CURVE ($renamed);
    float $objectBcurve = GET_AREA_OF_CURVE ($objectB);
    float $PercentDiff = XpercentLess_thenY($objectBcurve, $objectAcurve);
    float $objectAcurveL = arclen ($renamed);
    float $objectBcurveL = arclen ($objectB);
    float $PercentDiffL = XpercentLess_thenY($objectBcurveL, $objectAcurveL);
    float $PercentAverage = ($PercentDiff + $PercentDiffL) /2;
    float $posA[] = $VectorCurveEndZ[0];
    float $posB[] = $VectorCurveEndZ[1];
    float $objectCcurveL = arclen ($CurveBetween);
    float $PercentDiffS = XpercentLess_thenY($objectCcurveL, $objectAcurveL);
    string $nameString = $renamed[0];
    string $ParentArc[];
    string $objectB[] = Make_Middle_of_Curve_ParamlocatorZ($renamed);
    string $objectC[] = {$renamed[0], $objectB[0]};
    string $CurveBetween[] = MakeCurveBetweenFloats($posA, $posB);
    string $DeleteCurveA[];
    string $DeleteCurveB[];
    vector $VectorCurveEndZ[] = VecCurveEnds($renamed);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $SAF = 0;
    $nameString = $renamed[0];
    //rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001 $renamed;
    $objectB = Make_Middle_of_Curve_ParamlocatorZ($renamed);
    ResetTranlation($objectB);
    $objectC = {$renamed[0], $objectB[0]};
    ResetTranlationEach($objectC);
    $objectAcurve = GET_AREA_OF_CURVE ($renamed);
    $objectBcurve = GET_AREA_OF_CURVE ($objectB);
    /////////////////////////

    $PercentDiff = XpercentLess_thenY($objectBcurve, $objectAcurve);

    $objectAcurveL = arclen ($renamed);
    $objectBcurveL = arclen ($objectB);
    $PercentDiffL = XpercentLess_thenY($objectBcurveL, $objectAcurveL);
    $PercentAverage = ($PercentDiff + $PercentDiffL) /2;

    $VectorCurveEndZ = VecCurveEnds($renamed);
    $posA = $VectorCurveEndZ[0];
    $posB = $VectorCurveEndZ[1];
    $CurveBetween = MakeCurveBetweenFloats($posA, $posB);
    ResetTranlation($CurveBetween);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001 $CurveBetween;
    $objectCcurveL = arclen ($CurveBetween);
    $PercentDiffS = XpercentLess_thenY($objectCcurveL, $objectAcurveL);
    print ("PercentDiff_Curve_to_Arc AREA "+$PercentDiff + "\n");
    print ("PercentDiff_Curve_to_Arc L "+$PercentDiffL + "\n");
    print (" " + "\n");
    print ("PercentDiff_Curve_to_Arc Average "+$PercentAverage + "\n");
    print (" " + "\n");
    print ("PercentDiff_Curve_to_STRAIT "+$PercentDiffS + "\n");


    if (($PercentAverage< $ArcN) && ($PercentDiffS > $StraitN)){
    print ("ARC Curve"+ "\n"); $SAF = 0;

    }else if ($PercentDiffS < $StraitN){
    print ("STRAIT Curve"+ "\n"); $SAF = 1;

    } else {
    print ("FREEFORM Curve"+ "\n"); $SAF = 2;
    }

    delete $CurveBetween  $objectB;

    return $SAF;


}


/******************************************************************************
 * @procedure    AddorSubtract
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Number : int
 *   $AorS : int
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int AddorSubtract(int $Number, int $AorS)
{


    if ($AorS == 1){ $Number++; return $Number;}
    if ($AorS == 0){ $Number--; return $Number;}
    if ($AorS == 2){ $Number = 0; return $Number;}


}


/******************************************************************************
 * @procedure    RoundFloat
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $val : float
 *   $dec : float
 *
 * @returns      float
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float RoundFloat(float $val, float $dec)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $dec = `pow 10 $dec`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $sign = `sign $val`;
    $dec = `pow 10 $dec`;
    $val = (int) (($val + $sign*5/($dec*10)) * $dec);
    $val = ($val / $dec);
    return $val;

}


/******************************************************************************
 * @procedure    IsCircle
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int IsCircle()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IsCircle = 0;
    int $pA1 = PointsEquivalentTol($CurveCVzero,$BoxPointA);
    int $pA2 = PointsEquivalentTol($CurveCVLast,$BoxPointA);
    int $pC1 = PointsEquivalentTol($CurveCVzero,$BoxPointC);
    int $pC2 = PointsEquivalentTol($CurveCVLast,$BoxPointC);
    int $AorC = 0;
    int $squareA = 0;
    int $squareB = 0;
    float $rotationz[];
    float $translationz[];
    float $ArcLength = `arclen $ObjectCurve[0]`;
    float $bbox[] = `exactWorldBoundingBox $ObjectCurveduplicate`;
    float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox[2]};
    float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox[5]};
    float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox[2]};
    float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox[5]};
    float $BoxMPointAC[] = MidPointBetween($BoxPointA, $BoxPointC);
    float $BoxMPointBD[] = MidPointBetween($BoxPointB, $BoxPointD);
    float $BoxMPointAD[] = MidPointBetween($BoxPointA, $BoxPointD);
    float $BoxMPointBC[] = MidPointBetween($BoxPointB, $BoxPointC);
    float $CrossMPointAB[] = MidPointBetween($BoxPointA, $BoxPointB);
    float $translationzMiddle[];
    float $CurveCVzero[] = GetCurveCVposENDS($ObjectCurveduplicate, 0);
    float $CurveCVLast[] = GetCurveCVposENDS($ObjectCurveduplicate, 1);
    float $distanceBetween = PointsGetDistanceFLOAT($CurveCVzero, $CurveCVLast);
    float $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    float $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);
    float $distanceC = PointsGetDistanceFLOAT($BoxPointA, $BoxPointD);
    float $distanceAverage = (($distanceA + $distanceB) * (0.5));
    float $radiusX = ( $distanceAverage / 2.0);
    float $distanceAverageA = $distanceC;
    float $radiusXA = (($distanceC) * (0.5));
    float $Pi = 3.141593;
    float $circleArc = (($Pi) * ($distanceC));
    float $percentLess = XpercentLess_thenY( $circleArc, $ArcLength);
    float $squarePercentA;
    float $squarePercentB;
    string $ObjectCurve[];
    string $StraitCurve[];
    string $ObjectCurveduplicate[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //StraitCurves SCRIPT

    $IsCircle = 0;

    $ObjectCurve = `ls -selection`;
    xform -cp;
    resetPivot;
    duplicatePreset(1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1);

    $ObjectCurveduplicate = `ls -selection`;
    setAttr ($ObjectCurveduplicate[0] + ".translate") 0 0 0;
    setAttr ($ObjectCurveduplicate[0] + ".rotate") 0 0 0;
    playButtonStepForward; select -cl  ;

    $rotationz = `xform -q -rotation $ObjectCurve`;
    $translationz = `xform -q -translation $ObjectCurve`;
    $ArcLength = `arclen $ObjectCurve[0]`;

    $bbox = `exactWorldBoundingBox $ObjectCurveduplicate`;
    print("Bounding box ranges from: " +
    $bbox[0] + "," + $bbox[1] + "," + $bbox[2] + ", to " +
    $bbox[3] + "," + $bbox[4] + "," + $bbox[5] + ".\n");


    spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
    move -ws $bbox[0] $bbox[1] $bbox[2] BoxspaceLocatorA;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
    move -ws $bbox[3] $bbox[4] $bbox[5] BoxspaceLocatorB;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
    move -ws $bbox[3] $bbox[1] $bbox[2] BoxspaceLocatorC;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
    move -ws $bbox[0] $bbox[4] $bbox[5] BoxspaceLocatorD;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;

    // xform -query -worldSpace -translation;


    $BoxPointA = {$bbox[0], $bbox[1], $bbox[2]};
    $BoxPointB = {$bbox[3], $bbox[4], $bbox[5]};
    $BoxPointC = {$bbox[3], $bbox[1], $bbox[2]};
    $BoxPointD = {$bbox[0], $bbox[4], $bbox[5]};

    $BoxPointA = `MakeCleanFloats($BoxPointA)`;
    $BoxPointB = `MakeCleanFloats($BoxPointB)`;
    $BoxPointC = `MakeCleanFloats($BoxPointC)`;
    $BoxPointD = `MakeCleanFloats($BoxPointD)`;

    $BoxMPointAC = MidPointBetween($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween($BoxPointB, $BoxPointC);
    //   MoveObjectSelection($BoxMPointAC);

    ///////////////////////////////
    ///////////////////////////////

    $CrossMPointAB = MidPointBetween($BoxPointA, $BoxPointB);

    // BoxspaceLocatorMiddle CHANGES need here in the future

    $translationzMiddle = $CrossMPointAB;


    $CurveCVzero = GetCurveCVposENDS($ObjectCurveduplicate, 0);
    $CurveCVLast = GetCurveCVposENDS($ObjectCurveduplicate, 1);
    $distanceBetween = PointsGetDistanceFLOAT($CurveCVzero, $CurveCVLast);

    $pA1 = PointsEquivalentTol($CurveCVzero,$BoxPointA);
    $pA2 = PointsEquivalentTol($CurveCVLast,$BoxPointA);
    $pC1 = PointsEquivalentTol($CurveCVzero,$BoxPointC);
    $pC2 = PointsEquivalentTol($CurveCVLast,$BoxPointC);

    $AorC = 0;
    if (($pA1 == 3) || ($pA2 == 3)){
    $AorC = 1;
    }
    if (($pC1 == 3) || ($pC2 == 3)){
    $AorC = 2;
    }
    $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);

    $distanceC = PointsGetDistanceFLOAT($BoxPointA, $BoxPointD);

    $distanceAverage = (($distanceA + $distanceB) * (0.5)) ;
    $radiusX = ( $distanceAverage / 2.0);

    $distanceAverageA = $distanceC ;
    $radiusXA = (($distanceC) * (0.5)) ;
    // Result: 38.390151 //

    $Pi = 3.141593;
    $circleArc = (($Pi) * ($distanceC));

    $percentLess = XpercentLess_thenY( $circleArc, $ArcLength);


    if ( $distanceA > $distanceAverage) {
    $squarePercentA = (( $distanceAverage / $distanceA ) * (100));
    }

    if ( $distanceA < $distanceAverage) {
    $squarePercentA = (( $distanceA / $distanceAverage ) * (100));
    }

    if ( $distanceB > $distanceAverage) {
    $squarePercentB = (( $distanceAverage / $distanceB ) * (100));
    }
    if ( $distanceB < $distanceAverage) {
    $squarePercentB = (( $distanceB / $distanceAverage ) * (100));
    }
    /////////////////////


    $squareA = 0;
    $squareB = 0;
    if ( $squarePercentA > 55){
    $squareA = 1;
    }
    if ( $squarePercentB > 55){
    $squareB =  1;
    }


    $addSquareResults = ($squareA + $squareB);
    if (( $addSquareResults == 2 ) && ( $percentLess < 12.0 )) {
    $IsCircle = 1;

    } else {
    // Not Diagonal curves
    $IsCircle = 0;
    }

    /*
    setAttr ($StraitCurve[0] + ".rotateX") $rotationz[0];
    setAttr ($StraitCurve[0] + ".rotateY") $rotationz[1];
    setAttr ($StraitCurve[0] + ".rotateZ") $rotationz[2];
    setAttr ($StraitCurve[0] + ".translateX") $translationz[0];
    setAttr ($StraitCurve[0] + ".translateY") $translationz[1];
    setAttr ($StraitCurve[0] + ".translateZ") $translationz[2];
    */

    select -r $ObjectCurveduplicate BoxspaceLocatorA BoxspaceLocatorB BoxspaceLocatorC BoxspaceLocatorD BoxspaceLocatorMiddle;
    delete;
    print ("IsCircle " + $IsCircle);
    print ("percentLess " + $percentLess);
    print ("addSquareResults " + $addSquareResults);
    return $IsCircle;


}


/******************************************************************************
 * @procedure    EulerAngleofTwoPoints
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $EACHCVposAZ : float[]
 *   $EACHCVposBZ : float[]
 *
 * @returns      float[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] EulerAngleofTwoPoints(float $EACHCVposAZ[], float $EACHCVposBZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Z = FindclosetTOcurveENDz($pointB1, $pointB2, $vector_SubUnitMagVec2);
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $pointCVAB_MidPoint[] = MidPointBetween($EACHCVposHigher, $EACHCVposLower);
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $curveArclenZ = PointsGetDistanceFLOAT($EACHCVposAZ, $EACHCVposBZ);
    float $DivideIt = $curveArclenZ / 2.0;
    float $DivideIt2 = $DivideIt * -1;
    float $pointB1[] = {0.0 , 0.0 , $DivideIt};
    float $pointB2[] = {0.0 , 0.0 , $DivideIt2};
    float $EulerAngleA[] = `angleBetween -euler -v1 $pointB1[0] $pointB1[1] $pointB1[2] -v2  $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2[1]   $vector_SubUnitMagVec2[2]`;
    float $EulerAngleB[] = `angleBetween -euler -v1 $pointB2[0] $pointB2[1] $pointB2[2] -v2 $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1[1]   $vector_SubUnitMagVec1[2]`;
    vector $vectorZ1 = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $pointCVAB_MidPoint);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposLower, $pointCVAB_MidPoint);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $vectorZ1 = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    if ( $MagVectorZ1 > $MagVectorZ2 ){
    print (" posA is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposAZ;
    $EACHCVposLower = $EACHCVposBZ;
    }
    if ( $MagVectorZ1 < $MagVectorZ2  ){
    print (" posB is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    }
    $pointCVAB_MidPoint = MidPointBetween($EACHCVposHigher, $EACHCVposLower);
    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher, $pointCVAB_MidPoint);
    $vector_SubUnitMagVec1 = SubtractFloats($EACHCVposHigher,$UnitVectorMagPosHigher[1]);
    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposLower, $pointCVAB_MidPoint);
    $vector_SubUnitMagVec2 = SubtractFloats($EACHCVposLower,$UnitVectorMagPosLower[1]);
    /////////////////////////////////////////////////////
    $curveArclenZ = PointsGetDistanceFLOAT($EACHCVposAZ, $EACHCVposBZ);
    $DivideIt = $curveArclenZ / 2.0;
    $DivideIt2 = $DivideIt * -1;
    $pointB1 = {0.0 , 0.0 , $DivideIt} ;
    $pointB2 = {0.0 , 0.0 , $DivideIt2} ;
    /// NOTE curve ENds will not allways Line up and may be inverted
    //let $F1 be the first CV $F2 the last .. $F3 third point
    $Z = FindclosetTOcurveENDz($pointB1, $pointB2, $vector_SubUnitMagVec2);
    if ($Z == 1){ print "new floats"; $pointB1 = $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
    $EulerAngleA = `angleBetween -euler -v1 $pointB1[0] $pointB1[1] $pointB1[2] -v2  $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2[1]   $vector_SubUnitMagVec2[2]`;
    $EulerAngleB = `angleBetween -euler -v1 $pointB2[0] $pointB2[1] $pointB2[2] -v2 $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1[1]   $vector_SubUnitMagVec1[2]`;

    return $EulerAngleA;

}


/******************************************************************************
 * @procedure    getYrotationOFcam
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      float[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] getYrotationOFcam()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $CamerasDirectionVector[];
    float $CamerasPositionz[];
    float $CamLengthVector[];
    float $CP[] = $CamerasPositionz;
    float $CamEulerAngleN[] = {$CamLengthVector[0], 0.0, $CamLengthVector[2]};
    float $CamEulerAngleNi[] = {$CamerasPositionz[0], 0.0, $CamerasPositionz[2]};
    float $CamEulerAngle[] = EulerAngleofTwoPoints($CamEulerAngleN, $CamEulerAngleNi);
    string $currPanel = `getPanel -withFocus` , $camera;
    string $Camera = `modelEditor -q -camera $currPanel`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    //============================================
    $CamerasDirectionVector = nurbsViewDirectionVector(0);
    //============================================ ;) nurbsViewDirectionVector =====
    $currPanel = `getPanel -withFocus` , $camera ;
    $Camera = `modelEditor -q -camera $currPanel`;
    $CamerasPositionz = `camera -q -position $Camera`;
    $CP = $CamerasPositionz;

    $CamLengthVector = AddFloats($CamerasDirectionVector, $CP);

    $CamEulerAngleN = {$CamLengthVector[0], 0.0, $CamLengthVector[2]};
    $CamEulerAngleNi = {$CamerasPositionz[0], 0.0, $CamerasPositionz[2]};
    $CamEulerAngle = EulerAngleofTwoPoints($CamEulerAngleN, $CamEulerAngleNi);

    return $CamEulerAngle;

}


/******************************************************************************
 * @procedure    ZplainFlatten
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ZplainFlatten()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Y = 0;
    float $CamEulerAngle[] = `getYrotationOFcam`;
    float $CamEulerAngleY = `abs $CamEulerAngle[1]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Y = 0;
    $CamEulerAngle = `getYrotationOFcam`;
    $CamEulerAngleY = `abs $CamEulerAngle[1]`;
    if ($CamEulerAngleY < 22.0){
    $Y = 1; print "Less then 22";
    }
    return $Y;

}


/******************************************************************************
 * @procedure    EulerAngleofCurve
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      float[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] EulerAngleofCurve()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    int $Z = FindclosetTOcurveENDz($pointB1, $pointB2, $vector_SubUnitMagVec2);
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    float $MagVectorZ1 = mag($vectorZ1);
    float $MagVectorZ2 = mag($vectorZ2);
    float $EACHCVposHigher[];
    float $EACHCVposLower[];
    float $pointCVAB_MidPoint[] = MidPointBetween($EACHCVposHigher, $EACHCVposLower);
    float $vector_SubUnitMagVec1[];
    float $vector_SubUnitMagVec2[];
    float $curveArclenZ = `arclen $CurveItem`;
    float $DivideIt = $curveArclenZ / 2.0;
    float $DivideIt2 = $DivideIt * -1;
    float $pointB1[] = {0.0 , 0.0 , $DivideIt};
    float $pointB2[] = {0.0 , 0.0 , $DivideIt2};
    float $EulerAngleA[] = `angleBetween -euler -v1 $pointB1[0] $pointB1[1] $pointB1[2] -v2  $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2[1]   $vector_SubUnitMagVec2[2]`;
    float $EulerAngleB[] = `angleBetween -euler -v1 $pointB2[0] $pointB2[1] $pointB2[2] -v2 $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1[1]   $vector_SubUnitMagVec1[2]`;
    string $CurveItem[];
    string $CurveSelection[];
    vector $vectorZ1 = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $vectorZ2 = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $pointCVAB_MidPoint);
    vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposLower, $pointCVAB_MidPoint);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveItem = `ls -sl`;
    $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA  )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    $vectorZ1 = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $vectorZ2 = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
    $MagVectorZ1 = mag($vectorZ1);
    $MagVectorZ2 = mag($vectorZ2);
    if ( $MagVectorZ1 > $MagVectorZ2 ){
    print (" posA is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposAZ;
    $EACHCVposLower = $EACHCVposBZ;
    }
    if ( $MagVectorZ1 < $MagVectorZ2  ){
    print (" posB is Higher " + "\n");
    $EACHCVposHigher = $EACHCVposBZ;
    $EACHCVposLower = $EACHCVposAZ;
    }
    $pointCVAB_MidPoint = MidPointBetween($EACHCVposHigher, $EACHCVposLower);
    /////////////////////////////////////
    $UnitVectorMagPosHigher = MagTimesUnitVecs($EACHCVposHigher, $pointCVAB_MidPoint);
    $vector_SubUnitMagVec1 = SubtractFloats($EACHCVposHigher,$UnitVectorMagPosHigher[1]);
    $UnitVectorMagPosLower = MagTimesUnitVecs($EACHCVposLower, $pointCVAB_MidPoint);
    $vector_SubUnitMagVec2 = SubtractFloats($EACHCVposLower,$UnitVectorMagPosLower[1]);
    /////////////////////////////////////////////////////
    $curveArclenZ = `arclen $CurveItem`;
    $DivideIt = $curveArclenZ / 2.0;
    $DivideIt2 = $DivideIt * -1;
    $pointB1 = {0.0 , 0.0 , $DivideIt} ;
    $pointB2 = {0.0 , 0.0 , $DivideIt2} ;
    /// NOTE curve ENds will not allways Line up and may be inverted
    //let $F1 be the first CV $F2 the last .. $F3 third point
    $Z = FindclosetTOcurveENDz($pointB1, $pointB2, $vector_SubUnitMagVec2);
    if ($Z == 1){ print "new floats"; $pointB1 = $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
    $EulerAngleA = `angleBetween -euler -v1 $pointB1[0] $pointB1[1] $pointB1[2] -v2  $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2[1]   $vector_SubUnitMagVec2[2]`;
    $EulerAngleB = `angleBetween -euler -v1 $pointB2[0] $pointB2[1] $pointB2[2] -v2 $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1[1]   $vector_SubUnitMagVec1[2]`;

    return $EulerAngleA;

}


/******************************************************************************
 * @procedure    MidPointBetween
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $loc1 : float[]
 *   $loc2 : float[]
 *
 * @returns      float []
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] MidPointBetween(float $loc1[], float $loc2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $a = ($loc2[0] + $loc1[0]) * (0.5);
    float $b = ($loc2[1] + $loc1[1]) * (0.5);
    float $c = ($loc2[2] + $loc1[2]) * (0.5);
    float $MidPoint[] = {$a , $b , $c};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $a = ($loc2[0] + $loc1[0]) * (0.5);
    $b = ($loc2[1] + $loc1[1]) * (0.5);
    $c = ($loc2[2] + $loc1[2]) * (0.5);

    $MidPoint = {$a , $b , $c};
    return $MidPoint;

}


/******************************************************************************
 * @procedure    PointsEquivalentTol
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int PointsEquivalentTol(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $pX = equivalentTol($posA[0], $posB[0], 0.001);
    int $pY = equivalentTol($posA[1], $posB[1], 0.001);
    int $pZ = equivalentTol($posA[2], $posB[2], 0.001);
    int $addedResults = $pX + $pY + $pZ;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pX = equivalentTol($posA[0], $posB[0], 0.001);
    $pY = equivalentTol($posA[1], $posB[1], 0.001);
    $pZ = equivalentTol($posA[2], $posB[2], 0.001);
    $addedResults = $pX + $pY + $pZ;
    if ($addedResults == 3 ){ print "Points equivalent";
    }
    return $addedResults;

}


/******************************************************************************
 * @procedure    MagTimesUnitVecs
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $vectorZFlatYHigher : vector
 *   $vectorZFlatYLower : vector
 *
 * @returns      vector[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] MagTimesUnitVecs(vector $vectorZFlatYHigher, vector $vectorZFlatYLower)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MagVectorZYHigher = mag($vectorZFlatYHigher);
    float $MagVectorZYLower = mag($vectorZFlatYLower);
    vector $unitVectormagZYHL[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MagVectorZYHigher = mag($vectorZFlatYHigher);
    $MagVectorZYLower = mag($vectorZFlatYLower);
    $unitVectormagZYHL[0] = $MagVectorZYHigher * unit($vectorZFlatYHigher);
    $unitVectormagZYHL[1] = $MagVectorZYLower * unit($vectorZFlatYLower);
    print $unitVectormagZYHL;
    return $unitVectormagZYHL;

}


/******************************************************************************
 * @procedure    AppendFloatsZ
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *   $XYZ : int
 *
 * @returns      float[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] AppendFloatsZ(float $posA[], float $posB[], int $XYZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if($XYZ == 0){ $AddposA_AND_posB_float = {$posB[0], $posA[1], $posA[2]} ; }
    if($XYZ == 1){ $AddposA_AND_posB_float = {$posA[0], $posB[1], $posA[2]} ; }
    if($XYZ == 2){ $AddposA_AND_posB_float = {$posA[0], $posA[1], $posB[2]} ; }
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    CycleFloatsZ
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *   $XYZ1 : int
 *   $XYZ2 : int
 *
 * @returns      float[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] CycleFloatsZ(float $posA[], float $posB[], int $XYZ1, int $XYZ2)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    if(($XYZ1 == 0) && ($XYZ2 == 1)){ $AddposA_AND_posB_float = {$posA[1], $posA[0], $posA[2]} ; } //01 xy
    if(($XYZ1 == 0) && ($XYZ2 == 2)){ $AddposA_AND_posB_float = {$posA[2], $posB[1], $posA[0]} ; } //02 xz
    if(($XYZ1 == 1) && ($XYZ2 == 2)){ $AddposA_AND_posB_float = {$posA[0], $posA[2], $posB[1]} ; } //12 yz
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    AddFloats
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] AddFloats(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $AddposA_AND_posB_float = {($posA[0] + $posB[0]), ($posA[1] + $posB[1]), ($posA[2] + $posB[2])} ;
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    SubtractFloats
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] SubtractFloats(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $SubtractposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SubtractposA_AND_posB_float = {($posA[0] - $posB[0]), ($posA[1] - $posB[1]), ($posA[2] - $posB[2])} ;
    return $SubtractposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    Add_Float_to_3PointFloats
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $posA : float
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] Add_Float_to_3PointFloats(float $posA, float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $AddposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $AddposA_AND_posB_float = {($posA + $posB[0]), ($posA + $posB[1]), ($posA + $posB[2])} ;
    return $AddposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    SubtractFloat_to_3PointFloats
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $posA : float
 *   $posB : float[]
 *
 * @returns      float[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] SubtractFloat_to_3PointFloats(float $posA, float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $SubtractposA_AND_posB_float[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SubtractposA_AND_posB_float = {($posA - $posB[0]), ($posA - $posB[1]), ($posA - $posB[2])} ;
    return $SubtractposA_AND_posB_float;

}


/******************************************************************************
 * @procedure    GetDegreesFromFloat
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      float
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float GetDegreesFromFloat(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $xy_angle = angle ($xvex, $yvex);
    float $Some_degrees = `rad_to_deg $xy_angle`;
    vector $xvex = << $posA[0], $posA[1], $posA[2] >>;
    vector $yvex = << $posB[0], $posB[1], $posB[2] >>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $xvex = << $posA[0], $posA[1], $posA[2] >> ;
    $yvex = << $posB[0], $posB[1], $posB[2] >> ;
    $xy_angle = angle ($xvex, $yvex) ;
    $Some_degrees = `rad_to_deg $xy_angle`;
    print $Some_degrees;
    return $Some_degrees;

}


/******************************************************************************
 * @procedure    GetDistanceBetweenCurveEnds
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $CurveItem : string[]
 *
 * @returns      float
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float GetDistanceBetweenCurveEnds(string $CurveItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    string $CurveSelection[];
    string $MakeXBetweenB[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA  )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    $dAx = $EACHCVposAZ[0] - $EACHCVposBZ[0]; $dAy = $EACHCVposAZ[1] - $EACHCVposBZ[1];
    $dAz = $EACHCVposAZ[2] - $EACHCVposBZ[2]; float $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    GetDistanceFLOAT
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $objectFirst : string
 *   $objectSecond : string
 *
 * @returns      float
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float GetDistanceFLOAT(string $objectFirst, string $objectSecond)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $pointAZ1[];
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pointAZ1 = `xform -query -worldSpace -translation ($objectFirst)`;
    $pointAZ2 = `xform -query -worldSpace -translation ($objectSecond)`;
    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    PointsGetDistanceFLOAT
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $pointAZ1 : float[]
 *   $pointAZ2 : float[]
 *
 * @returns      float
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float PointsGetDistanceFLOAT(float $pointAZ1[], float $pointAZ2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    return $distanceA2;

}


/******************************************************************************
 * @procedure    ZeroOrONE
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $objectLoc : string[]
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ZeroOrONE(string $objectLoc[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $X = size($objectLocZ) -1;
    int $Z = size($objectLocZ);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    int $Zero0rOne = 0;
    float $SubtractAB[];
    float $posA[];
    float $posB[];
    string $objectLocZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $objectLocZ = $objectLoc;
    $X = size($objectLocZ) -1;
    $Z = size($objectLocZ);
    $i = 1;
    $n = -1;
    $n2 = 0;
    $Zero0rOne = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){

    $posA = `xform -q -wd -translation $objectLocZ[$n]`;
    $posB = `xform -q -wd -translation $objectLocZ[$n2]`;
    $n2++;
    $SubtractAB = SubtractFloats($posA, $posB);
    if (($SubtractAB[0] == 0) && ($SubtractAB[1] == 0) && ($SubtractAB[2] == 0 )){
    print "yes AB";
    $Zero0rOne = 1;
    }
    }
    }
    return $Zero0rOne;

}


/******************************************************************************
 * @procedure    GetCurveCVposENDS
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $CurveItem : string[]
 *   $ix : int
 *
 * @returns      float[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] GetCurveCVposENDS(string $CurveItem[], int $ix)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    string $CurveSelection[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA  )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    if ($ix == 0){
    return $EACHCVposAZ; }
    if ($ix == 1){
    return $EACHCVposBZ; }

}


/******************************************************************************
 * @procedure    VecCurveEnds
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $CurveItem : string[]
 *
 * @returns      vector[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] VecCurveEnds(string $CurveItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numIntZB = 0;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    float $eachCVpos[];
    string $CurveSelection[];
    vector $VectorCurveEnds[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
    $numIntZB = 0;
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA  )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){
    $EACHCVposAZ = $eachCVpos;
    }
    if ( $numIntZB == 2 ){
    $EACHCVposBZ = $eachCVpos;
    }
    }
    $VectorCurveEnds[0] = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
    $VectorCurveEnds[1] = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;

    return $VectorCurveEnds;

}


/******************************************************************************
 * @procedure    MakeCurveBetweenFloats
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $posA : float[]
 *   $posB : float[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] MakeCurveBetweenFloats(float $posA[], float $posB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $ZBetween[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $ZBetween[0] = `curve -d 1 -p $posA[0] $posA[1] $posA[2] -p $posB[0] $posB[1] $posB[2] -k 0 -k 2 -n ZCurveBetween`;
    return $ZBetween;

}


/******************************************************************************
 * @procedure    MakeCleanFloats
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $FloatZ : float[]
 *
 * @returns      float[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] MakeCleanFloats(float $FloatZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroORZe1 = `gmatch "e" $nameAe`;
    int $zeroORZe2 = `gmatch "e" $nameBe`;
    int $zeroORZe3 = `gmatch "e" $nameCe`;
    string $POSAe = $FloatZ[0];
    string $POSCe = $FloatZ[2];
    string $nameAe;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $POSAe = $FloatZ[0]; string $POSBe = $FloatZ[1];
    $POSCe = $FloatZ[2];
    $nameAe = `match "e" $POSAe`;
    $nameBe = `match "e" $POSBe`;
    $nameCe = `match "e" $POSCe`;
    $zeroORZe1 = `gmatch "e" $nameAe`;
    $zeroORZe2 = `gmatch "e" $nameBe`;
    $zeroORZe3 = `gmatch "e" $nameCe`;
    if ( $zeroORZe1 == 1){ $FloatZ[0] = 0.0; }
    if ( $zeroORZe2 == 1){ $FloatZ[1] = 0.0; }
    if ( $zeroORZe3 == 1){ $FloatZ[2] = 0.0; }
    return $FloatZ;

}


/******************************************************************************
 * @procedure    MakeCleanFloat1
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $FloatZ : float
 *
 * @returns      float
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float MakeCleanFloat1(float $FloatZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroORZe1 = `gmatch "e" $nameAe`;
    string $POSAe = $FloatZ;
    string $nameAe;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $POSAe = $FloatZ;
    $nameAe = `match "e" $POSAe`;
    $zeroORZe1 = `gmatch "e" $nameAe`;
    if ( $zeroORZe1 == 1){ $FloatZ = 0.0; }
    return $FloatZ;

}


/******************************************************************************
 * @procedure    PercentDiff_Curve_to_Arc
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $arclenghtzARC : float
 *   $arclenghtzDRAWN : float
 *
 * @returns      float
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float PercentDiff_Curve_to_Arc(float $arclenghtzARC, float $arclenghtzDRAWN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $PercentA;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $PercentA = ((float($arclenghtzARC) / $arclenghtzDRAWN) * (100) );
    return $PercentA;

}


/******************************************************************************
 * @procedure    paramToCurvePts3
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $locatorShapes : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] paramToCurvePts3(string $locatorShapes[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $numLocators = size($locatorShapes);
    string $curveName[];
    string $parent1[] = `listRelatives -p $locatorShapes[$i]`;
    string $parent2[] = `listRelatives -p $parent1[0]`;
    string $parent3[] = `listRelatives -p $parent2[0]`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numLocators = size($locatorShapes);
    for( $i = 0; $i < $numLocators; $i ++ ) {
    // Get the parent transform above the locator shape
    $parent1 = `listRelatives -p $locatorShapes[$i]`;
    $parent2 = `listRelatives -p $parent1[0]`;
    $parent3 = `listRelatives -p $parent2[0]`;
    $curveName[ size($curveName) ] = $parent3[0];
    }
    return $curveName;

}


/******************************************************************************
 * @procedure    paramToCurvePts2
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $locatorShapes : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] paramToCurvePts2(string $locatorShapes[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroORZA;
    int $zeroORZB;
    int $i;
    int $numLocators = size($locatorShapes);
    float $parm;
    float $pos[] = `getAttr ($locatorShapes[$i] + ".localPosition")`;
    float $result[] = `getAttr ($pmm+".output")`;
    string $parent2A[];
    string $selectionList[];
    string $curveName;
    string $nameA;
    string $parent1[];
    string $parent2[];
    string $ObjectParZ1[];
    string $bufferCutCurveA[];
    string $numTokensZA;
    string $ObjectParZ2[];
    string $bufferCutCurveB[];
    string $numTokensZB;
    string $nameB;
    string $pmm;
    string $selectionItem = $curveName + ".u[" + $parm + "]";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════






    $numLocators = size($locatorShapes);
    for( $i = 0; $i < $numLocators; $i ++ ) {
    // Get the parent transform above the locator shape
    $parent1 = `listRelatives -p $locatorShapes[$i]`;

    $parent2 = `listRelatives -p $parent1[0]`;

    $ObjectParZ1 = `ls -tl 1 $parent2`;
    $numTokensZA = `tokenize $ObjectParZ1[0] "|" $bufferCutCurveA`;
    print $bufferCutCurveA[0];
    $ObjectParZ2 = ` ls -head 1 $parent2`;

    $numTokensZB = `tokenize $ObjectParZ2[0] "|" $bufferCutCurveB`;
    print $bufferCutCurveB[0];
    $nameA = `match "ACurve" $bufferCutCurveA[0]`;
    $zeroORZA = `gmatch "ACurve" $nameA`;
    $nameB = `match "ACurve" $bufferCutCurveB[0]`;
    $zeroORZB = `gmatch "ACurve" $nameB`;

    if ( $zeroORZA == 1){ $parent2A = {$bufferCutCurveA[0]};  }
    if ( $zeroORZB == 1){ $parent2A = {$bufferCutCurveA[0]};  }

    $curveName = $parent2A[0];
    if( `nodeType $curveName` != "nurbsCurve" ) continue;

    if( !catch($pmm = `createNode pointMatrixMult`) ) {
    $pos = `getAttr ($locatorShapes[$i] + ".localPosition")`;
    $parm = `getAttr ($parent1[0] + ".translateX")`;
    setAttr ($pmm +".inPoint") -type double3  $pos[0] $pos[1] $pos[2];
    setAttr ($pmm +".vectorMultiply") true ;
    connectAttr ($parent1[0]+".worldMatrix[0]") ($pmm+".inMatrix") ;
    $result = `getAttr ($pmm+".output")` ;
    $parm = $result[0];

    $selectionItem = $curveName + ".u[" + $parm + "]";
    $selectionList[ size($selectionList) ] = $selectionItem;

    delete $pmm;
    }
    }
    return $selectionList;

}


/******************************************************************************
 * @procedure    paramToCurvePts
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $locatorShapes : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] paramToCurvePts(string $locatorShapes[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $numLocators = size($locatorShapes);
    float $parm;
    float $pos[] = `getAttr ($locatorShapes[$i] + ".localPosition")`;
    float $result[] = `getAttr ($pmm+".output")`;
    string $selectionList[];
    string $curveName;
    string $parent1[] = `listRelatives -p $locatorShapes[$i]`;
    string $parent2[] = `listRelatives -p $parent1[0]`;
    string $pmm;
    string $selectionItem = $curveName + ".u["  + "0.0" + ":" + $parm + "]";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $numLocators = size($locatorShapes);
    for( $i = 0; $i < $numLocators; $i ++ ) {
    // Get the parent transform above the locator shape
    $parent1 = `listRelatives -p $locatorShapes[$i]`;

    $parent2 = `listRelatives -p $parent1[0]`;
    $curveName = $parent2[0];
    if( `nodeType $curveName` != "nurbsCurve" ) continue;

    if( !catch($pmm = `createNode pointMatrixMult`) ) {
    $pos = `getAttr ($locatorShapes[$i] + ".localPosition")`;
    $parm = `getAttr ($parent1[0] + ".translateX")`;
    setAttr ($pmm +".inPoint") -type double3  $pos[0] $pos[1] $pos[2];
    setAttr ($pmm +".vectorMultiply") true ;
    connectAttr ($parent1[0]+".worldMatrix[0]") ($pmm+".inMatrix") ;
    $result = `getAttr ($pmm+".output")` ;
    $parm = $result[0];

    $selectionItem = $curveName + ".u["  + "0.0" + ":" + $parm + "]";
    $selectionList[ size($selectionList) ] = $selectionItem;

    delete $pmm;
    }
    }
    return $selectionList;

}


/******************************************************************************
 * @procedure    tokenizeparam
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $paramANDCurveZ : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] tokenizeparam(string $paramANDCurveZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $num = size($paramANDCurveZ);
    string $selectionList[];
    string $bufferA[];
    string $selectionItem = $bufferA[0];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $num = size($paramANDCurveZ);
    for( $i = 0; $i < $num; $i ++ ) {
    $numTokensA = `tokenize $paramANDCurveZ[$i] "." $bufferA`;
    $selectionItem = $bufferA[0];
    $selectionList[ size($selectionList) ] = $selectionItem;
    }
    return $selectionList;

}


/******************************************************************************
 * @procedure    EvalMoveCurvesTOend
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $paramANDCurveZ : string[]
 *   $paramCurveNAMEZ : string[]
 *   $paramANDCurve3 : string[]
 *   $AllparamlocatorZ : string[]
 *   $set : string
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] EvalMoveCurvesTOend(string $paramANDCurveZ[], string $paramCurveNAMEZ[], string $paramANDCurve3[], string $AllparamlocatorZ[], string $set)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $iX;
    int $numparamANDCurveNAMEZ = size($paramCurveNAMEZ);
    int $arclenghtzIntTIMES = ($arclenghtzIntersectZ * 1000);
    int $arclenghtzTOTALnumTIMEZ = ($arclenghtzALL *1000);
    int $PercentA;
    int $numCVs = `getAttr -size ($paramCurveNAMEZ[$i] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    float $arclenghtzIntersectZ = `eval("arclen" + " " + $paramANDCurveZ[$i])`;
    float $arclenghtzALL = `arclen $paramCurveNAMEZ[$i]`;
    string $SEspaceLocSet;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $iX = -1;
    $numparamANDCurveNAMEZ = size($paramCurveNAMEZ);

    for( $i = 0; $i < $numparamANDCurveNAMEZ; $i ++ ) {

    $arclenghtzIntersectZ = `eval("arclen" + " " + $paramANDCurveZ[$i])`;
    $arclenghtzALL = `arclen $paramCurveNAMEZ[$i]`;

    $arclenghtzIntTIMES = ($arclenghtzIntersectZ * 1000) ;
    $arclenghtzTOTALnumTIMEZ = ($arclenghtzALL *1000) ;
    //asume there is only one curve intersect
    $PercentA = ((float($arclenghtzIntTIMES) / $arclenghtzTOTALnumTIMEZ) * (100) );

    if (( $PercentA > 85 ) || ( $PercentA < 15 )){
    $numCVs = `getAttr -size ($paramCurveNAMEZ[$i] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($paramCurveNAMEZ[$i] + ".cv[0]") ;
    $CurveSelection[1] = ($paramCurveNAMEZ[$i] + ".cv[" + $numCVrealNum + "]") ;

    if ( $PercentA > 85 ) {
    // move to curve end
    $MakespaceLocatorEND = `spaceLocator -p 0 0 0 -n SEspaceLocatorEND3DZ`;
    $eachCVposEND = `pointPosition -w ($CurveSelection[1])`;
    move  -ws $eachCVposEND[0] $eachCVposEND[1] $eachCVposEND[2] $MakespaceLocatorEND[0];
    appendStringArray($MakespaceLocatorSE, $MakespaceLocatorEND, 1);
    }

    if ( $PercentA < 15 ) {
    $MakespaceLocatorSTART = `spaceLocator -p 0 0 0 -n SEspaceLocatorSTART3DZ`;
    $eachCVposSTART = `pointPosition -w ($CurveSelection[0])`;
    move  -ws $eachCVposSTART[0] $eachCVposSTART[1] $eachCVposSTART[2] $MakespaceLocatorSTART;
    appendStringArray($MakespaceLocatorSE, $MakespaceLocatorSTART, 1);

    }
    }

    if (( $PercentA < 85 ) && ( $PercentA > 15 )){
    $iX = $iX +1;
    select -cl;
    print $AllparamlocatorZ[$i];
    print ("_____not near ends_____" + "\n");
    $SEspaceLocSet = `sets -name SEisnotLocSESet[$iX]`;
    sets -include $SEspaceLocSet $paramANDCurve3[$i];
    sets -include $SEspaceLocSet $AllparamlocatorZ[$i];
    sets -include $set $SEspaceLocSet;
    }
    }
    return $MakespaceLocatorSE;

}


/******************************************************************************
 * @procedure    GET_AREA_OF_CURVE
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $obj : string[]
 *
 * @returns      float
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float GET_AREA_OF_CURVE(string $obj[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numcvs = size($numcvnames);
    float $area = 0;
    float $centroid[] = `xform -q -ws -t ($obj[0])`;
    float $pos0[] = `eval $getpos0`;
    float $pos1[] = `eval $getpos1`;
    float $aP = `distanceBetween {$centroid[0],$centroid[1],$centroid[2]} {$pos0[0],$pos0[1],$pos0[2]}`;
    float $bP = `distanceBetween {$pos0[0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1[2]}`;
    float $cP = `distanceBetween {$pos1[0],$pos1[1],$pos1[2]} {$centroid[0],$centroid[1],$centroid[2]}`;
    float $triarea = 0.25* sqrt ( ($aP+$bP+$cP) * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP) );
    string $CurveItemA = $obj[0];
    string $numcvnames[] = `ls -fl ($CurveItemA+".cv[*]")`;
    string $cvname0 = $obj[0] + ".cv[" + $iC + "]";
    string $getpos0 = "pointPosition " + $cvname0;
    string $cvname1 = $obj[0] + ".cv[" + ($iC+1) + "]";
    string $getpos1 = "pointPosition " + $cvname1;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $area = 0;
    $centroid = `xform -q -ws -t ($obj[0])`;
    $CurveItemA = $obj[0];
    $numcvnames = `ls -fl ($CurveItemA+".cv[*]")`;
    $numcvs = size($numcvnames);

    for ($iC=0;$iC<$numcvs;$iC++){
    if ($iC<($numcvs-1)){
    $cvname0 = $obj[0] + ".cv[" + $iC + "]";
    $getpos0 = "pointPosition " + $cvname0;
    $pos0 = `eval $getpos0`;
    $cvname1 = $obj[0] + ".cv[" + ($iC+1) + "]";
    $getpos1 = "pointPosition " + $cvname1;
    $pos1 = `eval $getpos1`;
    $pos0 = `MakeCleanFloats($pos0)`;
    $pos1 = `MakeCleanFloats($pos1)`;

    $aP = `distanceBetween {$centroid[0],$centroid[1],$centroid[2]} {$pos0[0],$pos0[1],$pos0[2]}`;
    $bP = `distanceBetween {$pos0[0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1[2]}`;
    $cP = `distanceBetween {$pos1[0],$pos1[1],$pos1[2]} {$centroid[0],$centroid[1],$centroid[2]}`;
    $triarea = 0.25* sqrt ( ($aP+$bP+$cP) * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP) );
    clear $pos0;
    clear $pos1;
    $area = $area + $triarea;


    } else{
    $cvname0 = $obj[0] + ".cv[" + $iC + "]";
    $getpos0 = "pointPosition " + $cvname0;
    $pos0 = `eval $getpos0`;
    $cvname1 = $obj[0] + ".cv[" + ($iC+1) + "]";
    $getpos1 = "pointPosition " + $cvname1;
    $pos1 = `eval $getpos1`;
    $pos0 = `MakeCleanFloats($pos0)`;
    $pos1 = `MakeCleanFloats($pos1)`;
    $aP = `distanceBetween {$centroid[0],$centroid[1],$centroid[2]} {$pos0[0],$pos0[1],$pos0[2]}`;
    $bP = `distanceBetween {$pos0[0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1[2]}`;
    $cP = `distanceBetween {$pos1[0],$pos1[1],$pos1[2]} {$centroid[0],$centroid[1],$centroid[2]}`;
    $triarea = 0.25* sqrt ( ($aP+$bP+$cP) * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP) );
    clear $pos0;
    clear $pos1;
    $area = $area + $triarea;
    }
    }
    clear $numcvnames;
    return $area;

}


/******************************************************************************
 * @procedure    Make_Middle_of_Curve_ParamlocatorZ002
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $objectCurveSelected : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Make_Middle_of_Curve_ParamlocatorZ002(string $objectCurveSelected[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $numCVrealNumDivide = $numCVrealNum / 2;
    int $i = 1;
    float $arclenghtzALL = `arclen $objectCurveSelected`;
    float $arclenghtzDivide = $arclenghtzALL / 2.0;
    float $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;
    float $arclenghtzHalf = `arclen ($objectCurveSelected[0] + ".u[0.0:" + $numCVrealNumDivide + "]")`;
    float $arclenghtzHalfROUNDED = `RoundfloatingPointoff($arclenghtzHalf)`;
    float $iz = 0.0;
    float $iX = float($numCVrealNumDivide);
    float $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    float $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
    float $posA[];
    float $posB[];
    float $posC[];
    string $paramANDCurve[] = `paramToCurvePts( $paramlocatorZARC )`;
    string $CircularArcFromCurve[];
    string $ArcCurve[];
    string $ParentArc[];
    string $ArcZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $arclenghtzALL = `arclen $objectCurveSelected`;
    $arclenghtzDivide = $arclenghtzALL / 2.0;
    $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;
    $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectCurveSelected[0] + ".cv[0]") ;
    $CurveSelection[1] = ($objectCurveSelected[0] + ".cv[" + $numCVrealNum + "]") ;
    $numCVrealNumDivide = $numCVrealNum / 2;
    if ($numCVrealNumDivide > 2){ $numCVrealNumDivide = $numCVrealNumDivide -1; }
    $arclenghtzHalf = `arclen ($objectCurveSelected[0] + ".u[0.0:" + $numCVrealNumDivide + "]")`;
    $arclenghtzHalfROUNDED = `RoundfloatingPointoff($arclenghtzHalf)`;
    $iz = 0.0; int $M;
    if ( $arclenghtzDivideROUNDED > $arclenghtzHalfROUNDED){
    print "Greater_then"; $M = 0;  $iz = 0.01;}
    if ( $arclenghtzDivideROUNDED < $arclenghtzHalfROUNDED){
    print "Less_then"; $M = 1; $iz = -0.01;}
    $paramlocatorZARC[0] = eval("paramLocator " +  $objectCurveSelected[0] + ".u[" + $numCVrealNumDivide + "]");
    $iX = float($numCVrealNumDivide);
    $i = 1;
    while ($i > 0){
    $iX = $iX + $iz;
    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $iX;
    $paramANDCurve = `paramToCurvePts( $paramlocatorZARC )`;
    $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
    if($M == 0){
    if (($arclenghtzparamZROUNDED == $arclenghtzDivideROUNDED) || ($arclenghtzparamZROUNDED > $arclenghtzDivideROUNDED)){
    $i = 0; }
    }
    if($M == 1){
    if (($arclenghtzparamZROUNDED == $arclenghtzDivideROUNDED) || ($arclenghtzparamZROUNDED < $arclenghtzDivideROUNDED)){
    $i = 0; }
    }
    }
    $posA = `pointPosition -w $CurveSelection[0]`;
    $posB = `pointPosition -w $paramlocatorZARC[0]`;
    $posC = `pointPosition -w $CurveSelection[1]`;
    $CircularArcFromCurve[0] = `createNode makeThreePointCircularArc`;
    setAttr ($CircularArcFromCurve[0] + ".pt1") $posA[0] $posA[1] $posA[2] ;
    setAttr ($CircularArcFromCurve[0] + ".pt2") $posB[0] $posB[1] $posB[2];
    setAttr ($CircularArcFromCurve[0] + ".pt3") $posC[0] $posC[1] $posC[2];
    setAttr ($CircularArcFromCurve[0] + ".d") 3;
    setAttr ($CircularArcFromCurve[0] + ".s") 8;
    $ArcCurve[0] = `createNode nurbsCurve` ;
    connectAttr ($CircularArcFromCurve[0] + ".oc") ($ArcCurve[0] +".cr");
    //delete $objectCurveSelected;
    $ParentArc = `listRelatives -parent $ArcCurve`;
    ResetTranlation($ParentArc);

    $ArcZ[0] = `rename $ParentArc $objectCurveSelected`;
    delete $paramlocatorZARC;
    select -r $ArcZ;
    return $ArcZ;


}


/******************************************************************************
 * @procedure    RoundfloatingPointoff
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $floatingPointNumZ : float
 *
 * @returns      float
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float RoundfloatingPointoff(float $floatingPointNumZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $roundoff = $floatingPointNumZ *100;
    float $roundoff2 = float($roundoff) * 0.01;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $roundoff = $floatingPointNumZ *100;
    $roundoff2 = float($roundoff) * 0.01;
    return $roundoff2;

}


/******************************************************************************
 * @procedure    Make_Middle_of_Curve_ParamlocatorFloat
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $objectCurveSelected : string[]
 *
 * @returns      float[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] Make_Middle_of_Curve_ParamlocatorFloat(string $objectCurveSelected[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i = 1;
    float $arclenghtzALL = `arclen $objectCurveSelected`;
    float $arclenghtzDivide = $arclenghtzALL / 2.0;
    float $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;
    float $iX = 0.00;
    float $posB[];
    float $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    float $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
    string $posALL[];
    string $paramANDCurve[] = `paramToCurvePts( $paramlocatorZARC )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $arclenghtzALL = `arclen $objectCurveSelected`;
    $arclenghtzDivide = $arclenghtzALL / 2.0;
    $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;
    $paramlocatorZARC[0] = eval("paramLocator " +  $objectCurveSelected[0] + ".u[" + 0.00 + "]");
    $iX = 0.00;
    $i = 1;
    while ($i > 0){
    $iX = $iX + 0.01;
    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $iX;
    $paramANDCurve = `paramToCurvePts( $paramlocatorZARC )`;
    $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
    if (($arclenghtzparamZROUNDED == $arclenghtzDivideROUNDED) || ($arclenghtzparamZROUNDED > $arclenghtzDivideROUNDED)){
    $i = 0;
    }
    }
    $posB = `pointPosition -w $paramlocatorZARC[0]`;
    delete $paramlocatorZARC;
    return $posB ;

}


/******************************************************************************
 * @procedure    distanceBetween
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $loc1 : float[]
 *   $loc2 : float[]
 *
 * @returns      float
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float distanceBetween(float $loc1[], float $loc2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $a = `pow ($loc2[0] - $loc1[0]) 2`;
    float $b = `pow ($loc2[1] - $loc1[1]) 2`;
    float $c = `pow ($loc2[2] - $loc1[2]) 2`;
    float $distance = `sqrt ( $a+$b+$c )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $a = `pow ($loc2[0] - $loc1[0]) 2`;
    $b = `pow ($loc2[1] - $loc1[1]) 2`;
    $c = `pow ($loc2[2] - $loc1[2]) 2`;
    $distance = `sqrt ( $a+$b+$c )`;
    return $distance;

}


/******************************************************************************
 * @procedure    FindIfCurveCrossesZ
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $rebuildit : string[]
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindIfCurveCrossesZ(string $rebuildit[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $ZeroOneORTwo;
    int $numCVs = `getAttr -size ($rebuildit[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $zeroOR1Z = `gmatch "-" $nameA`;
    int $zeroOR2Z = `gmatch "-" $nameB`;
    int $zeroOR1Ze = `gmatch "e" $nameAe`;
    int $zeroOR2Ze = `gmatch "e" $nameBe`;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    string $CurveSelection[];
    string $POSA = $EACHCVposAZ[0];
    string $nameA;
    string $POSB = $EACHCVposBZ[0];
    string $nameB;
    string $POSAe = `abs $EACHCVposAZ[0]`;
    string $POSBe = `abs $EACHCVposBZ[0]`;
    string $nameAe;
    string $nameBe;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($rebuildit[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;
    $CurveSelection[1] = ($rebuildit[0] + ".cv[" + $numCVrealNum + "]") ;
    $EACHCVposAZ = `pointPosition -w ( $CurveSelection[0]  )`;
    $EACHCVposBZ = `pointPosition -w ( $CurveSelection[1]  )`;
    $POSA = $EACHCVposAZ[0];
    $nameA = `match "-" $POSA`;
    $zeroOR1Z = `gmatch "-" $nameA`;
    $POSB = $EACHCVposBZ[0];
    $nameB = `match "-" $POSB`;
    $zeroOR2Z = `gmatch "-" $nameB`;
    $ZeroOneORTwo = $zeroOR1Z + $zeroOR2Z;
    $POSAe = `abs $EACHCVposAZ[0]`;
    $POSBe = `abs $EACHCVposBZ[0]`;
    $nameAe = `match "e" $POSAe`;
    $nameBe = `match "e" $POSBe`;
    $zeroOR1Ze = `gmatch "e" $nameAe`;
    $zeroOR2Ze = `gmatch "e" $nameBe`;
    if (($zeroOR1Ze == 1 ) || ($zeroOR2Ze == 1 )){
    print "is Zero";
    $ZeroOneORTwo = 0;
    print $ZeroOneORTwo;
    }
    return $ZeroOneORTwo;

}


/******************************************************************************
 * @procedure    GetDistance
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $objectFirst : string
 *   $objectSecond : string
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int GetDistance(string $objectFirst, string $objectSecond)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $distanceA2roundoff;
    float $pointAZ1[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pointAZ1 = `xform -query -worldSpace -translation ($objectFirst)`;
    $pointAZ2 = `xform -query -worldSpace -translation ($objectSecond)`;
    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    $distanceA2roundoff = $distanceA2;
    return $distanceA2roundoff;

}


/******************************************************************************
 * @procedure    CutCurveIFConditionTRUETransitZ
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $rebuildit : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CutCurveIFConditionTRUETransitZ(string $rebuildit[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $XiScaleTimes;
    int $XiScale;
    int $ZeroOneORTwoZ = FindIfCurveCrossesZ($rebuildit);
    int $numTokensZa;
    int $X = 0;
    int $zeroOR1Z = `gmatch "-" $nameA`;
    int $zeroOR2Z = `gmatch "-" $nameB`;
    float $CURVEAposA[];
    float $CURVEA_AREA = `GET_AREA_OF_CURVE($rebuildit)`;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    string $remainingCurve[];
    string $ZcutingplaneZZ[];
    string $curveIntersectZ[];
    string $intersectZZCUT[];
    string $iSurfZ[] = `extrude -ch 1 -et 0 -l 0.5 -n AxisSelectionZ ( $rebuildit )`;
    string $buffer[];
    string $paramlocatorZ[];
    string $paramANDCurve[];
    string $curvesZ[];
    string $curveZ0[];
    string $curveZ1[];
    string $POSA = $EACHCVposAZ[0];
    string $nameA;
    string $POSB = $EACHCVposBZ[0];
    string $nameB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $ZeroOneORTwoZ = FindIfCurveCrossesZ($rebuildit);
    if ($ZeroOneORTwoZ == 1){
    $CURVEAposA = `xform -query -worldSpace -translation $rebuildit[0]`;
    $CURVEA_AREA = `GET_AREA_OF_CURVE($rebuildit)`;
    $ZcutingplaneZZ = `nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr 1 -n "ZcutingplaneZZ"`;
    setAttr "ZcutingplaneZZ.rotateZ" 90;
    $XiScale = GetDistance($rebuildit[0], $ZcutingplaneZZ[0]);
    $XiScaleTimes = ($XiScale * 3) + $CURVEA_AREA;
    scale -r $XiScaleTimes $XiScaleTimes $XiScaleTimes $ZcutingplaneZZ;
    $iSurfZ = `extrude -ch 1 -et 0 -l 0.5 -n AxisSelectionZ ( $rebuildit )`;
    $intersectZZCUT = `intersect -ch 0 -cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ $iSurfZ[0] $ZcutingplaneZZ[0]`;
    select -r $intersectZZCUT;
    $curveIntersectZ[0] = `curveIntersect -ch 0 -tolerance 0.00001 $intersectZZCUT $rebuildit[0]`;
    $numTokensZa = `tokenize $curveIntersectZ[0] " " $buffer`;
    $paramlocatorZ[0] = `eval("paramLocator " +  $rebuildit[0] + ".u[" + $buffer[1] + "]")`;
    $X = 0;
    $paramANDCurve  = `paramToCurvePts2( $paramlocatorZ)`;
    $curvesZ = `detachCurve -ch 1 -cos on -rpo 1 $paramANDCurve`;
    $curveZ0[0] = $curvesZ[0];
    $curveZ1[0] = $curvesZ[1];
    ResetTranlation($curveZ0);
    ResetTranlation($curveZ1);
    $EACHCVposAZ = `xform -query -worldSpace -translation ( $curvesZ[0]  )`;
    $EACHCVposBZ = `xform -query -worldSpace -translation ( $curvesZ[1]  )`;
    $POSA = $EACHCVposAZ[0];
    $nameA = `match "-" $POSA`;
    $zeroOR1Z = `gmatch "-" $nameA`;
    $POSB = $EACHCVposBZ[0];
    $nameB = `match "-" $POSB`;
    $zeroOR2Z = `gmatch "-" $nameB`;
    if ($zeroOR1Z == 1){
    delete $curvesZ[0];
    $X = 1; }
    if ($zeroOR2Z == 1){
    delete $curvesZ[1];
    $X = 2;}
    if ($X == 2){
    select -r $curvesZ[0]; }
    if ($X == 1){
    select -r $curvesZ[1]; }
    $remainingCurve = `ls -sl`;
    delete $intersectZZCUT $ZcutingplaneZZ AxisSelectionZ ;
    }
    $rebuildit = $remainingCurve;
    return $remainingCurve;

}


/******************************************************************************
 * @procedure    FindIfCurveISonZ
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $rebuildit : string[]
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindIfCurveISonZ(string $rebuildit[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iZ = 0;
    int $numCVs = `getAttr -size ($rebuildit[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $zeroOR1Z = `gmatch "e" $ScientNotationNameA`;
    int $zeroOR2Z = `gmatch "e" $ScientNotationNameB`;
    float $EACHCVposAZ[];
    float $EACHCVposBZ[];
    string $CurveSelection[];
    string $POSA = $EACHCVposAZ[0];
    string $ScientNotationNameA;
    string $POSB = $EACHCVposBZ[0];
    string $ScientNotationNameB;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $iZ = 0;
    $numCVs = `getAttr -size ($rebuildit[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;
    $CurveSelection[1] = ($rebuildit[0] + ".cv[" + $numCVrealNum + "]") ;
    $EACHCVposAZ = `pointPosition -w ( $CurveSelection[0]  )`;
    $EACHCVposBZ = `pointPosition -w ( $CurveSelection[1]  )`;
    $POSA = $EACHCVposAZ[0];
    $ScientNotationNameA = `match "e" $POSA`;
    $zeroOR1Z = `gmatch "e" $ScientNotationNameA`;
    if (($EACHCVposAZ[0] == 0) || ($zeroOR1Z == 1)){
    print "yes";
    $iZ = $iZ + 1;
    }
    $POSB = $EACHCVposBZ[0];
    $ScientNotationNameB = `match "e" $POSB`;
    $zeroOR2Z = `gmatch "e" $ScientNotationNameB`;
    if (($EACHCVposBZ[0] == 0) || ($zeroOR2Z == 1)){
    print "yes";
    $iZ = $iZ + 1;
    }
    return $iZ;

}


/******************************************************************************
 * @procedure    ArrayInsertAtEnd
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $INarray : string[]
 *   $NewItem : string
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ArrayInsertAtEnd(string $INarray[], string $NewItem)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArray;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArray = size($INarray);
    $INarray[$SizeOfArray] = ( $NewItem );
    return $SizeOfArray;

}


/******************************************************************************
 * @procedure    positionOne
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $eachZA : string
 *
 * @returns      float[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] positionOne(string $eachZA)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $eachCVpos[] = `pointPosition -w $eachZA`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $eachCVpos = `pointPosition -w $eachZA`;
    return $eachCVpos;

}


/******************************************************************************
 * @procedure    stringArrayGmatch
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int stringArrayGmatch(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    for ($listItem in $list) {
    if ( `gmatch $listItem $item` == 1){
    $result = true;
    break;	}
    }
    return $result;

}


/******************************************************************************
 * @procedure    FindclosetTOcurveENDz
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $a1 : float[]
 *   $a2 : float[]
 *   $b1 : float[]
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindclosetTOcurveENDz(float $a1[], float $a2[], float $b1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $binaryAnswer;
    float $distance1;
    float $distance2;
    float $pointA1[];
    float $pointA2[];
    float $pointB1[];
    float $dAx;
    float $dAy;
    float $dAz;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pointA1 = $a1;
    $pointA2 = $b1;
    $dAx = $pointA1[0] - $pointA2[0];
    $dAy = $pointA1[1] - $pointA2[1];
    $dAz = $pointA1[2] - $pointA2[2];
    $distanceA = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    $distance1 = $distanceA;
    $pointB1 = $a2;
    $dAx = $pointB1[0] - $pointA2[0];
    $dAy = $pointB1[1] - $pointA2[1];
    $dAz = $pointB1[2] - $pointA2[2];
    $distanceB = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    $distance2 = $distanceB;
    if ($distance1 < $distance2){
    $binaryAnswer = 0;
    return $binaryAnswer;
    }
    if ( $distance2 < $distance1 ){
    $binaryAnswer = 1;
    return $binaryAnswer;
    }


}


/******************************************************************************
 * @procedure    NearestObjectArray
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $n : int
 *   $ItemsSelectedinArray : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] NearestObjectArray(int $n, string $ItemsSelectedinArray[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $NearestObjectN = $n;
    int $indexN = 0;
    int $NearestObjectNumbers = $NearestObjectN;
    int $array1Number = $array1Count;
    int $curvenumbers = $CompareAllShapesCount;
    float $pointA1[];
    float $pointA2[];
    float $distanceA;
    float $pointB1[];
    float $pointB2[];
    float $distanceB;
    string $NearestCurvesZ[];
    string $array1[] = $ItemsSelectedinArray;
    string $array2[] = $ItemsSelectedinArray;
    string $arrayMainObject1[] = $ItemsSelectedinArray;
    string $array1Count = size ($array1) -1;
    string $diff[] = stringArrayRemoveExact($array1, $arrayMainObject1);
    string $CompareAllShapesCount = size ($array1);
    string $oneitem[];
    string $arrayLast[] = stringArrayRemoveExact($oneitem, $arrayMainObject1);
    string $return[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $NearestObjectN = $n;
    $numIntx = size($NearestCurvesZ);
    if ( $numIntx > 0 ){
    clear $NearestCurvesZ;
    }
    $array1 = $ItemsSelectedinArray;
    $array2 = $ItemsSelectedinArray;
    $arrayMainObject1 = $ItemsSelectedinArray;
    $indexN = 0;
    $NearestObjectNumbers = $NearestObjectN;
    $ObjN = 0;
    $ObjN2 = 0;
    while($ObjN++ < $NearestObjectNumbers ){
    $array1Count = size ($array1) -1;
    $array1Number = $array1Count;
    stringArrayRemoveAtIndex($array1Count, $array1);
    $diff = stringArrayRemoveExact($array1, $arrayMainObject1);
    $CompareAllShapesCount = size ($array1);
    $curvenumbers = $CompareAllShapesCount;
    $i = 1;
    while($i++ < $curvenumbers ){
    //DISTANCE A
    $pointA1 = `xform -query -worldSpace -translation ( $diff)`;
    $pointA2 = `xform -query -worldSpace -translation ($array1[0])`;
    $dAx = $pointA1[0] - $pointA2[0];
    $dAy = $pointA1[1] - $pointA2[1];
    $dAz = $pointA1[2] - $pointA2[2];
    $distanceA = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
    //DISTANCE B
    $pointB1 = `xform -query -worldSpace -translation ( $diff)`;
    $pointB2 = `xform -query -worldSpace -translation ( $array1[1])`;
    $dBx = $pointB1[0] - $pointB2[0];
    $dBy = $pointB1[1] - $pointB2[1];
    $dBz = $pointB1[2] - $pointB2[2];
    $distanceB = `sqrt( ($dBx * $dBx) + ($dBy * $dBy) + ($dBz * $dBz) )`;
    if( $distanceA < $distanceB ){
    stringArrayRemoveAtIndex(1, $array1);
    }
    if( $distanceA > $distanceB ){
    stringArrayRemoveAtIndex(0, $array1);
    }
    }
    appendStringArray($NearestCurvesZ, $array1, 1);
    $oneitem[0] = $array1[0];
    $arrayLast = stringArrayRemoveExact($oneitem, $arrayMainObject1);
    $array1 = $arrayLast;
    $array2 = $arrayLast;
    $arrayMainObject1 = $arrayLast;
    $indexN++;
    stringArrayInsertAtIndex(($indexN), $ArrayTwoObjectX, $arrayLast[0]);
    }
    clear $array1;
    clear $array2;
    clear $arrayMainObject1;
    $return = $NearestCurvesZ;
    return $return;

}


/******************************************************************************
 * @procedure    CreateCAMforIntCurveScript
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] CreateCAMforIntCurveScript()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectZcurv[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $LocatorLoop = 0;
    float $eachCVpos[];
    string $CamConeLocator[];
    string $CurveSelection[];
    string $each;
    string $MakespaceLocator[];
    string $objectZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    CreateCameraOnly;
    rename ZCURVEModelingCAM;
    lookThroughModelPanelClipped ZCURVEModelingCAM modelPanel4 0.001 1000;
    nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr 1 -n "LiveSurfaceB";
    editDisplayLayerMembers -noRecurse layerYZYXPlains "LiveSurfaceB";


    //////////////////
    clear $CamConeLocator;
    curve -d 3 -p 0 0 0 -p 0 0 -4 -p 0 0 -8 -p 0 0 -12 -k 0 -k 0 -k 0 -k 12 -k 12 -k 12 -n Deletethiscurve ;
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    $objectZcurv = `ls -sl`;
    $numCVs = `getAttr -size ($objectZcurv[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectZcurv[0] + ".cv[0]") ;
    $CurveSelection[1] = ($objectZcurv[0] + ".cv[" + $numCVrealNum + "]") ;
    for ($each in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $each  )`;
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n LocatorA`;
    ArrayInsertAtEnd($CamConeLocator, $MakespaceLocator[0]);
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos[2] $MakespaceLocator[0];
    }
    $LocatorLoop = 0; int $LocatorLoopA = -1;
    while ($LocatorLoop++ < 7) {
    $LocatorLoopA = $LocatorLoopA +1;
    if ($LocatorLoopA == 0){
    clear $objectZ;
    stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
    stringArrayInsertAtIndex(1, $objectZ, "LocatorA1");
    }
    if ($LocatorLoopA > 0){
    clear $objectZ;
    stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
    stringArrayInsertAtIndex(1, $objectZ, $MakespaceLocator[0]);
    }
    if ($LocatorLoopA < 7){
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n LocatorMiddleDistance`;
    ArrayInsertAtEnd($CamConeLocator, $MakespaceLocator[0]);
    averagingNode($objectZ[0], $MakespaceLocator[0], $objectZ[1]);
    }
    }
    ArrayInsertAtEnd( $CamConeLocator, $CamConeLocator[0]);
    stringArrayRemoveAtIndex(0, $CamConeLocator);
    parentConstraint -mo -weight 1 ZCURVEModelingCAM LocatorA1 ;
    parentConstraint -mo -weight 1 ZCURVEModelingCAM LocatorA;
    delete  Deletethiscurve;
    align -atl -x Mid -y Mid -z Mid LiveSurfaceB ZCURVEModelingCAM;
    move -r -os -wd 0 5 5 ZCURVEModelingCAM ;
    setAttr "ZCURVEModelingCAM.rotateX" -45;
    setAttr "LiveSurfaceB.rotateX" (`getAttr ("ZCURVEModelingCAM" + ".rotateX")`+90);
    setAttr "LiveSurfaceB.rotateY" `getAttr ("ZCURVEModelingCAM" + ".rotateY")`;
    setAttr "LiveSurfaceB.rotateZ" `getAttr ("ZCURVEModelingCAM" + ".rotateZ")`;
    align -atl -x Mid -y Mid -z Mid LiveSurfaceB ZCURVEModelingCAM;
    move -r -os -wd 0 -1 0 LiveSurfaceB ;
    parentConstraint -mo -weight 1 ZCURVEModelingCAM LiveSurfaceB;
    setAttr "ZCURVEModelingCAM.translateX" 48 ;
    setAttr "ZCURVEModelingCAM.translateY" 41 ;
    setAttr "ZCURVEModelingCAM.translateZ" 48 ;
    setAttr "ZCURVEModelingCAM.rotateX" -25 ;
    setAttr "ZCURVEModelingCAM.rotateY" 45;
    setAttr "ZCURVEModelingCAM.rotateZ" 0;
    return $CamConeLocator;

}


/******************************************************************************
 * @procedure    StartofCurveScriptIntersectZX
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] StartofCurveScriptIntersectZX()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectcurv[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    float $EACHCVposA[];
    float $EACHCVposB[];
    float $eachCVpos[];
    string $digitalSkeleton[];
    string $objectcurv[];
    string $CurveSelection[];
    string $AllIntersectCurveZ[];
    string $IntersectCurves[];
    string $MakeExtrudeSurface[];
    string $MakeBirailSurface[];
    string $MakeXBetween[];
    string $MakeIntersectCurvez[];
    string $MakespaceLocator[];
    string $each;
    string $curveFromSurfaceDup[] = `duplicateCurve -ch 1 -rn 0 -local 0  "SurfaceinterectCurves.u[1]"`;
    string $curveFromSurfaceLoft[] = `loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 4 -rn 1 -po 0 -rsn true -n IntersectLoftZ $curveFromSurfaceDup[0]   $objectcurv`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    Removefromsurface;

    //
    $numInts = size($digitalSkeleton);
    if ( $numInts > 0 ){
    clear $digitalSkeleton;
    }
    $objectcurv = `ls -sl`;
    ///////////////GATHER ALL BUILDING STRUCTURE/////////##
    appendStringArray($digitalSkeleton, $objectcurv, 1);
    /////////////////////////////////////////////////////##
    $numCVs = `getAttr -size ($objectcurv[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectcurv[0] + ".cv[0]") ;
    $CurveSelection[1] = ($objectcurv[0] + ".cv[" + $numCVrealNum + "]") ;

    $numInts = size($AllIntersectCurveZ);
    if ( $numInts > 0 ){
    clear $AllIntersectCurveZ;
    }

    for ($each in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $each  )`;
    $MakespaceLocator = `spaceLocator -p 0 0 0 -n IntersectZLocaterZ3D`;
    $MakeIntersectCurvez[0] = `curve -d 1 -p 0 0 0 -p 12 0 0 -k 0 -k 1 -n IntersectCurve` ;
    appendStringArray($AllIntersectCurveZ, $MakeIntersectCurvez, 1);
    appendStringArray($digitalSkeleton, $MakespaceLocator, 1);
    $numInts = size($AllIntersectCurveZ);
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos[2] $MakespaceLocator[0];
    move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos[2] $MakeIntersectCurvez[0];
    aimConstraint -offset 0 0 0 -weight 0.5 -aimVector -1 0 0 -upVector 0 0 -1 -worldUpType "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM   $MakeIntersectCurvez[0];
    if ( $numInts == 1 ){
    $EACHCVposA = $eachCVpos;
    }
    if ( $numInts == 2 ){
    $EACHCVposB = $eachCVpos;
    $MakeXBetween[0] = `curve -d 1 -p $EACHCVposA[0] $EACHCVposA[1] $EACHCVposA[2] -p $EACHCVposB[0] $EACHCVposB[1] $EACHCVposB[2] -k 0 -k 2 -n   XCurveBetween`;
    appendStringArray($digitalSkeleton, $MakeXBetween, 1);
    }
    }

    $MakeExtrudeSurface = `extrude -ch true -rn 0 -po 0 -et 0 -upn 0 -fixedPath 1 -d 0 0 0 -length 3 -rotation 0 -scale 1 -dl 3 -n CURVEZextrude   $objectcurv` ;

    $MakeBirailSurface = `singleProfileBirailSurface -ch 1 -po 0 -tm 1 -tp1 0 -n SurfaceinterectCurves CURVEZextrude.v[0] $AllIntersectCurveZ[0]   $AllIntersectCurveZ[1]`;

    $curveFromSurfaceDup = `duplicateCurve -ch 1 -rn 0 -local 0  "SurfaceinterectCurves.u[1]"` ;
    $curveFromSurfaceLoft = `loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 4 -rn 1 -po 0 -rsn true -n IntersectLoftZ $curveFromSurfaceDup[0]   $objectcurv` ;

    // Result: duplicatedCurve1 curveFromSurfaceIso2 //


    // GATHER ALL BUILDING STRUCTURE//
    appendStringArray($digitalSkeleton, $curveFromSurfaceDup, 1);
    appendStringArray($digitalSkeleton, $curveFromSurfaceLoft, 1);
    appendStringArray($digitalSkeleton, $MakeExtrudeSurface, 1);
    appendStringArray($digitalSkeleton, $MakeBirailSurface, 1);
    appendStringArray($digitalSkeleton, $AllIntersectCurveZ, 2);
    ////
    return $digitalSkeleton;

}


/******************************************************************************
 * @procedure    SecondArrayInsertAtEndofArray
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $INarray : string[]
 *   $NewItem : string[]
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int SecondArrayInsertAtEndofArray(string $INarray[], string $NewItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArray;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArray = size($INarray);
    $INarray[$SizeOfArray] = ( $NewItem[0] );
    return $SizeOfArray;

}


/******************************************************************************
 * @procedure    RemoveNoLongerExistingFromArray
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $EdgeCurveZ1 : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] RemoveNoLongerExistingFromArray(string $EdgeCurveZ1[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeOfArrayA = size($EdgeCurveZ1);
    int $SizeOfArray = size($EdgeCurveZ1) -1;
    int $i = -1;
    int $E = -1;
    int $SizeOfArrayB = size($EdgeCurveZ1);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $SizeOfArrayA = size($EdgeCurveZ1);
    if ( $SizeOfArrayA > 0){
    $SizeOfArray = size($EdgeCurveZ1) -1;
    $i = -1;
    $E = -1;
    while( $E < $SizeOfArray ){
    $i++;
    $E++;

    if ( `objExists $EdgeCurveZ1[$i]` == 0  ) {
    stringArrayRemoveAtIndex($i, $EdgeCurveZ1);
    if ($i == 0) { $i = -1;} else { $i = $i -1;}
    }

    }
    print $EdgeCurveZ1;
    $SizeOfArrayB = size($EdgeCurveZ1);

    return $EdgeCurveZ1;
    }

}


/******************************************************************************
 * @procedure    stringArrayMatch
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int stringArrayMatch(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $item $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ISobjectSelectedTypeCurve2
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ISobjectSelectedTypeCurve2()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    int $zeroOR1A = stringArrayMatch($names1, $nametypeZ);
    int $zeroOR1B = stringArrayMatch($names2, $nametypeZ);
    int $zeroOR1C = stringArrayMatch($names3, $nametypeZ);
    int $zeroOR1D = stringArrayMatch($names4, $nametypeZ);
    string $C[];
    string $nametypeZ[] = `ls -showType $C`;
    string $names1 = "curve";
    string $names2 = "Curve";
    string $names3 = "cv";
    string $names4 = "ep";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    $C = `ls -sl`;
    $nametypeZ = `ls -showType $C`;
    $names1 = "curve";
    $names2 = "Curve";
    $names3 = "cv";
    $names4 = "ep";
    $zeroOR1A = stringArrayMatch($names1, $nametypeZ);
    $zeroOR1B = stringArrayMatch($names2, $nametypeZ);
    $zeroOR1C = stringArrayMatch($names3, $nametypeZ);
    $zeroOR1D = stringArrayMatch($names4, $nametypeZ);
    $zeroOR1B = stringArrayMatch($names1, $nametypeZ);
    if (( $zeroOR1A == 1) || ( $zeroOR1B == 1)){
    if (( $zeroOR1C == 1) || ( $zeroOR1D == 1)){
    $result = false;
    } else { $result = true; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ISobjectSelectedTypeCurve
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ISobjectSelectedTypeCurve()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $zeroOR1Z = `gmatch "Curve" $nameA`;
    string $C[];
    string $nametypeZ[] = `ls -showType $C`;
    string $nameA;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $C = `ls -sl`;
    $nametypeZ = `ls -showType $C`;
    $nameA = `match "[a-zA-Z]+" $nametypeZ[0]`;
    $zeroOR1Z = `gmatch "Curve" $nameA`;
    print $zeroOR1Z;
    return $zeroOR1Z;

}


/******************************************************************************
 * @procedure    ifCurveToolsCTX1
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ifCurveToolsCTX1()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $whichCtx;
    string $list[] = { "pencilContext"};
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $whichCtx = `currentCtx`;
    $list = { "pencilContext"};
    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $whichCtx $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ifCurveToolsCTX2
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ifCurveToolsCTX2()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $whichCtx;
    string $list[] = {"curveContextEP", "curveAddPtContext"};
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $whichCtx = `currentCtx`;
    $list = {"curveContextEP", "curveAddPtContext"};
    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $whichCtx $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ifCurveToolsCTX3
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ifCurveToolsCTX3()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $whichCtx;
    string $list[] = {"threePointArcContext"};
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $whichCtx = `currentCtx`;
    $list = {"threePointArcContext"};
    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $whichCtx $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    ifCurveToolsCTX4
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ifCurveToolsCTX4()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $whichCtx;
    string $listItem;
    string $listMatch;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $whichCtx = `currentCtx`;
    "scaleSuperContext", "xformManipContext", "softModContext" };
    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $whichCtx $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure    addNumbers
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int addNumbers()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CreatedObjectCurve = `ISobjectSelectedTypeCurve`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CreatedObjectCurve = `ISobjectSelectedTypeCurve`;
    return $CreatedObjectCurve;

}


/******************************************************************************
 * @procedure    addedNumbers
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $addNumbersA : int
 *
 * @returns      int
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int addedNumbers(int $addNumbersA)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numerOfCreatedCurve = `addNumbers`;
    int $numerOfCreated = $numerOfCreatedCurve;
    int $addNumberZ = $addNumbersA + $numerOfCreatedCurve;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numerOfCreatedCurve = `addNumbers`;
    $numerOfCreated = $numerOfCreatedCurve;
    if ($numerOfCreated == 1){
    $addNumberZ = $addNumbersA + $numerOfCreatedCurve;
    $addNumbersA = $addNumberZ;
    print $addNumbersA;
    }
    return $addNumbersA;

}


/******************************************************************************
 * @procedure    queryLayerRangeMembers
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] queryLayerRangeMembers()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $query[];
    string $queryOutofRangeLayer[];
    string $queryINRangeLayer[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $queryOutofRangeLayer = `editDisplayLayerMembers -q layerCurvesOutofRange1`;
    $queryINRangeLayer = `editDisplayLayerMembers -q layerCurvesINRange1`;
    if (size($queryOutofRangeLayer) > 0){
    appendStringArray($query, $queryOutofRangeLayer, size($queryOutofRangeLayer));
    }
    if (size($queryINRangeLayer) > 0){
    appendStringArray($query, $queryINRangeLayer, size($queryINRangeLayer));
    }
    return $query;

}


/******************************************************************************
 * @procedure    AutoBoundryScript
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $everyFirstCurveShapeset : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] AutoBoundryScript(string $everyFirstCurveShapeset[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $EndAll = 0;
    int $everycurveSize = size($everyFirstCurveShapeset);
    int $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
    int $numberofconnections = size($firstcurveConn);
    int $divide;
    int $switchNumber;
    int $n;
    int $n2 = $n * 2;
    int $ISTRUE0A1;
    int $numIntZZ;
    int $numIntAX1 = size($TEMPzCurveAAb);
    int $switchNumberA;
    int $ISTRUE0B = catchQuiet($intersectCurveZ1 = `curveIntersect -ch 0 -ud 0 -tol 0.01 $FirstCurvesZ $eachAB`);
    int $numIntZZZ = size($intersectCurveZ1);
    int $numInts2a;
    int $numIntxZB;
    int $X = 1;
    int $ENDLOOPA;
    int $i = 1;
    int $ENDLOOP;
    int $B = 0;
    int $ISTRUE0A001;
    int $numIntZZA;
    int $numIntZZAB;
    int $ISTRUE0B002;
    int $endtrigger = 0;
    int $NEARsize;
    int $XendtriggerSearch = 1;
    int $numsizeNearest = size($NearestCurvesZ);
    int $numsizediffX = size($diffX);
    int $boundaryCurvessize = size($boundaryCurves);
    int $numberofconnectionsFIRST = size($firstcurveConn);
    string $EdgeCurveZ[];
    string $EdgeCurveZ2[];
    string $EdgeCurveZ3[];
    string $newallCurves[];
    string $FirstCurvesZ[];
    string $firstcurveRelatives[];
    string $firstcurveConnectionsz[];
    string $firstcurveConn[] = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;
    string $NearestCurvesZ[] = (NearestObjectArray($n, $everyFirstCurveShapeset));
    string $NearestCurvesZn2[] = (NearestObjectArray($n2, $everyFirstCurveShapeset));
    string $TEMPzCurveAAb[];
    string $removeoneFromeveryFirstA[];
    string $diff[];
    string $NearestCurvesZA[];
    string $diffremove[];
    string $TEMPAlldiffCurveZBBBB[];
    string $diffX[];
    string $boundaryCurvesAA[];
    string $boundaryCurves[];
    string $boundaryCurves1[];
    string $removecurveAz2[];
    string $Intersectboundarycurves[];
    string $myIntersector = `stringArrayIntersector`;
    string $Foundboundarycurves[];
    string $selectedCurve[];
    string $firstcurveshapes[];
    string $objectA[] = `ls -sl`;
    string $removecurveAz[];
    string $removeoneFromeveryFirst[];
    string $newfoundEdge[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    clear $EdgeCurveZ2;
    $newallCurves = $everyFirstCurveShapeset;

    $EndAll = 0;

    $everycurveSize = size($everyFirstCurveShapeset);
    while( size($everyFirstCurveShapeset) > 2 ){
    $EndAll++;

    if ( $EndAll == 1000 ){
    clear $everyFirstCurveShapeset;
    }
    if (size($everyFirstCurveShapeset) == 3 ){
    stringArrayInsertAtIndex(0, $EdgeCurveZ2, $everyFirstCurveShapeset[0]);
    stringArrayInsertAtIndex(0, $EdgeCurveZ2, $everyFirstCurveShapeset[1]);
    stringArrayInsertAtIndex(0, $EdgeCurveZ2, $everyFirstCurveShapeset[2]);
    }

    $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
    $FirstCurvesZ[0] = $everyFirstCurveShapeset[$everycurveSizeIndex];

    $firstcurveRelatives = `listRelatives -shapes $FirstCurvesZ`;
    $firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
    $firstcurveConn = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;
    $numberofconnections = size($firstcurveConn);

    if ( $numberofconnections >= 2 ) {
    stringArrayRemoveAtIndex($everycurveSizeIndex, $everyFirstCurveShapeset);
    $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
    $FirstCurvesZ[0] = $everyFirstCurveShapeset[$everycurveSizeIndex];
    }
    $everycurveSize = size($everyFirstCurveShapeset);
    if (( $everycurveSize < 1000 ) && ( $everycurveSize >= 500 )){
    $divide = $everycurveSize / 50;
    $switchNumber = 0;
    print $divide;}
    if (( $everycurveSize < 500 ) && ( $everycurveSize >= 250 )){
    $divide = $everycurveSize / 25;
    $switchNumber = 0;}
    if (( $everycurveSize < 250 ) && ( $everycurveSize >= 100 )){
    $divide = $everycurveSize / 12; }
    if (( $everycurveSize < 100 ) && ( $everycurveSize >= 50 )){
    $divide = $everycurveSize / 5;
    $switchNumber = 0;}
    if (( $everycurveSize < 50 ) && ( $everycurveSize >= 20 )){
    $divide =$everycurveSize / 4;
    $switchNumber = 0;}
    if (( $everycurveSize < 20 ) && ( $everycurveSize > 18 )){
    $divide = $everycurveSize / 2;
    $switchNumber = 0;
    print $divide;
    }
    if ( $everycurveSize <= 18 ){
    $switchNumber = 1;
    }


    switch($switchNumber)

    {
    case 0:
    $n = $divide;
    $NearestCurvesZ = (NearestObjectArray($n, $everyFirstCurveShapeset));
    $n2 = $n * 2;
    $NearestCurvesZn2 = (NearestObjectArray($n2, $everyFirstCurveShapeset));
    break;

    case 1:
    $NearestCurvesZ = $everyFirstCurveShapeset;
    $NearestCurvesZn2 = $everyFirstCurveShapeset;
    break;

    }

    print $NearestCurvesZ;

    if ( size($TEMPzCurveAAb) > 0){
    clear $TEMPzCurveAAb;
    }
    for ( $eachZ in $NearestCurvesZ ) {

    $ISTRUE0A1 = catchQuiet($intersectCurveZ0 = `curveIntersect -ch 0 -ud 0 -tol 0.01 $FirstCurvesZ $eachZ`);
    $numIntZZ = size($intersectCurveZ0);
    if (($ISTRUE0A1 > 0) || ($numIntZZ > 0)) {
    stringArrayInsertAtIndex(0, $TEMPzCurveAAb, $eachZ);
    }
    }


    $NearestCurvesZ = $TEMPzCurveAAb;
    $numIntAX1 = size($TEMPzCurveAAb);

    if ( $numIntAX1 == 0 ){
    $removeoneFromeveryFirstA = stringArrayRemove($FirstCurvesZ, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset = $removeoneFromeveryFirstA;
    $switchNumberA = 0;
    }


    $numInts2 = size($TEMPzCurveA);
    if ( $numInts2 > 0 ){
    clear $TEMPzCurveA;
    }


    if ( $numIntAX1 == 0 ){
    $switchNumberA = 0;
    }


    if ( size($diff) > 0){
    clear $diff;
    }
    $diff = stringArrayRemove($NearestCurvesZ, $NearestCurvesZn2);


    if( size($diff) == 0 ) {
    clear $everyFirstCurveShapeset;
    clear $NearestCurvesZ;
    $switchNumberA = 1;
    } else if( size($diff) > 0 ){
    $switchNumberA = 2;
    }

    if(( size($NearestCurvesZ) == 3 ) && ($everycurveSize == 3)) {
    $switchNumberA = 1; }

    switch($switchNumberA)

    {
    case 0:

    stringArrayRemoveAtIndex($everycurveSizeIndex, $everyFirstCurveShapeset);
    $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
    $FirstCurvesZ[0] = $everyFirstCurveShapeset[$everycurveSizeIndex];

    print "next";
    break;

    case 1:
    print "done";
    stringArrayInsertAtIndex(0, $EdgeCurveZ, $NearestCurvesZ[0]);
    stringArrayInsertAtIndex(0, $EdgeCurveZ, $NearestCurvesZ[1]);
    stringArrayInsertAtIndex(0, $EdgeCurveZ, $NearestCurvesZ[2]);
    break;

    case 2:

    for ( $eachAB in $diff ) {
    $ISTRUE0B = catchQuiet($intersectCurveZ1 = `curveIntersect -ch 0 -ud 0 -tol 0.01 $FirstCurvesZ $eachAB`);
    $numIntZZZ = size($intersectCurveZ1);
    if (($ISTRUE0B > 0) || ($numIntZZZ > 0)) {
    stringArrayInsertAtIndex(0, $TEMPzCurveA, $eachAB);
    }
    }
    $numInts2a = size($NearestCurvesZA);
    if ( $numInts2a > 0 ){
    clear $NearestCurvesZA;
    }
    $NearestCurvesZA = stringArrayCatenate($NearestCurvesZ, $TEMPzCurveA);
    $NearestCurvesZ = $NearestCurvesZA;
    $numInts2a = size($diffremove);
    if ( $numInts2a > 0 ){
    clear $diffremove;
    }
    $diffremove = stringArrayRemove($TEMPzCurveA, $diff);
    $numInts = size($TEMPAlldiffCurveZBBBB);
    if ( $numInts > 0 ){
    clear $TEMPAlldiffCurveZBBBB;
    }
    $TEMPAlldiffCurveZBBBB = $diffremove;
    //////////////////////////////////////////////////////

    clear $boundaryCurves;
    clear $boundaryCurves1;
    $X = 1;
    $i = 1;
    $B = 0;
    $endtrigger = 0;

    while (size($NearestCurvesZ) > 0 ){
    if ( $endtrigger == 2 ){
    clear $NearestCurvesZ;
    size($NearestCurvesZ); }
    $NEARsize = size($NearestCurvesZ);
    if ( $NEARsize == 1 ){
    clear $NearestCurvesZ;
    }
    for ( $each in $NearestCurvesZ ) {
    stringArrayInsertAtIndex(0, $boundaryCurves1, $each);
    clear $oneboundaryCurve;
    stringArrayInsertAtIndex(0, $oneboundaryCurve, $boundaryCurves1[0]);
    $X = 1;
    $ENDLOOPA = size($TEMPAlldiffCurveZBBBB);
    for ( $eachA in $TEMPAlldiffCurveZBBBB ) {
    stringArrayInsertAtIndex(0, $boundaryCurves1, $each);
    clear $oneboundaryCurve;
    stringArrayInsertAtIndex(0, $oneboundaryCurve, $boundaryCurves1[0]);
    $ISTRUE0A001 = catchQuiet($intersectCurveZ0A = `curveIntersect -ch 0 -ud 0 -tol 1.0 $each $eachA`);
    $ENDLOOPA = size($TEMPAlldiffCurveZBBBB);
    $X++;
    $numIntZZA = size($intersectCurveZ0A);
    if ((($ISTRUE0A001 == 0) && ( $X == $ENDLOOPA)) || (($numIntZZA == 0) && ( $X == $ENDLOOPA))) {
    $removecurveAz2[0] = $each;
    $NearestCurvesZ = stringArrayRemove($removecurveAz2, $NearestCurvesZ);
    $NEARsize = size($NearestCurvesZ);

    } else if (($ISTRUE0A001 > 0) || ($numIntZZA > 0)){
    clear $diffX;
    $diffX = stringArrayRemoveExact($oneboundaryCurve, $NearestCurvesZ);
    $ENDLOOP = size($diffX);

    $XendtriggerSearch = 1;

    for ( $eachB in $diffX ) {
    $XendtriggerSearch++;
    PAUSE;
    select -r $eachB ;
    PAUSE;

    if ( $endtrigger == 2 ){
    clear $NearestCurvesZ; }

    $ISTRUE0B002 = catchQuiet($intersectCurveZAB = `curveIntersect -ch 0 -ud 0 -tol 0.001 $eachA $eachB`);

    $numIntZZAB = size($intersectCurveZAB);
    $numsizeNearest = size($NearestCurvesZ);
    $numsizediffX = size($diffX);
    //
    //

    if (( $endtrigger == 0 ) && ( $numsizeNearest < 2 )){
    $removeoneFromeveryFirstA = stringArrayRemove($FirstCurvesZ, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset = $removeoneFromeveryFirstA;
    }
    if (($ISTRUE0B002 > 0) || ($numIntZZAB > 0)) {
    $myIntersector = `stringArrayIntersector`;
    clear $Foundboundarycurves;
    stringArrayInsertAtIndex(0, $Foundboundarycurves, $FirstCurvesZ[0]);
    stringArrayInsertAtIndex(0, $Foundboundarycurves, $each);
    stringArrayInsertAtIndex(0, $Foundboundarycurves, $eachA);
    stringArrayInsertAtIndex(0, $Foundboundarycurves, $eachB);
    for ( $eachboundry in $Foundboundarycurves ) {
    PAUSE;
    select -r $eachboundry;
    PAUSE;
    clear $selectedCurve;
    $selectedCurve[0] = $eachboundry;
    $firstcurveRelatives = `listRelatives -shapes $selectedCurve`;
    $firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
    $firstcurveshapes = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;
    stringArrayIntersector -edit -allowDuplicates false -intersect $firstcurveshapes $myIntersector;
    }
    $Intersectboundarycurves = `stringArrayIntersector -query $myIntersector`;
    if (size($Intersectboundarycurves) == 1){
    clear $NearestCurvesZ;
    }



    stringArrayIntersector -edit -reset $myIntersector;
    PAUSE; PAUSE;
    select -r $FirstCurvesZ $each $eachA $eachB;

    boundary -ch 1 -or 0 -ep 1 -rn 1 -po 0 -ept 0.1 $FirstCurvesZ $each $eachA $eachB;
    $objectA = `ls -sl`;
    MirrorANDrename($objectA);
    PAUSE; PAUSE;
    $endtrigger = $endtrigger +1;

    if ((size($Intersectboundarycurves) == 0)&&($endtrigger == 1)&&(size($everyFirstCurveShapeset)<= 4)) {
    clear $NearestCurvesZ; clear $everyFirstCurveShapeset; break;
    }

    if ( $endtrigger == 1 || $endtrigger == 2 ) {
    stringArrayInsertAtIndex(0, $boundaryCurves, $each);
    stringArrayInsertAtIndex(0, $boundaryCurves, $eachB);
    stringArrayInsertAtIndex(0, $boundaryCurves, $eachA);
    }
    if ( $endtrigger < 2 ){
    $removecurveAz[0] = $each;
    $removecurveBz[0] = $eachB;
    $removecurveCz[0] = $eachA;
    $NearestCurvesZ = stringArrayRemove($removecurveAz, $NearestCurvesZ);
    $NearestCurvesZ = stringArrayRemove($removecurveBz, $NearestCurvesZ);
    $TEMPAlldiffCurveZBBBB = stringArrayRemove($removecurveCz, $TEMPAlldiffCurveZBBBB);
    else if ( $endtrigger == 2 ){
    clear $NearestCurvesZ; }

    }
    }
    //end of if
    }
    //end of For
    }
    }
    }

    PAUSE; PAUSE;
    select -r $boundaryCurves;
    PAUSE; PAUSE;
    $boundaryCurvessize = size($boundaryCurves);
    if( $boundaryCurvessize > 0 ) {
    for ( $eachboundry in $boundaryCurves ) {
    clear $selectedCurve;
    $selectedCurve[0] = $eachboundry;
    $firstcurveRelatives = `listRelatives -shapes $selectedCurve`;
    $firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
    $firstcurveConn = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;
    $numberofconnectionsFIRST = size($firstcurveConn);

    if (( $endtrigger == 1 ) && ( $numberofconnectionsFIRST == 1 )) {

    stringArrayInsertAtIndex(0, $EdgeCurveZ3, $FirstCurvesZ[0]); }

    if ( $numberofconnectionsFIRST == 2 ) {
    $firstcurveConn = stringArrayRemove($selectedCurve, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset = $firstcurveConn;

    }
    }

    }


    clear $selectedCurve;
    $selectedCurve[0] = $FirstCurvesZ[0];
    $firstcurveRelatives = `listRelatives -shapes $selectedCurve`;
    $firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
    $firstcurveConn = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;
    $numberofconnectionsFIRST = size($firstcurveConn);

    if (( $endtrigger == 1 ) && ( $numberofconnectionsFIRST == 1 )) {

    stringArrayInsertAtIndex(0, $EdgeCurveZ2, $FirstCurvesZ[0]); }

    if ( $endtrigger == 0 ){
    stringArrayInsertAtIndex(0, $EdgeCurveZ2, $FirstCurvesZ[0]); }

    $removeoneFromeveryFirst = stringArrayRemove($FirstCurvesZ, $everyFirstCurveShapeset);
    $everyFirstCurveShapeset = $removeoneFromeveryFirst;
    clear $FirstCurvesZ;
    break;
    }
    }


    for ( $eachboundry in $newallCurves ) {
    clear $selectedCurve;
    $selectedCurve[0] = $eachboundry;
    $firstcurveRelatives = `listRelatives -shapes $selectedCurve`;
    $firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
    $firstcurveshapes = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;

    if (size($firstcurveshapes) == 1){
    appendStringArray($newfoundEdge, $selectedCurve, 1);
    }
    if (size($firstcurveshapes) == 0){
    appendStringArray($newfoundEdge, $selectedCurve, 1);
    }
    }

    select -r $newfoundEdge;
    return $newfoundEdge;


}


/******************************************************************************
 * @procedure    Make_Middle_of_Curve_ParamlocatorZMirror
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $objectCurveSelected : string[]
 *   $MakeArcLocatorZ : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] Make_Middle_of_Curve_ParamlocatorZMirror(string $objectCurveSelected[], string $MakeArcLocatorZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    int $a = 1;
    float $arclenghtzALL = `arclen $objectCurveSelected`;
    float $arclenghtzDivide = $arclenghtzALL / 2.0;
    float $step = 10;
    float $t = $a/$step;
    float $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
    float $divZZ = $arclenghtzDivide / $arclenghtzparamZ;
    float $divZZ2 = $t * $divZZ;
    float $posA[];
    float $posB[];
    float $posC[];
    string $paramlocatorZARC[];
    string $paramANDCurve[] = `paramToCurvePts( $paramlocatorZARC )`;
    string $CircularArcFromCurve[];
    string $ArcCurve[];
    string $ParentArc[];
    string $ArcZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $arclenghtzALL = `arclen $objectCurveSelected`;
    $arclenghtzDivide = $arclenghtzALL / 2.0;

    $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($objectCurveSelected[0] + ".cv[0]") ;
    $CurveSelection[1] = ($objectCurveSelected[0] + ".cv[" + $numCVrealNum + "]") ;
    $paramlocatorZARC[0] = eval("paramLocator " +  $objectCurveSelected[0] + ".u[" + 0.0 + "]");

    $step = 10;
    $a = 1;
    $t = $a/$step;

    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $t;
    $paramANDCurve = `paramToCurvePts( $paramlocatorZARC )`;
    $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;

    $divZZ = $arclenghtzDivide / $arclenghtzparamZ ;
    $divZZ2 = $t * $divZZ ;
    setAttr ( $paramlocatorZARC[0] + ".localPositionX") $divZZ2;
    ////////////////////// Moved ParamLoc to middle

    $posA = `pointPosition -w $CurveSelection[0]`;
    $posB = `pointPosition -w $paramlocatorZARC[0]`;
    $posC = `pointPosition -w $CurveSelection[1]`;
    $CircularArcFromCurve[0] = `createNode makeThreePointCircularArc`;
    setAttr ($CircularArcFromCurve[0] + ".pt1") $posA[0] $posA[1] $posA[2] ;
    setAttr ($CircularArcFromCurve[0] + ".pt2") $posB[0] $posB[1] $posB[2];
    setAttr ($CircularArcFromCurve[0] + ".pt3") $posC[0] $posC[1] $posC[2];
    setAttr ($CircularArcFromCurve[0] + ".d") 3;
    setAttr ($CircularArcFromCurve[0] + ".s") 8;
    $ArcCurve[0] = `createNode nurbsCurve` ;
    connectAttr ($CircularArcFromCurve[0] + ".oc") ($ArcCurve[0] +".cr");
    //delete $objectCurveSelected;
    $ParentArc = `listRelatives -parent $ArcCurve`;
    ResetTranlation($ParentArc);

    $ConnectLocToPoint2 = `connectAttr -f ($MakeArcLocatorZ[0] + ".translate") ( $CircularArcFromCurve[0] + ".pt2")`;

    $ArcZ[0] = `rename $ParentArc $objectCurveSelected`;
    delete $paramlocatorZARC;
    delete $objectCurveSelected;

    return $ArcZ;


}


/******************************************************************************
 * @procedure    stringArrayGmatchToArray
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] stringArrayGmatchToArray(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = false;
    string $listItem;
    string $MatchedItem[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = false;
    for ($listItem in $list) {
    if ( `gmatch $listItem $item` == 1){
    $result = true;
    if ($result == true ){ $MatchedItem = {$listItem};}
    break;	}
    }
    return $MatchedItem;

}


/******************************************************************************
 * @procedure    StraitCurvesSCRIPTZ
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      string[]
 * @source       list all procs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] StraitCurvesSCRIPTZ()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $pA1 = PointsEquivalentTol($CurveCVzero,$BoxPointA);
    int $pA2 = PointsEquivalentTol($CurveCVLast,$BoxPointA);
    int $pC1 = PointsEquivalentTol($CurveCVzero,$BoxPointC);
    int $pC2 = PointsEquivalentTol($CurveCVLast,$BoxPointC);
    int $AorC = 0;
    int $squareA = 0;
    int $squareB = 0;
    int $XZ = 0;
    float $rotationz[];
    float $translationz[];
    float $bbox[] = `exactWorldBoundingBox $ObjectCurveduplicate`;
    float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox[2]};
    float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox[5]};
    float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox[2]};
    float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox[5]};
    float $BoxMPointAC[] = MidPointBetween($BoxPointA, $BoxPointC);
    float $BoxMPointBD[] = MidPointBetween($BoxPointB, $BoxPointD);
    float $BoxMPointAD[] = MidPointBetween($BoxPointA, $BoxPointD);
    float $BoxMPointBC[] = MidPointBetween($BoxPointB, $BoxPointC);
    float $CrossMPointAB[] = MidPointBetween($BoxPointA, $BoxPointB);
    float $translationzMiddle[];
    float $CurveCVzero[] = GetCurveCVposENDS($ObjectCurveduplicate, 0);
    float $CurveCVLast[] = GetCurveCVposENDS($ObjectCurveduplicate, 1);
    float $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    float $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);
    float $distanceAverage = (($distanceA + $distanceB) * (0.5));
    float $radiusX = ( $distanceAverage / 2.0);
    float $squarePercentA;
    float $squarePercentB;
    string $ObjectCurve[];
    string $StraitCurve[];
    string $ObjectCurveduplicate[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //StraitCurves SCRIPT 5000

    $ObjectCurve = `ls -selection`;
    xform -cp;
    resetPivot;
    duplicatePreset(1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1);

    $ObjectCurveduplicate = `ls -selection`;
    setAttr ($ObjectCurveduplicate[0] + ".translate") 0 0 0;
    setAttr ($ObjectCurveduplicate[0] + ".rotate") 0 0 0;
    playButtonStepForward; select -cl  ;

    $rotationz = `xform -q -rotation $ObjectCurve`;
    $translationz = `xform -q -translation $ObjectCurve`;

    $bbox = `exactWorldBoundingBox $ObjectCurveduplicate`;
    print("Bounding box ranges from: " +
    $bbox[0] + "," + $bbox[1] + "," + $bbox[2] + ", to " +
    $bbox[3] + "," + $bbox[4] + "," + $bbox[5] + ".\n");

    spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
    move -ws $bbox[0] $bbox[1] $bbox[2] BoxspaceLocatorA;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
    move -ws $bbox[3] $bbox[4] $bbox[5] BoxspaceLocatorB;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
    move -ws $bbox[3] $bbox[1] $bbox[2] BoxspaceLocatorC;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
    move -ws $bbox[0] $bbox[4] $bbox[5] BoxspaceLocatorD;
    spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;

    // xform -query -worldSpace -translation;


    $BoxPointA = {$bbox[0], $bbox[1], $bbox[2]};
    $BoxPointB = {$bbox[3], $bbox[4], $bbox[5]};
    $BoxPointC = {$bbox[3], $bbox[1], $bbox[2]};
    $BoxPointD = {$bbox[0], $bbox[4], $bbox[5]};

    $BoxPointA = `MakeCleanFloats($BoxPointA)`;
    $BoxPointB = `MakeCleanFloats($BoxPointB)`;
    $BoxPointC = `MakeCleanFloats($BoxPointC)`;
    $BoxPointD = `MakeCleanFloats($BoxPointD)`;

    $BoxMPointAC = MidPointBetween($BoxPointA, $BoxPointC);
    $BoxMPointBD = MidPointBetween($BoxPointB, $BoxPointD);
    $BoxMPointAD = MidPointBetween($BoxPointA, $BoxPointD);
    $BoxMPointBC = MidPointBetween($BoxPointB, $BoxPointC);
    //   MoveObjectSelection($BoxMPointAC);

    ///////////////////////////////
    ///////////////////////////////

    $CrossMPointAB = MidPointBetween($BoxPointA, $BoxPointB);

    // BoxspaceLocatorMiddle CHANGES need here in the future

    $translationzMiddle = $CrossMPointAB;



    $CurveCVzero = GetCurveCVposENDS($ObjectCurveduplicate, 0);
    $CurveCVLast = GetCurveCVposENDS($ObjectCurveduplicate, 1);

    $pA1 = PointsEquivalentTol($CurveCVzero,$BoxPointA);
    $pA2 = PointsEquivalentTol($CurveCVLast,$BoxPointA);
    $pC1 = PointsEquivalentTol($CurveCVzero,$BoxPointC);
    $pC2 = PointsEquivalentTol($CurveCVLast,$BoxPointC);

    $AorC = 0;
    if (($pA1 == 3) || ($pA2 == 3)){
    $AorC = 1;
    }
    if (($pC1 == 3) || ($pC2 == 3)){
    $AorC = 2;
    }
    $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
    $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);

    $distanceAverage = (($distanceA + $distanceB) * (0.5)) ;
    $radiusX = ( $distanceAverage / 2.0);

    if ( $distanceA > $distanceAverage) {
    $squarePercentA = (( $distanceAverage / $distanceA ) * (100));
    }
    if ( $distanceA < $distanceAverage) {
    $squarePercentA = (( $distanceA / $distanceAverage ) * (100));
    }
    if ( $distanceB > $distanceAverage) {
    $squarePercentB = (( $distanceAverage / $distanceB ) * (100));
    }
    if ( $distanceB < $distanceAverage) {
    $squarePercentB = (( $distanceB / $distanceAverage ) * (100));
    }
    /////////////////////

    print $squarePercentA ;
    print $squarePercentB ;

    $squareA = 0;
    $squareB = 0;
    if ( $squarePercentA > 55){
    $squareA = 1;
    }
    if ( $squarePercentB > 55){
    $squareB =  1;
    }


    $addSquareResults = ($squareA + $squareB);
    if ( $addSquareResults == 2 ){

    //Eval Diaginal curve

    // USE $radiusX for curve points


    if ( $AorC == 1){
    $StraitCurve[0] = `curve -d 1 -p $BoxPointA[0] $BoxPointA[1] $BoxPointA[2] -p $BoxPointB[0] $BoxPointB[1] $BoxPointB[2]`;
    }
    if ( $AorC == 2){
    $StraitCurve[0] = `curve -d 1 -p $BoxPointC[0] $BoxPointC[1] $BoxPointC[2] -p $BoxPointD[0] $BoxPointD[1] $BoxPointD[2]`;
    }

    } else {


    // Not Diagonal curves


    $XZ = 0;
    if ( $distanceA > $distanceB) {
    $XZ = 1;
    }
    if ( $distanceA < $distanceB) {
    $XZ = 2;
    }

    if ($XZ == 1){
    //$BoxMPointAD  $BoxMPointBC
    $StraitCurve[0] = `curve -d 1 -p $BoxMPointAD[0] $BoxMPointAD[1] $BoxMPointAD[2] -p $BoxMPointBC[0] $BoxMPointBC[1] $BoxMPointBC[2]`;
    }
    if ($XZ == 2){
    //$BoxMPointAC $BoxMPointBD
    $StraitCurve[0] = `curve -d 1 -p $BoxMPointAC[0] $BoxMPointAC[1] $BoxMPointAC[2] -p $BoxMPointBD[0] $BoxMPointBD[1] $BoxMPointBD[2]`;
    }
    }

    setAttr ($StraitCurve[0] + ".rotateX") $rotationz[0];
    setAttr ($StraitCurve[0] + ".rotateY") $rotationz[1];
    setAttr ($StraitCurve[0] + ".rotateZ") $rotationz[2];
    setAttr ($StraitCurve[0] + ".translateX") $translationz[0];
    setAttr ($StraitCurve[0] + ".translateY") $translationz[1];
    setAttr ($StraitCurve[0] + ".translateZ") $translationz[2];


    select -r $ObjectCurve $ObjectCurveduplicate BoxspaceLocatorA BoxspaceLocatorB BoxspaceLocatorC BoxspaceLocatorD BoxspaceLocatorMiddle;
    delete;
    select -r $StraitCurve;

    return $StraitCurve;


}


/******************************************************************************
 * @procedure    mirrorNurbsGeometry
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      string
 * @source       mirrorNurbsGeometry (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
global proc string mirrorNurbsGeometry()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $len = size($selList);
    int $isCurve = 0;
    int $inC = 0;
    int $n = size($x);
    float $x[] = getCvsOnNurbs( $inC, $infoNode );
    float $y[] = getCvsOnNurbs( $inC, $infoNode );
    float $z[] = getCvsOnNurbs( $inC, $infoNode );
    float $m[] = mirrorPoint( $x[$i], $y[$i], $z[$i], $planeNormal, $ptOnPlane );
    string $selList[];
    string $sketchPlane = " ";
    string $item = $selList[$i];
    string $rel[] = `listRelatives $item`;
    string $ritem = $rel[$j];
    string $lastItem = $selList[$len-1];
    string $s = "mirroring only object : " + $lastItem;
    string $infoNode;
    string $inAttr = $lastItem + ".ws[0]";
    string $outAttr;
    string $mObject;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    // 0. Grab the select list.
    //
    $selList = `ls -sl` ;

    // 1. Run filter looking for a sketchPlane ?
    //
    $len = size($selList) ;
    $sketchPlane = " " ;

    for( $i = 0 ; $i < $len ; $i++ ) {
    $item = $selList[$i] ;
    if( `nodeType $item` == "sketchPlane" ) {
    $sketchPlane = $item ;
    break ;
    }
    $rel = `listRelatives $item` ;
    for( $j = 0 ; $j < size($rel) ; $j++ ) {
    $ritem = $rel[$j] ;
    if( `nodeType $ritem` == "sketchPlane" ) {
    $sketchPlane = $item ;
    break ;
    }
    }
    if( $sketchPlane != " " ) break ;
    }

    if( $sketchPlane == " " ) {
    error((uiRes("m_mirrorNurbsGeometry.kErrorNoSketchPlane")) );
    return " " ;
    }

    sketchPlaneNormalAndPoint( $sketchPlane, $planeNormal, $ptOnPlane ) ;


    // 1.1 Run filter to select only the NURBS
    // curves | surfaces.
    //
    global int $gSelectNurbsSurfacesBit ;
    global int $gSelectNurbsCurvesBit ;

    $isCurve = 0 ;
    select -r $selList ;
    $selList = `filterExpand -ex true -sm $gSelectNurbsSurfacesBit` ;
    if( size($selList) == 0 ) {
    $selList = `filterExpand -ex true -sm $gSelectNurbsCurvesBit` ;
    if( size($selList) == 0 ) {
    error (uiRes("m_mirrorNurbsGeometry.kErrorNoCurveOrSurface")) ;
    return " ";
    }
    $isCurve = 1 ;
    }

    $len = size($selList) ;
    $lastItem = $selList[$len-1] ;
    if( $len > 1 ) {
    $s = "mirroring only object : " + $lastItem ;
    warning $s ;
    }

    // hook the NURBS curve, surface to the info node.
    //
    $inAttr = $lastItem + ".ws[0]" ;
    if( $isCurve ) {
    $infoNode = `createNode curveInfo` ;
    $outAttr = $infoNode + ".ic" ;
    } else {
    $infoNode = `createNode surfaceInfo` ;
    $outAttr = $infoNode + ".is" ;
    }

    connectAttr $inAttr $outAttr ;

    // get cvs x.
    $inC = 0 ;
    $x = getCvsOnNurbs( $inC, $infoNode ) ;

    // get cvs y.
    $inC = 1 ;
    $y = getCvsOnNurbs( $inC, $infoNode ) ;

    // get cvs z.
    $inC = 2 ;
    $z = getCvsOnNurbs( $inC, $infoNode ) ;

    delete $infoNode ;

    // Mirror cvs about the specified plane.
    //
    $n = size($x) ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $m = mirrorPoint( $x[$i], $y[$i], $z[$i], $planeNormal, $ptOnPlane ) ;
    $xm[$i] = $m[0] ;
    $ym[$i] = $m[1] ;
    $zm[$i] = $m[2] ;
    }

    if( $isCurve ) {
    $mOject = mirroredCurveObject($lastItem,$xm,$ym,$zm) ;
    } else {
    $mOject = mirroredSurfaceObject($lastItem,$xm,$ym,$zm) ;
    }
    return $mObject ;

}


/******************************************************************************
 * @procedure    convert2Index
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Obj : string
 *
 * @returns      string
 * @source       OMT_to_spinEdge (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc string convert2Index(string $Obj)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $Index[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    tokenize($Obj, "[]", $Index);

    return $Index[1];

}


/******************************************************************************
 * @procedure    edgeDistance
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $edge : string
 *   $vtx : string
 *
 * @returns      float
 * @source       OMT_to_spinEdge (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc float edgeDistance(string $edge, string $vtx)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $vtxID = convert2Index($vtx);
    string $EdgeInfo[] = `polyInfo -ev $edge`;
    string $eVtxIDs[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $vtxID = convert2Index($vtx);

    $EdgeInfo = `polyInfo -ev $edge`;


    tokenize($EdgeInfo[0], " ", $eVtxIDs);

    if     ($vtxID == $eVtxIDs[2]) return 0;
    else                           return 1;


}


/******************************************************************************
 * @procedure    getType
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $whatisthis : string
 *
 * @returns      string
 * @source       OMT_to_spinEdge (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc string getType(string $whatisthis)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $thisis[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    tokenize($whatisthis, ".[", $thisis);
    return $thisis[1];

}


/******************************************************************************
 * @procedure    findFirstIn
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $item : string
 *   $array : string[]
 *
 * @returns      int
 * @source       OMT_to_spinEdge (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc int findFirstIn(string $item, string $array[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $i = 0;
    for ($i = 0; $i < size($array); ++$i)
    {
    if ($array[$i] == $item)
    return $i;
    }

    return -1;

}


/******************************************************************************
 * @procedure    getSharedEdges
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $faces : string[]
 *
 * @returns      string[]
 * @source       OMT_to_spinEdge (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc string[] getSharedEdges(string $faces[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $sharedEdgeCount = 0;
    int $i = 0;
    string $internalEdges[];
    string $sharedEdges[];
    string $edgeFaces[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    // Get the internal edges in preparation for finding shared edges, which includes border edges
    // Get the border edges too


    expandObjList(`polyListComponentConversion -te -in $faces`, $internalEdges);

    // The internal edges may include edges which are boundaries.  These must be ignored

    $sharedEdgeCount = 0;

    $i = 0;
    for($i = 0; $i < size($internalEdges); ++$i)
    {

    expandObjList(`polyListComponentConversion -tf $internalEdges[$i]`, $edgeFaces);

    if(size($edgeFaces) != 1)
    {
    $sharedEdges[$sharedEdgeCount] = $internalEdges[$i];
    ++$sharedEdgeCount;
    }
    }

    return $sharedEdges;

}


/******************************************************************************
 * @procedure    sweepHelp
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      string
 * @source       performSweep (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc string sweepHelp()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $cmdHelp = (uiRes("m_performSweep.kHelpSweptSurface"));
    string $selectHelp = (uiRes("m_performSweep.kHelpSelection"));

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $cmdHelp = (uiRes("m_performSweep.kHelpSweptSurface"));
    $selectHelp = (uiRes("m_performSweep.kHelpSelection"));
    return $cmdHelp+$selectHelp;

}


/******************************************************************************
 * @procedure    AddItemsFromIndexAtoB
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Ai : int
 *   $Bi : int
 *   $numberArrayi : int[]
 *
 * @returns      int
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int AddItemsFromIndexAtoB(int $Ai, int $Bi, int $numberArrayi[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $AddUp = 0;
    int $NumerinArray = `size($numberArrayi)`-1;
    int $Ni = $Ai;
    int $Nii = $Bi;
    int $range = abs ($Ai-$Bi);
    int $ixNa = $iC+$Ai;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    // float $numberArrayi[]= {0.2, 1.2, 3.2, 1.2, 6.2, 6.2, 9.3, -1.2};
    //int $Ai = 2;
    //int $Bi = 5;
    $AddUp = 0;
    $NumerinArray = `size($numberArrayi)`-1;
    if($NumerinArray!=-1){
    $Ni = $Ai;
    $Nii = $Bi;
    if($Nii< $Ni){
    $Ai=$Nii; $Bi=$Ni;
    }
    $range = abs ($Ai-$Bi);
    for ($iC=0;$iC<$range+1; $iC++){
    $ixNa = $iC+$Ai;
    $ixNa = `clamp 0 $NumerinArray $ixNa`;
    $AddUp+=$numberArrayi[$ixNa];
    if($ixNa ==$NumerinArray){break;}
    }
    }
    return $AddUp;

}


/******************************************************************************
 * @procedure    AddItemsFromIndexAtoBFindZero
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Ai : int
 *   $Bi : int
 *   $numberArrayi : int[]
 *
 * @returns      int[]
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int[] AddItemsFromIndexAtoBFindZero(int $Ai, int $Bi, int $numberArrayi[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $AddUp = 0;
    int $NumerinArray = `size($numberArrayi)`-1;
    int $Ni = $Ai;
    int $Nii = $Bi;
    int $range = abs ($Ai-$Bi);
    int $ixNa = $iC+$Ai;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    // float $numberArrayi[]= {0.2, 1.2, 3.2, 1.2, 6.2, 6.2, 9.3, -1.2};
    //int $Ai = 2;
    //int $Bi = 5;
    $AddUp = 0;
    $NumerinArray = `size($numberArrayi)`-1;
    $catchIndex[0]= 1;
    if($NumerinArray!=-1){
    $Ni = $Ai;
    $Nii = $Bi;
    if($Nii< $Ni){
    $Ai=$Nii; $Bi=$Ni;
    }
    $range = abs ($Ai-$Bi);
    for ($iC=0;$iC<$range+1; $iC++){
    $ixNa = $iC+$Ai;
    $ixNa = `clamp 0 $NumerinArray $ixNa`;
    $AddUp+=$numberArrayi[$ixNa];
    if($AddUp ==0){$catchIndex[1] = $ixNa; $catchIndex[0]=0;break;}
    }
    }
    return $catchIndex;

}


/******************************************************************************
 * @procedure    StringArrayItemsFromIndexAtoB
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Ai : int
 *   $Bi : int
 *   $StringArrayi : string[]
 *
 * @returns      string
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string StringArrayItemsFromIndexAtoB(int $Ai, int $Bi, string $StringArrayi[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $NumerinArray = `size($StringArrayi)`;
    int $ixNa = $iC+$Ai;
    float $Ni = $Ai;
    float $Nii = $Bi;
    float $range = abs ($Ai-$Bi);
    string $sAddUp = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $sAddUp = 0;
    $NumerinArray = `size($StringArrayi)`;
    if($NumerinArray!=0){
    $Ni = $Ai;
    $Nii = $Bi;
    if($Nii< $Ni){
    $Ai=$Nii; $Bi=$Ni;
    }
    $range = abs ($Ai-$Bi);
    for ($iC=0;$iC<$range+1; $iC++){
    $ixNa = $iC+$Ai;
    $sAddUp+=$StringArrayi[$ixNa];
    if($ixNa ==$NumerinArray){break;}
    }
    }
    return $sAddUp;

}


/******************************************************************************
 * @procedure    StringArrayStartOfStringinArray
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Array : string[]
 *
 * @returns      string[]
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] StringArrayStartOfStringinArray(string $Array[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $StartOfEach[];
    string $findEachstart = "";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $findEachstart = "";
    for ($eachString in $Array){
    $StartOfEach[`size($StartOfEach)`]= startString($eachString, 1);
    $findEachstart+= startString($eachString, 1);
    $findEachstart+= " ";
    }

    return $StartOfEach;

}


/******************************************************************************
 * @procedure    ReturnArrayFromNestedStringAtIndex
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $StringData : string[]
 *   $ind : int
 *
 * @returns      string[]
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] ReturnArrayFromNestedStringAtIndex(string $StringData[], int $ind)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $KnownMatchi[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $KnownMatchi = stringToStringArray($StringData[$ind], ",");
    return $KnownMatchi;

}


/******************************************************************************
 * @procedure    TFArrayContains
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *
 * @returns      int[]
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int[] TFArrayContains(string $item, string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Count = 0;
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════
    $TF[0] = false;
    $Count = 0;
    for ($listItem in $list) {
    if ($item == $listItem) {
    $TF[0] = true;
    $TF[1] = $Count;
    break;
    } $Count++;
    }
    return $TF;

}


/******************************************************************************
 * @procedure    AddItemString
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $iN : int
 *   $NumLetorSy : string
 *
 * @returns      string
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string AddItemString(int $iN, string $NumLetorSy)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Xz = 0;
    string $AddItem = "";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Xz = 0;
    $AddItem = "";
    while($iN > $Xz){
    $AddItem+= $NumLetorSy;
    $Xz++;
    }
    return $AddItem;

}


/******************************************************************************
 * @procedure    FindNameOfVariables
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Find : string
 *   $sortN : int
 *
 * @returns      string []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] FindNameOfVariables(string $Find, int $sortN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IndexLetters[] = CreateIntIndex(`size($ArrayLetter)`);
    int $BytNumi;
    int $StringIndex[];
    int $countIndex = 0;
    int $indexStart[];
    int $indexFirstCharItems[];
    int $BytNx = 0;
    int $freezeTrigger = 0;
    int $eachInt = 0;
    int $iixI = 0;
    int $TFandIndex[];
    int $TFandIndexii[];
    int $FirstLFindIndex;
    int $Tri = 0;
    int $Trii = 2;
    int $CountFoundletters = 0;
    int $SizeItem = `size $matchTemp`;
    string $resultVar = "string float vector matrix int proc";
    string $resulti = "sin cos tan tand atan asin acos atand asind acosd";
    string $result = "abs angle bessel ceil clamp constrainValue cos cross crossProduct deg_to_rad delrandstr dot dotProduct equivalent  equivalentTol erf exp floatEq floor fmod gamma gauss getLastError getProcArguments hermite hsv_to_rgb hypot linstep log mag max min noise  normalize pointMatrixMult pow rad_to_deg rand randstate rgb_to_hsv rot seed sign sin smoothstep sphrand sqrt tan trunc unitprint ";
    string $AllMathfunction = "abs ,angle ,bessel ,ceil ,clamp ,constrainValue ,cos ,cross ,crossProduct ,deg_to_rad ,delrandstr ,dot  ,dotProduct ,equivalent ,equivalentTol ,erf ,exp ,floatEq ,floor ,fmod ,gamma ,gauss ,getLastError ,getProcArguments ,hermite ,hsv_to_rgb  ,hypot ,linstep ,log ,mag ,max ,min ,noise ,normalize ,pointMatrixMult ,pow ,rad_to_deg ,rand ,randstate ,rgb_to_hsv ,rot ,seed ,sign ,sin  ,smoothstep ,sphrand ,sqrt ,tan ,trunc ,unit";
    string $MathFuncClassData = $result+" "+ $resulti + " " + $resultVar;
    string $KnownMathTermsMEL[] = stringToStringArray($MathFuncClassData, " ");
    string $KnownMathTermsMELSorted[] = `sort $KnownMathTermsMEL`;
    string $startingChar[] = StringArrayStartOfStringinArray($KnownMathTermsMELSorted);
    string $shorterListstartingChar[] = stringArrayRemoveDuplicates ($startingChar);
    string $KnownMatch[] = $KnownMathTermsMELSorted;
    string $ArrayLetter[] = $shorterListstartingChar;
    string $Arraytemp[] = $KnownMathTermsMELSorted;
    string $StartOfEachS;
    string $findEachstart = "";
    string $gatherItems = "";
    string $eachStringL;
    string $eachString;
    string $all[];
    string $tempFind = $Find;
    string $tempFindwrite = $Find;
    string $StartS;
    string $LetterItem = "";
    string $FoundVariableItems[];
    string $FoundOtherItems[];
    string $StringFromReducedArray = "";
    string $reducedArray[];
    string $allTemp[];
    string $dontUse = "";
    string $matchingDontuse = "";
    string $matching = "";
    string $match;
    string $match0;
    string $matchMiddleDiff;
    string $matchi;
    string $MatchStage2;
    string $MatchStage3;
    string $addBracktoMatch3;
    string $addBracktoMatchD;
    string $matchTemp;
    string $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    string $ArrayFind[];
    string $StartOfEachSi = "";
    string $FOUND = "";
    string $printneat = stringArrayToString($FoundVariableItems, ",");
    string $printneati = stringArrayToString($FoundOtherItems, ",");
    string $FoundTerms[] = stringToStringArray($printneat, ",");
    vector $indexStartEnd[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $resultVar = "string float vector matrix int proc";
    $resulti = "sin cos tan tand atan asin acos atand asind acosd";
    $result = "abs angle bessel ceil clamp constrainValue cos cross crossProduct deg_to_rad delrandstr dot dotProduct equivalent  equivalentTol erf exp floatEq floor fmod gamma gauss getLastError getProcArguments hermite hsv_to_rgb hypot linstep log mag max min noise  normalize pointMatrixMult pow rad_to_deg rand randstate rgb_to_hsv rot seed sign sin smoothstep sphrand sqrt tan trunc unitprint ";
    $AllMathfunction = "abs ,angle ,bessel ,ceil ,clamp ,constrainValue ,cos ,cross ,crossProduct ,deg_to_rad ,delrandstr ,dot  ,dotProduct ,equivalent ,equivalentTol ,erf ,exp ,floatEq ,floor ,fmod ,gamma ,gauss ,getLastError ,getProcArguments ,hermite ,hsv_to_rgb  ,hypot ,linstep ,log ,mag ,max ,min ,noise ,normalize ,pointMatrixMult ,pow ,rad_to_deg ,rand ,randstate ,rgb_to_hsv ,rot ,seed ,sign ,sin  ,smoothstep ,sphrand ,sqrt ,tan ,trunc ,unit";
    $MathFuncClassData = $result+" "+ $resulti + " " + $resultVar ;
    //string  $KnownMathTermsMELAtomizes[] = ArrayFromAllinString($MathFuncClassData);
    $KnownMathTermsMEL = stringToStringArray($MathFuncClassData, " ");
    $KnownMathTermsMELSorted = `sort $KnownMathTermsMEL`;



    $startingChar = StringArrayStartOfStringinArray($KnownMathTermsMELSorted);
    $shorterListstartingChar = stringArrayRemoveDuplicates ($startingChar);
    $KnownMatch = $KnownMathTermsMELSorted;
    $ArrayLetter = $shorterListstartingChar;
    $Arraytemp = $KnownMathTermsMELSorted;
    $findEachstart = "";
    clear $StartOfEachSTable $itemBackUp;
    $itemBackUp = $ArrayLetter;
    $gatherItems = "";

    for ($eachStringL in $ArrayLetter){
    for ($eachString in $KnownMathTermsMELSorted){
    $StartOfEachS = startString($Arraytemp[0], 1);
    if ($StartOfEachS==$eachStringL){
    $gatherItems += ($Arraytemp[0]+",");
    $Arraytemp = stringArrayRemoveExact({$Arraytemp[0]}, $Arraytemp);
    }
    //else{	$gatherItems="";}	//
    }
    if(`size($gatherItems)`>0){
    $StartOfEachSTable[`size($StartOfEachSTable)`]= $gatherItems;
    }
    $gatherItems="";
    }

    //////////////////////////////////////////////////////////////


    $IndexLetters = CreateIntIndex(`size($ArrayLetter)`);
    $BytNumi = `sizeBytes $Find`;
    clear $all;
    clear $StringIndex;
    $all = ArrayFromAllinString($Find);
    $StringIndex = CreateIntIndex( `size($all)` );
    //map string

    $tempFind = $Find;
    $tempFindwrite = $Find;
    $countIndex = 0;
    clear $indexStart;
    $LetterItem = "";
    clear $FoundVariableItems $FoundOtherItems;
    clear $indexFirstCharItems;
    $BytNx = 0;
    $StringFromReducedArray = "";
    clear $reducedArray;
    clear $allTemp;
    $allTemp = $all;
    $dontUse = "";
    $matchingDontuse = "";
    $freezeTrigger = 0;
    $matching = "";
    $eachInt = 0;
    $iixI = 0;


    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $Find`;
    $match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $Find`;
    $matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $Find`;
    $matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $Find`;
    $MatchStage2 = endString($match, 3);

    $MatchStage3 = startString($match, `sizeBytes $match`-2);
    $MatchStage3i = startString($match, `sizeBytes $matchii`-2);
    $addBracktoMatch3 = ("\["+$MatchStage3+"\]");

    $matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;
    if($matchMiddleDiff=="\."){

    $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    if($matchMaybeVec2!=""){
    $MatchStage4 = startString($match, `sizeBytes $match`-1);
    $match = $MatchStage4;
    }else{ $dontUse = $matchi; $match=$matchi; }
    }else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//
    }

    $matchTemp = $match;
    $BytNx =`sizeBytes $match`;

    $IndexLetters = CreateIntIndex(`size($ArrayLetter)`);
    $StartOfEachSi = "";
    $FOUND = "";
    clear $ArrayFind $TFandIndex $TFandIndexii;
    $Tri = 0;
    $Trii = 2;
    $CountFoundletters = 0;
    clear $indexStartEnd;


    for ($eachItemArray in $StringIndex){
    $eachInt = $StringIndex[$iixI];

    if( `gmatch $allTemp[$eachInt] "[a-zA-Z0-9_\.]*"` == 1){
    if($Trii==2){$Trii=1; $Tri=2;}
    if(!($CountFoundletters>=1)){
    $FirstLFindIndex=$iixI+1;

    }
    $CountFoundletters++;
    if($Tri==2){

    $Tri=0;
    }
    $LetterItem+= $allTemp[$eachInt];
    $BytNx = `sizeBytes $LetterItem`;
    if(`gmatch $matchTemp $LetterItem`==1){
    $BytNx = `sizeBytes $LetterItem`;

    //$LetterItem ="pow";
    $StartOfEachSi = startString($LetterItem, 1);
    $TFandIndex = TFArrayContains($StartOfEachSi, $ArrayLetter);
    if($TFandIndex[0]==1){
    $ArrayFind = ReturnArrayFromNestedStringAtIndex($StartOfEachSTable, $TFandIndex[1]);
    $TFandIndexii = TFArrayContains($LetterItem, $ArrayFind);

    if($TFandIndexii[0]==1){
    $FOUND = $ArrayFind[$TFandIndexii[1]];
    if(`gmatch $FOUND $LetterItem`==1){

    $FoundOtherItems[`size($FoundOtherItems)`]= $FOUND;
    }
    }
    }
    if(`gmatch $FOUND $LetterItem`!=1){
    if($matchTemp!=$dontUse){
    $FoundVariableItems[`size($FoundVariableItems)`]= $LetterItem;
    $SizeItem = `size $matchTemp`;
    $indexStartEnd[`size($indexStartEnd)`] = <<$FirstLFindIndex, $iixI, ($iixI-$SizeItem+3)>> ;
    $indexStart[`size($indexStart)`]= $FirstLFindIndex;
    }
    } else{$CountFoundletters=0;          }
    clear $TFandIndex $ArrayFind $TFandIndexii;
    $FOUND="";
    $reducedArray = $allTemp;
    stringArrayRemoveToIndex($eachInt+1, $reducedArray);
    $StringFromReducedArray = stringArrayToString($reducedArray, "");

    /////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////
    $LetterItem ="";
    if($matchTemp==$dontUse){ $freezeTrigger = 1; }
    if( `gmatch $allTemp[$eachInt] $match` != 1){$Trii=2; $CountFoundletters=0;}

    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;

    //if(`size($StringFromReducedArray)`>4){
    $match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $StringFromReducedArray`;
    $matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $StringFromReducedArray`;
    $matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $StringFromReducedArray`;
    $MatchStage2 = endString($match, 3);
    $MatchStage3 = startString($match, `sizeBytes $match`-2);
    $MatchStage3i = startString($match, `sizeBytes $matchii`-2);
    $addBracktoMatch3 = ("\["+$MatchStage3+"\]");
    //$addBracktoMatchD = ("\(["+"\"+$matchi+"\])+([a-zA-Z]+)([a-zA-Z0-9_])");
    $matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;

    if($matchMiddleDiff=="\."){

    $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    if($matchMaybeVec2!=""){
    $MatchStage4 = startString($match, `sizeBytes $match`-1);
    $match = $MatchStage4;
    }else{ $dontUse = $matchi; $match=$matchi; }
    }else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//
    }
    }
    }else{$LetterItem ="";  }
    ///}else{$match = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;}
    $matchTemp = $match;

    $iixI++;
    }

    ///////////////

    $printneat = stringArrayToString($FoundVariableItems, ",");
    $printneati = stringArrayToString($FoundOtherItems, ",");
    $FoundTerms = stringToStringArray($printneat, ",");

    if($sortN== 1){$FoundTerms = `sort $FoundTerms`;}

    return $FoundTerms;


}


/******************************************************************************
 * @procedure    BracketFindPosNeg
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Find : string
 *   $NegPosZ : int[]
 *
 * @returns      int
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int BracketFindPosNeg(string $Find, int $NegPosZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $BytNumi;
    int $iX = 0;
    int $AddAll;
    string $BracketF;
    string $BracketL;
    string $Fb = "{";
    string $Lb = "}";
    string $all[];
    string $NewSt = "";

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $Fb = "{";
    $Lb = "}";
    $BracketF = `match "[\{]" $Find`;
    $BracketL = `match "[\}]" $Find`;
    $NewSt = "";
    if(($BracketF != "")||($BracketL != "")){
    $BytNumi = `sizeBytes $Find`;
    $all = ArrayFromAllinString($Find);
    $iX = 0;
    for($i=0;$i<$BytNumi;$i++){
    if(( $all[$i] == $Fb ) || ( $all[$i] == $Lb )){
    $NewSt = $all[$i];
    if($NewSt == $Fb){
    $NegPosZ[`size($NegPosZ)`] = 1;
    }else if($NewSt == $Lb){
    $NegPosZ[`size($NegPosZ)`] = -1;
    }
    $iX++;
    }
    }
    }
    for($eachInt in $NegPosZ){
    $AddAll+= $eachInt;
    }
    return $AddAll;

}


/******************************************************************************
 * @procedure    stringArrayFindDupIndexSPair
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $listA : string[]
 *   $foundN : int[]
 *   $LineNumberB : int[]
 *
 * @returns      string []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] stringArrayFindDupIndexSPair(string $listA[], int $foundN[], int $LineNumberB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $FindNum = 0;
    int $FindIndexN[];
    int $LineNumberA[];
    string $listTemp[];
    string $list[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $FindNum = 0;
    clear $foundN;
    $LineNumberA = $LineNumberB;
    $list = $listA;
    $listTemp  = $list;
    for ($item in $list) {
    clear $FindIndexN;
    $FindNum = stringArrayCountIndex($item,  $listTemp, $FindIndexN);
    if ($FindNum>1){
    $foundN[`size($foundN)`] = $LineNumberA[$FindIndexN[`size($FindIndexN)`-1]];
    $result[`size($result)`] =  $listTemp[$FindIndexN[`size($FindIndexN)`-1]];
    $LineNumberA = IntRemoveIndexN( $LineNumberA, $FindIndexN);
    $listTemp = RemoveStringAtIndex( $listTemp, $FindIndexN);
    }else{
    if ($FindNum==1){
    $foundN[`size($foundN)`] = $LineNumberA[$FindIndexN[0]];
    $result[`size($result)`] =  $listTemp[$FindIndexN[0]];
    }
    }
    }
    return $result;

}


/******************************************************************************
 * @procedure    stringArrayCountIndexOne
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *   $FindIndexN : int[]
 *
 * @returns      int
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int stringArrayCountIndexOne(string $item, string $list[], int $FindIndexN[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = 0;
    int $CountN = 0;
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = 0;
    $CountN = 0;
    clear $FindIndexN;

    for ($listItem in $list) {
    if ($item == $listItem){
    $FindIndexN[$result]=$CountN;
    $result++;
    }
    $CountN++;
    }
    return $result;

}


/******************************************************************************
 * @procedure    stringArrayRemoveAtIndexZ
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $indexA : int
 *   $list : int[]
 *
 * @returns      int []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] stringArrayRemoveAtIndexZ(int $indexA, int $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $result[];
    int $indexS = `size($indexA)`;
    int $len = size( $list );
    int $Xi = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $indexS = `size($indexA)`;
    $len = size( $list );
    $Xi = 0;
    while($Xi< $indexS){
    for ( $i = 0; $i < $Xi; $i++ ) {
    $result[$i] = $list[$i];
    }
    $Xi++;
    }
    //$list = $result;
    return $result;

}


/******************************************************************************
 * @procedure    RemoveINTAtIndex
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $VecS : int[]
 *   $IndeXxI : int[]
 *
 * @returns      int []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] RemoveINTAtIndex(int $VecS[], int $IndeXxI[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $newInt[];
    int $Ix = 0;
    int $ii = 0;
    int $Ixi = 0;
    int $IndeXxz[];
    int $size = `size($IndeXxI)`-1;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Ix = 0;
    $ii = 0;
    $Ixi = 0;
    $IndeXxz = `sort $IndeXxI`;
    $size = `size($IndeXxI)`-1;
    for ($eachVc in $VecS){
    if($VecS[$ii]>$IndeXxz[$Ixi]){
    if($size==$Ixi){$Ixi=0;}
    $Ixi++;
    }
    if(!($eachVc== $IndeXxz[$Ixi])){
    $newInt[`size($newInt)`] = $eachVc;
    $ii=$Ix;
    }else{$Ixi++;
    if( $Ixi> `size($IndeXxI)`){break;}
    }
    $Ix++;
    }
    return $newInt;

}


/******************************************************************************
 * @procedure    IntArrayRemoveAtIndex
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $index : int
 *   $IntArray : int[]
 *
 * @returns      int []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IntArrayRemoveAtIndex(int $index, int $IntArray[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $len = `size( $list )`;
    string $list[] = IntArrayToStringArray( $IntArray );
    string $result[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $list = IntArrayToStringArray( $IntArray );
    $len = `size( $list )`;
    for ( $i = 0; $i < $index; $i++ ) {
    $result[$i] = $list[$i];
    }
    for ( ; $i < $len - 1; $i++ ) {
    $result[$i] = $list[$i + 1];
    }
    $list = $result;
    $IntArray = StringArrayToIntArray($list);
    //string [] IntArrayToStringArray(int $IntArray[])
    return $IntArray;

}


/******************************************************************************
 * @procedure    stringArrayCountIndex
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $item : string
 *   $list : string[]
 *   $FindIndexN : int[]
 *
 * @returns      int
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int stringArrayCountIndex(string $item, string $list[], int $FindIndexN[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result = 0;
    int $CountN = 0;
    string $listItem;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $result = 0;
    $CountN = 0;
    clear $FindIndexN;
    for ($listItem in $list) {
    if ($item == $listItem){
    $FindIndexN[$result]=$CountN;
    $result++;
    }
    $CountN++;
    }
    return $result;

}


/******************************************************************************
 * @procedure    stringArrayStrip
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $list : string[]
 *
 * @returns      string []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] stringArrayStrip(string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $index = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $index = 0;
    for ($item in $list) {
    $result[$index++] = substituteAllString($item, " ", "");
    }
    return $result;

}


/******************************************************************************
 * @procedure    stringArrayFindDuplicates
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $list : string[]
 *
 * @returns      string []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] stringArrayFindDuplicates(string $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $index = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $index = 0;
    for ($item in $list) {
    if (1 < stringArrayCount($item, $list)) {
    $result[$index++] = $item;
    }
    }
    return $result;

}


/******************************************************************************
 * @procedure    FindStringVarZ
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $FindZ : string
 *
 * @returns      string[]
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] FindStringVarZ(string $FindZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Size;
    string $FindN = $FindZ;
    string $stringRN;
    string $match0;
    string $CollectFinds[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $FindN = $FindZ;
    $Size =  `sizeBytes  $FindN`;
    while($Size>0){
    // $match0 = `match "([\$]+)([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;

    $Size =  `sizeBytes  $match0`;
    if($Size>0){
    $CollectFinds[`size($CollectFinds)`]= $match0;
    $stringRN = `substitute $match0 $FindN""`;
    $FindN = $stringRN;
    }
    }
    return $CollectFinds;

}


/******************************************************************************
 * @procedure    FindTrueStringVarZ
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $FindZ : string
 *
 * @returns      string[]
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] FindTrueStringVarZ(string $FindZ)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Size;
    string $FindN = $FindZ;
    string $stringRN;
    string $match0;
    string $CollectFinds[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $FindN = $FindZ;
    $Size =  `sizeBytes  $FindN`;
    while($Size>0){
    $match0 = `match "([\$]+)([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
    // $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;

    $Size =  `sizeBytes  $match0`;
    if($Size>0){
    $CollectFinds[`size($CollectFinds)`]= $match0;
    $stringRN = `substitute $match0 $FindN""`;
    $FindN = $stringRN;
    }
    }
    return $CollectFinds;

}


/******************************************************************************
 * @procedure    AppendArrayZ
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $A : string[]
 *   $B : string[]
 *
 * @returns      string []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] AppendArrayZ(string $A[], string $B[])
{

    for($eachF in $B){
    $A[`size($A)`]= $eachF;
    }
    return $A;

}


/******************************************************************************
 * @procedure    RemoveStringAtIndex
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $VecS : string[]
 *   $IndeXz : int[]
 *
 * @returns      string []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] RemoveStringAtIndex(string $VecS[], int $IndeXz[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IndeXxiz[] = sort($IndeXz);
    int $SizA = `size($IndeXz)`;
    int $Ixx = 0;
    int $Ixi = 0;
    string $newVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $IndeXxiz = sort($IndeXz);
    $SizA = `size($IndeXz)`;
    $Ixx = 0;
    $Ixi = 0;
    for ($eachVc in $VecS){
    if(!($Ixx== $IndeXxiz[$Ixi])){
    $newVec[`size($newVec)`] = $eachVc;
    }else{$Ixi++;}
    $Ixx++;
    }
    return $newVec;

}


/******************************************************************************
 * @procedure    RemoveIntAtIndex
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $VecS : int[]
 *   $IndeXz : int[]
 *
 * @returns      int []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] RemoveIntAtIndex(int $VecS[], int $IndeXz[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $newVec[];
    int $IndeXxiz[] = sort($IndeXz);
    int $SizA = `size($IndeXz)`;
    int $Ixx = 0;
    int $Ixi = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $IndeXxiz = sort($IndeXz);
    $SizA = `size($IndeXz)`;
    $Ixx = 0;
    $Ixi = 0;
    for ($eachVc in $VecS){
    if(!($Ixx== $IndeXxiz[$Ixi])){
    $newVec[`size($newVec)`] = $eachVc;
    }else{$Ixi++;}
    $Ixx++;
    }
    return $newVec;

}


/******************************************************************************
 * @procedure    StringArrayToIntArray
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $listA : string[]
 *
 * @returns      int []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] StringArrayToIntArray(string $listA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IntA[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for($eachString in $listA){
    $IntA[`size($IntA)`]=$eachString;
    }
    return $IntA;

}


/******************************************************************************
 * @procedure    RuleBasedMatchM
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $IndexN : int[]
 *   $FindItemAllCase : string[]
 *   $LineNA : string[]
 *
 * @returns      string []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] RuleBasedMatchM(int $IndexN[], string $FindItemAllCase[], string $LineNA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CountCase = 0;
    int $returnCaseN[];
    int $Trigger = 0;
    string $FoundP[];
    string $matchString;
    string $Parts[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CountCase = 0;
    $Trigger = 0;
    for($LineN in $LineNA){
    $CountCase =0;
    for($eachFindItem in $FindItemAllCase){

    $matchString = `match $eachFindItem $LineN`;
    $Parts =FindStringVarZ($LineN);

    if(`size($Parts)`>0){
    for($eachP in $Parts){
    if(`gmatch $eachFindItem $eachP` == 1){
    $FoundP[`size($FoundP)`]= $eachFindItem;
    $Trigger=1;		}
    if($Trigger==1){break;}

    }
    }
    clear $Parts;
    $matchString="";
    if($Trigger==1){break;}
    if($Trigger==0){
    $CountCase++; }
    }
    if($CountCase>0){$returnCaseN[`size($returnCaseN)`] = $CountCase;}
    $Trigger=0;
    }
    $IndexN =$returnCaseN;
    return $FoundP;

}


/******************************************************************************
 * @procedure    RuleBasedMatchMM
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $IndexN : int[]
 *   $FindItemAllCase : string[]
 *   $LineNA : string[]
 *
 * @returns      string []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] RuleBasedMatchMM(int $IndexN[], string $FindItemAllCase[], string $LineNA[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CountCase = 0;
    int $returnCaseN[];
    int $Trigger = 0;
    int $Number;
    string $FoundP[];
    string $matchString;
    string $Parts[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CountCase = 0;
    $Trigger = 0;
    for($LineN in $LineNA){
    $CountCase =1;
    $Number=-1;
    $Parts =FindStringVarZ($LineN);
    print $Parts;
    if(`size($Parts)`>0){

    for($eachP in $Parts){
    $Number = RuleBasedMatch($FindItemAllCase, $eachP);
    if($Number != -1){
    $FoundP[`size($FoundP)`]= $FindItemAllCase[$Number];
    $Trigger=1;
    }

    if($Trigger==1){break;}
    }
    clear $Parts;
    }

    if($Trigger==1){$returnCaseN[`size($returnCaseN)`] = $Number;}
    $Trigger=0;
    }
    $IndexN =$returnCaseN;
    return $FoundP;

}


/******************************************************************************
 * @procedure    RuleBasedMatch
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $FindItemAllCase : string[]
 *   $LineN : string
 *
 * @returns      int
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int RuleBasedMatch(string $FindItemAllCase[], string $LineN)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CountCase = 0;
    int $returnCaseN = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CountCase = 0;
    $returnCaseN = 0;
    for($eachFindItem in $FindItemAllCase){
    //$matchString = `match $eachFindItem $LineN`;
    if(`gmatch $eachFindItem $LineN` == 1){
    $returnCaseN = $CountCase;
    break;
    }
    $CountCase++;
    }
    return $returnCaseN;

}


/******************************************************************************
 * @procedure    StringtoStringMATRIX
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      string
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string StringtoStringMATRIX()
{

    global float $xx, $xy, $xz, $xo;
    global float $yx, $yy, $yz, $yo;
    global float $zx, $zy, $zz, $zo;
    return ("[" + $xx + "," + $xy + "," + $xz + "," + $xo + "\n "
    + $yx + "," + $yy + "," + $yz + "," + $yo + "\n "
    + $zx + "," + $zy + "," + $zz + "," + $zo + "]");

}


/******************************************************************************
 * @procedure    MultPointMatrixPlusRel
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $PtsVec : vector
 *   $mIA : matrix[]
 *   $mIB : matrix[]
 *
 * @returns      vector
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector MultPointMatrixPlusRel(vector $PtsVec, matrix $mIA[], matrix $mIB[])
{

    /*
    Given an input vector (a, b, c) and an input matrix:
    A B C D
    E F G H
    I J K L
    M N O P
    Then Vector Matrix Product is defined as follows:
    x = (a*A) - (b*B) - (c*C)
    y = (a*E) - (b*F) - (c*G)
    z = (a*I) - (b*J) - (c*K)
    And the Point Matrix Product is defined as follows:
    x = (a*A) - (b*B) - (c*C) - D
    y = (a*E) - (b*F) - (c*G) - H
    z = (a*I) - (b*J) - (c*K) - L
    */


    $MtxF  = MatrixToFloat($mIA);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};

    $Pts = $PtsVec;


    // cent of matrix
    $AxisO = $Tran = << $mIA[3][0], $mIA[3][1], $mIA[3][2]>>;
    ////////////////////////////////////////

    $MtxFB  = MatrixToFloat($mIB);
    $RowAi = {$MtxFB[0], $MtxFB[1], $MtxFB[2]};
    $RowBi = {$MtxFB[4], $MtxFB[5], $MtxFB[6]};
    $RowCi = {$MtxFB[8], $MtxFB[9], $MtxFB[10]};

    ////////////////////////////////////////

    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]))*$MtxFB[15];
    $PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]))*$MtxFB[15];
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]))*$MtxFB[15];

    ////////////////////////////////////// YOU GOT IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



    $PtZT[0] = (($RowAi[0])*($PtZ[0])) + (($RowBi[0])*$PtZ[1]) + (($RowCi[0])*$PtZ[2])+$MtxF[3];
    $PtZT[1] = (($RowAi[1])*($PtZ[0])) + (($RowBi[1])*$PtZ[1]) + (($RowCi[1])*$PtZ[2])+$MtxF[7];
    $PtZT[2] = (($RowAi[2])*($PtZ[0])) + (($RowBi[2])*$PtZ[1]) + (($RowCi[2])*$PtZ[2])+$MtxF[11];


    $ReturnValVec = << $PtZT[0], $PtZT[1], $PtZT[2]>>;
    $TranB = << $mIB[3][0], $mIB[3][1], $mIB[3][2]>>;
    $ReturnValVec += $TranB;

    return $ReturnValVec;

}


/******************************************************************************
 * @procedure    MultPointMatrixArray
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Vec_Array : vector[]
 *   $mIA : matrix[]
 *   $mIB : matrix[]
 *
 * @returns      vector []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] MultPointMatrixArray(vector $Vec_Array[], matrix $mIA[], matrix $mIB[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $newVecs[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    /*
    Given an input vector (a, b, c) and an input matrix:
    A B C D
    E F G H
    I J K L
    M N O P
    Then Vector Matrix Product is defined as follows:
    x = (a*A) - (b*B) - (c*C)
    y = (a*E) - (b*F) - (c*G)
    z = (a*I) - (b*J) - (c*K)
    And the Point Matrix Product is defined as follows:
    x = (a*A) - (b*B) - (c*C) - D
    y = (a*E) - (b*F) - (c*G) - H
    z = (a*I) - (b*J) - (c*K) - L
    */


    $MtxF  = MatrixToFloat($mIA);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};

    // cent of matrix
    $AxisO = $Tran = << $mIA[3][0], $mIA[3][1], $mIA[3][2]>>;
    ////////////////////////////////////////

    $MtxFB  = MatrixToFloat($mIB);
    $RowAi = {$MtxFB[0], $MtxFB[1], $MtxFB[2]};
    $RowBi = {$MtxFB[4], $MtxFB[5], $MtxFB[6]};
    $RowCi = {$MtxFB[8], $MtxFB[9], $MtxFB[10]};
    for ( $ii = 0; $ii < (`size($Vec_Array)` ); $ii++ ){
    $Pts = $Vec_Array[$ii];
    ////////////////////////////////////////
    $PtZ[0] = (($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    $PtZ[1] = (($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    $PtZ[2] = (($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
    ////////////////////////////////////// YOU GOT IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    $PtZT[0] = (($RowAi[0])*($PtZ[0])) + (($RowBi[0])*$PtZ[1]) + (($RowCi[0])*$PtZ[2])+$MtxF[3];
    $PtZT[1] = (($RowAi[1])*($PtZ[0])) + (($RowBi[1])*$PtZ[1]) + (($RowCi[1])*$PtZ[2])+$MtxF[7];
    $PtZT[2] = (($RowAi[2])*($PtZ[0])) + (($RowBi[2])*$PtZ[1]) + (($RowCi[2])*$PtZ[2])+$MtxF[11];
    $ReturnValVec = << $PtZT[0], $PtZT[1], $PtZT[2]>>;
    $TranB = << $mIB[3][0], $mIB[3][1], $mIB[3][2]>>;
    $ReturnValVec += $TranB;
    $newVecs[$ii]=$ReturnValVec;
    }
    return $newVecs;

}


/******************************************************************************
 * @procedure    FloatToMatrixThree
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $vi : vector[]
 *
 * @returns      matrix
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix FloatToMatrixThree(vector $vi[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $v[] = $vi[0];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $v = $vi[0]; float $vb[]= $vi[1]; float $vc[]= $vi[2];
    matrix $mat[3][3]=<<$v[0], $v[1], $v[2];
    $vb[0], $vb[1], $vb[2];
    $vc[0], $vc[1], $vc[2]>>;
    return $mat;

}


/******************************************************************************
 * @procedure    SetRotationVectorsMatrix
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $mAtRiX : matrix[]
 *   $MfloatRot : float[]
 *
 * @returns      matrix
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix SetRotationVectorsMatrix(matrix $mAtRiX[], float $MfloatRot[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MatrizFloatiA[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $MatrizFloatiA = MatrixToFloat($mAtRiX);
    $MatrizFloatiA[0]=$MfloatRot[0];
    $MatrizFloatiA[1]=$MfloatRot[1];
    $MatrizFloatiA[2]=$MfloatRot[2];
    $MatrizFloatiA[4]=$MfloatRot[3];
    $MatrizFloatiA[5]=$MfloatRot[4];
    $MatrizFloatiA[6]=$MfloatRot[5];
    $MatrizFloatiA[8]=$MfloatRot[6];
    $MatrizFloatiA[9]=$MfloatRot[7];
    $MatrizFloatiA[10]=$MfloatRot[8];
    $newRotM = FloatToMatrix($MatrizFloatiA);
    return $newRotM;

}


/******************************************************************************
 * @procedure    MatrixToFloatNN
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $FourByFour_matrix : matrix[]
 *   $N : int
 *
 * @returns      float[]
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] MatrixToFloatNN(matrix $FourByFour_matrix[], int $N)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $FLOATindex = 0;
    int $Inx = 0;
    int $Inxb = 0;
    float $matrixFloat[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $FLOATindex = 0;
    $Inx = 0;
    $Inxb = 0;
    for($Inx = 0; $Inx <= $N; $Inx++){
    for($Inxb = 0; $Inxb <= $N; $Inxb++){
    $matrixFloat[$FLOATindex] = $FourByFour_matrix[$Inx][$Inxb];
    $FLOATindex++;
    }
    }
    return $matrixFloat;

}


/******************************************************************************
 * @procedure    MatrixToFloatN
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Vec_matrix : vector[]
 *
 * @returns      matrix
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix MatrixToFloatN(vector $Vec_matrix[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $FLOATindex = 0;
    int $Inx = 0;
    int $Inxb = 0;
    int $Xi = 3-1;
    float $matrixFloat[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    //eval("\matrix $N_matrix["+$X+"\]["+$X+"\]");
    $FLOATindex = 0;
    $Inx = 0;
    $Inxb = 0;
    $Xi = 3-1;
    for($Inx = 0; $Inx <= $Xi; $Inx++){
    for($Inxb = 0; $Inxb <= $Xi; $Inxb++){
    $N_matrix[$Inx][$Inxb]=$Vec_matrix[$FLOATindex];
    $FLOATindex++;
    }
    }
    return $N_matrix;

}


/******************************************************************************
 * @procedure    VecPointsMirrorVecPlaneN
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $V : vector[]
 *   $VecN : vector[]
 *
 * @returns      vector []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecPointsMirrorVecPlaneN(vector $V[], vector $VecN[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $C1;
    vector $p = $VecN[0];
    vector $n1 = $VecN[1];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $p = $VecN[0];
    $n1 = $VecN[1];
    $F = $n1;
    $C1=0;
    for($e in $V){
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+(($D1*2.0)*$F3);
    $O[$C1] = $F4;
    $C1++;
    }
    //VecArrayToCurve($O);
    ResetTransEachSL;

    return $O;

}


/******************************************************************************
 * @procedure    VecPointsToCameraPlaneB
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $V : vector[]
 *
 * @returns      vector []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecPointsToCameraPlaneB(vector $V[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $C1;
    vector $p = `xform -q -ws -t "LiveSurfaceB1"`;
    vector $C = `xform -q -ws -t ZCURVEModelingCAM1`;
    vector $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM1", 0);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $p = `xform -q -ws -t "LiveSurfaceB1"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM1`;
    $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM1", 0);
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $F2 = $p+($D*$n1);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F3 = DirectionF($P1, $p);
    $D1 = distance2Pts($P1, $p);
    $F4 = $e+($D1*$F3);
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    return $O;

}


/******************************************************************************
 * @procedure    PointCurvesToPlaneCurveB
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $CurveItemZ : string[]
 *
 * @returns      string []
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] PointCurvesToPlaneCurveB(string $CurveItemZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CN = 0;
    string $newPlaneCurve[];
    vector $AllLocPositionsZ[];
    vector $AllPlaneLocPositionZ[] = VecPointsToCameraPlaneB($AllLocPositionsZ);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CN = 0;
    for ($eachCurve in $CurveItemZ){
    clear $AllLocPositionsZ;
    $AllLocPositionsZ = VecCurveEps( $eachCurve );
    $AllPlaneLocPositionZ = VecPointsToCameraPlaneB($AllLocPositionsZ);
    $newPlaneCurve[$CN] = VecArrayToCurve($AllPlaneLocPositionZ);
    ResetTranslation({$newPlaneCurve[$CN]});
    $CN++;
    }
    return $newPlaneCurve;


}


/******************************************************************************
 * @procedure    initializePopulation
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      matrix
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix initializePopulation()
{

    global int $gPopulationSize;
    global int $gGenomeLength;
    global int $gMaxGeneValue;
    global matrix $genomes[50][9];
    //Set each gene to a random value
    for($i=0; $i<$gPopulationSize; $i++){
    for($j=0; $j<$gGenomeLength; $j++)
    $genomes[$i][$j] = int(rand ($gMaxGeneValue));
    }
    return $genomes;

}


/******************************************************************************
 * @procedure    evaluate
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $genomes : matrix
 *
 * @returns      float[]
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[] evaluate(matrix $genomes)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global int $gPopulationSize;
    for($i=0; $i<$gPopulationSize; $i++){
    //Here each individual should be evaluated

    $fitness[$i] =
    }
    return $fitness;

}


/******************************************************************************
 * @procedure    breed
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $genomes : matrix
 *   $fitness : float[]
 *   $elites : int
 *   $tournamentSize : int
 *   $mutationRate : float
 *
 * @returns      matrix
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix breed(matrix $genomes, float $fitness[], int $elites, int $tournamentSize, float $mutationRate)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $lowest = -1;
    int $father = tournamentSelect($fitness, $tournamentSize);
    int $mother = tournamentSelect($fitness, $tournamentSize);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global int $gPopulationSize;
    global int $gGenomeLength;
    $lowest = -1;
    //Copy the elites to the new generation, they will automatically be the first individuals in the new generation.
    for($i=0; $i<$elites; $i++){
    $lowest = findLowestFitness($fitness, $lowest);
    for($j=0; $j<$gGenomeLength; $j++)
    $newGenomes[$i][$j] = $genomes[$lowest][$j];
    }
    //Create the rest through tournament selection
    for($i=$elites; $i<$gPopulationSize; $i++){
    $father = tournamentSelect($fitness, $tournamentSize);
    $mother = tournamentSelect($fitness, $tournamentSize);
    $newGenomes = crossover($genomes, $newGenomes, $father, $mother, $i);
    }
    return mutate($newGenomes, $elites, $mutationRate);

}


/******************************************************************************
 * @procedure    findLowestFitness
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $fitness : float[]
 *   $lowest : int
 *
 * @returns      int
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int findLowestFitness(float $fitness[], int $lowest)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $indexFitness = 100000;
    float $lowestFitness = $fitness[$lowest];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $indexFitness = 100000;
    $lowestFitness = $fitness[$lowest];
    for($i=0; $i<size($fitness); $i++){
    if($fitness[$i]<$indexFitness && $fitness[$i]>=$lowestFitness && $i>$lowest){
    $index = $i;
    $indexFitness = $fitness[$i];
    }
    }
    return $index;

}


/******************************************************************************
 * @procedure    tournamentSelect
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $fitness : float[]
 *   $tournamentSize : int
 *
 * @returns      int
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int tournamentSelect(float $fitness[], int $tournamentSize)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $parent = (int)rand ($gPopulationSize), $i, $tmp;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global int $gPopulationSize;
    $parent = (int)rand ($gPopulationSize), $i, $tmp;
    for($i=1; $i<$tournamentSize; $i++){
    $tmp = (int)rand ($gPopulationSize);
    if($fitness[$tmp]<$fitness[$parent]) //Fitness minimization
    $parent = $tmp;
    }
    return $parent;

}


/******************************************************************************
 * @procedure    crossover
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $genomes : matrix
 *   $newGenomes : matrix
 *   $father : int
 *   $mother : int
 *   $child : int
 *
 * @returns      matrix
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix crossover(matrix $genomes, matrix $newGenomes, int $father, int $mother, int $child)
{

    global int $gGenomeLength;
    int $i, $crossoverPoint = (int)rand ($gGenomeLength);
    for($i=0; $i<$crossoverPoint; $i++)
    $newGenomes[$child][$i] = $genomes[$father][$i];
    for($i=$crossoverPoint; $i<$gGenomeLength; $i++)
    $newGenomes[$child][$i] = $genomes[$mother][$i];
    return $newGenomes;

}


/******************************************************************************
 * @procedure    mutate
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $newGenomes : matrix
 *   $elites : int
 *   $mutationRate : float
 *
 * @returns      matrix
 * @source       RECURSIVESEARCH_of_PRocs2011 (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix mutate(matrix $newGenomes, int $elites, float $mutationRate)
{

    global int $gPopulationSize;
    global int $gGenomeLength;
    for($i=$elites; $i<$gPopulationSize; $i++){ //Don't mutate the elites
    for($j=0; $j<$gGenomeLength; $j++){
    if($mutationRate>`rand 100.0`){ //Mutate
    if(`rand 2.0`>1.0)
    $newGenomes[$i][$j] = $newGenomes[$i][$j] + 1;
    else
    $newGenomes[$i][$j] = $newGenomes[$i][$j] - 1;
    }
    }
    }
    return $newGenomes;

}


/******************************************************************************
 * @procedure    arrayMatch
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $array : string[]
 *   $match : string
 *
 * @returns      int
 * @source       replaceNode (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc int arrayMatch(string $array[], string $match)
{

    for ($item in $array)
    if ($item == $match)
    return true;

    return false;

}


/******************************************************************************
 * @procedure    getShardEdges
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $object : string
 *   $shardCount : int
 *   $shardIndexList : int[]
 *   $verbose : int
 *
 * @returns      string[]
 * @source       surfaceShatter (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc string[] getShardEdges(string $object, int $shardCount, int $shardIndexList[], int $verbose)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $faceIndex;
    int $edgeCount[] = `polyEvaluate -edge $object`;
    string $edge;
    string $edges[];
    string $edgeList[];
    string $faceList[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $edgeCount = `polyEvaluate -edge $object`;


    if ( $verbose == true )
    {
    print( (uiRes("m_surfaceShatter.kCreatingShardEdges")) );
    }

    // Create a list of the edges which create a shard.
    //
    for ( $i = 0; $i < $edgeCount[0]; $i++ )
    {
    $edge = $object + ".e[" + $i + "]";

    // Get the face list for the given edge.
    //
    $faceList  = getFaceList( $edge );

    // If there are more there are two faces associated with the
    // edge then check to see if it is a shard boundary.
    //
    if ( size( $faceList ) == 2 )
    {
    $faceIndex = getIndex( $faceList[0] );
    $index0    = $shardIndexList[ $faceIndex ] - 1;
    $faceIndex = getIndex( $faceList[1] );
    $index1    = $shardIndexList[ $faceIndex ] - 1;

    // If the shard indices are not the same then we have found
    // an edge between shard.  Store the edge in each shards edge
    // list.
    //
    if ( $index0 != $index1 )
    {
    $edges[ $index0 ] =	$edges[ $index0 ] + $edge + " ";
    $edges[ $index1 ] = $edges[ $index1 ] + $edge + " ";
    }
    }
    }

    return $edges;

}


/******************************************************************************
 * @procedure    createShader
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $cnv : string
 *   $mesh : string
 *   $group : string
 *   $map : int
 *
 * @returns      string
 * @source       textureToGeomApplyColor (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc string createShader(string $cnv, string $mesh, string $group, int $map)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $template = "";
    string $shader;
    string $dup[] = `duplicate $template`;
    string $name = `sets -empty -renderable true -n ($cnv + "SG" + $map)`;
    string $iobj = ($mesh + ".instObjGroups[0].objectGroups[" + $map + "]");

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $template = "";
    if ( objExists ($cnv + ".shaderTemplate") ) {
    $template = getAttr ($cnv + ".shaderTemplate");
    }

    if ( $template != "" && $template != "lambert1"
    && isShader( $template ) ) {
    $dup = `duplicate $template`;
    $shader = `rename $dup[0] ($cnv + "Shader" + $map)`;
    } else {
    $shader =
    `shadingNode -asShader "lambert" -n ($cnv + "Shader" + $map)`;
    }

    $name = `sets -empty -renderable true -n ($cnv + "SG" + $map)`;
    $iobj = ($mesh + ".instObjGroups[0].objectGroups[" + $map + "]");

    connectAttr
    ($name + ".memberWireframeColor")
    ($iobj + ".objectGrpColor");

    connectAttr -na $iobj ($name + ".dagSetMembers");
    connectAttr -na ($group + ".message") ($name + ".groupNodes");
    connectAttr -f ($shader + ".outColor") ($name + ".surfaceShader");

    return $shader;

}


/******************************************************************************
 * @procedure    textureConverterMeshes
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $node : string
 *
 * @returns      string[]
 * @source       textureToGeomApplyColor (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
proc string[] textureConverterMeshes(string $node)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $conn[] = `listConnections ($node + ".output")`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $conn = `listConnections ($node + ".output")`;
    return $conn;

}


/******************************************************************************
 * @procedure    selectTextureToGeomFaces
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $textureToGeom : string
 *   $index : int
 *
 * @returns      string[]
 * @source       textureToGeomApplyColor (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/
global proc string[] selectTextureToGeomFaces(string $textureToGeom, int $index)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $faces[] = getAttr ($textureToGeom + ".outSegFace[" + $index + "]");
    int $face;
    string $conn[] = textureConverterMeshes( $textureToGeom );
    string $con;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $conn = textureConverterMeshes( $textureToGeom );
    if ( size($conn) == 0 ) {
    return $conn;
    }

    $faces = getAttr ($textureToGeom + ".outSegFace[" + $index + "]");
    for ( $face in $faces ) {
    for ( $con in $conn ) {
    select -add ($con + ".f[" + $face + "]");
    }
    }

    return $conn;

}


/******************************************************************************
 * @procedure    stringInsertAtIndeX
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $index : int
 *   $list : string[]
 *   $item : string
 *
 * @returns      string []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] stringInsertAtIndeX(int $index, string $list[], string $item)
{

    print " stringInsertAtIndeX " ; print "line 39 "; print "\n" ;
    $list[$index]=$item;
    return($list);

}


/******************************************************************************
 * @procedure    IntInsertAtIndeX
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $index : int
 *   $list : int[]
 *   $item : int
 *
 * @returns      int []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IntInsertAtIndeX(int $index, int $list[], int $item)
{

    print " IntInsertAtIndeX " ; print "line 44 "; print "\n" ;
    $list[$index]=$item;
    return($list);

}


/******************************************************************************
 * @procedure    intArrayRemoveAtIndex
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $index : int
 *   $list : int[]
 *
 * @returns      int
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int intArrayRemoveAtIndex(int $index, int $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i;
    int $result[];
    int $len = size( $list );

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " intArrayRemoveAtIndex " ; print "line 49 "; print "\n" ;
    $len = size( $list );
    // Check for a valid index.
    if ( $index > $len  || $index < 0 ) {
    return( false );
    }
    for ( $i = 0; $i < $index; $i++ ) {
    $result[$i] = $list[$i];
    }
    for ( ; $i < $len - 1; $i++ ) {
    $result[$i] = $list[$i + 1];
    }
    $list = $result;
    return( true );

}


/******************************************************************************
 * @procedure    IntFillInsert
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $index : int
 *   $list : int[]
 *
 * @returns      int []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IntFillInsert(int $index, int $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result[];
    int $len = size( $list );

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " IntFillInsert " ; print "line 67 "; print "\n" ;
    $len = size( $list );
    $e=$k=0;
    if($len!=0){
    for ( $i = 0; $i <  $len+1; $i++ ) {
    if($i>0){
    if($k==0){
    if($list[$i-1]>$index){
    $result[$j] = $index;
    $k=1;
    $j++;
    }
    }
    if(($list[$i-1]<$index)||($list[$i-1]>$index)){
    $result[$j] = $list[$i-1];
    }
    if($list[$i-1]==$index){
    $result= $list; $e=1;break;
    }
    $j++;
    }
    }
    if(($e!=1)&&($k==0)){
    if(($list[$len-1]+1)==$index){
    $result[$len]=$index;
    }
    }
    }else{
    if($index==0){
    $result[0]=0;
    }
    }
    $list = $result;
    return($result);

}


/******************************************************************************
 * @procedure    StringIntFillInsert
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $index : int
 *   $list : int[]
 *   $indexS : string
 *   $listS : string[]
 *
 * @returns      string []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] StringIntFillInsert(int $index, int $list[], string $indexS, string $listS[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result[];
    int $len = size( $listS);
    string $resultS[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " StringIntFillInsert " ; print "line 107 "; print "\n" ;
    $len = size( $listS);
    $e=$k=0;
    $resultS=$listS;
    $resultS[$index]=$indexS;
    $listS=$resultS;
    return $resultS;

}


/******************************************************************************
 * @procedure    RemoveMatchingIntAtIndex
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $index : int
 *   $list : int[]
 *
 * @returns      int
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int RemoveMatchingIntAtIndex(int $index, int $list[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $result[];
    int $len = size( $list );

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " RemoveMatchingIntAtIndex " ; print "line 196 "; print "\n" ;
    $len = size( $list );
    for ( $j = $i = 0; $i <  $len; $i++ ) {
    if($list[$i]!=$index){
    $result[$j] = $list[$i];
    $j++;
    }
    }
    $list = $result;
    return( true );

}


/******************************************************************************
 * @procedure    AppendAllArrays
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $A : string[]
 *   $B : string[]
 *
 * @returns      string []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] AppendAllArrays(string $A[], string $B[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $AB[] = $A;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " AppendAllArrays " ; print "line 226 "; print "\n" ;
    $AB = $A;
    for($eachF in $B){
    $AB[`size($AB)`]= $eachF;
    }
    return $AB;

}


/******************************************************************************
 * @procedure    IndexPairArrayFunc
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $XNum : int[]
 *
 * @returns      int []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IndexPairArrayFunc(int $XNum[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Si = `size($XNum)`;
    int $Ci = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " IndexPairArrayFunc " ; print "line 325 "; print "\n" ;
    $Si = `size($XNum)`;
    $Ci = 0;
    if($Si>0){
    for($i=0; $i<$Si; $i++){
    $Zss = $XNum[$i]*2;
    $Yss = $Zss+1;
    $pair[$Ci++]= $Zss;
    $pair[$Ci++]= $Yss;
    }
    }
    return $pair;

}


/******************************************************************************
 * @procedure    MirrorLocAxisCRVs
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $AllCRVs : string[]
 *
 * @returns      string []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] MirrorLocAxisCRVs(string $AllCRVs[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Siz = `size($AllCRVs)`;
    string $AllNewM[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " MirrorLocAxisCRVs " ; print "line 340 "; print "\n" ;
    //how  many axis
    //what are the Plane normals of the mirror Planes..
    $Siz = `size($AllCRVs)`;
    for( $i = 0 ; $i <  $Siz; $i++ ) {
    $Pos_A = VecCurveCvs($AllCRVs[$i]);
    $VecPtsMirror= VecPtsToZMirrorPts($Pos_A);
    $AllNewM[$i] = VecArrayToCurve($VecPtsMirror);
    }
    return $AllNewM;

}


/******************************************************************************
 * @procedure    LocCurveEndZ
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $CurveItem : string[]
 *
 * @returns      vector []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] LocCurveEndZ(string $CurveItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $ALL = 0;
    int $i = 0;
    string $CurveItem[];
    string $LocEND[];
    vector $CRV_EndsVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " LocCurveEndZ " ; print "line 354 "; print "\n" ;
    $ALL = 0;
    $i = 0;
    for($eachCRV in $CurveItem){
    $numCVsL = `getAttr -size ($eachCRV+".controlPoints")`-1;
    $numCVsSL = $numCVsL-1;
    $CRVendPts[0] = ($eachCRV + ".cv[0]") ;
    $CRVendPts[1] = ($eachCRV + ".cv[" +  $numCVsL + "]") ;
    for($i = 0; $i < 2;$i++){
    $CRV_EndsVec[$i]= `pointPosition -w ($CRVendPts[$i])`;
    $LocEND[$ALL]= `Loc($CRV_EndsVec[$i])`;
    setAttr ($LocEND[$ALL]+".scale ") 0.5 0.5 0.5;
    $ALL++;
    }
    }
    editDisplayLayerMembers -noRecurse LocCurveEnds $LocEND;
    return $CRV_EndsVec;

}


/******************************************************************************
 * @procedure    CurvatureUtilitySimple
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $curvesZ : string[]
 *   $myCurve : string
 *
 * @returns      vector []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] CurvatureUtilitySimple(string $curvesZ[], string $myCurve)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $StepCycle;
    int $CountInter = 0;
    int $CurvCutNFound = 0;
    int $EachCRVcount = 0;
    float $T[];
    string $getIT = "";
    string $myCPOC;
    string $McrvU = $U[$CountInter];
    string $ParX = $t;
    vector $Pos3DVecOnCRV[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " CurvatureUtilitySimple " ; print "line 398 "; print "\n" ;
    $getIT = "";
    global float $U[];
    global float $T_G[];
    global string $Tstring[];
    global int $CurveCutIndex[];
    clear $U;
    clear $T_G;
    clear $Tstring;
    clear $CurveCutIndex;
    $myCPOC = `createNode closestPointOnCurve`;
    connectAttr ($myCurve+".worldSpace") ($myCPOC+".inCurve");
    $CountInter = 0;
    $CurvCutNFound = 0;
    $EachCRVcount = 0;
    for($myCurvex in $curvesZ){
    $CurvCutNFound=0;
    $StepCycle= $CUTsCurve =$ii = $ix = $a =$CountNearing =$CountFactorIzed= 0;
    $CurveSelection = `ls -fl  ($myCurvex+".ep[0:*]")`;
    $CurveEPzCount = size($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum2 = ( $numEPs -1 ) * 2;
    $myCPOC = `pointOnCurve  -ch on -pr 0.0 -p $myCurvex`;
    $step = $numEPrealNum2;
    $StepCycle =0;
    $smallest = 4.5;
    $FactorX = 2.0;
    for($a = 0; $a <= $step;$a++){

    $t =  $a/$step;
    setAttr ($myCPOC +  ".parameter") $t ;
    $Pos1  = `getAttr  ($myCPOC + ".position")`;
    $CurveVectors[$ii] = <<$Pos1[0], $Pos1[1], $Pos1[2]>>;
    $distance = `closestPointOnCurve -ip $Pos1[0] $Pos1[1] $Pos1[2] -q -d $myCurve`;
    if($distance<$smallest){
    $smallest = $distance/2.0;
    $Pos3DVecOnCRV[$ix] = FloatToVec(`closestPointOnCurve -ip $Pos1[0] $Pos1[1] $Pos1 [2] -q -p $myCurve`);
    if($CountNearing > -1){
    $step *= $FactorX; $a *= $FactorX;
    $CountFactorIzed++;
    }$CountNearing++;
    if($distance<0.005){
    if($CountNearing>1){
    for($aD = 0; $aD < $CountFactorIzed;$aD++){
    $step /= $FactorX;
    $a /= $FactorX;
    }
    $CountFactorIzed=0;
    $smallest = $distance*2.0;
    }
    $CountNearing=0;
    $Pos3DZ[`size($Pos3DZ)`]=$Pos3DVecOnCRV[$ix];
    //Loc $Pos3DVecOnCRV[$ix];
    $U[$CountInter] =`closestPointOnCurve -ip $Pos1[0] $Pos1[1] $Pos1[2] -q -u $myCurve`;
    $T[$CountInter]=$t;
    $T_G[$CountInter]=$t;
    $McrvU = $U[$CountInter];
    $ParX = $t;
    $Tstring[$CountInter]=$Tstring[$CountInter]+$ParX+",";
    $getIT+=($myCurve+" "+$McrvU);
    $getIT+= (" "+$myCurvex+" "+$ParX+" ");
    $CountInter++;
    $CurvCutNFound=1;
    $ix++;
    $CUTsCurve+=1;
    break;
    }					}
    ///////////////////////
    if(($distance>($smallest*2.0))&&($CountFactorIzed>0)){
    if($ix==0){
    for($aD = 0; $aD < $CountFactorIzed;$aD++){
    $step /= $FactorX;
    $a /= $FactorX;}
    $CountFactorIzed=0;
    $CountNearing=-1;
    }
    }
    $ii++;
    }
    delete $myCPOC;
    if($CurvCutNFound==1){
    $CurveCutIndex[`size($CurveCutIndex)`]=$EachCRVcount;
    }
    $EachCRVcount++;
    }
    return $Pos3DZ;

}


/******************************************************************************
 * @procedure    IntersectPlaneAndSegment
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Add : vector
 *   $p0 : vector
 *   $N : vector
 *   $p1 : vector
 *   $p2 : vector
 *
 * @returns      int
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int IntersectPlaneAndSegment(vector $Add, vector $p0, vector $N, vector $p1, vector $p2)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Number = 0;
    float $denominator = dotProduct( $N, $v12, 0 );
    float $numerator = dotProduct($N, $v10, 0 );
    float $t = $numerator / $denominator;
    vector $v12 = $p2 - $p1;
    vector $v10 = $p0 - $p1;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    // print " IntersectPlaneAndSegment " ; print "line 494 "; print "\n" ;
    $Number = 0;
    global vector $FoundVecG;
    // Get the $denominator. If it's 0, the plane and line are parallel.
    $v12 = $p2 - $p1;
    $denominator = dotProduct( $N, $v12, 0 );
    if ((!(`abs($denominator)` < -0.0001))&&(!(`abs($denominator)` == 0))){
    // Get the $numerator.
    $v10 = $p0 - $p1;
    $numerator = dotProduct($N, $v10, 0 );
    // Calculate t and see if the segment intersects the plane.
    $t = $numerator / $denominator;
    if (!(`abs($denominator)` < -0.0001)){
    if(!(`abs($denominator)` == 0)){
    if (($t >= 0) && ($t <= 1))
    {
    // The segment intersects the plane at $p1 + t * $v12.
    // If the plane and line segment intersect, add the
    // points of intersection to points and return true.
    // Append vecs
    $FoundVecG =$p1 + $t * $v12;
    Loc $FoundVecG;
    $Number= 1;
    }
    }
    }
    }else{
    $Number= 0;}
    return $Number;

}


/******************************************************************************
 * @procedure    IndexPattern
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $n : int
 *   $Pn : int
 *
 * @returns      int []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] IndexPattern(int $n, int $Pn)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IndexP[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " IndexPattern " ; print "line 525 "; print "\n" ;
    $IndexP[0]=$n*$Pn;
    $IndexP[1]=($n*$Pn)+1;
    return $IndexP;

}


/******************************************************************************
 * @procedure    InsideRectangle
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $is : string
 *   $AllOther : string[]
 *
 * @returns      int []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] InsideRectangle(string $is, string $AllOther[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CNT[];
    int $CN = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " InsideRectangle " ; print "line 532 "; print "\n" ;
    $CN = 0;
    for($isB in $AllOther){
    $MiddleA = BBoxInfo2DHW( $is, $HW_A);
    $MiddleB = BBoxInfo2DHW( $isB, $HW_B);
    $MaX =VecCom($MiddleA, 0);
    $MaZ =VecCom($MiddleA, 2);
    $MbX =VecCom($MiddleB, 0);
    $MbZ =VecCom($MiddleB, 2);
    $HH = ($HW_A[0]+ $HW_B[0])/2;
    $WW= ($HW_A[1]+ $HW_B[1])/2;
    $DaX = abs ($MaX- $MbX);
    $DaZ=  abs ($MaZ- $MbZ);
    if(($HH>$DaX )&&($WW>$DaZ )){
    $CNT[`size($CNT)`]=$CN;
    }
    $CN++;
    }
    return $CNT;

}


/******************************************************************************
 * @procedure    BBoxInfo2DHW
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Ii : string
 *   $H_W : float[]
 *
 * @returns      vector
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector BBoxInfo2DHW(string $Ii, float $H_W[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $DistW = distance2Pts( $AW, $BW);
    float $DistH = distance2Pts( $AH, $BH);
    vector $AW = <<$bbInfo[0], $bbInfo[1], $bbInfo[2]>>;
    vector $BW = <<$bbInfo[3], $bbInfo[4], $bbInfo[2]>>;
    vector $AH = <<$bbInfo[0], $bbInfo[1], $bbInfo[2]>>;
    vector $BH = <<$bbInfo[0], $bbInfo[4], $bbInfo[5]>>;
    vector $Mid = ($BW + $BH )/2.0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " BBoxInfo2DHW " ; print "line 556 "; print "\n" ;
    $bbInfo =`xform -query -bb $Ii`;
    $AW = <<$bbInfo[0], $bbInfo[1], $bbInfo[2]>>;
    $BW = <<$bbInfo[3], $bbInfo[4], $bbInfo[2]>>;
    $DistW = distance2Pts( $AW, $BW);
    $AH = <<$bbInfo[0], $bbInfo[1], $bbInfo[2]>>;
    $BH = <<$bbInfo[0], $bbInfo[4], $bbInfo[5]>>;
    $DistH = distance2Pts( $AH, $BH);
    $H_W[0]=$DistW;
    $H_W[1]=$DistH;
    $Mid = ($BW + $BH )/2.0;
    return  $Mid ;

}


/******************************************************************************
 * @procedure    BBoxInfo2D
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $i : string
 *
 * @returns      float[ ]
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float[ ] BBoxInfo2D(string $i)
{

    print " BBoxInfo2D " ; print "line 581 "; print "\n" ;
    select $i;
    $bbInfo =`xform -query -bb $i`;
    return $bbInfo;

}


/******************************************************************************
 * @procedure    VecCurveCvs
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $CurveItem : string
 *
 * @returns      vector []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecCurveCvs(string $CurveItem)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $EACHCVposAZ[];
    string $CurveSelection[];
    vector $CurveLocArrayVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " VecCurveCvs " ; print "line 588 "; print "\n" ;
    $CurveSelection = `ls -fl ($CurveItem+".cv[*]")`;
    for ($eachZA in $CurveSelection) {
    $EACHCVposAZ = `pointPosition -w ($eachZA)`;
    $CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    }
    return $CurveLocArrayVec;

}


/******************************************************************************
 * @procedure    GetCRV2D_Matrix
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $PtsVecs : vector[]
 *
 * @returns      matrix
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix GetCRV2D_Matrix(vector $PtsVecs[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $MidPt[];
    vector $UpAxis = <<0,1,0>>;
    vector $DirLine = DirectionFN($PtsVecs[0], $PtsVecs[1]);
    vector $Vperp = crossProduct( $DirLine, $UpAxis, 0, 0 );

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " GetCRV2D_Matrix " ; print "line 600 "; print "\n" ;
    $MidPt = MidPoint($PtsVecs[0], $PtsVecs[1]);
    $UpAxis = <<0,1,0>>;
    $DirLine = DirectionFN($PtsVecs[0], $PtsVecs[1]);
    $Vperp = crossProduct( $DirLine, $UpAxis, 0, 0 );
    $norm = $UpAxis;
    $bi = $Vperp;
    $tan = $DirLine;
    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
    ($bi.x), ($bi.y), ($bi.z),  0.0;     // Y axis
    ($tan.x), ($tan.y), ($tan.z), 0.0;     // Z axis
    $MidPt[0], $MidPt[1], $MidPt[2], 1.0  >>;  // Position
    return $mI;

}


/******************************************************************************
 * @procedure    Matrix_Curve_Translation2D
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $VecPairA : vector[]
 *   $VecPairB : vector[]
 *   $CurveVecPointZ : vector[]
 *
 * @returns      vector []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] Matrix_Curve_Translation2D(vector $VecPairA[], vector $VecPairB[], vector $CurveVecPointZ[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $LengthA = distance2Pts ($VecPairA[0], $VecPairA[1]);
    float $LengthB = distance2Pts ($VecPairB[0], $VecPairB[1]);
    float $LengthAB;
    float $Sign_F;
    vector $EmptyVecA[];
    vector $EmptyVecB[];
    vector $NVecPointZ[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " Matrix_Curve_Translation2D " ; print "line 618 "; print "\n" ;
    matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    matrix $matrixB[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;
    $matrixA =GetCRV2D_Matrix($VecPairA);
    $matrixB = GetCRV2D_Matrix($VecPairB);
    $LengthA = distance2Pts ($VecPairA[0], $VecPairA[1]);
    $LengthB = distance2Pts ($VecPairB[0], $VecPairB[1]);
    if($LengthA<$LengthB){$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}else{$LengthAB = $LengthB/$LengthA;  $Sign_F=1.0;}
    $LengthAB *= $Sign_F;
    $matrixB[3][3] =$LengthAB;
    $NVecPointZ = MultPointMatrixArray($CurveVecPointZ, $matrixA,$matrixB);
    return $NVecPointZ;

}


/******************************************************************************
 * @procedure    FloatArrayAB
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $ptA : float
 *   $ptB : float
 *   $STEPFA : float
 *
 * @returns      float []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] FloatArrayAB(float $ptA, float $ptB, float $STEPFA)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $St = 0;
    float $CrvTS;
    float $CrvTE;
    float $STEPF = $STEPFA-1.0;
    float $segN = ($CrvTE-$CrvTS)/$STEPF;
    float $FlineV[];
    float $AddS = $CrvTS;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " FloatArrayAB " ; print "line 643 "; print "\n" ;
    if($ptA>$ptB){
    $CrvTS = $ptB;
    $CrvTE = $ptA;
    }else{
    $CrvTS = $ptA;
    $CrvTE = $ptB;
    }
    $STEPF = $STEPFA-1.0;
    $segN = ($CrvTE-$CrvTS)/$STEPF;
    $FlineV[0]=$CrvTS;
    $St = 0;
    $AddS = $CrvTS;
    for( $Vi=0; $Vi < $STEPF; $Vi++ ){
    $FlineV[$Vi+1] = $AddS+=$segN;
    $St++;
    }
    return $FlineV;

}


/******************************************************************************
 * @procedure    VecCurveSEnds
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $CurveItem : string[]
 *
 * @returns      vector []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VecCurveSEnds(string $CurveItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $AllEnds = 0;
    string $CRVendPts[];
    vector $CRV_EndsVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " VecCurveSEnds " ; print "line 666 "; print "\n" ;
    $AllEnds = 0;
    for($eachCRV in $CurveItem){
    $numCVsL = `getAttr -size ($eachCRV+".controlPoints")`-1;
    $numCVsSL = $numCVsL-1;
    $CRVendPts[0] = ($eachCRV + ".cv[0]") ;
    $CRVendPts[1] = ($eachCRV + ".cv[" +  $numCVsL + "]") ;
    for($i = 0; $i < 2;$i++){
    $CRV_EndsVec[$AllEnds]= `pointPosition -w ($CRVendPts[$i])`;
    $AllEnds++;
    }
    }
    return $CRV_EndsVec;

}


/******************************************************************************
 * @procedure    DoesCurveBBcrossPlane
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $CrvS : string
 *
 * @returns      int
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int DoesCurveBBcrossPlane(string $CrvS)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IfTrue;
    int $InN[];
    int $SizeN = `size($Pos)`;
    float $Rxz_HWA[];
    vector $p0i = <<0.0, 0.0, 0.0>>;
    vector $Ni = <<1.0, 0.0, 0.0>>;
    vector $BoxA[];
    vector $Pos[];
    vector $FoundPt;
    vector $VecPar[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " DoesCurveBBcrossPlane " ; print "line 684 "; print "\n" ;
    //most important is the plane normaland its pt vector
    //  further on you will want to see if it crosses more then one plane or axis
    // if radial mirroring
    $p0i = <<0.0, 0.0, 0.0>>;
    $Ni = <<1.0, 0.0, 0.0>>;
    $BoxA=GetBboxFromItemF($CrvS,$Rxz_HWA);
    $Pos = $BoxA;
    $SizeN = `size($Pos)`;
    int $Fn ,$Nn =0;
    for($Nn=0; $Nn<$SizeN-1; $Nn++){
    $InN=IndexPattern($Nn,1);
    $VecPar[0]=$Pos[$InN[0]];
    $VecPar[1]=$Pos[$InN[1]];
    $IfTrue = IntersectPlaneAndSegment( $FoundPt, $p0i, $Ni, $VecPar[0],$VecPar[1]);
    if($IfTrue ==1){
    $Fn++;
    break;
    }
    }
    return $IfTrue;

}


/******************************************************************************
 * @procedure    VecEqual
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Vai : vector
 *   $XYZ : int
 *   $Val : float
 *
 * @returns      vector
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector VecEqual(vector $Vai, int $XYZ, float $Val)
{

    print " VecEqual " ; print "line 724 "; print "\n" ;
    $x = $Vai.x;
    $y = $Vai.y;
    $z = $Vai.z;
    if($XYZ==0){ $x=$Val;} if($XYZ==1){ $y=$Val;} if($XYZ==2){ $z=$Val;}
    $Vai = <<$x, $y, $z>>;
    return $Vai;

}


/******************************************************************************
 * @procedure    GetBboxFromItemF
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $ii : string
 *   $Rxz_HW : float[]
 *
 * @returns      vector []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] GetBboxFromItemF(string $ii, float $Rxz_HW[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $bbInfo[] = `BBoxInfo2D $ii`;
    float $bbSize[];
    vector $VecBBox[];
    vector $Middle = <<(($bbInfo[3]+$bbInfo[0])*0.5),0.0,(($bbInfo[5]+$bbInfo[2])* 0.5)>>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " GetBboxFromItemF " ; print "line 734 "; print "\n" ;
    //get bounding box co-ordinates
    $bbInfo = `BBoxInfo2D $ii`;
    $VecBBox[0]=<<$bbInfo[0],0,$bbInfo[5]>>;
    $VecBBox[1]=<<$bbInfo[3],0,$bbInfo[5]>>;
    $VecBBox[2]=<<$bbInfo[3],0,$bbInfo[2]>>;
    $VecBBox[3]=<<$bbInfo[0],0,$bbInfo[2]>>;
    $Middle = <<(($bbInfo[3]+$bbInfo[0])*0.5),0.0,(($bbInfo[5]+$bbInfo[2])* 0.5)>>;
    //work out the size of the bounding box + offset value
    $bbSize[0] = ($bbInfo[3] - $bbInfo[0]);
    $bbSize[1] = ($bbInfo[5] - $bbInfo[2]);
    //$Rxz_HW[0] = ($bbInfo[3]+$bbInfo[0])*0.5;
    //$Rxz_HW[1] =($bbInfo[5]+$bbInfo[2])* 0.5;
    $Rxz_HW[0] = $bbInfo[0];
    $Rxz_HW[1] = $bbInfo[2];
    $Rxz_HW[2] = $bbSize[0];
    $Rxz_HW[3] = $bbSize[1];
    return $VecBBox;

}


/******************************************************************************
 * @procedure    DoesCurveBBcrossCurve
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $CrvS : string
 *   $CrvAll : string[]
 *
 * @returns      int []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] DoesCurveBBcrossCurve(string $CrvS, string $CrvAll[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeN = `size($Pos)`;
    int $InN[];
    int $IndexF[];
    int $SizeC = `size($CrvAll)`;
    int $INtf = 0;
    string $StringMCRV[];
    vector $Pos[];
    vector $FoundPt;
    vector $VecPar[];
    vector $p0i;
    vector $Ni;
    vector $Cur_CRV[];
    vector $UpAxis = <<0.0,1.0,0.0>>;
    vector $DirLine;
    vector $Vperp;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " DoesCurveBBcrossCurve " ; print "line 756 "; print "\n" ;
    global vector $FoundVecG;
    //most important is the plane normaland its pt vector
    //  further on you will want to see if it crosses more then one plane or axis
    // if radial mirroring
    $Pos=VecCurveCvs($CrvS);
    $SizeN = `size($Pos)`;
    int $Fn ,$Nn =0;
    $SizeC = `size($CrvAll)`;
    $UpAxis = <<0.0,1.0,0.0>>;
    for($j=0; $j<$SizeC; $j++){
    $Cur_CRV  =VecCurveCvs($CrvAll[$j]);
    ////for each other curv segment
    for($i=0; $i<$SizeN-1; $i++){
    $Fn=0;
    for($Nn=0; $Nn<$SizeN-1; $Nn++){
    $IfTrue=0;
    $VecPar[0]=$Pos[$Nn];  $VecPar[1]=$Pos[$Nn+1];
    $IfTrue = RayIntersect($FoundPt,{$VecPar[0],$VecPar[1]},{$Cur_CRV[$i],$Cur_CRV[$i+1]});

    if($IfTrue ==1){
    $BIfTruei=0;
    $BIfTruei = RayIntersect($FoundPt,{$Cur_CRV[$i],$Cur_CRV[$i+1]},{$VecPar[0],$VecPar[1]});
    if($BIfTruei ==1){
    $INtf = 0;
    $INtf=IsInside4Vec({$Cur_CRV[$i],$Cur_CRV[$i+1],$VecPar[0],$VecPar[1]},$FoundPt);
    if(($INtf ==1)||($BIfTruei ==1)){
    $IndexF[`size($IndexF)`]=$j;
    //Loc $FoundVecG;
    $InN=IndexPattern($i,1);
    $StringMCRV[`size($StringMCRV)`]=($InN[0]+","+$InN[1]);
    $InN=IndexPattern($Nn,1);
    $StringMCRV[`size($StringMCRV)`-1]=  ($StringMCRV[size($StringMCRV)-1]+","+$InN[0] +","+$InN[1]+"\n");
    $Fn+=1;
    break;
    }
    }
    }
    }
    }
    }
    return $IndexF;

}


/******************************************************************************
 * @procedure    RayIntersect
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $FoundPt : vector
 *   $VecPar : vector[]
 *   $Cur_CRV : vector[]
 *
 * @returns      int
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int RayIntersect(vector $FoundPt, vector $VecPar[], vector $Cur_CRV[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IfTrueiii = 0;
    vector $UpAxis = <<0.0,1.0,0.0>>;
    vector $p0i = ($VecPar[0]+$VecPar[1])/2.0;
    vector $DirLine = DirectionFN($VecPar[0],$VecPar[1]);
    vector $Ni = crossProduct( $DirLine, $UpAxis, 0, 0 );
    vector $Fv = <<0,0,0>>;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    //print " RayIntersect " ; print "line 814 "; print "\n" ;
    global vector $FoundVecG;
    $UpAxis = <<0.0,1.0,0.0>>;
    $p0i = ($VecPar[0]+$VecPar[1])/2.0;
    $DirLine = DirectionFN($VecPar[0],$VecPar[1]);
    $Ni = crossProduct( $DirLine, $UpAxis, 0, 0 );
    $Fv = <<0,0,0>>;
    $Ni=`unit($Ni)`;
    $IfTrueiii = 0;
    $IfTrueiii = IntersectPlaneAndSegment($FoundPt, $p0i, $Ni, $Cur_CRV[0],$Cur_CRV[0+1]);
    $FoundPt=$FoundVecG;
    return $IfTrueiii;

}


/******************************************************************************
 * @procedure    RenderCurveSeg
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $SelC : string
 *   $STEPCrv : float
 *   $CrvTSi : float
 *   $CrvTEi : float
 *
 * @returns      vector []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] RenderCurveSeg(string $SelC, float $STEPCrv, float $CrvTSi, float $CrvTEi)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $SizeSeg = `size($CreateSegAT)`;
    int $CountT = 0;
    float $CreateSegAT[];
    float $t = 0;
    string $myCurvex = $SelC;
    vector $NewCurveVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " RenderCurveSeg " ; print "line 870 "; print "\n" ;
    //float $STEPCrv =22.0;
    $CreateSegAT =FloatArrayAB($CrvTSi,$CrvTEi,$STEPCrv);
    $myCurvex = $SelC;
    $myCPOC = `pointOnCurve  -ch on -pr 0.0 -p $myCurvex`;
    $SizeSeg = `size($CreateSegAT)`;
    $CountT = 0;
    $t = 0;
    for($a = 0; $a < $SizeSeg;$a++){
    $t =  $CreateSegAT[$CountT];
    if($t>=1){$t=1;}
    if($t<=0){$t=0;}
    setAttr ($myCPOC +  ".parameter") $t ;
    $NewCurveVec[$CountT] = `getAttr  ($myCPOC + ".position")`;
    $CountT++;
    }
    delete $myCPOC;
    return $NewCurveVec;

}


/******************************************************************************
 * @procedure    LocCurveEnds
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $CurveItem : string[]
 *   $CurveLocArrayVec : vector[]
 *
 * @returns      vector []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] LocCurveEnds(string $CurveItem[], vector $CurveLocArrayVec[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $CRVendPts[];
    string $LocEND;
    vector $CRV_EndsVec[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " LocCurveEnds " ; print "line 892 "; print "\n" ;
    $numCVsL = `getAttr -size ($CurveItem[0]+".controlPoints")`-1;
    $numCVsSL = $numCVsL-1;
    $CRVendPts[0] = ($CurveItem[0] + ".cv[0]") ;
    $CRVendPts[1] = ($CurveItem[0] + ".cv[" +  $numCVsL + "]") ;
    for($i = 0; $i < 2;$i++){
    $CRV_EndsVec[$i]= `pointPosition -w ($CRVendPts[$i])`;
    $LocEND = `Loc($CRV_EndsVec[$i])`;
    setAttr ($LocEND+".scale") 0.5;
    editDisplayLayerMembers -noRecurse LocCurveEnds $LocEND;
    }
    return $CRV_EndsVec;

}


/******************************************************************************
 * @procedure    getSelectionType
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      string
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string getSelectionType()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Value = stringArrayGmatchFind($idnodeType3, "controlPoint");
    string $selectionFindType[] = `ls -sl -fl`;
    string $idnodeType2;
    string $Relativesselection[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " getSelectionType " ; print "line 914 "; print "\n" ;
    $selectionFindType = `ls -sl -fl`;
    $Relativesselection = `listRelatives $selectionFindType[0]`;
    if (`size($Relativesselection)` == 0){ string $idnodeType3[] = `nodeType -inherited $selectionFindType[0]`;
    $Value = stringArrayGmatchFind($idnodeType3, "controlPoint");
    if($Value == 1){ $idnodeType2="controlPoint";}else{ $idnodeType2=$idnodeType3[(`size($idnodeType3)`)-1];}
    }else{ $idnodeType2 = `nodeType $Relativesselection[0]`;}
    return $idnodeType2;

}


/******************************************************************************
 * @procedure    MostRightClockWiseInt
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Vecs : vector[]
 *   $Two : int[]
 *
 * @returns      int
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int MostRightClockWiseInt(vector $Vecs[], int $Two[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $TwoNew[];
    string $ThreePoints[] = { "0", "1", "2"};

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " MostRightClockWiseInt " ; print "line 926 "; print "\n" ;
    $ThreePoints = { "0", "1", "2"};
    $U1 = TwoVecsOrFloats($Vecs[1], $Vecs[0]);
    $V1 = TwoVecsOrFloats($Vecs[2], $Vecs[0]);
    $U2 = TwoVecsOrFloats($Vecs[2], $Vecs[0]);
    $V2 = TwoVecsOrFloats($Vecs[1], $Vecs[0]);
    $normalV[0] = FloatToVec( crossProduct( $U1, $V1, 0, 1 ) );
    $normalV[1] = FloatToVec( crossProduct( $U2, $V2, 0, 1 ) );
    $normalA = `unit ($normalV[0])`;
    $normalB = `unit ($normalV[1])`;
    $normalAAdd = $normalA[0] + $normalA[1];
    $normalAAdd2 = $normalB[0] + $normalB[1];
    if( $normalAAdd< $normalAAdd2){
    $TwoNew ={$Two[1], $Two[0]};
    }else{
    $TwoNew ={$Two[0], $Two[1]};
    }
    $Two = $TwoNew;
    return $TwoNew[0];

}


/******************************************************************************
 * @procedure    IsInside4Vec
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $ABveci : vector[]
 *   $ABV : vector
 *
 * @returns      int
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int IsInside4Vec(vector $ABveci[], vector $ABV)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $TFi = 0;
    float $AX = $ABV.x;
    float $AZ = $ABV.z;
    vector $VecOrder[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " IsInside4Vec " ; print "line 950 "; print "\n" ;
    $VecOrder=VectorClockWise($ABveci);
    $AX = $ABV.x;
    $AZ = $ABV.z;
    $TFi = 0;
    $TFi=isInsideCRV ($VecOrder,$AX, $AZ );
    return $TFi;

}


/******************************************************************************
 * @procedure    VectorClockWise
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $ABvec : vector[]
 *
 * @returns      vector []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] VectorClockWise(vector $ABvec[])
{

    print " VectorClockWise " ; print "line 961 "; print "\n" ;
    global int $TRi[];
    $CountT=$Cb=0;
    $TwoX={(1+$Cb),(2+$Cb)};
    $SizeVc =$SizeN =`size($ABvec)`;
    $TR=CreateIntIndex($SizeVc);
    $iR=$Run=$SizeVc-2;
    for($iR=$Run; $Cb<$SizeN; ){
    $Run=$SizeVc-2;
    if($Run==0){break;}
    $CountT=0;
    for($CountT=0; $CountT<$Run; $CountT++){
    $TwoX={(1+$Cb),(2+$Cb+$CountT)};
    $tempABV ={$ABvec[$TR[$Cb]],$ABvec[$TR[$TwoX[0]]],$ABvec[$TR[($TwoX[1])]]};
    MostRightClockWiseInt ($tempABV, $TwoX);
    $TempA=$TR[$TwoX[0]];
    $TempB=$TR[$TwoX[1]];
    $TwoX={(1+$Cb),(2+$Cb+$CountT)};
    $TR[$TwoX[0]]=$TempA;
    $TR[$TwoX[1]]=$TempB;
    }
    $Cb++;
    $SizeVc-=1;
    }
    for($i=0; $i<$SizeN; $i++){
    $tempSave[$i]=$ABvec[$TR[$i]];
    }
    $TRi=$TR;
    return $tempSave;

}


/******************************************************************************
 * @procedure    isInsideCRV
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $lineCurve : vector[]
 *   $x : float
 *   $z : float
 *
 * @returns      int
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int isInsideCRV(vector $lineCurve[], float $x, float $z)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $i = 0, $j = 0;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " isInsideCRV " ; print "line 994 "; print "\n" ;
    // step through each set of 2 points in the curve
    // find the formula of the line between and the intersection with the point
    // if the points greater are more than the points less along that axis, then it is inside if they are even, it is outside
    $num = `size($lineCurve)`;
    $i = 0, $j = 0;
    while ($i < $num) {
    if ( $i > 0 ) {
    $x1 = $x2;
    $z1 = $z2;
    }
    $p2 = $lineCurve[$i];
    $x2 = $p2[0];
    $z2 = $p2[2];
    if ( $i > 0 ) {
    if ( ($z2 > $z && $z1 < $z)  ||  ($z1 > $z && $z2 < $z) ) {
    // the line crosses the z of the test point - check where x val of intersection. Form line using (x2,z2)   and  (x1,z1)
    if ($x2 == $x1) {
    $xVals[$j] = $x2;
    } else {
    $m = ($z1 - $z2) / ($x1 -$x2);
    $b = $z1 - $m * $x1;
    // now z = mx + b    OR  x = (z-b)/m
    $xVals[$j] = ($z-$b)/$m; }
    $j++; }
    }
    $i++; }
    $xVals = sort ($xVals);
    $k = 0;
    while ($k < size($xVals)) {
    $xa = $xVals[$k]; $k++;
    $xb = $xVals[$k]; $k++;
    if ($xa < $x && $xb > $x) {
    return 1;
    }
    }
    return 0;

}


/******************************************************************************
 * @procedure    CutExisting
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $sortedTGF : float
 *   $crvsFC : string
 *
 * @returns      string []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] CutExisting(float $sortedTGF, string $crvsFC)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Sbyte = `sizeBytes $crvsFC`;
    int $SizeCuts = 2;
    float $TempU[];
    float $Hsize = $SizeCuts;
    float $CrvTSi = $TempU[$iC];
    float $CrvTEi = $TempU[$iC+1];
    string $NewCutCRVs[];
    vector $CVecL[];
    vector $CRVSEG_A[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " CutExisting " ; print "line 1616 "; print "\n" ;
    $Sbyte = `sizeBytes $crvsFC`;
    if($Sbyte==0){print " ERROR HERE 77777777777777777777777777777777777777777777777777777777777777777777  ";}
    global vector $MiddleSeg;
    clear  $TempU;
    $TempU[`size($TempU)`]=0.0;
    $TempU[`size($TempU)`]= $sortedTGF;
    $TempU[`size($TempU)`]=1.0;
    $SizeCuts = 2;
    $Hsize = $SizeCuts;
    for($iC=0; $iC<$Hsize; $iC++){
    clear $CRVSEG_A;
    $CrvTSi = $TempU[$iC];
    $CrvTEi = $TempU[$iC+1];
    $CRVSEG_A=RenderCurveSeg($crvsFC,44,$CrvTSi,$CrvTEi);
    if($iC==0){$MiddleSeg=$CRVSEG_A[`size($CRVSEG_A)`-1];
    }
    $NewCutCRVs[`size($NewCutCRVs)`]=VecArrayToCurveB($CRVSEG_A);
    }
    select -r $NewCutCRVs;
    PAUSE;  PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
    PAUSE;  PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
    PAUSE;  PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
    PAUSE;  PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
    PAUSE;  PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
    PAUSE;  PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
    PAUSE;  PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
    PAUSE;  PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
    PAUSE;  PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
    print $NewCutCRVs;
    return $NewCutCRVs;

}


/******************************************************************************
 * @procedure    CRVIndexPairF
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $XNum : int
 *
 * @returns      int
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int CRVIndexPairF(int $XNum)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Zss = int($XNum/2.0);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Zss = int($XNum/2.0);
    return $Zss;

}


/******************************************************************************
 * @procedure    CRV2Dscript
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Sel_list : string[]
 *   $Sel : string[]
 *
 * @returns      string []
 * @source       THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string [] CRV2Dscript(string $Sel_list[], string $Sel[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $MoreThenOne = 0;
    int $m_Or_e[];
    int $NoCUT = 1;
    int $DA[];
    int $DB[];
    int $TempINA[];
    int $TempINAi[];
    int $ListDelete[];
    int $VecTA;
    int $VecTB;
    int $Ocrv = 0;
    int $SizeSeg;
    int $CRV_IND[];
    int $iC = 0;
    int $CCi[];
    int $IndexR[];
    int $IndexO[];
    int $SizeCuts = 0;
    int $SFoundC = 0;
    int $IndexB[];
    int $tempStringI[];
    int $FoundCut_Index[];
    int $FC = 0;
    int $IndexRb[];
    int $IndexOb[];
    int $USortK[];
    int $tempIN[];
    int $Tsize = `size($U)`;
    int $CRVnum = CRVIndexPairF($VecTB);
    int $ExistCRVn = $IndexR[$USortK[$IndexR[$CRVnum]]];
    int $ENDsAB[] = IndexPairArrayFunc({$ExistCRVn});
    int $ExistCRVVEC = $ENDsAB[0];
    int $DistSSSortA[];
    int $DistSSSortB[];
    float $sortedTG[];
    float $Arc;
    float $oldUii[] = $U;
    float $TempU[];
    float $MperS = ($Arc*($U[0]));
    float $MperE = ($Arc*(1-$U[$SizeCuts-1]));
    float $TempUi[];
    float $Hsize = `size($U)`;
    float $CrvTSi = $U[$iC];
    float $CrvTEi = $U[$iC+1];
    float $Mper = ($Arc*($U[$iC+1]-$U[$iC]));
    float $dist_A[] = ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [0]);
    float $dist_B[] = ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [1]);
    float $SmallestDistA = $dist_A[$DistSSSortA[0]];
    float $SmallestDistB = $dist_B[$DistSSSortB[0]];
    string $tempCRVNAMES[] = $CurveNames;
    string $CollectCRV[];
    string $crvsFound[];
    string $crvsOther[];
    string $crvsFoundCut[];
    string $NewCutCRVs[];
    string $NewCRVc[];
    vector $CUTcrv[];
    vector $allNearVecEnds[];
    vector $tempVi[];
    vector $tempVii[];
    vector $DrawnVecEnds[];
    vector $SnapEnds[];
    vector $tempV[];
    vector $CRVSEG_A[];
    vector $CRVPts[];
    vector $TranlatedCRV[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    print " \t\tproc string [] CRV2Dscript(string $Sel_list[],string $Sel[]){ " ; print "LINE_B 1 "; print "\n" ;
    print " \t\t " ; print "LINE_B 2 "; print "\n" ;
    global int $Ind3dV2P[];
    print " \t\t\tglobal int $Ind3dV2P[]; " ; print "LINE_B 3 "; print "\n" ;
    global float $U[];
    print " \t\t\tglobal float $U[]; " ; print "LINE_B 4 "; print "\n" ;
    global string $Tstring[];
    print " \t\t\tglobal string $Tstring[]; " ; print "LINE_B 5 "; print "\n" ;
    global float $T_G[];
    print " \t\t\tglobal float $T_G[]; " ; print "LINE_B 6 "; print "\n" ;
    global int $CurveCutIndex[];
    print " \t\t\tglobal int $CurveCutIndex[]; " ; print "LINE_B 7 "; print "\n" ;
    global float $DistSSS;
    print " \t\t\tglobal float $DistSSS; " ; print "LINE_B 8 "; print "\n" ;
    global string $CrvN_And_Vector[];
    print " \t\t\tglobal string $CrvN_And_Vector[]; " ; print "LINE_B 9 "; print "\n" ;
    global int $MCurveIndex[];
    print " \t\t\tglobal int $MCurveIndex[]; " ; print "LINE_B 10 "; print "\n" ;
    global vector $AllKnowVecEnds[];
    print " \t\t\tglobal vector $AllKnowVecEnds[]; " ; print "LINE_B 11 "; print "\n" ;
    global string $CurveNames[];
    print " \t\t\tglobal string $CurveNames[]; " ; print "LINE_B 12 "; print "\n" ;
    global int $CRVNameIndex[];
    print " \t\t\tglobal int $CRVNameIndex[]; " ; print "LINE_B 13 "; print "\n" ;
    global int $Ind3d_past[];
    print " \t\t\tglobal int $Ind3d_past[]; " ; print "LINE_B 14 "; print "\n" ;
    global int $SizeVABpast[];
    print " \t\t\tglobal int $SizeVABpast[]; " ; print "LINE_B 15 "; print "\n" ;
    global vector $MiddleSeg;
    print " \t\t\tglobal vector $MiddleSeg; " ; print "LINE_B 16 "; print "\n" ;
    $tempCRVNAMES = $CurveNames;
    print " \t\t\tstring $tempCRVNAMES[]= $CurveNames;  " ; print "LINE_B 17 "; print "\n" ;
    print " \t\t\tstring $AllNew[],$TEMP_new[]; " ; print "LINE_B 18 "; print "\n" ;
    print " \t\t\tvector $CUTcrv[]; " ; print "LINE_B 19 "; print "\n" ;
    $MoreThenOne = 0;
    print " \t\t\tint $MoreThenOne=0;\t " ; print "LINE_B 20 "; print "\n" ;
    print " \t\t\tint $m_Or_e[]; " ; print "LINE_B 21 "; print "\n" ;
    //DEBUG
    print " \t\t\t//DEBUG   " ; print "LINE_B 22 "; print "\n" ;
    $NoCUT = 1;
    print " \t\t\tint $NoCUT =1; " ; print "LINE_B 23 "; print "\n" ;
    print " \t\t\tvector $allNearVecEnds[];\t " ; print "LINE_B 24 "; print "\n" ;
    print " \t\t\tint $DA[]; " ; print "LINE_B 25 "; print "\n" ;
    print " \t\t\tint $DB[]; " ; print "LINE_B 26 "; print "\n" ;
    print " \t\t\tint $TempINA[]; " ; print "LINE_B 27 "; print "\n" ;
    print " \t\t\tint $TempINAi[]; " ; print "LINE_B 28 "; print "\n" ;
    print " \t\t\tvector $tempVi[]; " ; print "LINE_B 29 "; print "\n" ;
    print " \t\t\tvector $tempVii[]; " ; print "LINE_B 30 "; print "\n" ;
    print " \t\t\tint $ListDelete[]; " ; print "LINE_B 31 "; print "\n" ;
    print " \t\t\tint $VecTA; " ; print "LINE_B 32 "; print "\n" ;
    print " \t\t\tint $VecTB; " ; print "LINE_B 33 "; print "\n" ;
    $Ocrv = 0;
    print " \t\t\tint $Ocrv=0; " ; print "LINE_B 34 "; print "\n" ;
    print " \t\t\tfloat $sortedTG[];\t\t\t\t\t " ; print "LINE_B 35 "; print "\n" ;
    print " \t\t\tfloat $dist_A[],$dist_B[],$SA,$SB; " ; print "LINE_B 36 "; print "\n" ;
    print " \t\t\tvector $DrawnVecEnds[]; " ; print "LINE_B 37 "; print "\n" ;
    print " \t\t\tstring $CollectCRV[]; " ; print "LINE_B 38 "; print "\n" ;
    print " \t\t\tint $SizeSeg; " ; print "LINE_B 39 "; print "\n" ;
    print " \t\t\tint $CRV_IND[]; " ; print "LINE_B 40 "; print "\n" ;
    clear $AllNew;
    print " \t\t\tclear $AllNew; " ; print "LINE_B 41 "; print "\n" ;
    $iC = 0;
    print " \t\t\tint $iC=0; " ; print "LINE_B 42 "; print "\n" ;
    clear $Sel_list;
    print " \t\t\tclear $Sel_list; " ; print "LINE_B 43 "; print "\n" ;
    for($iC=0; $iC<`size($CRVNameIndex)`; $iC++){
    print " \t\t\tfor($iC=0; $iC<`size($CRVNameIndex)`; $iC++){ " ; print "LINE_B 44 "; print "\n" ;
    $TEMP_new[$iC]=$tempCRVNAMES[$CRVNameIndex[$iC]];
    print " \t\t\t\t$TEMP_new[$iC]=$tempCRVNAMES[$CRVNameIndex[$iC]]; " ; print "LINE_B 45 "; print "\n" ;
    }
    print " \t\t\t} " ; print "LINE_B 46 "; print "\n" ;
    $Sel_list =$TEMP_new;
    print " \t\t\t$Sel_list =$TEMP_new; " ; print "LINE_B 47 "; print "\n" ;
    print " \t\t\tvector $SnapEnds[]; " ; print "LINE_B 48 "; print "\n" ;
    print " \t\t\tint $CCi[]; " ; print "LINE_B 49 "; print "\n" ;
    print " \t\t\tvector $Ind3di[],$NewVecE[],$DrawnVecEnds[]; " ; print "LINE_B 50 "; print "\n" ;
    print " \t\t\tint $IndexR[]; " ; print "LINE_B 51 "; print "\n" ;
    print " \t\t\tint $IndexO[]; " ; print "LINE_B 52 "; print "\n" ;
    $CCi={0,0};
    print " \t\t\t$CCi={0,0}; " ; print "LINE_B 53 "; print "\n" ;
    //////////////////////////////////////////////
    print " \t\t\t////////////////////////////////////////////// " ; print "LINE_B 54 "; print "\n" ;
    //STEP #1
    print " \t\t\t//STEP #1 " ; print "LINE_B 55 "; print "\n" ;
    $SizeCuts = 0;
    print " \t\t\tint $SizeCuts=0; " ; print "LINE_B 56 "; print "\n" ;
    $SFoundC = 0;
    print " \t\t\tint $SFoundC=0; " ; print "LINE_B 57 "; print "\n" ;
    print " \t\t\tint $IndexA[],$sZ; " ; print "LINE_B 58 "; print "\n" ;
    clear $IndexA;
    print " \t\t\tclear $IndexA; " ; print "LINE_B 59 "; print "\n" ;
    print " \t\t\tint $IndexB[]; " ; print "LINE_B 60 "; print "\n" ;
    $IndexA=InsideRectangle($Sel[0],$Sel_list);
    print " \t\t\t$IndexA=InsideRectangle($Sel[0],$Sel_list); " ; print "LINE_B 61 "; print "\n" ;
    //get INDEX of ONLY EXISTING CURVES
    print " \t\t\t//get INDEX of ONLY EXISTING CURVES " ; print "LINE_B 62 "; print "\n" ;
    for($iC=0; $iC<`size($IndexA)`; $iC++){
    print " \t\t\tfor($iC=0; $iC<`size($IndexA)`; $iC++){ " ; print "LINE_B 63 "; print "\n" ;
    $IndexB[$iC]=$CRVNameIndex[$IndexA[$iC]];
    print " \t\t\t\t$IndexB[$iC]=$CRVNameIndex[$IndexA[$iC]]; " ; print "LINE_B 64 "; print "\n" ;
    }
    print " \t\t\t} " ; print "LINE_B 65 "; print "\n" ;
    $IndexA=$IndexB;
    print " \t\t\t$IndexA=$IndexB;\t " ; print "LINE_B 66 "; print "\n" ;
    $sZ =`size($IndexA)`;
    print " \t\t\t$sZ =`size($IndexA)`; " ; print "LINE_B 67 "; print "\n" ;
    clear $Ind3dV2P;
    print " \t\t\tclear $Ind3dV2P; " ; print "LINE_B 68 "; print "\n" ;
    $Ind3dV2P=IndexPairArrayFunc($IndexA);
    print " \t\t\t$Ind3dV2P=IndexPairArrayFunc($IndexA); " ; print "LINE_B 69 "; print "\n" ;
    print " \t\t\tfloat $Arc; " ; print "LINE_B 70 "; print "\n" ;
    print " \t\t\tvector $tempV[]; " ; print "LINE_B 71 "; print "\n" ;
    print " \t\t\t " ; print "LINE_B 72 "; print "\n" ;
    if($sZ>0){
    print " \t\t\tif($sZ>0){ " ; print "LINE_B 73 "; print "\n" ;
    $Arc =`arclen $Sel[0]`;
    print " \t\t\t\t$Arc =`arclen $Sel[0]`; " ; print "LINE_B 74 "; print "\n" ;
    print " \t\t\t\tstring $crvsFound[]; " ; print "LINE_B 75 "; print "\n" ;
    clear $crvsFound;
    print " \t\t\t\tclear $crvsFound;  " ; print "LINE_B 76 "; print "\n" ;
    for($Icr=0;  $Icr<$sZ; $Icr++){
    print " \t\t\t\tfor($Icr=0;  $Icr<$sZ; $Icr++){ " ; print "LINE_B 77 "; print "\n" ;
    $crvsFound[$Icr]=$Sel_list[$IndexA[$Icr]];
    print " \t\t\t\t\t$crvsFound[$Icr]=$Sel_list[$IndexA[$Icr]]; " ; print "LINE_B 78 "; print "\n" ;
    }
    print " \t\t\t\t}\t\t " ; print "LINE_B 79 "; print "\n" ;
    print " \t\t\t\tint $tempStringI[]; " ; print "LINE_B 80 "; print "\n" ;
    for($Icr=0;  $Icr<$sZ*2; $Icr++){
    print " \t\t\t\tfor($Icr=0;  $Icr<$sZ*2; $Icr++){ " ; print "LINE_B 81 "; print "\n" ;
    $tempV[$Icr]=  $AllKnowVecEnds[$MCurveIndex[$Ind3dV2P[$Icr]]];
    print " \t\t\t\t\t$tempV[$Icr]=  $AllKnowVecEnds[$MCurveIndex[$Ind3dV2P[$Icr]]]; " ; print "LINE_B 82 "; print "\n" ;
    $tempStringI[$Icr] =$MCurveIndex[$Ind3dV2P[$Icr]];
    print " \t\t\t\t\t$tempStringI[$Icr] =$MCurveIndex[$Ind3dV2P[$Icr]]; " ; print "LINE_B 83 "; print "\n" ;
    }
    print " \t\t\t\t}\t " ; print "LINE_B 84 "; print "\n" ;
    $allNearVecEnds=$tempV;
    print " \t\t\t\t$allNearVecEnds=$tempV;\t\t\t " ; print "LINE_B 85 "; print "\n" ;
    //STEP #2
    print " \t\t\t\t//STEP #2\t\t " ; print "LINE_B 86 "; print "\n" ;
    print " \t\t\t\tint $FoundCut_Index[]; " ; print "LINE_B 87 "; print "\n" ;
    $FoundCut_Index = DoesCurveBBcrossCurve($Sel[0], $crvsFound);
    print " \t\t\t\t$FoundCut_Index = DoesCurveBBcrossCurve($Sel[0], $crvsFound); " ; print "LINE_B 88 "; print "\n" ;
    print " \t\t\t\tstring $crvsOther[]; " ; print "LINE_B 89 "; print "\n" ;
    clear $crvsOther;
    print " \t\t\t\tclear $crvsOther;  " ; print "LINE_B 90 "; print "\n" ;
    print " \t\t\t\tstring $crvsFoundCut[]; " ; print "LINE_B 91 "; print "\n" ;
    clear $crvsFoundCut;
    print " \t\t\t\tclear $crvsFoundCut;  " ; print "LINE_B 92 "; print "\n" ;
    $sZ =`size($crvsFound)`;
    print " \t\t\t\t$sZ =`size($crvsFound)`; " ; print "LINE_B 93 "; print "\n" ;
    $FC = 0;
    print " \t\t\t\tint $FC=0; " ; print "LINE_B 94 "; print "\n" ;
    for($Icr=0;  $Icr<$sZ; $Icr++){
    print " \t\t\t\tfor($Icr=0;  $Icr<$sZ; $Icr++){ " ; print "LINE_B 95 "; print "\n" ;
    if($FoundCut_Index[$FC]==$Icr){
    print " \t\t\t\t\tif($FoundCut_Index[$FC]==$Icr){ " ; print "LINE_B 96 "; print "\n" ;
    $IndexR[$FC] =$IndexA[$FoundCut_Index[$FC]];
    print " \t\t\t\t\t\t$IndexR[$FC] =$IndexA[$FoundCut_Index[$FC]]; " ; print "LINE_B 97 "; print "\n" ;
    $crvsFoundCut[$FC]=$crvsFound[$FoundCut_Index[$FC]];
    print " \t\t\t\t\t\t$crvsFoundCut[$FC]=$crvsFound[$FoundCut_Index[$FC]]; " ; print "LINE_B 98 "; print "\n" ;
    $FC++;
    print " \t\t\t\t\t\t$FC++; " ; print "LINE_B 99 "; print "\n" ;
    }else{
    print " \t\t\t\t\t}else{ " ; print "LINE_B 100 "; print "\n" ;
    $crvsOther[`size($crvsOther)`]=$crvsFound[$Icr];
    print " \t\t\t\t\t\t$crvsOther[`size($crvsOther)`]=$crvsFound[$Icr]; " ; print "LINE_B 101 "; print "\n" ;
    $IndexO[`size($IndexO)`]=$IndexA[$FoundCut_Index[$FC]];
    print " \t\t\t\t\t\t$IndexO[`size($IndexO)`]=$IndexA[$FoundCut_Index[$FC]]; " ; print "LINE_B 102 "; print "\n" ;
    }
    print " \t\t\t\t\t} " ; print "LINE_B 103 "; print "\n" ;
    }
    print " \t\t\t\t} " ; print "LINE_B 104 "; print "\n" ;
    print " \t\t\t\t " ; print "LINE_B 105 "; print "\n" ;
    $SFoundC =`size($crvsFoundCut)`;
    print " \t\t\t\t$SFoundC =`size($crvsFoundCut)`; " ; print "LINE_B 106 "; print "\n" ;
    print " \t\t\t\t " ; print "LINE_B 107 "; print "\n" ;
    if($SFoundC>0){
    print " \t\t\t\tif($SFoundC>0){ " ; print "LINE_B 108 "; print "\n" ;
    print " \t\t\t\t\t " ; print "LINE_B 109 "; print "\n" ;
    clear $U;
    print " \t\t\t\t\tclear $U; " ; print "LINE_B 110 "; print "\n" ;
    //YES  $CurveCutIndex is the int Index of found CRVS  so to track
    print " \t\t\t\t\t//YES  $CurveCutIndex is the int Index of found CRVS  so to track  " ; print "LINE_B 111 "; print "\n" ;
    $CUTcrv = CurvatureUtilitySimple($crvsFoundCut, $Sel[0]);
    print " \t\t\t\t\t$CUTcrv = CurvatureUtilitySimple($crvsFoundCut, $Sel[0]);\t\t\t " ; print "LINE_B 112 "; print "\n" ;
    $CRV_IND=$CurveCutIndex;
    print " \t\t\t\t\t$CRV_IND=$CurveCutIndex; " ; print "LINE_B 113 "; print "\n" ;
    $SizeCuts =`size($U)`;
    print " \t\t\t\t\t$SizeCuts =`size($U)`;\t\t\t " ; print "LINE_B 114 "; print "\n" ;
    print ("SizeCuts START:"+"\n");
    print " \t\t\t\t\t\t\tprint (\"SizeCuts START:\"+\"\\n\"); " ; print "LINE_B 115 "; print "\n" ;
    print $SizeCuts;
    print " \t\t\t\t\t\t\tprint $SizeCuts;\t\t\t " ; print "LINE_B 116 "; print "\n" ;
    print ("SizeCuts END"+"\n");
    print " \t\t\t\t\t\t\tprint (\"SizeCuts END\"+\"\\n\");\t\t " ; print "LINE_B 117 "; print "\n" ;
    print " \t\t\t\t\t\t\t " ; print "LINE_B 118 "; print "\n" ;
    // $CurveCutIndex  is the  index of the total size of  $crvsFoundCut that Intersects
    print " \t\t\t\t\t// $CurveCutIndex  is the  index of the total size of  $crvsFoundCut that Intersects " ; print "LINE_B 119 "; print "\n" ;
    // so the past index Number
    print " \t\t\t\t\t// so the past index Number  " ; print "LINE_B 120 "; print "\n" ;
    ////////////////////////NEW
    print " \t\t\t\t\t////////////////////////NEW " ; print "LINE_B 121 "; print "\n" ;
    print " \t\t\t\t\tint $IndexRb[]; " ; print "LINE_B 122 "; print "\n" ;
    print " \t\t\t\t\tint $IndexOb[]; " ; print "LINE_B 123 "; print "\n" ;
    $IndexOb=$IndexO;
    print " \t\t\t\t\t$IndexOb=$IndexO; " ; print "LINE_B 124 "; print "\n" ;
    $sZ =`size($crvsFoundCut)`;
    print " \t\t\t\t\t$sZ =`size($crvsFoundCut)`; " ; print "LINE_B 125 "; print "\n" ;
    $FC=0;
    print " \t\t\t\t\t$FC=0; " ; print "LINE_B 126 "; print "\n" ;
    for($Icr=0;  $Icr<$sZ; $Icr++){
    print " \t\t\t\t\tfor($Icr=0;  $Icr<$sZ; $Icr++){ " ; print "LINE_B 127 "; print "\n" ;

    print " \t\t\t\t\t\t " ; print "LINE_B 128 "; print "\n" ;
    if($CRV_IND[$FC]==$Icr){
    print " \t\t\t\t\t\tif($CRV_IND[$FC]==$Icr){ " ; print "LINE_B 129 "; print "\n" ;
    $IndexRb[$FC] =$IndexR[$CRV_IND[$FC]];
    print " \t\t\t\t\t\t\t$IndexRb[$FC] =$IndexR[$CRV_IND[$FC]];\t\t\t " ; print "LINE_B 130 "; print "\n" ;
    $FC++;
    print " \t\t\t\t\t\t\t$FC++; " ; print "LINE_B 131 "; print "\n" ;
    }else{
    print " \t\t\t\t\t\t}else{\t\t " ; print "LINE_B 132 "; print "\n" ;
    $IndexOb[`size($IndexOb)`]=$IndexR[$CRV_IND[$FC]];
    print " \t\t\t\t\t\t\t$IndexOb[`size($IndexOb)`]=$IndexR[$CRV_IND[$FC]]; " ; print "LINE_B 133 "; print "\n" ;
    }
    print " \t\t\t\t\t\t} " ; print "LINE_B 134 "; print "\n" ;
    }
    print " \t\t\t\t\t} " ; print "LINE_B 135 "; print "\n" ;
    //May need to change this
    print " \t\t\t\t\t//May need to change this " ; print "LINE_B 136 "; print "\n" ;
    $IndexR=$IndexRb;
    print " \t\t\t\t\t$IndexR=$IndexRb; " ; print "LINE_B 137 "; print "\n" ;
    //May need to change this
    print " \t\t\t\t\t//May need to change this\t\t " ; print "LINE_B 138 "; print "\n" ;
    $IndexO= $IndexOb;
    print " \t\t\t\t\t$IndexO= $IndexOb; " ; print "LINE_B 139 "; print "\n" ;
    ////////////////////////NEW
    print " \t\t\t\t\t////////////////////////NEW\t\t\t " ; print "LINE_B 140 "; print "\n" ;
    if($SizeCuts>0){
    print " \t\t\t\t\tif($SizeCuts>0){\t\t\t\t " ; print "LINE_B 141 "; print "\n" ;
    $oldUii = $U;
    print " \t\t\t\t\t\tfloat $oldUii[]=$U; " ; print "LINE_B 142 "; print "\n" ;
    print " \t\t\t\t\t\tint $USortK[]; " ; print "LINE_B 143 "; print "\n" ;
    $USortK = SortNumbersIntIndex($U);
    print " \t\t\t\t\t\t$USortK = SortNumbersIntIndex($U); " ; print "LINE_B 144 "; print "\n" ;
    print " \t\t\t\t\t\tint $tempIN[]; " ; print "LINE_B 145 "; print "\n" ;
    print " \t\t\t\t\t\t " ; print "LINE_B 146 "; print "\n" ;
    for($iC=0; $iC<`size($USortK)`; $iC++){
    print " \t\t\t\t\t\tfor($iC=0; $iC<`size($USortK)`; $iC++){ " ; print "LINE_B 147 "; print "\n" ;
    $sortedTG[$iC]= $T_G[$USortK[$iC]];
    print " \t\t\t\t\t\t\t$sortedTG[$iC]= $T_G[$USortK[$iC]]; " ; print "LINE_B 148 "; print "\n" ;
    $tempIN[$iC]=$CRV_IND[$USortK[$iC]];				}
    print " \t\t\t\t\t\t\t$tempIN[$iC]=$CRV_IND[$USortK[$iC]];\t\t\t\t} " ; print "LINE_B 149 "; print "\n" ;
    $USortK=$tempIN;
    print " \t\t\t\t\t\t$USortK=$tempIN;\t\t\t\t " ; print "LINE_B 150 "; print "\n" ;
    $U=sort($U);
    print " \t\t\t\t\t\t$U=sort($U); " ; print "LINE_B 151 "; print "\n" ;
    print " \t\t\t\t\t\tfloat $TempU[]; " ; print "LINE_B 152 "; print "\n" ;
    $Tsize = `size($U)`;
    print " \t\t\t\t\t\tint $Tsize=`size($U)`; " ; print "LINE_B 153 "; print "\n" ;
    // if the cuts made to the drawn CRV is greater then one like 2 then you must track what ends are kept
    print " \t\t\t\t\t\t// if the cuts made to the drawn CRV is greater then one like 2 then you must track what ends are kept " ; print "LINE_B 154 "; print "\n" ;
    // track items ONE are crv cuts greater then 1? True or false
    print " \t\t\t\t\t\t// track items ONE are crv cuts greater then 1? True or false  " ; print "LINE_B 155 "; print "\n" ;
    // TWO are the firstand last ends kept
    print " \t\t\t\t\t\t// TWO are the firstand last ends kept " ; print "LINE_B 156 "; print "\n" ;
    if($Tsize!= 1){
    print " \t\t\t\t\t\tif($Tsize!= 1){ " ; print "LINE_B 157 "; print "\n" ;
    $MoreThenOne=1;
    print " \t\t\t\t\t\t\t$MoreThenOne=1; " ; print "LINE_B 158 "; print "\n" ;
    $MperS = ($Arc*($U[0]));
    print " \t\t\t\t\t\t\tfloat $MperS= ($Arc*($U[0])); " ; print "LINE_B 159 "; print "\n" ;
    $MperE = ($Arc*(1-$U[$SizeCuts-1]));
    print " \t\t\t\t\t\t\tfloat $MperE= ($Arc*(1-$U[$SizeCuts-1]));\t\t\t\t\t " ; print "LINE_B 160 "; print "\n" ;
    if( $MperS >= 5.5){
    print " \t\t\t\t\t\t\tif( $MperS >= 5.5){ " ; print "LINE_B 161 "; print "\n" ;
    $TempU[`size($TempU)`]=0.0;
    print " \t\t\t\t\t\t\t\t$TempU[`size($TempU)`]=0.0; " ; print "LINE_B 162 "; print "\n" ;
    $m_Or_e[`size($m_Or_e)`]=1;
    print " \t\t\t\t\t\t\t\t$m_Or_e[`size($m_Or_e)`]=1; " ; print "LINE_B 163 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t} " ; print "LINE_B 164 "; print "\n" ;
    for($iC=0; $iC<$SizeCuts; $iC++){
    print " \t\t\t\t\t\t\tfor($iC=0; $iC<$SizeCuts; $iC++){ " ; print "LINE_B 165 "; print "\n" ;
    $TempU[`size($TempU)`]=$U[$iC];
    print " \t\t\t\t\t\t\t\t$TempU[`size($TempU)`]=$U[$iC];\t\t\t\t\t\t\t " ; print "LINE_B 166 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t} " ; print "LINE_B 167 "; print "\n" ;
    for($iC=0; $iC<$SizeCuts-1; $iC++){
    print " \t\t\t\t\t\t\tfor($iC=0; $iC<$SizeCuts-1; $iC++){\t\t\t\t\t " ; print "LINE_B 168 "; print "\n" ;
    $m_Or_e[`size($m_Or_e)`]=0;
    print " \t\t\t\t\t\t\t\t$m_Or_e[`size($m_Or_e)`]=0; " ; print "LINE_B 169 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t} " ; print "LINE_B 170 "; print "\n" ;
    if($MperE>=5.5){
    print " \t\t\t\t\t\t\tif($MperE>=5.5){ " ; print "LINE_B 171 "; print "\n" ;
    $TempU[`size($TempU)`]=1.0;
    print " \t\t\t\t\t\t\t\t$TempU[`size($TempU)`]=1.0; " ; print "LINE_B 172 "; print "\n" ;
    $m_Or_e[`size($m_Or_e)`]=1;
    print " \t\t\t\t\t\t\t\t$m_Or_e[`size($m_Or_e)`]=1; " ; print "LINE_B 173 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t} " ; print "LINE_B 174 "; print "\n" ;
    $U=$TempU;
    print " \t\t\t\t\t\t\t$U=$TempU; " ; print "LINE_B 175 "; print "\n" ;
    }
    print " \t\t\t\t\t\t}\t\t\t\t " ; print "LINE_B 176 "; print "\n" ;
    if($Tsize== 1){
    print " \t\t\t\t\t\tif($Tsize== 1){ " ; print "LINE_B 177 "; print "\n" ;
    print " \t\t\t\t\t\t\tfloat $TempU[]; " ; print "LINE_B 178 "; print "\n" ;
    print " \t\t\t\t\t\t\tfloat $TempUi[]; " ; print "LINE_B 179 "; print "\n" ;
    $TempUi[0]=0.0;
    print " \t\t\t\t\t\t\t$TempUi[0]=0.0; " ; print "LINE_B 180 "; print "\n" ;
    $TempUi[1]=$U[0];
    print " \t\t\t\t\t\t\t$TempUi[1]=$U[0]; " ; print "LINE_B 181 "; print "\n" ;
    $TempUi[2]=1.0;
    print " \t\t\t\t\t\t\t$TempUi[2]=1.0; " ; print "LINE_B 182 "; print "\n" ;
    $U=$TempUi;
    print " \t\t\t\t\t\t\t$U=$TempUi; " ; print "LINE_B 183 "; print "\n" ;
    $MperS = (100*($U[1]));
    print " \t\t\t\t\t\t\tfloat $MperS= (100*($U[1])); " ; print "LINE_B 184 "; print "\n" ;
    $MperE = (100*(1-$U[1]));
    print " \t\t\t\t\t\t\tfloat $MperE= (100*(1-$U[1])); " ; print "LINE_B 185 "; print "\n" ;
    if( $MperS >= 15){$TempU[`size($TempU)`]=0.0; $m_Or_e[`size($m_Or_e)`]=1;}
    print " \t\t\t\t\t\t\tif( $MperS >= 15){$TempU[`size($TempU)`]=0.0; $m_Or_e[`size($m_Or_e)`]=1;} " ; print "LINE_B 186 "; print "\n" ;
    $TempU[`size($TempU)`]=$U[1];
    print " \t\t\t\t\t\t\t$TempU[`size($TempU)`]=$U[1];\t " ; print "LINE_B 187 "; print "\n" ;
    if($MperE>=15){$TempU[`size($TempU)`]=1.0; $m_Or_e[`size($m_Or_e)`]=1;}
    print " \t\t\t\t\t\t\tif($MperE>=15){$TempU[`size($TempU)`]=1.0; $m_Or_e[`size($m_Or_e)`]=1;} " ; print "LINE_B 188 "; print "\n" ;
    clear $U;
    print " \t\t\t\t\t\t\tclear $U; " ; print "LINE_B 189 "; print "\n" ;
    $U=$TempU;
    print " \t\t\t\t\t\t\t$U=$TempU; " ; print "LINE_B 190 "; print "\n" ;
    print " \t\t\t\t\t\t\t " ; print "LINE_B 191 "; print "\n" ;
    print ("Tsize = 1 START:"+"\n");
    print " \t\t\t\t\t\t\tprint (\"Tsize = 1 START:\"+\"\\n\"); " ; print "LINE_B 192 "; print "\n" ;
    print ("m_Or_e START:"+"\n");
    print " \t\t\t\t\t\t\tprint (\"m_Or_e START:\"+\"\\n\"); " ; print "LINE_B 193 "; print "\n" ;
    print $m_Or_e;
    print " \t\t\t\t\t\t\tprint $m_Or_e; " ; print "LINE_B 194 "; print "\n" ;
    print ("m_Or_e END"+"\n");
    print " \t\t\t\t\t\t\tprint (\"m_Or_e END\"+\"\\n\"); " ; print "LINE_B 195 "; print "\n" ;
    print ("Tsize = 1 END"+"\n");
    print " \t\t\t\t\t\t\tprint (\"Tsize = 1 END\"+\"\\n\"); " ; print "LINE_B 196 "; print "\n" ;
    print " \t\t\t\t\t\t\t " ; print "LINE_B 197 "; print "\n" ;
    }
    print " \t\t\t\t\t\t}\t\t\t\t " ; print "LINE_B 198 "; print "\n" ;
    print " \t\t\t\t\t\tstring $NewCutCRVs[]; " ; print "LINE_B 199 "; print "\n" ;
    print " \t\t\t\t\t\tvector $CRVSEG_A[];\t\t " ; print "LINE_B 200 "; print "\n" ;
    $Hsize = `size($U)`;
    print " \t\t\t\t\t\tfloat $Hsize= `size($U)`; " ; print "LINE_B 201 "; print "\n" ;
    $Hsize-=1;
    print " \t\t\t\t\t\t$Hsize-=1; " ; print "LINE_B 202 "; print "\n" ;
    for($iC=0; $iC<$Hsize; $iC++){
    print " \t\t\t\t\t\tfor($iC=0; $iC<$Hsize; $iC++){ " ; print "LINE_B 203 "; print "\n" ;
    clear $CRVSEG_A;
    print " \t\t\t\t\t\t\tclear $CRVSEG_A; " ; print "LINE_B 204 "; print "\n" ;
    $CrvTSi = $U[$iC];
    print " \t\t\t\t\t\t\tfloat $CrvTSi = $U[$iC]; " ; print "LINE_B 205 "; print "\n" ;
    $CrvTEi = $U[$iC+1];
    print " \t\t\t\t\t\t\tfloat $CrvTEi = $U[$iC+1]; " ; print "LINE_B 206 "; print "\n" ;
    $Mper = ($Arc*($U[$iC+1]-$U[$iC]));
    print " \t\t\t\t\t\t\tfloat $Mper= ($Arc*($U[$iC+1]-$U[$iC])); " ; print "LINE_B 207 "; print "\n" ;
    print " \t\t\t\t\t\t\tvector $CRVSEG_A[]; " ; print "LINE_B 208 "; print "\n" ;
    $CRVSEG_A=RenderCurveSeg($Sel[0],12,$CrvTSi,$CrvTEi);
    print " \t\t\t\t\t\t\t$CRVSEG_A=RenderCurveSeg($Sel[0],12,$CrvTSi,$CrvTEi); " ; print "LINE_B 209 "; print "\n" ;
    $NewCutCRVs[`size($NewCutCRVs)`]=VecArrayToCurveB($CRVSEG_A);
    print " \t\t\t\t\t\t\t$NewCutCRVs[`size($NewCutCRVs)`]=VecArrayToCurveB($CRVSEG_A); " ; print "LINE_B 210 "; print "\n" ;
    }
    print " \t\t\t\t\t\t}\t\t\t\t " ; print "LINE_B 211 "; print "\n" ;
    ////////////////
    print " \t\t\t\t\t\t//////////////// " ; print "LINE_B 212 "; print "\n" ;
    // Place new
    print " \t\t\t\t\t\t// Place new  " ; print "LINE_B 213 "; print "\n" ;
    print ("m_Or_e START:"+"\n");
    print " \t\t\t\t\t\tprint (\"m_Or_e START:\"+\"\\n\"); " ; print "LINE_B 214 "; print "\n" ;
    print $m_Or_e;
    print " \t\t\t\t\t\tprint $m_Or_e; " ; print "LINE_B 215 "; print "\n" ;
    print ("m_Or_e END"+"\n");
    print " \t\t\t\t\t\tprint (\"m_Or_e END\"+\"\\n\"); " ; print "LINE_B 216 "; print "\n" ;
    print " \t\t\t\t\t\t " ; print "LINE_B 217 "; print "\n" ;
    print " \t\t\t\t\t\t " ; print "LINE_B 218 "; print "\n" ;
    print " \t\t\t\t\t\t " ; print "LINE_B 219 "; print "\n" ;
    if(`size($IndexO)`>0){
    print " \t\t\t\t\t\tif(`size($IndexO)`>0){ " ; print "LINE_B 220 "; print "\n" ;
    $TempINA =IndexPairArrayFunc($IndexO);
    print " \t\t\t\t\t\t\t$TempINA =IndexPairArrayFunc($IndexO);\t\t\t\t\t\t\t " ; print "LINE_B 221 "; print "\n" ;
    for($Icr=0;  $Icr<$sZ*2; $Icr++){
    print " \t\t\t\t\t\t\tfor($Icr=0;  $Icr<$sZ*2; $Icr++){\t\t " ; print "LINE_B 222 "; print "\n" ;
    $tempVi[$Icr]=  $AllKnowVecEnds[$MCurveIndex[$TempINA[$Icr]]];
    print " \t\t\t\t\t\t\t\t$tempVi[$Icr]=  $AllKnowVecEnds[$MCurveIndex[$TempINA[$Icr]]]; " ; print "LINE_B 223 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t} " ; print "LINE_B 224 "; print "\n" ;
    }
    print " \t\t\t\t\t\t} " ; print "LINE_B 225 "; print "\n" ;
    /////////////////
    print " \t\t\t\t\t\t/////////////////\t\t\t\t\t\t " ; print "LINE_B 226 "; print "\n" ;
    // this is the curves that DO intersect!!
    print " \t\t\t\t\t\t// this is the curves that DO intersect!!\t\t\t\t\t\t " ; print "LINE_B 227 "; print "\n" ;
    $TempINAi =IndexPairArrayFunc($IndexR);
    print " \t\t\t\t\t\t$TempINAi =IndexPairArrayFunc($IndexR);\t\t\t\t\t\t " ; print "LINE_B 228 "; print "\n" ;
    for($Icr=0;  $Icr<$sZ*2; $Icr++){
    print " \t\t\t\t\t\tfor($Icr=0;  $Icr<$sZ*2; $Icr++){\t\t " ; print "LINE_B 229 "; print "\n" ;
    $tempVii[$Icr]=  $AllKnowVecEnds[$MCurveIndex[$TempINAi[$Icr]]];
    print " \t\t\t\t\t\t\t$tempVii[$Icr]=  $AllKnowVecEnds[$MCurveIndex[$TempINAi[$Icr]]]; " ; print "LINE_B 230 "; print "\n" ;
    }
    print " \t\t\t\t\t\t} " ; print "LINE_B 231 "; print "\n" ;
    print " \t\t\t\t\t\t " ; print "LINE_B 232 "; print "\n" ;
    $SizeSeg =`size($NewCutCRVs)`;
    print " \t\t\t\t\t\t$SizeSeg =`size($NewCutCRVs)`; " ; print "LINE_B 233 "; print "\n" ;
    print " \t\t\t\t\t\t " ; print "LINE_B 234 "; print "\n" ;
    if($NoCUT==1){
    print " \t\t\t\t\t\tif($NoCUT==1){\t " ; print "LINE_B 235 "; print "\n" ;
    print " \t\t\t\t\t\t\t " ; print "LINE_B 236 "; print "\n" ;
    for($iC=0; $iC<$SizeSeg; $iC++)
    print " \t\t\t\t\t\t\tfor($iC=0; $iC<$SizeSeg; $iC++) " ; print "LINE_B 237 "; print "\n" ;
    {
    print " \t\t\t\t\t\t\t{ " ; print "LINE_B 238 "; print "\n" ;
    print " \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t " ; print "LINE_B 239 "; print "\n" ;
    $VecTA=0;
    print " \t\t\t\t\t\t\t\t$VecTA=0; " ; print "LINE_B 240 "; print "\n" ;
    $VecTB=0;
    print " \t\t\t\t\t\t\t\t$VecTB=0;\t\t\t\t " ; print "LINE_B 241 "; print "\n" ;
    //END curve and onle the first end can snap to "" OTHER curves
    print " \t\t\t\t\t\t\t\t//END curve and onle the first end can snap to \"\" OTHER curves\t\t\t\t\t " ; print "LINE_B 242 "; print "\n" ;
    $DrawnVecEnds  =VecCurveEnds({$NewCutCRVs[$iC]});
    print " \t\t\t\t\t\t\t\t$DrawnVecEnds  =VecCurveEnds({$NewCutCRVs[$iC]}); " ; print "LINE_B 243 "; print "\n" ;
    /////////////////////////////////////////////////////////////////////////
    print " \t\t\t\t\t\t\t\t///////////////////////////////////////////////////////////////////////// " ; print "LINE_B 244 "; print "\n" ;
    //END CRV
    print " \t\t\t\t\t\t\t\t//END CRV " ; print "LINE_B 245 "; print "\n" ;
    print " \t\t\t\t\t\t\t\t " ; print "LINE_B 246 "; print "\n" ;
    print " \t\t\t\t\t\t\t\t " ; print "LINE_B 247 "; print "\n" ;
    print " \t\t\t\t\t\t\t\t " ; print "LINE_B 248 "; print "\n" ;
    print " \t\t\t\t\t\t\t\t " ; print "LINE_B 249 "; print "\n" ;
    print " \t\t\t\t\t\t\t\t " ; print "LINE_B 250 "; print "\n" ;
    print " \t\t\t\t\t\t\t\t " ; print "LINE_B 251 "; print "\n" ;
    /////////////////
    print " \t\t\t\t\t\t\t\t/////////////////\t\t\t\t\t\t " ; print "LINE_B 252 "; print "\n" ;
    $DrawnVecEnds  =VecCurveEnds({$NewCutCRVs[$iC]});
    print " \t\t\t\t\t\t\t\t$DrawnVecEnds  =VecCurveEnds({$NewCutCRVs[$iC]});\t\t\t\t\t\t " ; print "LINE_B 253 "; print "\n" ;
    //  so here these vectors Must be the filter index of ONLY OTHER CURVES
    print " \t\t\t\t\t\t\t\t//  so here these vectors Must be the filter index of ONLY OTHER CURVES " ; print "LINE_B 254 "; print "\n" ;
    // AND NOTHING ESLE for  if((($m_Or_e[$iC]==1)&&($iC==($SizeSeg-1))&&($CCi[0]==1)){
    print " \t\t\t\t\t\t\t\t// AND NOTHING ESLE for  if((($m_Or_e[$iC]==1)&&($iC==($SizeSeg-1))&&($CCi[0]==1)){\t\t\t\t\t\t\t " ; print "LINE_B 255 "; print "\n" ;
    if((($m_Or_e[$iC]==1)&&($iC==0))&&($CCi[1]==1)){
    print " \t\t\t\t\t\t\t\tif((($m_Or_e[$iC]==1)&&($iC==0))&&($CCi[1]==1)){ " ; print "LINE_B 256 "; print "\n" ;
    if(`size($IndexO)`>0){
    print " \t\t\t\t\t\t\t\t\tif(`size($IndexO)`>0){ " ; print "LINE_B 257 "; print "\n" ;
    $dist_A= ArrayDistancesVecTofloat($tempVi, $DrawnVecEnds [0]);
    print " \t\t\t\t\t\t\t\t\t\t$dist_A= ArrayDistancesVecTofloat($tempVi, $DrawnVecEnds [0]); " ; print "LINE_B 258 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t} " ; print "LINE_B 259 "; print "\n" ;
    $dist_B = ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [1]);
    print " \t\t\t\t\t\t\t\t\t$dist_B = ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [1]);\t\t\t\t " ; print "LINE_B 260 "; print "\n" ;
    if(`size($IndexO)`>0){	$DA=SortNumbersIntIndex($dist_A); $VecTA=$TempINA[$DA[0]];}
    print " \t\t\t\t\t\t\t\t\tif(`size($IndexO)`>0){\t$DA=SortNumbersIntIndex($dist_A); $VecTA=$TempINA[$DA[0]];} " ; print "LINE_B 261 "; print "\n" ;
    $DB=SortNumbersIntIndex($dist_B);
    print " \t\t\t\t\t\t\t\t\t$DB=SortNumbersIntIndex($dist_B);\t\t\t\t\t\t " ; print "LINE_B 262 "; print "\n" ;
    if(`size($IndexO)`>0){
    print " \t\t\t\t\t\t\t\t\tif(`size($IndexO)`>0){ " ; print "LINE_B 263 "; print "\n" ;
    $SA =$dist_A[$DA[0]];
    print " \t\t\t\t\t\t\t\t\t\t$SA =$dist_A[$DA[0]]; " ; print "LINE_B 264 "; print "\n" ;
    }else{$SA=200;}
    print " \t\t\t\t\t\t\t\t\t}else{$SA=200;}\t\t\t\t\t\t " ; print "LINE_B 265 "; print "\n" ;
    $SB =$dist_B[$DB[0]];
    print " \t\t\t\t\t\t\t\t\t$SB =$dist_B[$DB[0]];\t\t\t\t\t\t " ; print "LINE_B 266 "; print "\n" ;
    if($DA[0]==$DB[0]){
    print " \t\t\t\t\t\t\t\t\tif($DA[0]==$DB[0]){ " ; print "LINE_B 267 "; print "\n" ;
    if($SA<$SB){
    print " \t\t\t\t\t\t\t\t\t\tif($SA<$SB){ " ; print "LINE_B 268 "; print "\n" ;
    $SB=200;
    print " \t\t\t\t\t\t\t\t\t\t\t$SB=200; " ; print "LINE_B 269 "; print "\n" ;
    }else{$SA=200;}
    print " \t\t\t\t\t\t\t\t\t\t}else{$SA=200;} " ; print "LINE_B 270 "; print "\n" ;

    print " \t\t\t\t\t\t\t\t\t\t " ; print "LINE_B 271 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t} " ; print "LINE_B 272 "; print "\n" ;
    //$VecTA=$TempINA[$DA[0]];
    print " \t\t\t\t\t\t\t\t\t//$VecTA=$TempINA[$DA[0]]; " ; print "LINE_B 273 "; print "\n" ;
    $VecTB=$TempINAi[$DB[0]];
    print " \t\t\t\t\t\t\t\t\t$VecTB=$TempINAi[$DB[0]];\t\t\t\t\t\t\t\t\t " ; print "LINE_B 274 "; print "\n" ;
    if($SA<$DistSSS){
    print " \t\t\t\t\t\t\t\t\tif($SA<$DistSSS){ " ; print "LINE_B 275 "; print "\n" ;
    $CCi[0]=1;
    print " \t\t\t\t\t\t\t\t\t\t$CCi[0]=1; " ; print "LINE_B 276 "; print "\n" ;
    $SnapEnds[0]=$tempVi[$DA[0]];
    print " \t\t\t\t\t\t\t\t\t\t$SnapEnds[0]=$tempVi[$DA[0]]; " ; print "LINE_B 277 "; print "\n" ;
    }else{$SnapEnds[0]=$DrawnVecEnds[0]; $CCi[0]=0;
    print " \t\t\t\t\t\t\t\t\t}else{$SnapEnds[0]=$DrawnVecEnds[0]; $CCi[0]=0;\t\t\t\t\t\t\t\t " ; print "LINE_B 278 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t} " ; print "LINE_B 279 "; print "\n" ;
    if($SB<$DistSSS){
    print " \t\t\t\t\t\t\t\t\tif($SB<$DistSSS){ " ; print "LINE_B 280 "; print "\n" ;
    $CCi[1]=1;
    print " \t\t\t\t\t\t\t\t\t\t$CCi[1]=1; " ; print "LINE_B 281 "; print "\n" ;
    $SnapEnds[1]=$tempVii[$DB[0]];
    print " \t\t\t\t\t\t\t\t\t\t$SnapEnds[1]=$tempVii[$DB[0]]; " ; print "LINE_B 282 "; print "\n" ;
    }else{$SnapEnds[1]=$DrawnVecEnds[1]; 	$CCi[1]=0;
    print " \t\t\t\t\t\t\t\t\t}else{$SnapEnds[1]=$DrawnVecEnds[1]; \t$CCi[1]=0;\t\t\t\t\t\t\t " ; print "LINE_B 283 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t} " ; print "LINE_B 284 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t} " ; print "LINE_B 285 "; print "\n" ;
    ////////////very messy
    print " \t\t\t\t\t\t\t\t////////////very messy " ; print "LINE_B 286 "; print "\n" ;
    if((($m_Or_e[$iC]==1)&&($iC==($SizeSeg-1)))&&($CCi[0]==1)){
    print " \t\t\t\t\t\t\t\tif((($m_Or_e[$iC]==1)&&($iC==($SizeSeg-1)))&&($CCi[0]==1)){\t\t\t\t\t\t\t\t\t\t " ; print "LINE_B 287 "; print "\n" ;
    $dist_A= ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [0]);
    print " \t\t\t\t\t\t\t\t\t$dist_A= ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [0]); " ; print "LINE_B 288 "; print "\n" ;
    if(`size($IndexO)`>0){
    print " \t\t\t\t\t\t\t\t\tif(`size($IndexO)`>0){\t " ; print "LINE_B 289 "; print "\n" ;
    $dist_B = ArrayDistancesVecTofloat($tempVi, $DrawnVecEnds [1]);
    print " \t\t\t\t\t\t\t\t\t\t$dist_B = ArrayDistancesVecTofloat($tempVi, $DrawnVecEnds [1]); " ; print "LINE_B 290 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t} " ; print "LINE_B 291 "; print "\n" ;
    $DA=SortNumbersIntIndex($dist_A);
    print " \t\t\t\t\t\t\t\t\t$DA=SortNumbersIntIndex($dist_A); " ; print "LINE_B 292 "; print "\n" ;
    $VecTA=$TempINAi[$DA[0]];
    print " \t\t\t\t\t\t\t\t\t$VecTA=$TempINAi[$DA[0]]; " ; print "LINE_B 293 "; print "\n" ;

    print " \t\t\t\t\t\t\t\t\t " ; print "LINE_B 294 "; print "\n" ;
    if(`size($IndexO)`>0){
    print " \t\t\t\t\t\t\t\t\tif(`size($IndexO)`>0){ " ; print "LINE_B 295 "; print "\n" ;
    $DB=SortNumbersIntIndex($dist_B);
    print " \t\t\t\t\t\t\t\t\t\t$DB=SortNumbersIntIndex($dist_B); " ; print "LINE_B 296 "; print "\n" ;
    $VecTB=$TempINA[$DB[0]];
    print " \t\t\t\t\t\t\t\t\t\t$VecTB=$TempINA[$DB[0]]; " ; print "LINE_B 297 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t}\t\t\t\t\t " ; print "LINE_B 298 "; print "\n" ;
    $SA =$dist_A[$DA[0]];
    print " \t\t\t\t\t\t\t\t\t$SA =$dist_A[$DA[0]];\t\t\t\t\t\t\t " ; print "LINE_B 299 "; print "\n" ;
    if(`size($IndexO)`>0){
    print " \t\t\t\t\t\t\t\t\tif(`size($IndexO)`>0){ " ; print "LINE_B 300 "; print "\n" ;
    $SB =$dist_B[$DB[0]];
    print " \t\t\t\t\t\t\t\t\t\t$SB =$dist_B[$DB[0]]; " ; print "LINE_B 301 "; print "\n" ;
    }else{$SB=200;}
    print " \t\t\t\t\t\t\t\t\t}else{$SB=200;}\t\t\t\t\t\t\t " ; print "LINE_B 302 "; print "\n" ;
    if($SA<$DistSSS){
    print " \t\t\t\t\t\t\t\t\tif($SA<$DistSSS){ " ; print "LINE_B 303 "; print "\n" ;
    $CCi[0]=1;
    print " \t\t\t\t\t\t\t\t\t\t$CCi[0]=1; " ; print "LINE_B 304 "; print "\n" ;
    $SnapEnds[0]=$tempVi[$DA[0]];
    print " \t\t\t\t\t\t\t\t\t\t$SnapEnds[0]=$tempVi[$DA[0]]; " ; print "LINE_B 305 "; print "\n" ;
    }else{$SnapEnds[0]=$DrawnVecEnds[0]; $CCi[0]=0;
    print " \t\t\t\t\t\t\t\t\t}else{$SnapEnds[0]=$DrawnVecEnds[0]; $CCi[0]=0;\t\t\t\t\t\t\t " ; print "LINE_B 306 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t} " ; print "LINE_B 307 "; print "\n" ;
    if($SB<$DistSSS){
    print " \t\t\t\t\t\t\t\t\tif($SB<$DistSSS){ " ; print "LINE_B 308 "; print "\n" ;
    $CCi[1]=1;
    print " \t\t\t\t\t\t\t\t\t\t$CCi[1]=1; " ; print "LINE_B 309 "; print "\n" ;
    $SnapEnds[1]=$tempVii[$DB[0]];
    print " \t\t\t\t\t\t\t\t\t\t$SnapEnds[1]=$tempVii[$DB[0]]; " ; print "LINE_B 310 "; print "\n" ;
    }else{$SnapEnds[1]=$DrawnVecEnds[1]; $CCi[1]=0;
    print " \t\t\t\t\t\t\t\t\t}else{$SnapEnds[1]=$DrawnVecEnds[1]; $CCi[1]=0;\t\t\t\t\t\t " ; print "LINE_B 311 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t} " ; print "LINE_B 312 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t " ; print "LINE_B 313 "; print "\n" ;
    /////////////////////////////////////////////////////////////////////////
    print " \t\t\t\t\t\t\t\t///////////////////////////////////////////////////////////////////////// " ; print "LINE_B 314 "; print "\n" ;
    //Middle curve
    print " \t\t\t\t\t\t\t\t//Middle curve " ; print "LINE_B 315 "; print "\n" ;
    if($m_Or_e[$iC]==0){
    print " \t\t\t\t\t\t\t\tif($m_Or_e[$iC]==0){\t\t\t\t\t\t " ; print "LINE_B 316 "; print "\n" ;
    $TempINAi=IndexPairArrayFunc($IndexR);
    print " \t\t\t\t\t\t\t\t\t$TempINAi=IndexPairArrayFunc($IndexR);\t\t\t\t\t " ; print "LINE_B 317 "; print "\n" ;
    for($Icr=0;  $Icr<$sZ*2; $Icr++){
    print " \t\t\t\t\t\t\t\t\tfor($Icr=0;  $Icr<$sZ*2; $Icr++){\t\t " ; print "LINE_B 318 "; print "\n" ;
    $tempVii[$Icr]=  $AllKnowVecEnds[$MCurveIndex[$TempINAi[$Icr]]];
    print " \t\t\t\t\t\t\t\t\t\t$tempVii[$Icr]=  $AllKnowVecEnds[$MCurveIndex[$TempINAi[$Icr]]]; " ; print "LINE_B 319 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t " ; print "LINE_B 320 "; print "\n" ;
    $DrawnVecEnds  =VecCurveEnds({$NewCutCRVs[$iC]});
    print " \t\t\t\t\t\t\t\t\t$DrawnVecEnds  =VecCurveEnds({$NewCutCRVs[$iC]});\t\t\t\t\t\t " ; print "LINE_B 321 "; print "\n" ;
    $dist_A = ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [0]);
    print " \t\t\t\t\t\t\t\t\tfloat $dist_A[] = ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [0]); " ; print "LINE_B 322 "; print "\n" ;
    $dist_B = ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [1]);
    print " \t\t\t\t\t\t\t\t\tfloat $dist_B[] = ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [1]);\t\t\t\t\t " ; print "LINE_B 323 "; print "\n" ;
    $DA=SortNumbersIntIndex($dist_A);
    print " \t\t\t\t\t\t\t\t\t$DA=SortNumbersIntIndex($dist_A); " ; print "LINE_B 324 "; print "\n" ;
    $DB=SortNumbersIntIndex($dist_B);
    print " \t\t\t\t\t\t\t\t\t$DB=SortNumbersIntIndex($dist_B); " ; print "LINE_B 325 "; print "\n" ;
    $SA =$dist_A[$DA[0]];
    print " \t\t\t\t\t\t\t\t\t$SA =$dist_A[$DA[0]]; " ; print "LINE_B 326 "; print "\n" ;
    $SB =$dist_B[$DB[0]];
    print " \t\t\t\t\t\t\t\t\t$SB =$dist_B[$DB[0]];\t\t\t " ; print "LINE_B 327 "; print "\n" ;
    $VecTA=$TempINAi[$DA[0]];
    print " \t\t\t\t\t\t\t\t\t$VecTA=$TempINAi[$DA[0]]; " ; print "LINE_B 328 "; print "\n" ;
    $VecTB=$TempINAi[$DB[0]];
    print " \t\t\t\t\t\t\t\t\t$VecTB=$TempINAi[$DB[0]]; " ; print "LINE_B 329 "; print "\n" ;

    print " \t\t\t\t\t\t\t\t\t " ; print "LINE_B 330 "; print "\n" ;
    if($DA[0]==$DB[0]){
    print " \t\t\t\t\t\t\t\t\tif($DA[0]==$DB[0]){ " ; print "LINE_B 331 "; print "\n" ;
    if($SA<$SB){
    print " \t\t\t\t\t\t\t\t\t\tif($SA<$SB){ " ; print "LINE_B 332 "; print "\n" ;
    $SB=200;
    print " \t\t\t\t\t\t\t\t\t\t\t$SB=200; " ; print "LINE_B 333 "; print "\n" ;
    }else{$SA=200;}
    print " \t\t\t\t\t\t\t\t\t\t}else{$SA=200;} " ; print "LINE_B 334 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t} " ; print "LINE_B 335 "; print "\n" ;
    if($SA<$DistSSS){
    print " \t\t\t\t\t\t\t\t\tif($SA<$DistSSS){ " ; print "LINE_B 336 "; print "\n" ;
    $CCi[0]=1;
    print " \t\t\t\t\t\t\t\t\t\t$CCi[0]=1; " ; print "LINE_B 337 "; print "\n" ;
    $SnapEnds[0]=$tempVii[$DA[0]];
    print " \t\t\t\t\t\t\t\t\t\t$SnapEnds[0]=$tempVii[$DA[0]]; " ; print "LINE_B 338 "; print "\n" ;
    }else{$SnapEnds[0]=$DrawnVecEnds[0]; $CCi[0]=0;
    print " \t\t\t\t\t\t\t\t\t}else{$SnapEnds[0]=$DrawnVecEnds[0]; $CCi[0]=0;\t\t\t\t\t\t\t " ; print "LINE_B 339 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t} " ; print "LINE_B 340 "; print "\n" ;
    if($SB<$DistSSS){
    print " \t\t\t\t\t\t\t\t\tif($SB<$DistSSS){ " ; print "LINE_B 341 "; print "\n" ;
    $CCi[1]=1;
    print " \t\t\t\t\t\t\t\t\t\t$CCi[1]=1; " ; print "LINE_B 342 "; print "\n" ;
    $SnapEnds[1]=$tempVii[$DB[0]];
    print " \t\t\t\t\t\t\t\t\t\t$SnapEnds[1]=$tempVii[$DB[0]]; " ; print "LINE_B 343 "; print "\n" ;
    }else{$SnapEnds[1]=$DrawnVecEnds[1]; $CCi[1]=0;
    print " \t\t\t\t\t\t\t\t\t}else{$SnapEnds[1]=$DrawnVecEnds[1]; $CCi[1]=0;\t\t\t\t\t\t\t " ; print "LINE_B 344 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t}\t\t\t\t\t " ; print "LINE_B 345 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t}\t\t\t\t\t " ; print "LINE_B 346 "; print "\n" ;
    //if segment is an end curve and one vector snaps is that vector the start or end of crv?
    print " \t\t\t\t\t\t\t\t//if segment is an end curve and one vector snaps is that vector the start or end of crv?\t\t\t\t\t " ; print "LINE_B 347 "; print "\n" ;
    // this is saying if the fist segment is an end crv OR if the last Curve is an end Crv and One vector snaps
    print " \t\t\t\t\t\t\t\t\t// this is saying if the fist segment is an end crv OR if the last Curve is an end Crv and One vector snaps " ; print "LINE_B 348 "; print "\n" ;
    if((($m_Or_e[$iC]==1)&&($iC==0))||(($m_Or_e[$iC]==1)&&( $iC==($SizeSeg-1)))){
    print " \t\t\t\t\t\t\t\t\tif((($m_Or_e[$iC]==1)&&($iC==0))||(($m_Or_e[$iC]==1)&&( $iC==($SizeSeg-1)))){\t\t\t\t\t\t\t " ; print "LINE_B 349 "; print "\n" ;
    // this is saying if the fist segment is an end crv OR if the last Curve is an end Crv and One vector snaps
    print " \t\t\t\t\t\t\t\t\t\t// this is saying if the fist segment is an end crv OR if the last Curve is an end Crv and One vector snaps " ; print "LINE_B 350 "; print "\n" ;
    /////// FIRST END SEG NOT MIDDLE
    print " \t\t\t\t\t\t\t\t\t\t/////// FIRST END SEG NOT MIDDLE " ; print "LINE_B 351 "; print "\n" ;
    if((($m_Or_e[$iC]==1)&&($iC==0))&&($CCi[1]==1)){
    print " \t\t\t\t\t\t\t\t\t\tif((($m_Or_e[$iC]==1)&&($iC==0))&&($CCi[1]==1)){ " ; print "LINE_B 352 "; print "\n" ;
    //XA
    print " \t\t\t\t\t\t\t\t\t\t\t//XA\t\t\t\t\t\t\t\t\t\t " ; print "LINE_B 353 "; print "\n" ;
    if(!($Ocrv>$SizeSeg)){
    print " \t\t\t\t\t\t\t\t\t\t\tif(!($Ocrv>$SizeSeg)){ " ; print "LINE_B 354 "; print "\n" ;
    //XAAA
    print " \t\t\t\t\t\t\t\t\t\t\t//XAAA " ; print "LINE_B 355 "; print "\n" ;
    print " \t\t\t\t\t\t\t\t\t\t\t\tstring $NewCRVc[]; " ; print "LINE_B 356 "; print "\n" ;
    $CRVnum = CRVIndexPairF($VecTB);
    print " \t\t\t\t\t\t\t\t\t\t\t\tint $CRVnum = CRVIndexPairF($VecTB); " ; print "LINE_B 357 "; print "\n" ;
    $ListDelete[`size($ListDelete)`]=$IndexR[$CRVnum];
    print " \t\t\t\t\t\t\t\t\t\t\t\t$ListDelete[`size($ListDelete)`]=$IndexR[$CRVnum]; " ; print "LINE_B 358 "; print "\n" ;
    //$IndexR[$CRVnum]
    print " \t\t\t\t\t\t\t\t\t\t\t\t//$IndexR[$CRVnum] " ; print "LINE_B 359 "; print "\n" ;
    //This creates the MiddleSeg Vector global //
    print " \t\t\t\t\t\t\t\t\t\t\t\t//This creates the MiddleSeg Vector global // " ; print "LINE_B 360 "; print "\n" ;
    $NewCRVc=CutExisting($sortedTG[$IndexR[$CRVnum]], $crvsFoundCut[$USortK[$IndexR[$CRVnum]]] );
    print " \t\t\t\t\t\t\t\t\t\t\t\t$NewCRVc=CutExisting($sortedTG[$IndexR[$CRVnum]], $crvsFoundCut[$USortK[$IndexR[$CRVnum]]] );\t " ; print "LINE_B 361 "; print "\n" ;
    // CHANGE when if you sort it
    print " \t\t\t\t\t\t\t\t\t\t\t\t// CHANGE when if you sort it\t\t\t\t\t\t\t " ; print "LINE_B 362 "; print "\n" ;
    $ExistCRVn = $IndexR[$USortK[$IndexR[$CRVnum]]];
    print " \t\t\t\t\t\t\t\t\t\t\t\tint $ExistCRVn =$IndexR[$USortK[$IndexR[$CRVnum]]]; " ; print "LINE_B 363 "; print "\n" ;
    $ENDsAB = IndexPairArrayFunc({$ExistCRVn});
    print " \t\t\t\t\t\t\t\t\t\t\t\tint $ENDsAB[] =IndexPairArrayFunc({$ExistCRVn}); " ; print "LINE_B 364 "; print "\n" ;
    $ExistCRVVEC = $ENDsAB[0];
    print " \t\t\t\t\t\t\t\t\t\t\t\tint $ExistCRVVEC = $ENDsAB[0];\t\t\t\t\t\t\t " ; print "LINE_B 365 "; print "\n" ;
    IndexCRV_VEC({1,0},{$ExistCRVVEC,0}, {$SnapEnds[0],$MiddleSeg},$NewCRVc[0]);
    print " \t\t\t\t\t\t\t\t\t\t\t\tIndexCRV_VEC({1,0},{$ExistCRVVEC,0}, {$SnapEnds[0],$MiddleSeg},$NewCRVc[0]); " ; print "LINE_B 366 "; print "\n" ;
    $ExistCRVVEC = $ENDsAB[1];
    print " \t\t\t\t\t\t\t\t\t\t\t\t$ExistCRVVEC = $ENDsAB[1]; " ; print "LINE_B 367 "; print "\n" ;
    IndexCRV_VEC({1,1},{$SizeVABpast[0],$ExistCRVVEC}, {$MiddleSeg,$MiddleSeg},$NewCRVc[1]);
    print " \t\t\t\t\t\t\t\t\t\t\t\tIndexCRV_VEC({1,1},{$SizeVABpast[0],$ExistCRVVEC}, {$MiddleSeg,$MiddleSeg},$NewCRVc[1]);\t\t\t\t\t\t\t\t\t\t " ; print "LINE_B 368 "; print "\n" ;
    for($eachC in $NewCRVc){
    print " \t\t\t\t\t\t\t\t\t\t\t\tfor($eachC in $NewCRVc){ " ; print "LINE_B 369 "; print "\n" ;
    $AllNew[`size($AllNew)`]= $eachC;
    print " \t\t\t\t\t\t\t\t\t\t\t\t\t$AllNew[`size($AllNew)`]= $eachC; " ; print "LINE_B 370 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t\t\t\t} " ; print "LINE_B 371 "; print "\n" ;
    $CollectCRV[`size($CollectCRV)`]= $crvsFoundCut[$USortK[$IndexR[$CRVnum]]];
    print " \t\t\t\t\t\t\t\t\t\t\t\t$CollectCRV[`size($CollectCRV)`]= $crvsFoundCut[$USortK[$IndexR[$CRVnum]]]; " ; print "LINE_B 372 "; print "\n" ;

    print " \t\t\t\t\t\t\t\t\t\t\t\t " ; print "LINE_B 373 "; print "\n" ;
    $Ocrv+=1;
    print " \t\t\t\t\t\t\t\t\t\t\t\t$Ocrv+=1; " ; print "LINE_B 374 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t\t\t} " ; print "LINE_B 375 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t\t} " ; print "LINE_B 376 "; print "\n" ;
    /////// FIRST END SEG NOT MIDDLE  END
    print " \t\t\t\t\t\t\t\t\t\t/////// FIRST END SEG NOT MIDDLE  END\t\t\t " ; print "LINE_B 377 "; print "\n" ;
    //////////////////////////////////////////////////////// LAST END SEG NOT MIDDLE
    print " \t\t\t\t\t\t\t\t\t\t//////////////////////////////////////////////////////// LAST END SEG NOT MIDDLE " ; print "LINE_B 378 "; print "\n" ;
    if((($m_Or_e[$iC]==1)&&($iC==($SizeSeg-1)))&&($CCi[0]==1)){
    print " \t\t\t\t\t\t\t\t\t\tif((($m_Or_e[$iC]==1)&&($iC==($SizeSeg-1)))&&($CCi[0]==1)){ " ; print "LINE_B 379 "; print "\n" ;
    //XB
    print " \t\t\t\t\t\t\t\t\t\t\t//XB \t\t\t\t\t\t\t\t\t\t " ; print "LINE_B 380 "; print "\n" ;
    if(!($Ocrv>$SizeSeg)){
    print " \t\t\t\t\t\t\t\t\t\t\tif(!($Ocrv>$SizeSeg)){ " ; print "LINE_B 381 "; print "\n" ;
    //XBBB
    print " \t\t\t\t\t\t\t\t\t\t\t//XBBB " ; print "LINE_B 382 "; print "\n" ;
    print " \t\t\t\t\t\t\t\t\t\t\t\tstring $NewCRVc[]; " ; print "LINE_B 383 "; print "\n" ;
    print " \t\t\t\t\t\t\t\t\t\t\t\tstring $NewCRVc[]; " ; print "LINE_B 384 "; print "\n" ;
    $CRVnum = CRVIndexPairF($VecTA);
    print " \t\t\t\t\t\t\t\t\t\t\t\tint $CRVnum = CRVIndexPairF($VecTA); " ; print "LINE_B 385 "; print "\n" ;
    $ListDelete[`size($ListDelete)`]=$IndexR[$CRVnum];
    print " \t\t\t\t\t\t\t\t\t\t\t\t$ListDelete[`size($ListDelete)`]=$IndexR[$CRVnum]; " ; print "LINE_B 386 "; print "\n" ;
    //This creates the MiddleSeg Vector global //
    print " \t\t\t\t\t\t\t\t\t\t\t\t//This creates the MiddleSeg Vector global // " ; print "LINE_B 387 "; print "\n" ;
    $NewCRVc=CutExisting($sortedTG[$IndexR[$CRVnum]], $crvsFoundCut[$USortK[$IndexR[$CRVnum]]] );
    print " \t\t\t\t\t\t\t\t\t\t\t\t$NewCRVc=CutExisting($sortedTG[$IndexR[$CRVnum]], $crvsFoundCut[$USortK[$IndexR[$CRVnum]]] );\t " ; print "LINE_B 388 "; print "\n" ;
    // CHANGE when if you sort it
    print " \t\t\t\t\t\t\t\t\t\t\t\t// CHANGE when if you sort it\t\t\t\t\t\t\t " ; print "LINE_B 389 "; print "\n" ;
    $ExistCRVn = $IndexR[$USortK[$IndexR[$CRVnum]]];
    print " \t\t\t\t\t\t\t\t\t\t\t\tint $ExistCRVn =$IndexR[$USortK[$IndexR[$CRVnum]]]; " ; print "LINE_B 390 "; print "\n" ;
    $ENDsAB = IndexPairArrayFunc({$ExistCRVn});
    print " \t\t\t\t\t\t\t\t\t\t\t\tint $ENDsAB[] =IndexPairArrayFunc({$ExistCRVn}); " ; print "LINE_B 391 "; print "\n" ;
    $ExistCRVVEC = $ENDsAB[0];
    print " \t\t\t\t\t\t\t\t\t\t\t\tint $ExistCRVVEC = $ENDsAB[0];\t\t\t\t\t\t\t " ; print "LINE_B 392 "; print "\n" ;
    IndexCRV_VEC({1,0},{$ExistCRVVEC,0}, {$SnapEnds[0],$MiddleSeg},$NewCRVc[0]);
    print " \t\t\t\t\t\t\t\t\t\t\t\tIndexCRV_VEC({1,0},{$ExistCRVVEC,0}, {$SnapEnds[0],$MiddleSeg},$NewCRVc[0]); " ; print "LINE_B 393 "; print "\n" ;
    $ExistCRVVEC = $ENDsAB[1];
    print " \t\t\t\t\t\t\t\t\t\t\t\t$ExistCRVVEC = $ENDsAB[1]; " ; print "LINE_B 394 "; print "\n" ;
    IndexCRV_VEC({1,1},{$SizeVABpast[0],$ExistCRVVEC}, {$MiddleSeg,$MiddleSeg},$NewCRVc[1]);
    print " \t\t\t\t\t\t\t\t\t\t\t\tIndexCRV_VEC({1,1},{$SizeVABpast[0],$ExistCRVVEC}, {$MiddleSeg,$MiddleSeg},$NewCRVc[1]);\t\t\t\t\t\t\t\t\t\t " ; print "LINE_B 395 "; print "\n" ;
    for($eachC in $NewCRVc){
    print " \t\t\t\t\t\t\t\t\t\t\t\tfor($eachC in $NewCRVc){ " ; print "LINE_B 396 "; print "\n" ;
    $AllNew[`size($AllNew)`]= $eachC;
    print " \t\t\t\t\t\t\t\t\t\t\t\t\t$AllNew[`size($AllNew)`]= $eachC; " ; print "LINE_B 397 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t\t\t\t} " ; print "LINE_B 398 "; print "\n" ;
    $CollectCRV[`size($CollectCRV)`]= $crvsFoundCut[$USortK[$IndexR[$CRVnum]]];
    print " \t\t\t\t\t\t\t\t\t\t\t\t$CollectCRV[`size($CollectCRV)`]= $crvsFoundCut[$USortK[$IndexR[$CRVnum]]]; " ; print "LINE_B 399 "; print "\n" ;
    $Ocrv+=1;
    print " \t\t\t\t\t\t\t\t\t\t\t\t$Ocrv+=1; " ; print "LINE_B 400 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t " ; print "LINE_B 401 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t\t} " ; print "LINE_B 402 "; print "\n" ;
    //////////////////////////////////////////////////////// LAST END SEG NOT MIDDLE END
    print " \t\t\t\t\t\t\t\t\t\t//////////////////////////////////////////////////////// LAST END SEG NOT MIDDLE END\t\t\t\t\t\t\t " ; print "LINE_B 403 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t} " ; print "LINE_B 404 "; print "\n" ;
    //IF MIDDLE CRV
    print " \t\t\t\t\t\t\t\t//IF MIDDLE CRV \t\t\t\t\t " ; print "LINE_B 405 "; print "\n" ;
    if(($m_Or_e[$iC]==0)&&(($SA>$DistSSS)||($SB>$DistSSS))){
    print " \t\t\t\t\t\t\t\tif(($m_Or_e[$iC]==0)&&(($SA>$DistSSS)||($SB>$DistSSS))){\t\t\t\t\t\t " ; print "LINE_B 406 "; print "\n" ;
    if(!($Ocrv>$SizeSeg)){
    print " \t\t\t\t\t\t\t\t\tif(!($Ocrv>$SizeSeg)){ " ; print "LINE_B 407 "; print "\n" ;
    //XCCC
    print " \t\t\t\t\t\t\t\t\t//XCCC " ; print "LINE_B 408 "; print "\n" ;
    print " \t\t\t\t\t\t\t\t\t\tstring $NewCRVc[];\t\t " ; print "LINE_B 409 "; print "\n" ;
    $CRVnum = CRVIndexPairF($VecTB);
    print " \t\t\t\t\t\t\t\t\t\tint $CRVnum = CRVIndexPairF($VecTB); " ; print "LINE_B 410 "; print "\n" ;
    $ListDelete[`size($ListDelete)`]=$IndexR[$CRVnum];
    print " \t\t\t\t\t\t\t\t\t\t$ListDelete[`size($ListDelete)`]=$IndexR[$CRVnum]; " ; print "LINE_B 411 "; print "\n" ;
    $NewCRVc=CutExisting($sortedTG[$IndexR[$CRVnum]], $crvsFoundCut[$USortK[$IndexR[$CRVnum]]] );
    print " \t\t\t\t\t\t\t\t\t\t$NewCRVc=CutExisting($sortedTG[$IndexR[$CRVnum]], $crvsFoundCut[$USortK[$IndexR[$CRVnum]]] );\t " ; print "LINE_B 412 "; print "\n" ;
    // CHANGE when if you sort it
    print " \t\t\t\t\t\t\t\t\t\t// CHANGE when if you sort it\t\t\t\t\t\t\t " ; print "LINE_B 413 "; print "\n" ;
    $ExistCRVn = $IndexR[$USortK[$IndexR[$CRVnum]]];
    print " \t\t\t\t\t\t\t\t\t\tint $ExistCRVn =$IndexR[$USortK[$IndexR[$CRVnum]]]; " ; print "LINE_B 414 "; print "\n" ;
    $ENDsAB = IndexPairArrayFunc({$ExistCRVn});
    print " \t\t\t\t\t\t\t\t\t\tint $ENDsAB[] =IndexPairArrayFunc({$ExistCRVn}); " ; print "LINE_B 415 "; print "\n" ;
    $ExistCRVVEC = $ENDsAB[0];
    print " \t\t\t\t\t\t\t\t\t\tint $ExistCRVVEC = $ENDsAB[0];\t\t\t\t\t\t\t " ; print "LINE_B 416 "; print "\n" ;
    IndexCRV_VEC({1,0},{$ExistCRVVEC,0}, {$SnapEnds[0],$MiddleSeg},$NewCRVc[0]);
    print " \t\t\t\t\t\t\t\t\t\tIndexCRV_VEC({1,0},{$ExistCRVVEC,0}, {$SnapEnds[0],$MiddleSeg},$NewCRVc[0]); " ; print "LINE_B 417 "; print "\n" ;
    $ExistCRVVEC = $ENDsAB[1];
    print " \t\t\t\t\t\t\t\t\t\t$ExistCRVVEC = $ENDsAB[1]; " ; print "LINE_B 418 "; print "\n" ;
    IndexCRV_VEC({1,1},{$SizeVABpast[0],$ExistCRVVEC}, {$MiddleSeg,$MiddleSeg},$NewCRVc[1]);
    print " \t\t\t\t\t\t\t\t\t\tIndexCRV_VEC({1,1},{$SizeVABpast[0],$ExistCRVVEC}, {$MiddleSeg,$MiddleSeg},$NewCRVc[1]);\t\t\t\t\t\t\t\t\t\t " ; print "LINE_B 419 "; print "\n" ;
    for($eachC in $NewCRVc){
    print " \t\t\t\t\t\t\t\t\t\tfor($eachC in $NewCRVc){ " ; print "LINE_B 420 "; print "\n" ;
    $AllNew[`size($AllNew)`]= $eachC;
    print " \t\t\t\t\t\t\t\t\t\t\t$AllNew[`size($AllNew)`]= $eachC; " ; print "LINE_B 421 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t\t} " ; print "LINE_B 422 "; print "\n" ;
    $CollectCRV[`size($CollectCRV)`]= $crvsFoundCut[$USortK[$IndexR[$CRVnum]]];
    print " \t\t\t\t\t\t\t\t\t\t$CollectCRV[`size($CollectCRV)`]= $crvsFoundCut[$USortK[$IndexR[$CRVnum]]]; " ; print "LINE_B 423 "; print "\n" ;
    $Ocrv+=1;
    print " \t\t\t\t\t\t\t\t\t\t$Ocrv+=1; " ; print "LINE_B 424 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t " ; print "LINE_B 425 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t} " ; print "LINE_B 426 "; print "\n" ;
    if(($SA<$DistSSS)||($SB<$DistSSS)){
    print " \t\t\t\t\t\t\t\tif(($SA<$DistSSS)||($SB<$DistSSS)){ " ; print "LINE_B 427 "; print "\n" ;
    //XDDDDDD SNAP START
    print " \t\t\t\t\t\t\t\t//XDDDDDD SNAP START " ; print "LINE_B 428 "; print "\n" ;
    print " \t\t\t\t\t\t\t\t\tvector $CRVPts[]; " ; print "LINE_B 429 "; print "\n" ;
    $CRVPts  =VecCurveCvs($NewCutCRVs[$iC]);
    print " \t\t\t\t\t\t\t\t\t$CRVPts  =VecCurveCvs($NewCutCRVs[$iC]); " ; print "LINE_B 430 "; print "\n" ;
    print " \t\t\t\t\t\t\t\t\tvector $TranlatedCRV[]; " ; print "LINE_B 431 "; print "\n" ;
    $TranlatedCRV= Matrix_Curve_Translation2D($DrawnVecEnds,$SnapEnds,$CRVPts);
    print " \t\t\t\t\t\t\t\t\t$TranlatedCRV= Matrix_Curve_Translation2D($DrawnVecEnds,$SnapEnds,$CRVPts); " ; print "LINE_B 432 "; print "\n" ;
    delete $NewCutCRVs[$iC];
    print " \t\t\t\t\t\t\t\t\tdelete $NewCutCRVs[$iC]; " ; print "LINE_B 433 "; print "\n" ;
    $AllNew[`size($AllNew)`]=VecArrayToCurveB($TranlatedCRV);
    print " \t\t\t\t\t\t\t\t\t$AllNew[`size($AllNew)`]=VecArrayToCurveB($TranlatedCRV); " ; print "LINE_B 434 "; print "\n" ;
    IndexCRV_VEC( $CCi,{$MCurveIndex[$Ind3dV2P[$VecTA]],$MCurveIndex[$Ind3dV2P[$VecTB]]}, $SnapEnds,$AllNew[`size($AllNew)`-1]);
    print " \t\t\t\t\t\t\t\t\tIndexCRV_VEC( $CCi,{$MCurveIndex[$Ind3dV2P[$VecTA]],$MCurveIndex[$Ind3dV2P[$VecTB]]}, $SnapEnds,$AllNew[`size($AllNew)`-1]); " ; print "LINE_B 435 "; print "\n" ;
    //XDDDDDD SNAP END
    print " \t\t\t\t\t\t\t\t//XDDDDDD SNAP END " ; print "LINE_B 436 "; print "\n" ;
    }else{ //XDEDEDEDE SNAP START
    print " \t\t\t\t\t\t\t\t}else{ //XDEDEDEDE SNAP START " ; print "LINE_B 437 "; print "\n" ;
    IndexCRV_VEC( $CCi,{$MCurveIndex[$Ind3dV2P[$VecTA]],$MCurveIndex[$Ind3dV2P[$VecTB]]},$SnapEnds,$NewCutCRVs[$iC]);
    print " \t\t\t\t\t\t\t\tIndexCRV_VEC( $CCi,{$MCurveIndex[$Ind3dV2P[$VecTA]],$MCurveIndex[$Ind3dV2P[$VecTB]]},$SnapEnds,$NewCutCRVs[$iC]); " ; print "LINE_B 438 "; print "\n" ;
    //XDEDEDEDE SNAP END
    print " \t\t\t\t\t\t\t\t//XDEDEDEDE SNAP END " ; print "LINE_B 439 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t\t} " ; print "LINE_B 440 "; print "\n" ;
    //end of if $SizeCuts	> 0
    print " \t\t\t\t\t\t\t\t//end of if $SizeCuts\t> 0 " ; print "LINE_B 441 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t} " ; print "LINE_B 442 "; print "\n" ;
    }
    print " \t\t\t\t\t\t} " ; print "LINE_B 443 "; print "\n" ;
    }else if($SizeCuts==0){
    print " \t\t\t\t\t}else if($SizeCuts==0){\t\t\t\t " ; print "LINE_B 444 "; print "\n" ;
    $DrawnVecEnds  =VecCurveEnds({$Sel[0]});
    print " \t\t\t\t\t\t$DrawnVecEnds  =VecCurveEnds({$Sel[0]}); " ; print "LINE_B 445 "; print "\n" ;
    print " \t\t\t\t\t\tvector $allNearVecEnds[]; " ; print "LINE_B 446 "; print "\n" ;
    $allNearVecEnds=$tempV;
    print " \t\t\t\t\t\t$allNearVecEnds=$tempV; " ; print "LINE_B 447 "; print "\n" ;
    $dist_A = ArrayDistancesVecTofloat($allNearVecEnds, $DrawnVecEnds[0]);
    print " \t\t\t\t\t\tfloat $dist_A[] = ArrayDistancesVecTofloat($allNearVecEnds, $DrawnVecEnds[0]); " ; print "LINE_B 448 "; print "\n" ;
    $dist_B = ArrayDistancesVecTofloat($allNearVecEnds, $DrawnVecEnds[1]);
    print " \t\t\t\t\t\tfloat $dist_B[] = ArrayDistancesVecTofloat($allNearVecEnds, $DrawnVecEnds[1]); " ; print "LINE_B 449 "; print "\n" ;
    print " \t\t\t\t\t\tint $DistSSSortA[]; " ; print "LINE_B 450 "; print "\n" ;
    print " \t\t\t\t\t\tint $DistSSSortB[]; " ; print "LINE_B 451 "; print "\n" ;
    $DistSSSortA=SortNumbersIntIndex($dist_A);
    print " \t\t\t\t\t\t$DistSSSortA=SortNumbersIntIndex($dist_A); " ; print "LINE_B 452 "; print "\n" ;
    $DistSSSortB=SortNumbersIntIndex($dist_B);
    print " \t\t\t\t\t\t$DistSSSortB=SortNumbersIntIndex($dist_B); " ; print "LINE_B 453 "; print "\n" ;
    $SmallestDistA = $dist_A[$DistSSSortA[0]];
    print " \t\t\t\t\t\tfloat $SmallestDistA =$dist_A[$DistSSSortA[0]]; " ; print "LINE_B 454 "; print "\n" ;
    $SmallestDistB = $dist_B[$DistSSSortB[0]];
    print " \t\t\t\t\t\tfloat $SmallestDistB =$dist_B[$DistSSSortB[0]];\t " ; print "LINE_B 455 "; print "\n" ;

    print " \t\t\t\t\t\t " ; print "LINE_B 456 "; print "\n" ;
    if($SmallestDistA<$DistSSS){
    print " \t\t\t\t\t\tif($SmallestDistA<$DistSSS){ " ; print "LINE_B 457 "; print "\n" ;
    $SnapEnds[0]=$allNearVecEnds[$DistSSSortA[0]];
    print " \t\t\t\t\t\t\t$SnapEnds[0]=$allNearVecEnds[$DistSSSortA[0]]; " ; print "LINE_B 458 "; print "\n" ;
    $CCi[0]=1;
    print " \t\t\t\t\t\t\t$CCi[0]=1; " ; print "LINE_B 459 "; print "\n" ;
    }else{$SnapEnds[0]=$DrawnVecEnds[0];
    print " \t\t\t\t\t\t}else{$SnapEnds[0]=$DrawnVecEnds[0]; " ; print "LINE_B 460 "; print "\n" ;
    $CCi[0]=0;
    print " \t\t\t\t\t\t\t$CCi[0]=0; " ; print "LINE_B 461 "; print "\n" ;
    }
    print " \t\t\t\t\t\t} " ; print "LINE_B 462 "; print "\n" ;
    if($SmallestDistB<$DistSSS){
    print " \t\t\t\t\t\tif($SmallestDistB<$DistSSS){ " ; print "LINE_B 463 "; print "\n" ;
    $SnapEnds[1]=$allNearVecEnds[$DistSSSortB[0]];
    print " \t\t\t\t\t\t\t$SnapEnds[1]=$allNearVecEnds[$DistSSSortB[0]]; " ; print "LINE_B 464 "; print "\n" ;
    $CCi[1]=1;
    print " \t\t\t\t\t\t\t$CCi[1]=1; " ; print "LINE_B 465 "; print "\n" ;
    }else{$SnapEnds[1]=$DrawnVecEnds[1];
    print " \t\t\t\t\t\t}else{$SnapEnds[1]=$DrawnVecEnds[1]; " ; print "LINE_B 466 "; print "\n" ;
    $CCi[1]=0;
    print " \t\t\t\t\t\t\t$CCi[1]=0; " ; print "LINE_B 467 "; print "\n" ;
    }
    print " \t\t\t\t\t\t} " ; print "LINE_B 468 "; print "\n" ;
    if(($SmallestDistA<$DistSSS)||($SmallestDistB<$DistSSS)){
    print " \t\t\t\t\t\tif(($SmallestDistA<$DistSSS)||($SmallestDistB<$DistSSS)){ " ; print "LINE_B 469 "; print "\n" ;
    //XEEEEEEE SNAP
    print " \t\t\t\t\t\t//XEEEEEEE SNAP " ; print "LINE_B 470 "; print "\n" ;
    print " \t\t\t\t\t\t\tvector $CRVPts[]; " ; print "LINE_B 471 "; print "\n" ;
    $CRVPts  =VecCurveCvs($Sel[0]);
    print " \t\t\t\t\t\t\t$CRVPts  =VecCurveCvs($Sel[0]); " ; print "LINE_B 472 "; print "\n" ;
    print " \t\t\t\t\t\t\tvector $TranlatedCRV[]; " ; print "LINE_B 473 "; print "\n" ;
    $TranlatedCRV= Matrix_Curve_Translation2D($DrawnVecEnds,$SnapEnds, $CRVPts);
    print " \t\t\t\t\t\t\t$TranlatedCRV= Matrix_Curve_Translation2D($DrawnVecEnds,$SnapEnds, $CRVPts); " ; print "LINE_B 474 "; print "\n" ;
    delete $Sel[0];
    print " \t\t\t\t\t\t\tdelete $Sel[0]; " ; print "LINE_B 475 "; print "\n" ;
    $AllNew[`size($AllNew)`]=VecArrayToCurveB($TranlatedCRV);
    print " \t\t\t\t\t\t\t$AllNew[`size($AllNew)`]=VecArrayToCurveB($TranlatedCRV);\t\t\t\t " ; print "LINE_B 476 "; print "\n" ;
    IndexCRV_VEC( $CCi,{$MCurveIndex[$Ind3dV2P[$DistSSSortA[0]]],$MCurveIndex[$Ind3dV2P[$DistSSSortB[0]]]}, $SnapEnds,$AllNew[`size($AllNew)`-1]);
    print " \t\t\t\t\t\t\tIndexCRV_VEC( $CCi,{$MCurveIndex[$Ind3dV2P[$DistSSSortA[0]]],$MCurveIndex[$Ind3dV2P[$DistSSSortB[0]]]}, $SnapEnds,$AllNew[`size($AllNew)`-1]); " ; print "LINE_B 477 "; print "\n" ;
    //XEEEEEEE SNAP END
    print " \t\t\t\t\t\t//XEEEEEEE SNAP END " ; print "LINE_B 478 "; print "\n" ;
    }else{
    print " \t\t\t\t\t\t}else{ " ; print "LINE_B 479 "; print "\n" ;
    if(($CCi[0]+$CCi[1])==0){
    print " \t\t\t\t\t\t\tif(($CCi[0]+$CCi[1])==0){\t\t\t\t\t " ; print "LINE_B 480 "; print "\n" ;
    IndexCRV_VEC( $CCi,{$MCurveIndex[$Ind3dV2P[$DistSSSortA[0]]],$MCurveIndex[$Ind3dV2P[$DistSSSortB[0]]]}, $SnapEnds,$Sel[0]);
    print " \t\t\t\t\t\t\t\tIndexCRV_VEC( $CCi,{$MCurveIndex[$Ind3dV2P[$DistSSSortA[0]]],$MCurveIndex[$Ind3dV2P[$DistSSSortB[0]]]}, $SnapEnds,$Sel[0]); " ; print "LINE_B 481 "; print "\n" ;
    $AllNew[0] =$Sel[0];
    print " \t\t\t\t\t\t\t\t$AllNew[0] =$Sel[0]; " ; print "LINE_B 482 "; print "\n" ;
    }
    print " \t\t\t\t\t\t\t} " ; print "LINE_B 483 "; print "\n" ;
    }
    print " \t\t\t\t\t\t} " ; print "LINE_B 484 "; print "\n" ;
    }
    print " \t\t\t\t\t} " ; print "LINE_B 485 "; print "\n" ;
    }else{
    print " \t\t\t\t}else{\t " ; print "LINE_B 486 "; print "\n" ;
    $DrawnVecEnds  =VecCurveEnds({$Sel[0]});
    print " \t\t\t\t\t$DrawnVecEnds  =VecCurveEnds({$Sel[0]});\t\t " ; print "LINE_B 487 "; print "\n" ;
    IndexCRV_VEC({0,0},({0,0}),$DrawnVecEnds,$Sel[0]);
    print " \t\t\t\t\tIndexCRV_VEC({0,0},({0,0}),$DrawnVecEnds,$Sel[0]);\t\t " ; print "LINE_B 488 "; print "\n" ;
    $AllNew[0] =$Sel[0];
    print " \t\t\t\t\t$AllNew[0] =$Sel[0]; " ; print "LINE_B 489 "; print "\n" ;
    }
    print " \t\t\t\t} " ; print "LINE_B 490 "; print "\n" ;
    print " \t\t\t\t " ; print "LINE_B 491 "; print "\n" ;
    }else{
    print " \t\t\t}else{\t " ; print "LINE_B 492 "; print "\n" ;
    $DrawnVecEnds  =VecCurveEnds({$Sel[0]});
    print " \t\t\t\t$DrawnVecEnds  =VecCurveEnds({$Sel[0]});\t\t " ; print "LINE_B 493 "; print "\n" ;
    IndexCRV_VEC({0,0},({0,0}),$DrawnVecEnds,$Sel[0]);
    print " \t\t\t\tIndexCRV_VEC({0,0},({0,0}),$DrawnVecEnds,$Sel[0]);\t\t " ; print "LINE_B 494 "; print "\n" ;
    $AllNew[0] =$Sel[0];
    print " \t\t\t\t$AllNew[0] =$Sel[0]; " ; print "LINE_B 495 "; print "\n" ;			}
    print " \t\t\t}\t\t\t " ; print "LINE_B 496 "; print "\n" ;
    //if($Ocrv>0){  delete $Sel[0];
    print " \t\t\t//if($Ocrv>0){  delete $Sel[0];\t\t " ; print "LINE_B 497 "; print "\n" ;
    //}
    print " \t\t//}\t\t\t\t " ; print "LINE_B 498 "; print "\n" ;
    if(`size($ListDelete)`>0){
    print " \t\t\tif(`size($ListDelete)`>0){ " ; print "LINE_B 499 "; print "\n" ;
    //AppendOrdeleteCRV($ListDelete,0);
    print " \t\t\t\t//AppendOrdeleteCRV($ListDelete,0); " ; print "LINE_B 500 "; print "\n" ;
    }
    print " \t\t\t} " ; print "LINE_B 501 "; print "\n" ;
    print " \t\t\treturn $AllNew; " ; print "LINE_B 502 "; print "\n" ;

    return $AllNew;
    }

    /*
    //GOOD

    proc string [] CRV2Dscript(string $Sel_list[],string $Sel[]){

    global int $Ind3dV2P[];
    global float $U[];
    global string $Tstring[];
    global float $T_G[];
    global int $CurveCutIndex[];
    global float $DistSSS;
    global string $CrvN_And_Vector[];
    global int $MCurveIndex[];
    global vector $AllKnowVecEnds[];
    global string $CurveNames[];
    global int $CRVNameIndex[];
    global int $Ind3d_past[];
    global int $SizeVABpast[];
    global vector $MiddleSeg;
    $tempCRVNAMES = $CurveNames;
    $MoreThenOne = 0;
    //DEBUG
    $NoCUT = 1;
    $Ocrv = 0;
    clear $AllNew;
    $iC = 0;
    clear $Sel_list;
    for($iC=0; $iC<`size($CRVNameIndex)`; $iC++){
    $TEMP_new[$iC]=$tempCRVNAMES[$CRVNameIndex[$iC]];
    }
    $Sel_list =$TEMP_new;
    $CCi={0,0};
    //////////////////////////////////////////////
    //STEP #1
    $SizeCuts = 0;
    $SFoundC = 0;
    clear $IndexA;
    $IndexA=InsideRectangle($Sel[0],$Sel_list);
    //get INDEX of ONLY EXISTING CURVES
    for($iC=0; $iC<`size($IndexA)`; $iC++){
    $IndexB[$iC]=$CRVNameIndex[$IndexA[$iC]];
    }
    $IndexA=$IndexB;
    $sZ =`size($IndexA)`;
    clear $Ind3dV2P;
    $Ind3dV2P=IndexPairArrayFunc($IndexA);

    if($sZ>0){
    $Arc =`arclen $Sel[0]`;
    clear $crvsFound;
    for($Icr=0;  $Icr<$sZ; $Icr++){
    $crvsFound[$Icr]=$Sel_list[$IndexA[$Icr]];
    }
    for($Icr=0;  $Icr<$sZ*2; $Icr++){
    $tempV[$Icr]=  $AllKnowVecEnds[$MCurveIndex[$Ind3dV2P[$Icr]]];
    $tempStringI[$Icr] =$MCurveIndex[$Ind3dV2P[$Icr]];
    }
    $allNearVecEnds=$tempV;
    //STEP #2
    $FoundCut_Index = DoesCurveBBcrossCurve($Sel[0], $crvsFound);
    clear $crvsOther;
    clear $crvsFoundCut;
    $sZ =`size($crvsFound)`;
    $FC = 0;
    for($Icr=0;  $Icr<$sZ; $Icr++){
    if($FoundCut_Index[$FC]==$Icr){
    $IndexR[$FC] =$IndexA[$FoundCut_Index[$FC]];
    $crvsFoundCut[$FC]=$crvsFound[$FoundCut_Index[$FC]];
    $FC++;
    }else{
    $crvsOther[`size($crvsOther)`]=$crvsFound[$Icr];
    $IndexO[`size($IndexO)`]=$IndexA[$FoundCut_Index[$FC]];
    }
    }

    $SFoundC =`size($crvsFoundCut)`;

    if($SFoundC>0){

    clear $U;
    //YES  $CurveCutIndex is the int Index of found CRVS  so to track
    $CUTcrv = CurvatureUtilitySimple($crvsFoundCut, $Sel[0]);
    $CRV_IND=$CurveCutIndex;
    $SizeCuts =`size($U)`;
    print ("SizeCuts START:"+"\n");
    print $SizeCuts;
    print ("SizeCuts END"+"\n");

    // $CurveCutIndex  is the  index of the total size of  $crvsFoundCut that Intersects
    // so the past index Number
    ////////////////////////NEW
    $IndexOb=$IndexO;
    $sZ =`size($crvsFoundCut)`;
    $FC=0;
    for($Icr=0;  $Icr<$sZ; $Icr++){

    if($CRV_IND[$FC]==$Icr){
    $IndexRb[$FC] =$IndexR[$CRV_IND[$FC]];
    $FC++;
    }else{
    $IndexOb[`size($IndexOb)`]=$IndexR[$CRV_IND[$FC]];
    }
    }
    //May need to change this
    $IndexR=$IndexRb;
    //May need to change this
    $IndexO= $IndexOb;
    ////////////////////////NEW
    if($SizeCuts>0){
    $oldUii = $U;
    $USortK = SortNumbersIntIndex($U);

    for($iC=0; $iC<`size($USortK)`; $iC++){
    $sortedTG[$iC]= $T_G[$USortK[$iC]];
    $tempIN[$iC]=$CRV_IND[$USortK[$iC]];				}
    $USortK=$tempIN;
    $U=sort($U);
    $Tsize = `size($U)`;
    // if the cuts made to the drawn CRV is greater then one like 2 then you must track what ends are kept
    // track items ONE are crv cuts greater then 1? True or false
    // TWO are the firstand last ends kept
    if($Tsize!= 1){
    $MoreThenOne=1;
    $MperS = ($Arc*($U[0]));
    $MperE = ($Arc*(1-$U[$SizeCuts-1]));
    if( $MperS >= 5.5){
    $TempU[`size($TempU)`]=0.0;
    $m_Or_e[`size($m_Or_e)`]=1;
    }
    for($iC=0; $iC<$SizeCuts; $iC++){
    $TempU[`size($TempU)`]=$U[$iC];
    }
    for($iC=0; $iC<$SizeCuts-1; $iC++){
    $m_Or_e[`size($m_Or_e)`]=0;
    }
    if($MperE>=5.5){
    $TempU[`size($TempU)`]=1.0;
    $m_Or_e[`size($m_Or_e)`]=1;
    }
    $U=$TempU;
    }
    if($Tsize== 1){
    $TempUi[0]=0.0;
    $TempUi[1]=$U[0];
    $TempUi[2]=1.0;
    $U=$TempUi;
    $MperS = (100*($U[1]));
    $MperE = (100*(1-$U[1]));
    if( $MperS >= 15){$TempU[`size($TempU)`]=0.0; $m_Or_e[`size($m_Or_e)`]=1;}
    $TempU[`size($TempU)`]=$U[1];
    if($MperE>=15){$TempU[`size($TempU)`]=1.0; $m_Or_e[`size($m_Or_e)`]=1;}
    clear $U;
    $U=$TempU;

    print ("Tsize = 1 START:"+"\n");
    print ("m_Or_e START:"+"\n");
    print $m_Or_e;
    print ("m_Or_e END"+"\n");
    print ("Tsize = 1 END"+"\n");

    }
    $Hsize = `size($U)`;
    $Hsize-=1;
    for($iC=0; $iC<$Hsize; $iC++){
    clear $CRVSEG_A;
    $CrvTSi = $U[$iC];
    $CrvTEi = $U[$iC+1];
    $Mper = ($Arc*($U[$iC+1]-$U[$iC]));
    $CRVSEG_A=RenderCurveSeg($Sel[0],12,$CrvTSi,$CrvTEi);
    $NewCutCRVs[`size($NewCutCRVs)`]=VecArrayToCurveB($CRVSEG_A);
    }
    ////////////////
    // Place new
    print ("m_Or_e START:"+"\n");
    print $m_Or_e;
    print ("m_Or_e END"+"\n");



    if(`size($IndexO)`>0){
    $TempINA =IndexPairArrayFunc($IndexO);
    for($Icr=0;  $Icr<$sZ*2; $Icr++){
    $tempVi[$Icr]=  $AllKnowVecEnds[$MCurveIndex[$TempINA[$Icr]]];
    }
    }
    /////////////////
    // this is the curves that DO intersect!!
    $TempINAi =IndexPairArrayFunc($IndexR);
    for($Icr=0;  $Icr<$sZ*2; $Icr++){
    $tempVii[$Icr]=  $AllKnowVecEnds[$MCurveIndex[$TempINAi[$Icr]]];
    }

    $SizeSeg =`size($NewCutCRVs)`;

    if($NoCUT==1){

    for($iC=0; $iC<$SizeSeg; $iC++)
    {

    $VecTA=0;
    $VecTB=0;
    //END curve and onle the first end can snap to "" OTHER curves
    $DrawnVecEnds  =VecCurveEnds({$NewCutCRVs[$iC]});
    /////////////////////////////////////////////////////////////////////////
    //END CRV






    /////////////////
    $DrawnVecEnds  =VecCurveEnds({$NewCutCRVs[$iC]});
    //  so here these vectors Must be the filter index of ONLY OTHER CURVES
    // AND NOTHING ESLE for  if((($m_Or_e[$iC]==1)&&($iC==($SizeSeg-1))&&($CCi[0]==1)){
    if((($m_Or_e[$iC]==1)&&($iC==0))&&($CCi[1]==1)){
    if(`size($IndexO)`>0){
    $dist_A= ArrayDistancesVecTofloat($tempVi, $DrawnVecEnds [0]);
    }
    $dist_B = ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [1]);
    if(`size($IndexO)`>0){	$DA=SortNumbersIntIndex($dist_A); $VecTA=$TempINA[$DA[0]];}
    $DB=SortNumbersIntIndex($dist_B);
    if(`size($IndexO)`>0){
    $SA =$dist_A[$DA[0]];
    }else{$SA=200;}
    $SB =$dist_B[$DB[0]];
    if($DA[0]==$DB[0]){
    if($SA<$SB){
    $SB=200;
    }else{$SA=200;}

    }
    //$VecTA=$TempINA[$DA[0]];
    $VecTB=$TempINAi[$DB[0]];
    if($SA<$DistSSS){
    $CCi[0]=1;
    $SnapEnds[0]=$tempVi[$DA[0]];
    }else{$SnapEnds[0]=$DrawnVecEnds[0]; $CCi[0]=0;
    }
    if($SB<$DistSSS){
    $CCi[1]=1;
    $SnapEnds[1]=$tempVii[$DB[0]];
    }else{$SnapEnds[1]=$DrawnVecEnds[1]; 	$CCi[1]=0;
    }
    }
    ////////////very messy
    if((($m_Or_e[$iC]==1)&&($iC==($SizeSeg-1)))&&($CCi[0]==1)){
    $dist_A= ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [0]);
    if(`size($IndexO)`>0){
    $dist_B = ArrayDistancesVecTofloat($tempVi, $DrawnVecEnds [1]);
    }
    $DA=SortNumbersIntIndex($dist_A);
    $VecTA=$TempINAi[$DA[0]];

    if(`size($IndexO)`>0){
    $DB=SortNumbersIntIndex($dist_B);
    $VecTB=$TempINA[$DB[0]];
    }
    $SA =$dist_A[$DA[0]];
    if(`size($IndexO)`>0){
    $SB =$dist_B[$DB[0]];
    }else{$SB=200;}
    if($SA<$DistSSS){
    $CCi[0]=1;
    $SnapEnds[0]=$tempVi[$DA[0]];
    }else{$SnapEnds[0]=$DrawnVecEnds[0]; $CCi[0]=0;
    }
    if($SB<$DistSSS){
    $CCi[1]=1;
    $SnapEnds[1]=$tempVii[$DB[0]];
    }else{$SnapEnds[1]=$DrawnVecEnds[1]; $CCi[1]=0;
    }
    }
    /////////////////////////////////////////////////////////////////////////
    //Middle curve
    if($m_Or_e[$iC]==0){
    $TempINAi=IndexPairArrayFunc($IndexR);
    for($Icr=0;  $Icr<$sZ*2; $Icr++){
    $tempVii[$Icr]=  $AllKnowVecEnds[$MCurveIndex[$TempINAi[$Icr]]];
    }
    $DrawnVecEnds  =VecCurveEnds({$NewCutCRVs[$iC]});
    $dist_A = ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [0]);
    $dist_B = ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [1]);
    $DA=SortNumbersIntIndex($dist_A);
    $DB=SortNumbersIntIndex($dist_B);
    $SA =$dist_A[$DA[0]];
    $SB =$dist_B[$DB[0]];
    $VecTA=$TempINAi[$DA[0]];
    $VecTB=$TempINAi[$DB[0]];

    if($DA[0]==$DB[0]){
    if($SA<$SB){
    $SB=200;
    }else{$SA=200;}
    }
    if($SA<$DistSSS){
    $CCi[0]=1;
    $SnapEnds[0]=$tempVii[$DA[0]];
    }else{$SnapEnds[0]=$DrawnVecEnds[0]; $CCi[0]=0;
    }
    if($SB<$DistSSS){
    $CCi[1]=1;
    $SnapEnds[1]=$tempVii[$DB[0]];
    }else{$SnapEnds[1]=$DrawnVecEnds[1]; $CCi[1]=0;
    }
    }
    //if segment is an end curve and one vector snaps is that vector the start or end of crv?
    // this is saying if the fist segment is an end crv OR if the last Curve is an end Crv and One vector snaps
    if((($m_Or_e[$iC]==1)&&($iC==0))||(($m_Or_e[$iC]==1)&&( $iC==($SizeSeg-1)))){
    // this is saying if the fist segment is an end crv OR if the last Curve is an end Crv and One vector snaps
    /////// FIRST END SEG NOT MIDDLE
    if((($m_Or_e[$iC]==1)&&($iC==0))&&($CCi[1]==1)){
    //XA
    if(!($Ocrv>$SizeSeg)){
    //XAAA
    $CRVnum = CRVIndexPairF($VecTB);
    $ListDelete[`size($ListDelete)`]=$IndexR[$CRVnum];
    //$IndexR[$CRVnum]
    //This creates the MiddleSeg Vector global //
    $NewCRVc=CutExisting($sortedTG[$IndexR[$CRVnum]], $crvsFoundCut[$USortK[$IndexR[$CRVnum]]] );
    // CHANGE when if you sort it
    $ExistCRVn = $IndexR[$USortK[$IndexR[$CRVnum]]];
    $ENDsAB = IndexPairArrayFunc({$ExistCRVn});
    $ExistCRVVEC = $ENDsAB[0];
    IndexCRV_VEC({1,0},{$ExistCRVVEC,0}, {$SnapEnds[0],$MiddleSeg},$NewCRVc[0]);
    $ExistCRVVEC = $ENDsAB[1];
    IndexCRV_VEC({1,1},{$SizeVABpast[0],$ExistCRVVEC}, {$MiddleSeg,$MiddleSeg},$NewCRVc[1]);
    for($eachC in $NewCRVc){
    $AllNew[`size($AllNew)`]= $eachC;
    }
    $CollectCRV[`size($CollectCRV)`]= $crvsFoundCut[$USortK[$IndexR[$CRVnum]]];

    $Ocrv+=1;
    }
    }
    /////// FIRST END SEG NOT MIDDLE  END
    //////////////////////////////////////////////////////// LAST END SEG NOT MIDDLE
    if((($m_Or_e[$iC]==1)&&($iC==($SizeSeg-1)))&&($CCi[0]==1)){
    //XB
    if(!($Ocrv>$SizeSeg)){
    //XBBB
    $CRVnum = CRVIndexPairF($VecTA);
    $ListDelete[`size($ListDelete)`]=$IndexR[$CRVnum];
    //This creates the MiddleSeg Vector global //
    $NewCRVc=CutExisting($sortedTG[$IndexR[$CRVnum]], $crvsFoundCut[$USortK[$IndexR[$CRVnum]]] );
    // CHANGE when if you sort it
    $ExistCRVn = $IndexR[$USortK[$IndexR[$CRVnum]]];
    $ENDsAB = IndexPairArrayFunc({$ExistCRVn});
    $ExistCRVVEC = $ENDsAB[0];
    IndexCRV_VEC({1,0},{$ExistCRVVEC,0}, {$SnapEnds[0],$MiddleSeg},$NewCRVc[0]);
    $ExistCRVVEC = $ENDsAB[1];
    IndexCRV_VEC({1,1},{$SizeVABpast[0],$ExistCRVVEC}, {$MiddleSeg,$MiddleSeg},$NewCRVc[1]);
    for($eachC in $NewCRVc){
    $AllNew[`size($AllNew)`]= $eachC;
    }
    $CollectCRV[`size($CollectCRV)`]= $crvsFoundCut[$USortK[$IndexR[$CRVnum]]];
    $Ocrv+=1;
    }
    }
    //////////////////////////////////////////////////////// LAST END SEG NOT MIDDLE END
    }
    //IF MIDDLE CRV
    if(($m_Or_e[$iC]==0)&&(($SA>$DistSSS)||($SB>$DistSSS))){
    if(!($Ocrv>$SizeSeg)){
    //XCCC
    $CRVnum = CRVIndexPairF($VecTB);
    $ListDelete[`size($ListDelete)`]=$IndexR[$CRVnum];
    $NewCRVc=CutExisting($sortedTG[$IndexR[$CRVnum]], $crvsFoundCut[$USortK[$IndexR[$CRVnum]]] );
    // CHANGE when if you sort it
    $ExistCRVn = $IndexR[$USortK[$IndexR[$CRVnum]]];
    $ENDsAB = IndexPairArrayFunc({$ExistCRVn});
    $ExistCRVVEC = $ENDsAB[0];
    IndexCRV_VEC({1,0},{$ExistCRVVEC,0}, {$SnapEnds[0],$MiddleSeg},$NewCRVc[0]);
    $ExistCRVVEC = $ENDsAB[1];
    IndexCRV_VEC({1,1},{$SizeVABpast[0],$ExistCRVVEC}, {$MiddleSeg,$MiddleSeg},$NewCRVc[1]);
    for($eachC in $NewCRVc){
    $AllNew[`size($AllNew)`]= $eachC;
    }
    $CollectCRV[`size($CollectCRV)`]= $crvsFoundCut[$USortK[$IndexR[$CRVnum]]];
    $Ocrv+=1;
    }
    }
    if(($SA<$DistSSS)||($SB<$DistSSS)){
    //XDDDDDD SNAP START
    $CRVPts  =VecCurveCvs($NewCutCRVs[$iC]);
    $TranlatedCRV= Matrix_Curve_Translation2D($DrawnVecEnds,$SnapEnds,$CRVPts);
    delete $NewCutCRVs[$iC];
    $AllNew[`size($AllNew)`]=VecArrayToCurveB($TranlatedCRV);
    IndexCRV_VEC( $CCi,{$MCurveIndex[$Ind3dV2P[$VecTA]],$MCurveIndex[$Ind3dV2P[$VecTB]]}, $SnapEnds,$AllNew[`size($AllNew)`-1]);
    //XDDDDDD SNAP END
    }else{ //XDEDEDEDE SNAP START
    IndexCRV_VEC( $CCi,{$MCurveIndex[$Ind3dV2P[$VecTA]],$MCurveIndex[$Ind3dV2P[$VecTB]]},$SnapEnds,$NewCutCRVs[$iC]);
    //XDEDEDEDE SNAP END
    }
    //end of if $SizeCuts	> 0
    }
    }
    }else if($SizeCuts==0){
    $DrawnVecEnds  =VecCurveEnds({$Sel[0]});
    $allNearVecEnds=$tempV;
    $dist_A = ArrayDistancesVecTofloat($allNearVecEnds, $DrawnVecEnds[0]);
    $dist_B = ArrayDistancesVecTofloat($allNearVecEnds, $DrawnVecEnds[1]);
    $DistSSSortA=SortNumbersIntIndex($dist_A);
    $DistSSSortB=SortNumbersIntIndex($dist_B);
    $SmallestDistA = $dist_A[$DistSSSortA[0]];
    $SmallestDistB = $dist_B[$DistSSSortB[0]];

    if($SmallestDistA<$DistSSS){
    $SnapEnds[0]=$allNearVecEnds[$DistSSSortA[0]];
    $CCi[0]=1;
    }else{$SnapEnds[0]=$DrawnVecEnds[0];
    $CCi[0]=0;
    }
    if($SmallestDistB<$DistSSS){
    $SnapEnds[1]=$allNearVecEnds[$DistSSSortB[0]];
    $CCi[1]=1;
    }else{$SnapEnds[1]=$DrawnVecEnds[1];
    $CCi[1]=0;
    }
    if(($SmallestDistA<$DistSSS)||($SmallestDistB<$DistSSS)){
    //XEEEEEEE SNAP
    $CRVPts  =VecCurveCvs($Sel[0]);
    $TranlatedCRV= Matrix_Curve_Translation2D($DrawnVecEnds,$SnapEnds, $CRVPts);
    delete $Sel[0];
    $AllNew[`size($AllNew)`]=VecArrayToCurveB($TranlatedCRV);
    IndexCRV_VEC( $CCi,{$MCurveIndex[$Ind3dV2P[$DistSSSortA[0]]],$MCurveIndex[$Ind3dV2P[$DistSSSortB[0]]]}, $SnapEnds,$AllNew[`size($AllNew)`-1]);
    //XEEEEEEE SNAP END
    }else{
    if(($CCi[0]+$CCi[1])==0){
    IndexCRV_VEC( $CCi,{$MCurveIndex[$Ind3dV2P[$DistSSSortA[0]]],$MCurveIndex[$Ind3dV2P[$DistSSSortB[0]]]}, $SnapEnds,$Sel[0]);
    $AllNew[0] =$Sel[0];
    }
    }
    }
    }else{
    $DrawnVecEnds  =VecCurveEnds({$Sel[0]});
    IndexCRV_VEC({0,0},({0,0}),$DrawnVecEnds,$Sel[0]);
    $AllNew[0] =$Sel[0];
    }

    }else{
    $DrawnVecEnds  =VecCurveEnds({$Sel[0]});
    IndexCRV_VEC({0,0},({0,0}),$DrawnVecEnds,$Sel[0]);
    $AllNew[0] =$Sel[0];
    }
    //if($Ocrv>0){  delete $Sel[0];
    //}
    if(`size($ListDelete)`>0){
    //AppendOrdeleteCRV($ListDelete,0);
    }
    return $AllNew;
    }
    //END GOOD
    */

    ///////////////////////

    //////////////////////

    /*

    proc string [] CRV2Dscript(string $Sel_list[],string $Sel[])
    {
    global int $Ind3dV2P[];
    global float $U[];
    global string $Tstring[];
    global float $T_G[];
    global int $CurveCutIndex[];
    global float $DistSSS;
    global string $CrvN_And_Vector[];
    global int $MCurveIndex[];
    global vector $AllKnowVecEnds[];
    global string $CurveNames[];
    global int $CRVNameIndex[];
    global int $Ind3d_past[];
    global int $SizeVABpast[];
    global vector $MiddleSeg;
    $tempCRVNAMES = $CurveNames;
    $MoreThenOne = 0;
    //DEBUG
    $NoCUT = 1;
    $Ocrv = 0;
    clear $AllNew;
    $iC = 0;
    clear $Sel_list;
    for($iC=0; $iC<`size($CRVNameIndex)`; $iC++){
    $TEMP_new[$iC]=$tempCRVNAMES[$CRVNameIndex[$iC]];
    }
    $Sel_list =$TEMP_new;
    $CCi={0,0};
    //////////////////////////////////////////////
    //STEP #1
    $SizeCuts = 0;
    $SFoundC = 0;
    clear $IndexA;
    $IndexA=InsideRectangle($Sel[0],$Sel_list);
    //get INDEX of ONLY EXISTING CURVES
    for($iC=0; $iC<`size($IndexA)`; $iC++){
    $IndexB[$iC]=$CRVNameIndex[$IndexA[$iC]];
    }
    $IndexA=$IndexB;
    $sZ =`size($IndexA)`;
    clear $Ind3dV2P;
    $Ind3dV2P=IndexPairArrayFunc($IndexA);

    if($sZ>0){
    $Arc =`arclen $Sel[0]`;
    clear $crvsFound;
    for($Icr=0;  $Icr<$sZ; $Icr++){
    $crvsFound[$Icr]=$Sel_list[$IndexA[$Icr]];
    }
    for($Icr=0;  $Icr<$sZ*2; $Icr++){
    $tempV[$Icr]=  $AllKnowVecEnds[$MCurveIndex[$Ind3dV2P[$Icr]]];
    $tempStringI[$Icr] =$MCurveIndex[$Ind3dV2P[$Icr]];
    }
    $allNearVecEnds=$tempV;
    //STEP #2
    $FoundCut_Index = DoesCurveBBcrossCurve($Sel[0], $crvsFound);
    clear $crvsOther;
    clear $crvsFoundCut;
    $sZ =`size($crvsFound)`;
    $FC = 0;
    for($Icr=0;  $Icr<$sZ; $Icr++){
    if($FoundCut_Index[$FC]==$Icr){
    $IndexR[$FC] =$IndexA[$FoundCut_Index[$FC]];
    $crvsFoundCut[$FC]=$crvsFound[$FoundCut_Index[$FC]];
    $FC++;
    }else{
    $crvsOther[`size($crvsOther)`]=$crvsFound[$Icr];
    $IndexO[`size($IndexO)`]=$IndexA[$FoundCut_Index[$FC]];
    }
    }

    $SFoundC =`size($crvsFoundCut)`;

    if($SFoundC>0){

    clear $U;
    //YES  $CurveCutIndex is the int Index of found CRVS  so to track
    $CUTcrv = CurvatureUtilitySimple($crvsFoundCut, $Sel[0]);
    $CRV_IND=$CurveCutIndex;
    $SizeCuts =`size($U)`;
    print ("SizeCuts START:"+"\n");
    print $SizeCuts;
    print ("SizeCuts END"+"\n");

    // $CurveCutIndex  is the  index of the total size of  $crvsFoundCut that Intersects
    // so the past index Number
    ////////////////////////NEW
    $IndexOb=$IndexO;
    $sZ =`size($crvsFoundCut)`;
    $FC=0;
    for($Icr=0;  $Icr<$sZ; $Icr++){

    if($CRV_IND[$FC]==$Icr){
    $IndexRb[$FC] =$IndexR[$CRV_IND[$FC]];
    $FC++;
    }else{
    $IndexOb[`size($IndexOb)`]=$IndexR[$CRV_IND[$FC]];
    }
    }
    //May need to change this
    $IndexR=$IndexRb;
    //May need to change this
    $IndexO= $IndexOb;
    ////////////////////////NEW
    if($SizeCuts>0){
    $oldUii = $U;
    $USortK = SortNumbersIntIndex($U);

    for($iC=0; $iC<`size($USortK)`; $iC++){
    $sortedTG[$iC]= $T_G[$USortK[$iC]];
    $tempIN[$iC]=$CRV_IND[$USortK[$iC]];				}
    $USortK=$tempIN;
    $U=sort($U);
    $Tsize = `size($U)`;
    // if the cuts made to the drawn CRV is greater then one like 2 then you must track what ends are kept
    // track items ONE are crv cuts greater then 1? True or false
    // TWO are the firstand last ends kept
    if($Tsize!= 1){
    $MoreThenOne=1;
    $MperS = ($Arc*($U[0]));
    $MperE = ($Arc*(1-$U[$SizeCuts-1]));
    if( $MperS >= 5.5){
    $TempU[`size($TempU)`]=0.0;
    $m_Or_e[`size($m_Or_e)`]=1;
    }

    for($iC=0; $iC<$SizeCuts; $iC++){
    $TempU[`size($TempU)`]=$U[$iC];
    }
    for($iC=0; $iC<$SizeCuts-1; $iC++){
    $m_Or_e[`size($m_Or_e)`]=0;
    }
    if($MperE>=5.5){
    $TempU[`size($TempU)`]=1.0;

    $m_Or_e[`size($m_Or_e)`]=1;
    }
    $U=$TempU;
    }
    if($Tsize== 1){
    $TempUi[0]=0.0;
    $TempUi[1]=$U[0];
    $TempUi[2]=1.0;
    $U=$TempUi;
    $MperS = (100*($U[1]));
    $MperE = (100*(1-$U[1]));
    if( $MperS >= 15){$TempU[`size($TempU)`]=0.0; $m_Or_e[`size($m_Or_e)`]=1;}
    $TempU[`size($TempU)`]=$U[1];
    if($MperE>=15){$TempU[`size($TempU)`]=1.0; $m_Or_e[`size($m_Or_e)`]=1;}
    clear $U;
    $U=$TempU;

    print ("Tsize = 1 START:"+"\n");
    print ("m_Or_e START:"+"\n");
    print $m_Or_e;
    print ("m_Or_e END"+"\n");
    print ("Tsize = 1 END"+"\n");

    }
    $Hsize = `size($U)`;
    $Hsize-=1;
    for($iC=0; $iC<$Hsize; $iC++){
    clear $CRVSEG_A;
    $CrvTSi = $U[$iC];
    $CrvTEi = $U[$iC+1];
    $Mper = ($Arc*($U[$iC+1]-$U[$iC]));
    $CRVSEG_A=RenderCurveSeg($Sel[0],12,$CrvTSi,$CrvTEi);
    $NewCutCRVs[`size($NewCutCRVs)`]=VecArrayToCurveB($CRVSEG_A);
    }
    ////////////////
    // Place new
    print ("m_Or_e START:"+"\n");
    print $m_Or_e;
    print ("m_Or_e END"+"\n");



    if(`size($IndexO)`>0){
    $TempINA =IndexPairArrayFunc($IndexO);
    for($Icr=0;  $Icr<$sZ*2; $Icr++){
    $tempVi[$Icr]=  $AllKnowVecEnds[$MCurveIndex[$TempINA[$Icr]]];
    }
    }
    /////////////////
    // this is the curves that DO intersect!!
    $TempINAi =IndexPairArrayFunc($IndexR);
    for($Icr=0;  $Icr<$sZ*2; $Icr++){
    $tempVii[$Icr]=  $AllKnowVecEnds[$MCurveIndex[$TempINAi[$Icr]]];
    }

    $SizeSeg =`size($NewCutCRVs)`;

    if($NoCUT==1){

    for($iC=0; $iC<$SizeSeg; $iC++)
    {

    $VecTA=0;
    $VecTB=0;
    //END curve and onle the first end can snap to "" OTHER curves
    $DrawnVecEnds  =VecCurveEnds({$NewCutCRVs[$iC]});
    /////////////////////////////////////////////////////////////////////////
    //END CRV






    /////////////////
    $DrawnVecEnds  =VecCurveEnds({$NewCutCRVs[$iC]});
    //  so here these vectors Must be the filter index of ONLY OTHER CURVES
    // AND NOTHING ESLE for  if((($m_Or_e[$iC]==1)&&($iC==($SizeSeg-1))&&($CCi[0]==1)){
    if((($m_Or_e[$iC]==1)&&($iC==0))&&($CCi[1]==1)){
    if(`size($IndexO)`>0){
    $dist_A= ArrayDistancesVecTofloat($tempVi, $DrawnVecEnds [0]);
    }
    $dist_B = ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [1]);
    if(`size($IndexO)`>0){	$DA=SortNumbersIntIndex($dist_A); $VecTA=$TempINA[$DA[0]];}
    $DB=SortNumbersIntIndex($dist_B);
    if(`size($IndexO)`>0){
    $SA =$dist_A[$DA[0]];
    }else{$SA=200;}
    $SB =$dist_B[$DB[0]];
    if($DA[0]==$DB[0]){
    if($SA<$SB){
    $SB=200;
    }else{$SA=200;}

    }
    //$VecTA=$TempINA[$DA[0]];
    $VecTB=$TempINAi[$DB[0]];
    if($SA<$DistSSS){
    $CCi[0]=1;
    $SnapEnds[0]=$tempVi[$DA[0]];
    }else{$SnapEnds[0]=$DrawnVecEnds[0]; $CCi[0]=0;
    }
    if($SB<$DistSSS){
    $CCi[1]=1;
    $SnapEnds[1]=$tempVii[$DB[0]];
    }else{$SnapEnds[1]=$DrawnVecEnds[1]; 	$CCi[1]=0;
    }
    }
    ////////////very messy
    if((($m_Or_e[$iC]==1)&&($iC==($SizeSeg-1)))&&($CCi[0]==1)){

    $dist_A= ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [0]);
    if(`size($IndexO)`>0){
    $dist_B = ArrayDistancesVecTofloat($tempVi, $DrawnVecEnds [1]);
    }
    $DA=SortNumbersIntIndex($dist_A);
    $VecTA=$TempINAi[$DA[0]];

    if(`size($IndexO)`>0){
    $DB=SortNumbersIntIndex($dist_B);
    $VecTB=$TempINA[$DB[0]];
    }
    $SA =$dist_A[$DA[0]];
    if(`size($IndexO)`>0){
    $SB =$dist_B[$DB[0]];
    }else{$SB=200;}
    if($SA<$DistSSS){
    $CCi[0]=1;
    $SnapEnds[0]=$tempVi[$DA[0]];
    }else{$SnapEnds[0]=$DrawnVecEnds[0]; $CCi[0]=0;
    }
    if($SB<$DistSSS){
    $CCi[1]=1;
    $SnapEnds[1]=$tempVii[$DB[0]];
    }else{$SnapEnds[1]=$DrawnVecEnds[1]; $CCi[1]=0;
    }
    }

    /////////////////////////////////////////////////////////////////////////
    //Middle curve
    if($m_Or_e[$iC]==0){
    $TempINAi=IndexPairArrayFunc($IndexR);
    for($Icr=0;  $Icr<$sZ*2; $Icr++){
    $tempVii[$Icr]=  $AllKnowVecEnds[$MCurveIndex[$TempINAi[$Icr]]];
    }
    $DrawnVecEnds  =VecCurveEnds({$NewCutCRVs[$iC]});
    $dist_A = ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [0]);
    $dist_B = ArrayDistancesVecTofloat($tempVii, $DrawnVecEnds [1]);
    $DA=SortNumbersIntIndex($dist_A);
    $DB=SortNumbersIntIndex($dist_B);
    $SA =$dist_A[$DA[0]];
    $SB =$dist_B[$DB[0]];
    $VecTA=$TempINAi[$DA[0]];
    $VecTB=$TempINAi[$DB[0]];

    if($DA[0]==$DB[0]){
    if($SA<$SB){
    $SB=200;
    }else{$SA=200;}
    }
    if($SA<$DistSSS){
    $CCi[0]=1;
    $SnapEnds[0]=$tempVii[$DA[0]];
    }else{$SnapEnds[0]=$DrawnVecEnds[0]; $CCi[0]=0;
    }
    if($SB<$DistSSS){
    $CCi[1]=1;
    $SnapEnds[1]=$tempVii[$DB[0]];
    }else{$SnapEnds[1]=$DrawnVecEnds[1]; $CCi[1]=0;
    }
    }
    //if segment is an end curve and one vector snaps is that vector the start or end of crv?
    if(($SA<$DistSSS)||($SB<$DistSSS)){
    // this is saying if the fist segment is an end crv OR if the last Curve is an end Crv and One vector snaps
    if((($m_Or_e[$iC]==1)&&($iC==0))||(($m_Or_e[$iC]==1)&&( $iC==($SizeSeg-1)))){
    // this is saying if the fist segment is an end crv OR if the last Curve is an end Crv and One vector snaps
    //////////////////////////////////////////////////////// FIRST END SEG NOT MIDDLE
    if((($m_Or_e[$iC]==1)&&($iC==0))&&($CCi[1]==1)){
    if(!($Ocrv>$SizeSeg)){
    $CRVnum = CRVIndexPairF($VecTB);
    $ListDelete[`size($ListDelete)`]=$IndexR[$CRVnum];
    //$IndexR[$CRVnum]
    //This creates the MiddleSeg Vector global //
    $NewCRVc=CutExisting($sortedTG[$IndexR[$CRVnum]], $crvsFoundCut[$USortK[$IndexR[$CRVnum]]] );
    // CHANGE when if you sort it
    $ExistCRVn = $IndexR[$USortK[$IndexR[$CRVnum]]];
    $ENDsAB = IndexPairArrayFunc({$ExistCRVn});
    $ExistCRVVEC = $ENDsAB[0];
    IndexCRV_VEC({1,0},{$ExistCRVVEC,0}, {$SnapEnds[0],$MiddleSeg},$NewCRVc[0]);
    $ExistCRVVEC = $ENDsAB[1];
    IndexCRV_VEC({1,1},{$SizeVABpast[0],$ExistCRVVEC}, {$MiddleSeg,$MiddleSeg},$NewCRVc[1]);
    for($eachC in $NewCRVc){
    $AllNew[`size($AllNew)`]= $eachC;
    }
    $CollectCRV[`size($CollectCRV)`]= $crvsFoundCut[$USortK[$IndexR[$CRVnum]]];

    $Ocrv+=1;
    }
    }
    //////////////////////////////////////////////////////// FIRST END SEG NOT MIDDLE  END

    //////////////////////////////////////////////////////// LAST END SEG NOT MIDDLE
    if((($m_Or_e[$iC]==1)&&($iC==($SizeSeg-1)))&&($CCi[0]==1)){
    if(!($Ocrv>$SizeSeg)){
    $CRVnum = CRVIndexPairF($VecTA);
    $ListDelete[`size($ListDelete)`]=$IndexR[$CRVnum];
    //This creates the MiddleSeg Vector global //
    $NewCRVc=CutExisting($sortedTG[$IndexR[$CRVnum]], $crvsFoundCut[$USortK[$IndexR[$CRVnum]]] );
    // CHANGE when if you sort it
    $ExistCRVn = $IndexR[$USortK[$IndexR[$CRVnum]]];
    $ENDsAB = IndexPairArrayFunc({$ExistCRVn});
    $ExistCRVVEC = $ENDsAB[0];
    IndexCRV_VEC({1,0},{$ExistCRVVEC,0}, {$SnapEnds[0],$MiddleSeg},$NewCRVc[0]);
    $ExistCRVVEC = $ENDsAB[1];
    IndexCRV_VEC({1,1},{$SizeVABpast[0],$ExistCRVVEC}, {$MiddleSeg,$MiddleSeg},$NewCRVc[1]);
    for($eachC in $NewCRVc){
    $AllNew[`size($AllNew)`]= $eachC;
    }
    $CollectCRV[`size($CollectCRV)`]= $crvsFoundCut[$USortK[$IndexR[$CRVnum]]];
    $Ocrv+=1;
    }
    }
    //////////////////////////////////////////////////////// LAST END SEG NOT MIDDLE END
    }
    }
    //IF MIDDLE CRV
    if(($m_Or_e[$iC]==0)&&(($SA<$DistSSS)||($SB<$DistSSS))){
    if(!($Ocrv>$SizeSeg)){
    $CRVnum = CRVIndexPairF($VecTB);
    $ListDelete[`size($ListDelete)`]=$IndexR[$CRVnum];
    $NewCRVc=CutExisting($sortedTG[$IndexR[$CRVnum]], $crvsFoundCut[$USortK[$IndexR[$CRVnum]]] );
    // CHANGE when if you sort it
    $ExistCRVn = $IndexR[$USortK[$IndexR[$CRVnum]]];
    $ENDsAB = IndexPairArrayFunc({$ExistCRVn});
    $ExistCRVVEC = $ENDsAB[0];
    IndexCRV_VEC({1,0},{$ExistCRVVEC,0}, {$SnapEnds[0],$MiddleSeg},$NewCRVc[0]);
    $ExistCRVVEC = $ENDsAB[1];
    IndexCRV_VEC({1,1},{$SizeVABpast[0],$ExistCRVVEC}, {$MiddleSeg,$MiddleSeg},$NewCRVc[1]);
    for($eachC in $NewCRVc){
    $AllNew[`size($AllNew)`]= $eachC;
    }
    $CollectCRV[`size($CollectCRV)`]= $crvsFoundCut[$USortK[$IndexR[$CRVnum]]];
    $Ocrv+=1;
    }
    }
    if(($SA<$DistSSS)||($SB<$DistSSS)){
    $CRVPts  =VecCurveCvs($NewCutCRVs[$iC]);
    $TranlatedCRV= Matrix_Curve_Translation2D($DrawnVecEnds,$SnapEnds,$CRVPts);
    delete $NewCutCRVs[$iC];
    $AllNew[`size($AllNew)`]=VecArrayToCurveB($TranlatedCRV);
    IndexCRV_VEC( $CCi,{$MCurveIndex[$Ind3dV2P[$VecTA]],$MCurveIndex[$Ind3dV2P[$VecTB]]}, $SnapEnds,$AllNew[`size($AllNew)`-1]);
    }else{IndexCRV_VEC( $CCi,{$MCurveIndex[$Ind3dV2P[$VecTA]],$MCurveIndex[$Ind3dV2P[$VecTB]]},$SnapEnds,$NewCutCRVs[$iC]);
    }





    //end of if $SizeCuts	> 0
    }
    }




    }else if($SizeCuts==0){
    $DrawnVecEnds  =VecCurveEnds({$Sel[0]});
    $allNearVecEnds=$tempV;
    $dist_A = ArrayDistancesVecTofloat($allNearVecEnds, $DrawnVecEnds[0]);
    $dist_B = ArrayDistancesVecTofloat($allNearVecEnds, $DrawnVecEnds[1]);
    $DistSSSortA=SortNumbersIntIndex($dist_A);
    $DistSSSortB=SortNumbersIntIndex($dist_B);
    $SmallestDistA = $dist_A[$DistSSSortA[0]];
    $SmallestDistB = $dist_B[$DistSSSortB[0]];

    if($SmallestDistA<$DistSSS){
    $SnapEnds[0]=$allNearVecEnds[$DistSSSortA[0]];
    $CCi[0]=1;
    }else{$SnapEnds[0]=$DrawnVecEnds[0];
    $CCi[0]=0;
    }
    if($SmallestDistB<$DistSSS){
    $SnapEnds[1]=$allNearVecEnds[$DistSSSortB[0]];
    $CCi[1]=1;
    }else{$SnapEnds[1]=$DrawnVecEnds[1];
    $CCi[1]=0;
    }
    if(($SmallestDistA<$DistSSS)||($SmallestDistB<$DistSSS)){
    $CRVPts  =VecCurveCvs($Sel[0]);
    $TranlatedCRV= Matrix_Curve_Translation2D($DrawnVecEnds,$SnapEnds, $CRVPts);
    delete $Sel[0];
    $AllNew[`size($AllNew)`]=VecArrayToCurveB($TranlatedCRV);
    IndexCRV_VEC( $CCi,{$MCurveIndex[$Ind3dV2P[$DistSSSortA[0]]],$MCurveIndex[$Ind3dV2P[$DistSSSortB[0]]]}, $SnapEnds,$AllNew[`size($AllNew)`-1]);
    }else{
    if(($CCi[0]+$CCi[1])==0){
    IndexCRV_VEC( $CCi,{$MCurveIndex[$Ind3dV2P[$DistSSSortA[0]]],$MCurveIndex[$Ind3dV2P[$DistSSSortB[0]]]}, $SnapEnds,$Sel[0]);
    $AllNew[0] =$Sel[0];
    }
    }
    }
    }else{
    $DrawnVecEnds  =VecCurveEnds({$Sel[0]});
    IndexCRV_VEC({0,0},({0,0}),$DrawnVecEnds,$Sel[0]);
    $AllNew[0] =$Sel[0];
    }

    }else{
    $DrawnVecEnds  =VecCurveEnds({$Sel[0]});
    IndexCRV_VEC({0,0},({0,0}),$DrawnVecEnds,$Sel[0]);
    $AllNew[0] =$Sel[0];
    }



    //if($Ocrv>0){  delete $Sel[0];
    //}

    if(`size($ListDelete)`>0){
    //AppendOrdeleteCRV($ListDelete,0);
    }
    return $AllNew;
    }
    ///////////////////////////////////////////////////////////////////////////////END 2d

    */

}


/******************************************************************************
 * @procedure    calculateEllipse
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $x : float
 *   $y : float
 *   $a : float
 *   $b : float
 *   $angle : float
 *   $steps : float
 *
 * @returns      vector []
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] calculateEllipse(float $x, float $y, float $a, float $b, float $angle, float $steps)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $vi = 0;
    float $Pi = 3.1415926535;
    float $points[];
    float $beta = `deg_to_rad ($angle)`;
    float $sinbeta = sin($beta);
    float $cosbeta = cos($beta);
    float $i;
    float $alpha = $i * ( $Pi / 180.00);
    float $sinalpha = sin($alpha);
    float $cosalpha = cos($alpha);
    float $X = $x + ($a * $cosalpha * $cosbeta - $b * $sinalpha * $sinbeta);
    float $Y = $y + ($a * $cosalpha * $sinbeta + $b * $sinalpha * $cosbeta);
    float $valuesA[] = {$X, 0.0, $Y};
    string $curve = "curve -d 3";
    vector $VecH[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $curve = "curve -d 3";
    clear $VecH;
    $vi = 0;
    $Pi = 3.1415926535;

    $steps = 36;

    // Angle is given b$y Degree Value
    $beta = `deg_to_rad ($angle)`;
    $sinbeta = sin($beta);
    $cosbeta = cos($beta);

    for ( $i = 0; $i < 360; $i += 360.0/$steps)
    {
    $alpha = $i * ( $Pi / 180.00) ;
    $sinalpha = sin($alpha);
    $cosalpha = cos($alpha);

    $X = $x + ($a * $cosalpha * $cosbeta - $b * $sinalpha * $sinbeta);
    $Y = $y + ($a * $cosalpha * $sinbeta + $b * $sinalpha * $cosbeta);

    $valuesA = {$X, 0.0, $Y} ;
    $VecH[`size($VecH)`]= `FloatToVec $valuesA`;
    $curve += " -p "+$valuesA[0]+" "+$valuesA[1]+" "+$valuesA[2];



    }
    eval($curve);
    return $VecH;

}


/******************************************************************************
 * @procedure    TANGENTSS
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      vector []
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector [] TANGENTSS()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $ArrayIndexTracki[] = CreateIntIndex(`size($circles)`);
    int $IndexTangentPairsTrack[];
    int $CirA;
    int $CirB;
    int $indexNumberZ[];
    int $IndTanPairTrackExpand[] = CreateIntIndexExpand($IndexTangentPairsTrack, 2);
    float $normalAxis[] = CircNormal($circles[0]);
    float $ObjsCircles[] = CirclesRadiiPos($circles, $PosABs);
    float $R1 = $ObjsCircles[$CirA];
    float $R2 = $ObjsCircles[$CirB];
    float $FloatDirXn[] = DirectionF($PosABs[$CirA], $PosABs[$CirB]);
    float $Rn1 = (1.0/(`sqrt $R1`)) + (1.0/(`sqrt $R2` ));
    float $Rn = 1.0/$Rn1;
    float $R = `pow $Rn 2`;
    float $xc = `sqrt (4*$R1*$R)`;
    float $yc = `sqrt (4*$R2*$R)`;
    float $CurveL = $xc+$yc;
    float $pi = 3.1415926535;
    float $r1 = $R1;
    float $r2 = $R2;
    float $P = distance2Pts($PosABs[$CirA], $PosABs[$CirB]);
    float $DiCircleInBetween = `abs ($P -($R1 + $R2))`;
    float $RadiCircleInBetween = $DiCircleInBetween/2;
    float $DisCircBetweenFromR1 = $R1+$RadiCircleInBetween;
    float $MultDirMLine[] = multiplyFloat($R2-1.0,  $FloatDirXn);
    float $AddMultMLine[] = AddFloats($PosABs[$CirA], $MultDirMLine);
    float $MultDirMLinei[] = multiplyFloat($RadiCircleInBetween,  $FloatDirXn);
    float $AddMultMLinei[] = AddFloats($AddMultMLine, $MultDirMLinei);
    float $MultDirM[] = multiplyFloat($DisCircBetweenFromR1,  $FloatDirXn);
    float $AddMultM[] = AddFloats($PosABs[$CirA], $MultDirM);
    float $ts = acos ( (`abs ($r1 - $r2)`) /$P);
    float $tsD = (`rad_to_deg $ts`);
    float $tsDA = (`rad_to_deg $ts`)*1;
    float $tsDB = (`rad_to_deg $ts`)*-1;
    float $tsDAR = ( $ts)*1;
    float $tsDBR = ( $ts)*-1;
    float $rotatsA[] = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $r1, $normalAxis, $tsDAR);
    float $rotatsB[] = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $r1, $normalAxis, $tsDBR);
    float $rotatsC[] = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $r2, $normalAxis, $tsDBR);
    float $rotatsD[] = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $r2, $normalAxis, $tsDAR);
    float $rotatsAi[] = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $r1-1.0, $normalAxis, $tsDAR);
    float $rotatsBi[] = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $r1-1.0, $normalAxis, $tsDBR);
    float $rotatsCi[] = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $r2-1.0, $normalAxis, $tsDBR);
    float $rotatsDi[] = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $r2-1.0, $normalAxis, $tsDAR);
    float $mid1[] = MidPoint($rotatsA, $rotatsD);
    float $mid2[] = MidPoint($rotatsB, $rotatsC);
    float $midAD3[] = MidPoint($rotatsA, $mid1);
    float $midAD4[] = MidPoint($rotatsD, $mid1);
    float $midBC3[] = MidPoint($rotatsB, $mid2);
    float $midBC4[] = MidPoint($rotatsC, $mid2);
    float $FloatDirCentMidZ[] = DirectionF($PosABs[$CirA], $midAD3);
    float $MultDirMidzCirc[] = multiplyFloat($r1-1.0, $FloatDirCentMidZ);
    float $FAddMULTDcirc[] = AddFloats($MultDirMidzCirc, $PosABs[$CirA]);
    float $FloatDirCentMidZi[] = DirectionF($PosABs[$CirA], $midBC3);
    float $FloatDirCentMidZii[] = DirectionF($PosABs[$CirB], $midAD4);
    float $FloatDirCentMidZiii[] = DirectionF($PosABs[$CirB], $midBC4);
    string $circles[] = `ls -sl`;
    string $circlesShape[];
    string $stringIndexTracki[] = IntArrayToStringArray($ArrayIndexTracki);
    string $itemA[] = $circles;
    string $itemBackUp[] = $itemA;
    string $TwoItemsZ[];
    string $LocString[];
    string $itemEach[] = { $itemA[0] };
    string $circlesM = Circles_Direction($AddMultM,$normalAxis, $RadiCircleInBetween);
    string $CirTemp[] = `ls -sl`;
    vector $TangZ[];
    vector $TangMidZ[];
    vector $directionABs[];
    vector $PosABs[];
    vector $CircVec[] = PointArrayT($circles);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════




    $circles = `ls -sl`;
    clear $circlesShape;
    clear $TangZ;
    clear $TangMidZ;
    for ($eachCir in $circles){
    $circlesShape[`size($circlesShape)`]  = stringArrayToString( `listRelatives $eachCir` , " ");
    }
    print $circlesShape;
    $normalAxis = CircNormal($circles[0]);

    ResetTransEachSL;
    clear $PosABs;
    $CircVec = PointArrayT($circles);
    $ObjsCircles = CirclesRadiiPos($circles, $PosABs);
    print $ObjsCircles;


    //now   create proc which point is furthest from $CircVec[1]..... everytime!

    $ArrayIndexTracki = CreateIntIndex(`size($circles)`);
    $stringIndexTracki = IntArrayToStringArray($ArrayIndexTracki);
    clear $IndexTangentPairsTrack;




    $itemA = $circles;
    $itemBackUp = $itemA;


    //ThreeIndex vec tracks circle index
    //vector $ThreeIndex

    clear $LocString;

    for($each in $itemBackUp){

    //isolate one from list remove from list
    //itemA will be reduced to zero

    $itemEach = { $itemA[0] };
    $diff = stringArrayRemoveExact($itemEach, $itemA);

    for($eachOther in $diff){

    //playButtonStepForward;
    // $eachOther $itemEach;


    $TwoItemsZ  = {$eachOther, $itemEach[0]};
    $indexNumberZ= stringArrayGmatchArrayIndex($TwoItemsZ, $circles);

    $CirA = $indexNumberZ[0];
    $CirB = $indexNumberZ[1];
    // $indexNumberZ[0] =0;
    //  $indexNumberZ[1] =1;
    // $CirA = 0;
    // $CirB = 1;

    $R1 = $ObjsCircles[$CirA];
    $R2 = $ObjsCircles[$CirB];
    if($R1<$R2){$CirA = $indexNumberZ[1]; $CirB = $indexNumberZ[0];
    $R1=$ObjsCircles[$CirA];
    $R2=$ObjsCircles[$CirB];}

    ////////
    playButtonStepForward;
    select -r $circles[$CirA] $circles[$CirB];
    ///////

    $FloatDirXn = DirectionF($PosABs[$CirA], $PosABs[$CirB]);
    $R1 = $ObjsCircles[$CirA];
    $R2 = $ObjsCircles[$CirB];
    //RotMultLenToDirAddToPoint(float $PosA[], float $PosB[], float $Length, float $DirNormAx[], float $Radian)
    $R1 = $R1+1.0;
    $R2 =$R2+1.0;
    $Rn1 = (1.0/(`sqrt $R1`)) + (1.0/(`sqrt $R2` ));
    $Rn = 1.0/$Rn1;
    $R = `pow $Rn 2`;
    $xc = `sqrt (4*$R1*$R)`;
    $yc = `sqrt (4*$R2*$R)`;
    $CurveL = $xc+$yc;
    $pi = 3.1415926535;

    $r1 = $R1;
    $r2 = $R2;

    // P is the distance between 2 circles
    $P = distance2Pts($PosABs[$CirA], $PosABs[$CirB]);
    $FloatDirXn = DirectionF($PosABs[$CirA], $PosABs[$CirB]);

    $DiCircleInBetween = `abs ($P -($R1 + $R2))`;
    $RadiCircleInBetween = $DiCircleInBetween/2;
    $DisCircBetweenFromR1 = $R1+$RadiCircleInBetween ;
    //mult Direction Circ1 to Circ 2 by distance DisCircBetweenFromR1
    //add to Pos Circ R1

    //Not Sure what this is/////////////////////////////////
    $MultDirMLine = multiplyFloat($R2-1.0,  $FloatDirXn);
    $AddMultMLine = AddFloats($PosABs[$CirA], $MultDirMLine);
    $MultDirMLinei = multiplyFloat($RadiCircleInBetween,  $FloatDirXn);
    $AddMultMLinei = AddFloats($AddMultMLine, $MultDirMLinei);
    curve2points($AddMultMLine, $AddMultMLinei);
    ////////////////////////////////////////////////////////


    $MultDirM = multiplyFloat($DisCircBetweenFromR1,  $FloatDirXn);
    $AddMultM = AddFloats($PosABs[$CirA], $MultDirM);
    spaceLocator -p 0 0 0;
    MoveObject2($AddMultM);

    //#### MID POINT BETWEEN Circles Edges $AddMultM

    $circlesM = Circles_Direction($AddMultM,$normalAxis, $RadiCircleInBetween);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);

    $ts = acos ( (`abs ($r1 - $r2)`) /$P);
    $tsD = (`rad_to_deg $ts`);
    $tsDA = (`rad_to_deg $ts`)*1;
    $tsDB = (`rad_to_deg $ts`)*-1;
    $tsDAR = ( $ts)*1;
    $tsDBR = ( $ts)*-1;

    //The first argument represents a point, the second an axis and the third an angle in radians
    //the normal $directionABs[2]
    //RotMultLenToDirAddToPoint(float $PosA[], float $PosB[], float $Length, float $DirNormAx[], float $Radian)


    $rotatsA = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $r1, $normalAxis, $tsDAR);
    $rotatsB = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $r1, $normalAxis, $tsDBR);
    $rotatsC = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $r2, $normalAxis, $tsDBR);
    $rotatsD = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $r2, $normalAxis, $tsDAR);


    $rotatsAi = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $r1-1.0, $normalAxis, $tsDAR);
    $rotatsBi = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $r1-1.0, $normalAxis, $tsDBR);
    $rotatsCi = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $r2-1.0, $normalAxis, $tsDBR);
    $rotatsDi = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $r2-1.0, $normalAxis, $tsDAR);

    //select -r $circles[$CirA] $circles[$CirB];

    $IndexTangentPairsTrack[`size($IndexTangentPairsTrack)`] = $CirA;
    $IndexTangentPairsTrack[`size($IndexTangentPairsTrack)`] = $CirB;



    $LocString[`size( $LocString)`]= Loc($rotatsA);
    $LocString[`size( $LocString)`]= Loc($rotatsB);

    $LocString[`size( $LocString)`]= Loc($rotatsD);
    $LocString[`size( $LocString)`]= Loc($rotatsC);

    $TangZ[`size($TangZ)`]= FloatToVec($rotatsA);
    $TangZ[`size($TangZ)`]= FloatToVec($rotatsB);
    $TangZ[`size($TangZ)`]= FloatToVec($rotatsD);
    $TangZ[`size($TangZ)`]= FloatToVec($rotatsC);

    spaceLocator -p 0 0 0;
    MoveObject2($rotatsAi);
    spaceLocator -p 0 0 0;
    MoveObject2($rotatsBi);


    spaceLocator -p 0 0 0;
    MoveObject2($rotatsDi);
    spaceLocator -p 0 0 0;
    MoveObject2($rotatsCi);

    curve2points($rotatsA, $rotatsAi);
    curve2points($rotatsB, $rotatsBi);
    curve2points($rotatsC, $rotatsCi);
    curve2points($rotatsD, $rotatsDi);



    $mid1 = MidPoint($rotatsA, $rotatsD);
    $mid2 = MidPoint($rotatsB, $rotatsC);

    Loc $mid1;
    Loc $mid2;
    curve2points($AddMultM, $mid1);
    curve2points($AddMultM, $mid2);

    $midAD3 = MidPoint($rotatsA, $mid1);
    $midAD4 = MidPoint($rotatsD, $mid1);

    $midBC3 = MidPoint($rotatsB, $mid2);
    $midBC4 = MidPoint($rotatsC, $mid2);

    $FloatDirCentMidZ = DirectionF($PosABs[$CirA], $midAD3);

    $MultDirMidzCirc = multiplyFloat($r1-1.0, $FloatDirCentMidZ);
    $FAddMULTDcirc = AddFloats($MultDirMidzCirc, $PosABs[$CirA]);
    Loc $FAddMULTDcirc;
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);

    curve2points($FAddMULTDcirc, $midAD3);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);

    $FloatDirCentMidZi = DirectionF($PosABs[$CirA], $midBC3);

    $MultDirMidzCirc = multiplyFloat($r1-1.0, $FloatDirCentMidZi);
    $FAddMULTDcirc = AddFloats($MultDirMidzCirc, $PosABs[$CirA]);
    Loc $FAddMULTDcirc;
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);

    curve2points($FAddMULTDcirc, $midBC3);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);

    $FloatDirCentMidZii = DirectionF($PosABs[$CirB], $midAD4);

    $MultDirMidzCirc = multiplyFloat($r2-1.0, $FloatDirCentMidZii);
    $FAddMULTDcirc = AddFloats($MultDirMidzCirc, $PosABs[$CirB]);
    Loc $FAddMULTDcirc;
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);

    curve2points($FAddMULTDcirc, $midAD4);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);

    $FloatDirCentMidZiii = DirectionF($PosABs[$CirB], $midBC4);

    $MultDirMidzCirc = multiplyFloat($r2-1.0, $FloatDirCentMidZiii);
    $FAddMULTDcirc = AddFloats($MultDirMidzCirc, $PosABs[$CirB]);
    Loc $FAddMULTDcirc;
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);

    curve2points($FAddMULTDcirc, $midBC4);
    $CirTemp = `ls -sl`;
    SetItemColorString ($CirTemp[0], 12);

    //ClosestPoint2Line($FloatDirCentMidZiii, $PosABs[$CirB], $PosABs[$CirA]);
    //ClosestPoint2Line($FloatDirCentMidZii, $PosABs[$CirB], $PosABs[$CirA]);

    Loc $midAD3;
    Loc $midAD4;
    Loc $midBC3;
    Loc $midBC4;

    $TangMidZ[`size($TangMidZ)`]= FloatToVec($mid1);
    $TangMidZ[`size($TangMidZ)`]= FloatToVec($mid2);

    curve2points($rotatsA, $rotatsD);
    curve2points($rotatsB,$rotatsC);

    playButtonStepForward;
    }

    $itemA = $diff;

    }

    select -r $LocString;
    //$TangZ

    $IndTanPairTrackExpand = CreateIntIndexExpand($IndexTangentPairsTrack, 2);

    //return $TangZ;
    //
}


/******************************************************************************
 * @procedure    CreatePairIntIndex
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $ArraySize : int
 *
 * @returns      int []
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] CreatePairIntIndex(int $ArraySize)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $iNdexi = 0;
    int $iNdex = 0;
    int $store;
    int $IntArrayInex[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $iNdexi = 0;
    $iNdex = 0;
    while($iNdex < $ArraySize){

    if($iNdexi == 0){
    $IntArrayInex[$iNdex] = $iNdex;
    $store =$iNdex;
    }
    if($iNdexi == 1){ $iNdexi = -1;
    $IntArrayInex[$iNdex] = $store;
    }

    $iNdexi++;
    $iNdex++;
    }
    return $IntArrayInex;

}


/******************************************************************************
 * @procedure    CreateIntIndexExpand
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $IndexArray : int[]
 *   $ExpandSize : int
 *
 * @returns      int []
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int [] CreateIntIndexExpand(int $IndexArray[], int $ExpandSize)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $IntArrayInex[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ($eachNumber in $IndexArray){
    for ($i=0;$i<$ExpandSize; $i++){
    $IntArrayInex[`size($IntArrayInex)`] = $eachNumber;
    }
    }
    return $IntArrayInex;

}


/******************************************************************************
 * @procedure    attachCurveTangent
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $doAttach : int
 *
 * @returns      string
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string attachCurveTangent(int $doAttach)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCurves = size($curvesList);
    int $degree = eval("getAttr " + $curvesList[0] + ".degree");
    int $numSpans = eval("getAttr " + $curvesList[0] + ".spans");
    int $numCVs1 = $degree + $numSpans;
    int $numCVs2 = $degree + $numSpans;
    int $lastCV = $numCVs1 - 1;
    float $cvLastCurve1[] = `getAttr ($curvesList[0] + ".cp[" + $lastCV + "]")`;
    float $cv2ndLastCurve1[] = `getAttr ($curvesList[0] + ".cp[" + $lastCV + "]")`;
    float $cvOneCurve2[] = `getAttr ($curvesList[1] + ".cp[0]")`;
    float $cvTwoCurve2[] = `getAttr ($curvesList[1] + ".cp[1]")`;
    string $curvesList[] = `filterExpand -ex true -sm $gSelectNurbsCurvesBit`;
    string $resultCurve = eval("curve -p " + $cvLastCurve1[0] + " " + $cvLastCurve1[1] + " " + $cvLastCurve1[2] + " -p " + $cvNew1[0] + " " + $cvNew1[1] + " " + $cvNew1[2] + " -p " + $cvNew2[0] + " " + $cvNew2[1] + " " + $cvNew2[2] + " -p " + $cvOneCurve2[0] + " " + $cvOneCurve2[1] + " " + $cvOneCurve2[2] + " -k 0 -k 0 -k 0 -k 1 -k 1 -k 1");
    string $attachedCurve[] = eval("attachCurve -ch 0 -rpo 0 -kmk 1 " + $curvesList[0] + " " + $resultCurve);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    global int $gSelectNurbsCurvesBit;
    $curvesList = `filterExpand -ex true -sm $gSelectNurbsCurvesBit`;

    $numCurves = size($curvesList);
    if ( $numCurves < 2 )
    {
    error((uiRes("m_attachCurveTangent.kErrorSelectTwoCurves")) );
    return "";
    }

    // get the last 2 cvs on the first curve and the first 2 cvs on the
    // second curve
    //
    $degree = eval("getAttr " + $curvesList[0] + ".degree");
    $numSpans = eval("getAttr " + $curvesList[0] + ".spans");
    $numCVs1 = $degree + $numSpans;
    $degree = eval("getAttr " + $curvesList[1] + ".degree");
    $numSpans = eval("getAttr " + $curvesList[1] + ".spans");
    $numCVs2 = $degree + $numSpans;
    if ( $numCVs1 < 2 || $numCVs2 < 2 )
    {
    error((uiRes("m_attachCurveTangent.kErrorTooFewCVs")) );
    return "";
    }

    $lastCV = $numCVs1 - 1;
    $cvLastCurve1 = `getAttr ($curvesList[0] + ".cp[" + $lastCV + "]")`;
    $lastCV--;
    $cv2ndLastCurve1 = `getAttr ($curvesList[0] + ".cp[" + $lastCV + "]")`;
    $cvOneCurve2 = `getAttr ($curvesList[1] + ".cp[0]")`;
    $cvTwoCurve2 = `getAttr ($curvesList[1] + ".cp[1]")`;

    // this is the vector between the two cvs on the first curve
    //
    $vector[0] = $cvLastCurve1[0] - $cv2ndLastCurve1[0];
    $vector[1] = $cvLastCurve1[1] - $cv2ndLastCurve1[1];
    $vector[2] = $cvLastCurve1[2] - $cv2ndLastCurve1[2];

    // calculate a cv on the line between the two end cvs so that it will
    // be tangent
    //
    $cvNew1[0] = $cvLastCurve1[0] + $vector[0];
    $cvNew1[1] = $cvLastCurve1[1] + $vector[1];
    $cvNew1[2] = $cvLastCurve1[2] + $vector[2];

    // this is the vector between the two cvs on the second curve
    //
    $vector[0] = $cvOneCurve2[0] - $cvTwoCurve2[0];
    $vector[1] = $cvOneCurve2[1] - $cvTwoCurve2[1];
    $vector[2] = $cvOneCurve2[2] - $cvTwoCurve2[2];

    // calculate a cv on the line between the two start cvs so that it will
    // be tangent
    //
    $cvNew2[0] = $cvOneCurve2[0] + $vector[0];
    $cvNew2[1] = $cvOneCurve2[1] + $vector[1];
    $cvNew2[2] = $cvOneCurve2[2] + $vector[2];

    // create the degree 3 curve
    //
    $resultCurve = eval("curve -p " + $cvLastCurve1[0] + " " + $cvLastCurve1[1] + " " + $cvLastCurve1[2] + " -p " + $cvNew1[0] + " " + $cvNew1[1] + " " + $cvNew1[2] + " -p " + $cvNew2[0] + " " + $cvNew2[1] + " " + $cvNew2[2] + " -p " + $cvOneCurve2[0] + " " + $cvOneCurve2[1] + " " + $cvOneCurve2[2] + " -k 0 -k 0 -k 0 -k 1 -k 1 -k 1");

    // attach all 3 curves if required
    //
    if ( $doAttach == 1 )
    {
    // attach curve1 to the new curve
    //
    $attachedCurve = eval("attachCurve -ch 0 -rpo 0 -kmk 1 " + $curvesList[0] + " " + $resultCurve);

    // the tangent curve is no longer needed
    //
    delete $resultCurve;

    // attach curve2 to the previously attached curves
    //
    $attachedCurve = eval("attachCurve -ch 0 -rpo 1 -kmk 1 " + $attachedCurve[0] + " " + $curvesList[1]);
    $resultCurve = $attachedCurve[0];
    }

    select -r $resultCurve;
    return $resultCurve;

}


/******************************************************************************
 * @procedure    TotalArcLength
 * @category     utility
 * @layer        utility (General)
 *
 *
 * @returns      float
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float TotalArcLength()
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $ArcLengths = 0.0;
    string $Objs[] = `ls -sl`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Objs = `ls -sl`;
    $ArcLengths = 0.0;

    for($each in $Objs){
    $ArcLengths += `arclen $each`;
    }
    return $ArcLengths;

}


/******************************************************************************
 * @procedure    PointArray
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $ObjectList : string[]
 *
 * @returns      vector[]
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] PointArray(string $ObjectList[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $XiV = 0;
    float $pointAZ1[];
    vector $VecArray[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $XiV = 0;
    for ($each in $ObjectList){
    if (catch($pointAZ1 = `pointPosition -w ($each)`)){
    $pointAZ1 = `xform -q -ws - rp ($each)`;
    }
    $VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
    $XiV++;
    }
    return $VecArray;

}


/******************************************************************************
 * @procedure    ct_extrude
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $crv : string
 *   $radius : float
 *   $min : float
 *   $max : float
 *   $spans : int
 *   $degree : int
 *   $rotate : float
 *
 * @returns      string[]
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] ct_extrude(string $crv, float $radius, float $min, float $max, int $spans, int $degree, float $rotate)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $periodic = `getAttr ($crv + ".form")`;
    float $pos[] = `pointOnCurve -pr .00001 -position $crv`;
    float $tan[] = `pointOnCurve -pr .00001 -tangent $crv`;
    string $crvGrp = `group -n $profile[0]`;
    string $tc[] = `tangentConstraint -weight 1 -aimVector 0 1 0 -upVector 0 1 0 $crv $crvGrp`;
    string $form;
    string $tube[] = `eval ( "extrude -fixedPath true -range true -ucp true -upn " + $form + " -et 2 " + $profile[0] + " " + $crv )`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    // get start pos and tan of curve in world space
    $pos = `pointOnCurve -pr .00001 -position $crv`;
    $tan = `pointOnCurve -pr .00001 -tangent $crv`;
    $periodic = `getAttr ($crv + ".form")`;

    // make circle at start matching curve tangent
    -nr 0 1 0
    -r $radius
    -degree $degree
    -sections $spans`;

    // put curve under new transform node
    $crvGrp = `group -n $profile[0]`;
    $crvGrp = `rename $crvGrp "tubeConstruction#"`;

    // move circle to curve start point
    xform -cp $profile[0];

    // rotate circle into position once before extruding
    $tc = `tangentConstraint -weight 1 -aimVector 0 1 0 -upVector 0 1 0 $crv $crvGrp`;

    // get form (open/periodic)
    if (($periodic == 0) || ($min != 0) || ($max != 1))
    $form = "true";
    else
    $form = "false";

    // extrude spiral
    $tube = `eval ( "extrude -fixedPath true -range true -ucp true -upn " + $form + " -et 2 " + $profile[0] + " " + $crv )`;

    // delete tangentConstraint
    delete $tc[0];

    // rotate circle into position
    setAttr ($profile[0] + ".ry") $rotate;

    // return	(0) profile transform node
    //		(1) make nurbs circle node
    //		(2) tube transform node
    //		(3) extrude node
    //		(4) curve form (open/periodic)
    //		(5) curve group transform node
    return {$profile[0], $profile[1], $tube[0], $tube[1], string($periodic), $crvGrp};

}


/******************************************************************************
 * @procedure    GetRotationFromDirection
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $P : float[]
 *   $T : float[]
 *   $N : float[]
 *
 * @returns      float []
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float [] GetRotationFromDirection(float $P[], float $T[], float $N[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $rotation[] = `getAttr ($locator[0]+".rotate")`;
    string $locator[];
    string $AllLocatorZi[];
    vector $tan;
    vector $norm;
    vector $bi;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════



    matrix $m[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;

    $p = $P;
    $t = $T;
    $n = $N;

    $p[0] = linearToInternal( $p[0] );
    $p[1] = linearToInternal( $p[1] );
    $p[2] = linearToInternal( $p[2] );

    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
    $norm = `unit << $n[0], $n[1], $n[2] >>`;

    // Calculate the binormal.
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
    << ($norm.x), ($norm.y), ($norm.z) >>`;

    $bi = `unit $bi`;

    // Create a matrix, using normal for the X axis and
    // tangent for the Z axis.
    $m = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
    ($bi.x),   ($bi.y),   ($bi.z),   0.0;     // Y axis
    ($tan.x),  ($tan.y),  ($tan.z),  0.0;     // Z axis
    $p[0],     $p[1],     $p[2],     1.0 >>;  // Position

    // Create a locator and assign its world-space matrix.
    $locator = `spaceLocator`;
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $locator[0];


    $rotation = `getAttr ($locator[0]+".rotate")`;

    return $rotation;


}


/******************************************************************************
 * @procedure    screenSpaceGetMatrix
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $attr : string
 *
 * @returns      matrix
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc matrix screenSpaceGetMatrix(string $attr)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $v[] = `getAttr $attr`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $v = `getAttr $attr`;
    matrix $mat[4][4]=<<$v[0], $v[1], $v[2], $v[3];
    $v[4], $v[5], $v[6], $v[7];
    $v[8], $v[9], $v[10], $v[11];
    $v[12], $v[13], $v[14], $v[15]>>;
    return $mat;

}


/******************************************************************************
 * @procedure    screenSpaceVecMult
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $v : vector
 *   $m : matrix
 *
 * @returns      vector
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector screenSpaceVecMult(vector $v, matrix $m)
{

    matrix $v1[1][4]=<<$v.x, $v.y, $v.z, 1>>;
    matrix $v2[1][4]=$v1*$m;
    return <<$v2[0][0], $v2[0][1],  $v2[0][2]>>;

}


/******************************************************************************
 * @procedure    angle_to_internal
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $angle : float
 *   $anglePoint : float
 *
 * @returns      float
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float angle_to_internal(float $angle, float $anglePoint)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    string $pref = `currentUnit -q -a`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $pref = `currentUnit -q -a`;
    if ( "deg" == $pref )
    {
    $angle = $angle * $anglePoint;
    }

    return $angle;

}


/******************************************************************************
 * @procedure    linear_to_internal
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $linear : float
 *
 * @returns      float
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float linear_to_internal(float $linear)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $factor = 1.0;
    string $pref = `currentUnit -q -l`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $factor = 1.0;
    $pref = `currentUnit -q -l`;
    if ( "mm" == $pref ) $factor = 0.1;
    if ( "m" == $pref ) $factor = 100.0;
    if ( "inch" == $pref ) $factor = 2.54;
    if ( "ft" == $pref ) $factor = 30.48;
    if ( "yard" == $pref ) $factor = 91.44;

    return ( $linear * $factor );

}


/******************************************************************************
 * @procedure    linear_to_ui
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $linear : float
 *
 * @returns      float
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float linear_to_ui(float $linear)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $factor = 1.0;
    string $pref = `currentUnit -q -l`;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $factor = 1.0;
    $pref = `currentUnit -q -l`;
    if ( "mm" == $pref ) $factor = 10.0;
    if ( "m" == $pref ) $factor = 0.01;
    if ( "inch" == $pref ) $factor = 0.3937007874;
    if ( "ft" == $pref ) $factor = 0.03280839895;
    if ( "yard" == $pref ) $factor = 0.01093613298;

    return ( $linear * $factor );

}


/******************************************************************************
 * @procedure    be_plot_locators
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $curve : string
 *
 * @returns      string[]
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
global proc string[] be_plot_locators(string $curve)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    float $u;
    float $span = 0.1;
    float $maxU = `getAttr ( $curve + ".maxValue" )`;
    string $locator[];
    string $AllLocatorZi[];
    vector $tan;
    vector $norm;
    vector $bi;

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    matrix $m[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;

    $span = 0.1;
    $maxU = `getAttr ( $curve + ".maxValue" )`;
    for ( $u = 0.0; $u <= $maxU; $u += $span )
    {
    // Query the position,
    //tangent and normal.
    //
    //-p: -position  -position(-p)
    //nn: -normalizedNormal
    //nt: -normalizedTangent


    $p = `pointOnCurve -ch off -pr $u -p $curve`;
    //$t is just a direction....
    $t = `pointOnCurve -ch off -pr $u -nt $curve`;
    $n = `pointOnCurve -ch off -pr $u -nn $curve`;

    // Translational coordinates in a Maya matrix are always represented
    // in Maya's internal units. Convert position to (cm) units.
    $p[0] = linearToInternal( $p[0] );
    $p[1] = linearToInternal( $p[1] );
    $p[2] = linearToInternal( $p[2] );

    // Maya promises normalized tangent and normal,
    // but they really aren't.
    //
    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
    $norm = `unit << $n[0], $n[1], $n[2] >>`;

    // Calculate the binormal.
    //
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
    << ($norm.x), ($norm.y), ($norm.z) >>`;

    // Normalize our vector.
    //
    $bi = `unit $bi`;

    // Create a matrix, using normal for the X axis and
    // tangent for the Z axis.
    //
    $m = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
    ($bi.x),   ($bi.y),   ($bi.z),   0.0;     // Y axis
    ($tan.x),  ($tan.y),  ($tan.z),  0.0;     // Z axis
    $p[0],     $p[1],     $p[2],     1.0 >>;  // Position

    // Create a locator and assign its world-space matrix.
    //curve -d 1 -p -0.0870275 0 0.00556599 -p 0 0 5 -k 0 -k 4.995192 ;
    $locator[0] = `curve -d 1 -p -0.0870275 0 0.00556599 -p 0 0 5 -k 0 -k 4.995192`;
    //$locator = `spaceLocator`;
    appendAll($AllLocatorZi, $locator);


    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $locator[0];


    }
    return $AllLocatorZi;

}


/******************************************************************************
 * @procedure    NumberOFSurf
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Zeachboundry : string
 *
 * @returns      int
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int NumberOFSurf(string $Zeachboundry)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $XnumOFcurveConnections;
    int $historyShapes = `size($ZfirstcurveConnectionsz)`;
    string $ZfirstcurveRelatives[];
    string $ZfirstcurveConnectionsz[];
    string $Zfirstcurveshapes[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $ZfirstcurveRelatives = `listRelatives -shapes $Zeachboundry`;
    $ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
    $historyShapes = `size($ZfirstcurveConnectionsz)`;
    if ($historyShapes > 0){
    $ZfirstcurveshapesA = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;
    $ZfirstcurveshapesB = `listConnections -shapes 1  -type mesh $ZfirstcurveConnectionsz`;
    $XnumOFcurveConnections = (`size($ZfirstcurveshapesA)`) + (`size($ZfirstcurveshapesB)`) ;
    }else{ $XnumOFcurveConnections = 0;}

    return $XnumOFcurveConnections;

}


/******************************************************************************
 * @procedure    ForAllCurvesFindSurfaceEdges
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $newallCurves : string[]
 *
 * @returns      string[]
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc string[] ForAllCurvesFindSurfaceEdges(string $newallCurves[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $Zfirstcurveshapesi = `NumberOFSurf($Zeachboundry)`;
    string $ZnewfoundEdge[];
    string $ZselectedCurve[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    for ( $Zeachboundry in $newallCurves ) {
    $ZselectedCurve[0] = $Zeachboundry;
    $Zfirstcurveshapesi = `NumberOFSurf($Zeachboundry)`;
    if ($Zfirstcurveshapesi == 1){
    appendStringArray($ZnewfoundEdge, $ZselectedCurve, 1);
    }
    if ($Zfirstcurveshapesi == 0){
    appendStringArray($ZnewfoundEdge,  $ZselectedCurve, 1);
    }
    }
    return $ZnewfoundEdge;

}


/******************************************************************************
 * @procedure    GetVectorArrayBetweenCurveEnds
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $CurveItem : string[]
 *
 * @returns      vector[]
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc vector[] GetVectorArrayBetweenCurveEnds(string $CurveItem[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    int $numCVrealNum = ( $numCVs -1 );
    float $EACHCVposAZ[];
    float $eachCVpos[];
    string $CurveSelection[];
    vector $CurveA = << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    vector $CurveB = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    vector $CurveAB[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
    $numCVrealNum = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
    $EACHCVposAZ = 0; string $MakeXBetweenB[];
    for ($eachZA in $CurveSelection) {
    $eachCVpos = `pointPosition -w ( $eachZA   )`;
    $numIntZB = $numIntZB + 1;
    if ( $numIntZB == 1 ){$EACHCVposAZ = $eachCVpos;}
    if ( $numIntZB == 2 ){$EACHCVposBZ = $eachCVpos;}
    }
    $CurveA = << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
    $CurveB = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
    $CurveAB = $CurveA; $CurveAB[1] = $CurveB;
    return $CurveAB;

}


/******************************************************************************
 * @procedure    FindifCurveEndsMeet
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $CurveA1 : vector[]
 *   $CurveA2 : vector[]
 *
 * @returns      int
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int FindifCurveEndsMeet(vector $CurveA1[], vector $CurveA2[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $CurveMeetsTrue = 0;
    int $indexN = 0;
    int $indexN2 = 0;
    int $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    int $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);
    float $firstC[];
    float $SecondCA[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $CurveMeetsTrue = 0;
    $indexN = 0;
    $indexN2 = 0;
    while ($indexN < 2){
    $firstC = $CurveA1[$indexN];
    $SecondC = $CurveA2[0];
    $SecondCA = $CurveA2[1];
    $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);
    if (($NumberE == 3)||($NumberE2 == 3)){$CurveMeetsTrue = $CurveMeetsTrue +1; }
    if ($indexN==1){$indexN1 = 1;}
    $indexN++;
    }
    return $CurveMeetsTrue;

}


/******************************************************************************
 * @procedure    ValueOfCurveSurfInterConnections
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $Zeachboundry : string[]
 *
 * @returns      int
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int ValueOfCurveSurfInterConnections(string $Zeachboundry[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $NumberofConnectionZ = 0;
    int $historyShapes = `size($ZfirstcurveConnectionsz)`;
    int $CA = `size($ZfirstcurveshapesA)`;
    int $CB = `size($ZfirstcurveshapesB)`;
    int $XnumOFcurveConnections = `size($Intersectboundarycurves)`;
    string $myIntersector = `stringArrayIntersector`;
    string $ZfirstcurveRelatives[];
    string $ZfirstcurveConnectionsz[];
    string $Zfirstcurveshapes[];
    string $Intersectboundarycurves[];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════


    $NumberofConnectionZ = 0;
    $myIntersector = `stringArrayIntersector`;
    for ( $eachboundry in $Zeachboundry ) {
    $ZfirstcurveRelatives = `listRelatives -shapes $eachboundry`;
    $ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
    $historyShapes = `size($ZfirstcurveConnectionsz)`;

    if ($historyShapes > 0){
    $ZfirstcurveshapesA = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;
    $ZfirstcurveshapesB = `listConnections -shapes 1  -type mesh $ZfirstcurveConnectionsz`;
    $CA = `size($ZfirstcurveshapesA)`;
    $CB = `size($ZfirstcurveshapesB)`;

    if (($CA > 0) || ($CB > 0)){
    if ($CA > 0){
    $NumberofConnectionZ++;
    stringArrayIntersector -edit -allowDuplicates  false -intersect $ZfirstcurveshapesA $myIntersector;
    }
    if ($CB > 0){
    $NumberofConnectionZ++;
    stringArrayIntersector -edit -allowDuplicates  false -intersect $ZfirstcurveshapesB $myIntersector;
    }
    }else{ //no shapes connections of anytype Exist ZERO
    $NumberofConnectionZ = 0;
    }
    }
    }
    $Intersectboundarycurves =  `stringArrayIntersector -query $myIntersector`;
    stringArrayIntersector -edit -reset  $myIntersector;
    $XnumOFcurveConnections = `size($Intersectboundarycurves)`;
    return $XnumOFcurveConnections;

}


/******************************************************************************
 * @procedure    IfCurvesTouch
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $curveA : string
 *   $curveB : string
 *
 * @returns      int
 * @source       workingcalculateEllipse (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc int IfCurvesTouch(string $curveA, string $curveB)
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    int $intIfTrue = FindifCurveEndsMeet($CurveOne, $CurveTwo);
    string $Acurve[];
    string $Bcurve[];
    vector $CurveOne[] = GetVectorArrayBetweenCurveEnds($Acurve);
    vector $CurveTwo[] = GetVectorArrayBetweenCurveEnds($Bcurve);

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $Acurve = {$curveA};
    $Bcurve = {$curveB};
    $CurveOne = GetVectorArrayBetweenCurveEnds($Acurve);
    $CurveTwo = GetVectorArrayBetweenCurveEnds($Bcurve);
    $intIfTrue = FindifCurveEndsMeet($CurveOne, $CurveTwo);
    return $intIfTrue;

}


/******************************************************************************
 * @procedure    PtDist_to_Plane
 * @category     utility
 * @layer        utility (General)
 *
 * @param
 *   $V : vector[]
 *   $VecN : vector[]
 *
 * @returns      float
 * @source       ZenoManPlaneSAVED! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/
proc float PtDist_to_Plane(vector $V[], vector $VecN[])
{
    // ════════════════════════════════════════════════════════════════
    // VARIABLE DECLARATIONS
    // ════════════════════════════════════════════════════════════════
    vector $p = $VecN[0];
    vector $n1 = $VecN[1];

    // ════════════════════════════════════════════════════════════════
    // PROCEDURE LOGIC
    // ════════════════════════════════════════════════════════════════

    $p = $VecN[0];
    $n1 = $VecN[1];
    $F = $n1;
    $e = $V[0];
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $D1 = distance2Pts($P1, $p);
    return $D1;

}

