/******************************************************************************
 * TRANSFORM PROCEDURES
 *
 * Category: transform
 * Procedure Count: 20
 *
 * This file contains cleaned and annotated MEL procedures.
 * All variable declarations have been moved to the start of each procedure.
 *
 * Mathematical Layers:
 *   - affine: GL(4,R)
 *
 * Generated by cleanup_mel_scripts.py
 ******************************************************************************/


/******************************************************************************
 * @procedure FindNameOfVariables
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $Find (string)
 *   $sortN (int)
 * @returns string []
 *
 * @dependencies ArrayFromAllinString, StringArrayStartOfStringinArray, ReturnArrayFromNestedStringAtIndex, PrintLongArrayNice, CreateIntIndex
 *                (+1 more)
 *
 * @source proc string [] FindNameOfVariables (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string [] FindNameOfVariables(string $Find, int $sortN)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $IndexLetters[] = CreateIntIndex(`size($ArrayLetter)`);
    int $BytNumi;
    int $StringIndex[];
    int $StringIndex[] = CreateIntIndex( `size($all)` );
    int $countIndex = 0;
    int $indexStart[];
    int $indexFirstCharItems[];
    int $BytNx = 0;
    int $freezeTrigger = 0;
    int $eachInt = 0;
    int $iixI = 0;
    int $IndexLetters[] = CreateIntIndex(`size($ArrayLetter)`);
    int $TFandIndex[];
    int $TFandIndexii[];
    int $FirstLFindIndex;
    int $Tri = 0;
    int $Trii = 2;
    int $CountFoundletters = 0;
    int $SizeItem = `size $matchTemp`;
    string $resultVar = "string float vector matrix int proc";
    string $resulti = "sin cos tan tand atan asin acos atand asind acosd";
    string $result = "abs angle bessel ceil clamp constrainValue cos cross crossProduct deg_to_rad delrandstr dot dotProduct equivalent equivalentTol erf exp floatEq floor fmod gamma gauss getLastError getProcArguments hermite hsv_to_rgb hypot linstep log mag max min noise normalize pointMatrixMult pow rad_to_deg rand randstate rgb_to_hsv rot seed sign sin smoothstep sphrand sqrt tan trunc unitprint ";
    string $AllMathfunction = "abs ,angle ,bessel ,ceil ,clamp ,constrainValue ,cos ,cross ,crossProduct ,deg_to_rad ,delrandstr ,dot ,dotProduct ,equivalent ,equivalentTol ,erf ,exp ,floatEq ,floor ,fmod ,gamma ,gauss ,getLastError ,getProcArguments ,hermite ,hsv_to_rgb ,hypot ,linstep ,log ,mag ,max ,min ,noise ,normalize ,pointMatrixMult ,pow ,rad_to_deg ,rand ,randstate ,rgb_to_hsv ,rot ,seed ,sign ,sin ,smoothstep ,sphrand ,sqrt ,tan ,trunc ,unit";
    string $MathFuncClassData = $result+" "+ $resulti + " " + $resultVar ;
    string $KnownMathTermsMEL[] = stringToStringArray($MathFuncClassData, " ");
    string $KnownMathTermsMELSorted[] = `sort $KnownMathTermsMEL`;
    string $startingChar[] = StringArrayStartOfStringinArray($KnownMathTermsMELSorted);
    string $shorterListstartingChar[] = stringArrayRemoveDuplicates ($startingChar);
    string $KnownMatch[] = $KnownMathTermsMELSorted;
    string $ArrayLetter[] = $shorterListstartingChar;
    string $Arraytemp[] = $KnownMathTermsMELSorted;
    string $StartOfEachS;
    string $findEachstart = "";
    string $gatherItems = "";
    string $eachStringL;
    string $eachString;
    string $all[];
    string $all[] = ArrayFromAllinString($Find);
    string $tempFind = $Find;
    string $tempFindwrite = $Find;
    string $StartS;
    string $LetterItem = "";
    string $FoundVariableItems[];
    string $FoundOtherItems[];
    string $StringFromReducedArray = "";
    string $reducedArray[];
    string $allTemp[];
    string $dontUse = "";
    string $matchingDontuse = "";
    string $matching = "";
    string $match;
    string $match0;
    string $matchMiddleDiff;
    string $matchi;
    string $MatchStage2;
    string $MatchStage3;
    string $addBracktoMatch3;
    string $addBracktoMatchD;
    string $matchTemp;
    string $dontUse;
    string $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    string $ArrayFind[];
    string $StartOfEachSi = "";
    string $FOUND = "";
    string $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    string $printneat = stringArrayToString($FoundVariableItems, ",");
    string $printneati = stringArrayToString($FoundOtherItems, ",");
    string $FoundTerms[] = stringToStringArray($printneat, ",");
    vector $indexStartEnd[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────


    $resultVar = "string float vector matrix int proc";
    $resulti = "sin cos tan tand atan asin acos atand asind acosd";
    $result = "abs angle bessel ceil clamp constrainValue cos cross crossProduct deg_to_rad delrandstr dot dotProduct equivalent equivalentTol erf exp floatEq floor fmod gamma gauss getLastError getProcArguments hermite hsv_to_rgb hypot linstep log mag max min noise normalize pointMatrixMult pow rad_to_deg rand randstate rgb_to_hsv rot seed sign sin smoothstep sphrand sqrt tan trunc unitprint ";
    $AllMathfunction = "abs ,angle ,bessel ,ceil ,clamp ,constrainValue ,cos ,cross ,crossProduct ,deg_to_rad ,delrandstr ,dot ,dotProduct ,equivalent ,equivalentTol ,erf ,exp ,floatEq ,floor ,fmod ,gamma ,gauss ,getLastError ,getProcArguments ,hermite ,hsv_to_rgb ,hypot ,linstep ,log ,mag ,max ,min ,noise ,normalize ,pointMatrixMult ,pow ,rad_to_deg ,rand ,randstate ,rgb_to_hsv ,rot ,seed ,sign ,sin ,smoothstep ,sphrand ,sqrt ,tan ,trunc ,unit";
    $MathFuncClassData = $result+" "+ $resulti + " " + $resultVar ;
    //string  $KnownMathTermsMELAtomizes[] = ArrayFromAllinString($MathFuncClassData);
    $KnownMathTermsMEL = stringToStringArray($MathFuncClassData, " ");
    $KnownMathTermsMEL = `sort $KnownMathTermsMEL`;

    //

    print (" "+"\n");
    PrintLongArrayNice($KnownMathTermsMELSorted , 5);
    print (" "+"\n");

    $startingChar = StringArrayStartOfStringinArray($KnownMathTermsMELSorted);
    $shorterListstartingChar = stringArrayRemoveDuplicates ($startingChar);
    $KnownMatch = $KnownMathTermsMELSorted;
    $ArrayLetter = $shorterListstartingChar;
    $Arraytemp = $KnownMathTermsMELSorted;
    $findEachstart = "";
    clear $StartOfEachSTable $itemBackUp;
    $itemBackUp = $ArrayLetter;
    $gatherItems = "";

    for ($eachStringL in $ArrayLetter){
    for ($eachString in $KnownMathTermsMELSorted){
    $StartOfEachS = startString($Arraytemp[0], 1);
    if ($StartOfEachS==$eachStringL){
    $gatherItems += ($Arraytemp[0]+",");
    $Arraytemp = stringArrayRemoveExact({$Arraytemp[0]}, $Arraytemp);
    }
    //else{	$gatherItems="";}	//
    }
    if(`size($gatherItems)`>0){
    $StartOfEachSTable[`size($StartOfEachSTable)`]= $gatherItems;
    }
    $gatherItems="";
    }
    print $StartOfEachSTable;
    //$ArrayLetter

    /////////////////////////////////////////////////////////////////////////////////////////////////////



    $IndexLetters = CreateIntIndex(`size($ArrayLetter)`);
    $BytNumi = `sizeBytes $Find`;
    clear $all;
    clear $StringIndex;
    $all = ArrayFromAllinString($Find);
    $StringIndex = CreateIntIndex( `size($all)` );
    //map string

    $tempFind = $Find;
    $tempFind = $Find;
    $countIndex = 0;
    clear $indexStart;
    $LetterItem = "";
    clear $FoundVariableItems $FoundOtherItems;
    clear $indexFirstCharItems;
    $BytNx = 0;
    $StringFromReducedArray = "";
    clear $reducedArray;
    clear $allTemp;
    $allTemp = $all;
    $dontUse = "";
    $matchingDontuse = "";
    $freezeTrigger = 0;
    $matching = "";
    //print $allTemp;
    $eachInt = 0;
    $iixI = 0;
    print $Find;

    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $Find`;
    $match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $Find`;
    $matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $Find`;
    $matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $Find`;
    $MatchStage2 = endString($match, 3);
    //print $MatchStage2;
    $MatchStage3 = startString($match, `sizeBytes $match`-2);
    $MatchStage3i = startString($match, `sizeBytes $matchii`-2);
    $addBracktoMatch3 = ("\["+$MatchStage3+"\]");
    //$addBracktoMatchD = ("\(["+"\"+$matchi+"\])+([a-zA-Z]+)([a-zA-Z0-9_])");
    $matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;
    if($matchMiddleDiff=="\."){
    print"yes";
    $match = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    if($matchMaybeVec2!=""){
    $MatchStage4 = startString($match, `sizeBytes $match`-1);
    $match = $MatchStage4;
    }else{ $dontUse = $matchi; $match=$matchi; }
    }else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//
    }
    print $match;
    print ("\n");
    print $dontUse;
    print ("\n");
    $matchTemp = $match;
    $BytNx =`sizeBytes $match`;


    //  $allTemp[$eachItemArray]
    //"([a-zA-Z]+)([a-zA-Z0-9_])*"


    $IndexLetters = CreateIntIndex(`size($ArrayLetter)`);
    $StartOfEachS = "";
    $FOUND = "";
    clear $ArrayFind $TFandIndex $TFandIndexii;
    $Tri = 0;
    $Tri = 2;
    $CountFoundletters = 0;
    clear $indexStartEnd;
    //print $StringIndex;


    for ($eachItemArray in $StringIndex){
    $eachInt = $StringIndex[$iixI];
    //$eachInt =  $iixI;
    //print $allTemp[$eachInt];
    if( `gmatch $allTemp[$eachInt] "[a-zA-Z0-9_\.]*"` == 1){
    if($Trii==2){$Trii=1; $Tri=2;}
    if(!($CountFoundletters>=1)){
    $FirstLFindIndex=$iixI+1;
    //print $iixI;
    }
    $CountFoundletters++;
    if($Tri==2){
    //print ("TRIGGER_____TRIGGER"+ $iixI);
    //$FirstLFindIndex=$iixI;
    $Tri=0;
    }
    $LetterItem+= $allTemp[$eachInt];
    $BytNx = `sizeBytes $LetterItem`;
    if(`gmatch $matchTemp $LetterItem`==1){
    $BytNx = `sizeBytes $LetterItem`;
    print ("found whole string " +"\n");
    //$LetterItem ="pow";
    $StartOfEachSi = startString($LetterItem, 1);
    $TFandIndex = TFArrayContains($StartOfEachSi, $ArrayLetter);
    if($TFandIndex[0]==1){
    $ArrayFind = ReturnArrayFromNestedStringAtIndex($StartOfEachSTable, $TFandIndex[1]);
    $TFandIndexii = TFArrayContains($LetterItem, $ArrayFind);
    //print ("FoundTable"+ $TFandIndexii[0]+$TFandIndexii[1] + "\n");
    if($TFandIndexii[0]==1){
    $FOUND = $ArrayFind[$TFandIndexii[1]];
    if(`gmatch $FOUND $LetterItem`==1){
    //print ($FOUND + "\n");
    $FoundOtherItems[`size($FoundOtherItems)`]= $FOUND;
    }
    }
    }
    if(`gmatch $FOUND $LetterItem`!=1){
    if($matchTemp!=$dontUse){
    $FoundVariableItems[`size($FoundVariableItems)`]= $LetterItem;
    $SizeItem = `size $matchTemp`;
    $indexStartEnd[`size($indexStartEnd)`] = <<$FirstLFindIndex, $iixI, ($iixI-$SizeItem+3)>> ;
    $indexStart[`size($indexStart)`]= $FirstLFindIndex;
    }
    } else{$CountFoundletters=0;          }
    clear $TFandIndex $ArrayFind $TFandIndexii;
    $FOUND="";
    $reducedArray = $allTemp;
    stringArrayRemoveToIndex($eachInt+1, $reducedArray);
    $StringFromReducedArray = stringArrayToString($reducedArray, "");
    print (" " +"\n");
    print $StringFromReducedArray;
    print (" " +"\n");
    /////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////
    $LetterItem ="";
    if($matchTemp==$dontUse){ $freezeTrigger = 1; }
    if( `gmatch $allTemp[$eachInt] $match` != 1){$Trii=2; $CountFoundletters=0;}
    print ($FirstLFindIndex + "\n");
    print ($iixI + "\n");
    $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;
    print ( $match0 + "\n");
    //if(`size($StringFromReducedArray)`>4){
    $match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $StringFromReducedArray`;
    $matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $StringFromReducedArray`;
    $matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $StringFromReducedArray`;
    $MatchStage2 = endString($match, 3);
    $MatchStage3 = startString($match, `sizeBytes $match`-2);
    $MatchStage3i = startString($match, `sizeBytes $matchii`-2);
    $addBracktoMatch3 = ("\["+$MatchStage3+"\]");
    //$addBracktoMatchD = ("\(["+"\"+$matchi+"\])+([a-zA-Z]+)([a-zA-Z0-9_])");
    $matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;
    print ( $matchMiddleDiff + "\n");
    if($matchMiddleDiff=="\."){
    print"yes";
    $match = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
    if($matchMaybeVec2!=""){
    $MatchStage4 = startString($match, `sizeBytes $match`-1);
    $match = $MatchStage4;
    }else{ $dontUse = $matchi; $match=$matchi; }
    }else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//
    }
    }
    }else{$LetterItem ="";  }
    ///}else{$match = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;}
    $matchTemp = $match;
    print ($match+ "\n");
    $iixI++;
    }


    ///////////////

    print $indexStartEnd;
    print $indexStart;
    $printneat = stringArrayToString($FoundVariableItems, ",");
    $printneat = stringArrayToString($FoundOtherItems, ",");

    $FoundTerms = stringToStringArray($printneat, ",");

    if($sortN== 1){$FoundTerms = `sort $FoundTerms`;}

    return $FoundTerms;


}


/******************************************************************************
 * @procedure getpositions
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $objectlist (string[])
 * @returns vector[]
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc vector[] getpositions(string $objectlist[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $iX = 0;
    string $objectlistF[] = `ls -fl $objectlist`;
    vector $pointsV[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────


    $objectlistF = `ls -fl $objectlist`;
    $iX = 0;
    for ($each in $objectlistF){
    if (catch($pointsV[$iX] = `pointPosition -w  $each`)){
    $pointsV[$iX] = `xform -q -ws - rp $each`;
    }
    $iX++;
    }
    return $pointsV;

}


/******************************************************************************
 * @procedure ZeroOrONE
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $objectLoc (string[])
 * @returns int
 *
 * @dependencies SubtractFloats
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int ZeroOrONE(string $objectLoc[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $X = size($objectLocZ) -1;
    int $Z = size($objectLocZ);
    int $i = 1;
    int $n = -1;
    int $n2 = 0;
    int $Zero0rOne = 0;
    float $SubtractAB[];
    float $posA[];
    float $posB[];
    string $objectLocZ[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $objectLocZ = $objectLoc;
    $X = size($objectLocZ) -1;
    $Z = size($objectLocZ);
    $i = 1;
    $n = -1;
    $n = 0;
    $Z = 0;
    for( $i = 0; $i < $X; $i ++ ) {
    $n = $n + 1;
    $Z = $Z - 1;
    $ix = 0;
    $n2 = $n + 1;
    while ($Z > $ix++){

    $posA = `xform -q -wd -translation  $objectLocZ[$n]`;
    $posB = `xform -q -wd -translation  $objectLocZ[$n2]`;
    $n2++;
    $SubtractAB = SubtractFloats($posA, $posB);
    if (($SubtractAB[0] == 0) && ($SubtractAB[1] ==  0) && ($SubtractAB[2] == 0 )){
    print "yes AB";
    $Zero0rOne = 1;
    }
    }
    }
    return $Zero0rOne;

}


/******************************************************************************
 * @procedure GetDistance
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $objectFirst (string)
 *   $objectSecond (string)
 * @returns int
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int GetDistance(string $objectFirst, string $objectSecond)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $distanceA2roundoff;
    int $distanceA2roundoff = $distanceA2;
    float $pointAZ1[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $pointAZ1 = `xform -query -worldSpace - translation ($objectFirst)`;
    $pointAZ2 = `xform -query -worldSpace - translation ($objectSecond)`;
    $dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy =  $pointAZ1[1] - $pointAZ2[1];
    $dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2;
    $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy *  $dAy) + ($dAz * $dAz) )`;
    $distanceA2roundoff = $distanceA2;
    return $distanceA2roundoff;

}


/******************************************************************************
 * @procedure ProjectCrv2PlaneNormalP
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $vecRs (vector[])
 *   $AvN (vector)
 *   $Midp (vector)
 * @returns vector []
 *
 * @dependencies GetMatrix, FloatToVec, DirectionFN, ClosestPoint2LineVec, DirectionF
 *                (+1 more)
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc vector [] ProjectCrv2PlaneNormalP(vector $vecRs[], vector $AvN, vector $Midp)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $SizeVp = `size($vecRs)`;
    int $CountF[];
    int $CountFN = 0;
    int $C1;
    int $trackit[];
    int $TF = 0;
    int $SizeC = `size($O)`;
    float $valN;
    vector $vecRsA[];
    vector $NewPtsP[];
    vector $PtsVec;
    vector $Tran;
    vector $DirectC = DirectionFN($vecRs[0], $Midp);
    vector $tan = crossProduct($DirectC,$AvN, 0, 0 );
    vector $V[];
    vector $p = `xform -q -ws -t "LiveSurfaceB"`;
    vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
    vector $n1 = $AvN;
    vector $RECORD[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    float $RowA[],$RowB[],$RowC[],$Pts[],$AxisO[],$PtZ[];
    $DirectC = DirectionFN($vecRs[0], $Midp);
    $tan = crossProduct($DirectC,$AvN, 0, 0 );
    $RowA = $tan;
    $RowB = $DirectC;
    $RowC = $AvN;
    // cent of matrix
    $AxisO = $Tran = $Midp;
    $SizeVp = `size($vecRs)`;
    vector  $Xv,$Dv,$ZEROIi;
    $CountF = 0;
    for($Ind=0; $Ind<$SizeVp; $Ind++){
    $PtsVec=$vecRs[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $Xv = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    $Dv=DirectionF($Xv,$PtsVec);
    $ZEROIi = $Dv*$AvN;
    $valN= $ZEROIi.x*$ZEROIi.y*$ZEROIi.z;
    $sign = `sign $valN`;
    $valN = (int) (($valN + $sign*5/(1.0*10)) * 1.0);
    $valN = ($valN/1.0);
    if($valN==1){
    $NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    $vecRsA[$CountFN]=$PtsVec;
    $CountF[$CountFN]=$Ind;
    $CountFN++;
    }
    }
    $V= $vecRsA;
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = $AvN;
    float $D, $D1;
    vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[];
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F4 = $NewPtsP[$C1];
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    matrix $MatrixNewB[4][4];
    $MatrixNewB = GetMatrix("ZCURVEModelingCAM");
    $MtxF  = MatrixToFloat($MatrixNewB);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};
    $TF = 0;
    $SizeC = `size($O)`;
    for($Ind=0; $Ind<$SizeC; $Ind++){
    $PtsVec= $O[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $TF=rectContains(-0.5,-0.5, 1.0, 1.0,$PtZ[0], $PtZ[2]);
    if($TF==1){
    $RECORD[`size($RECORD)`]=$O[$Ind];
    }
    $TF=0;
    }
    return $RECORD;

}


/******************************************************************************
 * @procedure ProjectCrv2PlaneNormalPindex
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $vecRs (vector[])
 *   $AvN (vector)
 *   $Midp (vector)
 * @returns vector []
 *
 * @dependencies GetMatrix, FloatToVec, DirectionFN, ClosestPoint2LineVec, DirectionF
 *                (+1 more)
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc vector [] ProjectCrv2PlaneNormalPindex(vector $vecRs[], vector $AvN, vector $Midp)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $SizeVp = `size($vecRs)`;
    int $CountF[];
    int $CountFN = 0;
    int $C1;
    int $trackit[];
    int $TF = 0;
    int $TFcn = 0;
    int $SizeC = `size($O)`;
    float $valN;
    vector $vecRsA[];
    vector $NewPtsP[];
    vector $PtsVec;
    vector $Tran;
    vector $DirectC = DirectionFN($vecRs[0], $Midp);
    vector $tan = crossProduct($DirectC,$AvN, 0, 0 );
    vector $V[];
    vector $p = `xform -q -ws -t "LiveSurfaceB"`;
    vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
    vector $n1 = $AvN;
    vector $RECORD[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    global int $Index3dVecs2P[];
    global vector $AllKnowVecsInView[];
    clear $Index3dVecs2P;
    clear $AllKnowVecsInView;

    float $RowA[],$RowB[],$RowC[],$Pts[],$AxisO[],$PtZ[];
    $DirectC = DirectionFN($vecRs[0], $Midp);
    $tan = crossProduct($DirectC,$AvN, 0, 0 );
    $RowA = $tan;
    $RowB = $DirectC;
    $RowC = $AvN;
    // cent of matrix
    $AxisO = $Tran = $Midp;
    $SizeVp = `size($vecRs)`;
    vector  $Xv,$Dv,$ZEROIi;
    $CountF = 0;
    for($Ind=0; $Ind<$SizeVp; $Ind++){
    $PtsVec=$vecRs[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $Xv = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    $Dv=DirectionF($Xv,$PtsVec);
    $ZEROIi = $Dv*$AvN;
    $valN= $ZEROIi.x*$ZEROIi.y*$ZEROIi.z;
    $sign = `sign $valN`;
    $valN = (int) (($valN + $sign*5/(1.0*10)) * 1.0);
    $valN = ($valN/1.0);
    if($valN==1){
    $NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
    $vecRsA[$CountFN]=$PtsVec;
    $CountF[$CountFN]=$Ind;
    $CountFN++;
    }
    }
    $V= $vecRsA;
    $p = `xform -q -ws -t "LiveSurfaceB"`;
    $C = `xform -q -ws -t ZCURVEModelingCAM`;
    $n1 = $AvN;
    float $D, $D1;
    vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[];
    $C1=0;
    for($e in $V){
    $F = DirectionF($C, $e);
    $M = $e+($F);
    $D = distance2Pts($e, $p);
    $P1 = ClosestPoint2LineVec($n1, $p, $e);
    $F4 = $NewPtsP[$C1];
    $P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
    $F1 = DirectionF($P, $M);
    $O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
    $C1++;
    }
    matrix $MatrixNewB[4][4];
    $MatrixNewB = GetMatrix("ZCURVEModelingCAM");
    $MtxF  = MatrixToFloat($MatrixNewB);
    $RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
    $RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
    $RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};
    $TF = 0;
    $TF = 0;
    $SizeC = `size($O)`;
    for($Ind=0; $Ind<$SizeC; $Ind++){
    $PtsVec= $O[$Ind];
    $Pts = $PtsVec;
    $PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
    $PtZ[2] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
    $PtZ[1] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
    $TF=rectContains(-0.5,-0.5, 1.0, 1.0,$PtZ[0], $PtZ[2]);
    if($TF==1){
    $RECORD[$TFcn`]=$O[$Ind];
    $AllKnowVecsInView[$TFcn]= $vecRsA[$Ind];
    $FinalIndex[$TFcn]=$CountF[$Ind];
    $TFcn++;
    }
    $TF=0;
    }
    $Ind3dV2P=$FinalIndex;
    return $RECORD;

}


/******************************************************************************
 * @procedure screenSpaceVecMult
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $v (vector)
 *   $m (matrix)
 * @returns vector
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc vector screenSpaceVecMult(vector $v, matrix $m)
{

    matrix $v1[1][4]=<<$v.x, $v.y, $v.z, 1>>;
    matrix $v2[1][4]=$v1*$m;
    return <<$v2[0][0], $v2[0][1],  $v2[0][2]>>;

}


/******************************************************************************
 * @procedure initializePopulation
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @returns matrix
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc matrix initializePopulation()
{

    global int $gPopulationSize;
    global int $gGenomeLength;
    global int $gMaxGeneValue;
    global matrix $genomes[50][9];
    int $i, $j;
    //Set each gene to a random value
    for($i=0; $i<$gPopulationSize; $i++){
    for($j=0; $j<$gGenomeLength; $j++)
    $genomes[$i][$j] = int(rand ($gMaxGeneValue));
    }
    return $genomes;

}


/******************************************************************************
 * @procedure breed
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $genomes (matrix)
 *   $fitness (float[])
 *   $elites (int)
 *   $tournamentSize (int)
 *   $mutationRate (float)
 * @returns matrix
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc matrix breed(matrix $genomes, float $fitness[], int $elites, int $tournamentSize, float $mutationRate)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $lowest = -1;
    int $father = tournamentSelect($fitness, $tournamentSize);
    int $mother = tournamentSelect($fitness, $tournamentSize);

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    global int $gPopulationSize;
    global int $gGenomeLength;
    matrix $newGenomes[50][9]; //The next generation
    $lowest = -1;
    //Copy the elites to the new generation, they will automatically be the first individuals in the new generation.
    for($i=0; $i<$elites; $i++){
    $lowest = findLowestFitness($fitness, $lowest);
    for($j=0; $j<$gGenomeLength; $j++)
    $newGenomes[$i][$j] = $genomes[$lowest][$j];
    }
    //Create the rest through tournament selection
    for($i=$elites; $i<$gPopulationSize; $i++){
    $father = tournamentSelect($fitness, $tournamentSize);
    $mother = tournamentSelect($fitness, $tournamentSize);
    $newGenomes = crossover($genomes, $newGenomes, $father, $mother, $i);
    }
    return mutate($newGenomes, $elites, $mutationRate);

}


/******************************************************************************
 * @procedure GetObjectsInFrontOfPlane2
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $Loc (string[])
 *   $VecArray (vector[])
 *   $VecArrayRemainsB (vector[])
 * @returns string []
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string [] GetObjectsInFrontOfPlane2(string $Loc[], vector $VecArray[], vector $VecArrayRemainsB[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $IndexVec = 0;
    int $IndexVecRemain = 0;
    string $ObjectList[];
    string $ObjectsInFrontOfPlane[];
    vector $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    vector $VecArrayRemains[];
    vector $ObjectToCamShiftA;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    float $CamPlane1[],$ObjectToCam,$ObjToCamdistShiftDiff;
    $CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
    $CamerasDirectionVectorNormal = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
    $IndexVec = 0;
    $IndexVec = 0;
    clear $ObjectsInFrontOfPlane;
    for ($eachPoint in $VecArray){
    $ObjectToCam = distance2Pts( $CamPlane1, $VecArray[$IndexVec]);
    $ObjectToCamShiftA = ($CamerasDirectionVectorNormal* 10.5)+$VecArray[$IndexVec];
    $ObjToCamdistShiftDiff = distance2Pts( $CamPlane1, $ObjectToCamShiftA);
    if($ObjToCamdistShiftDiff<$ObjectToCam){
    stringArrayInsertAtIndex(`size($ObjectsInFrontOfPlane)`, $ObjectsInFrontOfPlane, $Loc[$IndexVec]);
    $VecArrayRemains[$IndexVecRemain]= $VecArray[$IndexVec];
    $IndexVecRemain++;
    }
    $IndexVec++;
    }
    $VecArrayRemainsB = $VecArrayRemains;
    return $ObjectsInFrontOfPlane;

}


/******************************************************************************
 * @procedure PointInNurbPlane
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $AllPlaneLocPosition (vector[])
 *   $ObjectsInFront (string[])
 *   $Newindex (int[])
 *   $Locint (int)
 * @returns string []
 *
 * @dependencies MidPoint, MoveObject2, FloatToVec, AddFloats, DirectionF
 *                (+2 more)
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string [] PointInNurbPlane(vector $AllPlaneLocPosition[], string $ObjectsInFront[], int $Newindex[], int $Locint)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $IndexV[] = CreateIntIndex(`size($AllPlaneLocPosition)`);
    int $IndexReduced[];
    int $indexRecord = 0;
    int $indexPoints = 0;
    int $Lastindex = 0;
    int $lastIntIndex[];
    int $indexM = 0;
    int $FourDiections = 0;
    int $inDexName = 0;
    float $AveragePoints[] = `xform -q -ws -t LiveSurfaceB`;
    float $Direct[] = DirectionF( $each, $AveragePoints);
    float $PlaneDimentionsV = distance2Pts( $SurfEnds[0], $SurfEnds[1]);
    float $PlaneDimentionsH = distance2Pts( $SurfEnds[1],$SurfEnds[3]);
    float $RadiusMax = distance2Pts( $AveragePoints, $SurfEnds[0]);
    float $FoundDistance;
    float $PlaneDimentionsVH = $PlaneDimentionsV/100;
    float $PlaneDimentionsHH = $PlaneDimentionsH/100;
    float $LocPoint[] = $eachPoint;
    float $MultDirAV[];
    float $DistanceA = distance2Pts( $MiddlePointA[$indexM],  $LocPoint);
    float $FloatDirectionPointz[] = AddFloats($MultDirAV, $LocPoint);
    float $DistanceB = distance2Pts( $MiddlePointA[$indexM],  $FloatDirectionPointz);
    string $EdgesSurface[];
    string $allObjectsInPlane[];
    string $stringName = ("Plane"+ $allObjectsInPlane[$inDexName]);
    vector $SurfEnds[] = PointArray($EdgesSurface);
    vector $MiddlePointA[];
    vector $DirectionsToCent[];
    vector $firstReduction[];
    vector $PointsZ[] = $firstReduction;
    vector $AllPointsInplane[];
    vector $NewVecArray[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    clear $EdgesSurface;
    $EdgesSurface[0] = "LiveSurfaceBShape.cv[0][0]" ;
    $EdgesSurface[1] = "LiveSurfaceBShape.cv[0][3]" ;
    $EdgesSurface[2] = "LiveSurfaceBShape.cv[3][3]" ;
    $EdgesSurface[3] = "LiveSurfaceBShape.cv[3][0]" ;
    $SurfEnds = PointArray($EdgesSurface);
    $MiddlePointA[0] = FloatToVec(MidPoint($SurfEnds[0], $SurfEnds[1]));
    $MiddlePointA[1] = FloatToVec(MidPoint($SurfEnds[1], $SurfEnds[2]));
    $MiddlePointA[2] = FloatToVec(MidPoint($SurfEnds[2], $SurfEnds[3]));
    $MiddlePointA[3] = FloatToVec(MidPoint($SurfEnds[3], $SurfEnds[0]));
    $AveragePoints = `xform -q -ws -t LiveSurfaceB`;
    clear $DirectionsToCent;
    for ($each in $MiddlePointA){
    $Direct = DirectionF( $each, $AveragePoints);
    $DirectionsToCent[size($DirectionsToCent)] = <<$Direct[0], $Direct[1], $Direct[2]>>;
    }
    $PlaneDimentionsV = distance2Pts( $SurfEnds[0], $SurfEnds[1]);
    $PlaneDimentionsH = distance2Pts( $SurfEnds[1],$SurfEnds[3]);
    $IndexV = CreateIntIndex(`size($AllPlaneLocPosition)`);
    $RadiusMax = distance2Pts( $AveragePoints, $SurfEnds[0]);
    $indexRecord = 0;
    for ($eachVec in $AllPlaneLocPosition){
    $FoundDistance = distance2Pts( $AveragePoints, $eachVec);
    if($FoundDistance<=$RadiusMax){
    $IndexReduced[`size($IndexReduced)`] = $IndexV[$indexRecord];
    $firstReduction[`size($firstReduction)`]= $eachVec;
    }
    $indexRecord++;
    }
    $PlaneDimentionsV = $PlaneDimentionsV/100;
    $PlaneDimentionsH = $PlaneDimentionsH/100;
    $indexPoints = 0;
    $PointsZ = $firstReduction;
    $Lastindex = 0;
    $indexM = 0;
    $FourDiections = 0;
    for ($eachPoint in $firstReduction){
    $LocPoint = $eachPoint;
    $indexM = 0;
    $FourDiections = 0;
    for ($each in  $DirectionsToCent){
    $DistanceA = distance2Pts( $MiddlePointA[$indexM],  $LocPoint);
    if(($indexM==0)||($indexM==2)){
    $MultDirAV= multiplyFloat($PlaneDimentionsVH, $each);
    }
    if(($indexM==1)||($indexM==3)){
    $MultDirAV= multiplyFloat($PlaneDimentionsHH, $each);
    }
    $FloatDirectionPointz = AddFloats($MultDirAV, $LocPoint);
    $DistanceB = distance2Pts( $MiddlePointA[$indexM],  $FloatDirectionPointz);
    if( $DistanceB > $DistanceA){
    $FourDiections++;
    }
    $indexM++;
    }
    if( $FourDiections == 4 ){
    $AllPointsInplane[`size($AllPointsInplane)`]= $eachPoint;
    $lastIntIndex[$Lastindex]=  $IndexReduced[$indexPoints];
    $Lastindex++;
    }
    $indexPoints++;
    }
    for ($eachNumber in $lastIntIndex){
    stringArrayInsertAtIndex(`size($allObjectsInPlane)`, $allObjectsInPlane, $ObjectsInFront[$eachNumber]);
    }
    $Newindex = $lastIntIndex;
    for ($eachNumber in $lastIntIndex){
    $NewVecArray[`size($NewVecArray)`] =$AllPlaneLocPosition[$eachNumber];
    }
    $AllPlaneLocPosition=$NewVecArray;
    if($Locint==1){
    $inDexName = 0;
    for ($each in $AllPointsInplane){
    $stringName = ("Plane"+ $allObjectsInPlane[$inDexName]);
    spaceLocator -p 0 0 0 -n $stringName;
    MoveObject2($each);
    scale -r 0.01 0.01 0.01;
    editDisplayLayerMembers -noRecurse LocOnLivePlaneB $stringName;
    $inDexName++;
    }
    }
    return $allObjectsInPlane;

}


/******************************************************************************
 * @procedure ForceOrtho
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $CurveItemAX (string[])
 * @returns string []
 *
 * @dependencies MidPoint, VecCurveEnds, FloatToVec, VecCurveEps, PositiveDirectionLine
 *                (+13 more)
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string [] ForceOrtho(string $CurveItemAX[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $edgeZsetA;
    int $edgeZsetB;
    int $ReducedIndexA[] = floatArrayCountDuplicates($distancesEachToCurve);
    int $ReducedIndexB[] = floatArrayCountDuplicates($distancesEachToCurveB);
    int $NearestInt[] = SortNumbersIntIndex($distAz);
    int $NearestIntB[] = SortNumbersIntIndex($distBz);
    int $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    int $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];
    int $NearestIndex;
    int $NearestIndexEach;
    int $ReducedIndexXAB[];
    int $AxisOrthoLineA = $AxisOrthoLine;
    int $iVc = 0;
    int $TrackFoundN[];
    int $TrackN[];
    int $TwoPointsi[];
    int $AXIS = $AxisOrthoLineA;
    int $ALLlikeness[];
    int $ALLlikenessForce[];
    int $i = 0;
    int $TriggerPoints;
    int $SortedForce[];
    int $Sorted[] = SortNumbersIntIndex($distTo3DCurveEnd);
    int $ReducedIndex[] = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    int $OntheSameLine = 0;
    int $CountN = 0;
    int $AddInt = $AdditR;
    int $AddInt = $AdditR;
    int $AddInt = $AdditR;
    float $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    float $distancesEachToCurve[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    float $distancesEachToCurveB[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    float $distAz[];
    float $distBz[];
    float $CamPos_A[];
    float $EpipolXx[] = {0.0,$CamPos_A[1],$CamPos_A[2]};
    float $PlaneEpipolXx[] = FloatPointsToCamPlane( $EpipolXx);
    float $EpipolYx[] = {$CamPos_A[0],0.0,$CamPos_A[2]};
    float $PlaneEpipolYx[] = FloatPointsToCamPlane( $EpipolYx);
    float $EpipolZx[] = {$CamPos_A[0],$CamPos_A[1],0.0};
    float $PlaneEpipolZx[] = FloatPointsToCamPlane( $EpipolZx);
    float $MidCurveA[] = MidPoint($CRV_ENDSi[0], $CRV_ENDSi[1]);
    float $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    float $FPointN_LineC[];
    float $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);
    float $XY[];
    float $XYZi[];
    float $XYZadd[];
    float $Xd;
    float $Yd;
    float $Zd;
    float $All_X[];
    float $All_Y[];
    float $All_Z[];
    float $All_ZYX[];
    float $All_ZYXDiff[];
    float $diffXYZ;
    float $Dist_3DNear = (($Dist_3D/3.0)*2.0);
    float $newOrderFloat;
    float $distTo3DCurveEnd[] = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    float $SdistTo3DCurveEnd[];
    float $Additi[];
    float $AdditiB[];
    float $AdditRi;
    float $AdditRiX;
    float $DistSnap;
    float $Additi[];
    float $AdditiB[];
    float $AdditRi;
    float $AdditRiX;
    float $EulerAngleA[];
    float $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
    float $Addit[];
    float $AdditR;
    float $Addit[];
    float $AdditR;
    float $Addit[];
    float $AdditR;
    string $queryLocCurveEnds[] = queryLocOnLivePlaneBLayer();
    string $queryLocCurveEndsOLD[] = $queryLocCurveEnds;
    string $newNames;
    string $NearCurvesEnds[];
    string $BothCurves[];
    string $EmptyStringNewOrderA[];
    string $LocA = $queryLocCurveEnds[$NearestInt[0]];
    string $LocB = $queryLocCurveEnds[$NearestIntB[0]];
    string $LocName;
    string $Loc_AorB = "";
    string $newNames = stringArrayToString($queryLocCurveEnds, " ");
    string $newNamesResultAX = substituteAllString($newNames, "Plane", "");
    string $AllarrayCurvesNear[];
    string $NewFoundLocs[];
    string $arrayCurvesNear[];
    string $CurvesV[];
    string $LocsV[];
    string $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
    string $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    vector $Positions[];
    vector $VecCurEnds[] = VecCurveEnds({$TempCrv});
    vector $LocCurveEndsVec[] = PointArray($queryLocCurveEnds);
    vector $EndSnapAndEndProject[];
    vector $endNotNearZ[];
    vector $NearEndZ;
    vector $LocOnPlaneVec[] = PointArray($arrayCurvesNear );
    vector $Loc3D_Vec[] = PointArray($NewFoundLocs );
    vector $ALLLoc3D_VecAB[] = PointArray($AllarrayCurvesNear);
    vector $ReducedVecAB[];
    vector $ALLLoc3D_Vec[];
    vector $MovedEndPointPlane[] = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    vector $CRV_ENDSi[];
    vector $DDirEpipolXYZ[];
    vector $EpipolD[];
    vector $AllEpipolXYZ[];
    vector $XYZdirectL[];
    vector $LineMidi;
    vector $NewDirZi;
    vector $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    vector $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    vector $Dir_CamRay;
    vector $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    vector $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);
    vector $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    vector $One;
    vector $each;
    vector $NearPointsXYZ[];
    vector $ReducedVec[];
    vector $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    vector $VecLineDirMi;
    vector $PointN_LineXYZ;
    vector $SnapN;
    vector $SnapPlaceN;
    vector $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $eachVec);
    vector $VecLineDirMi;
    vector $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);
    vector $VecLineDirM;
    vector $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    vector $VecLineDirM;
    vector $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    vector $VecLineDirM;
    vector $Points3DPair_And_2DPair[];
    vector $Crv_Pts[];
    vector $MirrorAcrossPlaneVecs[] = VecMultMatrixMirror($Crv_Pts);

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    global string $StereoCurveZ[];
    global int $addNumbersA;
    global float $AngleEpiPole;
    global int $IsOrthoLineTrue;
    global int $AxisOrthoLine;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemAX[0];
    $Positions = VecCurveEps($CurveItemAX[0]);
    $TempCrv = VecArrayToCurve($Positions);
    delete $CurveItemAX[0];
    $VecCurEnds = VecCurveEnds({$TempCrv});
    $queryLocCurveEnds = queryLocOnLivePlaneBLayer();
    $queryLocCurveEnds = $queryLocCurveEnds;
    $edgeZsetA = 0;
    $edgeZsetB = 0;
    $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
    float $NdistA,$NdistB;
    if(`size($queryLocCurveEnds)` >= 2){
    $LocCurveEndsVec = PointArray($queryLocCurveEnds);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
    $distancesEachToCurve = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
    $ReducedIndexA = floatArrayCountDuplicates($distancesEachToCurve);
    $ReducedIndexB = floatArrayCountDuplicates($distancesEachToCurveB);
    for($eachInt in $ReducedIndexA){
    $distAz[`size($distAz)`]= $distancesEachToCurve[$eachInt];
    }
    for($eachInt in $ReducedIndexB){
    $distBz[`size($distBz)`]= $distancesEachToCurveB[$eachInt];
    }
    $NearestInt = SortNumbersIntIndex($distAz);
    $NearestInt = SortNumbersIntIndex($distBz);
    $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
    $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];
    $EmptyStringNewOrderA[0] = $queryLocCurveEnds[$ReducedIndexA[$NearestInt[0]]];
    $EmptyStringNewOrderA[1] = $queryLocCurveEnds[$ReducedIndexB[$NearestIntB[0]]];
    $NearestInt[0] =  $NewIntIndexAA;
    $NearestIntB[0] = $NewIntIndexBB;
    $NdistA = $distancesEachToCurve[$NearestInt[0]];
    $NdistB= $distancesEachToCurveB[$NearestIntB[0]];
    $LocA = $queryLocCurveEnds[$NearestInt[0]];
    $LocB = $queryLocCurveEnds[$NearestIntB[0]];
    clear $EndSnapAndEndProject;
    $Loc_AorB = "";
    if($NdistA<$NdistB){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    $Loc_AorB="B";
    }else{
    $Loc_AorB="A";
    $LocName =$LocB;
    $NearestIndex=$NearestIntB[0];
    $NearEndZ = $VecCurEnds[1];
    $endNotNearZ[0] = $VecCurEnds[0];}
    if($NdistA==$NdistB){
    $Loc_AorB="A";
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    $NearEndZ = $VecCurEnds[0];
    $endNotNearZ[0] = $VecCurEnds[1];
    }
    if($NearestInt[0]==$NearestIntB[0]){
    $LocName =$LocA;
    $NearestIndex=$NearestInt[0];
    }
    $newNames = stringArrayToString($queryLocCurveEnds, " ");
    $newNames = substituteAllString($newNames, "Plane", "");
    $AllarrayCurvesNear = stringToStringArray($newNamesResultAX, " ");
    $NewFoundLocs[0]  = $AllarrayCurvesNear[$NearestIndex];
    $arrayCurvesNear[0] = $queryLocCurveEnds[$NearestIndex];

    $LocOnPlaneVec = PointArray($arrayCurvesNear );
    $Loc3D_Vec = PointArray($NewFoundLocs );
    $ALLLoc3D_VecAB = PointArray($AllarrayCurvesNear);
    if($Loc_AorB == "A"){
    $ReducedIndexXAB = $ReducedIndexA;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexA,$ALLLoc3D_VecAB);
    }
    if($Loc_AorB == "B"){
    $ReducedIndexXAB = $ReducedIndexB;
    $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexB,$ALLLoc3D_VecAB);
    }
    $ALLLoc3D_Vec = $ReducedVecAB;
    $MovedEndPointPlane = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
    $CRV_ENDSi[0]= $LocOnPlaneVec[0];
    $CRV_ENDSi[1]= $MovedEndPointPlane[0];
    $CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $EpipolXx = {0.0,$CamPos_A[1],$CamPos_A[2]};
    $PlaneEpipolXx = FloatPointsToCamPlane( $EpipolXx);
    $EpipolYx = {$CamPos_A[0],0.0,$CamPos_A[2]};
    $PlaneEpipolYx = FloatPointsToCamPlane( $EpipolYx);
    $EpipolZx = {$CamPos_A[0],$CamPos_A[1],0.0};
    $PlaneEpipolZx = FloatPointsToCamPlane( $EpipolZx);
    $MidCurveA = MidPoint($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
    $DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
    $DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
    $DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
    $EpipolD = $DDirEpipolXYZ;
    $AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
    $AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
    $AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);
    $XYZdirectL[0] = << 1,0,0>>;
    $XYZdirectL[1] = << 0,1,0>>;
    $XYZdirectL[2] = << 0,0,1>>;
    $NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
    $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
    $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
    $AxisOrthoLineA = $AxisOrthoLine;
    $Dir_CamRay =  DirectionFN($MovedEndPointPlane[0],$CamPos_A);
    $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
    $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);
    $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);
    $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC));
    float $Xx, $Yy, $Zz;
    float $Xxi, $Yyi, $Zzi;
    $XYZi  = $PointN_LineC;
    $XYZadd  = $PointN_LineC;
    $XYZi[0] = $XYZadd[0]+$XYZadd[1];
    $XYZi[1] = $XYZadd[1]+$XYZadd[2];
    $XYZi[2] = $XYZadd[0]+$XYZadd[2];
    $iVc = 0;
    clear $TrackFoundN;
    if($AxisOrthoLineA ==2){
    $TwoPointsi[0] = 0;
    }
    if($AxisOrthoLineA ==1){
    $TwoPointsi[0] = 2;
    }
    if($AxisOrthoLineA ==0){
    $TwoPointsi[0] = 1;
    }
    $AXIS = $AxisOrthoLineA;
    clear $ALLlikeness;
    float $Dx,$Dy,$Dz;
    $i = 0;
    $Dist_3D = (($Dist_3D/3.0)*2.0);
    for ($each in $ALLLoc3D_Vec){
    $One = $ALLLoc3D_Vec[$i];
    $XY[0] = $Xx  = $One.x;
    $XY[1] = $Yy  = $One.y;
    $XY[2] = $Zz  = $One.z;
    if( $ReducedIndexXAB[$iVc]!= $NearestIndex ){
    $TriggerPoints=0;
    if( (equivalentTol($XYZadd[0], $Xx,  0.01) )==1){
    $All_X[$i] = $Xx;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[1], $Yy,  0.01) )==1){
    $All_Y[$i] = $Yy;
    $TriggerPoints++;
    }
    if( (equivalentTol($XYZadd[2], $Zz,  0.01) )==1){
    $All_Z[$i] = $Zz;
    $TriggerPoints++;
    }
    if( $TriggerPoints<2){
    $diffXYZ = `abs ($XY[$AXIS] - $XYZadd[$AXIS])`;
    if(($diffXYZ< $Dist_3DNear)&&($diffXYZ!=0)){
    $All_ZYX[`size($All_ZYX)`] =$XY[$AXIS];
    $All_ZYXDiff[`size($All_ZYXDiff)`] = $diffXYZ;
    }
    }
    if( $TriggerPoints==2){
    $ALLlikeness[`size($ALLlikeness)`] = $ReducedIndexXAB[$i];
    }
    }
    $i++;
    $iVc++;
    }
    if(`size($All_ZYXDiff)`> 0){
    $SortedForce = SortNumbersIntIndex($All_ZYXDiff);
    $newOrderFloat = $All_ZYX[$SortedForce[0]];
    }
    if(`size($ALLlikeness)`> 0){
    select -cl;
    for($eachIn in $ALLlikeness){
    select -add $AllarrayCurvesNear[$eachIn];
    PAUSE;
    }
    clear $NearPointsXYZ;
    $iVc =0;
    for($eachIn in $ALLlikeness){
    if( $iVc!= $NearestIndex ){
    $NearPointsXYZ[`size($NearPointsXYZ )`] =  $ALLLoc3D_VecAB[$eachIn];
    }
    $iVc++;
    }
    $distTo3DCurveEnd = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
    $Sorted = SortNumbersIntIndex($distTo3DCurveEnd);
    $NearPointsXYZ = NewVecOrderWithINTKey($Sorted,$NearPointsXYZ);
    clear $SdistTo3DCurveEnd;
    for($eachIn in $Sorted){
    $SdistTo3DCurveEnd[`size($SdistTo3DCurveEnd)`] = $distTo3DCurveEnd[$eachIn];
    }
    $ReducedIndex = floatArrayCountDuplicates($SdistTo3DCurveEnd);
    $ReducedVec = NewVecOrderWithINTKey($ReducedIndex,$NearPointsXYZ);
    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    $OntheSameLine = 0;
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $OntheSameLine =1;
    }
    $CountN = 0;
    for($eachVec in $ReducedVec){
    $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $eachVec);
    $VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
    $Additi = $VecLineDirMi ;
    $AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
    $Additi = $LineDirect_3D;
    $AdditiB = $DirLineCrossXYZi ;
    $AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
    if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
    $PointN_LineXYZ = $eachVec;
    print " on same Line ";
    }else{
    $PointN_LineXYZ  = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $eachVec);
    }
    if( (distance2Pts($PointN_LineXYZ, $PointN_LineC))>0.001){
    $LocsV[`size($LocsV)`] = `Loc $PointN_LineXYZ`;
    $CurvesV[`size($CurvesV)`] = curve2points($eachVec, $PointN_LineXYZ);
    PAUSE;
    }
    if($CountN==0){
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapN = $eachVec;
    $SnapPlaceN = $PointN_LineXYZ;
    }
    if($CountN!=0){
    print  $DistSnap;
    if((distance2Pts($PointN_LineXYZ, $PointN_LineC))<  $DistSnap){
    $SnapN = $eachVec;
    $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
    $SnapPlaceN = $PointN_LineXYZ;
    }
    }
    $CountN++;
    }
    $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);
    delete $CurvesV;
    delete $LocsV;
    if(($EulerAngleA[3] >85)&&($EulerAngleA[3]<95)){
    $Dist_3D = distance2Pts($PointN_LineC, $SnapPlaceN);
    if($Dist_3DSnap<($Dist_3D/2.0)){
    cycleBackgroundColor;
    PAUSE;
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    $AddInt = $AdditR;
    if($AddInt == 0){
    $PointN_LineC = $SnapPlaceN;
    PAUSE; PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }else{
    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $FPointN_LineC =  $PointN_LineC;
    $FPointN_LineC[$AXIS] = $newOrderFloat;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }
    }else{
    if(`size($All_ZYXDiff)`> 0){
    cycleBackgroundColor;
    PAUSE; PAUSE;
    cycleBackgroundColor;
    PAUSE; PAUSE;
    $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
    $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
    $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
    $VecLineDirM = ($DirLineAA-$DirLineBB);
    $Addit = $VecLineDirM ;
    $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
    print ("AdditR : "+$AdditR +"\n");
    $AddInt = $AdditR;
    if($AddInt == 0){
    print ("AdditR WENT THROUGHT: "+$AdditR +"\n");
    $PointN_LineC = $PointN_TEMP;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    cycleBackgroundColor;
    PAUSE;
    }
    }
    }
    $Points3DPair_And_2DPair[0]= $Loc3D_Vec[0];
    $Points3DPair_And_2DPair[1]= $PointN_LineC;
    $Points3DPair_And_2DPair[2]= $LocOnPlaneVec[0];
    $Points3DPair_And_2DPair[3]= $NewPlanePoint;
    delete $TempCrv;
    $CurvesV = curve2points($Loc3D_Vec[0], $PointN_LineC);
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 10 -d 3 -tol 0.05 $CurvesVi;
    $Crv_Pts = VecCurveEps($CurvesVi );
    $MirrorAcrossPlaneVecs = VecMultMatrixMirror($Crv_Pts);
    $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
    clear $StereoCurveZ;
    $BothCurves[0] = $CurvesVi;
    $BothCurves[1] = $TheSecondCurve;
    $StereoCurveZ = $BothCurves;
    $addNumbersA =-3;
    ResetTranslation($BothCurves);
    CurveIndexVecTracking($BothCurves);
    editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $BothCurves;
    evalVectorIndexAdditionSubtract;
    EVALCamScripts;
    clear $StereoCurveZ;
    }
    return $BothCurves;

}


/******************************************************************************
 * @procedure BBoxInfo2D
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $i (string)
 * @returns float[ ]
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc float[ ] BBoxInfo2D(string $i)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    float $test[] = `xform -query -ws -t`;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    float $bbInfo[5];
    select $i;
    PolySelectConvert 3;
    $test = `xform -query -ws -t`;
    $sizeTest = ((`size $test`) / 3);
    for ($a=1, $bbInfo[0] = $test[0], $bbInfo[3] = $test[0], $x=3, $bbInfo[1] = $test[1], $bbInfo[4] = $test[1], $y=4, $bbInfo[2] = $test[2], $bbInfo[5] = $test[2], $z=5; $a < $sizeTest; $a++)
    {
    $tempX = $test[$x];
    $x = $x + 3;
    $bbInfo[0] = `min $bbInfo[0] $tempX`;
    $bbInfo[3] = `max $bbInfo[3] $tempX`;
    $tempY = $test[$y];
    $y = $y + 3;
    $bbInfo[1] = `min $bbInfo[1] $tempY`;
    $bbInfo[4] = `max $bbInfo[4] $tempY`;
    $tempZ = $test[$z];
    $z = $z + 3;
    $bbInfo[2] = `min $bbInfo[2] $tempZ`;
    $bbInfo[5] = `max $bbInfo[5] $tempZ`;
    }
    return $bbInfo;

}


/******************************************************************************
 * @procedure GetNearest
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $Nn (int)
 *   $OneObject (string)
 *   $diff (string[])
 * @returns string []
 *
 * @dependencies ReverseFloatArray, ReverseStringArray, SortFloatArrayAndString
 *
 * @source working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string [] GetNearest(int $Nn, string $OneObject, string $diff[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $Indx = 0;
    int $iX = 0;
    float $pointA1[];
    float $distanceA[];
    float $pointA2[];
    float $NewfloatsX[];
    float $NewfloatsXi[] = ReverseFloatArray($NewfloatsX);
    string $objectList[] = $diff;
    string $EmptyStringX[];
    string $returnZi[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $objectList = $diff;
    $pointA1 = `xform -query -worldSpace - translation ($OneObject)`;
    clear  $distanceA;
    $Indx = 0;
    for ($eachZx in $objectList){
    if (catch($pointA2 = `xform -q -ws -t $objectList[$Indx]`)){
    $pointA2 = `pointPosition -w $objectList[$Indx]`;
    }

    $Indx++;
    $dAx = $pointA1[0] - $pointA2[0];
    $dAy = $pointA1[1] - $pointA2[1];
    $dAz = $pointA1[2] - $pointA2[2];
    $distanceA[`size($distanceA)`] = `sqrt( ($dAx * $dAx) + ($dAy * $dAy)  + ($dAz * $dAz) )`;
    }


    clear $EmptyStringX;
    $NewfloatsX = SortFloatArrayAndString($distanceA, $objectList, $EmptyStringX);
    $EmptyStringX = ReverseStringArray($EmptyStringX);
    $NewfloatsX = ReverseFloatArray($NewfloatsX);

    $iX = 0;
    while ($Nn > $iX){
    $returnZi[`size($returnZi)`] = $EmptyStringX[$iX];
    $iX++;
    }

    return $returnZi;

}


/******************************************************************************
 * @procedure CircNormal
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $eachCirV (string)
 * @returns float []
 *
 * @dependencies Normal3Points
 *
 * @source working GRAMSCANN!!! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc float [] CircNormal(string $eachCirV)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    float $FloatDirNormalCurveA[] = Normal3Points($worldPosA, $FloatPointA, $FloatPointB);

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────


    string $PointA[], $PointB[];
    float $FloatPointA[], $FloatPointB[], $worldPosA[];

    $PointA = `ls -fl ($eachCirV+".ep[0]")`;
    $PointB = `ls -fl ($eachCirV+".ep[3]")`;
    $FloatPointA = `pointPosition -w  $PointA `;
    $FloatPointB = `pointPosition -w  $PointB`;
    $worldPosA = `xform -q -ws -a -rp $eachCirV`;
    $FloatDirNormalCurveA = Normal3Points($worldPosA, $FloatPointA, $FloatPointB);
    return $FloatDirNormalCurveA;

}


/******************************************************************************
 * @procedure NewVecOrderEllipZ
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $NewOneCurveS (string)
 *   $EmptyVectorArrayA (vector[])
 *   $MidEpipolPosFCam (float[])
 * @returns int []
 *
 * @dependencies FloatToVec, ReverseIntArray, MostRightClockWiseInt, VAnglesofThreeVec, FindDirectionDiff
 *                (+3 more)
 *
 * @source MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int [] NewVecOrderEllipZ(string $NewOneCurveS, vector $EmptyVectorArrayA[], float $MidEpipolPosFCam[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $IndexTrackE[];
    int $TwoZeroOne[] = {0,1};
    int $TwoZeroOneG[] = {0,1};
    int $TFmostRArray[];
    int $LargestIntR_KEY[];
    int $LargestIntL_KEY[];
    int $COUNT_Nlr = 0;
    int $LargestIntR[] = SortNumbersIntIndex($AllAngiX_RIGHT);
    int $LargestIntL[] = SortNumbersIntIndex($AllAngiX_LEFT);
    int $NewStartInt = $LargestIntL_KEY[$LargestIntL[0]];
    int $SizeE = `size($EmptyVectorArrayA)`;
    int $NewArrayInt;
    int $NewArrayIntX[];
    int $Add = 0;
    float $EllipesPos_A[];
    float $allAngiX[];
    float $DIff;
    float $AllAngiX_RIGHT[];
    float $AllAngiX_LEFT[];
    vector $Dir_VecMAIN;
    vector $threeVecs[];
    vector $threeVecsG[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $EllipesPos_A = `xform -q -ws -t $NewOneCurveS`;
    $Dir_VecMAIN =  DirectionFN($MidEpipolPosFCam, $EllipesPos_A);
    $IndexTrackE = CreateIntIndex(`size($EmptyVectorArrayA)`);

    $TwoZeroOne = {0,1};
    $TwoZeroOne = {0,1};
    clear $allAngiX; clear $TFmostRArray;
    $threeVecs[0] = FloatToVec($MidEpipolPosFCam);
    $threeVecs[1] = FloatToVec($EllipesPos_A);

    for($EachVector in $EmptyVectorArrayA){

    $DIff = FindDirectionDiff($Dir_VecMAIN, $MidEpipolPosFCam, $EachVector);
    if($DIff!= 0){
    $allAngiX[`size($allAngiX)`]=  VAnglesofThreeVec($MidEpipolPosFCam, $EllipesPos_A, $EachVector);
    $threeVecs[2] = $EachVector;
    $TFmostRArray[`size($TFmostRArray)`] = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);

    }else{ $allAngiX[`size($allAngiX)`]= 0;  $TFmostRArray[`size($TFmostRArray)`] =0;}

    }

    //print  $allAngiX;
    //print  $TFmostRArray;

    clear $LargestIntR_KEY;
    clear $LargestIntL_KEY;
    clear $AllAngiX_LEFT;
    clear $AllAngiX_RIGHT;
    $COUNT_Nlr = 0;
    for($EachIntarray in $TFmostRArray){
    if($EachIntarray==1){
    $AllAngiX_RIGHT[`size($AllAngiX_RIGHT)`]= $allAngiX[$COUNT_Nlr];
    $LargestIntR_KEY[`size($LargestIntR_KEY)`]=$COUNT_Nlr;
    }
    if($EachIntarray==0){
    $AllAngiX_LEFT[`size($AllAngiX_LEFT)`]= $allAngiX[$COUNT_Nlr];
    $LargestIntL_KEY[`size($LargestIntL_KEY)`]=$COUNT_Nlr;
    }
    $COUNT_Nlr++;
    }

    $LargestIntR = SortNumbersIntIndex($AllAngiX_RIGHT);
    $LargestIntR = ReverseIntArray($LargestIntR);
    // Loc $EmptyVectorArrayA[$LargestIntR_KEY[$LargestIntR[0]]];
    $LargestIntL = SortNumbersIntIndex($AllAngiX_LEFT);
    $LargestIntL = ReverseIntArray($LargestIntL);
    // Loc $EmptyVectorArrayA[$LargestIntL_KEY[$LargestIntL[0]]];

    print $LargestIntR_KEY[$LargestIntR[0]];
    print $LargestIntL_KEY[$LargestIntL[0]];
    // Loc $EmptyVectorArrayA[$LargestIntL_KEY[$LargestIntL[0]]];
    // test
    $NewStartInt = $LargestIntL_KEY[$LargestIntL[0]];
    //  $IndexTrackE
    $SizeE = `size($EmptyVectorArrayA)`;
    $Add = 0;
    for($EachIntX in $IndexTrackE){
    $NewArrayIntX[`size($NewArrayIntX)`] = fmod(($NewStartInt+$Add),$SizeE);
    $Add++;
    }
    Loc $EmptyVectorArrayA[$NewArrayIntX[0]];
    Loc $EmptyVectorArrayA[$NewArrayIntX[12]];
    curve2points($EmptyVectorArrayA[$NewArrayIntX[0]],$EllipesPos_A);
    curve2points($EmptyVectorArrayA[$NewArrayIntX[0]],$EmptyVectorArrayA[$NewArrayIntX[12]]);
    $threeVecsG[0] = $EmptyVectorArrayA[$NewArrayIntX[0]];
    $threeVecsG[1] = FloatToVec($EllipesPos_A);
    $threeVecsG[2] = $EmptyVectorArrayA[$NewArrayIntX[12]];
    $MostRL_Int = MostRightClockWiseInt ($threeVecsG, $TwoZeroOneG);
    return $NewArrayIntX;


}


/******************************************************************************
 * @procedure SimpleEllipse3Pts
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $TestCurveC (string)
 *   $EmptyVectorArray (vector[])
 * @returns string
 *
 * @dependencies FloatToVec, DirectionFN, SortNumbersIntIndex, CurvatureUtility
 *
 * @source MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string SimpleEllipse3Pts(string $TestCurveC, vector $EmptyVectorArray[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $TrackC[];
    int $Mini[];
    int $NewIndexAi[];
    int $MidAngle = (`size($NewIndexAi)`-1)/2;
    int $xc = 0;
    int $findLowestGroup[];
    int $Pastint;
    int $ChangeOver;
    int $Sub;
    float $CIrceP[];
    float $DPiMidi = distance2Pts($CurveCollectVec[$NewIndexAi[0]],$AverageVecCurve);
    float $FloatDirMA[] = DirectionFN($AverageVecCurve,$CurveCollectVec[$NewIndexAi[0]]);
    float $LowestAngle = $angleZii[$NewIndexAi[0]];
    float $MiddleAngle = $angleZii[$NewIndexAi[$MidAngle]];
    float $HighestAngle = $angleZii[$NewIndexAi[`size($NewIndexAi)`-1]];
    float $AvAllangles = ($LowestAngle+$MiddleAngle+$HighestAngle)/3.0;
    float $eachAi;
    string $NewCurveE[] = `ls -sl`;
    vector $CurveCollectVec[];
    vector $MidVecDir = FloatToVec($FloatDirMA);
    vector $AveVec = FloatToVec($AverageVecCurve);
    vector $NewPvec;
    vector $ThreeEllipVecP[];
    vector $NewEllipesCurve[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $CIrceP = `xform -q -ws -t $TestCurveC`;
    $AverageVecCurve =$CIrceP;

    float $AddedCurvA, $angleZii[];
    clear $angleZii;  clear $CurveCollectVec;
    $CurveCollectVec = CurvatureUtility($TestCurveC, 3, $angleZii, $TrackC, $AddedCurvA);

    clear $NewIndexAi;
    $NewIndexAi  = SortNumbersIntIndex($angleZii);
    //##
    curve2points($CurveCollectVec[$NewIndexAi[0]],$AverageVecCurve);

    $DPiMidi = distance2Pts($CurveCollectVec[$NewIndexAi[0]],$AverageVecCurve);
    $FloatDirMA = DirectionFN($AverageVecCurve,$CurveCollectVec[$NewIndexAi[0]]);
    $MidVecDir = FloatToVec($FloatDirMA);
    $AveVec = FloatToVec($AverageVecCurve);
    $NewPvec = ($MidVecDir * $DPiMidi)+ $AveVec;
    // the three vectors needed to make the ellipse
    //$CurveCollectVec[$NewIndexAi[0]] , $NewPvec and any point one curve (close to first vec)
    $MidAngle = (`size($NewIndexAi)`-1)/2;
    $LowestAngle = $angleZii[$NewIndexAi[0]];
    $MiddleAngle = $angleZii[$NewIndexAi[$MidAngle]];
    $HighestAngle = $angleZii[$NewIndexAi[`size($NewIndexAi)`-1]];
    $AvAllangles = ($LowestAngle+$MiddleAngle+$HighestAngle)/3.0;
    $xc = 0;
    clear $findLowestGroup;
    for($eachAi in $angleZii){
    if($eachAi< $AvAllangles){
    $findLowestGroup[`size($findLowestGroup)`]=$xc;
    Loc  $CurveCollectVec[$xc];
    }
    $xc++;
    }

    $findLowestGroup = `sort $findLowestGroup`;
    $xc =0;
    for($eachInt in $findLowestGroup){
    if($xc>0){
    $Sub =$eachInt -$Pastint;
    if(($eachInt -$Pastint)> 3){
    $ChangeOver =  $Pastint;
    Loc  $CurveCollectVec[$ChangeOver];
    }
    }
    $Pastint = $eachInt;
    $xc++;
    }


    // the three vectors needed to make the ellipse
    //$CurveCollectVec[$NewIndexAi[0]] , $NewPvec and any point one curve (close to first vec)
    //$CurveCollectVec[$NewIndexAi[0]] , $NewPvec, $CurveCollectVec[$ChangeOver];

    $ThreeEllipVecP[0] = $CurveCollectVec[$NewIndexAi[0]] ;
    $ThreeEllipVecP[1] = $NewPvec;
    $ThreeEllipVecP[2] = $CurveCollectVec[$ChangeOver];

    $NewEllipesCurve = calculateEllipseCurve($ThreeEllipVecP, 300);
    $NewCurveE = `ls -sl`;
    $EmptyVectorArray = $NewEllipesCurve;

    return $NewCurveE[0];

}


/******************************************************************************
 * @procedure CurvatureUtility
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $curvesZ (string)
 *   $NumberofSteps (int)
 *   $curvature (float[])
 *   $C (int[])
 *   $TotalCA (float)
 * @returns vector []
 *
 * @dependencies SortNumbersIntIndex
 *
 * @source MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc vector [] CurvatureUtility(string $curvesZ, int $NumberofSteps, float $curvature[], int $C[], float $TotalCA)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $ii = 0;
    int $numEPs = size ($CurveSelection);
    int $numEPrealNum = ( $numEPs -1 );
    int $NewIndexN[];
    float $step = $NumberofSteps;
    float $CRVRadi[];
    float $CIrceP[];
    float $DistanceS[];
    string $myCurve = $curvesZ;
    string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
    string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`;
    string $CurveEPzCount = size ($CurveSelection);
    vector $CurveVectors[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    global int $SortDistanceIntG;
    $step = $NumberofSteps;
    $myCurve = $curvesZ;
    $ii = 0;
    float $a ,$t, $TotalCAX, $values[];
    $TotalCAX =0;
    $t=0.0;
    $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;


    $CurveSelection = `ls -fl  ($myCurve+".ep[0:*]")`;
    $CurveEPzCount = size ($CurveSelection);
    $numEPs = size ($CurveSelection);
    $numEPrealNum = ( $numEPs -1 );

    $CIrceP = `xform -q -ws -t $curvesZ`;
    for($a = 0.0; $t < $numEPrealNum;$a++){

    $t =  $a/$step;
    setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
    $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
    $CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
    $CRVRadi[$ii] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;



    $DistanceS[$ii] = distance2Pts($values,$CIrceP);

    $ii++;
    }
    $NewIndexN = SortNumbersIntIndex($DistanceS);
    $SortDistanceIntG = $NewIndexN[0];
    delete $paramlocatorpointOnCurvex;

    for($eachCURVA in $CRVRadi){
    $TotalCAX +=  $eachCURVA;
    }
    $TotalCA = $TotalCAX;
    $curvature = $CRVRadi;
    return $CurveVectors;

}


/******************************************************************************
 * @procedure be_plot_locators
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $curve (string)
 * @returns string[]
 *
 * @source Workin TangentSSs (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

global proc string[] be_plot_locators(string $curve)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    float $u;
    float $span = 0.1;
    float $maxU = `getAttr ( $curve + ".maxValue" )`;
    string $locator[];
    string $AllLocatorZi[];
    vector $tan;
    vector $norm;
    vector $bi;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    float $p[3];
    float $t[3];
    float $n[3];
    matrix $m[4][4] = << 1.0, 0.0, 0.0, 0.0;
    0.0, 1.0, 0.0, 0.0;
    0.0, 0.0, 1.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;

    $span = 0.1;
    $maxU = `getAttr ( $curve + ".maxValue" )`;
    for ( $u = 0.0; $u <= $maxU; $u += $span )
    {
    // Query the position,
    //tangent and normal.
    //
    //-p: -position  -position(-p)
    //nn: -normalizedNormal
    //nt: -normalizedTangent


    $p = `pointOnCurve -ch off -pr $u -p $curve`;
    //$t is just a direction....
    $t = `pointOnCurve -ch off -pr $u -nt $curve`;
    $n = `pointOnCurve -ch off -pr $u -nn $curve`;

    // Translational coordinates in a Maya matrix are always represented
    // in Maya's internal units. Convert position to (cm) units.
    $p[0] = linearToInternal( $p[0] );
    $p[1] = linearToInternal( $p[1] );
    $p[2] = linearToInternal( $p[2] );

    // Maya promises normalized tangent and normal,
    // but they really aren't.
    //
    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
    $norm = `unit << $n[0], $n[1], $n[2] >>`;

    // Calculate the binormal.
    //
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
    << ($norm.x), ($norm.y), ($norm.z) >>`;

    // Normalize our vector.
    //
    $bi = `unit $bi`;

    // Create a matrix, using normal for the X axis and
    // tangent for the Z axis.
    //
    $m = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
    ($bi.x),   ($bi.y),   ($bi.z),   0.0;     // Y axis
    ($tan.x),  ($tan.y),  ($tan.z),  0.0;     // Z axis
    $p[0],     $p[1],     $p[2],     1.0 >>;  // Position

    // Create a locator and assign its world-space matrix.
    //curve -d 1 -p -0.0870275 0 0.00556599 -p 0 0 5 -k 0 -k 4.995192 ;
    $locator[0] = `curve -d 1 -p -0.0870275 0 0.00556599 -p 0 0 5 -k 0 -k 4.995192`;
    //$locator = `spaceLocator`;
    appendAll($AllLocatorZi, $locator);


    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $locator[0];


    }
    return $AllLocatorZi;

}


/******************************************************************************
 * @procedure BBoxInfo2DHW
 * @category  transform
 * @layer     affine (GL(4,R))
 * @description Transformation operations
 *
 * @parameters
 *   $Ii (string)
 *   $H_W (float[])
 * @returns vector
 *
 * @source THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc vector BBoxInfo2DHW(string $Ii, float $H_W[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    float $DistW = distance2Pts( $AW, $BW);
    float $DistH = distance2Pts( $AH, $BH);
    vector $AW = <<$bbInfo[0], $bbInfo[1], $bbInfo[2]>>;
    vector $BW = <<$bbInfo[3], $bbInfo[4], $bbInfo[2]>>;
    vector $AH = <<$bbInfo[0], $bbInfo[1], $bbInfo[2]>>;
    vector $BH = <<$bbInfo[0], $bbInfo[4], $bbInfo[5]>>;
    vector $Mid = ($BW + $BH )/2.0;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    print " BBoxInfo2DHW " ; print "line 556 "; print "\n" ;
    float $bbInfo[5];
    $bbInfo =`xform -query -bb $Ii`;
    $AW = <<$bbInfo[0], $bbInfo[1], $bbInfo[2]>>;
    $BW = <<$bbInfo[3], $bbInfo[4], $bbInfo[2]>>;
    $DistW = distance2Pts( $AW, $BW);
    $AH = <<$bbInfo[0], $bbInfo[1], $bbInfo[2]>>;
    $BH = <<$bbInfo[0], $bbInfo[4], $bbInfo[5]>>;
    $DistH = distance2Pts( $AH, $BH);
    $H_W[0]=$DistW;
    $H_W[1]=$DistH;
    $Mid = ($BW + $BH )/2.0;
    return  $Mid ;

}

