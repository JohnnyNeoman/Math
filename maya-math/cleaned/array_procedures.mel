/******************************************************************************
 * ARRAY PROCEDURES
 *
 * Category: array
 * Procedure Count: 68
 *
 * This file contains cleaned and annotated MEL procedures.
 * All variable declarations have been moved to the start of each procedure.
 *
 * Mathematical Layers:
 *   - utility: Data
 *
 * Generated by cleanup_mel_scripts.py
 ******************************************************************************/


/******************************************************************************
 * @procedure ReverseStringArrayZ
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $array (string[])
 * @returns string[]
 *
 * @source ReverseStringArrayZ (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string[] ReverseStringArrayZ(string $array[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    string $arrayOut[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    for($i=0;$i<size($array);$i++){
    $arrayOut[$i]=$array[(size($array)-1-$i)]; }
    return $arrayOut;

}


/******************************************************************************
 * @procedure stringArrayMatchToArray
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $item (string)
 *   $list (string[])
 * @returns string[]
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

global proc string[] stringArrayMatchToArray(string $item, string $list[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $resultZ = false;
    int $sizeMatchedItems = `size($matchedItem)`;
    int $matchedBlankN = isValidString($matchedItem[0], "([a-zA-Z]+)([a-zA-Z0-9_])*");
    string $FoundMatchedItem[];
    string $MatchedItem[];
    string $OneiteminArrayList = $each;
    string $matchedItem[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $resultZ = false;
    for ($each in $list) {
    $OneiteminArrayList = $each;
    $matchedItem = {`match $item $OneiteminArrayList `};
    $sizeMatchedItems = `size($matchedItem)`;
    $matchedBlankN = isValidString($matchedItem[0], "([a-zA-Z]+)([a-zA-Z0-9_])*");
    if (($sizeMatchedItems >  0) && ($matchedBlankN > 0)){
    $resultZ = true;
    if ($resultZ == true ){ $FoundMatchedItem[0] = ($OneiteminArrayList); }
    break;	}
    }
    return  $FoundMatchedItem;

}


/******************************************************************************
 * @procedure FindifArraysContain
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $FirstList (string[])
 *   $array2 (string[])
 * @returns int
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

global proc int FindifArraysContain(string $FirstList[], string $array2[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $found;
    int $Trigger;
    string $oneItemz = $each;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    for ($each in $FirstList){
    $oneItemz = $each;
    $found = stringArrayContains($oneItemz, $array2);
    if ( $found == 1 ){ $Trigger = 1; break; }
    }
    return $Trigger;

}


/******************************************************************************
 * @procedure stringArrayGmatchIndex
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $itemA (string[])
 *   $list (string[])
 * @returns int
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

global proc int stringArrayGmatchIndex(string $itemA[], string $list[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $result = false;
    int $ResultIndex = 0;
    int $Index = 0;
    string $item = $itemA[0];
    string $listItem;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $item = $itemA[0];
    $result = false;
    $ResultIndex = 0;
    $Index = 0;
    for ($EachlistItem in $list) {
    if ( $EachlistItem == $item ){
    $result = true; $ResultIndex =  $Index;
    break;	}
    $Index++;
    }
    return $ResultIndex;

}


/******************************************************************************
 * @procedure SortEvenArrays
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $ArrayItems (string[])
 * @returns string[]
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

global proc string[] SortEvenArrays(string $ArrayItems[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $getsize = size($ArrayItems);
    int $i = 0;
    string $newItemsList[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $getsize = size($ArrayItems);
    $i = 0;
    $iX = 0;
    while($i < $getsize){
    $iX++;
    if ( $iX == 2){
    string $oneitem[0] = {$ArrayItems[$i]};
    appendStringArray($newItemsList, $oneitem, 1);
    $iX = 0;
    }
    $i++;
    }
    return $newItemsList;

}


/******************************************************************************
 * @procedure ArrayFromAllinString
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $list (string)
 * @returns string[]
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

global proc string[] ArrayFromAllinString(string $list)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $i = 0;
    int $Indexi = 0;
    int $triggerends = 0;
    string $singleStringItemB[];
    string $singleStringItemA[];
    string $listA = $list;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────


    $i = 0;
    $Indexi = 0;
    $triggerends = 0;
    $listA = $list;
    while ( $triggerends < 1 ) {
    $i++;
    $singleStringItemA = {`substring $listA $i $i`};
    if (size($singleStringItemA[0]) == 0){
    $triggerends = 2; } else {
    appendStringArray($singleStringItemB,  $singleStringItemA, 1);
    }
    $Indexi++;
    if ($Indexi == 20){ $triggerends = 2;}
    }
    return $singleStringItemB;

}


/******************************************************************************
 * @procedure ArrayToIntList
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $singleStringItemB (string[])
 * @returns int[]
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

global proc int[] ArrayToIntList(string $singleStringItemB[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $Numberlist[];
    int $triggerendsB = 0;
    int $newlistSize = size($singleStringItemB);
    int $ci = 0;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $triggerendsB = 0;
    $newlistSize = size($singleStringItemB);
    $ci = 0;
    while ( $triggerendsB < $newlistSize ) {
    $Numberlist[$ci] = $singleStringItemB[$ci];
    $ci++;
    $triggerendsB = $triggerendsB + 1;
    }
    print $Numberlist;
    return $Numberlist;

}


/******************************************************************************
 * @procedure SortPatternArrays
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $ArrayItems (string[])
 *   $NumberlistA (int[])
 * @returns string[]
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string[] SortPatternArrays(string $ArrayItems[], int $NumberlistA[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $getsizeNlist = size($NumberlistA);
    int $iN = 0;
    int $getsize = size($ArrayItems);
    int $i = 0;
    string $newItemsList[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────


    $getsizeNlist = size($NumberlistA);
    $iN = 0;
    $getsize = size($ArrayItems);
    $i = 0;
    $iX = 0;
    while($i < $getsize){
    $iX++;
    if ( $NumberlistA[$iN] == 0){
    string $oneitem[0] = {$ArrayItems[$i]};
    appendStringArray($newItemsList, $oneitem, 1);
    if ( $iN == $getsizeNlist){ $iN = -1;}
    $iX = 0;
    }

    $iN++;
    $i++;
    }
    return $newItemsList;

}


/******************************************************************************
 * @procedure SortEvenArraysInt
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $ArrayItems (string)
 *   $Num (int)
 * @returns string[]
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string[] SortEvenArraysInt(string $ArrayItems, int $Num)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $getsize = size($ArrayItems);
    int $i = 0;
    string $newItemsList[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────


    $getsize = size($ArrayItems);
    $i = 0;
    $iX = 0;
    while($i < $getsize){
    $iX++;
    if ( $Num == 2){
    if ( $iX == 2){
    string $oneitem[0] = {$ArrayItems[$i]};
    appendStringArray($newItemsList, $oneitem, 1);
    $iX = 0;
    }
    }

    if ( $Num == 1){
    if ( $iX == 1){
    string $oneitem[0] = {$ArrayItems[$i]};
    appendStringArray($newItemsList, $oneitem, 1);
    }
    if ( $iX == 2){ $iX = 0;}
    }

    $i++;
    }
    return $newItemsList;

}


/******************************************************************************
 * @procedure ArrayInsertAtEnd
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $INarray (string[])
 *   $NewItem (string)
 * @returns int
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int ArrayInsertAtEnd(string $INarray[], string $NewItem)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $SizeOfArray;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $SizeOfArray = size($INarray);
    $INarray[$SizeOfArray] = ( $NewItem );
    return $SizeOfArray;

}


/******************************************************************************
 * @procedure stringArrayGmatch
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $item (string)
 *   $list (string[])
 * @returns int
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int stringArrayGmatch(string $item, string $list[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $result = false;
    string $listItem;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $result = false;
    for ($listItem in $list) {
    if ( `gmatch $listItem $item` ==  1){
    $result = true;
    break;	}
    }
    return $result;

}


/******************************************************************************
 * @procedure NearestObjectArray
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $n (int)
 *   $ItemsSelectedinArray (string[])
 * @returns string[]
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string[] NearestObjectArray(int $n, string $ItemsSelectedinArray[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $NearestObjectN = $n;
    int $indexN = 0;
    int $NearestObjectNumbers = $NearestObjectN;
    int $array1Number = $array1Count;
    int $curvenumbers = $CompareAllShapesCount;
    float $pointA1[];
    float $pointA2[];
    float $distanceA;
    float $pointB1[];
    float $pointB2[];
    float $distanceB;
    string $NearestCurvesZ[];
    string $array1[] = $ItemsSelectedinArray;
    string $array2[] = $ItemsSelectedinArray;
    string $arrayMainObject1[] = $ItemsSelectedinArray;
    string $array1Count = size ($array1) -1;
    string $diff[] = stringArrayRemoveExact($array1,  $arrayMainObject1);
    string $CompareAllShapesCount = size ($array1);
    string $oneitem[];
    string $arrayLast[] = stringArrayRemoveExact ($oneitem, $arrayMainObject1);
    string $array1[];
    string $array2[];
    string $arrayMainObject1[];
    string $return[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $NearestObjectN = $n;
    $numIntx = size($NearestCurvesZ);
    if ( $numIntx > 0 ){
    clear $NearestCurvesZ;
    }
    $array1 = $ItemsSelectedinArray;
    $array2 = $ItemsSelectedinArray;
    $arrayMainObject1 = $ItemsSelectedinArray;
    string $ArrayTwoObjectX[0];
    $indexN = 0;
    $NearestObjectN = $NearestObjectN;
    $ObjN = -1;
    $ObjN2 = 0;
    while($ObjN++ < $NearestObjectNumbers ){
    $array1 = size ($array1) -1;
    $array1Number = $array1Count;
    stringArrayRemoveAtIndex($array1Count, $array1);
    $diff = stringArrayRemoveExact($array1,  $arrayMainObject1);
    $CompareAllShapesCount = size ($array1);
    $curvenumbers = $CompareAllShapesCount;
    $i = 1;
    while($i++ < $curvenumbers ){
    //DISTANCE A
    $pointA1 = `xform -query -worldSpace - translation ( $diff)`;
    $pointA2 = `xform -query -worldSpace - translation ($array1[0])`;
    $dAx = $pointA1[0] - $pointA2[0];
    $dAy = $pointA1[1] - $pointA2[1];
    $dAz = $pointA1[2] - $pointA2[2];
    $distanceA = `sqrt( ($dAx * $dAx) + ($dAy * $dAy)  + ($dAz * $dAz) )`;
    //DISTANCE B
    $pointB1 = `xform -query -worldSpace - translation ( $diff)`;
    $pointB2 = `xform -query -worldSpace - translation ( $array1[1])`;
    $dBx = $pointB1[0] - $pointB2[0];
    $dBy = $pointB1[1] - $pointB2[1];
    $dBz = $pointB1[2] - $pointB2[2];
    $distanceB = `sqrt( ($dBx * $dBx) + ($dBy * $dBy)  + ($dBz * $dBz) )`;
    if( $distanceA < $distanceB ){
    stringArrayRemoveAtIndex(1, $array1);
    }
    if( $distanceA > $distanceB ){
    stringArrayRemoveAtIndex(0, $array1);
    }
    }
    appendStringArray($NearestCurvesZ, $array1, 1);
    $oneitem[0] = $array1[0];
    $arrayLast = stringArrayRemoveExact ($oneitem, $arrayMainObject1);
    $array1 = $arrayLast;
    $array2 = $arrayLast;
    $arrayMainObject1 = $arrayLast;
    $indexN++;
    stringArrayInsertAtIndex(($indexN),  $ArrayTwoObjectX, $arrayLast[0]);
    }
    clear $array1;
    clear $array2;
    clear $arrayMainObject1;
    $return = $NearestCurvesZ;
    return $return;

}


/******************************************************************************
 * @procedure SecondArrayInsertAtEndofArray
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $INarray (string[])
 *   $NewItem (string[])
 * @returns int
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int SecondArrayInsertAtEndofArray(string $INarray[], string $NewItem[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $SizeOfArray;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $SizeOfArray = size($INarray);
    $INarray[$SizeOfArray] = ( $NewItem[0] );
    return $SizeOfArray;

}


/******************************************************************************
 * @procedure RemoveNoLongerExistingFromArray
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $EdgeCurveZ1 (string[])
 * @returns string[]
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string[] RemoveNoLongerExistingFromArray(string $EdgeCurveZ1[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $SizeOfArrayA = size($EdgeCurveZ1);
    int $SizeOfArray = size($EdgeCurveZ1) -1;
    int $i = -1;
    int $E = -1;
    int $SizeOfArrayB = size($EdgeCurveZ1);

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $SizeOfArrayA = size($EdgeCurveZ1);
    if ( $SizeOfArrayA > 0){
    $SizeOfArray = size($EdgeCurveZ1) -1;
    $i = -1;
    $E = -1;
    while( $E < $SizeOfArray ){
    $i++;
    $E++;

    if ( `objExists $EdgeCurveZ1[$i]` == 0  ) {
    stringArrayRemoveAtIndex($i, $EdgeCurveZ1);
    if ($i == 0) { $i = -1;} else { $i = $i -1;}
    }

    }
    print $EdgeCurveZ1;
    $SizeOfArray = size($EdgeCurveZ1);
    }
    return $EdgeCurveZ1;

}


/******************************************************************************
 * @procedure stringArrayMatch
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $item (string)
 *   $list (string[])
 * @returns int
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int stringArrayMatch(string $item, string $list[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $result = false;
    string $listItem;
    string $listMatch;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $result = false;
    for ($listItem in $list) {
    $listMatch = `match $item $listItem`;
    if ( size($listMatch) > 0){
    $result = true; break; }
    }
    return $result;

}


/******************************************************************************
 * @procedure stringArrayGmatchToArray
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $item (string)
 *   $list (string[])
 * @returns string[]
 *
 * @source Circle Part Working (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

global proc string[] stringArrayGmatchToArray(string $item, string $list[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $result = false;
    string $listItem;
    string $MatchedItem[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $result = false;
    for ($listItem in $list) {
    if ( `gmatch $listItem $item` ==  1){
    $result = true;
    if ($result == true ){ $MatchedItem =  {$listItem};}
    break;	}
    }
    return $MatchedItem;

}


/******************************************************************************
 * @procedure ArcLengthArray
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $Objs (string[])
 * @returns float []
 *
 * @source the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc float [] ArcLengthArray(string $Objs[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    float $ArcLengths[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    for($each in $Objs){
    $ArcLengths[`size($ArcLengths)`]= `arclen $each`;
    }
    return $ArcLengths;

}


/******************************************************************************
 * @procedure PointArrayT
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $ObjectList (string[])
 * @returns vector[]
 *
 * @source the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc vector[] PointArrayT(string $ObjectList[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $XiV = 0;
    float $pointAZ1[];
    vector $VecArray[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────


    $XiV = 0;
    for ($each in $ObjectList){
    if (catch($pointAZ1 = `xform -q -ws -t ($each)`)){
    $pointAZ1 = `pointPosition -w ($each)`;
    }
    $VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
    $XiV++;
    }
    return $VecArray;

}


/******************************************************************************
 * @procedure PointArray
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $ObjectList (string[])
 * @returns vector[]
 *
 * @source the real Tangent Circle Proc (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc vector[] PointArray(string $ObjectList[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $XiV = 0;
    float $pointAZ1[];
    vector $VecArray[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────


    $XiV = 0;
    for ($each in $ObjectList){
    if (catch($pointAZ1 = `pointPosition -w ($each)`)){
    $pointAZ1 = `xform -q -ws - rp ($each)`;
    }
    $VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
    $XiV++;
    }
    return $VecArray;

}


/******************************************************************************
 * @procedure VecArrayDiff
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $IndeXxz (int[])
 * @returns vector []
 *
 * @source ThreePointCircle_TriangulationSTarting to work! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc vector [] VecArrayDiff(int $IndeXxz[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $Ixx = 0;
    int $EIndex[];
    int $Ii = 0;
    int $one;
    vector $VecS[] = $AllVecsG;
    vector $newVec[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    global vector $AllVecsG[];
    global vector $WorkingAllVecsG[];
    $VecS = $AllVecsG;
    $Ixx = 0;
    $EIndex = $IndeXxz;
    $EIndex = `sort $EIndex`;
    $Ii = 0;
    for ($eachVc in $VecS){
    $one =$EIndex[$Ii];
    if(!($Ixx==$one)){
    $newVec[`size($newVec)`] = $VecS[$Ixx];
    }else{$Ii++;}
    $Ixx++;
    }
    $WorkingAllVecsG = $newVec;
    return $newVec;

}


/******************************************************************************
 * @procedure IntArrayDiff
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $IndeXxI (int[])
 * @returns int []
 *
 * @source ThreePointCircle_TriangulationSTarting to work! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int [] IntArrayDiff(int $IndeXxI[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $VecS[];
    int $newInt[];
    int $Ix = 0;
    int $ii = 0;
    int $Ixi = 0;
    int $IndeXxz[];
    int $size = `size($IndeXxI)`-1;
    vector $VecSXX[];
    vector $newVec[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    global int $IndexPtsG[];
    global int $WorkingIndexPtsG[];
    global vector $AllVecsG[];
    global vector $WorkingAllVecsG[];
    $VecS= $IndexPtsG;
    $VecSXX = $AllVecsG;
    $Ix = 0;
    $ii = 0;
    $Ix = 0;
    $IndeXxz = `sort $IndeXxI`;
    $size = `size($IndeXxI)`-1;
    for ($eachVc in $VecS){
    if(($Ix != $IndeXxz[$Ixi])&&($eachVc != -2)){
    $newInt[`size($newInt)`] = $Ix;
    $newVec[`size($newVec)`] = $Ix;
    }else{$Ixi++; if( $Ix > `size($IndeXxz)`){break;}
    }
    $Ix++;
    }
    $WorkingIndexPtsG= $newInt;
    $WorkingAllVecsG = $newVec;
    return $newInt;

}


/******************************************************************************
 * @procedure VecArrayInclude
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $IndeXxz (int[])
 * @returns vector []
 *
 * @source ThreePointCircle_TriangulationSTarting to work! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc vector [] VecArrayInclude(int $IndeXxz[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $Ixx = 0;
    int $EIndex[];
    int $Ii = 0;
    int $one;
    vector $VecS[] = $AllVecsG;
    vector $newVec[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    global vector $AllVecsG[];
    global vector $WorkingAllVecsG[];
    $VecS = $AllVecsG;
    $Ixx = 0;
    $EIndex = $IndeXxz;
    $EIndex = `sort $EIndex`;
    $Ii = 0;
    for ($eachVc in $VecS){
    $one =$EIndex[$Ii];
    if(($Ixx==$one)){
    $newVec[`size($newVec)`] = $VecS[$Ixx];
    }else{$Ii++;}
    $Ixx++;
    }
    $WorkingAllVecsG = $newVec;
    return $newVec;

}


/******************************************************************************
 * @procedure IntArrayInc
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $VecS (int[])
 *   $IndeXxI (int[])
 * @returns int []
 *
 * @source ThreePointCircle_TriangulationSTarting to work! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int [] IntArrayInc(int $VecS[], int $IndeXxI[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $newInt[];
    int $Ix = 0;
    int $ii = 0;
    int $Ixi = 0;
    int $IndeXxz[];
    int $size = `size($IndeXxI)`-1;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $Ix = 0;
    $ii = 0;
    $Ix = 0;
    $IndeXxz = `sort $IndeXxI`;
    $size = `size($IndeXxI)`-1;
    for ($eachVc in $VecS){
    if($VecS[$ii]>$IndeXxz[$Ixi]){
    if($size==$Ixi){$Ixi=0;}
    $Ixi++;
    }
    if(($eachVc== $IndeXxz[$Ixi])){
    $newInt[`size($newInt)`] = $eachVc;
    $ii=$Ix;
    }else{$Ixi++;}
    $Ix++;
    }
    return $newInt;

}


/******************************************************************************
 * @procedure IntArrayInclude
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $IndeXxI (int[])
 * @returns int []
 *
 * @source ThreePointCircle_TriangulationSTarting to work! (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int [] IntArrayInclude(int $IndeXxI[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $VecS[] = $IndexPtsG;
    int $newInt[];
    int $Ix = 0;
    int $ii = 0;
    int $Ixi = 0;
    int $IndeXxz[];
    int $size = `size($IndeXxI)`-1;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    global int $IndexPtsG[];
    global int $WorkingIndexPtsG[];
    $VecS = $IndexPtsG;
    $Ix = 0;
    $ii = 0;
    $Ix = 0;
    $IndeXxz = `sort $IndeXxI`;
    $size = `size($IndeXxI)`-1;
    for ($eachVc in $VecS){
    if($VecS[$ii]>$IndeXxz[$Ixi]){
    if($size==$Ixi){$Ixi=0;}
    $Ixi++;
    }
    if(($eachVc== $IndeXxz[$Ixi])){
    $newInt[`size($newInt)`] = $eachVc;
    $ii=$Ix;
    }else{$Ixi++;}
    $Ix++;
    }
    $WorkingIndexPtsG= $newInt;
    return $newInt;

}


/******************************************************************************
 * @procedure StringArrayItemsFromIndexAtoB
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $Ai (int)
 *   $Bi (int)
 *   $StringArrayi (string[])
 * @returns string
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string StringArrayItemsFromIndexAtoB(int $Ai, int $Bi, string $StringArrayi[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $NumerinArray = `size($StringArrayi)`;
    int $ixNa = $iC+$Ai;
    float $Ni = $Ai;
    float $Nii = $Bi;
    float $range = abs ($Ai-$Bi);
    string $sAddUp = 0;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $sAddUp = 0;
    $NumerinArray = `size($StringArrayi)`;
    if($NumerinArray!=0){
    $Ni = $Ai;
    $Ni = $Bi;
    if($Nii< $Ni){
    $Ai=$Nii; $Bi=$Ni;
    }
    $range = abs ($Ai-$Bi);
    for ($iC=0;$iC<$range+1; $iC++){
    $ixNa = $iC+$Ai;
    $sAddUp+=$StringArrayi[$ixNa];
    if($ixNa ==$NumerinArray){break;}
    }
    }
    return $sAddUp;

}


/******************************************************************************
 * @procedure StringArrayStartOfStringinArray
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $Array (string[])
 * @returns string[]
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string[] StringArrayStartOfStringinArray(string $Array[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    string $StartOfEach[];
    string $findEachstart = "";

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $findEachstart = "";
    for ($eachString in $Array){
    $StartOfEach[`size($StartOfEach)`]= startString($eachString, 1);
    $findEachstart+= startString($eachString, 1);
    $findEachstart+= " ";
    }

    return $StartOfEach;

}


/******************************************************************************
 * @procedure ReturnArrayFromNestedStringAtIndex
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $StringData (string[])
 *   $ind (int)
 * @returns string[]
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string[] ReturnArrayFromNestedStringAtIndex(string $StringData[], int $ind)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    string $KnownMatchi[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $KnownMatchi = stringToStringArray($StringData[$ind], ",");
    return $KnownMatchi;

}


/******************************************************************************
 * @procedure TFArrayContains
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $item (string)
 *   $list (string[])
 * @returns int[]
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int[] TFArrayContains(string $item, string $list[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $Count = 0;
    string $listItem;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────
    int $TF[1];
    $TF[0] = false;
    $Count = 0;
    for ($listItem in $list) {
    if ($item == $listItem) {
    $TF[0] = true;
    $TF[1] = $Count;
    break;
    } $Count++;
    }
    return $TF;

}


/******************************************************************************
 * @procedure stringArrayFindDupIndexSPair
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $listA (string[])
 *   $foundN (int[])
 *   $LineNumberB (int[])
 * @returns string []
 *
 * @dependencies IntRemoveIndexN, RemoveStringAtIndex
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string [] stringArrayFindDupIndexSPair(string $listA[], int $foundN[], int $LineNumberB[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $FindNum = 0;
    int $FindIndexN[];
    int $LineNumberA[];
    string $listTemp[];
    string $list[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    string $item, $result[];
    $FindNum = 0;
    clear $foundN;
    $LineNumberA = $LineNumberB;
    $list = $listA;
    $listTemp  = $list;
    for ($item in $list) {
    clear $FindIndexN;
    $FindNum = stringArrayCountIndex($item,  $listTemp, $FindIndexN);
    if ($FindNum>1){
    $foundN[`size($foundN)`] = $LineNumberA[$FindIndexN[`size($FindIndexN)`-1]];
    $result[`size($result)`] =  $listTemp[$FindIndexN[`size($FindIndexN)`-1]];
    $LineNumberA = IntRemoveIndexN( $LineNumberA, $FindIndexN);
    $listTemp = RemoveStringAtIndex( $listTemp, $FindIndexN);
    }else{
    if ($FindNum==1){
    $foundN[`size($foundN)`] = $LineNumberA[$FindIndexN[0]];
    $result[`size($result)`] =  $listTemp[$FindIndexN[0]];
    }
    }
    }
    return $result;

}


/******************************************************************************
 * @procedure stringArrayCountIndexOne
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $item (string)
 *   $list (string[])
 *   $FindIndexN (int[])
 * @returns int
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int stringArrayCountIndexOne(string $item, string $list[], int $FindIndexN[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $result = 0;
    int $CountN = 0;
    string $listItem;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $result = 0;
    $CountN = 0;
    clear $FindIndexN;

    for ($listItem in $list) {
    if ($item == $listItem){
    $FindIndexN[$result]=$CountN;
    $result++;
    }
    $CountN++;
    }
    return $result;

}


/******************************************************************************
 * @procedure stringArrayRemoveAtIndexZ
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $indexA (int)
 *   $list (int[])
 * @returns int []
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int [] stringArrayRemoveAtIndexZ(int $indexA, int $list[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $i;
    int $result[];
    int $indexS = `size($indexA)`;
    int $len = size( $list );
    int $Xi = 0;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $i = `size($indexA)`;
    $len = size( $list );
    $Xi = 0;
    while($Xi< $indexS){
    for ( $i = 0; $i < $Xi; $i++ ) {
    $result[$i] = $list[$i];
    }
    $Xi++;
    }
    //$list = $result;
    return $result;

}


/******************************************************************************
 * @procedure IntArrayRemoveAtIndex
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $index (int)
 *   $IntArray (int[])
 * @returns int []
 *
 * @dependencies StringArrayToIntArray, IntArrayToStringArray
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int [] IntArrayRemoveAtIndex(int $index, int $IntArray[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $i;
    int $len = `size( $list )`;
    string $list[] = IntArrayToStringArray( $IntArray );
    string $result[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────


    $list = IntArrayToStringArray( $IntArray );
    $len = `size( $list )`;
    for ( $i = 0; $i < $index; $i++ ) {
    $result[$i] = $list[$i];
    }
    for ( ; $i < $len - 1; $i++ ) {
    $result[$i] = $list[$i + 1];
    }
    $list = $result;
    $IntArray = StringArrayToIntArray($list);
    //string [] IntArrayToStringArray(int $IntArray[])
    return $IntArray;

}


/******************************************************************************
 * @procedure stringArrayCountIndex
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $item (string)
 *   $list (string[])
 *   $FindIndexN (int[])
 * @returns int
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int stringArrayCountIndex(string $item, string $list[], int $FindIndexN[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $result = 0;
    int $CountN = 0;
    string $listItem;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $result = 0;
    $CountN = 0;
    clear $FindIndexN;
    for ($listItem in $list) {
    if ($item == $listItem){
    $FindIndexN[$result]=$CountN;
    $result++;
    }
    $CountN++;
    }
    return $result;

}


/******************************************************************************
 * @procedure stringArrayStrip
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $list (string[])
 * @returns string []
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string [] stringArrayStrip(string $list[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $index = 0;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    string $item, $result[];
    $index = 0;
    for ($item in $list) {
    $result[$index++] = substituteAllString($item, " ", "");
    }
    return $result;

}


/******************************************************************************
 * @procedure stringArrayFindDuplicates
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $list (string[])
 * @returns string []
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string [] stringArrayFindDuplicates(string $list[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $index = 0;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    string $item, $result[];
    $index = 0;
    for ($item in $list) {
    if (1 < stringArrayCount($item, $list)) {
    $result[$index++] = $item;
    }
    }
    return $result;

}


/******************************************************************************
 * @procedure StringArrayToIntArray
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $listA (string[])
 * @returns int []
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int [] StringArrayToIntArray(string $listA[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $IntA[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    for($eachString in $listA){
    $IntA[`size($IntA)`]=$eachString;
    }
    return $IntA;

}


/******************************************************************************
 * @procedure AppendArrayZ
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $A (string[])
 *   $B (string[])
 * @returns string []
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string [] AppendArrayZ(string $A[], string $B[])
{

    for($eachF in $B){
    $A[`size($A)`]= $eachF;
    }
    return $A;

}


/******************************************************************************
 * @procedure intArrayRemoveDuplicates
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $list (int[])
 * @returns int []
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int [] intArrayRemoveDuplicates(int $list[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $index = 0;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    int $item, $result[];
    $index = 0;
    for ($item in $list) {
    if (0 == intArrayCount($item, $result)) {
    $result[$index++] = $item;
    }
    }
    return $result;

}


/******************************************************************************
 * @procedure intArrayCount
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $item (int)
 *   $list (int[])
 * @returns int
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int intArrayCount(int $item, int $list[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $result = 0;
    int $listItem;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $result = 0;
    for ($listItem in $list) {
    if ($item == $listItem) $result++;
    }
    return $result;

}


/******************************************************************************
 * @procedure RStringArrayStartOfStringinArray
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $Array (string[])
 * @returns string[]
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string[] RStringArrayStartOfStringinArray(string $Array[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    string $StartOfEach[];
    string $stringRN;
    string $SS;
    string $S;
    string $findEachstart = "";

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $findEachstart = "";
    for ($eachString in $Array){

    $stringRN = `substitute "[/$]" $eachString ""`;
    $S=startString($eachString, 3);

    $findEachstart= $S;
    $findEachstart+= "";
    $StartOfEach[`size($StartOfEach)`]= $findEachstart;
    }

    return $StartOfEach;

}


/******************************************************************************
 * @procedure stringArrayCountDuplicatesAUGMENT
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $listX (string[])
 *   $AddtoEnd (string)
 * @returns string []
 *
 * @dependencies ReverseStringArray
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string [] stringArrayCountDuplicatesAUGMENT(string $listX[], string $AddtoEnd)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $index = 0;
    int $X = 0;
    int $C = 0;
    int $NumberE[];
    string $list[] = $listX;
    string $Expr = "\\$";
    string $ExprA = "";

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $list = $listX;
    $list = ReverseStringArray($list);
    string $item, $result[], $CollectR[];
    $index = 0;
    $X = 0;
    $C = 0;
    $result = $list;
    $Expr = "\\$";
    $Expr = "";

    for ($item in $list) {
    $NumberE[$X] = stringArrayCount($item, $result);
    if (1 == $NumberE[$X]) {
    if(startString($item, 1)!= "$"){
    $CollectR[$X] = $ExprA+$item+$AddtoEnd;
    }
    if(startString($item, 1)== "$"){
    $CollectR[$X] = $item+$AddtoEnd;}
    }else{
    if (1 < $NumberE[$X]) {
    $C = $NumberE[$X]-1;
    if(startString($item, 1)!= "$"){
    $CollectR[$X] = $ExprA+$item+$C+$AddtoEnd;
    }
    if(startString($item, 1)== "$"){
    $CollectR[$X] = $item+$C+$AddtoEnd;
    }
    }
    }
    stringArrayRemoveToIndex(1, $result);
    $X++;	}
    $CollectR = ReverseStringArray($CollectR);
    return $CollectR;

}


/******************************************************************************
 * @procedure ReverseStringArray
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $array (string[])
 * @returns string[]
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string[] ReverseStringArray(string $array[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    string $arrayOut[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    for($i=0;$i<size($array);$i++){
    $arrayOut[$i]=$array[(size($array)-1-$i)];}
    return $arrayOut;

}


/******************************************************************************
 * @procedure intArrayRemoveEqual
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $list (int[])
 *   $listB (int[])
 * @returns int []
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int [] intArrayRemoveEqual(int $list[], int $listB[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $index = 0;
    int $i = 0;
    int $S = `size($listB)`-1;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $index = 0;
    $i = 0;
    $S = `size($listB)`-1;
    for ($item in $list) {
    if ($listB[$i]== $item) {

    $i++;
    if($i>$S){break;}
    }else{$result[$index++] = $item;}
    }

    return $result;

}


/******************************************************************************
 * @procedure stringArrayGmatchArrayIndex
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $itemA (string[])
 *   $list (string[])
 * @returns int []
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int [] stringArrayGmatchArrayIndex(string $itemA[], string $list[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $sizeitem = `size($itemA)`;
    int $result = false;
    int $ResultIndex[];
    int $Index = 0;
    int $BreakTrigger = 0;
    string $listItem;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $sizeitem = `size($itemA)`;
    $result = false;
    $Index = 0;
    $BreakTrigger = 0;
    for ($EachlistItem in $list) {
    for ($EachlistA in $itemA) {
    if ( $EachlistItem == $EachlistA ){
    $result = true; $ResultIndex[`size($ResultIndex)`] =  $Index;
    $BreakTrigger++;
    if ( $BreakTrigger == $sizeitem ){	break;	}
    }
    }
    $Index++;
    }
    return $ResultIndex;

}


/******************************************************************************
 * @procedure stringArrayGmatchFind
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $itemsA (string[])
 *   $Item (string)
 * @returns int
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int stringArrayGmatchFind(string $itemsA[], string $Item)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $result = false;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $result = false;
    for ($EachlistA in $itemsA) {
    if ( $EachlistA == $Item ){
    $result = true;
    break;	}
    }	return $result;

}


/******************************************************************************
 * @procedure ArrayDistancesVecTofloat
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $allVec (vector[])
 *   $point (float[])
 * @returns float []
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc float [] ArrayDistancesVecTofloat(vector $allVec[], float $point[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    float $AllDistances[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    for ($each in $allVec){
    $AllDistances[`size($AllDistances)`] = distance2Pts( $each, $point);
    }
    return $AllDistances;

}


/******************************************************************************
 * @procedure ReverseIntArray
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $array (int[])
 * @returns int[]
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int[] ReverseIntArray(int $array[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $arrayOut[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    for($i=0;$i<size($array);$i++){
    $arrayOut[$i]=$array[(size($array)-1-$i)];}
    return $arrayOut;

}


/******************************************************************************
 * @procedure multiplyFloatArray
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $posA (float)
 *   $posB (float[])
 * @returns float[]
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc float[] multiplyFloatArray(float $posA, float $posB[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    float $Timespos[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    for($eachF in $posB){
    $Timespos[`size($Timespos)`] = $eachF*$posA;
    }
    return $Timespos;

}


/******************************************************************************
 * @procedure IntArrayToStringArray
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $IntArray (int[])
 * @returns string []
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string [] IntArrayToStringArray(int $IntArray[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    string $Intnumbers;
    string $array[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    for($each in $IntArray){
    $Intnumbers += $each+" ";
    }
    $array = stringToStringArray($Intnumbers, " ");
    return $array;

}


/******************************************************************************
 * @procedure FloatArrayToStringArray
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $FloatArray (float[])
 * @returns string []
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string [] FloatArrayToStringArray(float $FloatArray[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    string $floatnumbers;
    string $array[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    for($each in $FloatArray){
    $floatnumbers += $each+" ";
    }
    $array = stringToStringArray($floatnumbers, " ");
    return $array;

}


/******************************************************************************
 * @procedure NewArrayOrderWithIndexKey
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $stringIndexTrack (string[])
 *   $ObjsCurve (string[])
 * @returns string []
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string [] NewArrayOrderWithIndexKey(string $stringIndexTrack[], string $ObjsCurve[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $iNew;
    string $newOrderArray[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    for($each in $stringIndexTrack){
    $iNew = $each;
    stringArrayInsertAtIndex(`size($newOrderArray)`, $newOrderArray, $ObjsCurve[$iNew]);
    }
    return $newOrderArray;

}


/******************************************************************************
 * @procedure SortFloatArrayAndString
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $allFloatToSort (float[])
 *   $ObjsCurve (string[])
 *   $EmptyStringNewOrder (string[])
 * @returns float []
 *
 * @dependencies IntArrayToStringArray, NewArrayOrderWithIndexKey, CreateIntIndex
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc float [] SortFloatArrayAndString(float $allFloatToSort[], string $ObjsCurve[], string $EmptyStringNewOrder[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $sIze = `size($allFloatToSort)`-1;
    int $IndexTrack[] = CreateIntIndex(`size($aF)`);
    float $Floatlist[] = $allFloatToSort;
    float $aF[] = $allFloatToSort;
    string $stringIndexTrack[] = IntArrayToStringArray($IndexTrack);
    string $newOrderArray[] = NewArrayOrderWithIndexKey($stringIndexTrack, $ObjsCurve);

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $Floatlist = $allFloatToSort;
    $sIze = `size($allFloatToSort)`-1;
    $aF = $allFloatToSort;
    $IndexTrack = CreateIntIndex(`size($aF)`);
    quickSort($aF, $IndexTrack, 0, $sIze);
    $stringIndexTrack = IntArrayToStringArray($IndexTrack);
    $newOrderArray = NewArrayOrderWithIndexKey($stringIndexTrack, $ObjsCurve);
    $EmptyStringNewOrder = $newOrderArray;
    return $aF;

}


/******************************************************************************
 * @procedure floatArrayCountDuplicates
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $listX (float[])
 * @returns int []
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int [] floatArrayCountDuplicates(float $listX[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $index = 0;
    int $X = 0;
    int $Xi = 0;
    int $C = 0;
    int $NumberE[];
    int $NoneDup[];
    float $list[] = $listX;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $list = $listX;
    float $item, $result[], $CollectR[];
    $index = 0;
    $X = 0;
    $X = 0;
    $C = 0;
    $result = $list;
    for ($item in $list) {
    $NumberE[$X] = floatArrayCount($item, $result);
    if (1 == $NumberE[$X]) {
    $NoneDup[`size($NoneDup)`] = $Xi;
    }else{
    if (1 < $NumberE[$X]) {
    floatArrayRemoveAtIndex($X, $result);
    $X--;
    }
    }
    $Xi++;
    $X++;	}
    return $NoneDup;

}


/******************************************************************************
 * @procedure floatArrayCount
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $item (float)
 *   $list (float[])
 * @returns int
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int floatArrayCount(float $item, float $list[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $result = 0;
    float $listItem;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $result = 0;
    for ($listItem in $list) {
    if ($item == $listItem) $result++;	}
    return $result;

}


/******************************************************************************
 * @procedure floatArrayRemoveAtIndex
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $index (int)
 *   $list (float[])
 * @returns int
 *
 * @source RADIAL_S_matrix (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int floatArrayRemoveAtIndex(int $index, float $list[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $i;
    int $len = size( $list );
    float $result[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $len = size( $list );
    if( $index > $len  || $index < 0 ){
    return( false );
    }
    for( $i = 0; $i < $index; $i++ ){
    $result[$i] = $list[$i];
    }
    for( ; $i < $len - 1; $i++ ){
    $result[$i] = $list[$i + 1];
    }
    $list = $result;
    return( true );

}


/******************************************************************************
 * @procedure IntArrayReturnClosedLoop
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $listX (int[])
 *   $listTD (int[])
 * @returns int []
 *
 * @dependencies MultLenToDirAddToPoint, TransformRelByMatrixXform, Angle2D, PointsEquivalentTol, Loc
 *                (+50 more)
 *
 * @source working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int [] IntArrayReturnClosedLoop(int $listX[], int $listTD[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $Ct;
    int $ModNn;
    int $index = 0;
    int $X = 0;
    int $CountD = 0;
    int $CountDX = 0;
    int $NumberE[];
    int $NumberER[];
    int $IndexDup[];
    int $result = 0;
    int $index = 0;
    int $indexArray[];
    int $CurveMeetsTrue = 0;
    int $indexN = 0;
    int $indexN2 = 0;
    int $IndexEnds[];
    int $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    int $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);
    int $TF = 0;
    int $intIfTrue[] = FindifCurveEndsMeetIndex($CurveOne, $CurveTwo, $TF);
    int $TF = 0;
    int $intIfTrue[] = FindifCurveEndsMeetIndexZ($CurveOne, $CurveTwo, $TF);
    int $CurveMeetsTrue = 0;
    int $indexN = 0;
    int $indexN2 = 0;
    int $IndexEnds[];
    int $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    int $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);
    int $numCVs;
    int $num;
    int $count = 0;
    int $i = 0;
    int $Cindex = 0;
    int $Cindex = 0;
    int $Cindex = 0;
    int $NumberCs = $number3;
    int $n = $number3;
    int $i;
    int $i;
    int $i;
    int $NumberCs = $number3;
    int $n = $NumberCs;
    int $i;
    int $i;
    int $SizeV = size($c);
    float $FDirNorA[] = Normal3Points($PtsVec[0], $PtsVec[1],$PtsVec[2]);
    float $ObjsCirclesE = `arclen`*2.0;
    float $ObjsCirclesEi = `arclen`;
    float $ObjsCirclesEii = `arclen`;
    float $Di = distance2Pts( $CircPos , $PointN);
    float $PointN[] = ClosestPoint2Line($VecLineDir, $PosA, $CircPos);
    float $Di = distance2Pts( $CircPos , $PointN);
    float $DiffL = ($ObjsCirclesRad-$Di)*2.0;
    float $FloatDirXn[] = DirectionF( $Vec[2], $Vec[0]);
    float $PointNii[] = MultLenToDirAddToPoint($Di, DirectionF( $Vec[2], $PointN), $PointN);
    float $DistAddiR2 = $Di*2.0;
    float $HightD = sqrt (abs ((`pow $Di 2.0`) - (`pow $ObjsCirclesRad 2.0`)));
    float $PointNiii[] = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[1], $Vec[0]), $PointN);
    float $PointNiiiB[] = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[0], $Vec[1]), $PointN);
    float $ObjsCirclesEi = `arclen`;
    float $ObjsCirclesEii = `arclen`;
    float $ObjsCirclesEiii = `arclen`;
    float $Dii = distance2Pts(  $AVecArrayPos_MC[0] ,  $AVecArrayPos_MC[1]);
    float $DiX = distance2Pts(  $AVecArrayPos_MC[0] ,  $VecCamPos_A);
    float $DiffMathAz = $ObjsCirclesEii/$DiX;
    float $DiffMathBz = $DiffMathAz*$Dii;
    float $TESTx = $ObjsCirclesEii +$DiffMathBz ;
    float $DiffMathA = $DiX / (($Dii+$DiX)/100.0);
    float $DiffMathAi = (($DiffMathA/100.0) * $ObjsCirclesEiii);
    float $DiffMathA = $DiX / (($Dii+$DiX)/100.0);
    float $DiffMathB = $Dii / (($Dii+$DiX)/100.0);
    float $DiffMathBi = $DiffMathB / 100.0;
    float $Testri = ($Dii/$DiX)+1.000;
    float $DiffMathAiX = ($Testri * $ObjsCirclesEii);
    float $TESTx = $ObjsCirclesEiii -$DiffMathAiX ;
    float $Testr = ($ObjsCirclesEiii / $ObjsCirclesEii);
    float $TESTx = $Testr -$Testri;
    float $TESTx = $Testr -$Testri;
    float $DiffMathAx = $ObjsCirclesEii/ (($ObjsCirclesEiii)/100.0);
    float $DiffMathAi = (($DiffMathAx/100.0) * $ObjsCirclesEii);
    float $Testr = ($ObjsCirclesEii / $ObjsCirclesEiii);
    float $Testrii = ($ObjsCirclesEiii - $ObjsCirclesEii)/$Dii;
    float $Testr = ($ObjsCirclesEiii / $ObjsCirclesEii);
    float $Testri = ($Dii/$Testr);
    float $PerDiffX = percent_of( $ObjsCirclesEii ,$ObjsCirclesEiii);
    float $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
    float $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    float $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    float $NofCirclesa = (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
    float $NofCirclesb = ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
    float $NofCirclesc = ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);
    float $PI = 3.1415926535;
    float $Cir = ($PI *$r )*2.00 ;
    float $Seg = $Cir/8.0;
    float $LengAngle = 360.000/$Seg;
    float $DiffMathA = $Seg / ($Cir/100.0);
    float $DiffMathAB = 360.0/(100.0/$DiffMathA);
    float $angle = $LengAngle / $sides;
    float $a = $i * $angle ;
    float $angle = 0.00;
    float $AstepF = 0.035;
    float $TstepF = 1.025;
    float $Step = 120;
    float $LSS = 0.050;
    float $a = 1.0;
    float $FoundRadii[];
    float $CurveSizeFloat = logN(logN(logN(`log (5.605099)`)));
    float $LS = 0.050;
    float $LS = 0.050;
    float $XLOOG = abs  (((logN(`log ($FoundRadii[$Cindex]/8.0)`))));
    float $a;
    float $pi = 3.1415926535;
    float $Pi = 3.1415926535;
    float $RA;
    float $RB;
    float $R2 = $RA;
    float $R1 = $RB;
    float $DCircle = (($R2 - $R1)/2.0) + $R1 ;
    float $Rii = (($R2 - $R1)/2.0);
    float $SideA = $RB + $Rii;
    float $SideB = $Rii*2;
    float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    float $ArcangleC2 = $ArcangleC*2.0;
    float $Aii = (`asin ($RB/($RB + $Rii))`);
    float $number3 = 360.0/$ArcangleC2;
    float $len = $DCircle;
    float $r = $DCircle;
    float $angle = 360.0 / $n ;
    float $x[] = createRegularPolygonX( $n, $r ) ;
    float $y[] = createRegularPolygonY( $n, $r ) ;
    float $z = 0.0 ;
    float $rotatsB[] = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($angle)) );
    float $a = $i * $angle ;
    float $rotatsA[] = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($a)) );
    float $a = $i * $angle ;
    float $rotatsA[] = RotDirToPoint($VCirPosX,$DirectionStart, $RB, $Normal, (deg_to_rad($a)) );
    float $a = $i * $angle ;
    float $rotatsA[] = RotDirToPoint($VCirPosX,$DirectionStartB, $r, $Normal, (deg_to_rad($a)) );
    float $a = $i * $angle ;
    float $rotatsA[] = RotDirToPoint($VCirPosX,$DirectionStart, $r, $Normal, (deg_to_rad($a)) );
    float $Templast[];
    float $center[];
    float $normal[];
    float $p1[] = `xform -q -ws -t $selectionList[0]`;
    float $p2[] = `xform -q -ws -t $selectionList[1]`;
    float $p3[] = `xform -q -ws -t $selectionList[2]`;
    float $FloatPosZero[] = {0, 0, 0};
    float $FloatDirection[] = DirectionF($FloatPosZero, $normal);
    float $MultDirP[] = multiplyFloat(2, $FloatDirection);
    float $center[] = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    float $FloatDirPerpCenter[] = DirectionF($center, $mid3);
    float $FloatDirPerpCenterB[] = DirectionF($center,$mid1);
    float $FloatDirPerpCenterC[] = DirectionF($center,$mid2);
    float $FloatDirPointAB[] = DirectionF($p1, $p2);
    float $FloatDirPointBC[] = DirectionF($p2, $p3);
    float $FloatDirPointAC[] = DirectionF($p1, $p3);
    float $center6[] = lineIntersection( $p1, $FloatDirPerpCenter, $p2, $FloatDirPointBC );
    float $center7[] = lineIntersection( $p3,  $FloatDirPerpCenterB, $p1, $FloatDirPointAB );
    float $center8[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
    float $center9[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPerpCenter );
    float $OrthoCenterCir[] = midPoint2Pts( $center9, $center );
    float $Radius2HalfTimes2 = (distance2Pts( $center9, $center ))*2;
    float $Radius2BHalf = (distance2Pts( $center9, $center ));
    float $radiusZ = distance2Pts( $p1, $center );
    float $Radius3Half = $radiusZ/2;
    float $radius;
    float $PI = 3.1415926535;
    float $Cir = ($PI *$r )*2.00 ;
    float $Seg = $Cir/8.0;
    float $LengAngle = 360.000/$n;
    float $angle = $LengAngle / $sides;
    float $a;
    float $Start_angle = (90.0);
    float $End_angle;
    float $PI = 3.1415926535;
    float $Cir = ($PI *$r )*2.00 ;
    float $Seg = $Cir/8.0;
    float $LengAngle = 360.000/$Seg;
    float $angle = $LengAngle / $sides;
    float $a = $i * $angle ;
    float $PI = 3.1415926535;
    float $Cir = ($PI *$r )*2.00 ;
    float $Seg = $Cir/8.0;
    float $LengAngle = 360.000/$Seg;
    float $DiffMathA = $Seg / ($Cir/100.0);
    float $DiffMathAB = 360.0/(100.0/$DiffMathA);
    float $angle = $LengAngle / $sides;
    float $a = $i * $angle ;
    float $x[];
    float $angle = 360.0 / $n ;
    float $a = $i * $angle ;
    float $x[];
    float $angle = 360.0 / $n ;
    float $a = $i * $angle ;
    float $DiffMathA = 12.000 / (159.434902/100.0);
    float $LengAngle = 360.000/$DiffMathA;
    float $angle = 180.000/$sides;
    float $PI = 3.1415926535;
    float $DiffMathA = 12.0 / (159.434902/100.0);
    float $LengAngle = 360.0/(100.0/$DiffMathA);
    float $angle = $LengAngle / $sides;
    float $a = $i * $angle ;
    float $pi = 3.1415926535;
    float $Pi = 3.1415926535;
    float $RA;
    float $RB;
    float $R2 = $RA;
    float $R1 = $RB;
    float $DCircle = (($R2 - $R1)/2.0) + $R1 ;
    float $Rii = (($R2 - $R1)/2.0);
    float $SideA = $RB + $Rii;
    float $SideB = $Rii*2;
    float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    float $ArcangleC2 = $ArcangleC*2.0;
    float $number3 = 360.0/$ArcangleC2;
    float $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
    float $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    float $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    float $NofCirclesa = (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
    float $NofCirclesb = ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
    float $NofCirclesc = ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);
    float $len = $DCircle;
    float $r = $DCircle;
    float $x[] = createRegularPolygonX( $n, $r ) ;
    float $y[] = createRegularPolygonY( $n, $r ) ;
    float $z = 0.0 ;
    float $LengthsT[] = ArcLengthArray(`ls -sl`);
    float $LengthsM[] = ArcLengthArray(`ls -sl`);
    float $Lengths[] = ArcLengthArray(`ls -sl`);
    float $LengthsSub[];
    float $PerDiff = percent_of($LengthsM[0], $Lengths[3]);
    float $LengthsC[] = ArcLengthArray(`ls -sl`);
    float $FDirNorA[] = Normal3Points($PtsVec[0], $PtsVec[1],$PtsVec[2]);
    float $x = VecCom($VLocPos_A, 0);
    float $y = VecCom($VLocPos_A, 1);
    float $PI = 3.1415926535;
    float $angle = 0;
    float $Distance = 0;
    float $DistanceMM = 0;
    float $Arc = 0;
    float $p1x = 0, $p1y = 0, $p2x = 0, $p2y = 0;
    float $triarea = 0;
    float $tri_areaM = 0;
    float $aP;
    float $bP;
    float $cP;
    float $N;
    float $PI = 3.1415926535;
    float $TWO_PI = 3.1415926535;
    float $Arc = `arclen $CurveItemAX[0]`;
    float $AverageVecCurve[] = AverageVectorPoint($Positions);
    float $DDistPt_toC = distance2Pts($VCrvPos_A, $VLocPos_A);
    float $DDist = $Distance/float($TotalS);
    float $DDistX = $Distance+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    float $DDistMM = $DistanceMM+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    float $DDistMM = $DistanceMM/float($TotalS);
    float $MathA = $DDistMM/$DDist;
    float $MathB = $DDistPt_toC/$MathA;
    string $list[];
    string $listItem;
    string $CurveSelection[];
    string $selItemz[] = `ls-sl`;
    string $selLocz[];
    string $itemD[];
    string $itemD[] = `duplicate -rr $item`;
    string $CurveItemZ[] = `ls -sl`;
    string $initial_string;
    string $rules[];
    string $tmp;
    string $ThefirstCurve = VecArrayToCurve($Xs);
    string $ThefirstCurve = VecArrayToCurve($Xs);
    string $CurvesV[];
    string $CurvesV[];
    string $circleA[];
    string $circleB[];
    string $circles[];
    string $circlesC[];
    string $LItem[] = `ls -sl`;
    string $selectionList[];
    string $circlesItem[];
    string $ThefirstCurve = VecArrayToCurve($Xs);
    string $Locs[];
    string $ThefirstCurve = VecArrayToCurve($Xs);
    string $ThefirstCurve = VecArrayToCurve($Xs);
    string $ThefirstCurve = VecArrayToCurveB($Xs);
    string $circleA[];
    string $circleB[];
    string $circles[];
    string $circlesC[];
    string $CurveItemAXX[] = `ls -sl`;
    string $CurveItemAX[] = `ls -sl`;
    string $CurveItemAX[] = `ls -sl`;
    string $LItem[] = `ls -sl`;
    vector $CurveOne[] = GetVectorArrayBetweenCurveEnds({$curveA});
    vector $CurveTwo[] = GetVectorArrayBetweenCurveEnds({$curveB});
    vector $CurveOne[] = GetVectorArrayBetweenCurveEnds({$curveA});
    vector $CurveTwo[] = GetVectorArrayBetweenCurveEnds({$curveB});
    vector $CurveAB[];
    vector $eachCVposV;
    vector $VecLi[];
    vector $NewVeci;
    vector $VecCamPos_A;
    vector $VecArrayPos_MC[];
    vector $ThreeEllipVecP[];
    vector $PtsVec[] = PointArrayT(`ls -sl`);
    vector $NewEllipesCurve[];
    vector $AVecArrayPos_MC[];
    vector $AVecArrayPos_MC[];
    vector $VecCamPos_A;
    vector $CircPos = $VecArrayPos_MC[1];
    vector $PosA = $VecCamPos_A;
    vector $PosB = $AVecArrayPos_MC[0];
    vector $VecLineDir = PositiveDirectionLine($PosA, $PosB);
    vector $Vec[];
    vector $AVecArrayPos_MC[];
    vector $A_CrvCentroidA = FloatToVec(AverageVectorPoint( $AVecArrayPos_MC));
    vector $Xs[];
    vector $Xs[];
    vector $Normal = << 0.0,1.0,0.0>>;
    vector $HighCurvePoints[];
    vector $NormalCurvePoints[];
    vector $DirecAB = ((unit(`rot $Direc $DirNorm $Radian`))*$Length)+$Vecpt;
    vector $VCirPosX;
    vector $Normal = <<0.0, 1.0, 0.0>>;
    vector $VecPairA[];
    vector $EmptyVecA[];
    vector $DirectionStart = <<$matrixA[0][0], $matrixA[0][1], $matrixA[0][2] >>;
    vector $DirectionStartB = <<$rotatsB[0], $rotatsB[1], $rotatsB[2] >>;
    vector $VrotatsA[];
    vector $VrotatsCiH[];
    vector $VrotatsBiH[];
    vector $VrotatsCi[];
    vector $VrotatsBi[];
    vector $VrotatsAi[];
    vector $CirclePts = <<$rotatsA[0], $rotatsA[1], $rotatsA[2] >>;
    vector $DirLine = DirectionFN($CirclePts, $VCirPosX);
    vector $Vperp = crossProduct( $DirLine, $Normal, 0, 0 );
    vector $VperpN = crossProduct( $DirLine, ($Normal*-1.0), 0, 0 );
    vector $VperpA = ($Rii/2.0)* $VperpN*-1.0;
    vector $VperpC = ($Rii/2.0)*$DirLine;
    vector $VperpB = ( $Rii/2.0)*$Vperp*-1.0;
    vector $VperpD = (-1*$Rii/2.0)*$DirLine;
    vector $veCPos1[];
    vector $Xs[];
    vector $VecCurEndsa[] = VecCurveEnds({$ThefirstCurve});
    vector $Xs[];
    vector $Xs[];
    vector $Xs[];
    vector $Positions[];
    vector $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM`;
    vector $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM`;
    vector $Plane_Trans = `xform -q -ws -t LiveSurfaceB`;
    vector $Plane = `xform -q -ws -ro LiveSurfaceB`;
    vector $PtsVec[] = PointArrayT(`ls -sl`);
    vector $VCrvPos_AA;
    vector $PtsVec[] = PointArrayT(`ls -sl`);
    vector $VCrvPos_A;
    vector $VLocPosX;
    vector $VCrvPos_A;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $list = IntArrayToStringArray($listX);
    string $item, $result[], $CollectR[];
    $index = 0;
    $X = 0;
    $CountD = 0;
    $CountD = 0;
    $result = $list;
    //for ($item in $result) {

    while(`size($result)`> 0 ) {
    $item = $result[0];
    $CountD = stringArrayCount($item, $result);

    $IndexDup = StringArrayCountIndexDup($item, $list, $CountDX);
    if($CountDX >1){
    for($eachINT in $IndexDup){
    $listTD[$eachINT] = $CountDX;
    }
    clear $IndexDup;
    }
    if ($CountD>1) {
    $NumberE[$index]=$CountD;
    print ($item+" "+$CountD+"\n");
    $NumberER[$index] =$NumberE[$index];
    $CollectR[$index] = $item;
    $index++;
    $result = stringArrayRemove({$item},$result);
    }
    $X++;
    if($X ==200){break;}
    }

    return $NumberER;
    }



    proc int[] StringArrayCountIndexDup(string $item, string $list[], int $Count)
    {
    $result = 0;
    $index = 0;

    for ($listItem in $list) {

    if ($item == $listItem){
    $indexArray[$result] = $index;
    $result++;}

    $index++;
    }
    $Count = $result;
    return $indexArray;
    }


    proc int [] FindifCurveEndsMeetIndex(vector $CurveA1[], vector $CurveA2[], int $TF){
    $CurveMeetsTrue = 0;
    $index = 0;
    $index = 0;
    float $firstC[], $SecondC[], $SecondCA[];

    while ($indexN < 2){

    $firstC = $CurveA1[$indexN];
    $SecondC = $CurveA2[0];
    $SecondCA = $CurveA2[1];

    $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    $NumberE = PointsEquivalentTol( $firstC, $SecondCA);

    if ($NumberE == 3){
    if($indexN==0){
    $IndexEnds[0]=1; $IndexEnds[1]=0; $IndexEnds[2]=1; $IndexEnds[3]=0;

    }else{
    $IndexEnds[0]=0; $IndexEnds[1]=1; $IndexEnds[2]=1; $IndexEnds[3]=0;

    }
    $CurveMeetsTrue = 1;
    break; }

    if ($NumberE2 == 3){

    if($indexN==0){
    $IndexEnds[0]=1; $IndexEnds[1]=0; $IndexEnds[2]=0; $IndexEnds[3]=1;

    }else{

    $IndexEnds[0]=0; $IndexEnds[1]=1; $IndexEnds[2]=0; $IndexEnds[3]=1;}
    $CurveMeetsTrue = 1;
    break; }

    if ($indexN==1){$indexN1 = 1;}
    $indexN++;
    }

    $TF = $CurveMeetsTrue;
    return $IndexEnds;
    }


    proc int [] IfCurvesTouchIndex(string $curveA, string $curveB,int $TFa){
    $CurveOne = GetVectorArrayBetweenCurveEnds({$curveA});
    $CurveTwo = GetVectorArrayBetweenCurveEnds({$curveB});
    $TF = 0;
    $intIfTrue = FindifCurveEndsMeetIndex($CurveOne, $CurveTwo, $TF);
    $TFa = $TF;
    return $intIfTrue;
    }


    proc int [] IfCurvesTouchIndexZ(string $curveA, string $curveB,int $TFa){
    $CurveOne = GetVectorArrayBetweenCurveEnds({$curveA});
    $CurveTwo = GetVectorArrayBetweenCurveEnds({$curveB});
    $TF = 0;
    $intIfTrue = FindifCurveEndsMeetIndexZ($CurveOne, $CurveTwo, $TF);
    $TFa = $TF;
    return $intIfTrue;
    }



    proc int [] FindifCurveEndsMeetIndexZ(vector $CurveA1[], vector $CurveA2[], int $TF){
    $CurveMeetsTrue = 0;
    $index = 0;
    $index = 0;
    float $firstC[], $SecondC[], $SecondCA[];

    while ($indexN < 2){

    $firstC = $CurveA1[$indexN];
    $SecondC = $CurveA2[0];
    $SecondCA = $CurveA2[1];

    $NumberE = PointsEquivalentTol( $firstC, $SecondC);
    $NumberE = PointsEquivalentTol( $firstC, $SecondCA);

    if ($NumberE == 3){
    if($indexN==0){
    $IndexEnds[0]=0; $IndexEnds[1]=0;

    }else{
    $IndexEnds[0]=1; $IndexEnds[1]=0;
    }
    $CurveMeetsTrue = 1;
    break; }

    if ($NumberE2 == 3){

    if($indexN==0){
    $IndexEnds[0]=0; $IndexEnds[1]=1;
    }else{

    $IndexEnds[0]=1; $IndexEnds[1]=1; }
    $CurveMeetsTrue = 1;
    break; }

    if ($indexN==1){$indexN1 = 1;}
    $indexN++;
    }

    $TF = $CurveMeetsTrue;
    return $IndexEnds;
    }





    proc vector[] GetVectorArrayCRVEnds(string $CurveItemZ[]){

    for ($CurveItem in $CurveItemZ) {
    $numCVs = `getAttr -size ($CurveItem +  ".controlPoints")`;
    $num = ( $numCVs -1 );
    $CurveSelection[0] = ($CurveItem + ".cv[0]") ;
    $CurveSelection[1] = ($CurveItem + ".cv[" +  $num + "]") ;
    for ($eachZA in $CurveSelection) {
    $eachCVposV = `pointPosition -w ($eachZA)`;
    $CurveAB[`size($CurveAB)`] = $eachCVposV;
    }
    }
    return $CurveAB;
    }


    $selItemz = `ls-sl`;

    matrix $NewAMatrix[4][4];
    $NewAMatrix = GetMatrix($selItemz[0]);

    matrix $NewBMatrix[4][4];
    $NewBMatrix = GetMatrix($selItemz[1]);




    clear $selLocz;
    for($eachVec in  $VecArrayPos_MC){
    $selLocz[`size($selLocz)`] = `Loc $eachVec`;
    }

    select -r $selLocz[0];

    TransformRelByMatrixXformMX($NewBMatrix, $selLocz)




    TransformRelByMatrixXform($NewBMatrix, $selItemz[0]);
    TransformItemByMatrixXform($NewBMatrix, $selItemz[0]);





    proc TransformRelByMatrixXformMX(matrix $m[][], string $itemA[]){
    $VecLi = PointArrayT($itemA);
    $count = 0;
    for($item in $itemA){
    $itemD  = `duplicate -rr $item`;
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $itemD[0];
    select -r $itemD ; PAUSE;
    //$NewVeci = VecMultMatrix($NewVeci, $m);
    //xform -ws -t ($NewVeci.x) ($NewVeci.y) ($NewVeci.z) $itemD[0];
    $count++;
    }
    }

    proc TransformItemByMatrixXform(matrix $m[][], string $item){
    $itemD = `duplicate -rr $item`;
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3])
    ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3])
    ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3])
    ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $itemD[0];
    }

    $VecCamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
    $VecArrayPos_MC = PointArrayT(`ls-sl -fl`);



    $ThreeEllipVecP = PointArrayT(`ls-sl`);
    //////////////////

    $PtsVec = PointArrayT(`ls -sl`);
    $FDirNorA = Normal3Points($PtsVec[0], $PtsVec[1],$PtsVec[2]);
    //////////


    //	$ThreeEllipVecP[0] = $CurveCollectVec[$NewIndexAi[0]] ;
    //	$ThreeEllipVecP[1] = $NewPvec;
    //	$ThreeEllipVecP[2] = $CurveCollectVec[$ChangeOver];
    $NewEllipesCurve = calculateEllipseCurve($ThreeEllipVecP, 300);


    //LineIntersectCirTF(  $ObjsCirclesRad , $VecArrayPos_MC[1], $VecCamPos_A ,$VecArrayPos_MC[0])

    // circle pos, circle radius, line direction, line pos
    //proc int LineIntersectCirTFZ(float $ObjsCirclesRad, vector $CircPos[], vector $PosA,vector $PosB){


    $AVecArrayPos_MC = PointArrayT(`ls-sl`);


    LineIntersectCirTFZ(float $ObjsCirclesRad, vector $CircPos, vector $PosB){


    $AVecArrayPos_MC = PointArrayT(`ls-sl`);

    $VecCamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;

    $CircPos = $VecArrayPos_MC[1];
    $PosA = $VecCamPos_A;
    $PosB = $AVecArrayPos_MC[0];
    $ObjsCirclesE = `arclen`*2.0;


    $ObjsCirclesE = `arclen`;
    $ObjsCirclesE = `arclen`;
    // Result: 0.41585 //
    // Result: 14.251443 //

    // Result: 23.164589 //
    // Result: 0.191253 //

    $Di = distance2Pts( $CircPos , $PointN);

    $VecLi = PositiveDirectionLine($PosA, $PosB);
    //float $ObjsCirclesRad = `arclen`*2.0;
    // $ObjsCirclesRad = $ObjsCirclesRad/2.0;

    $PointN = ClosestPoint2Line($VecLineDir, $PosA, $CircPos);
    Loc $PointN;
    curve2points($PosB, $PointN);
    print  $ObjsCirclesRad;

    $Di = distance2Pts( $CircPos , $PointN);
    $Di = ($ObjsCirclesRad-$Di)*2.0;

    //$Di = $ObjsCirclesRad;

    $Vec[0] = $PosA;
    $Vec[1] = $PosB;
    $Vec[2] = $CircPos;


    $FloatDirXn = DirectionF( $Vec[2], $Vec[0]);
    $PointN = MultLenToDirAddToPoint($Di, DirectionF( $Vec[2], $PointN), $PointN);
    Loc $PointNii;
    $Di = $Di*2.0;
    $HightD = sqrt (abs ((`pow $Di 2.0`) - (`pow $ObjsCirclesRad 2.0`)));
    $PointN = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[1], $Vec[0]), $PointN);
    Loc $PointNiii;

    $PointN = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[0], $Vec[1]), $PointN);
    Loc $PointNiiiB;
    curve2points($PointNiii,$PointNiiiB);



    if($Di<$eachObjsCirclesRad){
    $returnValue =1; break;}
    if($Di==$eachObjsCirclesRad){
    $returnValue =0;}
    if($Di>$eachObjsCirclesRad){
    $returnValue =-1;}
    $IndexI++;
    }

    return $returnValue;
    }


    $AVecArrayPos_MC = PointArrayT(`ls-sl`);

    //distance2Pts(  $AVecArrayPos_MC[0] ,  $AVecArrayPos_MC[2]);
    //distance2Pts(  $AVecArrayPos_MC[1] ,  $AVecArrayPos_MC[2]);

    $A_CrvCentroidA = FloatToVec(AverageVectorPoint( $AVecArrayPos_MC));
    Loc $A_CrvCentroidA;


    $CurveItemZ = `ls -sl`;


    PointCurvesToPlaneCurve($CurveItemZ);


    $ObjsCirclesE = `arclen`;
    $ObjsCirclesE = `arclen`;
    $ObjsCirclesE = `arclen`;

    $Di = distance2Pts(  $AVecArrayPos_MC[0] ,  $AVecArrayPos_MC[1]);
    $Di = distance2Pts(  $AVecArrayPos_MC[0] ,  $VecCamPos_A);

    $Di = $ObjsCirclesEii/$DiX;
    $Di = $DiffMathAz*$Dii;
    $TESTx = $ObjsCirclesEii +$DiffMathBz ;


    // Result: -2.134459 //
    print $ObjsCirclesEiii;
    2.268188


    $Di = $DiX / (($Dii+$DiX)/100.0);

    // Result: 2.94791 //
    $Testr = ($ObjsCirclesEii / $ObjsCirclesEiii);
    // Result: 0.0294791 //


    $Di = (($DiffMathA/100.0) * $ObjsCirclesEiii);


    $Di = $DiX / (($Dii+$DiX)/100.0);
    $Di = $Dii / (($Dii+$DiX)/100.0);

    $Di = $DiffMathB / 100.0;

    $Testri = ($Dii/$DiX)+1.000;
    $Di = ($Testri * $ObjsCirclesEii);
    $TESTx = $ObjsCirclesEiii -$DiffMathAiX ;

    $Testr = ($ObjsCirclesEiii / $ObjsCirclesEii);
    $TESTx = $Testr -$Testri;

    $TESTx = $Testr -$Testri;


    $Di = $ObjsCirclesEii/ (($ObjsCirclesEiii)/100.0);

    $Di = (($DiffMathAx/100.0) * $ObjsCirclesEii);

    $Testr = ($ObjsCirclesEii / $ObjsCirclesEiii);

    // 1.167526

    // Result: 0.0668641 //
    // Result: 2.268188 //

    print $Dii;
    print $ObjsCirclesEi;
    print $ObjsCirclesEii;
    print $ObjsCirclesEiii;

    $Testri = ($ObjsCirclesEiii - $ObjsCirclesEii)/$Dii;

    $Testr = ($ObjsCirclesEiii / $ObjsCirclesEii);
    $Testri = ($Dii/$Testr);

    $PerDiffX = percent_of( $ObjsCirclesEii ,$ObjsCirclesEiii);

    //start with a simple string
    $initial_string = "a";

    //define some rules of replacement and put them in an array
    $rules[0] = "aab->abbaaa";

    //iteratively replace and return the final result into the variable $tmp
    $tmp = aa_lsystem_replace("a",$rules,3);

    //print the result
    print($tmp);


    $drawrules[0] = "a->move 10";
    $drawrules[1] = "b->turn 90 0";

    //draw a line using the rules and an lsystem string (using the $tmp string
    // from the aa_lsystem_replace example)
    aa_lsystem_draw($tmp,$drawrules,<<0,0,0>>,0,0);

    /*
    $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
    $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    $NofCirclesa = (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
    $NofCirclesb = ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
    $NofCirclesc = ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);

    */


    clear $Xs;
    $centerX = $centerY = 0.0;
    $sides = 22.000;
    $PI = 3.1415926535;
    $away =15.00;
    $Yp=0.0;

    $r =  $away;
    $Cir = ($PI *$r )*2.00 ;
    $Seg = $Cir/8.0;
    $LengAngle = 360.000/$Seg;

    $Di = $Seg / ($Cir/100.0);
    $Di = 360.0/(100.0/$DiffMathA);


    $angle = $LengAngle / $sides;

    for( $i=0; $i <= $sides; $i++ ){
    // How far around the center.
    $a = $i * $angle ;
    $x = (($centerX + cos( deg_to_rad($a) ) * $away));
    $y =  (($centerY + sin( deg_to_rad($a) ) * $away));
    $Xs[$i] =<<$x, $Yp, $y>>;
    }
    $ThefirstCurve = VecArrayToCurve($Xs);




    proc LogCurveDetail(vector $Direction, vector $startV, float $L){
    //vector $Direction =<< 1.0,0.0,0.0>>;
    $Normal = << 0.0,1.0,0.0>>;
    $angle = 0.00;
    $i = 0;
    $Xs[$i] = $startV;

    $AstepF = 0.035;
    $TstepF = 1.025;
    $Step = 120;
    $LSS = 0.050;

    $a = 1.0;
    for( $i=1; $i <= $Step; $i++ ){

    $angle +=$AstepF;
    $angle*=1.025;
    // $a = `logN ($angle)` ;
    $a =  ($angle);
    $Xs[$i] = RotMultLenPts($Xs[$i-1], $Direction, $Normal, $L, deg_to_rad($a) );
    $Direction= `unit (FloatToVec(DirectionFN($Xs[$i],$Xs[$i-1])))`;
    }
    $ThefirstCurve = VecArrayToCurve($Xs);
    }

    ////////////////////////////////////////////



    clear $HighCurvePoints;
    clear $NormalCurvePoints;
    clear $FoundRadii;

    $HighCurvePoints = CurvatureUtilityDetailCurvature($CurveItemA[0], 260,$NormalCurvePoints,$FoundRadii);

    print $FoundRadii;
    $CurveSizeFloat = logN(logN(logN(`log (5.605099)`)));

    clear $CurvesV;
    $LS = 0.050;
    $Cindex = 0;
    if(`size($HighCurvePoints)`>0){
    for ($eachVec in $HighCurvePoints){
    LogCurveDetail(`unit $NormalCurvePoints[$Cindex]`*-1, $eachVec, 0.005 );

    $Cindex++;

    }
    }


    clear $CurvesV;
    $LS = 0.050;
    $Cindex = 0;
    if(`size($HighCurvePoints)`>0){
    for ($eachVec in $HighCurvePoints){
    LogCurveDetail(`unit $NormalCurvePoints[$Cindex]`*-1, $eachVec, abs (((logN(`log ($FoundRadii[$Cindex]/9.0)`)))));

    $Cindex++;

    }
    }


    $Cindex = 0;
    for ($eachVec in $HighCurvePoints){

    $XLOOG = abs  (((logN(`log ($FoundRadii[$Cindex]/8.0)`))));
    print ($XLOOG +"\n");
    $Cindex++;
    }

    //$a = $angle;
    //$Xs[$i] = $Xs[$i-1]+($L*( (FloatToVec(RotDirToPoint($Xs[$i-1],$Direction,$L,$Normal, deg_to_rad($a)) ))));
    // $Xs[$i] = $Xs[$i-1]+($L*(`unit(FloatToVec(RotDirToPoint($Xs[$i-1],$Direction,$L,$Normal, deg_to_rad($a)) ))`));
    //$Xs[$i] = $Xs[$i-1]+($L*(`unit(FloatToVec(RotDirToPoint($Xs[$i-1],$Direction,$L,$Normal, atan($a) )))`));



    proc vector RotMultLenPts(vector $Vecpt, vector $Direc, vector $DirNorm, float $Length, float $Radian){
    $DirecAB = ((unit(`rot $Direc $DirNorm $Radian`))*$Length)+$Vecpt;
    return $DirecAB;
    }


    proc float logN(float $x){
    $a = (`log (abs($x))`)*(`sign($x)`) ;
    return $a;
    }


    SteinerChain(22,5);
    SteinerChain(22, 3.2);

    proc string [] SteinerChain(float $RAa, float $RBb){
    //
    // float $RAa = 22.0;
    // float $RBb = 3.2;

    $pi = 3.1415926535;
    $Pi = 3.1415926535;
    if(!( $RAa==$RBb)){
    if( $RAa<$RBb){
    $RA = $RBb;
    $RB = $RAa;}else{ $RA = $RAa; $RB =  $RBb;}

    //float $RA = 22.0;
    //float $RB = 15.68;
    $circleA = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RA -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $circleB = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RB -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $R2 = $RA;
    $R1 = $RB;
    $DCircle = (($R2 - $R1)/2.0) + $R1 ;
    $Rii = (($R2 - $R1)/2.0);
    $SideA = $RB + $Rii;
    $SideB = $Rii*2;
    //GOT it for SURE
    //HightsOfIsoscelesTriangle($SideA, $SideB, $SideA)
    $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    $ArcangleC = $ArcangleC*2.0;
    $Aii = (`asin ($RB/($RB + $Rii))`);
    $number3 = 360.0/$ArcangleC2;

    ////////////////####
    ///////////////###
    $NumberCs = $number3;

    $n = $number3;
    $len = $DCircle;
    $r = $DCircle;
    $angle = 360.0 / $n ;
    print $angle;

    $x = createRegularPolygonX( $n, $r ) ;
    $y = createRegularPolygonY( $n, $r ) ;

    // create the n-sided polygon.
    $z = 0.0 ;




    $LItem = `ls -sl`;
    $VCirPosX = `xform -q -ws -t $LItem[0]`;


    matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 0.0;
    0.0, 0.0, 0.0, 1.0 >>;

    $Normal = <<0.0, 1.0, 0.0>>;


    $VecPairA[0]= <<0.0, 1.0, 0.0>>;
    $VecPairA[1]= $VecPairA[0]*2;

    $matrixA = TwoPointMatrixPlusAxisWorld($VecPairA, $EmptyVecA, 1);
    $matrixA  = TwoPointMatrixB($VecPairA);
    $DirectionStart = <<$matrixA[0][0], $matrixA[0][1], $matrixA[0][2] >>;
    $angle = 360.0 / ($n*2) ;
    $r = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($angle)) );
    $DirectionStart = <<$rotatsB[0], $rotatsB[1], $rotatsB[2] >>;
    $DirectionStartB = `unit($DirectionStartB)`;
    Loc $DirectionStartB;

    //RotMultLenToDirAddToPoint(float $PosA[], float $PosB[], float $Length, float $DirNormAx[], float $Radian)
    // float $rotatsA[] = RotDirToPoint($DirectionStart, $VCirPosX,$RA, $Normal, $a );
    $angle = 360.0 / $n ;




    for( $i = 0 ; $i < ($n) ; $i++ ) {
    $a = $i * $angle ;
    $r = RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($a)) );
    Loc $rotatsA;

    }


    for( $i = 0 ; $i < ($n) ; $i++ ) {
    $a = $i * $angle ;
    $r = RotDirToPoint($VCirPosX,$DirectionStart, $RB, $Normal, (deg_to_rad($a)) );
    Loc $rotatsA;

    }


    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < ($n) ; $i++ ) {
    $a = $i * $angle ;
    $r = RotDirToPoint($VCirPosX,$DirectionStartB, $r, $Normal, (deg_to_rad($a)) );
    $VrotatsA[$i] =   FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $r, $Normal, (deg_to_rad($a)) ));

    Loc $rotatsA;

    }
    //////////////////////////////////


    for( $i = 0 ; $i < $n ; $i++ ) {

    $a = $i * $angle ;
    $r = RotDirToPoint($VCirPosX,$DirectionStart, $r, $Normal, (deg_to_rad($a)) );

    $VrotatsCiH[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $RA, $Normal, (deg_to_rad(($a))) ));
    $VrotatsBiH[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $RB, $Normal, (deg_to_rad(($a))) ));
    Loc $VrotatsCiH[$i];

    $VrotatsCi[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStart, $RA, $Normal, (deg_to_rad($a)) ));
    $VrotatsBi[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStartB, $r, $Normal, (deg_to_rad($a)) ));

    $VrotatsAi[$i] = FloatToVec(RotDirToPoint($VCirPosX,$DirectionStart, $RB, $Normal, (deg_to_rad($a)) ));


    $CirclePts = <<$rotatsA[0], $rotatsA[1], $rotatsA[2] >>;

    $DirLine = DirectionFN($CirclePts, $VCirPosX);
    $Vperp = crossProduct( $DirLine, $Normal, 0, 0 );
    $Vperp = `unit($Vperp + $DirLine)`;
    $Vperp = crossProduct( $DirLine, ($Normal*-1.0), 0, 0 );
    $VperpN = `unit( ($VperpN) + ($DirLine))`;

    $Vperp = ($Rii/2.0)* $VperpN*-1.0;
    $VperpA = $CirclePts+$VperpA;
    Loc $VperpA;


    curve2points($VrotatsBi[$i],$VrotatsCiH[$i]);

    if($i>0){

    curve2points($VrotatsBi[$i-1],$VperpA);


    }
    if($i==0){
    $Templast= $VperpA;}

    $Vperp = ($Rii/2.0)*$DirLine;
    $VperpC = $CirclePts+$VperpC;
    Loc $VperpC;
    curve2points($VrotatsCi[$i],$VperpC);
    /////////////

    $Vperp = ( $Rii/2.0)*$Vperp*-1.0;
    $VperpB = $CirclePts+$VperpB;
    Loc $VperpB;
    curve2points($VrotatsBi[$i],$VperpB);

    /////////////////////

    $Vperp = (-1*$Rii/2.0)*$DirLine;
    $VperpD = $CirclePts+$VperpD;
    Loc $VperpD;

    curve2points($VrotatsAi[$i],$VperpD);
    curve2points($VrotatsBi[$i],$VrotatsBiH[$i]);

    if($i==($n-1)){
    curve2points($VrotatsBi[$i],$Templast);
    }

    $circlesC = `circle -c $rotatsA[0] $rotatsA[1] $rotatsA[2] -nr 0 0 1 -sw 360 -r ($Rii/2.0) -d 3 -ut 0 -tol 0.001 -s 16 -ch 1`;
    $circles[$i] = $circlesC[0];
    makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $circles[0];
    xform -cp $circles[$i];
    }



    //$circles[`size($circles)`] = $circleA[0];
    //$circles[`size($circles)`] = $circleB[0];
    select -r $circleA $circleB $circles ;
    //select -r $circles ;
    return $circles;
    }
    }


    proc  Circle3PtZB(){
    ResetTransEachSL;



    $selectionList = `ls -sl`;

    $veCPos1[0] = `xform -q -ws -t $selectionList[0]`;
    $veCPos1[1] = `xform -q -ws -t $selectionList[1]`;
    $veCPos1[2] = `xform -q -ws -t $selectionList[2]`;

    $p1 = `xform -q -ws -t $selectionList[0]`;
    $p2 = `xform -q -ws -t $selectionList[1]`;
    $p3 = `xform -q -ws -t $selectionList[2]`;

    // Get the vector p1-p2, p1-p3
    //
    $p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
    $p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
    $p1p4[0] = $p2[0]-$p3[0]; 		$p1p4[1] = $p2[1]-$p3[1]; 		$p1p4[2]= $p2[2]-$p3[2];

    // Get the normal to the plane formed by p1, p2, p3, which is the
    // cross prod of p1-p2 and p1-p3

    $normal = crossProduct( $p1p2, $p1p3, 0, 0 );


    //float $OrthoCenterC = midPoint2Pts( $FloatPos1, $p3 );
    $FloatPosZero = {0, 0, 0};
    $FloatDirection = DirectionF($FloatPosZero, $normal);
    $MultDirP = multiplyFloat(2, $FloatDirection);
    //float $FloatDirectionPoint[] = AddFloats($MultDirP, $FloatPos1);


    // Get the mid pts on each vector (the average of two pts)
    float $mid1[3], $mid2[3], $mid3[3];
    $mid1 = midPoint2Pts( $p1, $p2 );
    $mid2 = midPoint2Pts( $p1, $p3 );
    $mid3 = midPoint2Pts( $p2, $p3 );

    //$mid1 a-b $mid2 a-c $mid3 b-c


    // Get the perp. vectors to p1-p2 and p1-p3, which is the
    // cross prod of the normal vector with p1-p2 and p1-p3. Get these
    // as normalized vectors before sending them to lineIntersection

    float $perp_p1p2[3];
    float $perp_p1p3[3];
    float $perp_p1p4[3];
    $perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
    $perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
    $perp_p1p4 = crossProduct( $normal, $p1p4, 0, 1 );



    // Intersect the persp. vectors going through the mid pts.
    // The intersection is the center of the arc.
    //
    $center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
    //spaceLocator -p 0 0 0;
    //MoveObject2($center);

    //FloatDirPerpCenter is FloatDirPerpCenterA
    $FloatDirPerpCenter = DirectionF($center, $mid3);
    $FloatDirPerpCenter = DirectionF($center,$mid1);
    $FloatDirPerpCenter = DirectionF($center,$mid2);

    $FloatDirPointAB = DirectionF($p1, $p2);
    $FloatDirPointBC = DirectionF($p2, $p3);
    $FloatDirPointAC = DirectionF($p1, $p3);


    //MidPoint of Iso Tri
    $center = lineIntersection( $p1, $FloatDirPerpCenter, $p2, $FloatDirPointBC );


    $center = lineIntersection( $p3,  $FloatDirPerpCenterB, $p1, $FloatDirPointAB );


    $center = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );

    $center = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPerpCenter );

    $OrthoCenterCir = midPoint2Pts( $center9, $center );


    $Radius2HalfTimes2 = (distance2Pts( $center9, $center ))*2;
    $Radius2BHalf = (distance2Pts( $center9, $center ));

    // Find the radius for the circle and return the radius.
    //

    $r = distance2Pts( $p1, $center );
    $Radius3Half = $radiusZ/2;

    //string $circlesItemB[];
    //$circlesItemB[0] = Circles_Direction($OrthoCenterCir, $FloatDirection, $Radius2HalfTimes2);

    //string $circlesItemC[];
    //$circlesItemC[0] = Circles_Direction($OrthoCenterCir, $FloatDirection,  $Radius2BHalf);

    $circlesItem[0] = Circles_Direction($center, $FloatDirection, $radiusZ);


    }

    Circle3PtZB;




    clear $Xs;
    $centerX = $centerY = 0.0;
    $sides = 22.000;
    $PI = 3.1415926535;
    $away =22.0;
    $Yp=0.0;

    $r =  $away;
    $Cir = ($PI *$r )*2.00 ;
    $Seg = $Cir/8.0;

    $LengAngle = 360.000/$n;
    $angle = $LengAngle / $sides;

    $Start_angle = (90.0);

    for( $k=0; $k < $n; $k++ ){


    for( $i=0; $i <= $sides; $i++ ){
    // How far around the center.
    $a = ($i * $angle)+$Start_angle ;
    $End_angle=$a;
    $x = (($centerX + cos( deg_to_rad($a) ) * $away));
    $y =  (($centerY + sin( deg_to_rad($a) ) * $away));
    $Xs[$i] =<<$x, $Yp, $y>>;
    }
    $ThefirstCurve = VecArrayToCurve($Xs);
    $Start_angle = $End_angle;


    $Vec = VecCurveEnds({$ThefirstCurve});
    for($eachV in $VecCurEndsa){
    $Locs[0] = `Loc ($eachV)`;
    SetItemColorString ($Locs[0], 6);
    }
    }



    $centerX = $centerY = 0.0;
    $sides = 22.000;
    $PI = 3.1415926535;
    $away =15.00;
    $Yp=0.0;

    $r =  $away;
    $Cir = ($PI *$r )*2.00 ;
    $Seg = $Cir/8.0;
    $LengAngle = 360.000/$Seg;

    $angle = $LengAngle / $sides;

    for( $i=0; $i <= $sides; $i++ ){
    // How far around the center.
    $a = $i * $angle ;
    $x = (($centerX + cos( deg_to_rad($a) ) * $away));
    $y =  (($centerY + sin( deg_to_rad($a) ) * $away));
    $Xs[$i] =<<$x, $Yp, $y>>;
    }
    $ThefirstCurve = VecArrayToCurve($Xs);







    clear $Xs;
    $centerX = $centerY = 0.0;
    $sides = 22.000;
    $PI = 3.1415926535;
    $away =15.00;
    $Yp=0.0;

    $r =  $away;
    $Cir = ($PI *$r )*2.00 ;
    $Seg = $Cir/8.0;
    $LengAngle = 360.000/$Seg;

    $Di = $Seg / ($Cir/100.0);
    $Di = 360.0/(100.0/$DiffMathA);


    $angle = $LengAngle / $sides;

    for( $i=0; $i <= $sides; $i++ ){
    // How far around the center.
    $a = $i * $angle ;
    $x = (($centerX + cos( deg_to_rad($a) ) * $away));
    $y =  (($centerY + sin( deg_to_rad($a) ) * $away));
    $Xs[$i] =<<$x, $Yp, $y>>;
    }
    $ThefirstCurve = VecArrayToCurve($Xs);




    proc float[] createRegularPolygonY( int $n, float $r )
    {
    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * cos(deg_to_rad($a)) ;
    }
    return $x ;
    }
    proc float[] createRegularPolygonX( int $n,float $r )
    {
    $angle = 360.0 / $n ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $a = $i * $angle ;
    $x[$i] =  $r * sin(deg_to_rad($a)) ;
    }
    return $x ;
    }


    //arclen

    // 159.434902 = C of circle    .. 12.000  = bounding Box of object

    $Di = 12.000 / (159.434902/100.0);
    $LengAngle = 360.000/$DiffMathA;
    $angle = 180.000/$sides;

    clear $Xs;
    $centerX = $centerY = 0;
    $sides = 22.000;
    $PI = 3.1415926535;
    $away =25.378;
    $Yp=0.0;
    $Di = 12.0 / (159.434902/100.0);

    //float $DiffMathAB = 360.0/(100.0/$DiffMathA);

    $LengAngle = 360.0/(100.0/$DiffMathA);


    $angle = $LengAngle / $sides;

    for( $i=0; $i <= $sides; $i++ ){
    // How far around the center.
    $a = $i * $angle ;
    $x = (($centerX + cos( deg_to_rad($a) ) * $away));
    $y =  (($centerY + sin( deg_to_rad($a) ) * $away));
    $Xs[$i] =<<$x, $Yp, $y>>;
    }
    $ThefirstCurve = VecArrayToCurveB($Xs);




    SteinerChain(22,5);

    proc string [] SteinerChain(float $RAa, float $RBb){
    //
    //float $RA = 22.0;
    //float $RB = 15.680;
    $pi = 3.1415926535;
    $Pi = 3.1415926535;
    if(!( $RAa==$RBb)){
    if( $RAa<$RBb){
    $RA = $RBb;
    $RB = $RAa;}else{ $RA = $RAa; $RB =  $RBb;}
    //float $RA = 22.0;
    //float $RB = 15.68;
    $circleA = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RA -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $circleB = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RB -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
    $R2 = $RA;
    $R1 = $RB;
    $DCircle = (($R2 - $R1)/2.0) + $R1 ;
    $Rii = (($R2 - $R1)/2.0);
    $SideA = $RB + $Rii;
    $SideB = $Rii*2;
    //GOT it for SURE

    $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
    $ArcangleC = $ArcangleC*2.0;
    //float $Aii =  (`asin ($RB/($RB + $Rii))`);
    $number3 = 360.0/$ArcangleC2;
    $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
    $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
    $NofCirclesa = (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
    $NofCirclesb = ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
    $NofCirclesc = ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);

    $NumberCs = $number3;
    $n = $NumberCs;
    $len = $DCircle;
    $r = $DCircle;
    $x = createRegularPolygonX( $n, $r ) ;
    $y = createRegularPolygonY( $n, $r ) ;
    // create the n-sided polygon.
    $z = 0.0 ;
    for( $i = 0 ; $i < $n ; $i++ ) {
    $circlesC = `circle -c $x[$i] $y[$i] $z -nr 0 0 1 -sw 360 -r $Rii -d 3 -ut 0 -tol 0.001 -s 16 -ch 1`;
    $circles[`size($circles)`] = $circlesC[0];
    makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $circles[0];
    xform -cp $circles[0];
    //rotate -r -os 0 0 45 $circles[0];
    //aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "scene" $circleB[0] $circles[0];

    }
    //$circles[`size($circles)`] = $circleA[0];
    //$circles[`size($circles)`] = $circleB[0];
    select -r $circleA $circleB $circles ;
    //select -r $circles ;
    return $circles;
    }
    }









    $CurveItemAXX = `ls -sl`;


    $CurveItemAX = `ls -sl`;
    CurvesToPlane( $CurveItemAX);

    $CurveItemAX = `ls -sl`;
    VanishingCurvesS({$CurveItemAX[0]})



    $LengthsT = ArcLengthArray(`ls -sl`);
    AnglesofTriangle($LengthsT[0], $LengthsT[1], $LengthsT[2]);


    $LengthsM = ArcLengthArray(`ls -sl`);
    // Result: 41.305301 //

    $Lengths = ArcLengthArray(`ls -sl`);
    // Result: 48.907858 46.767741 35.03743 37.820183 //
    1          2          3     4

    for($eachF in $Lengths){
    $LengthsSub[`size($LengthsSub)`] = $eachF - $LengthsM[0];

    }
    print $LengthsSub;
    7.602557
    5.46244
    -6.267871
    -3.485118

    0.115505
    0.15301
    0.163837
    0.183377

    $PerDiff = percent_of($LengthsM[0], $Lengths[3]);
    // Result: 1.184058 //
    // Result: 1.132245 //
    // Result: 1.178891 //
    // Result: 1.09215 //

    $Lengths = ArcLengthArray(`ls -sl`);
    // Result: 0.115 0.153 0.163 0.183 //
    4       3      2       1
    print $LengthsC;



    $Positions = VecCurveEps($CurveItemAX[0]);



    //GetworldMatrix(string $object)

    matrix $CamMatrix[4][4];
    $CamMatrix = GetMatrix("ZCURVEModelingCAM");

    matrix $SbMatrix[4][4];
    $SbMatrix= GetMatrix("LiveSurfaceB");

    PrintMatrix($CamMatrix , 4);
    |   0.7071067812              0  -0.7071067812              0|
    |  -0.2988362387    0.906307787  -0.2988362387              0|
    |   0.6408563821   0.4226182617   0.6408563821              0|
    |             48             41             48              1|

    PrintMatrix($SbMatrix , 4);
    |   0.7071067812              0  -0.7071067812              0|
    |   0.6408563821   0.4226182617   0.6408563821              0|
    |   0.2988362387   -0.906307787   0.2988362387              0|
    |    47.51487706    40.68008189    47.51487706              1|


    matrix $CamMatrixR[4][4];
    $CamMatrixR = GetMatrix("ZCURVEModelingCAM");
    matrix $SbMatrixR[4][4];
    $SbMatrixR= GetMatrix("LiveSurfaceB");

    PrintMatrix($CamMatrixR , 4);
    |   0.3971478906              0  -0.9177546257              0|
    |  -0.2713874308   0.9552783621  -0.1174398283              0|
    |   0.8767111357     0.29570805   0.3793867865              0|
    |    65.68910652    31.48173412    28.38978033              1|

    PrintMatrix($SbMatrixR , 4);
    |   0.3971478906              0  -0.9177546257              0|
    |   0.8767111357     0.29570805   0.3793867865              0|
    |   0.2713874308  -0.9552783621   0.1174398283              0|
    |    65.02544355    31.25788598    28.10258772              1|


    $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM`;
    $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM`;
    // Result: <<48, 41, 48>>  //
    // Result: <<-25, 45, 0>>  //


    Loc $Cam_Trans;

    $Plane_Trans = `xform -q -ws -t LiveSurfaceB`;
    $Plane = `xform -q -ws -ro LiveSurfaceB`;


    setAttr "ZCURVEModelingCAM.rotateX" -25;
    setAttr "ZCURVEModelingCAM.rotateY" 45;
    setAttr "ZCURVEModelingCAM.rotateZ" 0;

    setAttr "ZCURVEModelingCAM.translate" 48 41 48;

    $PtsVec = PointArrayT(`ls -sl`);
    $FDirNorA = Normal3Points($PtsVec[0], $PtsVec[1],$PtsVec[2]);
    $VCrvPos_AA =  FloatToVec(AverageVectorPoint($PtsVec));

    makeCurvePointDirectionLength(22, $FDirNorA, $VCrvPos_AA);


    ////////////

    $PtsVec = PointArrayT(`ls -sl`);
    AnglesofTriangleThreeVec($PtsVec[0], $PtsVec[1],$PtsVec[2]);
    /////////////////



    $VCrvPos_A =  FloatToVec(AverageVectorPoint($PtsVec));
    Loc $VCrvPos_A;

    $LItem = `ls -sl`;
    $VLocPosX = `xform -q -ws -t $LItem[0]`;


    InsidePolygon($Positions,$VLocPosX);

    proc int InsidePolygon(vector $c[],vector $VLocPos_A)
    {

    $VCrvPos_A =  FloatToVec(AverageVectorPoint($c));

    $x = VecCom($VLocPos_A, 0);
    $y = VecCom($VLocPos_A, 1);

    // Convex is just a collection of points for the polygon
    // just replace that code in the for-loop to loop through the points in your polygon

    $PI = 3.1415926535;
    $angle = 0;
    $Di = 0;
    $Di = 0;
    $Arc = 0;
    $p1 = 0, $p1y = 0, $p2x = 0, $p2y = 0;
    $SizeV = size($c);
    int $TotalS, $indexState, $indexLeft, $indexRight, $countS, $NearIndex;
    $TotalS = $SizeV;
    $triarea = 0;
    $tri_areaM = 0;
    $countS =1;

    for ($i=0;$i< $SizeV; $i++) {

    $indexState = $i;
    $indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
    $indexRight = fmod(($indexState + $countS),$TotalS);
    $DistA = distance2Pts($c[$i], $c[$indexLeft]);
    $DistB = distance2Pts($c[$i], $c[$indexRight]);
    if($DistA<$DistB){
    $nearestIndex = $indexLeft;
    }else{$NearIndex = $indexRight;}
    /*
    $p1x = ( (VecCom($c[$i], 0)) - $x ); // point A X - X
    $p1y = ( (VecCom($c[$i], 1)) - $y ); // point A Y - Y
    $p2x = ( (VecCom($c[$NearIndex], 0)) - $x ); // point A's nearest neighbor X - X
    $p2y = ( (VecCom($c[$NearIndex], 1)) - $y ); // point A's nearest neighbor Y - Y
    */
    $aP = distance2Pts($c[$i], $c[$indexRight]);
    $bP = distance2Pts($VLocPos_A, $c[$indexRight]);
    $cP = distance2Pts($c[$i], $VLocPos_A);
    $triarea += 0.25* (sqrt ( ($aP+$bP+$cP)  * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP)  ));
    $aPm = distance2Pts($c[$i], $c[$indexRight]);
    $bPm = distance2Pts($VCrvPos_A, $c[$indexRight]);
    $cPm = distance2Pts($c[$i], $VCrvPos_A);
    $tri_areaM += 0.25* (sqrt ( ($aPm+$bPm+$cPm)  * ($bPm+$cPm-$aPm) * ($cPm+$aPm-$bPm) * ($aPm+$bPm-$cPm)  ));
    $DistanceMM += distance2Pts($c[$i], $VCrvPos_A);
    $Distance += distance2Pts($c[$i], $VLocPos_A);
    //$angle += Angle2D($p1x,$p1y,$p2x,$p2y);
    $Arc += distance2Pts($c[$i], $c[$indexRight]);
    }

    //print ("Tri_area: "+$triarea + "\n");
    //print ("Tri_areaM: "+$tri_areaM+ "\n");
    /*
    if (abs($angle) < $PI){
    print (" INSIDE " + "\n");
    }else{ print (" OUTSIDE! " + "\n");}
    */

    // if (equivalentTol($triarea, $tri_areaM,  0.00001) ==1){
    //print ("Tri_area INSIDE " + "\n");
    //}else{ print ("Tri_area OUTSIDE! " + "\n");}

    //   if (abs($angle) < $PI){//
    if (equivalentTol($triarea, $tri_areaM,  0.00001) ==1){
    return 1;
    }else{
    return 0;}

    }


    proc float VecCom(vector $Vai, int $XYZ){
    $x = $Vai.x;
    $y = $Vai.y;
    $z = $Vai.z;
    if($XYZ==0){$N=$x;} if($XYZ==1){$N=$y;} if($XYZ==2){$N=$z;}
    return $N;
    }


    proc float Angle2D(float $x1, float $y1, float $x2, float $y2)
    {
    $PI = 3.1415926535;
    $TWO_PI = 3.1415926535;

    float $dtheta,$theta1,$theta2;

    $theta1 = atan2($y1,$x1);
    $theta2 = atan2($y2,$x2);
    $dtheta = $theta2 - $theta1;

    while ($dtheta > $PI)
    $dtheta -= $TWO_PI;
    while ($dtheta < -$PI)
    $dtheta += $TWO_PI;


    return $dtheta;
    }

    /*


    $Arc = `arclen $CurveItemAX[0]`;
    $AverageVecCurve = AverageVectorPoint($Positions);

    //////////

    $DDistPt_toC = distance2Pts($VCrvPos_A, $VLocPos_A);
    $DDist = $Distance/float($TotalS);
    print ("Dist_each/SIZE: "+$DDist + "\n");
    //Dist_each/SIZE: 18.31929743
    print (" dist_to_M: "+ $DDistPt_toC+"  dist_each: "+$DDist + "\n");
    $DDist = $Distance+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    $DDist = $DistanceMM+(float($TotalS)*$DDistPt_toC)/float($TotalS);
    $DDist = $DistanceMM/float($TotalS);
    $MathA = $DDistMM/$DDist;
    $MathB = $DDistPt_toC/$MathA;
    print $Arc;
    outside
    dist_to_M: 8.210088295  dist_each: 10.678618
    dist_to_M: 10.98501803  dist_each: 19.20895454
    inside
    dist_to_M: 4.491177258  dist_each: 10.90761121
    dist_to_M: 2.733438324  dist_each: 15.81548968
    print (" distance to crv middle "+ $DDistPt_toC+" dist to each crv div "+$DDist + "\n");
    //float $Xpi = $PI/$angle;
    //float $XTpi = $Xpi*$angle;
    print ($angle + "\n");
    */


}


/******************************************************************************
 * @procedure StringArrayCountIndexDup
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $item (string)
 *   $list (string[])
 *   $Count (int)
 * @returns int[]
 *
 * @source working nowPolygonizeCURVES (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int[] StringArrayCountIndexDup(string $item, string $list[], int $Count)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $result = 0;
    int $index = 0;
    int $indexArray[];
    string $listItem;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $result = 0;
    $index = 0;

    for ($listItem in $list) {

    if ($item == $listItem){
    $indexArray[$result] = $index;
    $result++;}

    $index++;
    }
    $Count = $result;
    return $indexArray;

}


/******************************************************************************
 * @procedure AverageFloatArrays
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $FloatArrayA (float[])
 *   $FloatArrayB (float[])
 * @returns float []
 *
 * @source MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc float [] AverageFloatArrays(float $FloatArrayA[], float $FloatArrayB[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $Ix = 0;
    float $AddAll[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = ($eachF + $FloatArrayB[$Ix])/2.0;
    $Ix++;
    }
    return $AddAll;

}


/******************************************************************************
 * @procedure AddFloatArrays
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $FloatArrayA (float[])
 *   $FloatArrayB (float[])
 * @returns float []
 *
 * @source MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc float [] AddFloatArrays(float $FloatArrayA[], float $FloatArrayB[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $Ix = 0;
    float $AddAll[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = ($eachF + $FloatArrayB[$Ix]);
    $Ix++;
    }
    return $AddAll;

}


/******************************************************************************
 * @procedure DivideFloatArrays
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $FloatArrayA (float[])
 *   $DivideX (float)
 * @returns float []
 *
 * @source MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc float [] DivideFloatArrays(float $FloatArrayA[], float $DivideX)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $Ix = 0;
    float $AddAll[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] =  $eachF/$DivideX;
    $Ix++;
    }
    return $AddAll;

}


/******************************************************************************
 * @procedure DiffFloatArrays
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $FloatArrayA (float[])
 *   $FloatArrayB (float[])
 * @returns float []
 *
 * @source MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc float [] DiffFloatArrays(float $FloatArrayA[], float $FloatArrayB[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $Ix = 0;
    float $AddAll[];

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $Ix = 0;
    for($eachF in $FloatArrayA){
    $AddAll[$Ix] = abs (($eachF - $FloatArrayB[$Ix]));
    $Ix++;
    }
    return $AddAll;

}


/******************************************************************************
 * @procedure PercentDiffZeroOneArrays
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $FloatArrayA (float[])
 *   $FloatArrayB (float[])
 * @returns float
 *
 * @source MuchBetter SNAP for stereocurve (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc float PercentDiffZeroOneArrays(float $FloatArrayA[], float $FloatArrayB[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $Ix = 0;
    float $Fx = 0.0;
    float $AddAll;
    float $DiffMathA;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $Ix = 0;
    $Fx = 0.0;
    for($eachF in $FloatArrayA){
    if ($eachF != $FloatArrayB[$Ix]){
    $AddAll+= 1.0;
    }
    $Fx++;
    $Ix++;
    }

    //print ($AddAll +" "+$Fx+"\n");

    if($AddAll != 0){
    $DiffMathA =  $AddAll / ($Fx/100.0);
    }else{ $DiffMathA = 0;}

    return $DiffMathA;

}


/******************************************************************************
 * @procedure SortFloatArrayAndStringN
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $n (int)
 *   $allFloatToSort (float[])
 *   $ObjsCurve (string[])
 *   $EmptyStringNewOrder (string[])
 * @returns float []
 *
 * @dependencies IntArrayToStringArray, NewArrayOrderWithIndexKey, CreateIntIndex
 *
 * @source TANGENTZZMakeItSo (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc float [] SortFloatArrayAndStringN(int $n, float $allFloatToSort[], string $ObjsCurve[], string $EmptyStringNewOrder[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $sIze = `size($allFloatToSort)`;
    int $IndexTrack[] = CreateIntIndex(`size($aF)`);
    float $Floatlist[] = $allFloatToSort;
    float $aF[] = $allFloatToSort;
    string $stringIndexTrack[] = IntArrayToStringArray($IndexTrack);
    string $newOrderArray[] = NewArrayOrderWithIndexKey($stringIndexTrack, $ObjsCurve);

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    $Floatlist = $allFloatToSort;
    $sIze = `size($allFloatToSort)`;
    if (($n==$sIze)||($n>$sIze)){
    $n = $sIze-1;
    }
    //float $aF[] = { 1.0, 9.2, 0.445, 5.3, 0.6, 7.0, -0.8, -2.22, 4.133, 3.002};
    $aF = $allFloatToSort;
    $IndexTrack = CreateIntIndex(`size($aF)`);
    quickSort($aF, $IndexTrack, 0, $n);
    $stringIndexTrack = IntArrayToStringArray($IndexTrack);
    $newOrderArray = NewArrayOrderWithIndexKey($stringIndexTrack, $ObjsCurve);
    $EmptyStringNewOrder = $newOrderArray;
    return $aF;


}


/******************************************************************************
 * @procedure arrayMatch
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $array (string[])
 *   $match (string)
 * @returns int
 *
 * @source replaceNode (2020_11_07 23_28_22 UTC).mel
 ******************************************************************************/

proc int arrayMatch(string $array[], string $match)
{

    for ($item in $array)
    if ($item == $match)
    return true;

    return false;

}


/******************************************************************************
 * @procedure intArrayRemoveAtIndex
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $index (int)
 *   $list (int[])
 * @returns int
 *
 * @source THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int intArrayRemoveAtIndex(int $index, int $list[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $i;
    int $result[];
    int $len = size( $list );

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    print " intArrayRemoveAtIndex " ; print "line 49 "; print "\n" ;
    $len = size( $list );
    // Check for a valid index.
    if ( $index > $len  || $index < 0 ) {
    return( false );
    }
    for ( $i = 0; $i < $index; $i++ ) {
    $result[$i] = $list[$i];
    }
    for ( ; $i < $len - 1; $i++ ) {
    $result[$i] = $list[$i + 1];
    }
    $list = $result;
    return( true );

}


/******************************************************************************
 * @procedure AppendAllArrays
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $A (string[])
 *   $B (string[])
 * @returns string []
 *
 * @source THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc string [] AppendAllArrays(string $A[], string $B[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    string $AB[] = $A;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    print " AppendAllArrays " ; print "line 226 "; print "\n" ;
    $AB = $A;
    for($eachF in $B){
    $AB[`size($AB)`]= $eachF;
    }
    return $AB;

}


/******************************************************************************
 * @procedure IndexPairArrayFunc
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $XNum (int[])
 * @returns int []
 *
 * @source THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc int [] IndexPairArrayFunc(int $XNum[])
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $Si = `size($XNum)`;
    int $Ci = 0;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    print " IndexPairArrayFunc " ; print "line 325 "; print "\n" ;
    int $Zss,$Yss,$pair[];
    $Si = `size($XNum)`;
    $Ci = 0;
    if($Si>0){
    for($i=0; $i<$Si; $i++){
    $Zss = $XNum[$i]*2;
    $Yss = $Zss+1;
    $pair[$Ci++]= $Zss;
    $pair[$Ci++]= $Yss;
    }
    }
    return $pair;

}


/******************************************************************************
 * @procedure FloatArrayAB
 * @category  array
 * @layer     utility (Data)
 * @description Array manipulation
 *
 * @parameters
 *   $ptA (float)
 *   $ptB (float)
 *   $STEPFA (float)
 * @returns float []
 *
 * @source THE_one_EYED_Man_is_KING (2020_11_07 23_28_22 UTC).txt
 ******************************************************************************/

proc float [] FloatArrayAB(float $ptA, float $ptB, float $STEPFA)
{
    // ─────────────────────────────────────────────────────────────
    // VARIABLE DECLARATIONS
    // ─────────────────────────────────────────────────────────────
    int $St = 0;
    float $CrvTS;
    float $CrvTE;
    float $STEPF = $STEPFA-1.0;
    float $segN = ($CrvTE-$CrvTS)/$STEPF;
    float $FlineV[];
    float $AddS = $CrvTS;

    // ─────────────────────────────────────────────────────────────
    // PROCEDURE BODY
    // ─────────────────────────────────────────────────────────────

    print " FloatArrayAB " ; print "line 643 "; print "\n" ;
    if($ptA>$ptB){
    $CrvTS = $ptB;
    $CrvTE = $ptA;
    }else{
    $CrvTS = $ptA;
    $CrvTE = $ptB;
    }
    $STEPF = $STEPFA-1.0;
    $segN = ($CrvTE-$CrvTS)/$STEPF;
    $FlineV[0]=$CrvTS;
    $St = 0;
    $AddS = $CrvTS;
    for( $Vi=0; $Vi < $STEPF; $Vi++ ){
    $FlineV[$Vi+1] = $AddS+=$segN;
    $St++;
    }
    return $FlineV;

}

