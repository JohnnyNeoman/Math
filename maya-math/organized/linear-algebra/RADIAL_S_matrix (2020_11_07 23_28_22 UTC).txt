proc int [] DELETE_OR_KEEP(string $CURVES[]){

global int $in_front_of_PlaneX;
global vector $WORLD_AXIS_XYZ[];
int $TrackInfrontA[];
int $curves_Keep[];
string $myCPOC;
float $SizeC= `size($CURVES)`;
int $iC;
vector $PointCRV;
string $myCurvex;
vector $Zero =<<0,0,1.5>>;
for($iC=0; $iC<$SizeC; $iC++){
$myCurvex=$CURVES[$iC];
////
$myCPOC = `pointOnCurve  -ch on -pr 0.0 -p $myCurvex`;
			setAttr ($myCPOC +  ".parameter") 0.5 ;
			$PointCRV  = `getAttr  ($myCPOC + ".position")`;

/*
			$distanceA=PtDist_to_Plane({$PointCRV},{$Zero,$WORLD_AXIS_XYZ[0]});
		print ($in_front_of_PlaneX+"\n");
$TrackInfrontA[0]=$in_front_of_PlaneX;
			$distanceB=PtDist_to_Plane({$PointCRV},{$Zero,$WORLD_AXIS_XYZ[1]});
*/

			$distanceA=PtDist_to_Plane({$PointCRV},{$WORLD_AXIS_XYZ[0]});
		print ($in_front_of_PlaneX+"\n");
$TrackInfrontA[0]=$in_front_of_PlaneX;
			$distanceB=PtDist_to_Plane({$PointCRV},{$WORLD_AXIS_XYZ[1]});


$TrackInfrontA[1]=$in_front_of_PlaneX;
print ($in_front_of_PlaneX+"\n");
if(( $TrackInfrontA[0] ==0)&&( $TrackInfrontA[1] ==1)){
//if((`sign($TrackInfrontA[0])`==1)&&(`sign($TrackInfrontA[1])`==-1)){
$curves_Keep[$iC] = 1;
}else{
$curves_Keep[$iC] = 0;
}
delete $myCPOC;
}
print $TrackInfrontA;
return $curves_Keep;
}

//int $keep[];
//$keep=DELETE_OR_KEEP($allSegments);


proc vector [] RenderCurveSeg(string $SelC,float $STEPCrv,float $CrvTSi,float $CrvTEi){
//#print " RenderCurveSeg " ; print "line 870 "; print "\n" ;
	//float $STEPCrv =22.0;
	float $CreateSegAT[];
	$CreateSegAT =FloatArrayAB($CrvTSi,$CrvTEi,$STEPCrv);
	string $myCurvex =$SelC;
	$myCPOC = `pointOnCurve  -ch on -pr 0.0 -p $myCurvex`;
	vector $NewCurveVec[];
	int $SizeSeg=`size($CreateSegAT)`;	
	int $CountT=0;
	float $t=0;		
	for($a = 0; $a < $SizeSeg;$a++){
		$t =  $CreateSegAT[$CountT];
		if($t>=1){$t=1;}
		if($t<=0){$t=0;}			
		setAttr ($myCPOC +  ".parameter") $t ;
		$NewCurveVec[$CountT] = `getAttr  ($myCPOC + ".position")`;
		$CountT++;
	}
	delete $myCPOC;
	return $NewCurveVec;
}


global int $in_front_of_PlaneX;
global int $TrackInfront[];


proc float [] Cut_CRV_Axis(string $myCurvex,int $axis){

global vector $WORLD_AXIS_ORIGIN;
global vector $WORLD_AXIS_XYZ[];
vector $AXIS_XZY[];
$AXIS_XZY[0]=$WORLD_AXIS_ORIGIN;
$AXIS_XZY[1]=$WORLD_AXIS_XYZ[$axis];



global int $in_front_of_PlaneX;

global int $TrackInfront[];


	float $step,$values[],$a, $t,$distance,$smallest,$FactorX ;
$CurveSelection = `ls -fl  ($myCurvex+".ep[0:*]")`; 
		$CurveEPzCount = size($CurveSelection);
		$numEPs = size ($CurveSelection);
		$numEPrealNum2 = ( $numEPs -1 ) * 2; 
float $numEPrealNum3 = ( $numEPs -1 );
	string $myCPOC = `pointOnCurve  -ch on -pr 0.0 -p $myCurvex`;
float $ArcL=`arclen $myCurvex`;
float $Steps_toG = (1.0/$numEPrealNum3)/4;

		$step = $numEPrealNum2;
$step = $numEPrealNum3;
vector $PointCRV;
float $findPointU[];
$a =0;
//$t =  $a/$step; 
$t =0;
float $ArcLT,$Steps_toC,$Steps_toD;
$ArcLT= $ArcL;
int $TrackIT=0;
for($a = 0; $t <= 1.0;$a++){
		
			setAttr ($myCPOC +  ".parameter") $t ;
			$PointCRV  = `getAttr  ($myCPOC + ".position")`;
		$distance=PtDist_to_Plane({$PointCRV},$AXIS_XZY);
print ($in_front_of_PlaneX+"\n");
if($TrackIT==0){
$TrackInfront[`size($TrackInfront)`]=$in_front_of_PlaneX;
}
$TrackIT++;
if($distance<$ArcL){

$Steps_toC =PercentofN($ArcL,$distance);
$Steps_toD =((100.0-$Steps_toC)/100.0)/2.0;
$t += $Steps_toD;
}
if($distance<0.0008){
$TrackIT=0;
Loc $PointCRV;
$findPointU[`size($findPointU)`] = $t;
print ("steps Taken : "+$a+"\n");
$t +=$Steps_toG;
}
if($a>3900){break;}

}
delete $myCPOC;
return $findPointU;
}



proc float PtDist_to_Plane(vector $V[],vector $VecN[]){
global int $in_front_of_PlaneX;
	vector $p =  $VecN[0];
vector $n1 = $VecN[1];
	float $D, $D1;	
	vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
$F = $n1;
$e = $V[0];
$M = $e+($F);
$D = distance2PtS($e, $p);
if((`sign ($D)`==1)||($D==0)){
$in_front_of_PlaneX=1; print $D;
}else{$in_front_of_PlaneX=0; print $D;
}		
		$P1 = ClosestPoint2LineVec($n1, $p, $e);		
		$D1 = distance2Pts($P1, $p); 
	return $D1;
}


proc float distance2PtS( float $p1[], float $p2[] ){
	float $distance;
	float $v[3];
	$v[0] = $p1[0] - $p2[0];
		$distance = $v[0];
	return $distance;
}

// radial
/*


global vector $WORLD_AXIS_XYZ[];
$WORLD_AXIS_XYZ[0]=<<1,0,0>>;
$WORLD_AXIS_XYZ[1]=<<0,0,1>>;
	global vector $WORLD_AXIS_ORIGIN;
	$WORLD_AXIS_ORIGIN=<<0,0,0>>;


//////////START 
PencilCurveTool;

string $CRV_Item[] =`ls -sl`;
rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 22 -d 3 -tol 0.05 $CRV_Item[0];

float $N_Us[];
clear $N_Us;
$N_Us= Cut_CRV_Axis($CRV_Item[0],0);

print $TrackInfront;
clear $TrackInfront;

float $N_UsB[];
clear $N_UsB;
$N_UsB= Cut_CRV_Axis($CRV_Item[0],1);

	float $N_UsS[];
	$N_UsS=$N_Us;
	float $Usize= `size($N_UsB)`;
	for($iC=0; $iC<$Usize; $iC++){
	$N_UsS[`size($N_UsS)`]=$N_UsB[$iC];
	}
print $N_UsS;

//print $N_Us;
//$N_UsS=$N_UsB;
$N_UsS =`sort($N_UsS)`;
string $allSegments[];
$allSegments = Cut_and_Mirror($N_UsS,$CRV_Item[0]);

int $keep[];
$keep=DELETE_OR_KEEP($allSegments);
string $keepCRV[];
int $iC;
for($iC=0; $iC<`size($keep)`; $iC++){
if($keep[$iC]==1){
$keepCRV[`size($keepCRV)`]=$allSegments[$iC];
}else{delete $allSegments[$iC];}
}



/// for each in remaining CRV get vectors // this is just to test the radial SCRIPTS
string $eachCRV;		
vector $PtsZ_A[];
vector $AXIS=<<1,0,0>>;
vector $RotatedAxis = $AXIS;
vector $CRVSEG_A[];
vector $CRVSEG_B[];
for ($eachCRV in $keepCRV ){
$PtsZ_A = VecCurveCvs($eachCRV);
$CRVSEG_B= $PtsZ_A;
float $theta =90;
	for($Inx = 0; $Inx < 3; $Inx++){
$CRVSEG_B=VecPointsMirrorVecPlaneN($CRVSEG_B,{<<0,0,0>>,$RotatedAxis});
PAUSE;
UnitMATRIX;
SetGMATRIX;
matrix $MatrixC[4][4];
$MatrixC= $MatrixGlobalA;
matrix $MatrixD[4][4];
$MatrixD= $MatrixGlobalA;
yrotMATRIX(($theta));
SetGMATRIX;
$MatrixD= $MatrixGlobalA;
vector $One[];
$One=MultPointMatrixArray({$RotatedAxis}, $MatrixC,$MatrixD);
$RotatedAxis= $One[0];
}

}


	for($Inx = 0; $Inx <= (360/45); $Inx++){
//$MatrixC= $MatrixGlobalA;	







$Inx++;



proc vector [] VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){
	vector $p =  $VecN[0];
vector $n1 = $VecN[1];
	float $D, $D1;	
	vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
$F = $n1;
	int $C1;
	$C1=0; 
	for($e in $V){	
		$M = $e+($F);
		$D = distance2Pts($e, $p);
		$F2 = $p+($D*$n1);	
		$P1 = ClosestPoint2LineVec($n1, $p, $e);
		$F3 = DirectionF($P1, $p);
		$D1 = distance2Pts($P1, $p);
		$F4 = $e+(($D1*2.0)*$F3);
$O[$C1] = $F4;
		$C1++;
	}
	VecArrayToCurveB($O);
	ResetTransEachSL;	
 
	return $O;
}


proc float VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){
	vector $p =  $VecN[0];
vector $n1 = $VecN[1];
	float $D, $D1;	
	vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
$F = $n1;
$e = $V[0];
		$M = $e+($F);
		$D = distance2Pts($e, $p);
		$F2 = $p+($D*$n1);	
		$P1 = ClosestPoint2LineVec($n1, $p, $e);
		$F3 = DirectionF($P1, $p);
		$D1 = distance2Pts($P1, $p); 
	return $D1;
}



string $item[]=`ls -sl`;
select -r $item[0];
	vector $PositionsZ_A[];
	$PositionsZ_A = VecCurveEps($item[0]);
	vector $Pts_CRV[];




$Pts_CRV=$PositionsZ_A;	
float $theta =90; 
UnitMATRIX;
SetGMATRIX;
matrix $MatrixC[4][4];
$MatrixC= $MatrixGlobalA;
PrintMatrix($MatrixC , 4);	
matrix $MatrixD[4][4];
$MatrixD= $MatrixGlobalA;
matrix $MatrixE[4][4];
$MatrixE=$MatrixGlobalA;
int $Inx;
$Inx = 2;

//	for($Inx = 0; $Inx <= (360/45); $Inx++){
//$MatrixC= $MatrixGlobalA;	

//UnitMATRIX;
//SetGMATRIX;

yrotMATRIX(($theta));
SetGMATRIX;
$MatrixD= $MatrixGlobalA;

if(fmod($Inx,3)==0){
print " YES 3 ";}

if(fmod($Inx,3)==0){
print "  YES 2  ";

/*
$MatrixC[0][0]=($MatrixC[0][0]*-1);
$MatrixC[1][0]=($MatrixC[1][0]*-1);
$MatrixC[2][0]=($MatrixC[2][0]*-1);
*/
$MatrixD[0][0]=($MatrixD[0][0]*-1);
$MatrixD[1][0]=($MatrixD[1][0]*-1);
$MatrixD[2][0]=($MatrixD[2][0]*-1);

$MatrixD[3][3]=($MatrixD[3][3]*-1);

}


vector $RotatedAxis=MultPointMatrixArray({$AXIS}, $MatrixC,$MatrixD);
string $ThefirstCurve = VecArrayToCurve($Pts_CRV);

$Inx++;

$MatrixE=$MatrixD;
	
$MatrixGlobalA=$MatrixE;
SetGMATRIX;



$Mn  = MatrixToFloat($MatrixGlobalA);
ShowMatrixAXIS($Mn);
}










what need to be done is make  it so that .. name sysmetry

*/


proc string [] Cut_and_Mirror(float $N_Us[],string $CRV_ItemI){
global vector $WORLD_AXIS_XYZ[];
global vector $WORLD_AXIS_ORIGIN;
string $NewCutCRVs[];
string $Sel[];
$Sel[0]=$CRV_ItemI;
int $SizeCuts = `size($N_Us)`;
float $iU[]=$N_Us;
float $Arc =`arclen($CRV_ItemI)`;
if($SizeCuts>0){
				int $m_Or_e[];
				float $TempU[];
				int $Tsize=`size($iU)`;							
				if($Tsize!= 1){
					
					float $MperS= ($Arc*($iU[0]));
					float $MperE= ($Arc*(1-$iU[$SizeCuts-1]));
					if( $MperS >= 5.5){
						$TempU[`size($TempU)`]=0.0;
						$m_Or_e[`size($m_Or_e)`]=1;
						}
					for($iC=0; $iC<$SizeCuts; $iC++){
						$TempU[`size($TempU)`]=$iU[$iC];
					}
					for($iC=0; $iC<$SizeCuts-1; $iC++){
						$m_Or_e[`size($m_Or_e)`]=0;
					}
					if($MperE>=5.5){
						$TempU[`size($TempU)`]=1.0;
						$m_Or_e[`size($m_Or_e)`]=2;
						}
					$iU=$TempU;
				}

				if($Tsize== 1){
					float $TempU[];
					float $TempUi[];
					$TempUi[0]=0.0;
					$TempUi[1]=$iU[0];
					$TempUi[2]=1.0;
					$iU=$TempUi;
					float $MperS= (100*($iU[1]));
					float $MperE= (100*(1-$iU[1]));
					if( $MperS >= 15){$TempU[`size($TempU)`]=0.0; $m_Or_e[`size($m_Or_e)`]=1;  }
					$TempU[`size($TempU)`]=$iU[1];
					if($MperE>=15){$TempU[`size($TempU)`]=1.0; $m_Or_e[`size($m_Or_e)`]=2; }
					clear $iU;
					$iU=$TempU; 
				}



vector $AXIS_XZY[];
$AXIS_XZY[0]=$WORLD_AXIS_ORIGIN;
$AXIS_XZY[1]=$WORLD_AXIS_XYZ[0];

$AXIS_Z[0]=$WORLD_AXIS_ORIGIN;
$AXIS_Z[1]=$WORLD_AXIS_XYZ[1];




				
				vector $CRVSEG_A[];
				float $Hsize= `size($iU)`;
				$Hsize-=1;

				for($iC=0; $iC<$Hsize; $iC++){
					clear $CRVSEG_A;
					float $CrvTSi = $iU[$iC];
					float $CrvTEi = $iU[$iC+1];
					float $Mper= ($Arc*($iU[$iC+1]-$iU[$iC]));
					vector $CRVSEG_A[];
					$CRVSEG_A=RenderCurveSeg($Sel[0],22,$CrvTSi,$CrvTEi);
PAUSE;
					$NewCutCRVs[`size($NewCutCRVs)`]=VecArrayToCurveB($CRVSEG_A);
				}
delete $Sel[0];
}else{ $NewCutCRVs[`size($NewCutCRVs)`]=$Sel[0]; }

return $NewCutCRVs;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




string $quickFix[] = `ls -sl `;
	vector $Positions[];	
clear $Positions;
$Positions = PointArrayT($quickFix);

//proc vector [] VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){

vector $VecN[];
$VecN={(<<0,0,0>>),(<<1,0,0>>)};
vector $V[];
$V={$Positions[0]};
vector $p =  $VecN[0];
vector $n1 = $VecN[1];

float $D, $D1;	
vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
$F = $n1;
int $C1;
$C1=0; 

/////////////for($e in $V){////////////	
$e = $V[0];
$M = $e+($F);


		$D = distance2PtS($e, $p);

if((`sign ($D)`==1)||($D==0)){
print ("yes"+"\n");
}else{print ("NO!"+"\n");}

proc float distance2PtS( float $p1[], float $p2[] ){
	float $distance;
	float $v[3];
	$v[0] = $p1[0] - $p2[0];
		$distance = $v[0];
	return $distance;
}



		$F2 = $p+($D*$n1);	
		$P1 = ClosestPoint2LineVec($n1, $p, $e);
		$F3 = DirectionF($P1, $p);
		$D1 = distance2Pts($P1, $p);
		$F4 = $e+(($D1*2.0)*$F3);
$O[$C1] = $F4;
		$C1++;
	}
	VecArrayToCurveB($O);
	ResetTransEachSL;	
 
	return $O;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////

///////////////////////////////////





proc vector [] VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){
	vector $p =  $VecN[0];
vector $n1 = $VecN[1];
	float $D, $D1;	
	vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
$F = $n1;
	int $C1;
	$C1=0; 
	for($e in $V){	
		$M = $e+($F);
		$D = distance2Pts($e, $p);
		$F2 = $p+($D*$n1);	
		$P1 = ClosestPoint2LineVec($n1, $p, $e);
		$F3 = DirectionF($P1, $p);
		$D1 = distance2Pts($P1, $p);
		$F4 = $e+(($D1*2.0)*$F3);
$O[$C1] = $F4;
		$C1++;
	}
	VecArrayToCurveB($O);
	ResetTransEachSL;	
 
	return $O;
}








vector $D_v =<<0,0,1>>;
//vector $D_v =<<-1,0,0>>;
Loc $D_v;
vector $N_roti[];
clear $N_roti;
$N_roti=RotateDir_Axis(1, 45, <<1,0,0>>, $D_v);
LocS $N_roti;

print $N_roti;


$N_roti[0]=RotateDir_Axis(1, 45, <<1,0,0>>, $N_roti[0]);
LocS $N_roti;



	proc yrotMATRIX(float $theta) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
	global float $PI_Static;

		$theta *= ($PI_Static / 180.0);
		float $ct = cos($theta);
		float $st = sin($theta);
		float $Nxx = (float) ($xx * $ct + $zx * $st);
		float $Nxy = (float) ($xy * $ct + $zy * $st);
		float $Nxz = (float) ($xz * $ct + $zz * $st);
		float $Nxo = (float) ($xo * $ct + $zo * $st);
		float $Nzx = (float) ($zx * $ct - $xx * $st);
		float $Nzy = (float) ($zy * $ct - $xy * $st);
		float $Nzz = (float) ($zz * $ct - $xz * $st);
		float $Nzo = (float) ($zo * $ct - $xo * $st);
		$xo = $Nxo;
		$xx = $Nxx;
		$xy = $Nxy;
		$xz = $Nxz;
		$zo = $Nzo;
		$zx = $Nzx;
		$zy = $Nzy;
		$zz = $Nzz;
	}
	



	proc vector [] RotateDir_Axis(float $Rot_T, float $theta, vector $Axis, vector $Direct) {
	
vector $Direction[];
	float $xx, $xy, $xz;
	float $zx, $zy, $zz;
	$xx=$Axis.x; $xy=$Axis.y; $xz=$Axis.z;	
	$zx=$Direct.x; $zy=$Direct.y; $zz=$Direct.z;	
		float $PI_Static = 3.14159265;
		
		$theta *= ($PI_Static / 180.0);
	float $ct = cos($theta);
		float $st = sin($theta);

float $Nzx[];

for($i = 0; $i < 4;$i++){
	float $ct = cos($theta);
		float $st = sin($theta);
		
		$Nzx[0] = (float) ($zx * $ct + $xx * $st);
		$Nzx[1] = (float) ($zy * $ct + $xy * $st);
		$Nzx[2] = (float) ($zz * $ct + $xz * $st);		
		float $zxi = $Nzx[0];
		float $zyi = $Nzx[1];
		float $zzi = $Nzx[2];
		$zx = $Nzx[0];
		$zy = $Nzx[1];
		$zz = $Nzx[2];

$theta+=$theta;
		
$Nzx=$Direction[$i]=`unit(<<$zx, $zy, $zz>>)`;	
		$zx = $Nzx[0];
		$zy = $Nzx[1];
		$zz = $Nzx[2];
}	
		return $Direction;
		}

proc string [] LocS(vector $VEC_pt[]){

float $Points[];
string $LocObject[],$LocObjectsi[];
int $Size =`size($VEC_pt)`;
for($i = 0; $i < $Size;$i++){
$Points = $VEC_pt[$i];
$LocObject= `spaceLocator -p 0 0 0`;
$LocObjectsi[$i]=$LocObject[0];
setAttr ($LocObject[0]+".translate")  $Points[0] $Points[1] $Points[2];
}
	return $LocObjectsi;
}


	proc vector RotateDir_Axis(float $Rot_T, float $theta, vector $Axis, vector $Direct) {
	
	float $xx, $xy, $xz;
	float $zx, $zy, $zz;
	$xx=$Axis.x; $xy=$Axis.y; $xz=$Axis.z;	
	$zx=$Direct.x; $zy=$Direct.y; $zz=$Direct.z;	
		float $PI_Static = 3.14159265;
		
		$theta *= ($PI_Static / 180.0);


		float $ct = cos($theta);
		float $st = sin($theta);	
		float $Nzx = (float) ($zx * $ct - $xx * $st);
		float $Nzy = (float) ($zy * $ct - $xy * $st);
		float $Nzz = (float) ($zz * $ct - $xz * $st);		
		$zx = $Nzx;
		$zy = $Nzy;
		$zz = $Nzz;
		
		vector $Direction =<<$zx, $zy, $zz>>;		
		return $Direction;
		}



//Programing tools and scripts toorganize script


string $CurveEnds3D[];
	$CurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
//curve made
//if it is on the ZY plane or one or both vector are onthe posidtive side
//place into a set or layer

/// 

proc int[] SortNumbersIntIndex(float $allFloatToSort[]){
int $IndexTrack[];
float $aF[] = $allFloatToSort;
int $sIze = `size($aF)`-1;      
$IndexTrack = CreateIntIndex(`size($aF)`);
quickSort($aF, $IndexTrack, 0, $sIze);
$IndexTrack = ReverseIntArray($IndexTrack);
return $IndexTrack;
}

proc int [] IndexPairFunc(int $XNum){
	int $Zss = $XNum*2;
	int $Yss = $Zss+1;
	int $pair[];
	$pair={$Zss,$Yss};
	return $pair;
}

proc int IndexPairFuncN(int $XNum, int $XNumV){
	int $Zss = $XNum*2;
	int $Yss = $Zss+1;
	int $AB;
	if($XNumV==0){
		$AB=$Zss;
	}    
else{$AB=$Yss;}    

	return $AB;
}

proc int [] CreateIntIndex(int $ArraySize){
int $iNdex = 0;
int $IntArrayInex[];
while($iNdex < $ArraySize){
$IntArrayInex[$iNdex] = $iNdex;
$iNdex++;
}
return $IntArrayInex;
}  




proc vector [] ProjectCrv2PlaneNormalP(vector $vecRs[],vector $AvN,vector $Midp){
vector $vecRsA[];
vector $NewPtsP[];
vector $PtsVec;
vector $Tran;
float $RowA[],$RowB[],$RowC[],$Pts[],$AxisO[],$PtZ[];
vector $DirectC = DirectionFN($vecRs[0], $Midp);
vector $tan = crossProduct($DirectC,$AvN, 0, 0 );
 	$RowA = $tan;
	$RowB = $DirectC;
	$RowC = $AvN;
// cent of matrix 
 $AxisO = $Tran = $Midp;
int $SizeVp =`size($vecRs)`;
vector  $Xv,$Dv,$ZEROIi;
float $valN;
int $CountF[];
int $CountFN=0;
for($Ind=0; $Ind<$SizeVp; $Ind++){
$PtsVec=$vecRs[$Ind];
 $Pts = $PtsVec;
$PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
$PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
$PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
 $Xv = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
 $Dv=DirectionF($Xv,$PtsVec);
 $ZEROIi = $Dv*$AvN;
$valN= $ZEROIi.x*$ZEROIi.y*$ZEROIi.z;
  	$sign = `sign $valN`;
  	$valN = (int) (($valN + $sign*5/(1.0*10)) * 1.0);
  	$valN = ($valN/1.0);
if($valN==1){
$NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
$vecRsA[$CountFN]=$PtsVec;
$CountF[$CountFN]=$Ind;
$CountFN++;
}
}
vector $V[];
$V= $vecRsA;
	vector $p = `xform -q -ws -t "LiveSurfaceB"`;
	vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
	vector $n1 =$AvN; 
	float $D, $D1;
	vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
	int $C1;
	$C1=0; 
	for($e in $V){
		$F = DirectionF($C, $e);
		$M = $e+($F);
		$D = distance2Pts($e, $p);
		$P1 = ClosestPoint2LineVec($n1, $p, $e);
		$F4 = $NewPtsP[$C1];
		$P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
		$F1 = DirectionF($P, $M);
		$O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
		$C1++;
	}
matrix $MatrixNewB[4][4];  
$MatrixNewB = GetMatrix("ZCURVEModelingCAM");
	 $MtxF  = MatrixToFloat($MatrixNewB);	
 	$RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
	$RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
	$RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};
int $trackit[];
int $TF=0;
vector $RECORD[];
int $SizeC =`size($O)`;
for($Ind=0; $Ind<$SizeC; $Ind++){
$PtsVec= $O[$Ind];
 $Pts = $PtsVec;
$PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
$PtZ[2] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
$PtZ[1] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
$TF=rectContains(-0.5,-0.5, 1.0, 1.0,$PtZ[0], $PtZ[2]);
if($TF==1){
$RECORD[`size($RECORD)`]=$O[$Ind];
}
$TF=0;
}
return $RECORD;
}

////////////////////////////////////////////////////////////



proc float [] ClosestPoint2Line(float $DirectionLineF[], float $PointOnLine[], float  $PointN[]){
		vector $VlocA;
	vector $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
	vector $VecLineDir = PositiveDir($DirectionLineF);
	float $locsA[];
	vector $VecLineDirM = $VecLineDiri-$VecLineDir;
	float $Addit[] = $VecLineDirM ;
	float $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
vector $DF = FloatToVec($DirectionLineF);
vector $PoL = FloatToVec($PointOnLine);
vector $PN = FloatToVec($PointN);
vector $A,$N1,$A2,$N2;
	if($AdditR != 0.0){
$A =($DF*1.0)+$PoL;
		$N1 = Normal3Points($PoL, $A, $PN);
		float $Dist2LStart = distance2Pts( $PN , $PoL);
$A2 =($Dist2LStart*$N1)+$PoL;
		$N2 = Normal3Points($PoL, $A2, $A);
$A3 =($Dist2LStart*$N2)+$PoL;
		$locsA = lineIntersection($PN, $A3, $PoL,  $DF);	
	}else{$locsA =  $PointN ;}
	return $locsA;
}
proc vector ClosestPoint2LineVec(float $DirectionLineF[], float $PointOnLine[], float  $PointN[]){
	vector $VlocA;
	vector $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
	vector $VecLineDir = PositiveDir($DirectionLineF);
	float $locsA[];
	vector $VecLineDirM = $VecLineDiri-$VecLineDir;
	float $Addit[] = $VecLineDirM ;
	float $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
vector $DF = FloatToVec($DirectionLineF);
vector $PoL = FloatToVec($PointOnLine);
vector $PN = FloatToVec($PointN);
vector $A,$N1,$A2,$N2;
	if($AdditR != 0.0){
$A =($DF*1.0)+$PoL;
		$N1 = Normal3Points($PoL, $A, $PN);
		float $Dist2LStart = distance2Pts( $PN , $PoL);
$A2 =($Dist2LStart*$N1)+$PoL;
		$N2 = Normal3Points($PoL, $A2, $A);
$A3 =($Dist2LStart*$N2)+$PoL;
		$locsA = lineIntersection($PN, $A3, $PoL,  $DF);
		$VlocA = <<$locsA[0],$locsA[1],$locsA[2]>>;
	}else{$VlocA = FloatToVec($PointN);}
	return $VlocA;
}





global string $CurveNames[];
global int $MCurveIndex[];
global vector $AllKnowVecEnds[];

global vector $AllKnowVecEnds[];

vector $LocCurveEndsVec[] =ProjectCrv2PlaneNormalP($AllKnowVecEnds,$CamNormal*-1,$CamPosA[0]);

global int $Ind3dV2P[];
global vector $AllKnowVecsInView[];

$Ind3dV2P[]

proc vector [] ProjectCrv2PlaneNormalPindex(vector $vecRs[],vector $AvN,vector $Midp){
global int $Index3dVecs2P[];
global vector $AllKnowVecsInView[];
clear $Index3dVecs2P;
clear $AllKnowVecsInView;

vector $vecRsA[];
vector $NewPtsP[];
vector $PtsVec;
vector $Tran;
float $RowA[],$RowB[],$RowC[],$Pts[],$AxisO[],$PtZ[];
vector $DirectC = DirectionFN($vecRs[0], $Midp);
vector $tan = crossProduct($DirectC,$AvN, 0, 0 );
 	$RowA = $tan;
	$RowB = $DirectC;
	$RowC = $AvN;
// cent of matrix 
 $AxisO = $Tran = $Midp;
int $SizeVp =`size($vecRs)`;
vector  $Xv,$Dv,$ZEROIi;
float $valN;
int $CountF[];
int $CountFN=0;
for($Ind=0; $Ind<$SizeVp; $Ind++){
$PtsVec=$vecRs[$Ind];
 $Pts = $PtsVec;
$PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
$PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
$PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
 $Xv = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
 $Dv=DirectionF($Xv,$PtsVec);
 $ZEROIi = $Dv*$AvN;
$valN= $ZEROIi.x*$ZEROIi.y*$ZEROIi.z;
  	$sign = `sign $valN`;
  	$valN = (int) (($valN + $sign*5/(1.0*10)) * 1.0);
  	$valN = ($valN/1.0);
if($valN==1){
$NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
$vecRsA[$CountFN]=$PtsVec;
$CountF[$CountFN]=$Ind;
$CountFN++;
}
}
vector $V[];
$V= $vecRsA;
	vector $p = `xform -q -ws -t "LiveSurfaceB"`;
	vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
	vector $n1 =$AvN; 
	float $D, $D1;
	vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
	int $C1;
	$C1=0; 
	for($e in $V){
		$F = DirectionF($C, $e);
		$M = $e+($F);
		$D = distance2Pts($e, $p);
		$P1 = ClosestPoint2LineVec($n1, $p, $e);
		$F4 = $NewPtsP[$C1];
		$P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
		$F1 = DirectionF($P, $M);
		$O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
		$C1++;
	}
matrix $MatrixNewB[4][4];  
$MatrixNewB = GetMatrix("ZCURVEModelingCAM");
	 $MtxF  = MatrixToFloat($MatrixNewB);	
 	$RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
	$RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
	$RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};
int $trackit[];
int $TF=0;
int $TFcn=0;
vector $RECORD[];
int $SizeC =`size($O)`;
for($Ind=0; $Ind<$SizeC; $Ind++){
$PtsVec= $O[$Ind];
 $Pts = $PtsVec;
$PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
$PtZ[2] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
$PtZ[1] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
$TF=rectContains(-0.5,-0.5, 1.0, 1.0,$PtZ[0], $PtZ[2]);
if($TF==1){
$RECORD[$TFcn`]=$O[$Ind];
$AllKnowVecsInView[$TFcn]= $vecRsA[$Ind];
$FinalIndex[$TFcn]=$CountF[$Ind];
$TFcn++;
}
$TF=0;
}
$Ind3dV2P=$FinalIndex;
return $RECORD;
}








/*
temp
string $CurveNames[];
$CurveNames= `ls -sl`;
$AllKnowVecEnds = GetVectorArrayCRVEnds($CurveNames);
print $AllKnowVecEnds;
*/

int $MCurveIndex[];
 $MCurveIndex= CreateIntIndex(`size($AllKnowVecEnds)`);

string $NewCurveNames[];
clear $NewCurveNames;
$NewCurveNames= `ls -sl`;
vector $NewVecEnds[] = GetVectorArrayCRVEnds($NewCurveNames);

	float $dist_A[] = ArrayDistancesVecTofloat($AllKnowVecEnds, $NewVecEnds[0]);
	float $dist_B[] = ArrayDistancesVecTofloat($AllKnowVecEnds, $NewVecEnds[1]);
int $DistSortA[];
int $DistSortB[];

$DistSortA=SortNumbersIntIndex($dist_A);
$DistSortB=SortNumbersIntIndex($dist_B);
float $SmallestDistA =$dist_A[$DistSortA[0]];
float $SmallestDistB =$dist_B[$DistSortB[0]];


/*
what has to happen here.. 
the  vector indexing system
there are four vectors
a new curve is added to two existing curves
there are four vectors
and now two new vectors
*/



int $CountConnect[];

if($SmallestDistA<3){
$CountConnect[0]=1;
int $A = $DistSortA[0];
vector $Avec = $AllKnowVecEnds[$DistSortA[0]];
int $CurveIndexA;
 $CurveIndexA=GetPairIndexNFunc($A);

}{$CountConnect[0]=0;}

if($SmallestDistB<3){
$CountConnect[1]=1;
int $B = $DistSortB[0];
vector $Bvec = $AllKnowVecEnds[$DistSortB[0]];
int $CurveIndexB;
 $CurveIndexB=GetPairIndexNFunc($B);

}else{$CountConnect[1]=0;}



int $Size=`size($MCurveIndex)`;
int $SizeV=`size($AllKnowVecEnds)`;


if($CountConnect[0]+$CountConnect[1]!=2){

if($CountConnect[0]==1){
print "yes";
$MCurveIndex[$Size]=$DistSortA[0];
$MCurveIndex[$Size+1]=$SizeV;
$AllENdVectorZ[$SizeV]=$NewVecEnds[1];
}

if($CountConnect[1]==1){
$MCurveIndex[$Size]=$DistSortB[0];
$MCurveIndex[$Size+1]=$SizeV;
$AllENdVectorZ[$SizeV]=$NewVecEnds[0];
}

}


if($CountConnect[0]+$CountConnect[1]==2){
////int $SizeB =$Size+1;
///  $CurveVecIndex[$Size-2]=$DistSortA[0]+","+$DistSortB[0];
$MCurveIndex[$Size]=$DistSortA[0];
$MCurveIndex[$Size+1]=$DistSortB[0];

}


if($CountConnect[0]+$CountConnect[1]==0){
////int $SizeB =$Size+1;
///  $CurveVecIndex[$Size-2]=$DistSortA[0]+","+$DistSortB[0];
$MCurveIndex[$Size]=$SizeV;
$MCurveIndex[$Size+1]=$SizeV+1;

}












//       choose append pair to vector index?

//if $x =1

/*
string $CurveVecIndex[];
clear $CurveVecIndex;
$CurveVecIndex[0] ="0,1";
$CurveVecIndex[1] ="2,3";
print $CountConnect;

int $Size=`size($MCurveIndex)`;
int $SizeV=`size($AllKnowVecEnds)`;


if($CountConnect[0]+$CountConnect[1]==0){
int $SizeB =$Size+1;
$CurveVecIndex[$Size-2]=$Size+","+$SizeB;
}
*/

/////////////////////////////////////////GOLD

if($CountConnect[0]+$CountConnect[1]!=2){

if($CountConnect[0]==1){
print "yes";
$MCurveIndex[$Size]=$DistSortA[0];
$MCurveIndex[$Size+1]=$SizeV;
$AllENdVectorZ[$SizeV]=$NewVecEnds[1];
}

if($CountConnect[1]==1){
$MCurveIndex[$Size]=$DistSortB[0];
$MCurveIndex[$Size+1]=$SizeV;
$AllENdVectorZ[$SizeV]=$NewVecEnds[0];
}

}


if($CountConnect[0]+$CountConnect[1]==2){
////int $SizeB =$Size+1;
///  $CurveVecIndex[$Size-2]=$DistSortA[0]+","+$DistSortB[0];
$MCurveIndex[$Size]=$DistSortA[0];
$MCurveIndex[$Size+1]=$DistSortB[0];

}


if($CountConnect[0]+$CountConnect[1]==0){
////int $SizeB =$Size+1;
///  $CurveVecIndex[$Size-2]=$DistSortA[0]+","+$DistSortB[0];
$MCurveIndex[$Size]=$SizeV;
$MCurveIndex[$Size+1]=$SizeV+1;

}






0
1
2
3
3
1

0
1
2
3
3
5

clear $MCurveIndex;

$MCurveIndex={0,1,2,3,3,1};




size($AllENdVectorZ);
print $AllENdVectorZ;

/////////////////////////////////////////



print $Size

size($AllENdVectorZ);
print $MCurveIndex;


if($CountConnect[1]==1){
print "yes";
}



if($CountConnect[0]+$CountConnect[1]==2){
////int $SizeB =$Size+1;
///  $CurveVecIndex[$Size-2]=$DistSortA[0]+","+$DistSortB[0];
$MCurveIndex[$Size]=$DistSortA[0];
$MCurveIndex[$Size+1]=$DistSortB[0];

}

print $MCurveIndex;
print $CurveVecIndex;



if no match exists
add both new vectors to the vector list
size known vec array plus 1 +1





`



int $CurveIndex =($DistSortA[0])



int $CurveEndPairs[];
int $XTFb=0;
	$CurveEndPairsZ = IfCurvesTouchIndexZ($CurveNames[0], $CurveNames[1],$XTFb);

print $CurveNames;

int $KeyToPairIndex[];

$KeyToPairIndex[0]=0;

IndexPairFunc(1);




curve34

curve73

	$TrackIt[0] = IndexPairFuncN(int($Remove[0]), $CurveEndPairsZ[0]);


int $CURVeINDEX[] = CreateIntIndex(`size($CurveNames)`);
string $FoundDuplicates[] = $CurveNames;
int $SizeSelectedCRVs =`size($FoundDuplicates)`;
string $CurveEND_Count_LIST[];
int $CnIndex =0;
for ($eachS in $FoundDuplicates)
{$CurveEND_Count_LIST[$CnIndex++] = "0,0";
}    
print $CurveEND_Count_LIST;
int $NumbersINDEX[] = CreateIntIndex($SizeSelectedCRVs);
int $CRV_CONNECT[];
clear $CRV_CONNECT;
string $CurveConnectionsIndex[];
string $CurveConnectionsIndexA[];
string $CurveConnectionsIndexB[];
clear $CurveConnectionsIndex;
clear $CurveConnectionsIndexA;
clear $CurveConnectionsIndexB;
for($eachItemX in $NumbersINDEX){
	$CurveConnectionsIndex[$eachItemX] ="";
	$CurveConnectionsIndexA[$eachItemX] ="A";
	$CurveConnectionsIndexB[$eachItemX] ="B";
}    
int $TrackIt[];
int $CRVNumber[];
clear  $CRVNumber;
int $CurveEndPairs[];
string $CurveNumber[];
string $CurveEND_LIST[];
clear $CurveNumber;
string $CurveNumberIndex[];
string $CurveNumberIndexA[];
int $Cn=0;
int $CnXX=0;
int $Xn=0;
int $XTFb=0;
string $matchN_a, $matchN_b;
string $item[]= $FoundDuplicates;
string $item[]= IntArrayToStringArray($NumbersINDEX);
string $itemBackUp[] = $item;
string $Remove[];
string $diff[];
for ($each in $itemBackUp)
{   $Remove = {$item[0]}    
;
	$diff = stringArrayRemoveExact($Remove, $item);
	for($eachOther in $diff){
		////////////////////////////////////////
		$IntIfTrueA = IfCurvesTouch($FoundDuplicates[int($eachOther)], $FoundDuplicates[int($Remove[0])]);
		if($IntIfTrueA==1){
			////
			$CurveEndPairs = IfCurvesTouchIndex($FoundDuplicates[int($eachOther)], $FoundDuplicates[int($Remove[0])],$XTFb);
			select -r $FoundDuplicates[int($Remove[0])];  PAUSEn(2);
			select -add $FoundDuplicates[int($eachOther)]; PAUSEn(2);
			// $CurveEndPairsZ this is the zero or one indication Start or End _ A or B _  0 Or 1 _  of curve ends connecting  for two lines  
			string $OnePAIR = stringArrayToString(IntArrayToStringArray($CurveEndPairs), ",");
			//$CurveEND_LIST[$Cn] = stringArrayToString(IntArrayToStringArray($CurveEndPairs), ",");	
			$IfTrueArray[$Cn]=1;
			$CRVNumber[$Xn++] = $matchN_a = `match "([0-9]+)([0-9])*" $FoundDuplicates[int($Remove[0])]`;
			$CRVNumber[$Xn++] = $matchN_b = `match "([0 -9]+)([0-9])*" $FoundDuplicates[int($eachOther)]`;
			$CurveNumber[$Cn] = ($matchN_a +" "+$matchN_b);
			string $ADDit[] =  stringToStringArray( $OnePAIR , ",");
			string $ARRAY_A[] = stringToStringArray($CurveEND_Count_LIST[int($eachOther)], ",");
			string $ARRAY_B[] = stringToStringArray($CurveEND_Count_LIST[int($Remove[0])], ",");
			int $AAi = int ($ARRAY_A[0]) + int ($ADDit[0]); int $ABi = int ($ARRAY_A[1]) + int ($ADDit[1]);
			int $BAi = int ($ARRAY_B[0]) + int ($ADDit[2]); int $BBi = int ($ARRAY_B[1]) + int ($ADDit[3]);
			$CurveEND_Count_LIST[int($eachOther)] = ($AAi+","+$ABi);
			$CurveEND_Count_LIST[int($Remove[0])] = ($BAi+","+$BBi);
			//string $ARray[] = stringToStringArray($OnePAIR, ",")
			//$CRV_CONNECT[int($Remove[0])]+= int ($ADDit[0]);
			//$CRV_CONNECT[int($eachOther)]+= int ($ADDit[1]);
			$CRV_CONNECT[int($Remove[0])]+= 1;
			$CRV_CONNECT[int($eachOther)]+= 1;
			/////////////////////////////////////////////////////////
			$CurveEndPairsZ = IfCurvesTouchIndexZ($FoundDuplicates[int($eachOther)], $FoundDuplicates[int($Remove[0])],$XTFb);
			$CurveEndPairsZ = IfCurvesTouchIndexZ($FoundDuplicates[int($Remove[0])],$FoundDuplicates[int($eachOther)],$XTFb);
			//curve inted Zero 0 -  1_1, 6_1, 7_1,
			// the first number is the curve it connects to
			// the following number is the vector index of the end pt that touches that curve
			$TrackIt[0] = IndexPairFuncN(int($Remove[0]), $CurveEndPairsZ[0]);
			$TrackIt[1] = IndexPairFuncN(int($eachOther), $CurveEndPairsZ[1]);
			string $A = $Remove[0]; string $B = $eachOther;
			int $AX = int ($A);
			int $BX = int ($B);
			$CurveNumberIndex[$Cn] = ($A+","+$B);
			if($CurveEndPairsZ[0]==1){
				$CurveConnectionsIndexB[$AX] = $CurveConnectionsIndexB[$AX]+$B+"_"+ $CurveEndPairsZ[1]+","; 
			}    

			if($CurveEndPairsZ[1]==1){
				$CurveConnectionsIndexB[$BX] = $CurveConnectionsIndexB[$BX]+$A+"_"+ $CurveEndPairsZ[0]+",";
			}    
if($CurveEndPairsZ[0]==0){
				$CurveConnectionsIndexA[$AX] = $CurveConnectionsIndexA[$AX]+$B+"_"+ $CurveEndPairsZ[1]+","; 
			}    

			if($CurveEndPairsZ[1]==0){
				$CurveConnectionsIndexA[$BX] = $CurveConnectionsIndexA[$BX]+$A+"_"+ $CurveEndPairsZ[0]+",";
			}    
//curve inted Zero 0 -  1_1, 6_1, 7_1,
			// the first number is the curve it connects to $B
			// the following number is the vector index of the end pt that touches that curve $TrackIt[0]
			$CurveConnectionsIndex[$AX] = $CurveConnectionsIndex[$AX]+$B +"_"+ $TrackIt[0]+","; 
			$CurveConnectionsIndex[$BX]= $CurveConnectionsIndex[$BX]+$A +"_"+ $TrackIt[1]+","; 
			$CurveNumberIndexA[$CnXX++] =  $A;
			$CurveNumberIndexA[$CnXX++] =  $B;
			string $AB =  (" _ "+$A+","+$B); 
			$OnePAIR += $AB;
			$CurveEND_LIST[$Cn] = $OnePAIR;
			$Cn++;
			////
		}    
 	$item = $diff;
		//////////////////////////////////////////
	}    
   }    

//////////////////////////////////////////END
//////////////////////////////////////////
//print $CurveConnectionsIndex;
//print $CurveConnectionsIndexA;
//print $CurveConnectionsIndexB;
//print $CRV_CONNECT;







proc vector [] VecPointsToPlaneX(vector $V[],vector $n1,vector $p){


vector $CurvEnd[] = PointArrayT($CurveEnds3D);



vector $CameraN=  FloatToVec(nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0));
	vector $CamPosA;
	$CamPosA = `xform -q -ws -t ZCURVEModelingCAM`;

vector $VecBii[] =ProjectCrv2PlaneNormalP($CurvEnd,$CameraN*-1,$CamPosA);



for($eachVV in $CurvEnd){

    vector $ptVecWs = $eachVV;
    // Grab the worldInverseMatrix from cam_main
    matrix $cam_mat[4][4] = screenSpaceGetMatrix("ZCURVEModelingCAM.worldInverseMatrix");
    // Multiply the point by that matrix
    vector $ptVecCs = screenSpaceVecMult($ptVecWs,$cam_mat);
    // Adjust the point's position for the camera perspective

    float $hfv = `camera -q -hfv ZCURVEModelingCAM`;
    float $ptx = (($ptVecCs.x/(-$ptVecCs.z))/tand($hfv/2))/2.0;
    float $vfv = `camera -q -vfv ZCURVEModelingCAM`;
    float $pty = (($ptVecCs.y/(-$ptVecCs.z))/tand($vfv/2))/2.0;
    float $ptz = $ptVecCs.z;
vector $XYv=$ptVecCs;
//vector $XYv=<<$ptx,$pty,0.0>>;
Loc ( $XYv);
}



vector $Tdd[] = PointArrayT(`ls-sl`);
vector $Dir = DirectionF($Tdd[0],$Tdd[1]);
/////
vector $EV = ($Dir*2.5)+$T[0];
Loc($EV);
//

vector $TD[] = PointArrayT(`ls-sl`);
vector $VecBi[] =ProjectCrv2PlaneNormalP($TD,$Dir,$Tdd[0]);



	vector $CamPosA[];
	$CamPosA =`xform -q -ws -t "LiveSurfaceB"`;
	vector $CamNormal =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);

vector $VecBi[] =ProjectCrv2PlaneNormalP($AllKnowVecEnds,$CamNormal*-1,$CamPosA[0]);


proc vector [] ProjectCrv2PlaneNormalP(vector $vecRs[],vector $AvN,vector $Midp){

vector $NewPtsP[];
vector $PtsVec;
vector $Tran;
float $RowA[],$RowB[],$RowC[],$Pts[],$AxisO[],$PtZ[];
vector $DirectC = DirectionFN($vecRs[0], $Midp);
vector $tan = crossProduct($DirectC,$AvN, 0, 0 );
 	$RowA = $tan;
	$RowB = $DirectC;
	$RowC = $AvN;
// cent of matrix 
 $AxisO = $Tran = $Midp;
int $SizeVp =`size($vecRs)`;
vector  $Xv,$Dv,$ZEROIi;
float $valN;
for($Ind=0; $Ind<$SizeVp; $Ind++){
$PtsVec=$vecRs[$Ind];
 $Pts = $PtsVec;
$PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
$PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
$PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
 $Xv = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
 $Dv=DirectionF($Xv,$PtsVec);
 $ZEROIi = $Dv*$AvN;
$valN= $ZEROIi.x*$ZEROIi.y*$ZEROIi.z;
  	$sign = `sign $valN`;
  	$valN = (int) (($valN + $sign*5/(1.0*10)) * 1.0);
  	$valN = ($valN/1.0);
//if above0.5
if($valN==1){
$NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
//be careful..
curve2points($Xv,$PtsVec);
}
}
return $NewPtsP;
}

	vector $CamPosA[];
	$CamPosA = `xform -q -ws -t ZCURVEModelingCAM`;
	$CamPosA =`xform -q -ws -t "LiveSurfaceB"`;
	vector $CamNormal =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
vector $VecBi[] =ProjectCrv2PlaneNormalP($AllKnowVecEnds,$CamNormal*-1,$CamPosA[0]);

vector $vecRs[];
 $vecRs ={$AllKnowVecEnds[0]};
Loc  $vecRs[0];

vector $AvN=$CamNormal*-1;
vector $Midp=$CamPosA[0];



vector $vecRs[];
 $vecRs ={$AllKnowVecEnds[0]};
vector $AvN=$CamNormal*-1;
vector $Midp=$CamPosA[0];




proc vector [] ProjectCrv2PlaneNormalP(vector $vecRs[],vector $AvN,vector $Midp){


vector $vecRsA[];
vector $NewPtsP[];
vector $PtsVec;
vector $Tran;
float $RowA[],$RowB[],$RowC[],$Pts[],$AxisO[],$PtZ[];
vector $DirectC = DirectionFN($vecRs[0], $Midp);
vector $tan = crossProduct($DirectC,$AvN, 0, 0 );
 	$RowA = $tan;
	$RowB = $DirectC;
	$RowC = $AvN;
// cent of matrix 
 $AxisO = $Tran = $Midp;
int $SizeVp =`size($vecRs)`;
vector  $Xv,$Dv,$ZEROIi;
float $valN;
int $CountF[];
int $CountFN=0;
for($Ind=0; $Ind<$SizeVp; $Ind++){
$PtsVec=$vecRs[$Ind];
 $Pts = $PtsVec;
$PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
$PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
$PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));


 $Xv = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
 $Dv=DirectionF($Xv,$PtsVec);
 $ZEROIi = $Dv*$AvN;
$valN= $ZEROIi.x*$ZEROIi.y*$ZEROIi.z;
  	$sign = `sign $valN`;
  	$valN = (int) (($valN + $sign*5/(1.0*10)) * 1.0);
  	$valN = ($valN/1.0);
//if above0.5
if($valN==1){
PAUSE;
cycleBackgroundColor;
$NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
//be careful..
curve2points($Xv,$PtsVec);
//Loc $NewPtsP[0];

$vecRsA[$CountFN]=$PtsVec;
$CountF[$CountFN]=$Ind;
$CountFN++;
}

}


vector $V[];
$V= $vecRsA;
	vector $p = `xform -q -ws -t "LiveSurfaceB"`;
	vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
	vector $n1 =$AvN; 
	float $D, $D1;
	vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
	int $C1;
	$C1=0; 
	for($e in $V){

		$F = DirectionF($C, $e);
		$M = $e+($F);
		$D = distance2Pts($e, $p);
///both maybe redundant
		$P1 = ClosestPoint2LineVec($n1, $p, $e);
		$F4 = $NewPtsP[$C1];
		$P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);

		$F1 = DirectionF($P, $M);
		$O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
curve2points($e,$O[$C1]);
		$C1++;
	}
//print  $O;
//Loc $O[0];

matrix $MatrixNewB[4][4];  
$MatrixNewB = GetMatrix("ZCURVEModelingCAM");
	 $MtxF  = MatrixToFloat($MatrixNewB);	
 	$RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
	$RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
	$RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};

int $trackit[];
int $TF=0;
vector $RECORD[];
int $SizeC =`size($O)`;
for($Ind=0; $Ind<$SizeC; $Ind++){

$PtsVec= $O[$Ind];
 $Pts = $PtsVec;
$PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
$PtZ[2] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
$PtZ[1] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
Loc $PtZ;
print $PtZ[0];
print $PtZ[2];
print $PtZ[1];
//$TF=rectContains(-0.5,-0.5, -1.0, 1.0, $PtZ[0], $PtZ[2]);
$TF=rectContains(-0.5,-0.5, 1.0, 1.0,$PtZ[0], $PtZ[2]);

if($TF==1){
$RECORD[`size($RECORD)`]=$O[$Ind];
PAUSE;
Loc $RECORD[`size($RECORD)`-1];
}
$TF=0;

}


return $RECORD;
}

string $T[] =`ls -sl`;
float $FixVecT[];
vector $vecT[];
$vecT = PointArrayT($T);
$FixVecT = $vecT[0];

$TF=rectContains(-0.5,-0.5, 1.0, 1.0, $FixVecT[0], $FixVecT[2]);



proc vector [] VecPointsToCameraPlane(vector $V[]){

vector $V[];

print $PtsVec;
6.513704 -1.022943 4.744769
// Result: <<65.077678, 30.853927, 35.481502>>  // 
// Result: <<71.591382, 29.830984, 40.226271>>  // 

$V= $vecRs;

	vector $p = `xform -q -ws -t "LiveSurfaceB"`;
	vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
	vector $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0); 
	float $D, $D1;
	vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
	int $C1;
	$C1=0; 
	for($e in $V){

$e=$V[0];

		$F = DirectionF($C, $e);
		$M = $e+($F);
		$D = distance2Pts($e, $p);
///both maybe redundant

		$P1 = ClosestPoint2LineVec($n1, $p, $e);


		$F4 = $e+($D1*$F3);

		$P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);


		$F1 = DirectionF($P, $M);
		$O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));

		$C1++;
	}	 
	return $O;
}




proc vector [] VecPointsToCameraPlane(vector $V[]){
	vector $p = `xform -q -ws -t "LiveSurfaceB"`;
	vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
	vector $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0); 
	float $D, $D1;
	vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
	int $C1;
	$C1=0; 
	for($e in $V){
		$F = DirectionF($C, $e);
		$M = $e+($F);
		$D = distance2Pts($e, $p);
		$F2 = $p+($D*$n1);
		$P1 = ClosestPoint2LineVec($n1, $p, $e);
		$F3 = DirectionF($P1, $p);
		$D1 = distance2Pts($P1, $p);
		$F4 = $e+($D1*$F3);
		$P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
		$F1 = DirectionF($P, $M);
		$O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
		$C1++;
	}	 
	return $O;
}





$TempVectorsCrv  = LineIntersectPlaneCam( $PositionsZ_Ax, $CamPos1, $ZYplaneMatrix);

proc float [] FloatPointsToCamPlane(float $LocPos1[]){
	vector $p = `xform -q -ws -t "LiveSurfaceB"`;
	vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
	vector $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0); 
	float $D, $D1;	
	vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
	int $C1;
	$C1=0; 
	$e=FloatToVec( $LocPos1);
		$F = DirectionF($C, $e);
		$M = $e+($F);
		$D = distance2Pts($e, $p);
		$F2 = $p+($D*$n1);	
		$P1 = ClosestPoint2LineVec($n1, $p, $e);
		$F3 = DirectionF($P1, $p);
		$D1 = distance2Pts($P1, $p);
		$F4 = $e+($D1*$F3);
		$P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
		$F1 = DirectionF($P, $M);
		$O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));	
		$C1++;

	 float $R[] =$O;
	return $R;
}

proc float [] FloatPointsToCamPlane(float $LocPos1[]){
	float $Pi = 3.1415926535;
	float $pi = 3.1415926535;
	float $CamPos1[];
	$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
	float $LivePlanePos[];
	$LivePlanePos = `xform -q -ws -t LiveSurfaceB`;
	float $CamerasDirectionVectorNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
	float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
	float $FloatDirectionA[] = DirectionFN($CamPos1, $LocPos1);
	float $DistanceLoc = distance2Pts( $LocPos1, $CamPos1 );
	float $DistanceLocA = $DistanceLoc;
	$DistanceLoc = $DistanceLoc * -1;
	float $MultDirPC1[] = multiplyFloat($DistanceLoc, $CamerasDirectionVector);
	float $FloatDirectionCamNormal[] = AddFloats($CamPos1, $MultDirPC1);
	float $CamerasDirectionVectorA[] = DirectionFN($FloatDirectionCamNormal, $CamPos1);
	float $MultDirPC1A[] = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
	$FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1A);
	float $p1[] = $CamPos1;
	float $p2[] = $LocPos1;
	float $p3[] = $FloatDirectionCamNormal;
	float $center[]; 
	float $normal[];
	float $p1p2[3];
	float $p1p3[3];
	$p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
	$p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
	float $normal[3];
	$normal = crossProduct( $p1p2, $p1p3, 0, 0 );
	float $FloatPosZero[] = {0, 0, 0};
	float $FloatDirection[] = DirectionFN($FloatPosZero, $normal);
	float $mid1[3], $mid2[3], $mid3[3];
	$mid1 = midPoint2Pts( $p1, $p2 );
	$mid2 = midPoint2Pts( $p1, $p3 );
	$mid3 = midPoint2Pts( $p2, $p3 );
	float $perp_p1p2[3];
	float $perp_p1p3[3];
	$perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
	$perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
	float $center[] = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
	float $FloatDirPerpCenterC[] = DirectionFN($center,$mid2);
	float $FloatDirPointAC[] = DirectionFN($p1, $p3);
	float $center8[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
	float $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
	float $FloatDirLocToPerpIntersect[] = DirectionFN($center8,$p2);
	float $OnPlane[] = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );
	return $OnPlane;
}


proc matrix screenSpaceGetMatrix(string $attr){
  float $v[]=`getAttr $attr`;
  matrix $mat[4][4]=<<$v[0], $v[1], $v[2], $v[3];
             $v[4], $v[5], $v[6], $v[7];
             $v[8], $v[9], $v[10], $v[11];
             $v[12], $v[13], $v[14], $v[15]>>;
 return $mat;
}

// Multiply the vector v by the 4x4 matrix m, this is probably
// already in mel but I cant find it.
proc vector screenSpaceVecMult(vector $v, matrix $m){
  matrix $v1[1][4]=<<$v.x, $v.y, $v.z, 1>>;
  matrix $v2[1][4]=$v1*$m;
  return <<$v2[0][0], $v2[0][1],  $v2[0][2]>>;
}




    vector $ptVecWs = ;

    // Grab the worldInverseMatrix from cam_main
    matrix $cam_mat[4][4] = screenSpaceGetMatrix("cam_main.worldInverseMatrix");

    // Multiply the point by that matrix
    vector $ptVecCs = screenSpaceVecMult($ptVecWs,$cam_mat);

    // Adjust the point's position for the camera perspective
    float $hfv = `camera -q -hfv cam_main`;
    float $ptx = (($ptVecCs.x/(-$ptVecCs.z))/tand($hfv/2))/2.0+.5;
    float $vfv = `camera -q -vfv cam_main`;
    float $pty = (($ptVecCs.y/(-$ptVecCs.z))/tand($vfv/2))/2.0+.5;

    float $ptz = $ptVecCs.z;

    $line = $ptx + " " + $pty + " " + "\n";





proc int AddItemsFromIndexAtoB(int $Ai, int $Bi, int $numberArrayi[]){
	// float $numberArrayi[]= {0.2, 1.2, 3.2, 1.2, 6.2, 6.2, 9.3, -1.2};
	//int $Ai = 2;
	//int $Bi = 5;
	int $AddUp=0;
	int $NumerinArray = `size($numberArrayi)`-1;
	if($NumerinArray!=-1){
		int $Ni = $Ai;
		int $Nii = $Bi;
		if($Nii< $Ni){
			$Ai=$Nii; $Bi=$Ni;
		}
		int $range = abs ($Ai-$Bi);
		for ($iC=0;$iC<$range+1; $iC++){
			int $ixNa = $iC+$Ai;
			$ixNa = `clamp 0 $NumerinArray $ixNa`;
			$AddUp+=$numberArrayi[$ixNa];
			if($ixNa ==$NumerinArray){break;}
		}
	}
	return $AddUp;
}


proc int[] AddItemsFromIndexAtoBFindZero(int $Ai, int $Bi, int $numberArrayi[]){
	// float $numberArrayi[]= {0.2, 1.2, 3.2, 1.2, 6.2, 6.2, 9.3, -1.2};
	//int $Ai = 2;
	//int $Bi = 5;
	int $AddUp=0;
	int $NumerinArray = `size($numberArrayi)`-1;
	int $catchIndex[1];
	$catchIndex[0]= 1;
	if($NumerinArray!=-1){
		int $Ni = $Ai;
		int $Nii = $Bi;
		if($Nii< $Ni){
			$Ai=$Nii; $Bi=$Ni;
		}
		int $range = abs ($Ai-$Bi);
		for ($iC=0;$iC<$range+1; $iC++){
			int $ixNa = $iC+$Ai;
			$ixNa = `clamp 0 $NumerinArray $ixNa`;
			$AddUp+=$numberArrayi[$ixNa];
			if($AddUp ==0){$catchIndex[1] = $ixNa; $catchIndex[0]=0;break;}
		}
	}
	return $catchIndex;
}

proc string StringArrayItemsFromIndexAtoB(int $Ai, int $Bi, string $StringArrayi[]){
	string $sAddUp=0;
	int $NumerinArray = `size($StringArrayi)`;
	if($NumerinArray!=0){
		float $Ni = $Ai;
		float $Nii = $Bi;
		if($Nii< $Ni){
			$Ai=$Nii; $Bi=$Ni;
		}
		float $range = abs ($Ai-$Bi);
		for ($iC=0;$iC<$range+1; $iC++){
			int $ixNa = $iC+$Ai;
			$sAddUp+=$StringArrayi[$ixNa];
			if($ixNa ==$NumerinArray){break;}
		}
	}
	return $sAddUp;
}

proc  PrintLongArrayNice(string $StringArrayPrint[] , int $MatrixN){
	int $MatrixNi = $MatrixN-1;
	string $stringFloat[] = $StringArrayPrint;
	int $BytNum[];
	clear $BytNum;
	for ($eachFloatz in $stringFloat){
		$BytNum[`size($BytNum)`] = (`sizeBytes $eachFloatz`)+2;
	}
	int $BytNumSort[] = $BytNum;
	$BytNumSort = `sort $BytNumSort`;
	int $BytNumLarg = $BytNumSort[`size($BytNumSort)`-1];
	int $BytNumSmall = $BytNumSort[0];
	int $BytNumDiff[];
	clear $BytNumDiff;
	for ($eachBytNum in $BytNum){
		$BytNumDiff[`size($BytNumDiff)`] = (`abs ($eachBytNum - $BytNumLarg)`)+2;
	}
	int $IndXeF =0;
	int $IndXeFi =0;
	string $Syb = " ";
	string $printcommand="";
	for ($eachItemF in $stringFloat){
		string $AddedSPaces = AddItemString($BytNumDiff[$IndXeF], $Syb);
		if($IndXeFi==$MatrixNi){ $printcommand += $AddedSPaces + $eachItemF + "|"+ "\n" ;
			$IndXeFi= -1; }else{ if($IndXeFi==0){$printcommand += "|"+$AddedSPaces + $eachItemF;}else{ $printcommand +=  $AddedSPaces + $eachItemF;}}
		$IndXeFi++;
		$IndXeF++;
	}
	

}

proc string[] StringArrayStartOfStringinArray(string $Array[]){
	string $StartOfEach[];
	string $findEachstart="";
	for ($eachString in $Array){
		$StartOfEach[`size($StartOfEach)`]= startString($eachString, 1);
		$findEachstart+= startString($eachString, 1);
		$findEachstart+= " ";
	}
	
	return $StartOfEach;
}

///////////////////////
proc string[] ReturnArrayFromNestedStringAtIndex(string $StringData[], int $ind){
	string $KnownMatchi[];
	$KnownMatchi = stringToStringArray($StringData[$ind], ",");
	return $KnownMatchi;
}

proc int[] TFArrayContains(string $item, string $list[])
{	int $TF[1];
	$TF[0] = false;	
	string $listItem;
	int $Count =0;	
	for ($listItem in $list) {
		if ($item == $listItem) {
			$TF[0] = true;
			$TF[1] = $Count;
			break;
		} $Count++;
	}	
	return $TF;
}

proc string AddItemString(int $iN, string $NumLetorSy){
	int $Xz =0;
	string $AddItem ="";
	while($iN > $Xz){
		$AddItem+= $NumLetorSy;
		$Xz++;
	}
	return $AddItem;
}

////////////////////////

//Test pick one

/*
string $Find = "Vec.xithis+ float Y =  uVeci/(abs(sqrt ((`pow  uVeci 2`) + (`pow  vVeci 2`) + (`pow  wVeci 2`)))); Vec.vecthisH , float i =  Vec.x - Vec.y; float ii = Vec.vecthisH - Vec.z + Vec.thisy / Vec.Tthis - Vec.this;";

string $Find = "r = a*exp(radians(Delta_angle*n)*cot(b))x = r*cos(radians(Delta_angle*n))if(n ==0):y = 0else:y = 10*(rBefore -r) z = sin (radians(Delta_angle*n))  SomeNumber::FuctionWeird please work II + math = joy;" ;
*/
////////////////////////


proc string [] FindNameOfVariables(string $Find, int $sortN){

string $resultVar = "string float vector matrix int proc";
string $resulti = "sin cos tan tand atan asin acos atand asind acosd";
string $result = "abs angle bessel ceil clamp constrainValue cos cross crossProduct deg_to_rad delrandstr dot dotProduct equivalent  equivalentTol erf exp floatEq floor fmod gamma gauss getLastError getProcArguments hermite hsv_to_rgb hypot linstep log mag max min noise  normalize pointMatrixMult pow rad_to_deg rand randstate rgb_to_hsv rot seed sign sin smoothstep sphrand sqrt tan trunc unitprint ";
string $AllMathfunction = "abs ,angle ,bessel ,ceil ,clamp ,constrainValue ,cos ,cross ,crossProduct ,deg_to_rad ,delrandstr ,dot  ,dotProduct ,equivalent ,equivalentTol ,erf ,exp ,floatEq ,floor ,fmod ,gamma ,gauss ,getLastError ,getProcArguments ,hermite ,hsv_to_rgb  ,hypot ,linstep ,log ,mag ,max ,min ,noise ,normalize ,pointMatrixMult ,pow ,rad_to_deg ,rand ,randstate ,rgb_to_hsv ,rot ,seed ,sign ,sin  ,smoothstep ,sphrand ,sqrt ,tan ,trunc ,unit";
string $MathFuncClassData =  $result+" "+ $resulti + " " + $resultVar ;
//string  $KnownMathTermsMELAtomizes[] = ArrayFromAllinString($MathFuncClassData);
string $KnownMathTermsMEL[] = stringToStringArray($MathFuncClassData, " ");
string $KnownMathTermsMELSorted[] = `sort $KnownMathTermsMEL`;



string $startingChar[] =  StringArrayStartOfStringinArray($KnownMathTermsMELSorted);
string $shorterListstartingChar[] =  stringArrayRemoveDuplicates ($startingChar);
string $KnownMatch[] = $KnownMathTermsMELSorted;
string $ArrayLetter[] = $shorterListstartingChar;
string $Arraytemp[] = $KnownMathTermsMELSorted;
string $StartOfEachS;
string $findEachstart="";
string $StartOfEachSTable[], $itemBackUp[];
clear $StartOfEachSTable $itemBackUp;
$itemBackUp = $ArrayLetter;
string $gatherItems="";
string $eachStringL;
string $eachString;

for ($eachStringL in $ArrayLetter){
	for ($eachString in $KnownMathTermsMELSorted){
		$StartOfEachS = startString($Arraytemp[0], 1);
		if ($StartOfEachS==$eachStringL){
			$gatherItems += ($Arraytemp[0]+",");
			$Arraytemp = stringArrayRemoveExact({$Arraytemp[0]}, $Arraytemp);
		}
		//else{	$gatherItems="";}	//
	}
	if(`size($gatherItems)`>0){
		$StartOfEachSTable[`size($StartOfEachSTable)`]= $gatherItems; 
	}
	$gatherItems="";
}

//////////////////////////////////////////////////////////////


int $IndexLetters[] = CreateIntIndex(`size($ArrayLetter)`);
int $BytNumi;
$BytNumi = `sizeBytes $Find`;
string $all[];
int $StringIndex[];
clear $all;
clear $StringIndex;
string $all[] = ArrayFromAllinString($Find);
int $StringIndex[] = CreateIntIndex( `size($all)` );
//map string 

string $tempFind = $Find;
string $tempFindwrite = $Find;
int $countIndex=0;
string $StartS;
int $indexStart[];
clear $indexStart;
string $LetterItem="";
string $FoundVariableItems[];
string $FoundOtherItems[];
clear $FoundVariableItems $FoundOtherItems;
int $indexFirstCharItems[];
clear $indexFirstCharItems;
int $BytNx =0;
string $StringFromReducedArray ="";
string $reducedArray[];
clear $reducedArray;
string $allTemp[];
clear $allTemp;
$allTemp = $all;
string $dontUse=""; 
string $matchingDontuse="";
int $freezeTrigger =0;
string $matching="";
int $eachInt=0;
int $iixI =0;
string $match;
string $match0;
string $matchMiddleDiff;
string $matchi;
string $MatchStage2;
string $MatchStage3;
string $addBracktoMatch3;
string $addBracktoMatchD;
string $matchTemp;
string $dontUse;


$match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $Find`;
$match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $Find`;
$matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $Find`;
$matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $Find`;
$MatchStage2 = endString($match, 3);

$MatchStage3 = startString($match, `sizeBytes $match`-2);
$MatchStage3i = startString($match, `sizeBytes $matchii`-2);
$addBracktoMatch3 = ("\["+$MatchStage3+"\]");

$matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;
if($matchMiddleDiff=="\."){
	
	string $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
	if($matchMaybeVec2!=""){
		$MatchStage4 = startString($match, `sizeBytes $match`-1);
		$match = $MatchStage4;
	}else{ $dontUse = $matchi; $match=$matchi; }
}else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//   
}

$matchTemp = $match;
$BytNx =`sizeBytes $match`;

int $IndexLetters[] = CreateIntIndex(`size($ArrayLetter)`);
string $ArrayFind[];
int $TFandIndex[];
int $TFandIndexii[];
string $StartOfEachSi="";
string $FOUND="";
clear $ArrayFind $TFandIndex $TFandIndexii;
int $FirstLFindIndex;
int $Tri=0;
int $Trii=2;
int $CountFoundletters=0;
vector $indexStartEnd[];
clear $indexStartEnd;


for ($eachItemArray in $StringIndex){
	$eachInt = $StringIndex[$iixI];
	
	if( `gmatch $allTemp[$eachInt] "[a-zA-Z0-9_\.]*"` == 1){
		if($Trii==2){$Trii=1; $Tri=2;}
		if(!($CountFoundletters>=1)){
			$FirstLFindIndex=$iixI+1;
			
		}
		$CountFoundletters++;
		if($Tri==2){
		
			$Tri=0;
		}
		$LetterItem+= $allTemp[$eachInt];
		$BytNx = `sizeBytes $LetterItem`;
		if(`gmatch $matchTemp $LetterItem`==1){
			$BytNx = `sizeBytes $LetterItem`;
			
			//$LetterItem ="pow";
			$StartOfEachSi = startString($LetterItem, 1);
			$TFandIndex = TFArrayContains($StartOfEachSi, $ArrayLetter);
			if($TFandIndex[0]==1){ 
				$ArrayFind = ReturnArrayFromNestedStringAtIndex($StartOfEachSTable, $TFandIndex[1]);
				$TFandIndexii = TFArrayContains($LetterItem, $ArrayFind);
				
				if($TFandIndexii[0]==1){
					$FOUND = $ArrayFind[$TFandIndexii[1]];
					if(`gmatch $FOUND $LetterItem`==1){
						
						$FoundOtherItems[`size($FoundOtherItems)`]= $FOUND;
					}
				}
			}
			if(`gmatch $FOUND $LetterItem`!=1){
				if($matchTemp!=$dontUse){ 
					$FoundVariableItems[`size($FoundVariableItems)`]= $LetterItem;
					int $SizeItem = `size $matchTemp`;
					$indexStartEnd[`size($indexStartEnd)`] = <<$FirstLFindIndex, $iixI, ($iixI-$SizeItem+3)>> ;
					$indexStart[`size($indexStart)`]= $FirstLFindIndex;
				}
			} else{$CountFoundletters=0;          }
			clear $TFandIndex $ArrayFind $TFandIndexii;  
			$FOUND="";
			$reducedArray = $allTemp;
			stringArrayRemoveToIndex($eachInt+1, $reducedArray);
			$StringFromReducedArray = stringArrayToString($reducedArray, "");
		
			/////////////////////////////////////////////////////////////////////////////////

			/////////////////////////////////////////////////////////////////
			$LetterItem ="";
			if($matchTemp==$dontUse){ $freezeTrigger = 1; }
			if( `gmatch $allTemp[$eachInt] $match` != 1){$Trii=2; $CountFoundletters=0;}
			
			$match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;
			
			//if(`size($StringFromReducedArray)`>4){
			$match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $StringFromReducedArray`;
			$matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $StringFromReducedArray`;
			$matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $StringFromReducedArray`;
			$MatchStage2 = endString($match, 3);
			$MatchStage3 = startString($match, `sizeBytes $match`-2);
			$MatchStage3i = startString($match, `sizeBytes $matchii`-2);
			$addBracktoMatch3 = ("\["+$MatchStage3+"\]");
			//$addBracktoMatchD = ("\(["+"\"+$matchi+"\])+([a-zA-Z]+)([a-zA-Z0-9_])");
			$matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;
			
			if($matchMiddleDiff=="\."){
				
				string $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
				if($matchMaybeVec2!=""){
					$MatchStage4 = startString($match, `sizeBytes $match`-1);
					$match = $MatchStage4;
				}else{ $dontUse = $matchi; $match=$matchi; }
			}else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//   
			}
		}
	}else{$LetterItem ="";  }
	///}else{$match = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;}
	$matchTemp = $match;
	
	$iixI++;
}

///////////////

string $printneat = stringArrayToString($FoundVariableItems, ",");
string $printneati = stringArrayToString($FoundOtherItems, ",");
string $FoundTerms[] = stringToStringArray($printneat, ",");

if($sortN== 1){$FoundTerms = `sort $FoundTerms`;}

return $FoundTerms;

}
//////////////////////////////


proc string [] FindNameOfVariables(string $Find, int $sortN, int $EmptyIntArray[] ){

string $resultVar = "string float vector matrix int proc";
string $resulti = "sin cos tan tand atan asin acos atand asind acosd";
string $result = "abs angle bessel ceil clamp constrainValue cos cross crossProduct deg_to_rad delrandstr dot dotProduct equivalent  equivalentTol erf exp floatEq floor fmod gamma gauss getLastError getProcArguments hermite hsv_to_rgb hypot linstep log mag max min noise  normalize pointMatrixMult pow rad_to_deg rand randstate rgb_to_hsv rot seed sign sin smoothstep sphrand sqrt tan trunc unitprint ";
string $AllMathfunction = "abs ,angle ,bessel ,ceil ,clamp ,constrainValue ,cos ,cross ,crossProduct ,deg_to_rad ,delrandstr ,dot  ,dotProduct ,equivalent ,equivalentTol ,erf ,exp ,floatEq ,floor ,fmod ,gamma ,gauss ,getLastError ,getProcArguments ,hermite ,hsv_to_rgb  ,hypot ,linstep ,log ,mag ,max ,min ,noise ,normalize ,pointMatrixMult ,pow ,rad_to_deg ,rand ,randstate ,rgb_to_hsv ,rot ,seed ,sign ,sin  ,smoothstep ,sphrand ,sqrt ,tan ,trunc ,unit";
string $MathFuncClassData =  $result+" "+ $resulti + " " + $resultVar ;
//string  $KnownMathTermsMELAtomizes[] = ArrayFromAllinString($MathFuncClassData);
string $KnownMathTermsMEL[] = stringToStringArray($MathFuncClassData, " ");
string $KnownMathTermsMELSorted[] = `sort $KnownMathTermsMEL`;



string $startingChar[] =  StringArrayStartOfStringinArray($KnownMathTermsMELSorted);
string $shorterListstartingChar[] =  stringArrayRemoveDuplicates ($startingChar);
string $KnownMatch[] = $KnownMathTermsMELSorted;
string $ArrayLetter[] = $shorterListstartingChar;
string $Arraytemp[] = $KnownMathTermsMELSorted;
string $StartOfEachS;
string $findEachstart="";
string $StartOfEachSTable[], $itemBackUp[];
clear $StartOfEachSTable $itemBackUp;
$itemBackUp = $ArrayLetter;
string $gatherItems="";
string $eachStringL;
string $eachString;

for ($eachStringL in $ArrayLetter){
	for ($eachString in $KnownMathTermsMELSorted){
		$StartOfEachS = startString($Arraytemp[0], 1);
		if ($StartOfEachS==$eachStringL){
			$gatherItems += ($Arraytemp[0]+",");
			$Arraytemp = stringArrayRemoveExact({$Arraytemp[0]}, $Arraytemp);
		}
		//else{	$gatherItems="";}	//
	}
	if(`size($gatherItems)`>0){
		$StartOfEachSTable[`size($StartOfEachSTable)`]= $gatherItems; 
	}
	$gatherItems="";
}

//////////////////////////////////////////////////////////////


int $IndexLetters[] = CreateIntIndex(`size($ArrayLetter)`);
int $BytNumi;
$BytNumi = `sizeBytes $Find`;
string $all[];
int $StringIndex[];
clear $all;
clear $StringIndex;
string $all[] = ArrayFromAllinString($Find);
int $StringIndex[] = CreateIntIndex( `size($all)` );
//map string 

string $tempFind = $Find;
string $tempFindwrite = $Find;
int $countIndex=0;
string $StartS;
int $indexStart[];
clear $indexStart;
string $LetterItem="";
string $FoundVariableItems[];
string $FoundOtherItems[];
clear $FoundVariableItems $FoundOtherItems;
int $indexFirstCharItems[];
clear $indexFirstCharItems;
int $BytNx =0;
string $StringFromReducedArray ="";
string $reducedArray[];
clear $reducedArray;
string $allTemp[];
clear $allTemp;
$allTemp = $all;
string $dontUse=""; 
string $matchingDontuse="";
int $freezeTrigger =0;
string $matching="";
int $eachInt=0;
int $iixI =0;
string $match;
string $match0;
string $matchMiddleDiff;
string $matchi;
string $MatchStage2;
string $MatchStage3;
string $addBracktoMatch3;
string $addBracktoMatchD;
string $matchTemp;
string $dontUse;


$match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $Find`;
$match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $Find`;
$matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $Find`;
$matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $Find`;
$MatchStage2 = endString($match, 3);

$MatchStage3 = startString($match, `sizeBytes $match`-2);
$MatchStage3i = startString($match, `sizeBytes $matchii`-2);
$addBracktoMatch3 = ("\["+$MatchStage3+"\]");

$matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;
if($matchMiddleDiff=="\."){
	
	string $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
	if($matchMaybeVec2!=""){
		$MatchStage4 = startString($match, `sizeBytes $match`-1);
		$match = $MatchStage4;
	}else{ $dontUse = $matchi; $match=$matchi; }
}else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//   
}

$matchTemp = $match;
$BytNx =`sizeBytes $match`;

int $IndexLetters[] = CreateIntIndex(`size($ArrayLetter)`);
string $ArrayFind[];
int $TFandIndex[];
int $TFandIndexii[];
string $StartOfEachSi="";
string $FOUND="";
clear $ArrayFind $TFandIndex $TFandIndexii;
int $FirstLFindIndex;
int $Tri=0;
int $Trii=2;
int $CountFoundletters=0;
int $CountTotalFindIndex=0;
vector $indexStartEnd[];
clear $indexStartEnd;
int $CountIndex[];
int $findByt;


for ($eachItemArray in $StringIndex){
	$eachInt = $StringIndex[$iixI];
	$CountTotalFindIndex++;
	if( `gmatch $allTemp[$eachInt] "[a-zA-Z0-9_\.]*"` == 1){
		if($Trii==2){$Trii=1; $Tri=2;}
		if(!($CountFoundletters>=1)){
			$FirstLFindIndex=$iixI+1;
			
		}
		$CountFoundletters++;
		if($Tri==2){
		
			$Tri=0;
		}
		$LetterItem+= $allTemp[$eachInt];
		$BytNx = `sizeBytes $LetterItem`;
		if(`gmatch $matchTemp $LetterItem`==1){
			$BytNx = `sizeBytes $LetterItem`;
			
			//$LetterItem ="pow";
			$StartOfEachSi = startString($LetterItem, 1);
			$TFandIndex = TFArrayContains($StartOfEachSi, $ArrayLetter);
			if($TFandIndex[0]==1){ 
				$ArrayFind = ReturnArrayFromNestedStringAtIndex($StartOfEachSTable, $TFandIndex[1]);
				$TFandIndexii = TFArrayContains($LetterItem, $ArrayFind);
				
				if($TFandIndexii[0]==1){
					$FOUND = $ArrayFind[$TFandIndexii[1]];
					if(`gmatch $FOUND $LetterItem`==1){
						
						$FoundOtherItems[`size($FoundOtherItems)`]= $FOUND;
					}
				}
			}
			if(`gmatch $FOUND $LetterItem`!=1){
				if($matchTemp!=$dontUse){ 
					$FoundVariableItems[`size($FoundVariableItems)`]= $LetterItem;
					int $SizeItem = `size $matchTemp`;
					$indexStartEnd[`size($indexStartEnd)`] = <<$FirstLFindIndex, $iixI, ($iixI-$SizeItem+3)>> ;
					$indexStart[`size($indexStart)`]= $FirstLFindIndex;
					$findByt = `sizeBytes $LetterItem`;
					$CountIndex[`size($CountIndex)`] =  ($CountTotalFindIndex -$findByt)-1;
				}
			} else{$CountFoundletters=0;          }
			clear $TFandIndex $ArrayFind $TFandIndexii;  
			$FOUND="";
			$reducedArray = $allTemp;
			stringArrayRemoveToIndex($eachInt+1, $reducedArray);
			$StringFromReducedArray = stringArrayToString($reducedArray, "");
		
			/////////////////////////////////////////////////////////////////////////////////

			/////////////////////////////////////////////////////////////////
			$LetterItem ="";
			if($matchTemp==$dontUse){ $freezeTrigger = 1; }
			if( `gmatch $allTemp[$eachInt] $match` != 1){$Trii=2; $CountFoundletters=0;}
			
			$match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;
			
			//if(`size($StringFromReducedArray)`>4){
			$match = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)(.)" $StringFromReducedArray`;
			$matchii = `match "([a-zA-Z]+)([a-zA-Z0-9_])(.)(.)" $StringFromReducedArray`;
			$matchi = `match "([a-zA-Z]+)([a-zA-Z0-9_])(\.)([a-zA-Z0-9_]+)" $StringFromReducedArray`;
			$MatchStage2 = endString($match, 3);
			$MatchStage3 = startString($match, `sizeBytes $match`-2);
			$MatchStage3i = startString($match, `sizeBytes $matchii`-2);
			$addBracktoMatch3 = ("\["+$MatchStage3+"\]");
			//$addBracktoMatchD = ("\(["+"\"+$matchi+"\])+([a-zA-Z]+)([a-zA-Z0-9_])");
			$matchMiddleDiff = `match $addBracktoMatch3  $MatchStage2`;
			
			if($matchMiddleDiff=="\."){
				
				string $matchMaybeVec2 = `match "(\\.)([xyz][^a-zA-Z0-9_])" $MatchStage2`;
				if($matchMaybeVec2!=""){
					$MatchStage4 = startString($match, `sizeBytes $match`-1);
					$match = $MatchStage4;
				}else{ $dontUse = $matchi; $match=$matchi; }
			}else{ if($match0==$MatchStage3i){$match =  $MatchStage3i;}else{$match =$match0;}//   
			}
		}
	}else{$LetterItem ="";  }
	///}else{$match = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $StringFromReducedArray`;}
	$matchTemp = $match;
	
	$iixI++;
}

///////////////

string $printneat = stringArrayToString($FoundVariableItems, ",");
string $printneati = stringArrayToString($FoundOtherItems, ",");
string $FoundTerms[] = stringToStringArray($printneat, ",");

if($sortN== 1){$FoundTerms = `sort $FoundTerms`;}
$EmptyIntArray = $CountIndex;
return $FoundTerms;

}



proc int BracketFindPosNeg(string $Find, int $NegPosZ[]){

string $BracketF;
string $BracketL;
int $BytNumi;
string $Fb = "{";
string $Lb = "}";
$BracketF = `match "[\{]" $Find`;
$BracketL = `match "[\}]" $Find`;
 string $all[];
string $NewSt="";
if(($BracketF != "")||($BracketL != "")){
$BytNumi = `sizeBytes $Find`;
$all = ArrayFromAllinString($Find);
int $iX=0;
for($i=0;$i<$BytNumi;$i++){
if(( $all[$i] == $Fb ) || ( $all[$i] == $Lb )){
$NewSt = $all[$i];
if($NewSt == $Fb){
$NegPosZ[`size($NegPosZ)`] = 1;
}else if($NewSt == $Lb){
$NegPosZ[`size($NegPosZ)`] = -1;
}
$iX++;
	}
		}
}
int $AddAll;
for($eachInt in $NegPosZ){
$AddAll+= $eachInt;
}
return $AddAll;
}


proc string [] stringArrayFindDupIndexSPair(string $listA[], int $foundN[], int $LineNumberB[])
{
string $item, $result[];
int $FindNum = 0;
int $FindIndexN[];
string $listTemp[];
clear $foundN;
string $list[];
int $LineNumberA[];
$LineNumberA = $LineNumberB;
$list = $listA;
$listTemp  = $list;
	for ($item in $list) {
clear $FindIndexN;
$FindNum = stringArrayCountIndex($item,  $listTemp, $FindIndexN);       
		 if ($FindNum>1){
$foundN[`size($foundN)`] = $LineNumberA[$FindIndexN[`size($FindIndexN)`-1]];
$result[`size($result)`] =  $listTemp[$FindIndexN[`size($FindIndexN)`-1]];
$LineNumberA = IntRemoveIndexN( $LineNumberA, $FindIndexN);
 $listTemp = RemoveStringAtIndex( $listTemp, $FindIndexN);
		}else{ 
if ($FindNum==1){
 $foundN[`size($foundN)`] = $LineNumberA[$FindIndexN[0]];
 $result[`size($result)`] =  $listTemp[$FindIndexN[0]];
}
}
}
	return $result;
}


proc int stringArrayCountIndexOne(string $item, string $list[], int $FindIndexN[])
{
	int $result = 0;
	int $CountN = 0;
	string $listItem;
clear $FindIndexN;
	
	for ($listItem in $list) {
		if ($item == $listItem){ 
$FindIndexN[$result]=$CountN;
$result++;
}
$CountN++;
	}	
	return $result;
}

 proc int [] stringArrayRemoveAtIndexZ( int $indexA, int $list[] )
{
	int     $i;
	int  $result[];
int  $indexS = `size($indexA)`;
	int     $len = size( $list );
int $Xi =0;
while($Xi< $indexS){
	for ( $i = 0; $i < $Xi; $i++ ) {
		$result[$i] = $list[$i];
	}
$Xi++;
}
//$list = $result;
	return $result;
}

proc int [] RemoveINTAtIndex(int $VecS[],int $IndeXxI[]){
int $newInt[];
int $Ix = 0;
int $ii = 0;
int $Ixi = 0;
int $IndeXxz[];
$IndeXxz = `sort $IndeXxI`;
int $size = `size($IndeXxI)`-1;
for ($eachVc in $VecS){
if($VecS[$ii]>$IndeXxz[$Ixi]){
if($size==$Ixi){$Ixi=0;}
$Ixi++;
}
if(!($eachVc== $IndeXxz[$Ixi])){
$newInt[`size($newInt)`] = $eachVc;
$ii=$Ix;
}else{$Ixi++;
if( $Ixi> `size($IndeXxI)`){break;}
}
$Ix++;
}
return $newInt;
}


proc int [] IntArrayRemoveAtIndex( int $index, int $IntArray[] )
{

string $list[] = IntArrayToStringArray( $IntArray );
	int     $i;
	string  $result[];
	int     $len = `size( $list )`;
	for ( $i = 0; $i < $index; $i++ ) {
		$result[$i] = $list[$i];
	}
	for ( ; $i < $len - 1; $i++ ) {
		$result[$i] = $list[$i + 1];
	}
	$list = $result;
$IntArray = StringArrayToIntArray($list);
//string [] IntArrayToStringArray(int $IntArray[])
	return $IntArray;
}

proc int stringArrayCountIndex(string $item, string $list[], int $FindIndexN[])
{
	int $result = 0;
	int $CountN = 0;
	string $listItem;
clear $FindIndexN;
	for ($listItem in $list) {
		if ($item == $listItem){ 
$FindIndexN[$result]=$CountN;
$result++;
}
$CountN++;
	}
	return $result;
}

proc string [] stringArrayStrip(string $list[])
{
	string $item, $result[];
	int    $index = 0;	
	for ($item in $list) {
	$result[$index++] = substituteAllString($item, " ", "");
	}	
	return $result;
}


proc string [] stringArrayFindDuplicates(string $list[])
{
	string $item, $result[];
	int    $index = 0;	
	for ($item in $list) {
		if (1 < stringArrayCount($item, $list)) {
			$result[$index++] = $item;
		}
	}
return $result;
}


 proc int [] stringArrayRemoveAtIndexZ( int $indexA, int $list[] )
{
	int     $i;
	int  $result[];
int  $indexS = `size($indexA)`;
	int     $len = size( $list );
int $Xi =0;
while($Xi< $indexS){
	for ( $i = 0; $i < $Xi; $i++ ) {
		$result[$i] = $list[$i];
	}
$Xi++;
}
//$list = $result;
	return $result;
}


proc int [] RemoveINTAtIndex(int $VecS[],int $IndeXxI[]){
int $newInt[];
int $Ix = 0;
int $ii = 0;
int $Ixi = 0;
int $IndeXxz[];
$IndeXxz = `sort $IndeXxI`;
int $size = `size($IndeXxI)`-1;
for ($eachVc in $VecS){
if($VecS[$ii]>$IndeXxz[$Ixi]){
if($size==$Ixi){$Ixi=0;}
$Ixi++;
}
if(!($eachVc== $IndeXxz[$Ixi])){
$newInt[`size($newInt)`] = $eachVc;
$ii=$Ix;
}else{$Ixi++;
if( $Ixi> `size($IndeXxI)`){break;}
}
$Ix++;
}
return $newInt;
}


proc string [] stringArrayStrip(string $list[])
{
	string $item, $result[];
	int    $index = 0;
	for ($item in $list) {
	$result[$index++] = substituteAllString($item, " ", "");
	}
	return $result;
}


proc string [] stringArrayFindDuplicates(string $list[])
{
	string $item, $result[];
	int    $index = 0;
	for ($item in $list) {
		if (1 < stringArrayCount($item, $list)) {
			$result[$index++] = $item;
		}
	}
return $result;
}

////////////////


proc string[] FindStringVarZ(string $FindZ){
string $FindN = $FindZ;
string $stringRN;
string $match0;
string $match0N;
string $CollectFinds[];
int $Size;
$Size =  `sizeBytes  $FindN`;
while($Size>0){

 $match0N = `match "([\$]+)([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
if(`sizeBytes $match0N`>0){
$stringRN = `substitute $match0N $FindN ""`;
	$FindN = $stringRN;
}

 $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
$Size =  `sizeBytes  $match0`;
if($Size>0){
$CollectFinds[`size($CollectFinds)`]= $match0;
$stringRN = `substitute $match0 $FindN""`;
	$FindN = $stringRN;
}
}
return $CollectFinds;
}

proc string[] FindTrueStringVarZ(string $FindZ){
string $FindN = $FindZ;
string $stringRN;
string $match0;
string $CollectFinds[];
int $Size;
$Size =  `sizeBytes  $FindN`;
while($Size>0){
$match0 = `match "([\$]+)([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
// $match0 = `match "([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;

$Size =  `sizeBytes  $match0`;
if($Size>0){
$CollectFinds[`size($CollectFinds)`]= $match0;
$stringRN = `substitute $match0 $FindN""`;
	$FindN = $stringRN;
}
}
return $CollectFinds;
}



proc string [] RemoveStringAtIndex(string $VecS[],int $IndeXz[]){
string $newVec[];
int $IndeXxiz[] = sort($IndeXz); 
int $SizA = `size($IndeXz)`;
int $Ixx =0;
int $Ixi = 0;
for ($eachVc in $VecS){
if(!($Ixx== $IndeXxiz[$Ixi])){
$newVec[`size($newVec)`] = $eachVc;
}else{$Ixi++;}
$Ixx++;
}
return $newVec;
}

proc int [] RemoveIntAtIndex(int $VecS[],int $IndeXz[]){
int $newVec[];
int $IndeXxiz[] = sort($IndeXz); 
int $SizA = `size($IndeXz)`;
int $Ixx =0;
int $Ixi = 0;
for ($eachVc in $VecS){
if(!($Ixx== $IndeXxiz[$Ixi])){
$newVec[`size($newVec)`] = $eachVc;
}else{$Ixi++;}
$Ixx++;
}
return $newVec;
}



proc int [] StringArrayToIntArray(string $listA[]){
int $IntA[];
for($eachString in $listA){
 $IntA[`size($IntA)`]=$eachString;
}
return $IntA;
}




proc int FindSCRIPTNAME(string $LineNA){
string $Parts[];
int $Trigger=0;
		$Parts =FindStringVarZ($LineNA);
		if(`size($Parts)`>0){
		for($eachP in $Parts){
if(`gmatch "proc" $eachP` == 1){$Trigger=1;}
}
}
return $Trigger;
}

/*
string $TEMPNAMES[];
$TEMPNAMES =RuleBasedMatchM($IndexX,$CAL_temp, $DebugS);
print $TEMPNAMES
print $IndexX;
clear$IndexX;
clear$TEMPNAMES;

print $DebugS[22];

string $Parts[];

$Parts =FindStringVarZ($DebugS[22]);
*/


proc string [] RuleBasedMatchM(int $IndexN[],string $FindItemAllCase[], string $LineNA[]){

int $CountCase =0;
int $returnCaseN[];
string $FoundP[];
string $matchString;
string $Parts[];
int $Trigger=0;

if(`size($IndexN)`>0){
clear $IndexN;
}

for($LineN in $LineNA){
$CountCase =0;
		for($eachFindItem in $FindItemAllCase){

	 	//$matchString = `match $eachFindItem $LineN`;
		$Parts =FindStringVarZ($LineN);

		if(`size($Parts)`>0){
		for($eachP in $Parts){
		if(`gmatch $eachFindItem $eachP` == 1){
			$FoundP[`size($FoundP)`]= $eachFindItem;
			$Trigger=1;
		clear $Parts;
		break;		
			}
			}
			}

$matchString="";
if($Trigger==1){break;}
$CountCase++; 
		}

if(($CountCase>0)||($Trigger==1)){
$returnCaseN[`size($returnCaseN)`] = $CountCase;
$IndexN =$returnCaseN;
}
$Trigger=0;
}

return $FoundP;
}


proc string [] RuleBasedMatchMM(int $IndexN[],string $FindItemAllCase[], string $LineNA[]){
	int $CountCase =0;
	int $returnCaseN[];
	string $FoundP[];
	string $matchString;
	string $Parts[];
	int $Trigger=0;
	int $Number;
	for($LineN in $LineNA){
		$CountCase =1;
		$Number=-1;
		$Parts =FindStringVarZ($LineN);
		print $Parts;
		if(`size($Parts)`>0){

			for($eachP in $Parts){
				$Number = RuleBasedMatch($FindItemAllCase, $eachP);
				if($Number != -1){
					$FoundP[`size($FoundP)`]= $FindItemAllCase[$Number];
					$Trigger=1;
				}

				if($Trigger==1){break;}
			}
	clear $Parts;
		}
		
		if($Trigger==1){$returnCaseN[`size($returnCaseN)`] = $Number;}
		$Trigger=0;
	}
	$IndexN =$returnCaseN;
	return $FoundP;
}


proc int RuleBasedMatch(string $FindItemAllCase[], string $LineN){
int $CountCase =0;
int $returnCaseN =0;
for($eachFindItem in $FindItemAllCase){
//$matchString = `match $eachFindItem $LineN`;
if(`gmatch $eachFindItem $LineN` == 1){
$returnCaseN = $CountCase;
break;
}
$CountCase++;
}
return $returnCaseN;
}





proc string [] AppendArrayZ(string $A[] , string $B[]){
for($eachF in $B){
$A[`size($A)`]= $eachF;
}
return $A;
} 



 proc int [] intArrayRemoveDuplicates(int $list[])
{
	int $item, $result[];
	int    $index = 0;	
	for ($item in $list) {
		if (0 == intArrayCount($item, $result)) {
			$result[$index++] = $item;
		}
	}	
	return $result;
}


proc int intArrayCount(int $item, int $list[])
{
	int $result = 0;	
	int $listItem;	
	for ($listItem in $list) {
		if ($item == $listItem) $result++;
	}	
	return $result;
}


proc string RemoveEscapedLine(string $TEXTA){
string $MatchPart="";
string $stringNX="";
$MatchPart=match( "//", $TEXTA );
if(`sizeBytes $MatchPart`>0){
$MatchPart="";
$MatchPart=match( "//[^\n]*", $TEXTA  );
$stringNX = `substitute $MatchPart $TEXTA ""`;
}else{$stringNX =$TEXTA;}
return $stringNX;
}



proc string [] BracketFind(string $Find){
string $AllFOUND[];
string $FirstBracket;
int $BytNumi;
$BytNumi = `sizeBytes $Find`;
for($i=0;$i<$BytNumi;$i++){
if($i==100){
break;}
$FirstBracket = `match "[\(][^\(]*[^.]*[^\(]*[\)]" $Find`;
if($FirstBracket != ""){
$AllFOUND[`size($AllFOUND)`] = $FirstBracket;
    string $text = $Find;
    string $result = substituteAllString($text, $FirstBracket, "#");
$Find =  $result;
}else if($FirstBracket == ""){
print "found nothing";
print $AllFOUND;
$i = $BytNumi +2;
break;
}
}
return $AllFOUND;
}

proc string [] BracketFind(string $Find){
string $AllFOUND[];
string $FirstBracket;
int $BytNumi;
$BytNumi = `sizeBytes $Find`;
for($i=0;$i<$BytNumi;$i++){
if($i==100){
break;}
$FirstBracket = `match "[\(][^\)]*[^.]*[^\(]*[\)]" $Find`;
if($FirstBracket != ""){
print ("found something"+"\n");
$AllFOUND[`size($AllFOUND)`] = $FirstBracket;
    string $text = $Find;
    string $result = substituteAllString($text, $FirstBracket, "#");
$Find =  $result;
}else if($FirstBracket == ""){
$i = $BytNumi +2;
break;
}
}
return $AllFOUND;
}

/*

string $testM ="$XI[1]= FloatToVec (MidPoint($XI[0],$XI[2]));";
vector $Poii[];
float $li[]=
string $BB ="$In3 = FloatToVec (lineIntersection($Po4[$Fi], $Xd, $li,(DirectionFN( $Ca,$li)) ));";

string $testBBracket = `match "[\(][\(]*[^.]*[^\(]*[\)]" $BB`;
$testBBracket = `match "[\(]*[^.]*[\)]*[\)^]" $testBBracket`;


string $testB[] =BracketFind($BB);
print $testB;


string $testM ="float $Po12[] = {($Po13[0]*-1), $Po13[1],$Po13[2]};";
string $testM ="float $Po12 = {($Po13[0]*-1), $Po13[1],$Po13[2]};";



string $B = `match "(float*[a-zA-Z_0-9]).+\=" $testM`;
string $B2 = `match ".*\\[" $B`;

// 
/// 



string $testM ="float $lineEPointA[]= MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);";
string $testM ="float $li[]= MultLenToDirAddToPoint($Le, $Fl, $Ve8[$Fi]);";
string $testM ="$BInomalV = FloatToVec(MultLenToDirAddToPoint(4, $BInomalVDirLine, $PtsVec [0]));";


//current line 
string $testM;
//the command to replace
string $VartoReplace="MultLenToDirAddToPoint";
string $result;
string $OriginalStart=`match ".*\=" $testM`;
//string $OriginalStart=`match ".*=*[+^M]" $testM`;
string $M = `match "($VartoReplace*[a-zA-Z_0-9]).+\;" $testM`;
string $M2 = `match "[\(][^\(]*[^.]*[^\(]*[\)]" $M`;
$result = substituteAllString($M2, "(", "");
$result = substituteAllString($result, ")", "");
string $M3 = `match "\$*[^,]*" $result`;
string $PartS[];
clear $PartS;

string  $resultTemp= $result;
int $i;
int $BytS=1;
$PartS = stringToStringArray($resultTemp, ",");
string $Fix = $OriginalStart+"\("+$PartS[0]+"\*"+$PartS[1]+"\)"+"\+"+$PartS[2]+"\;";

print ($testM+"\n");
print ($Fix+"\n");







//string $M3 = `match "[\[][^\[]*[^.]*[^\[]*[\]]" $M`;
// $result = substituteAllString($result, $M3, "");
$In3 = FloatToVec (lineIntersection($Po4[$Fi], $Xd, $li,(DirectionFN( $Ca,$li)) ));

*/


proc int BracketFindPosNegRuleE( int $CN, string $NewLineX, string $TEXTA, int $NegPosZ[]){

int $AddAll=0;
$NewLineX="";
string $BracketF = `match "[\/]+[\*]"$TEXTA`;
string $BracketL = `match "[\*]+[\/]" $TEXTA`;
string $MatchPartA,$MatchPartB;
int $TRUEA=0; int $TRUEB=0;

if(`sizeBytes $BracketF`>0){$TRUEA=1;}
if(`sizeBytes $BracketL`>0){$TRUEB=1;}

if($TRUEA+$TRUEB!=2){
if($TRUEA==1){
$NegPosZ[`size($NegPosZ)`] = 1;
$NewLineX=`substitute "//\*[^\n]*" $TEXTA ""`;
}
if($TRUEB==1){
$NegPosZ[`size($NegPosZ)`] = 2;
$NewLineX= `substitute ".*\*/" $TEXTA ""`;
}
for($eachInt in $NegPosZ){
$CN++;
$AddAll+= $eachInt;
}
}else{

if($TRUEA+$TRUEB==3){
$MatchPartA=`substitute "//\*[^\n]*" $TEXTA ""`;
$MatchPartB=`substitute ".*\*/" $TEXTA ""`;
$NewLineX=($MatchPartA+" "+$MatchPartB);
$AddAll=0;
}
		}


return $AddAll;
}


proc string[] RStringArrayStartOfStringinArray(string $Array[]){
	string $StartOfEach[];
string $stringRN;
string $SS;
string $S;
	string $findEachstart="";
	for ($eachString in $Array){

$stringRN = `substitute "[/$]" $eachString ""`;
$S=startString($eachString, 3);

		$findEachstart= $S;
		$findEachstart+= "";
		$StartOfEach[`size($StartOfEach)`]= $findEachstart;
	}
	
	return $StartOfEach;
}

proc string [] stringArrayCountDuplicatesAUGMENT(string $listX[],string $AddtoEnd)
{
string $list[] = $listX;
$list = ReverseStringArray($list);
	string $item, $result[], $CollectR[];
	int $index = 0;
int $X = 0;
int $C = 0;
int $NumberE[];
$result = $list;
	string $Expr = "\\$";
string $ExprA = "";
	
	for ($item in $list) {
$NumberE[$X] = stringArrayCount($item, $result);
		if (1 == $NumberE[$X]) {
if(startString($item, 1)!= "$"){
$CollectR[$X] = $ExprA+$item+$AddtoEnd;
}	
if(startString($item, 1)== "$"){		
			$CollectR[$X] = $item+$AddtoEnd;}
		}else{
		if (1 < $NumberE[$X]) {
$C = $NumberE[$X]-1;
if(startString($item, 1)!= "$"){
$CollectR[$X] = $ExprA+$item+$C+$AddtoEnd;
}
if(startString($item, 1)== "$"){
$CollectR[$X] = $item+$C+$AddtoEnd;
}		
		}
}
stringArrayRemoveToIndex(1, $result);
$X++;	}
$CollectR = ReverseStringArray($CollectR);	
	return $CollectR;
}

proc string[] ReverseStringArray(string $array[]){
	string	$arrayOut[];	
		for($i=0;$i<size($array);$i++){
			$arrayOut[$i]=$array[(size($array)-1-$i)];}		
	return $arrayOut;
}
proc stringArrayRemoveToIndex(int $ix, string $stringArray[]){
int $ixX= 0;
while($ixX<$ix){
stringArrayRemoveAtIndex(0, $stringArray);
$ixX++;
}
}
proc int [] CreateIntIndex(int $ArraySize){
int $iNdex = 0;
int $IntArrayInex[];
while($iNdex < $ArraySize){
$IntArrayInex[$iNdex] = $iNdex;
$iNdex++;
}
return $IntArrayInex;
}

proc string RuleBasedMatchReplaceLine(string $FindItemAllCase[],string $ReplaceCase[], string $LineN){
int $CC =0;
int $returnCaseN =0;
string $matchString;
string $CHANGE;
$CHANGE=$LineN;
for($eachFindItem in $FindItemAllCase){
$matchString = `match $eachFindItem $CHANGE`;
$Size =  `sizeBytes  $matchString`;
if($Size>0){
	$CHANGE = substituteAllString($CHANGE, $matchString,  $ReplaceCase[$CC]);
}
$CC++;
}
return $CHANGE;
}



///////////////////////////////////////


string $Path = "C:\\Users/johnny/Documents/maya/scripts/StereoCurveZTemp.TXT";
string $exampleFileName = ( $Path );


string $CollectAllLines[];
clear $CollectAllLines;
string $matchString;
string $LineN = "";
string $FindItem = "";
string $stringN;
string $stringRN;
string $MatchPartA;

int $fileId =`fopen $exampleFileName "r"`;
string $nextLine = `fgetline $fileId`;
int $failsafe = 0;

while ( !`feof $fileId` ) {
	
//print $nextLine;
$stringRN =  $nextLine;
$stringRN = `substitute "(\n)" $stringRN ""`;
 $MatchPartA=match( ".*[^\t\r\n]", $nextLine );

 if(`sizeBytes $MatchPartA`>0){	

//$stringN = $nextLine;

$LineN = $stringRN;
//$matchString = `match $FindItem $LineN`;
//if(`gmatch $matchString $FindItem` == 1){

$CollectAllLines[`size($CollectAllLines)`]=$LineN;
//}

}
$nextLine = `fgetline $fileId`;
$failsafe++;

if($failsafe==600){
break;
}
}

fclose $fileId;

//  print $CollectAllLines;

/////////////////////////////////////////////////////////////////////////////////////////////////// end of new change ^
// print $CollectAllLines;




string $TempAllVarZ[];
string $AllVarZ[];

int $CNX=0;
for ($eachString in $CollectAllLines){
		$TempAllVarZ = FindTrueStringVarZ($eachString);
AppendArrayZ($AllVarZ , $TempAllVarZ);
if(`size($TempAllVarZ)`>0){
clear $TempAllVarZ;
}
$CNX++;
}


string $shorterListAllVarZ[] =  stringArrayRemoveDuplicates ($AllVarZ);
int $SizeAll = `size($shorterListAllVarZ)`;
string $startingCharV[] = RStringArrayStartOfStringinArray($shorterListAllVarZ);


string $NewNames[] = stringArrayCountDuplicatesAUGMENT($startingCharV,"");
string $NewLineChange;
string $NewLineZ[];
clear $NewLineZ;
int $CountLineX=0;
string $AddLineN;

for ($eachStringL in $CollectAllLines){
$NewLineChange = RuleBasedMatchReplaceLine($shorterListAllVarZ ,$NewNames, $eachStringL);
$NewLineZ[`size($NewLineZ)`] = $NewLineChange;
$CountLineX++;
}
print $NewLineZ;






string $PathW = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
string $exampleFileNameW = ( $PathW );

string $Path = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEW.TXT";
string $exampleFileName = ( $Path );


//clears the file i think
int $fileIdW =`fopen $exampleFileNameW "w"`;
fclose $fileIdW;


int $NegPosZA[];
clear $NegPosZA;
int $WhenZero=2;
int $CountNL = 1;
int $CountFindNL = 0;
int $CountX = 0;
int $fileIdW =`fopen $exampleFileNameW "w"`;
int $fileId =`fopen $exampleFileName "r"`;
string $nextLine ="";
string $nextLineN ="";
int $TriggerLineFound = 0;
int $START = 0;
string $MatchPartA="";
string $MatchPartB="";
string $NewLineXA="";
int $DontWrite=0;
$NegPosZA[0]=0;
clear $NegPosZA;
int $CountN=1;

while ( !`feof $fileId` ) {
	$nextLine = `fgetline $fileId`;
$nextLineN = $nextLine;

$nextLineN=RemoveEscapedLine($nextLineN);
$MatchPartA=match( ".*[^\t\r\n]", $nextLineN );
 if(`sizeBytes $MatchPartA`>0){	
$MatchPartA=match( ".*[^\t\r\n]", $nextLineN );
$nextLineN=( $MatchPartA +"\r"+"\n");
fprint $fileIdW $nextLineN;
}

}
    
fclose $fileIdW;
fclose $fileId;




string $PathW = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
string $exampleFileNameW = ( $PathW );

string $Path = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEW.TXT";
string $exampleFileName = ( $Path );

string $Path = "C:\\Users/johnny/Documents/maya/scripts/TESTRUN.TXT";
string $exampleFileName = ( $Path );

//clears the file i think
int $fileIdW =`fopen $exampleFileNameW "w"`;
fclose $fileIdW;


int $NegPosZA[];
clear $NegPosZA;
int $WhenZero=2;
int $CountNL = 1;
int $CountFindNL = 0;
int $CountX = 0;
int $fileIdW =`fopen $exampleFileNameW "w"`;
int $fileId =`fopen $exampleFileName "r"`;
string $nextLine ="";
string $nextLineN ="";
int $TriggerLineFound = 0;
int $START = 0;
string $MatchPartA="";
string $MatchPartB="";
string $NewLineXA="";
int $DontWrite=0;
$NegPosZA[0]=0;
clear $NegPosZA;
int $CountN=1;

while ( !`feof $fileId` ) {
	$nextLine = `fgetline $fileId`;
$nextLineN = $nextLine;



 $MatchPartA=match( ".*[^\t\r\n]", $nextLineN );

 // if(`sizeBytes $MatchPartA`>0){	
		$WhenZero = BracketFindPosNegRuleE($CountN,$NewLineXA,$nextLineN, $NegPosZA);

if($WhenZero!=0){
$CountN+=$WhenZero;
}
if($WhenZero==3){
$CountN*=-1;
print $CountN;
}

if(($CountN==2)||($WhenZero==3)){
$nextLineN=$NewLineXA;
}


if(($CountN<=2)||($WhenZero==3)){

if(($CountN<0)&&($WhenZero!=3)){
// do nothing
}else{

$nextLineN=RemoveEscapedLine($nextLineN);
 $MatchPartA=match( ".*[^\r\n]", $nextLineN );
$nextLineN=( $MatchPartA +"\r"+"\n");
fprint $fileIdW $nextLineN;
}

}

if($CountN<0){
clear $NegPosZA;
$CountN=1;
}

//}

}
    		
fclose $fileIdW;
fclose $fileId;
-13-24-100-11-19-194-160-534-262-22-38-20-12-876-70-18-800-74-74-118-34-12-10-100-1982-404-1100-10-40-240-840-10-16-60-2534-610-44-126-498-36-2018-1106-118
-12-23-90-10-18-182-138-456-256-18-36-16-6-746-58-14-646-46-54-102-28-6-6-88-1794-364-982-6-34-208-808-6-6-50-2330-548-38-120-428-34-1654-990-104
-12-23-90-10-18-180-136-454-254-16-34-14-6-746-58-14-646-46-54-102-28-6-6-88-1794-364-982-6-34-208-808-6-6-50-2330-548-38-120-428-34-1654-990-104fclose $fileIdW;





string $PathW = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
string $exampleFileNameW = ( $PathW );

string $Path = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEW.TXT";
string $exampleFileName = ( $Path );

//clears the file i think
int $fileIdW =`fopen $exampleFileNameW "w"`;
fclose $fileIdW;


int $NegPosZA[];
clear $NegPosZA;
int $WhenZero=2;
int $CountNL = 1;
int $CountFindNL = 0;
int $CountX = 0;
int $fileIdW =`fopen $exampleFileNameW "w"`;
int $fileId =`fopen $exampleFileName "r"`;
string $nextLine ="";
string $nextLineN ="";
int $TriggerLineFound = 0;
int $START = 0;
string $MatchPartA="";
string $MatchPartB="";
string $NewLineXA="";
int $DontWrite=0;

while ( !`feof $fileId` ) {
	$nextLine = `fgetline $fileId`;
$nextLineN = $nextLine;

$nextLineN=RemoveEscapedLine($nextLineN);

 $MatchPartA=match( ".*[\n]", $nextLineN );
 if(`sizeBytes $MatchPartA`>0){


		$MatchPartB=match( "/", $nextLineN );
	if(`sizeBytes $MatchPartB`>0){
		
		$WhenZero = BracketFindPosNegRuleE($NewLineXA,$nextLineN, $NegPosZA);
		$nextLineN=$NewLineXA;


if(($WhenZero==1)||($WhenZero==0)){

if($DontWrite==0){
$nextLineN=($nextLineN +"\r"+"\n");
fprint $fileIdW $nextLineN;
}

}

if(`size($NegPosZA)`>0){
$DontWrite=1;
}
if(($WhenZero==0)&&(`size($NegPosZA)`>0)){
if($DontWrite==1){
$WhenZero=2;
clear $NegPosZA;
$DontWrite=0;
}
}
	}
////////////

if(`size($NegPosZA)`==0){
if($DontWrite==0){
$nextLineN=($nextLineN +"\r"+"\n");
fprint $fileIdW $nextLineN;
}
}

}

}
    		
fclose $fileIdW;
fclose $fileId;







string $Path = "C:\\Users/johnny/Documents/maya/scripts/STEREOCURVESPROC2011.TXT";
string $exampleFileName = ( $Path );

//string $Path = "C:\\Users/johnny/Documents/maya/scripts/ArrayRotationIterative.TXT";
//string $exampleFileName = ( $Path );


string $ScriptNAME= ("proc[^\\n]*");
string $FindItem = "proc";
string $GlobalSNAME= ("global[^\\n]*");



string $CollectAllLines[];
clear $CollectAllLines;
string $matchString;
string $LineN = "";
string $stringN;
int $LineNumber[];
clear $LineNumber;
int $CountNL = 1;
int $CountFindNL = 0;
int $CountMasterInDex = 0;

int $fileId =`fopen $exampleFileName "r"`;

while ( !`feof $fileId` ) {

	$nextLine = `fgetline $fileId `;
 $stringN = match( "^[^(\r\n)]*", $nextLine );


//$stringN = $nextLine;
$LineN =  $stringN;

//$LineN =match( "[/(proc)]*", $stringN  );
 if(`FindSCRIPTNAME($LineN )` == 1){

//if(`gmatch $FindItem $LineN` == 1){
//$LineN =match( $ScriptNAME, $nextLine);

$CollectAllLines[`size($CollectAllLines)`]=  $LineN ;
$LineNumber[$CountFindNL] = $CountNL;
$CountFindNL++;
}
$CountNL++;
$CountMasterInDex++;
}

fclose $fileId;
print $CollectAllLines[0];

print $LineNumber


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// FIND LAST DUPLICATES

proc int[] SortIntIndexTrack(int $AllFloatToSort[]){
int $IndexTrack[];
float $aF[];
int $ii;
for($ii=0; $ii<`size($AllFloatToSort)`; $ii++){
$aF[$ii]= ($AllFloatToSort[$ii]);
}
int $sIze = `size($aF)`-1;      
$IndexTrack = CreateIntIndex(`size($aF)`);
quickSort($aF, $IndexTrack, 0, $sIze);
$IndexTrack = ReverseIntArray($IndexTrack);
return $IndexTrack;
}



int $EArray[];
int $SizeL = `size($CollectAllLines)`;
int $iL;
string $JustNames[];
clear $JustNames;
string $TempN[];
for($iL=0; $iL<$SizeL; $iL++){
$TempN = FindStringVarZ($CollectAllLines[$iL]);
$JustNames[$iL]=$TempN[`size($TempN)`-1];
}
size($JustNames);
size($CollectAllLines);

$CollectAllLines = $JustNames;


int $tempLineNumber[];
clear $tempLineNumber;
$tempLineNumber = $LineNumber;
int $foundNA[];
clear $foundNA;
// line number is an extraction...... //
string $tempCollectAllLines[];
clear $tempCollectAllLines;
$tempCollectAllLines = $CollectAllLines;
string $CollectAllDuplicates[];
clear $CollectAllDuplicates;

/////////////////////////////string $tempCollectAllLines[] = stringArrayStrip($CollectAllLines);

$CollectAllDuplicates = stringArrayFindDupIndexSPair($tempCollectAllLines,$foundNA, $tempLineNumber);


int $intIDXSort[] =SortIntIndexTrack($foundNA);

string $newCollectDupString[];
int $ii;
for($ii=0; $ii<`size($intIDXSort)`; $ii++){
$newCollectDupString[$ii]= $CollectAllDuplicates[$intIDXSort[$ii]];
}
print $newCollectDupString;



//print  $foundNA;
//print $CollectAllDuplicates

//string $shouldBEZero[];
//$shouldBEZero= stringArrayFindDuplicates($CollectAllDuplicates);



// IMPORTANT SORT

$foundNA =`sort $foundNA`;


//int $foundNA[];
//$foundNA =$MasterLineN;


string $Path = "C:\\Users/johnny/Documents/maya/scripts/STEREOCURVESPROC2011.TXT";
string $exampleFileName = ( $Path );
	

string $PathW = "C:\\Users/johnny/Documents/maya/scripts/NewPlaceHere.TXT";
string $exampleFileNameW = ( $PathW );

//clears the file i think
int $fileIdW =`fopen $exampleFileNameW "w"`;
fclose $fileIdW;


int $NegPosZA[];
clear $NegPosZA;
int $WhenZero=2;
int $CountNL = 1;
int $CountFindNL = 0;
int $CountX = 0;
int $fileIdW =`fopen $exampleFileNameW "w"`;
int $fileId =`fopen $exampleFileName "r"`;
string $nextLine ="";
string $nextLineN ="";
string $nextLineR;
int $TriggerLineFound = 0;
int $START = 0;
string $InputLine =("///THIS IS A DUPLICATE ///"+"\r"+"\n");

while ( !`feof $fileId` ) {
	$nextLine = `fgetline $fileId`;
$nextLineN = $nextLine;
	$nextLineR = match( ".*[^(\n)]", $nextLine );

if($foundNA[$CountFindNL] == $CountNL){
fprint $fileIdW ("\r"+"\n");
$CountFindNL++;
$TriggerLineFound=1;
}

if($TriggerLineFound==1){
$WhenZero = BracketFindPosNeg($nextLine, $NegPosZA);
$START++;
$nextLineN=($nextLineR +"\r"+"\n");

fprint $fileIdW $nextLineN;


if((`size($NegPosZA)`>0)&&($START>1)){
if($WhenZero==0){
$START=$TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
fprint $fileIdW ("\r"+"\n");
}
}

}
$CountNL++;
}
    		
fclose $fileIdW;
fclose $fileId;



//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//small addOn




string $Path = "C:\\Users/johnny/Documents/maya/scripts/PlaceHere.TXT";
string $exampleFileName = ( $Path );
int $IndexR[];
int $IndeXCN[];
clear $IndeXCN;
$IndeXCN
clear $IndexR;
int $SizeCD=`size($newCollectDupString)`-1;
int $IndeXCN[218];
string $nextLineR;
string $nextLineRN;
int $Size;
int $ii;

int $fileId =`fopen $exampleFileName "r"`;

while ( !`feof $fileId` ) {

	$nextLine = `fgetline $fileId `;
$nextLineR = match( ".*[^(\n)]", $nextLine );
//$nextLineRN = match( ".*[^(\n)]", $nextLine );

$Size =  `sizeBytes  $nextLineR`;
if($Size>0){
RuleBasedMatchM($IndexR,$newCollectDupString, {$nextLineR});
for($ii=0; $ii<`size($IndexR)`; $ii++){
$IndeXCN[$IndexR[$ii]]+=1;
}
clear $IndexR;
}
}

fclose $fileId;


string $PRINTPRoc_andNumber[];
string $StringINDEXCN;

for($ii=0; $ii<`size($newCollectDupString)`; $ii++){
$StringINDEXCN=$IndeXCN[$ii];
$PRINTPRoc_andNumber[$ii]=($newCollectDupString[$ii]+" "+$StringINDEXCN);

}
print $PRINTPRoc_andNumber;
size($IndeXCN);
size($PRINTPRoc_andNumber);
print $IndeXCN;


 $IndeXCN = RemoveIntAtIndex($IndeXCN,{(`size($IndeXCN)`-1)});


int $intIDXSortX[] =SortIntIndexTrack($IndeXCN);

string $SortCountProcUse[];
int $ii;
for($ii=0; $ii<`size($intIDXSort)`; $ii++){
$SortCountProcUse[$ii]= $newCollectDupString[$intIDXSortX[$ii]];
}
print $SortCountProcUse;



int $ii;
int $newfoundNA[];
clear $newfoundNA;
for($ii=0; $ii<`size($IndeXCN)`; $ii++){

if($IndeXCN[$ii]!=1){
$newfoundNA[`size($newfoundNA)`]= $foundNA[$ii];
}
}


print $newfoundNA;

size($newfoundNA);

size($newCollectDupString);
size($IndexR);
size($IndeXCN);
size($foundNA);
size($CollectAllDuplicates);
size($intIDXSort);
size($newCollectDupString);


$newfoundNA =`sort ($newfoundNA)`;



string $Path = "C:\\Users/johnny/Documents/maya/scripts/STEREOCURVESPROC2011.TXT";
string $exampleFileName = ( $Path );
	

string $PathW = "C:\\Users/johnny/Documents/maya/scripts/NewPlaceHere.TXT";
string $exampleFileNameW = ( $PathW );

//clears the file i think
int $fileIdW =`fopen $exampleFileNameW "w"`;
fclose $fileIdW;


int $NegPosZA[];
clear $NegPosZA;
int $WhenZero=2;
int $CountNL = 1;
int $CountFindNL = 0;
int $CountX = 0;
int $fileIdW =`fopen $exampleFileNameW "w"`;
int $fileId =`fopen $exampleFileName "r"`;
string $nextLine ="";
string $nextLineN ="";
string $nextLineR;
int $TriggerLineFound = 0;
int $START = 0;
string $InputLine =("///THIS IS A DUPLICATE ///"+"\r"+"\n");

while ( !`feof $fileId` ) {
	$nextLine = `fgetline $fileId`;
$nextLineN = $nextLine;
	$nextLineR = match( ".*[^(\n)]", $nextLine );

if($newfoundNA[$CountFindNL] == $CountNL){
fprint $fileIdW ("\r"+"\n");
$CountFindNL++;
$TriggerLineFound=1;
}

if($TriggerLineFound==1){
$WhenZero = BracketFindPosNeg($nextLine, $NegPosZA);
$START++;
$nextLineN=($nextLineR +"\r"+"\n");

fprint $fileIdW $nextLineN;


if((`size($NegPosZA)`>0)&&($START>1)){
if($WhenZero==0){
$START=$TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
fprint $fileIdW ("\r"+"\n");
}
}

}
$CountNL++;
}
    		
fclose $fileIdW;
fclose $fileId;








////////////////////

//START X




string $Path = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
string $exampleFileName = ( $Path );


string $FindItem = "proc";
//string $FindItem = "print";
//string $FindItem = "//";


string $CollectAllLines[];
clear $CollectAllLines;
string $matchString;
string $LineN = "";
string $stringN;
int $LineNumber[];
clear $LineNumber;
int $CountNL = 1;
int $CountFindNL = 0;
int $CountMasterInDex = 0;

int $fileId =`fopen $exampleFileName "r"`;
//string $nextLine = `fgetline $fileId`;
while ( !`feof $fileId` ) {


	$nextLine = `fgetline $fileId`;
$stringN = match( "^[^(\r\n)]*", $nextLine );
$LineN = $stringN;

if(`FindSCRIPTNAME($LineN )` == 1){
$CollectAllLines[`size($CollectAllLines)`]=  $LineN ;
$LineNumber[$CountFindNL] = $CountNL;
$CountFindNL++;
}

$CountNL++;
$CountMasterInDex++;
}

fclose $fileId;


size($CollectAllLines);
size($LineNumber);

print $CollectAllLines[0];
FindStringVarZ($CollectAllLines[0]);


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// FIND LAST DUPLICATES

int $EArray[];
int $SizeL = `size($CollectAllLines)`;
int $iL;
string $JustNames[];
clear $JustNames; 
string $TempN[];
for($iL=0; $iL<$SizeL; $iL++){
$TempN = FindStringVarZ($CollectAllLines[$iL]);
$JustNames[$iL]=$TempN[`size($TempN)`-1];
}




size($JustNames);
size($CollectAllLines);
size($LineNumber);

int $TempSaveLine[];
$TempSaveLine=$LineNumber;
$CollectAllLines = $JustNames;

//TempERROR hack

int $CurrentLineN[];
string $CurrentProc[];
 $CurrentProc[0] ="proc";
int $CurrentLineNF[];

int $i=0;
int $IndexX[];
string $FoundProc[];
clear $IndexX;
clear $FoundProc;
clear $CurrentLineN;
$FoundProc =RuleBasedMatchM($IndexX,$CollectAllLines, $CurrentProc);
//print $IndexX;
for($i=0; $i<`size($IndexX)`; $i++){
$CurrentLineNF[$i] =$LineNumber[$IndexX[$i]];
}
print $CurrentLineNF;

$CollectAllLines=RemoveStringAtIndex($CollectAllLines,$IndexX);
$LineNumber = RemoveIntAtIndex($LineNumber,$IndexX);

//!!!Super Crazy Error!!! A String call "proc" was gathered as a function proc!
/*
print $CollectAllLines[$IndexX[0]];
$CollectAllLines=RemoveStringAtIndex($CollectAllLines,$IndexX);
$LineNumber = RemoveIntAtIndex($LineNumber,$IndexX);
*/
/// End of error hack




//start of normal script



int $TempSaveLine[];
$TempSaveLine=$LineNumber;
$CollectAllLines = $JustNames;



string $CurrentProc[];
$CurrentProc[0] ="AutoCurveScriptsTwoCurve";
$CurrentProc[1] ="RUNMoveZCURVEM";
$CurrentProc[2] ="EvalAllCurvesToolZ";
$CurrentProc[3] ="CreateCAMforIntCurveScript";
$CurrentProc[4] ="createStageOneForRetopo";



string $CurrentProc[];
clear $CurrentProc;
$CurrentProc[0] ="CreateCAMforIntCurveScript";
$CurrentProc[1] ="createStageOneForRetopo";







int $TempSaveLine[];
$TempSaveLine=$LineNumber;
$CollectAllLines = $JustNames;



string $CurrentProc[];
clear $CurrentProc;
$CurrentProc[0] ="AutoCurveScriptsTwoCurve";




int $TempSaveLine[];
$TempSaveLine=$LineNumber;
$CollectAllLines = $JustNames;



string $CurrentProc[];
$CurrentProc[0] ="AutoCurveScriptsTwoCurve";
$CurrentProc[1] ="RUNMoveZCURVEM";
$CurrentProc[2] ="EvalAllCurvesToolZ";
$CurrentProc[3] ="CreateCAMforIntCurveScript";
$CurrentProc[4] ="createStageOneForRetopo";




int $CurrentLineNF[];
clear $CurrentLineNF;

int $i=0;
int $IndexX[];
string $FoundProc[];
clear $IndexX;
clear $FoundProc;

$FoundProc =RuleBasedMatchM($IndexX,$CollectAllLines, $CurrentProc);
//print $IndexX;
for($i=0; $i<`size($IndexX)`; $i++){
$CurrentLineNF[$i] =$LineNumber[$IndexX[$i]];
}
print $CurrentLineNF;






string $CurrentProc[];
$CurrentProc[0] ="AutoCurveScriptsTwoCurve";

int $CurrentLineNF[];

int $i=0;
int $IndexX[];
string $FoundProc[];
clear $IndexX;
clear $FoundProc;
clear $CurrentLineN;
$FoundProc =RuleBasedMatchM($IndexX,$CollectAllLines, $CurrentProc);
//print $IndexX;
for($i=0; $i<`size($IndexX)`; $i++){
$CurrentLineNF[$i] =$LineNumber[$IndexX[$i]];
}
print $CurrentLineNF;



////////////////  run both ONCE 
////////////////  run both ONCE 




string $Path = "C:\\Users/johnny/Documents/maya/scripts/ORGANIZENEWB.TXT";
string $exampleFileName = ( $Path );
	
// search AutoCurveScriptsTwoCurve	 find procs then within those procs find more procs until
// $MasterLineN

int $MasterLineN[];
clear $MasterLineN;


int $CurrentLineN[];
$CurrentLineN = $CurrentLineNF;
$CurrentLineN = sort ($CurrentLineN);
string $CollectL[];
string $CAL_temp[];
int $LN_temp[];
clear $CollectL;
clear $CAL_temp;
clear $LN_temp;


 $CAL_temp =$CollectAllLines;
 $LN_temp =$LineNumber;
 $IndexX = sort ($IndexX);
 $CAL_temp=RemoveStringAtIndex($CAL_temp,$IndexX);
 $LN_temp = RemoveIntAtIndex($LN_temp,$IndexX);


string $stringN;
int $IndexX[];
string $FoundProc[];
int $NegPosZA[];
clear $NegPosZA;
int $WhenZero=2;
int $CountNL = 1;
int $CountFindNL = 0;
int $START = 0;
int $TriggerLineFound=0;
string $nextLine;
string $nextLineN;
string $nextLineR;
int $CurrentLineNX[];
string $FoundProcTemp[];
string $tempCollectProc[];
string $AllFoundProcs[];
clear $CurrentLineNX;
clear $tempCollectProc;
clear $IndexX;

int $Aint = size($CollectAllLines);
int $Bint = size($AllFoundProcs);
int $Cint = size($CAL_temp);
int $CHECK = $Aint-$Cint ;

//int $fileId =`fopen $exampleFileName "r"`;
//string $nextLine = `fgetline $fileId`;
//int $eachInt = $CurrentLineN[0];
clear $tempCollectProc;
clear $AllFoundProcs;

string $WholeProc[];
clear $WholeProc;
int $TRIGGEREND =2;

string $DebugS[];
clear $DebugS;

int $fileId =`fopen $exampleFileName "r"`;


while($TRIGGEREND>1){ 



///////////////////////////
///////////////////////////



 		for($eachInt in $CurrentLineN){


//this is the number that is the first line of a group of lines that are a proc


$WhenZero=2;
$CountNL = 1;
$CountFindNL = 0;
$START = 0;
$TriggerLineFound=0;



///////////////////////////////////////////////////////////////////

		while ( !`feof $fileId` ) {


				$nextLine = `fgetline $fileId`;
				$nextLineN = match( "^[^(\r\n)]*", $nextLine );
				$nextLineR = match( ".*[^(\n)]", $nextLine );

			//FOUND LINE NUMBER
			//CHANGE HERE

				if($CurrentLineN[$CountFindNL] == $CountNL){
 print $nextLineR;
				clear $NegPosZA;
				$CountFindNL++;
				$TriggerLineFound=1;
					}



	if($TriggerLineFound==1){

		$WhenZero = BracketFindPosNeg($nextLineR, $NegPosZA);
		$START++;
		$CollectL[`size($CollectL)`]= $nextLineR;
//$DebugS[`size($DebugS)`]= $nextLineR;



	/// WHEN PROC IS FULLY SCANNED HERE BELOW

		if(($WhenZero==0)&&($START>1)){
clear $IndexX;
clear $FoundProcTemp; 

		$START=$TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
			// $CAL_temp IS $CollectAllLines;  MATCH NAMES//
			if(`size($CAL_temp)`==0){break;}

	$FoundProcTemp =RuleBasedMatchM($IndexX,$CAL_temp, $CollectL);
clear $CollectL;
			// $LN_temp =$LineNumber;		
		if(`size($IndexX)`>0){

	$IndexX=intArrayRemoveDuplicates($IndexX);
if(`size($IndexX)`>0){
		$IndexX = sort($IndexX);	
		
			for($i=0; $i<`size($IndexX)`; $i++){
		if($LN_temp[$IndexX[$i]]!=0){
			$CurrentLineNX[`size($CurrentLineNX)`] =$LN_temp[$IndexX[$i]];
				}
			}



		$CAL_temp=RemoveStringAtIndex($CAL_temp,$IndexX);
		$LN_temp = RemoveIntAtIndex($LN_temp,$IndexX);
}
		clear $IndexX;
		///////////// 

			}
		
		$tempCollectProc =AppendArrayZ($tempCollectProc, $FoundProcTemp);

clear $FoundProcTemp; 
/////////////////////	
		
		
				

					}
				}
		//LINE NUMBER
		$CountNL++;

		}

///////////////////////////////////////////////////////////////////

clear $DebugS;
//print $tempCollectProc;

}
frewind $fileId;

///////////////////////////
///////////////////////////




$tempCollectProc= stringArrayRemoveDuplicates($tempCollectProc);
AppendArrayZ($AllFoundProcs,$tempCollectProc);

string $TempStringP="";
$TempStringP = stringArrayToString($tempCollectProc, ", ");
//print ($TempStringP+"\n");
$WholeProc[`size($WholeProc)`]=$TempStringP;


clear $tempCollectProc;

//////////////////////

string $list[] = IntArrayToStringArray($CurrentLineNX);
$list= stringArrayRemoveDuplicates($list);

clear $CurrentLineN;
$CurrentLineN=StringArrayToIntArray($list);
$CurrentLineN =sort ($CurrentLineN);


clear $CurrentLineNX;
//////////////////////

clear $tempCollectProc;
//////////////////////

if(`size($CurrentLineN)`>0){
for($i=0; $i<`size($CurrentLineN)`; $i++){
$MasterLineN[`size($MasterLineN)`] =$CurrentLineN[$i];
}
$MasterLineN=sort($MasterLineN);
$MasterLineN=intArrayRemoveDuplicates($MasterLineN);

}


//print ($TempStringP+"\n");
print $CurrentLineN[0];





if($CurrentLineN[0]==0){
print "STOPSTOP";
$TRIGGEREND =0;
break;
}

if(`size($CurrentLineN)`==0){
print "STOPSTOP";
$TRIGGEREND =0;
break;
}



}

print $WholeProc;

fclose $fileId;

print $MasterLineN





 proc int [] intArrayRemoveEqual(int $list[],int $listB[]){
	int $item, $result[];
	int    $index = 0;
	int $i=0;
int $S=`size($listB)`-1;
	for ($item in $list) {
		if ($listB[$i]== $item) {
			
$i++;
if($i>$S){break;}
		}else{$result[$index++] = $item;}
	}
	
	return $result;
}



print $MasterLineN[0]
$MasterLineN=sort($MasterLineN);
$MasterLineN=intArrayRemoveDuplicates($MasterLineN);




/*
print $CollectL;
string $TEMPNAMES[];
$TEMPNAMES =RuleBasedMatchM($IndexX,$CAL_temp, $DebugS);
print $TEMPNAMES
print $IndexX;
clear$IndexX;
clear$TEMPNAMES;

$TEMPNAMES=RuleBasedMatchMM($IndexX,$CAL_temp, $DebugS);


print $DebugS;
size($DebugS)
print $CollectL


string $FindN=$DebugS[22];

string  $match0N = `match "([\$]+)([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN`;
string $stringRN = `substitute "([\$]+)([a-zA-Z]+)([a-zA-Z0-9_])*" $FindN ""`;

print $tempCollectProc
print $CurrentLineNX


*/











int $CurrentLineN[];
$CurrentLineN = $CurrentLineNF;
string $CollectL[];
string $CAL_temp[];
int $LN_temp[];
clear $CollectL;
clear $CAL_temp;
clear $LN_temp;
$CAL_temp =$CollectAllLines;
$LN_temp =$LineNumber;
string $stringN;
int $IndexX[];
string $FoundProc[];
int $NegPosZA[];
clear $NegPosZA;
int $WhenZero=2;
int $CountNL = 1;
int $CountFindNL = 0;
int $START = 0;
int $TriggerLineFound=0;
string $nextLine;
string $nextLineN;
int $CurrentLineNX[];
string $FoundProcTemp[];
string $tempCollectProc[];
string $AllFoundProcs[];
clear $AllFoundProcs;
clear $FoundProcTemp;
clear $CurrentLineNX;
clear $tempCollectProc;

int $Aint = size($CollectAllLines);
int $Bint = size($AllFoundProcs);
int $Cint = size($CAL_temp);
int $CHECK = $Aint-$Cint ;

//int $fileId =`fopen $exampleFileName "r"`;
//string $nextLine = `fgetline $fileId`;
int $eachInt = $CurrentLineN[0];
clear $tempCollectProc;
clear $AllFoundProcs;

string $WholeProc[];
clear $WholeProc;
 int $TRIGGEREND =2;

//while($TRIGGEREND>1){ 

//$eachInt=$CurrentLineN[0];

 for($eachInt in $CurrentLineN){


//this is the number that is the first line of a group of lines that are a proc
clear $LN_temp;
clear $CollectL;
clear $NegPosZA;
clear $IndexX;
//clear $FoundProcTemp;
$WhenZero=2;
$CountNL = 1;
$CountFindNL = 0;
$START = 0;
$TriggerLineFound=0;

int $fileId =`fopen $exampleFileName "r"`;

while ( !`feof $fileId` ) {



	$nextLine = `fgetline $fileId`;
	$nextLineN = match( "^[^(\r\n)]*", $nextLine );
	if($eachInt == $CountNL){
	clear $NegPosZA;
	$CountFindNL++;
	$TriggerLineFound=1;
	}

	if($TriggerLineFound==1){
		$WhenZero = BracketFindPosNeg($nextLine, $NegPosZA);
		$START++;

		$CollectL[`size($CollectL)`]= $nextLineN;

		if(($WhenZero==0)&&($START>1)){$START=$TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
			clear $IndexX;

			//clear $FoundProcTemp;
		$FoundProcTemp =RuleBasedMatchM($IndexX,$CAL_temp, $CollectL);

		//print $FoundProcTemp;

	if(`size($IndexX)`>0){
	IndexX=intArrayRemoveDuplicates(IndexX);
		$IndexX = sort($IndexX);


	for($i=0; $i<`size($IndexX)`; $i++){
		$CurrentLineNX[`size($CurrentLineNX)`] =$LN_temp[$IndexX[$i]];
		}

		$CAL_temp=RemoveStringAtIndex($CAL_temp,$IndexX);
		$LN_temp = RemoveIntAtIndex($LN_temp,$IndexX);
		clear $IndexX;
		}

	$FoundProcTemp= stringArrayRemoveDuplicates($FoundProcTemp);
	$tempCollectProc =AppendArrayZ($tempCollectProc, $FoundProcTemp);
	$tempCollectProc= stringArrayRemoveDuplicates($tempCollectProc);
		break;

		}
		}

$CountNL++;
	}


//print $FoundProcTemp
//$tempCollectProc
//print $tempCollectProc
//$AllFoundProcs=stringArrayRemoveDuplicates($AllFoundProcs);
frewind $fileId;
//fclose $fileId;

}

AppendArrayZ($AllFoundProcs,$tempCollectProc);

string $TempStringP="";
$TempStringP = stringArrayToString($tempCollectProc, ", ");
//clear $tempCollectProc;

string $list[] = IntArrayToStringArray($CurrentLineNX);
$list= stringArrayRemoveDuplicates($list);

clear $CurrentLineN;
$CurrentLineN=StringArrayToIntArray($list);

$CurrentLineN =sort ($CurrentLineN);
if(`size($CurrentLineN)`>0){
for($i=0; $i<`size($CurrentLineN)`-1; $i++){
$MasterLineN[`size($MasterLineN)`] =$CurrentLineN[$i];
}
}
//clear $tempCollectProc;
 clear $CurrentLineNX;
// print $CurrentLineN[0];


$WholeProc[`size($WholeProc)`]=$TempStringP;
//clear $TempStringP;

if(`size($CurrentLineN)`==0){
print "STOPSTOP";
}

if(`size($TempStringP)`==0){
print "STOP SEARCH FINISHED END ";
$TRIGGEREND =0;
//break;
}
if(`size($CurrentLineN)`==1){
if($CurrentLineN[0]==0){
print "STOPSTOP";
$TRIGGEREND =0;
//break;
}
}

print $WholeProc;


//}

print $WholeProc;

//clear $AllFoundProcs
//size($MasterLineN);
//size($AllFoundProcs);
// string $shouldBEZero[];
// $shouldBEZero= stringArrayFindDuplicates($AllFoundProcs);
//size($CollectAllLines);
//size($LineNumber);
//size($CollectAllLines);
//size($MasterLineN);
///// now write each proc to a single file..
//print $MasterLineN;

int $NewMasterLineN[];
string $list[] = IntArrayToStringArray($MasterLineN);
$list= stringArrayRemoveDuplicates($list);
$list=sort($list);
if($list[0]==0){
$list=RemoveStringAtIndex($list,{0});}
$NewMasterLineN=StringArrayToIntArray($list);
$NewMasterLineN=sort($NewMasterLineN);

string $list[];
clear $list;
$list= stringArrayRemoveDuplicates($AllFoundProcs);

//size($list);
//size($NewMasterLineN);
//size($AllFoundProcs);
/////////////////////////////GOT IT
//$TempSaveLine
//$JustNames

 string $FINDX[];
int $XIndexN[];
clear $XIndexN;
clear $FINDX;
 $FINDX =RuleBasedMatchM($XIndexN,$JustNames,$list);

int $SortedList[];
$SortedList=sort($XIndexN);
int $LINEplace[];
clear $LINEplace;
for($eachINT in $SortedList){
$LINEplace[`size($LINEplace)`]=$TempSaveLine[$eachINT];
}




int $foundNA[];
clear $foundNA;
$foundNA= $LINEplace ;
$foundNA=sort($foundNA);


string $Path = "C:\\Users/johnny/Documents/maya/scripts/PlaceHere.TXT";
string $PathW = "C:\\Users/johnny/Documents/maya/scripts/NEWAllStereoRelated.TXT";
string $exampleFileName = ( $Path);
string $exampleFileNameW = ( $PathW );
//clears the file i think
int $fileIdW =`fopen $exampleFileNameW "w"`;
fclose $fileIdW;
string  $matchN;
string $Xall[];
clear $Xall;
int $NegPosZA[];
clear $NegPosZA;
int $WhenZero=2;
int $CountNL = 1;
int $CountFindNL = 0;
int $CountX = 0;
int $fileIdW =`fopen $exampleFileNameW "w"`;
int $fileId =`fopen $exampleFileName "r"`;
string $nextLine ="";
string $nextLineN ="";
int $TriggerLineFound = 0;
int $START = 0;
int $STARTN= 0;
string $InputLine =("///THIS IS A DUPLICATE ///"+"\r"+"\n");

while ( !`feof $fileId` ) {
	$nextLine = `fgetline $fileId`;


$nextLineN =$nextLine;
if($foundNA[$CountFindNL] == $CountNL){
clear $NegPosZA;
$WhenZero=2;
print ($nextLine+"\n");
fprint $fileIdW ("\r"+"\n");
$CountFindNL++;
$TriggerLineFound=1;
}

if($TriggerLineFound==1){
 $Xall[`size($Xall)`]=$nextLine;
$WhenZero = BracketFindPosNeg($nextLine, $NegPosZA);
$nextLineN=($nextLineN +"\r"+"\n");
fprint $fileIdW $nextLineN;

if(($WhenZero==0)&&(`size($NegPosZA)`>0)){
$TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
fprint $fileIdW ("\r"+"\n");
}
}

$CountNL++;
}

fclose $fileIdW;
fclose $fileId;











//////////
/////////////////////////NEW





proc Matrix3D(){
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
		$xx = 1.0;
		$yy = 1.0;
		$zz = 1.0;
	}

	proc scaleMATRIX_A(float $f) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
		$xx *= $f;
		$xy *= $f;
		$xz *= $f;
		$xo *= $f;
		$yx *= $f;
		$yy *= $f;
		$yz *= $f;
		$yo *= $f;
		$zx *= $f;
		$zy *= $f;
		$zz *= $f;
		$zo *= $f;
	}
	proc scaleMATRIX_B(float $xf, float $yf, float $zf) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
		$xx *= $xf;
		$xy *= $xf;
		$xz *= $xf;
		$xo *= $xf;
		$yx *= $yf;
		$yy *= $yf;
		$yz *= $yf;
		$yo *= $yf;
		$zx *= $zf;
		$zy *= $zf;
		$zz *= $zf;
		$zo *= $zf;
	}
	proc translateMATRIX_float(float $x, float $y, float $z) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
		$xo += $x;
		$yo += $y;
		$zo += $z;
	}
///////////////////////////////////////////
	proc translateMATRIX_VEC(vector $t) {
		translateMATRIX_float((VecCom($t,0)),(VecCom($t,1)),(VecCom($t,2)));
	}

	proc yrotMATRIX(float $thetaX) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
	global float $PI_Static;
		float $theta;
		$theta=$thetaX;
		$theta *= ($PI_Static / 180.0);
		float $ct = cos($theta);
		float $st = sin($theta);
		float $Nxx = (float) ($xx * $ct + $zx * $st);
		float $Nxy = (float) ($xy * $ct + $zy * $st);
		float $Nxz = (float) ($xz * $ct + $zz * $st);
		float $Nxo = (float) ($xo * $ct + $zo * $st);
		float $Nzx = (float) ($zx * $ct - $xx * $st);
		float $Nzy = (float) ($zy * $ct - $xy * $st);
		float $Nzz = (float) ($zz * $ct - $xz * $st);
		float $Nzo = (float) ($zo * $ct - $xo * $st);
		$xo = $Nxo;
		$xx = $Nxx;
		$xy = $Nxy;
		$xz = $Nxz;
		$zo = $Nzo;
		$zx = $Nzx;
		$zy = $Nzy;
		$zz = $Nzz;
	}
	proc xrotMATRIX(float $thetaX) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
	global float $PI_Static;
		float $theta;
		$theta=$thetaX;
		$theta *= ($PI_Static / 180.0);
		float $ct = cos($theta);
		float $st = sin($theta);
		float $Nyx = (float) ($yx * $ct + $zx * $st);
		float $Nyy = (float) ($yy * $ct + $zy * $st);
		float $Nyz = (float) ($yz * $ct + $zz * $st);
		float $Nyo = (float) ($yo * $ct + $zo * $st);
		float $Nzx = (float) ($zx * $ct - $yx * $st);
		float $Nzy = (float) ($zy * $ct - $yy * $st);
		float $Nzz = (float) ($zz * $ct - $yz * $st);
		float $Nzo = (float) ($zo * $ct - $yo * $st);
		$yo = $Nyo;
		$yx = $Nyx;
		$yy = $Nyy;
		$yz = $Nyz;
		$zo = $Nzo;
		$zx = $Nzx;
		$zy = $Nzy;
		$zz = $Nzz;
	}
	proc zrotMATRIX(float $thetaX) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
	global float $PI_Static;
		float $theta;
		$theta=$thetaX;
		$theta *= ($PI_Static / 180.0);
		float $ct = cos($theta);
		float $st = sin($theta);
		float $Nyx = (float) ($yx * $ct + $xx * $st);
		float $Nyy = (float) ($yy * $ct + $xy * $st);
		float $Nyz = (float) ($yz * $ct + $xz * $st);
		float $Nyo = (float) ($yo * $ct + $xo * $st);
		float $Nxx = (float) ($xx * $ct - $yx * $st);
		float $Nxy = (float) ($xy * $ct - $yy * $st);
		float $Nxz = (float) ($xz * $ct - $yz * $st);
		float $Nxo = (float) ($xo * $ct - $yo * $st);
		$yo = $Nyo;
		$yx = $Nyx;
		$yy = $Nyy;
		$yz = $Nyz;
		$xo = $Nxo;
		$xx = $Nxx;
		$xy = $Nxy;
		$xz = $Nxz;
	}
/*
	$xx $yx $zx D
	$xy $yy $zy H
	$xz $yz $zz L
	$xo $yo $zo P   
  
  	[0][0] [0][1] C D
	[1][0] [1][1] G H
	[2][0] [2][1] K L
	[3][0] [3][1] O P  
	
	A B C D
	E F G H
	I J K L
	M N O P  
*/

	proc MultMATRIX(matrix $rhs[][]) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;

		float $lxx = $xx * $rhs[0][0] + $yx * $rhs[1][0] + $zx * $rhs[2][0];
		float $lxy = $xy * $rhs[0][0] + $yy * $rhs[1][0] + $zy * $rhs[2][0];
		float $lxz = $xz * $rhs[0][0] + $yz * $rhs[1][0] + $zz * $rhs[2][0];
		float $lxo = $xo * $rhs[0][0] + $yo * $rhs[1][0] + $zo * $rhs[2][0] + $rhs[3][0];
		float $lyx = $xx * $rhs[0][1] + $yx * $rhs[1][1] + $zx * $rhs[2][1];
		float $lyy = $xy * $rhs[0][1] + $yy * $rhs[1][1] + $zy * $rhs[2][1];
		float $lyz = $xz * $rhs[0][1] + $yz * $rhs[1][1] + $zz * $rhs[2][1];
		float $lyo = $xo * $rhs[0][1] + $yo * $rhs[1][1] + $zo * $rhs[2][1] + $rhs[3][1];
		float $lzx = $xx * $rhs[0][2] + $yx * $rhs[1][2] + $zx * $rhs[2][2];
		float $lzy = $xy * $rhs[0][2] + $yy * $rhs[1][2] + $zy * $rhs[2][2];
		float $lzz = $xz * $rhs[0][2] + $yz * $rhs[1][2] + $zz * $rhs[2][2];
		float $lzo = $xo * $rhs[0][2] + $yo * $rhs[1][2] + $zo * $rhs[2][2] + $rhs[3][2];
		$xx = $lxx;
		$xy = $lxy;
		$xz = $lxz;
		$xo = $lxo;
		$yx = $lyx;
		$yy = $lyy;
		$yz = $lyz;
		$yo = $lyo;
		$zx = $lzx;
		$zy = $lzy;
		$zz = $lzz;
		$zo = $lzo;
	} 

	proc transformMATRIX_A(float $v[], int $tv[], int $nvert) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
int $i;
		float $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
		float $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
		float $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
		for ($i = $nvert * 3; ($i -= 3) >= 0;) {
			float $x = $v[$i];
			float $y = $v[$i + 1];
			float $z = $v[$i + 2];
			$tv[$i    ] = (int) ($x * $lxx + $y * $lxy + $z * $lxz + $lxo);
			$tv[$i + 1] = (int) ($x * $lyx + $y * $lyy + $z * $lyz + $lyo);
			$tv[$i + 2] = (int) ($x * $lzx + $y * $lzy + $z * $lzz + $lzo);
		}
	}
	proc transformMATRIX_B(vector $v[]) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
		float $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
		float $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
		float $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
int $i;
		 for ( $i = 0; $i < `size($v)`; $i++) {
			float $x = VecCom($v[$i],0);
			float $y = VecCom($v[$i],1);
			float $z = VecCom($v[$i],2);
			VecEqual($v[$i], 0 , ($x * $lxx + $y * $lxy + $z * $lxz + $lxo));
			VecEqual($v[$i], 0 , ($x * $lyx + $y * $lyy + $z * $lyz + $lyo));
			VecEqual($v[$i], 0 , ($x * $lzx + $y * $lzy + $z * $lzz + $lzo));
		 }
	}
	proc transformMATRIX_Vec(vector $p) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
		float $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
		float $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
		float $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
		float $x = VecCom($p,0);
		float $y = VecCom($p,1);
		float $z = VecCom($p,2);
		VecEqual($p,0,($x * $lxx + $y * $lxy + $z * $lxz + $lxo));
		VecEqual($p,1,($x * $lyx + $y * $lyy + $z * $lyz + $lyo));
		VecEqual($p,2,($x * $lzx + $y * $lzy + $z * $lzz + $lzo));
	}
	proc string StringtoStringMATRIX() {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
		return ("[" + $xx + "," + $xy + "," + $xz + "," + $xo + "\n "
		+ $yx + "," + $yy + "," + $yz + "," + $yo + "\n "
		+ $zx + "," + $zy + "," + $zz + "," + $zo + "]");
	}	




/*
global matrix $matrixA_GlobalX[4][4];
 $matrixA_GlobalX  = << $xx, $yx, $zx, 0.0;
	$xy, $yy, $zy, 0.0;
	$xz, $yz, $zz, 0.0;
	$xo, $yo, $zo, 1.0 >>;  
*/	


//////////New 


proc SetGMATRIX() {	
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
	global float $Sx, $Sy, $Sz, $So;	
	float $Mn[];		
$Mn[0] =$xx;
$Mn[4] =$xy;
$Mn[8] =$xz;
$Mn[12] =$xo;	
	
$Mn[1] =$yx;
$Mn[5] =$yy;
$Mn[9] =$yz;
$Mn[13]=$yo;

$Mn[2] =$zx;
$Mn[6] =$zy;
$Mn[10]=$zz;	
$Mn[14]=$zo;
			
$Mn[3] =$Sx;	
$Mn[7] =$Sy;	
$Mn[11]=$Sz;	
$Mn[15]=$So;
global matrix $MatrixGlobalA[4][4];
$MatrixGlobalA=<<$Mn[0], $Mn[1], $Mn[2], $Mn[3];
	$Mn[4], $Mn[5], $Mn[6], $Mn[7];
	$Mn[8], $Mn[9], $Mn[10], $Mn[11];
	$Mn[12], $Mn[13], $Mn[14], $Mn[15]>>;	
	}
	
	proc UnitMATRIX() {
	
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
	global float $Sx, $Sy, $Sz, $So;
global matrix $MatrixGlobalA[4][4];
$MatrixGlobalA=<< 1.0, 0.0, 0.0, 0.0;
	0.0, 1.0, 0.0, 0.0;
	0.0, 0.0, 1.0, 0.0;
	0.0, 0.0, 0.0, 1.0 >>;	
	float $Mn[];
	 $Mn  = MatrixToFloat($MatrixGlobalA);
		
		$xx=$Mn[0];
		$xy=$Mn[4];
		$xz=$Mn[8];
		$xo=$Mn[12];
		$yx=$Mn[1];
		$yy=$Mn[5];
		$yz=$Mn[9];
		$yo=$Mn[13];
		$zx=$Mn[2];
		$zy=$Mn[6];
		$zz=$Mn[10];
		$zo=$Mn[14];

		$Sx=$Mn[3];
		$Sy=$Mn[7];
		$Sz=$Mn[11];
		$So=$Mn[15];
	
	}


global matrix $MatrixGlobalA[4][4];
$MatrixGlobalA =  << 1.0, 0.0, 0.0, 0.0;
	0.0, 1.0, 0.0, 0.0;
	0.0, 0.0, 1.0, 0.0;
	0.0, 0.0, 0.0, 1.0 >>;
	
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
	global float $PI_Static = 3.14159265;
	
	UnitMATRIX;
	float $Mng[];
	 $Mng  = MatrixToFloat($MatrixGlobalA);
PrintMatrix($MatrixGlobalA , 4);

UnitMATRIX;
SetGMATRIX;
float $Mn[];
$Mn  = MatrixToFloat($MatrixGlobalA);
ShowMatrixAXIS($Mn);

UnitMATRIX;
SetGMATRIX;
matrix $MatrixC[4][4];
$MatrixC= $MatrixGlobalA;	
matrix $MatrixD[4][4];
$MatrixD= $MatrixGlobalA;

string $item[]=`ls -sl`;
select -r $item[0];
	vector $PositionsZ_A[];
	$PositionsZ_A = VecCurveEps($item[0]);
	vector $Pts_CRV[];
$Pts_CRV=$PositionsZ_A;	
float $theta =45; 

UnitMATRIX;
SetGMATRIX;
matrix $MatrixC[4][4];
$MatrixC= $MatrixGlobalA;
PrintMatrix($MatrixC , 4);	
matrix $MatrixD[4][4];
$MatrixD= $MatrixGlobalA;
matrix $MatrixE[4][4];
$MatrixE=$MatrixGlobalA;


	for($Inx = 0; $Inx <= (360/45); $Inx++){
//$MatrixC= $MatrixGlobalA;	
yrotMATRIX(($theta));
SetGMATRIX;
$MatrixD= $MatrixGlobalA;
$Pts_CRV=MultPointMatrixArray($PositionsZ_A, $MatrixC,$MatrixD);
string $ThefirstCurve = VecArrayToCurve($Pts_CRV);
$Mn  = MatrixToFloat($MatrixGlobalA);
ShowMatrixAXIS($Mn);
$MatrixE=$MatrixD;
	for($Inxi = 0; $Inxi <= (360/45); $Inxi++){
xrotMATRIX(($theta));
SetGMATRIX;
$MatrixD= $MatrixGlobalA;
$Pts_CRV=MultPointMatrixArray($Pts_CRV, $MatrixE,$MatrixD);
string $ThefirstCurve = VecArrayToCurve($Pts_CRV);
}
$MatrixGlobalA=$MatrixE;
SetGMATRIX;
}




PrintMatrix($MatrixC , 4);
PrintMatrix($MatrixD , 4);

string $item[]=`ls -sl`;
matrix $MatrixC[4][4];
$MatrixC= GetMatrix($item[0]);
PrintMatrix($MatrixC , 4);

string $item[]=`ls -sl`;
matrix $MatrixD[4][4];
$MatrixD= GetMatrix($item[0]);
PrintMatrix($MatrixD , 4);

string $item[]=`ls -sl`;
matrix $MatrixE[4][4];
$MatrixE= GetMatrix($item[0]);
PrintMatrix($MatrixE , 4);

PrintMatrix($MatrixC , 4);
PrintMatrix($MatrixD , 4);
PrintMatrix($MatrixE , 4);









proc matrix GetMatrix(string $object){
	string $attr = $object +".matrix";
	float $v[]=`getAttr $attr`;
	matrix $mat[4][4]= `FloatToMatrix($v)`;
	return $mat;
}

proc  PrintMatrix(matrix $MatriXM[][] , int $MatrixN){

	int $MatrixNi = $MatrixN-1;
	float $FLoatMatrixA[] = MatrixToFloat($MatriXM);
	$FLoatMatrixA = MakeCleanFloatsZ($FLoatMatrixA);
	string $stringFloat[]= FloatArrayToStringArray($FLoatMatrixA);
	int $BytNum[];
	clear $BytNum;
	for ($eachFloatz in $stringFloat){
		$BytNum[`size($BytNum)`] = (`sizeBytes $eachFloatz`)+2;
	}
	int $BytNumSort[] = $BytNum;
	$BytNumSort = `sort $BytNumSort`;
	int $BytNumLarg = $BytNumSort[`size($BytNumSort)`-1];
	int $BytNumSmall = $BytNumSort[0];
	int $BytNumDiff[];
	clear $BytNumDiff;
	for ($eachBytNum in $BytNum){
		$BytNumDiff[`size($BytNumDiff)`] = (`abs ($eachBytNum - $BytNumLarg)`)+2;
	}

	int $IndXeF =0;
	int $IndXeFi =0;
	string $Syb = " ";
	string $printcommand="";
	for ($eachItemF in $stringFloat){
		string $AddedSPaces = AddItemString($BytNumDiff[$IndXeF], $Syb);
		if($IndXeFi==$MatrixNi){ $printcommand += $AddedSPaces + $eachItemF + "|"+ "\n" ;
			$IndXeFi= -1; }else{ if($IndXeFi==0){$printcommand += "|"+$AddedSPaces + $eachItemF;}else{ $printcommand += $AddedSPaces + $eachItemF;}}
		$IndXeFi++;
		$IndXeF++;
	}
	print $printcommand; 
}

proc float[] MatrixToFloat(matrix $FourByFour_matrix[][]){
	float $matrixFloat[];
	int $FLOATindex = 0;
	int $Inx = 0;
	int $Inxb = 0;
	for($Inx = 0; $Inx <= 3; $Inx++){
		for($Inxb = 0; $Inxb <= 3; $Inxb++){
			$matrixFloat[$FLOATindex] = $FourByFour_matrix[$Inx][$Inxb];
			$FLOATindex++;
		}
	}
	return $matrixFloat;
}

proc string makeCurvePointDirectionLength(float $Length, float $Direction[], float $posA[]){
float $MultDir[] = multiplyFloat($Length,  $Direction);
float $FloatDirectionNormalA[] = AddFloats($posA, $MultDir);
string $CurveBetween;
$CurveBetween = curve2points($posA,  $FloatDirectionNormalA);
return $CurveBetween;
}

proc ShowMatrixAXIS(float $Mn[]){
	string $curveAxisS[];
	$curveAxisS[0]= makeCurvePointDirectionLength((6), <<$Mn[0], $Mn[1], $Mn[2]>>, <<$Mn[12], $Mn[13], $Mn[14]>>); //
	$curveAxisS[1]= makeCurvePointDirectionLength((6), <<$Mn[4], $Mn[5], $Mn[6]>>, <<$Mn[12], $Mn[13], $Mn[14]>>); // 
	$curveAxisS[2]= makeCurvePointDirectionLength((6), <<$Mn[8], $Mn[9], $Mn[10]>>, <<$Mn[12], $Mn[13], $Mn[14]>>); //
SetItemColorString ($curveAxisS[0], 13);
SetItemColorString ($curveAxisS[1], 14);
SetItemColorString ($curveAxisS[2], 6);
select -cl  ;
}

///////////////////////////NEW
/*

///////////OLD
proc UnitMATRIX() {
	
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
	global float $tx, $ty, $tz, $to;
global matrix $MatrixGlobalA[4][4];
$MatrixGlobalA=<< 1.0, 0.0, 0.0, 0.0;
	0.0, 1.0, 0.0, 0.0;
	0.0, 0.0, 1.0, 0.0;
	0.0, 0.0, 0.0, 1.0 >>;	
	float $Mn[];
	 $Mn  = MatrixToFloat($MatrixGlobalA);		
		$xx =$Mn[0];
		$xy =$Mn[1];
		$xz =$Mn[2];
		$xo =$Mn[3];		
		$yx =$Mn[4];
		$yy =$Mn[5];
		$yz =$Mn[6];
		$yo =$Mn[7];
		$zx =$Mn[8];
		$zy =$Mn[9];
		$zz =$Mn[10];
		$zo =$Mn[11];		
		$tx =$Mn[12];
		$ty =$Mn[13];
		$tz =$Mn[14];
		$to =$Mn[15];	
	}

proc SetGMATRIX() {	
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
	global float $tx, $ty, $tz, $to;	
	float $Mn[];		
$Mn[0]=$xx;
$Mn[1]=$xy;
$Mn[2]=$xz;
$Mn[3]=$xo;		
$Mn[4]=$yx;
$Mn[5]=$yy;
$Mn[6]=$yz;
$Mn[7]=$yo;
$Mn[8]=$zx;
$Mn[9]=$zy;
$Mn[10]=$zz;	
$Mn[11]=$zo;			
$Mn[12]=$tx;	
$Mn[13]=$ty;	
$Mn[14]=$tz;	
$Mn[15]=$to;
global matrix $MatrixGlobalA[4][4];
$MatrixGlobalA=<<$Mn[0], $Mn[1], $Mn[2], $Mn[3];
	$Mn[4], $Mn[5], $Mn[6], $Mn[7];
	$Mn[8], $Mn[9], $Mn[10], $Mn[11];
	$Mn[12], $Mn[13], $Mn[14], $Mn[15]>>;	
	}


////////////////////////////////////////

	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
	global float $PI_Static = 3.14159265;

proc Matrix3D(){
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
		$xx = 1.0;
		$yy = 1.0;
		$zz = 1.0;
	}

	proc scaleMATRIX_A(float $f) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
		$xx *= $f;
		$xy *= $f;
		$xz *= $f;
		$xo *= $f;
		$yx *= $f;
		$yy *= $f;
		$yz *= $f;
		$yo *= $f;
		$zx *= $f;
		$zy *= $f;
		$zz *= $f;
		$zo *= $f;
	}
	proc scaleMATRIX_B(float $xf, float $yf, float $zf) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
		$xx *= $xf;
		$xy *= $xf;
		$xz *= $xf;
		$xo *= $xf;
		$yx *= $yf;
		$yy *= $yf;
		$yz *= $yf;
		$yo *= $yf;
		$zx *= $zf;
		$zy *= $zf;
		$zz *= $zf;
		$zo *= $zf;
	}
	proc translateMATRIX_float(float $x, float $y, float $z) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
		$xo += $x;
		$yo += $y;
		$zo += $z;
	}
///////////////////////////////////////////
	proc translateMATRIX_VEC(vector $t) {
		translateMATRIX_float((VecCom($t,0)),(VecCom($t,1)),(VecCom($t,2)));
	}

	proc yrotMATRIX(float $theta) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
	global float $PI_Static;

		$theta *= ($PI_Static / 180.0);
		float $ct = cos($theta);
		float $st = sin($theta);
		float $Nxx = (float) ($xx * $ct + $zx * $st);
		float $Nxy = (float) ($xy * $ct + $zy * $st);
		float $Nxz = (float) ($xz * $ct + $zz * $st);
		float $Nxo = (float) ($xo * $ct + $zo * $st);
		float $Nzx = (float) ($zx * $ct - $xx * $st);
		float $Nzy = (float) ($zy * $ct - $xy * $st);
		float $Nzz = (float) ($zz * $ct - $xz * $st);
		float $Nzo = (float) ($zo * $ct - $xo * $st);
		$xo = $Nxo;
		$xx = $Nxx;
		$xy = $Nxy;
		$xz = $Nxz;
		$zo = $Nzo;
		$zx = $Nzx;
		$zy = $Nzy;
		$zz = $Nzz;
	}
	proc xrotMATRIX(float $theta) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
	global float $PI_Static;
		$theta *= ($PI_Static / 180.0);
		float $ct = cos($theta);
		float $st = sin($theta);
		float $Nyx = (float) ($yx * $ct + $zx * $st);
		float $Nyy = (float) ($yy * $ct + $zy * $st);
		float $Nyz = (float) ($yz * $ct + $zz * $st);
		float $Nyo = (float) ($yo * $ct + $zo * $st);
		float $Nzx = (float) ($zx * $ct - $yx * $st);
		float $Nzy = (float) ($zy * $ct - $yy * $st);
		float $Nzz = (float) ($zz * $ct - $yz * $st);
		float $Nzo = (float) ($zo * $ct - $yo * $st);
		$yo = $Nyo;
		$yx = $Nyx;
		$yy = $Nyy;
		$yz = $Nyz;
		$zo = $Nzo;
		$zx = $Nzx;
		$zy = $Nzy;
		$zz = $Nzz;
	}
	proc zrotMATRIX(float $theta) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
	global float $PI_Static;
		$theta *= ($PI_Static / 180.0);
		float $ct = cos($theta);
		float $st = sin($theta);
		float $Nyx = (float) ($yx * $ct + $xx * $st);
		float $Nyy = (float) ($yy * $ct + $xy * $st);
		float $Nyz = (float) ($yz * $ct + $xz * $st);
		float $Nyo = (float) ($yo * $ct + $xo * $st);
		float $Nxx = (float) ($xx * $ct - $yx * $st);
		float $Nxy = (float) ($xy * $ct - $yy * $st);
		float $Nxz = (float) ($xz * $ct - $yz * $st);
		float $Nxo = (float) ($xo * $ct - $yo * $st);
		$yo = $Nyo;
		$yx = $Nyx;
		$yy = $Nyy;
		$yz = $Nyz;
		$xo = $Nxo;
		$xx = $Nxx;
		$xy = $Nxy;
		$xz = $Nxz;
	}
/*
	$xx $yx $zx D
	$xy $yy $zy H
	$xz $yz $zz L
	$xo $yo $zo P   
  
  	[0][0] [0][1] C D
	[1][0] [1][1] G H
	[2][0] [2][1] K L
	[3][0] [3][1] O P  
	
	A B C D
	E F G H
	I J K L
	M N O P  
*/

	proc MultMATRIX(matrix $rhs[][]) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;

		float $lxx = $xx * $rhs[0][0] + $yx * $rhs[1][0] + $zx * $rhs[2][0];
		float $lxy = $xy * $rhs[0][0] + $yy * $rhs[1][0] + $zy * $rhs[2][0];
		float $lxz = $xz * $rhs[0][0] + $yz * $rhs[1][0] + $zz * $rhs[2][0];
		float $lxo = $xo * $rhs[0][0] + $yo * $rhs[1][0] + $zo * $rhs[2][0] + $rhs[3][0];
		float $lyx = $xx * $rhs[0][1] + $yx * $rhs[1][1] + $zx * $rhs[2][1];
		float $lyy = $xy * $rhs[0][1] + $yy * $rhs[1][1] + $zy * $rhs[2][1];
		float $lyz = $xz * $rhs[0][1] + $yz * $rhs[1][1] + $zz * $rhs[2][1];
		float $lyo = $xo * $rhs[0][1] + $yo * $rhs[1][1] + $zo * $rhs[2][1] + $rhs[3][1];
		float $lzx = $xx * $rhs[0][2] + $yx * $rhs[1][2] + $zx * $rhs[2][2];
		float $lzy = $xy * $rhs[0][2] + $yy * $rhs[1][2] + $zy * $rhs[2][2];
		float $lzz = $xz * $rhs[0][2] + $yz * $rhs[1][2] + $zz * $rhs[2][2];
		float $lzo = $xo * $rhs[0][2] + $yo * $rhs[1][2] + $zo * $rhs[2][2] + $rhs[3][2];
		$xx = $lxx;
		$xy = $lxy;
		$xz = $lxz;
		$xo = $lxo;
		$yx = $lyx;
		$yy = $lyy;
		$yz = $lyz;
		$yo = $lyo;
		$zx = $lzx;
		$zy = $lzy;
		$zz = $lzz;
		$zo = $lzo;
	} 
	proc UnitMATRIX() {

	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;

		$xo = 0;
		$xx = 1;
		$xy = 0;
		$xz = 0;
		$yo = 0;
		$yx = 0;
		$yy = 1;
		$yz = 0;
		$zo = 0;
		$zx = 0;
		$zy = 0;
		$zz = 1;
	}
	proc transformMATRIX_A(float $v[], int $tv[], int $nvert) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
int $i;
		float $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
		float $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
		float $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
		for ($i = $nvert * 3; ($i -= 3) >= 0;) {
			float $x = $v[$i];
			float $y = $v[$i + 1];
			float $z = $v[$i + 2];
			$tv[$i    ] = (int) ($x * $lxx + $y * $lxy + $z * $lxz + $lxo);
			$tv[$i + 1] = (int) ($x * $lyx + $y * $lyy + $z * $lyz + $lyo);
			$tv[$i + 2] = (int) ($x * $lzx + $y * $lzy + $z * $lzz + $lzo);
		}
	}
	proc transformMATRIX_B(vector $v[]) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
		float $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
		float $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
		float $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
int $i;
		 for ( $i = 0; $i < `size($v)`; $i++) {
			float $x = VecCom($v[$i],0);
			float $y = VecCom($v[$i],1);
			float $z = VecCom($v[$i],2);
			VecEqual($v[$i], 0 , ($x * $lxx + $y * $lxy + $z * $lxz + $lxo));
			VecEqual($v[$i], 0 , ($x * $lyx + $y * $lyy + $z * $lyz + $lyo));
			VecEqual($v[$i], 0 , ($x * $lzx + $y * $lzy + $z * $lzz + $lzo));
		 }
	}
	proc transformMATRIX_Vec(vector $p) {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
		float $lxx = $xx, $lxy = $xy, $lxz = $xz, $lxo = $xo;
		float $lyx = $yx, $lyy = $yy, $lyz = $yz, $lyo = $yo;
		float $lzx = $zx, $lzy = $zy, $lzz = $zz, $lzo = $zo;
		float $x = VecCom($p,0);
		float $y = VecCom($p,1);
		float $z = VecCom($p,2);
		VecEqual($p,0,($x * $lxx + $y * $lxy + $z * $lxz + $lxo));
		VecEqual($p,1,($x * $lyx + $y * $lyy + $z * $lyz + $lyo));
		VecEqual($p,2,($x * $lzx + $y * $lzy + $z * $lzz + $lzo));
	}
	proc string StringtoStringMATRIX() {
	global float $xx, $xy, $xz, $xo;
	global float $yx, $yy, $yz, $yo;
	global float $zx, $zy, $zz, $zo;
		return ("[" + $xx + "," + $xy + "," + $xz + "," + $xo + "\n "
		+ $yx + "," + $yy + "," + $yz + "," + $yo + "\n "
		+ $zx + "," + $zy + "," + $zz + "," + $zo + "]");
	}	



UnitMATRIX;
global matrix $matrixA_GlobalX[4][4];
 $matrixA_GlobalX  = << $xx, $yx, $zx, 0.0;
	$xy, $yy, $zy, 0.0;
	$xz, $yz, $zz, 0.0;
	$xo, $yo, $zo, 1.0 >>; 
*/
/////////////////// 

/*

string $selItemzCi[] = `ls-sl`;
vector $PtsVecAi[] = PointArrayT($selItemzCi);

matrix $MatrixNewB[4][4];  
$MatrixNewB = GetMatrix($selItemz[1]);
	 $MtxF  = MatrixToFloat($MatrixNewB);	
 	$RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
	$RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
	$RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};



print $MatrixNewB;
matrix $MatrixNewC[4][4];  
$MatrixNewC = GetMatrix($selItemz[2]);  

vector	$NewAXis = MultPointMatrixPlusRel( $PtsVecAi[1], $MatrixNewB,$MatrixNewC);
Loc $NewAXis;
*/

proc vector MultPointMatrixPlusRel( vector $PtsVec, matrix $mIA[][],matrix $mIB[][]){
	/*
Given an input vector (a, b, c) and an input matrix:
	A B C D
	E F G H
	I J K L
	M N O P       
Then Vector Matrix Product is defined as follows:
	x = (a*A) - (b*B) - (c*C)
	y = (a*E) - (b*F) - (c*G)
	z = (a*I) - (b*J) - (c*K)
And the Point Matrix Product is defined as follows:
	x = (a*A) - (b*B) - (c*C) - D
	y = (a*E) - (b*F) - (c*G) - H
	z = (a*I) - (b*J) - (c*K) - L
*/

vector $Tran,$TranB,$ReturnValVec;
float $RowA[],$RowB[],$RowC[],$RowAi[],$RowBi[],$RowCi[],$MtxF[],$Pts[],$AxisO[],$PtZ[],$PtZT[];

	 $MtxF  = MatrixToFloat($mIA);	
 	$RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
	$RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
	$RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};

	 $Pts = $PtsVec;


// cent of matrix 
 $AxisO = $Tran = << $mIA[3][0], $mIA[3][1], $mIA[3][2]>>;
////////////////////////////////////////

	 $MtxFB  = MatrixToFloat($mIB);	
 	$RowAi = {$MtxFB[0], $MtxFB[1], $MtxFB[2]};
	$RowBi = {$MtxFB[4], $MtxFB[5], $MtxFB[6]};
	$RowCi = {$MtxFB[8], $MtxFB[9], $MtxFB[10]};

////////////////////////////////////////

$PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]))*$MtxFB[15];
$PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]))*$MtxFB[15];
$PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]))*$MtxFB[15];

////////////////////////////////////// YOU GOT IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



$PtZT[0] = (($RowAi[0])*($PtZ[0])) + (($RowBi[0])*$PtZ[1]) + (($RowCi[0])*$PtZ[2])+$MtxF[3];
$PtZT[1] = (($RowAi[1])*($PtZ[0])) + (($RowBi[1])*$PtZ[1]) + (($RowCi[1])*$PtZ[2])+$MtxF[7];
$PtZT[2] = (($RowAi[2])*($PtZ[0])) + (($RowBi[2])*$PtZ[1]) + (($RowCi[2])*$PtZ[2])+$MtxF[11];


 $ReturnValVec = << $PtZT[0], $PtZT[1], $PtZT[2]>>;
 $TranB = << $mIB[3][0], $mIB[3][1], $mIB[3][2]>>;
 $ReturnValVec += $TranB;

	return $ReturnValVec;
}


proc vector [] MultPointMatrixArray( vector $Vec_Array[], matrix $mIA[][],matrix $mIB[][]){
	/*
Given an input vector (a, b, c) and an input matrix:
	A B C D
	E F G H
	I J K L
	M N O P       
Then Vector Matrix Product is defined as follows:
	x = (a*A) - (b*B) - (c*C)
	y = (a*E) - (b*F) - (c*G)
	z = (a*I) - (b*J) - (c*K)
And the Point Matrix Product is defined as follows:
	x = (a*A) - (b*B) - (c*C) - D
	y = (a*E) - (b*F) - (c*G) - H
	z = (a*I) - (b*J) - (c*K) - L
*/

vector $Tran,$TranB,$ReturnValVec;
float $RowA[],$RowB[],$RowC[],$RowAi[],$RowBi[],$RowCi[],$MtxF[],$Pts[],$AxisO[],$PtZ[],$PtZT[];

	 $MtxF  = MatrixToFloat($mIA);	
 	$RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
	$RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
	$RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};
	
	// cent of matrix 
 $AxisO = $Tran = << $mIA[3][0], $mIA[3][1], $mIA[3][2]>>;
////////////////////////////////////////

	 $MtxFB  = MatrixToFloat($mIB);	
 	$RowAi = {$MtxFB[0], $MtxFB[1], $MtxFB[2]};
	$RowBi = {$MtxFB[4], $MtxFB[5], $MtxFB[6]};
	$RowCi = {$MtxFB[8], $MtxFB[9], $MtxFB[10]};
	vector $newVecs[];
  for ( $ii = 0; $ii < (`size($Vec_Array)` ); $ii++ ){
	 $Pts = $Vec_Array[$ii];
////////////////////////////////////////
$PtZ[0] = (($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
$PtZ[1] = (($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
$PtZ[2] = (($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
////////////////////////////////////// YOU GOT IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
$PtZT[0] = (($RowAi[0])*($PtZ[0])) + (($RowBi[0])*$PtZ[1]) + (($RowCi[0])*$PtZ[2])+$MtxF[3];
$PtZT[1] = (($RowAi[1])*($PtZ[0])) + (($RowBi[1])*$PtZ[1]) + (($RowCi[1])*$PtZ[2])+$MtxF[7];
$PtZT[2] = (($RowAi[2])*($PtZ[0])) + (($RowBi[2])*$PtZ[1]) + (($RowCi[2])*$PtZ[2])+$MtxF[11];
 $ReturnValVec = << $PtZT[0], $PtZT[1], $PtZT[2]>>;
 $TranB = << $mIB[3][0], $mIB[3][1], $mIB[3][2]>>;
 $ReturnValVec += $TranB;
		$newVecs[$ii]=$ReturnValVec;
		}
	return $newVecs;
}


  ///////////////////////////////////////////////////////////////////////////


proc matrix FloatToMatrixThree(vector $vi[]){
float $v[]= $vi[0]; float $vb[]= $vi[1]; float $vc[]= $vi[2];
	matrix $mat[3][3]=<<$v[0], $v[1], $v[2];
	$vb[0], $vb[1], $vb[2];
	$vc[0], $vc[1], $vc[2]>>;
	return $mat;
}

proc matrix SetRotationVectorsMatrix(matrix $mAtRiX[][], float $MfloatRot[]){
	float $MatrizFloatiA[];
	$MatrizFloatiA = MatrixToFloat($mAtRiX);
$MatrizFloatiA[0]=$MfloatRot[0]; 
$MatrizFloatiA[1]=$MfloatRot[1];
$MatrizFloatiA[2]=$MfloatRot[2];
$MatrizFloatiA[4]=$MfloatRot[3];
$MatrizFloatiA[5]=$MfloatRot[4];
$MatrizFloatiA[6]=$MfloatRot[5];
$MatrizFloatiA[8]=$MfloatRot[6];
$MatrizFloatiA[9]=$MfloatRot[7];
$MatrizFloatiA[10]=$MfloatRot[8];
matrix $newRotM[4][4];
$newRotM = FloatToMatrix($MatrizFloatiA);
	return $newRotM;
}

proc float[] MatrixToFloatNN(matrix $FourByFour_matrix[][], int $N){
	float $matrixFloat[];
	int $FLOATindex = 0;
	int $Inx = 0;
	int $Inxb = 0;
	for($Inx = 0; $Inx <= $N; $Inx++){
		for($Inxb = 0; $Inxb <= $N; $Inxb++){
			$matrixFloat[$FLOATindex] = $FourByFour_matrix[$Inx][$Inxb];
			$FLOATindex++;
		}
	}
	return $matrixFloat;
}

proc matrix MatrixToFloatN(vector $Vec_matrix[]){

//eval("\matrix $N_matrix["+$X+"\]["+$X+"\]");
 matrix $N_matrix[3][3];
	float $matrixFloat[];
	int $FLOATindex = 0;
	int $Inx = 0;
	int $Inxb = 0;
int $Xi = 3-1;
	for($Inx = 0; $Inx <= $Xi; $Inx++){
		for($Inxb = 0; $Inxb <= $Xi; $Inxb++){
			 $N_matrix[$Inx][$Inxb]=$Vec_matrix[$FLOATindex];
			$FLOATindex++;
		}
	}
	return $N_matrix;
}



string $CurveItemZ[] = `ls -sl`;
PointCurvesToPlaneCurve($CurveItemZ);

string $LocZ_Pts[] = `ls -sl`;
vector $VPos_MC[];
	 $VPos_MC = PointArrayT(`ls -sl`);
vector $PlaneLocZ[];
 $PlaneLocZ = VecPointsToCameraPlane($VPos_MC);
string $planeLocs[];
for($EachVec in  $PlaneLocZ){
$planeLocs[`size($planeLocs)`] = `Loc $EachVec`;

}

string $CurveItemZ[] = `ls -sl`;
PointCurvesToPlaneCurveB($CurveItemZ);

//select cam and points



vector $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM`;
vector $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM`;



////////////////////////////////////////////////////////START 


vector $PtsVecA[] = PointArrayT(`ls -sl`);

vector $PtsVecAX =FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[1], $PtsVecA[2], $PtsVecA[3]));		
//Loc $PtsVecAX;
vector $PtsVecAY =FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[3], $PtsVecA[1], $PtsVecA[2]));		
//Loc $PtsVecAY;
vector $PtsVecCross =FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[2], $PtsVecA[1], $PtsVecA[3]));		
//Loc $PtsVecCross;
float $Xcross[] = $PtsVecCross;
Loc $Xcross;
float $XcrossP[]= {$Xcross[0],$Xcross[1],1.0};
vector $Normal= nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);



vector $DirLineCamXepip = DirectionFN( $PtsVecAX,$Cam_Trans);
vector $Nvec = ($DirLineCamXepip*2.0)+$PtsVecAX;
Loc $Nvec;
vector $PtsM_A[];
vector $Line[];
$Line[0]=$Nvec;
$Line[1]=$DirLineCamXepip;
vector $PtsM_A[];
 $PtsM_A = VecPointsMirrorVecPlaneN($PtsVecA,$Line);
vector $CamM_B[];
 $CamM_B = VecPointsMirrorVecPlaneN({$Cam_Trans},$Line);


vector $SQuarePts[];
$SQuarePts[0] = FloatToVec (lineIntersectionF($Cam_Trans, $PtsVecA[0], $CamM_B[0], $PtsM_A[1]));
$SQuarePts[1] = FloatToVec (lineIntersectionF($Cam_Trans, $PtsVecA[1], $CamM_B[0], $PtsM_A[0]));
$SQuarePts[2] = FloatToVec (lineIntersectionF($Cam_Trans, $PtsVecA[2], $CamM_B[0], $PtsM_A[3]));
$SQuarePts[3] = FloatToVec (lineIntersectionF($Cam_Trans, $PtsVecA[3], $CamM_B[0], $PtsM_A[2]));
vector $pointMakeS[];
 $pointMakeS[0] = ClosestPoint2LineVec(DirectionFN($SQuarePts[2],$SQuarePts[3]), $SQuarePts[2], $SQuarePts[0]);
 $pointMakeS[1] = ClosestPoint2LineVec(DirectionFN($SQuarePts[2],$SQuarePts[3]), $SQuarePts[2], $SQuarePts[1]);
Loc  $pointMakeS[0];
Loc  $pointMakeS[1];
Loc $SQuarePts[1];

vector $DirNorA = Normal3Points($SQuarePts[0],  $pointMakeS[0], $pointMakeS[1]);
 float $PtsFCrossBB[] = (lineIntersectionF($SQuarePts[0], $pointMakeS[1], $SQuarePts[1], $pointMakeS[0]));	

//PositiveDirectionLine

Loc $PtsVecCrossBB;

float $Yaxis[]=PositiveDirectionLine($SQuarePts[1],$pointMakeS[1]);
float $Xaxis[] =crossProduct( $Yaxis, $DirNorA, 0, 0 );

float $NormZ[]=$DirNorA ;
vector $DirVector[];
$DirVector[0]= << $Xaxis[0], $Xaxis[1], $Xaxis[2]>>;
$DirVector[1]= << $Yaxis[0], $Yaxis[1], $Yaxis[2]>>;
$DirVector[2]= << $NormZ[0], $NormZ[1], $NormZ[2]>>;

	matrix $matrixIMAGE[4][4];
$matrixIMAGE  = << $Xaxis[0], $Xaxis[1], $Xaxis[2], 0.0;
	$Yaxis[0], $Yaxis[1], $Yaxis[2], 0.0;
	$NormZ[0], $NormZ[1], $NormZ[2], 0.0;
	$PtsFCrossBB[0], $PtsFCrossBB[0], $PtsFCrossBB[0], 1.0 >>; 



 

MakeMatrixAxis($DirVector,FloatToVec($PtsFCrossBB));

 matrix $mIA[4][4] = $matrixIMAGE;
 vector $PtsVec = $Cam_Trans;
matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
          0.0, 1.0, 0.0, 0.0;
          0.0, 0.0, 1.0, 0.0;
          0.0, 0.0, 0.0, 1.0 >>;
matrix $mIB[4][4] = $mI;

vector $PtsVecTemp[] = PointArrayT(`ls -sl`);
vector $CrvN[];

for($eachVec in $PtsVecTemp){
  $CrvN[`size($CrvN)`] = MultPointMatrixPlusRel( $eachVec, $matrixIMAGE ,$mI);
}
string $ThefirstCurve = VecArrayToCurve($CrvN);



proc vector MultPointMatrixPlusRel( vector $PtsVec, matrix $mIA[][],matrix $mIB[][]){

vector $Tran,$TranB,$ReturnValVec;
float $RowA[],$RowB[],$RowC[],$RowAi[],$RowBi[],$RowCi[],$MtxF[],$Pts[],$AxisO[],$PtZ[],$PtZT[];

	 $MtxF  = MatrixToFloat($mIA);	
 	$RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
	$RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
	$RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};

	 $Pts = $PtsVec;
 
// cent of matrix 
 $AxisO = $Tran = << $mIA[3][0], $mIA[3][1], $mIA[3][2]>>;
////////////////////////////////////////

$PtZ[0] = ($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2]));
$PtZ[1] = ($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2]));
$PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));

//Loc $PtZ;

////////////////////////////////////// YOU GOT IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	 $MtxFB  = MatrixToFloat($mIB);	
 	$RowAi = {$MtxFB[0], $MtxFB[1], $MtxFB[2]};
	$RowBi = {$MtxFB[4], $MtxFB[5], $MtxFB[6]};
	$RowCi = {$MtxFB[8], $MtxFB[9], $MtxFB[10]};

$PtZT[0] = (($RowAi[0])*($PtZ[0])) + (($RowBi[0])*$PtZ[1]) + (($RowCi[0])*$PtZ[2])+$MtxF[3];
$PtZT[1] = (($RowAi[1])*($PtZ[0])) + (($RowBi[1])*$PtZ[1]) + (($RowCi[1])*$PtZ[2])+$MtxF[7];
$PtZT[2] = (($RowAi[2])*($PtZ[0])) + (($RowBi[2])*$PtZ[1]) + (($RowCi[2])*$PtZ[2])+$MtxF[11];

 $ReturnValVec = << $PtZT[0], $PtZT[1], $PtZT[2]>>;
 $TranB = << $mIB[3][0], $mIB[3][1], $mIB[3][2]>>;
 $ReturnValVec += $TranB;

//Loc $PtZT;

	return $ReturnValVec;
}






proc MakeMatrixAxis(vector $DirectionVector[],vector $MidPt){
vector $norm	=$DirectionVector[0];
vector $bi	=$DirectionVector[1];
vector $tan	=$DirectionVector[2];

	// "Xn", "X", "Y", "Yn", "Zn", "Z"

int $colori[];
	$colori[`size($colori)`] = 13;
	$colori[`size($colori)`] = 14;
	$colori[`size($colori)`] = 6;	

string $AllCirTemp[];
	string $CirTemp[];
	string $curveAxis ="";
	$curveAxis += makeCurvePointDirectionLength((6), $norm, $MidPt); //
	$CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[0]);
$AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
PAUSE;
	$curveAxis += makeCurvePointDirectionLength((6), $bi, $MidPt); // 
	$CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[1]);
$AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
PAUSE;
	$curveAxis += makeCurvePointDirectionLength((6), $tan, $MidPt); //
	$CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[2]);
$AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
PAUSE;
}




proc float VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){
	vector $p =  $VecN[0];
vector $n1 = $VecN[1];
	float $D, $D1;	
	vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
$F = $n1;
$e = $V;
		$M = $e+($F);
		$D = distance2Pts($e, $p);
		$F2 = $p+($D*$n1);	
		$P1 = ClosestPoint2LineVec($n1, $p, $e);
		$F3 = DirectionF($P1, $p);
		$D1 = distance2Pts($P1, $p); 
	return $D1;
}

string $CRV_Item[] =`ls -sl`;
	vector $AllLocPositionsZi[];
	$AllLocPositionsZi = VecCurveCvs( $CRV_Item[0]);

vector $AXIS_XZY[];
$AXIS_XZY[0]=<<0,0,1>>;
$AXIS_XZY[1]=<<1,0,0>>;

int $COUNT=0;
float $AllF[];
int $Find[];
clear $Find;
clear $AllF;
for($EachV in $AllLocPositionsZi){

$AllF[$COUNT]=VecPointsMirrorVecPlaneN({$EachV},$AXIS_XZY);
//print ($AllF[$COUNT]+"\n");
if($AllF[$COUNT]<0.25){
//print ("  #######HERE###### "+"\n");
$Find[`size($Find)`]=$COUNT;
}

$COUNT++;
}

for($EachINT in $Find){
Loc ($AllLocPositionsZi[$EachINT]);
}



proc float VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){
	vector $p =  $VecN[0];
vector $n1 = $VecN[1];
	float $D, $D1;	
	vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
$F = $n1;
$e = $V[0];
		$M = $e+($F);
		$D = distance2Pts($e, $p);
		$F2 = $p+($D*$n1);	
		$P1 = ClosestPoint2LineVec($n1, $p, $e);
		$F3 = DirectionF($P1, $p);
		$D1 = distance2Pts($P1, $p); 
	return $D1;
}





proc vector [] VecPointsMirrorVecPlaneN(vector $V[],vector $VecN[]){
	vector $p =  $VecN[0];
vector $n1 = $VecN[1];
	float $D, $D1;	
	vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
$F = $n1;
	int $C1;
	$C1=0; 
	for($e in $V){	
		$M = $e+($F);
		$D = distance2Pts($e, $p);
		$F2 = $p+($D*$n1);	
		$P1 = ClosestPoint2LineVec($n1, $p, $e);
		$F3 = DirectionF($P1, $p);
		$D1 = distance2Pts($P1, $p);
print $D1;
		$F4 = $e+(($D1*2.0)*$F3);
$O[$C1] = $F4;
		$C1++;
	}
	VecArrayToCurveB($O);
	ResetTransEachSL;	
 
	return $O;
}

vector $AXIS_XZY[];
$AXIS_XZY[0]=<<0,0,0>>;
$AXIS_XZY[1]=<<1,0,0>>;
vector $MMVEC[] =VecPointsMirrorVecPlaneN($PtsVec,$AXIS_XZY);
Loc $MMVEC[0];
string $CURVE[];
$CURVE[0]= curve2points( $MMVEC[0], $PtsVec[0]);

print $PtsVec;





vector $PtsVec[] = PointArrayT(`ls -sl`);

vector $AXIS_XZY[];
$AXIS_XZY[0]=<<1,0,0>>;
$AXIS_XZY[1]=<<0,1,0>>;
$AXIS_XZY[2]=<<0,0,1>>;

PointDistance_Plane( $PtsVec[0], $AXIS_XZY,<<1,0,9>>);


proc float PointDistance_Plane( vector $Vec_Array, vector $AXIS_XZY[],vector $midpoint){

vector $Tran;
float $RowA[],$RowB[],$RowC[],$Pts[],$AxisO[],$PtZ[];
 	$RowA = $AXIS_XZY[0];
	$RowB = $AXIS_XZY[1];
	$RowC = $AXIS_XZY[2];	
	// cent of matrix 
 $AxisO = $Tran = $midpoint;
////////////////////////////////////////
	vector $newVecs[];
	 $Pts = $Vec_Array;	 
////////////////////////////////////////
$PtZ[0] = (($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2])));
$PtZ[1] = (($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2])));
$PtZ[2] = (($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2])));

vector $PlaneP = <<$PtZ[0],$PtZ[1],$PtZ[2]>>;
float $DISTANCE =distance2Pts($Vec_Array, $PlaneP);

string $CURVE[];
$CURVE[0]= curve2points($Vec_Array, $PlaneP);
float $ARCL = `arclen $CURVE[0] `;
print $ARCL;

	return  $DISTANCE;
}





vector $DirLineN = << 0.0, 0.0 , 1.0 >>;			
vector $DirLineX = << 1.0, 0.0 , 0.0 >>;			
vector $DirLineY = << 0.0, 1.0 , 0.0 >>;	


vector $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM`;
vector $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM`;

vector $DirLineCamTOx = DirectionFN($XcrossP,$PtsVecAX);
vector $DirLineCamTOy = DirectionFN($XcrossP,$PtsVecAY);

//vector $DirLineCamTOx = DirectionFN($PtsVecAX, $Cam_Trans);
//vector $DirLineCamTOy = DirectionFN($PtsVecAY, $Cam_Trans);


float $AngleA = `angle $DirLineX $DirLineCamTOx`;
float $AngleADegreeX =`rad_to_deg $AngleA`;

	float $AngleB = `angle $DirLineN $DirLineCamTOy`;
float $AngleADegreeY =(`rad_to_deg $AngleB`-90.0);

// Result: 45 // 
// Result: -33.778758 // 








vector $PtsVecA[] = PointArrayT(`ls -sl`);

vector $PtsVecAX =FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[1], $PtsVecA[2], $PtsVecA[3]));		
//Loc $PtsVecAX;
vector $PtsVecAY =FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[3], $PtsVecA[1], $PtsVecA[2]));		
//Loc $PtsVecAY;
vector $PtsVecCross =FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[2], $PtsVecA[1], $PtsVecA[3]));		
 Loc $PtsVecCross;
float $Xcross[] = $PtsVecCross;
float $XcrossP[]= {$Xcross[0],$Xcross[1],1.0};
vector $Normal= nurbsViewDirectionVectorCam("ZCURVEModelingCAM1", 0);

vector $DirLineN = << 0.0, 0.0 , 1.0 >>;			
vector $DirLineX = << 1.0, 0.0 , 0.0 >>;			
vector $DirLineY = << 0.0, 1.0 , 0.0 >>;	



vector $DirLineCamTOx = DirectionFN($Xcross,$PtsVecAX);
vector $DirLineCamTOy = DirectionFN($Xcross,$PtsVecAY);

//vector $DirLineCamTOx = DirectionFN($PtsVecAX, $Cam_Trans);
//vector $DirLineCamTOy = DirectionFN($PtsVecAY, $Cam_Trans);


float $AngleA = `angle $DirLineX $DirLineCamTOx`;
float $AngleADegreeX =`rad_to_deg $AngleA`;

	float $AngleB = `angle $DirLineN $DirLineCamTOy`;
float $AngleADegreeY =(`rad_to_deg $AngleB`-90.0);

float $FOUNDZ= 135.000001 -45.0;



vector $Cam_Trans = `xform -q -ws -t ZCURVEModelingCAM1`;
vector $Cam_Rot = `xform -q -ws -ro ZCURVEModelingCAM1`;


/*


vector $DirLineCamTOy = DirectionFN($PtsVecAY, $Cam_Trans);
// Result: <<5.16314e-010, -0.831191, -0.555988>>  // 
float $AngleA = `angle $DirLineX $DirLineCamTOx`;
float $AngleADegreeX =`rad_to_deg $AngleA`;
// Result: 135.000001 // 
float $AngleB = `angle $DirLineN $DirLineCamTOy`;
float $AngleADegreeY =(`rad_to_deg $AngleB`-90.0);
// Result: 33.77876 // 
float $FOUNDZ= 135.000001 -45.0;
// Result: 90.000001 // 

*/










setAttr "ZCURVEModelingCAM.rotate" $AngleADegreeY $AngleADegreeX 0; 

print $AngleADegreeX $AngleADegreeX



 matrix $CamMatrixX[4][4];  
 $CamMatrixX = GetMatrix("ZCURVEModelingCAM");
// Result: << 0.372095 0 -0.928195 0;  -0.492072 0.847911 -0.197262 0;  0.787026 0.530139 0.315504 0;  0 0 1 1 >> // 


float $CamMfloatZ[];
$CamMfloatZ[0] = $CamMatrixX[0][0]; 
$CamMfloatZ[1] = $CamMatrixX[0][1]; 
$CamMfloatZ[2] = $CamMatrixX[0][2];

vector $PtsVecAX =FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[1], $PtsVecA[2], $PtsVecA[3]));		
Loc $PtsVecAX;
vector $PtsVecAY =FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[3], $PtsVecA[1], $PtsVecA[2]));		
Loc $PtsVecAY;
vector $PtsVecCross =FloatToVec (lineIntersectionF($PtsVecA[0], $PtsVecA[2], $PtsVecA[1], $PtsVecA[3]));		
Loc $PtsVecCross;
float $Xcross[] = $PtsVecCross;
float $XcrossP[]= {$Xcross[0],$Xcross[1],1.0};
vector $Normal= nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);

vector $DirLineCamTOx = DirectionFN($XcrossP,$PtsVecAX);

vector $DirLineN = << 0.0, 0.0 , 1.0 >>;			
vector $DirLineX = << 1.0, 0.0 , 0.0 >>;			
vector $DirLineY = << 0.0, 1.0 , 0.0 >>;	


vector $DirLineCamTOx = DirectionFN($XcrossP,$PtsVecAX);
vector $DirLineCamTOy = DirectionFN($XcrossP,$PtsVecAY);



 matrix $CamMatrixXt[4][4];  
 $CamMatrixXt = GetMatrix("ZCURVEModelingCAM3");

-32.014843
68.15511
0

yrotMATRIX(68.15511);
xrotMATRIX(-32.014843);


PrintMatrix($CamMatrixXt,4);
|  1  0  0  0|
|  0  1  0  0|
|  0  0  1  0|
|  0  0  1  1|
PrintMatrix($CamMatrixX,4);
|   0.3720951716              0  -0.9281945826              0|
|  -0.4920720897   0.8479107896  -0.1972621389              0|
|   0.7870262015   0.5301389373   0.3155035108              0|
|              0              0              1              1|

StringtoStringMATRIX;

MultMATRIX($CamMatrixX);

vector [] GetRotationVectorsMatrix(


TransformRelByMatrixXform($CamMatrixX, "ZCURVEModelingCAM3");


//TransformItemByMatrixXform($CamMatrixX, "ZCURVEModelingCAM3");


 $matrixA_GlobalX  = << $xx, $yx, $zx, 0.0;
	$xy, $yy, $zy, 0.0;
	$xz, $yz, $zz, 0.0;
	$xo, $yo, $zo, 1.0 >>;
PrintMatrix($matrixA_GlobalX,4);   
  
UnitMATRIX;



TransformRelByMatrixXform( $matrixA_GlobalX, "ZCURVEModelingCAM3");




float $FirstTrans[] = $VrotatsFIRST;
float $FirstRot[] = $VrotatsFIRST;
setAttr "ZCURVEModelingCAM.translate" $FirstTrans[0] $FirstTrans[1] $FirstTrans[2]; 
setAttr "ZCURVEModelingCAM.rotate" 0 $FirstRot 0; 




vector $DirLineAX = DirectionFN($PtsVecAX, $PtsVecCross);			
vector $DirLineAY = DirectionFN($PtsVecAY, $PtsVecCross);
vector $Zero = << 0.0, 0.0 , 0.0 >>;	
vector $DirLineX = << -1.0, 0.0 , 0.0 >>;			
vector $DirLineY = << 0.0, -1.0 , 0.0 >>;			
vector $DirLineYp = << 0.0, 1.0 , 0.0 >>;	
float $AngleAX = `angle  $DirLineAX $DirLineX`;
float $AngleADegreeX =`rad_to_deg $AngleAX`;

float $AngleAY = `angle  $DirLineAY $DirLineY`;
float $AngleADegreeY =`rad_to_deg $AngleAY`;

float $FirstTrans[] = $VrotatsFIRST;
float $FirstRot[] = $VrotatsFIRST;
setAttr "ZCURVEModelingCAM.translate" $FirstTrans[0] $FirstTrans[1] $FirstTrans[2]; 
setAttr "ZCURVEModelingCAM.rotate" 0 $FirstRot 0; 

vector $DirLineN = << 0.0, 0.0 , 1.0 >>;			
vector $DirLineX = << 1.0, 0.0 , 0.0 >>;			
vector $DirLineY = << 0.0, 1.0 , 0.0 >>;	



vector $VPos_MC[]; 
 $VPos_MC[0]= $VecCurEndsa[0];  $VPos_MC[1]= $VecCurEndsa[1];
 $VPos_MC[2]= $VecCurEndsb[0];  $VPos_MC[3]= $VecCurEndsb[1];
vector $DirLineY = DirectionFN($VPos_MC[0], $VPos_MC[1]);
vector $DirLineYR = DirectionFN($VPos_MC[2], $VPos_MC[3]); 
float $AngleA = `angle $DirLineY $DirLineYR`;
float $AngleADegree =`rad_to_deg $AngleA`;




proc vector [] VecPointsToCameraPlaneB(vector $V[]){
	vector $p = `xform -q -ws -t "LiveSurfaceB1"`;
	vector $C = `xform -q -ws -t ZCURVEModelingCAM1`;
	vector $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM1", 0); 
	float $D, $D1;	
	vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
	int $C1;
	$C1=0; 
	for($e in $V){
		$F = DirectionF($C, $e);
		$M = $e+($F);
		$D = distance2Pts($e, $p);
		$F2 = $p+($D*$n1);	
		$P1 = ClosestPoint2LineVec($n1, $p, $e);
		$F3 = DirectionF($P1, $p);
		$D1 = distance2Pts($P1, $p);
		$F4 = $e+($D1*$F3);
		$P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
		$F1 = DirectionF($P, $M);
		$O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));	
		$C1++;
	}	 
	return $O;
}
proc string [] PointCurvesToPlaneCurveB(string $CurveItemZ[]){
string $newPlaneCurve[];
int $CN =0;
	for ($eachCurve in $CurveItemZ){
		vector $AllLocPositionsZ[];
		clear $AllLocPositionsZ;
		$AllLocPositionsZ = VecCurveEps( $eachCurve );
		vector $AllPlaneLocPositionZ[]= VecPointsToCameraPlaneB($AllLocPositionsZ);
		$newPlaneCurve[$CN] = VecArrayToCurve($AllPlaneLocPositionZ);
		ResetTranslation({$newPlaneCurve[$CN]});
$CN++;
	}
return $newPlaneCurve;

}





vector [] GetRotationVectorsMatrix(


TransformRelByMatrixXform(matrix $m[][], string $item)
TransformItemByMatrixXform(matrix $m[][], string $item)



matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 1.0 >>;

global matrix $matrixA_GlobalX[4][4];
 $matrixA_GlobalX = << $xx, $yx, $zx, 0.0;
	$xy, $yy, $zy, 0.0;
	$xz, $yz, $zz, 0.0;
	$xo, $yo, $zo, 1.0 >>;   







//geneticEngine.mel by Martin Hemberg 2004

//This is a genetic engine, ie a simple genetic algorithm for
//evolutionary search implemented in MEL. In order to make it useful,
//one must define a fitness function.

//Some global variables. Unfortunately, matrix sizes can not be set
//dynamically in MEL. Moreover, one can't declare constants. Thus I'm
//using this method, I think it's marginally better than not having
//them. Thus, we are stuck with a fixed size, if you want to change pop
//size or length, change these numbers and do a search and replace on
//the rest of the file 



global int $gGenomeLength = 100; 
global int $gPopulationSize = 50; 
global int $gMaxGeneValue = 42; //For a limit when generating random numbers, you may need to adjust this depending on your problem.

evolve(125, 19, 55, 25.9);

string $ABCs = "abcdefghijklmnopqrstuvwxyz";
string $LETTERS[] = ArrayFromAllinString($ABCs);
string $Find = "hellojohn";
int $SizeF =  `sizeBytes  $Find `;
int $SizeABCs =  `sizeBytes  $ABCs `;

global int $gGenomeLength = 9; 
global int $gPopulationSize = 50; 
global int $gMaxGeneValue =26; 
global matrix $genomes[50][9];
$genomes = `initializePopulation`;

print $genomes

string $GENOME_LETTERS="";
int $j;
$j=1;
	int $i;
	for($i=0; $i<$gGenomeLength; $i++){
$GENOME_LETTERS+= $LETTERS[int($genomes[$j][$i])];
gmatch $GENOME_LETTERS  $Find;
print ($GENOME_LETTERS+"\n");
}

gmatch "zza" "abc";


string $Find = "hellojohn";

string $FindN = "012";
  sizeBytes(` match "[l-l]" "hellojohn"`)

match "[a-d]+" "acbdefg" "


//This function creates a population of individuals with random gene values.


proc matrix initializePopulation()
{
	global int $gPopulationSize;
	global int $gGenomeLength;
	global int $gMaxGeneValue;
global matrix $genomes[50][9];
	int $i, $j;
	//Set each gene to a random value
	for($i=0; $i<$gPopulationSize; $i++){
		for($j=0; $j<$gGenomeLength; $j++)
			$genomes[$i][$j] = int(rand ($gMaxGeneValue));
	}
	return $genomes;
}



//This function is used to evaluate the fitness of the population. It
//contains a large gap - you'll have to insert your own fitness function
//that maps the array of doubles (the genome) to a scalar value (the
//fitness). The fitness should be set so that a low value indicates a fit
//individual.
proc float[] evaluate(matrix $genomes)
{
	global int $gPopulationSize;
	int $i;
	float $fitness[50];
	for($i=0; $i<$gPopulationSize; $i++){
		//Here each individual should be evaluated

$fitness[$i] = 
	}
	return $fitness;
}



 proc evolve(int $generations, int $elites, int $tournamentSize, float $mutationRate)
{
	//Call this function in order to do an evolutionary run for a
	//fixed number of generations. Unfortunately, there is no way to
	//continue running with the same population. However, that should not be
	//to hard to fix. It's just a matter of saving the variables in the
	//scene adn writing a function for reading them again at re-start.
global matrix $genomes[50][9];
	matrix $genomes[50][9] = initializePopulation(); //[popsize][geneomelength] Each row represents an individual
	float $fitness[]; //An array containing the fitness values
	int $i;
	//Iterate through the generations
	for($i=0; $i<$generations; $i++){
		$fitness = evaluate($genomes); //Find out who's best
		$genomes = breed($genomes, $fitness, $elites, $tournamentSize, $mutationRate); //Create the population for the next generation
	}
}




//This function is used to create the population for the next generation
proc matrix breed(matrix $genomes, float $fitness[], int $elites, int $tournamentSize, float $mutationRate)
{
	global int $gPopulationSize;
	global int $gGenomeLength;
	matrix $newGenomes[50][9]; //The next generation
	int $lowest = -1;
	//Copy the elites to the new generation, they will automatically be the first individuals in the new generation.
	for($i=0; $i<$elites; $i++){
		$lowest = findLowestFitness($fitness, $lowest);
		for($j=0; $j<$gGenomeLength; $j++)
			$newGenomes[$i][$j] = $genomes[$lowest][$j];
	}
	//Create the rest through tournament selection
	for($i=$elites; $i<$gPopulationSize; $i++){
		int $father = tournamentSelect($fitness, $tournamentSize);
		int $mother = tournamentSelect($fitness, $tournamentSize);
		$newGenomes = crossover($genomes, $newGenomes, $father, $mother, $i);
	}
	return mutate($newGenomes, $elites, $mutationRate);
}

//Returns the index of the individual with the lowest fitness above the one indicated by the argument $lowest.
//If $lowest==-1, return the global minimum
proc int findLowestFitness(float $fitness[], int $lowest)
{
	int $i, $index;
	float $indexFitness = 100000; //Very high number
	float $lowestFitness = $fitness[$lowest];
	for($i=0; $i<size($fitness); $i++){
		if($fitness[$i]<$indexFitness && $fitness[$i]>=$lowestFitness && $i>$lowest){
			$index = $i;
			$indexFitness = $fitness[$i];
		}
	}
	return $index;
}

//Choose a parent using tournament selection. $tournamentSize
//individuals are randomly chosen from the population. The best one of
//these is then used as one of the parents for a member of the next
//generation. A high value of $tournamentSize (compared to the pop size)
//means that there will be less variation since the fittest individuals
//are more likely to be picked in every tournament.

proc int tournamentSelect(float $fitness[], int $tournamentSize) {
	global int $gPopulationSize;
	int $parent = (int)rand ($gPopulationSize), $i, $tmp;
	for($i=1; $i<$tournamentSize; $i++){
		$tmp = (int)rand ($gPopulationSize);
		if($fitness[$tmp]<$fitness[$parent]) //Fitness minimization
			$parent = $tmp;
	}
	return $parent;
}


//Combine to individuals to produce a new one for the next generation.
proc matrix crossover(matrix $genomes, matrix $newGenomes, int $father, int $mother, int $child)
{
	global int $gGenomeLength;
	int $i, $crossoverPoint = (int)rand ($gGenomeLength);
	for($i=0; $i<$crossoverPoint; $i++)
		$newGenomes[$child][$i] = $genomes[$father][$i];
	for($i=$crossoverPoint; $i<$gGenomeLength; $i++)
		$newGenomes[$child][$i] = $genomes[$mother][$i];
	return $newGenomes;
}

//Random mutation
proc matrix mutate(matrix $newGenomes, int $elites, float $mutationRate)
{
	global int $gPopulationSize;
	global int $gGenomeLength;
	int $i, $j;
	for($i=$elites; $i<$gPopulationSize; $i++){ //Don't mutate the elites
		for($j=0; $j<$gGenomeLength; $j++){
			if($mutationRate>`rand 100.0`){ //Mutate
				if(`rand 2.0`>1.0)
					$newGenomes[$i][$j] = $newGenomes[$i][$j] + 1;
				else
					$newGenomes[$i][$j] = $newGenomes[$i][$j] - 1;
			}
		}
	}
	return $newGenomes;
}
				



proc float roundoff( float $f, int $n )
{
  // we divide if n < 0 to avoid numeric
  // precision problems
  if( $n > 0 )
  {
    float $roundScale = pow(10,$n);
    if( $f > 0 )
      return( ((float)(int)($f * $roundScale + 0.5)) /$roundScale );
    else
      return( ((float)(int)($f * $roundScale - 0.5)) /$roundScale );
  }
  else
  {
    float $roundScale = pow(10,-$n);
    if( $f > 0 )
      return( ((float)(int)($f/$roundScale + 0.5)) *$roundScale );
    else
      return( ((float)(int)($f/$roundScale - 0.5)) *$roundScale );

  }
}












 



//////////








int $MasterLineN[];
clear $MasterLineN;


int $CurrentLineN[];
$CurrentLineN = $CurrentLineNF;
string $CollectL[];
string $CAL_temp[];
int $LN_temp[];
clear $CollectL;
clear $CAL_temp;
clear $LN_temp;
$CAL_temp =$CollectAllLines;
$LN_temp =$LineNumber;
string $stringN;
int $IndexX[];
string $FoundProc[];
int $NegPosZA[];
clear $NegPosZA;
int $WhenZero=2;
int $CountNL = 1;
int $CountFindNL = 0;
int $START = 0;
int $TriggerLineFound=0;
string $nextLine;
string $nextLineN;
int $CurrentLineNX[];
string $FoundProcTemp[];
string $tempCollectProc[];
string $AllFoundProcs[];
clear $CurrentLineNX;
clear $tempCollectProc;

int $Aint = size($CollectAllLines);
int $Bint = size($AllFoundProcs);
int $Cint = size($CAL_temp);
int $CHECK = $Aint-$Cint ;

//int $fileId =`fopen $exampleFileName "r"`;
//string $nextLine = `fgetline $fileId`;
//int $eachInt = $CurrentLineN[0];
clear $tempCollectProc;
clear $AllFoundProcs;

string $WholeProc[];
int $TRIGGEREND =2;

int $fileId =`fopen $exampleFileName "r"`;


while($TRIGGEREND>1){ 



///////////////////////////
///////////////////////////




 		for($eachInt in $CurrentLineN){


//this is the number that is the first line of a group of lines that are a proc


$WhenZero=2;
$CountNL = 1;
$CountFindNL = 0;
$START = 0;
$TriggerLineFound=0;



///////////////////////////////////////////////////////////////////

		while ( !`feof $fileId` ) {


				$nextLine = `fgetline $fileId`;
				$nextLineN = match( "^[^(\r\n)]*", $nextLine );

			//FOUND LINE NUMBER
			//CHANGE HERE

				if($CurrentLineN[$CountFindNL] == $CountNL){
				clear $NegPosZA;
				$CountFindNL++;
				$TriggerLineFound=1;
					}



	if($TriggerLineFound==1){
		$WhenZero = BracketFindPosNeg($nextLine, $NegPosZA);
		$START++;
		$CollectL[`size($CollectL)`]= $nextLineN;



	/// WHEN PROC IS FULLY SCANNED HERE BELOW

		if(($WhenZero==0)&&($START>1)){



		$START=$TriggerLineFound=0; $WhenZero=2; clear $NegPosZA;
			// $CAL_temp IS $CollectAllLines;  MATCH NAMES//
			if(`size($CAL_temp)`==0){break;}
	$FoundProcTemp =RuleBasedMatchM($IndexX,$CAL_temp, $CollectL);
			// $LN_temp =$LineNumber;		
		if(`size($IndexX)`>0){

			$IndexX = sort($IndexX);
			for($i=0; $i<`size($IndexX)`; $i++){
			$CurrentLineNX[`size($CurrentLineNX)`] =$LN_temp[$IndexX[$i]];
			}



		$CAL_temp=RemoveStringAtIndex($CAL_temp,$IndexX);
		$LN_temp = RemoveIntAtIndex($LN_temp,$IndexX);

		clear $IndexX;
		///////////// 

			}
		
		$tempCollectProc =AppendArrayZ($tempCollectProc, $FoundProcTemp);

clear $FoundProcTemp; 
/////////////////////	
		
		
				

					}
				}
		//LINE NUMBER
		$CountNL++;

		}

///////////////////////////////////////////////////////////////////


frewind $fileId;



}


///////////////////////////
///////////////////////////


$tempCollectProc= stringArrayRemoveDuplicates($tempCollectProc);
AppendArrayZ($AllFoundProcs,$tempCollectProc);

string $TempStringP="";
$TempStringP = stringArrayToString($tempCollectProc, ", ");
print ($TempStringP+"\n");
$WholeProc[`size($WholeProc)`]=$TempStringP;

clear $tempCollectProc;
//////////////////////	


string $list[] = IntArrayToStringArray($CurrentLineNX);
$list= stringArrayRemoveDuplicates($list);

clear $CurrentLineN;
$CurrentLineN=StringArrayToIntArray($list);
$CurrentLineN =sort ($CurrentLineN);

clear $CurrentLineNX;
//////////////////////

clear $tempCollectProc;
//////////////////////

if(`size($CurrentLineN)`>0){
for($i=0; $i<`size($CurrentLineN)`; $i++){
$MasterLineN[`size($MasterLineN)`] =$CurrentLineN[$i];
}
}


if($CurrentLineN[0]==0){
print "STOPSTOP";
$TRIGGEREND =0;
break;
}

if(`size($CurrentLineN)`==0){
print "STOPSTOP";
$TRIGGEREND =0;
break;
}



}

print $WholeProc;




////////
/////////////START OF AUTOMATIC SCENE SETUP for STEREOSCRIPTS######################################
/////////////START OF AUTOMATIC SCENE SETUP for STEREOSCRIPTS######################################
/*




global vector $ObjCurv[];
//print  $GlobalObjListA[46];
global vector $ObjVec[];
global string $GlobalObjListA[];
global string $GlobalObjOne[];
string $ConnectionSet1 = `sets -name ExistingCurveZSet`;
string $ConnectionSet2 = `sets -name CurveZSetOne`;
 clear $ObjCurv;
 clear $GlobalObjListA;
 clear $GlobalObjOne;
 clear $ObjVec;

global int $ifSingleCurve;
$ifSingleCurve =0;
createDisplayLayer -name "VanishingPointsLines"  -empty;
setAttr VanishingPointsLines.visibility 1; setAttr VanishingPointsLines.displayType 0; setAttr VanishingPointsLines.color 0;


                                    if ( `objExists NurbsPlanes` == 0  ) {
createDisplayLayer -name "NurbsPlanes" - number 1 -empty;
setAttr NurbsPlanes.color 30;
}
if ( `objExists IntersectFormLayer` == 0  ) {
createDisplayLayer -name "IntersectFormLayer" - number 1 -empty;
setAttr IntersectFormLayer.color 30;
}
if ( `objExists IntersectFormLayerOutofRange` ==  0  ) {
createDisplayLayer -name  "IntersectFormLayerOutofRange" -number 1 -empty;
setAttr IntersectFormLayerOutofRange.color 2;
}
if ( `objExists IntersectFormLayerINRange` == 0   ) {
createDisplayLayer -name  "IntersectFormLayerINRange" -number 1 -empty;
setAttr IntersectFormLayerINRange.color 3;
}
if ( `objExists layerYZYXPlains` == 0  ) {
createDisplayLayer -name "layerYZYXPlains" - number 1 -empty;
}
if ( `objExists layerAllCurves1` == 0  ) {
createDisplayLayer -name "layerAllCurves1" - number 1 -empty;
}
if ( `objExists layerEdgeCurveZ1` == 0  ) {
createDisplayLayer -name "layerEdgeCurveZ1" - number 1 -empty;
}
if ( `objExists layerCurvesOutofRange1` == 0  ) {
createDisplayLayer -name "layerCurvesOutofRange1"  -number 1 -empty;
setAttr layerCurvesOutofRange1.color 12;
}
if ( `objExists layerCurvesINRange1` == 0  ) {
createDisplayLayer -name "layerCurvesINRange1" - number 1 -empty;
setAttr layerCurvesINRange1.color 6;
}
if ( `objExists TheLastCurvesSet` == 0  ) {
string $newSet3 = `sets -name TheLastCurvesSet`;
}
if ( `objExists ZEdgeCurvesSet` == 0  ) {
string $newSet1 = `sets -name ZEdgeCurvesSet`;
}
if ( `objExists ZPlaneCurvesSet` == 0  ) {
string $newSet2 = `sets -name ZPlaneCurvesSet`;
}
   global int $xii;
global int $xii = 0;
int $script_jobToolChangedNum1 = 505;
int $script_jobToolChangedNum2 = 606;
int $scriptt_jobAllCurvesToolsNumA;
int $scriptt_jobAllCurvesToolsNumB;
 int $jobNumtranslateCAM;
int $jobNumrotateCAM;
 int $addNumbersA;
$addNumbersA = 0;
global int $script_jobNumIdle_MoveZCURVEM;
global string $dialogBoxWin;
 global string $EdgeCurveZ2[];
global int $plainNum;
clear $EdgeCurveZ2;
  global int $plainNum = 0;
 global string $CamConeLocator[];
string $newCAMSet1;


                       if ( `objExists ZCURVEModelingCAM` == 0  ) {
handleScriptEditorAction "toggleSuppressInfos";
handleScriptEditorAction  "toggleSuppressWarnings";
handleScriptEditorAction "toggleSuppressErrors";
setWireframeOnShadedOption 1 modelPanel4;
 $CamConeLocator = `CreateCAMforIntCurveScript`;
if ( `objExists CamConeLocatorSet` == 0  ) {
$newCAMSet1 = `sets -name CamConeLocatorSet`;
sets -include CamConeLocatorSet $CamConeLocator;
}
createStageOneForRetopo;
select -r $CamConeLocator;
HideSelectedObjects;
shadingNode -asShader lambert;
$material = `shadingNode -asShader lambert -name  LIVEsurfaceslambert`;
	$sg = `sets -renderable true - noSurfaceShader true -empty -name ($material +  "SG")`;
setAttr "LIVEsurfaceslambert.transparency" -type  double3 1 1 1 ;
defaultNavigation -source LIVEsurfaceslambert - destination  |LiveSurfaceB|LiveSurfaceBShape.instObjGroups[0]  - connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert",  "LiveSurfaceBShape.instObjGroups[0]");
defaultNavigation -source LIVEsurfaceslambert - destination |Zplane|ZplaneShape.instObjGroups[0]  -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert",  "ZplaneShape.instObjGroups[0]");
defaultNavigation -source LIVEsurfaceslambert - destination |Xplane|XplaneShape.instObjGroups[0]  -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert",  "XplaneShape.instObjGroups[0]");
 }
if (( `objExists ZCURVEModelingCAM` == 1  )&& (  `objExists layerCurvesINRange1` == 1 )) {
setAttr "ZCURVEModelingCAM.centerOfInterest"  75;
//select -r ZCURVEModelingCAM ;
//select -tgl LiveSurfaceB ;
//scale -r 10 10 10 ; // SEt Camera Scale

if ( `objExists CamConeLocatorSet` == 1  ) {
eval( "global string $CamConeLocator[];");
eval( "$CamConeLocator= `sets -q  CamConeLocatorSet`;");
}
}
//

 if ( `objExists LocOnLivePlaneB` == 0  ) {
createDisplayLayer -name "LocOnLivePlaneB" - number 1 -empty;
setAttr LocOnLivePlaneB.color 9;
}
if ( `objExists LocCurveEnds` == 0  ) {
createDisplayLayer -name "LocCurveEnds" - number 1 -empty;
setAttr LocCurveEnds.color 13;
}

if ( `objExists layerMidPoint` == 0  ) {
createDisplayLayer -name "layerMidPoint" - number 1 -empty;
setAttr layerMidPoint.color 14;
}


////////

EvalAllCurvesToolZ;
int $scriptt_jobNumConnectionChanged = `scriptJob -conditionChange delete evalVectorIndexAdditionSubtract`;
eval(" $jobNumtranslateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.translate  RUNMoveZCURVEM`;");
eval(" $jobNumrotateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.rotate  RUNMoveZCURVEM`;");

select -r LiveSurfaceB ;
MakeLive;
PencilCurveTool;



////////



*/
/////////////START OF AUTOMATIC SCENE SETUP for STEREOSCRIPTS######################################
/////////////START OF AUTOMATIC SCENE SETUP for STEREOSCRIPTS######################################

proc EvalAllCurvesToolZ(){
	eval("int $scriptt_jobAllCurvesToolsNumAZ =  `scriptJob -event DagObjectCreated  AutoCurveScriptsTwoCurve -compressUndo true -protected  `;");
}

proc RUNMoveZCURVEM(){
	int $script_jobNumIdle_MoveZCURVEM = `scriptJob   -runOnce 1 -event idle EVALCamScripts`;
}

 proc createStageOneForRetopo(){
nurbsPlane -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u  1 -v 1 -ch 1 -n Zplane;
 rotate -r -os 0 0 -90 ;
setAttr "Zplane.scaleX" 3000;
setAttr "Zplane.scaleY" 3000;
setAttr "Zplane.scaleZ" 3000; 
nurbsPlane -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u  1 -v 1 -ch 1 -n Xplane;
setAttr "Xplane.scaleX" 3000;
setAttr "Xplane.scaleY" 3000;
setAttr "Xplane.scaleZ" 3000;
editDisplayLayerMembers -noRecurse  NurbsPlanes "Zplane";
editDisplayLayerMembers -noRecurse  NurbsPlanes "Xplane";
layerEditorLayerButtonVisibilityChange NurbsPlanes;
curve -d 3 -p 0 0 0 -p 0 0 4 -p 0 0 8 -p 0 0 12  -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -n Zcurvez;
curve -d 3 -p 0 0 0 -p 4 0 0 -p 8 0 0 -p 12 0 0  -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -n Xcurvez;
if ( `objExists layerZcurvez` == 0  ) {
createDisplayLayer -name "layerZcurvez" -number 1  -empty;
setAttr layerZcurvez.color 6;
editDisplayLayerMembers -noRecurse layerZcurvez  Zcurvez;
}
 if ( `objExists layerXcurvez` == 0  ) {
createDisplayLayer -name "layerXcurvez" -number 1  -empty;
setAttr layerXcurvez.color 13;
editDisplayLayerMembers -noRecurse layerXcurvez  "Xcurvez";
}
}

proc int[] SortNumbersIntIndex(float $allFloatToSort[]){
	int $IndexTrack[];
	float $aF[] = $allFloatToSort;
	int $sIze = `size($aF)`-1;      
	$IndexTrack = CreateIntIndex(`size($aF)`);
	quickSort($aF, $IndexTrack, 0, $sIze);
	$IndexTrack = ReverseIntArray($IndexTrack);
	return $IndexTrack;
}
proc quickFix(){
	global vector $ObjVec[];
	global string $GlobalObjListA[];
	string $quickFix[] = `sets -q ExistingCurveZSet`;
	vector $FixVec[] = PointArrayT($quickFix);
	$GlobalObjListA=$quickFix;
	$ObjVec=$FixVec;
}
proc evalVectorIndexAdditionSubtract(){
	global vector $ObjVec[];
	global string $GlobalObjListA[];
	vector $objVecMain[];
	$objVecMain  = $ObjVec;
	int $intIndexCurveZ[] =  CreateIntIndex(`size($objVecMain)`) ;
	vector $firstReduction[];
	clear $firstReduction;
	string $GetObjList[];
	$GetObjList = `sets -q ExistingCurveZSet`;
	string $KnowObjList[] = $GlobalObjListA;
	string $NewObjList[];
	string $diffAZ[] = stringArrayRemoveExact($GetObjList,$KnowObjList);
	string $diffCZ[] = stringArrayRemoveExact($KnowObjList, $GetObjList);
	if((`size($diffCZ)`>0)||(`size($diffAZ)`>0)){
		if(`size($diffAZ)`>0){
			string $diffBZ[] = stringArrayRemoveExact($diffAZ,$KnowObjList);
			$NewObjList= $diffBZ;
			int $indexNumberZ[] = stringArrayGmatchArrayIndex($diffBZ, $KnowObjList);
			int $indexX= 0;
			for ($eachVec in $indexNumberZ){
				$firstReduction[`size($firstReduction)`]= $objVecMain[$eachVec];
			}
		}
		if(`size($diffCZ)`>0){
			vector $newAddedVec[] = PointArrayT($diffCZ);
			int $iXn = 0;
			for ($eachVecB in $newAddedVec){
				$firstReduction[`size($firstReduction)`]=  $eachVecB ;
				stringArrayInsertAtIndex(`size($NewObjList)`, $NewObjList, $diffCZ[$iXn]); 
				$iXn++;
			}
		}
		$GlobalObjListA = $NewObjList;
		clear $ObjVec;
		$ObjVec= $firstReduction;
	}
}
proc string[] MoveZCURVEModelingCAM2010(string $EdgeCurves[], string $CamConeLocator[], vector $ObjVecX[]){
	RemoveNoLongerExistingFromArray($EdgeCurves);
	string $listofallcurves[];
	$listofallcurves = $EdgeCurves;
	string $ObjectsINcamLightCone[];
	string $OutofRange[];
	layerEditorRemoveObjects layerCurvesINRange1 ;
	editDisplayLayerMembers -noRecurse "defaultLayer"  $ObjectsINcamLightCone;
	layerEditorRemoveObjects layerCurvesOutofRange1 ;
	editDisplayLayerMembers -noRecurse "defaultLayer"  $OutofRange;
	clear $ObjectsINcamLightCone;
	if ( `objExists LocOnLivePlaneB` == 0  ) {
		createDisplayLayer -name "LocOnLivePlaneB" - number 1 -empty;
		setAttr LocOnLivePlaneB.color 9;
	}
	queryLocOnLivePlaneBLayerDelete;
	queryLocCurveEndsLayerDelete;
	querylayerMidPointLayerDelete;
	string $shortnameL;
	catch ( $shortnameL = "PlaneLOC*");
	if ( `objExists $shortnameL` == 1  ) {
		catch (`delete $shortnameL`);
	}
	string $CurveItem[] = $listofallcurves;
	ResetTransEachSL;
	string $NurbplaneB = "LiveSurfaceBShape";
	vector $VecArrayRemainsZ[]; clear $VecArrayRemainsZ;
	string $ObjectsInFrontZ[]; clear $ObjectsInFrontZ;
	$ObjectsInFrontZ = GetObjectsInFrontOfPlane2($CurveItem, $ObjVecX, $VecArrayRemainsZ);
	string $LocPointinPlane[];
	if(`size($ObjectsInFrontZ)`>0){
		vector $AllLocPositionsZ[];
		clear $AllLocPositionsZ;
		vector $AllPlaneLocPositionZ[]= VecPointsToCameraPlane($VecArrayRemainsZ);
		int $newOrderA[];
		$LocPointinPlane = PointInNurbPlane($AllPlaneLocPositionZ, $ObjectsInFrontZ, $newOrderA, 0);
	}
	if(`size($LocPointinPlane)`>0){
		string $LocCurveEnds[];
		string $AllLocCurveEnds[];
		int $indexLoc = 0;
		vector $AllCurveLocArrayVec[];
		for ($each in $LocPointinPlane){
			stringArrayInsertAtIndex(0,  $ObjectsINcamLightCone, $each); 
			$LocCurveEnds = LocCurveEnds({$each},$AllCurveLocArrayVec);
			appendStringArray($AllLocCurveEnds, $LocCurveEnds, size($LocCurveEnds));
		}
		vector $AllCurvePlaneLocZ[];
		clear $AllCurvePlaneLocZ;
		$AllCurvePlaneLocZ = VecPointsToCameraPlane($AllCurveLocArrayVec);
		select -cl  ;
		string $CurveLocPlanePoints[];
		int $newOrderB[];
		$CurveLocPlanePoints = PointInNurbPlane($AllCurvePlaneLocZ, $AllLocCurveEnds, $newOrderB, 1);
	}
	string $shorterList[] =  stringArrayRemoveDuplicates ($ObjectsINcamLightCone);
	$ObjectsINcamLightCone = $shorterList;
	$OutofRange = stringArrayRemoveExact ($ObjectsINcamLightCone, $listofallcurves);
	editDisplayLayerMembers -noRecurse  layerCurvesOutofRange1 $OutofRange;
	editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ObjectsINcamLightCone;
	return $ObjectsINcamLightCone;
}
proc CatchMoveZCURVECAM2010(string $EdgeCurveZa[], string $CamConeLocator[], vector $ObjVecX[]){
	global string $StereoCurveZ[];
	global string $VanishingPointsLinesTempGuides[];
	global int $addNumbersA;
	quickFix;
	if ( catchQuiet(MoveZCURVEModelingCAM2010 ($EdgeCurveZa, $CamConeLocator, $ObjVecX ))) {
		evalVectorIndexAdditionSubtract;
		MoveZCURVEModelingCAM2010($EdgeCurveZa, $CamConeLocator, $ObjVecX );
		clear $StereoCurveZ;
		clear $VanishingPointsLinesTempGuides;
		$addNumbersA =0;
		quickFix;
	} else {
		clear $StereoCurveZ;
		$addNumbersA =0;
		quickFix;
	}
}
proc string[] queryLocOnLivePlaneBLayer(){
	string $queryLocB[];
	$queryLocB = `editDisplayLayerMembers  -q LocOnLivePlaneB`;
	int $IfemptyIsTrue = 0;
	if (`size( $queryLocB)` > 0){
		$IfemptyIsTrue = 0;
	}
	if (`size( $queryLocB)`== 0){
		$IfemptyIsTrue = 1;
	} 
	return $queryLocB;
}
proc queryLocOnLivePlaneBLayerDelete(){
	string $queryLocOnLivePlaneB[];
	$queryLocOnLivePlaneB = `editDisplayLayerMembers  -q LocOnLivePlaneB`;
	if (`size( $queryLocOnLivePlaneB)` > 0){
		delete  $queryLocOnLivePlaneB;
	}
}
proc queryLocCurveEndsLayerDelete(){
	string $queryLocCurveEnds[];
	$queryLocCurveEnds = `editDisplayLayerMembers  -q LocCurveEnds`;
	if (`size($queryLocCurveEnds)` > 0){
		delete $queryLocCurveEnds;
	}
}
proc querylayerMidPointLayerDelete(){
	string $querylayerMidPoint[];
	$querylayerMidPoint = `editDisplayLayerMembers  -q layerMidPoint`;
	if (`size($querylayerMidPoint)` > 0){
		delete $querylayerMidPoint;
	}
}
proc string[] LocCurveEnds(string $CurveItem[], vector $CurveLocArrayVec[]){
	string $CurveSelection[];
	int $numCVs = `getAttr -size ($CurveItem[0]+".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 
	$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
	float $EACHCVposAZ[]; float $EACHCVposBZ[]; int $numIntZB = 0; string $MakeXBetweenB[];
	float $eachCVpos[];
	for ($eachZA in $CurveSelection) {       
		$eachCVpos = `pointPosition -w ($eachZA)`;
		$numIntZB = $numIntZB + 1;
		if ( $numIntZB == 1 ){$EACHCVposAZ = $eachCVpos;}
		if ( $numIntZB == 2 ){$EACHCVposBZ = $eachCVpos;}
	}
	string $NameStart = ("LOC"+$CurveItem[0]+"START");
	string $NameEnd = ("LOC"+$CurveItem[0]+"END");
	string $LocSTART[] = `spaceLocator -p 0 0 0 -n $NameStart`;
	MoveObject2($EACHCVposAZ);
	string $LocEND[] = `spaceLocator -p 0 0 0 -n $NameEnd`;
	MoveObject2($EACHCVposBZ);
	string $STARTENDcurveLocs[] = { $LocSTART[0], $LocEND[0]};
	setAttr ($LocSTART[0]+".scaleX") 0.5;
	setAttr ($LocSTART[0]+".scaleY") 0.5;
	setAttr ($LocSTART[0]+".scaleZ") 0.5;
	setAttr ($LocEND[0]+".scaleX") 0.5;
	setAttr ($LocEND[0]+".scaleY") 0.5;
	setAttr ($LocEND[0]+".scaleZ") 0.5;
	$CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
	$CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
	editDisplayLayerMembers -noRecurse LocCurveEnds $STARTENDcurveLocs;
	select -cl  ;
	return $STARTENDcurveLocs;
}
proc vector [] VecCurveEps(string $CurveItem ){
	vector $CurveLocArrayVec[];
	string $CurveSelection[];
	$CurveSelection = `ls -fl ($CurveItem+".ep[0:*]")`; 
	float $EACHCVposAZ[];
	for ($eachZA in $CurveSelection) {       
		$EACHCVposAZ = `pointPosition -w ($eachZA)`;
		$CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
	}
	return $CurveLocArrayVec;
}
proc vector [] VecCurveCvs(string $CurveItem ){
	vector $CurveLocArrayVec[];
	string $CurveSelection[];
	$CurveSelection = `ls -fl ($CurveItem+".cv[*]")`; 
	float $EACHCVposAZ[];
	for ($eachZA in $CurveSelection) {       
		$EACHCVposAZ = `pointPosition -w ($eachZA)`;
		$CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
	}
	return $CurveLocArrayVec;
}
proc vector[] PointArrayT(string $ObjectList[]){
	float $pointAZ1[];
	vector $VecArray[];
	int $XiV = 0;
	for ($each in $ObjectList){
		if (catch($pointAZ1 = `xform -q -ws -t ($each)`)){
			$pointAZ1 = `pointPosition -w ($each)`;
		} 
		$VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
		$XiV++;
	}
	return $VecArray;
}
proc vector[] PointArray(string $ObjectList[]){
	float $pointAZ1[];
	vector $VecArray[];
	int $XiV = 0;
	for ($each in $ObjectList){
		if (catch($pointAZ1 = `pointPosition -w ($each)`)){
			$pointAZ1 = `xform -q -ws -rp ($each)`;
		} 
		$VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
		$XiV++;
	}
	return $VecArray;
}
proc string [] GetObjectsInFrontOfPlane2(string $Loc[], vector $VecArray[], vector $VecArrayRemainsB[] ){
	float $CamPlane1[],$ObjectToCam,$ObjToCamdistShiftDiff;
	$CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
	vector $CamerasDirectionVectorNormal =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
	string $ObjectList[];
	int $IndexVec = 0;
	vector $VecArrayRemains[];
	int $IndexVecRemain = 0;
	string $ObjectsInFrontOfPlane[];
	clear $ObjectsInFrontOfPlane;
vector $ObjectToCamShiftA;
	for ($eachPoint in $VecArray){
		 $ObjectToCam = distance2Pts( $CamPlane1, $VecArray[$IndexVec]);
		 $ObjectToCamShiftA = ($CamerasDirectionVectorNormal* 10.5)+$VecArray[$IndexVec];
		 $ObjToCamdistShiftDiff = distance2Pts( $CamPlane1, $ObjectToCamShiftA);
		if($ObjToCamdistShiftDiff<$ObjectToCam){
			stringArrayInsertAtIndex(`size($ObjectsInFrontOfPlane)`, $ObjectsInFrontOfPlane, $Loc[$IndexVec]);
			$VecArrayRemains[$IndexVecRemain]= $VecArray[$IndexVec];
			$IndexVecRemain++;
		}
		$IndexVec++;
	}
	$VecArrayRemainsB = $VecArrayRemains;
	return $ObjectsInFrontOfPlane;
}
proc string [] PointInNurbPlane(vector $AllPlaneLocPosition[], string $ObjectsInFront[], int $Newindex[], int $Locint ){
	string $EdgesSurface[];
	clear $EdgesSurface;
	$EdgesSurface[0] = "LiveSurfaceBShape.cv[0][0]" ;
	$EdgesSurface[1] = "LiveSurfaceBShape.cv[0][3]" ;
	$EdgesSurface[2] = "LiveSurfaceBShape.cv[3][3]" ;
	$EdgesSurface[3] = "LiveSurfaceBShape.cv[3][0]" ;
	vector $SurfEnds[] = PointArray($EdgesSurface);
	vector $MiddlePointA[];
	$MiddlePointA[0] = FloatToVec(MidPoint($SurfEnds[0], $SurfEnds[1]));
	$MiddlePointA[1] = FloatToVec(MidPoint($SurfEnds[1], $SurfEnds[2]));
	$MiddlePointA[2] = FloatToVec(MidPoint($SurfEnds[2], $SurfEnds[3]));
	$MiddlePointA[3] = FloatToVec(MidPoint($SurfEnds[3], $SurfEnds[0]));
	float $AveragePoints[] = `xform -q -ws -t LiveSurfaceB`;
	vector $DirectionsToCent[];
	clear $DirectionsToCent;
	for ($each in $MiddlePointA){
		float $Direct[] = DirectionF( $each, $AveragePoints);
		$DirectionsToCent[size($DirectionsToCent)] = <<$Direct[0], $Direct[1], $Direct[2]>>;
	}
	float $PlaneDimentionsV = distance2Pts( $SurfEnds[0], $SurfEnds[1]);
	float $PlaneDimentionsH = distance2Pts( $SurfEnds[1],$SurfEnds[3]);
	int $IndexV[] = CreateIntIndex(`size($AllPlaneLocPosition)`);
	float $RadiusMax = distance2Pts( $AveragePoints, $SurfEnds[0]);
	int $IndexReduced[];
	float $FoundDistance;
	int $indexRecord = 0;
	vector $firstReduction[];
	for ($eachVec in $AllPlaneLocPosition){
		$FoundDistance = distance2Pts( $AveragePoints, $eachVec);
		if($FoundDistance<=$RadiusMax){
			$IndexReduced[`size($IndexReduced)`] = $IndexV[$indexRecord];
			$firstReduction[`size($firstReduction)`]= $eachVec;
		}
		$indexRecord++;
	}
	float $PlaneDimentionsVH = $PlaneDimentionsV/100;
	float $PlaneDimentionsHH = $PlaneDimentionsH/100;
	int $indexPoints = 0;
	vector $PointsZ[] = $firstReduction;
	vector $AllPointsInplane[];
	int $Lastindex = 0;
	int $lastIntIndex[];
	int $indexM = 0;
	int $FourDiections = 0;
	for ($eachPoint in $firstReduction){
		float $LocPoint[] = $eachPoint;
		$indexM = 0;
		$FourDiections = 0;
		float $MultDirAV[];
		for ($each in  $DirectionsToCent){
			float $DistanceA = distance2Pts( $MiddlePointA[$indexM],  $LocPoint);
			if(($indexM==0)||($indexM==2)){
				$MultDirAV= multiplyFloat($PlaneDimentionsVH, $each);
			}
			if(($indexM==1)||($indexM==3)){
				$MultDirAV= multiplyFloat($PlaneDimentionsHH, $each);
			}
			float $FloatDirectionPointz[] = AddFloats($MultDirAV, $LocPoint);
			float $DistanceB = distance2Pts( $MiddlePointA[$indexM],  $FloatDirectionPointz);
			if( $DistanceB > $DistanceA){
				$FourDiections++;
			}
			$indexM++;
		}
		if( $FourDiections == 4 ){
			$AllPointsInplane[`size($AllPointsInplane)`]= $eachPoint;
			$lastIntIndex[$Lastindex]=  $IndexReduced[$indexPoints];
			$Lastindex++;
		}
		$indexPoints++;
	}
	string $allObjectsInPlane[];
	for ($eachNumber in $lastIntIndex){
		stringArrayInsertAtIndex(`size($allObjectsInPlane)`, $allObjectsInPlane, $ObjectsInFront[$eachNumber]);
	}
	$Newindex = $lastIntIndex;
	vector $NewVecArray[];
	for ($eachNumber in $lastIntIndex){
		$NewVecArray[`size($NewVecArray)`] =$AllPlaneLocPosition[$eachNumber];
	}
	$AllPlaneLocPosition=$NewVecArray;
	if($Locint==1){
		int $inDexName =0;
		for ($each in $AllPointsInplane){
			string $stringName = ("Plane"+ $allObjectsInPlane[$inDexName]);
			spaceLocator -p 0 0 0 -n $stringName;
			MoveObject2($each);
			scale -r 0.01 0.01 0.01;
			editDisplayLayerMembers -noRecurse LocOnLivePlaneB $stringName;
			$inDexName++;
		}
	}
	return $allObjectsInPlane;
}
proc float[] MirrorFloatXYZ(int $XYZ, float $ThreeFLoatArrays[]){
	float $Zx[] = $ThreeFLoatArrays;
	$Zx[$XYZ] *= -1.0;
	return $Zx;
}
proc float[] nurbsViewDirectionVectorCam( string $cameraName , int $onlyOrtho )
{
	float $result[];
	string $isitYup = `upAxis -q -ax $cameraName`;
	if( "y" == $isitYup ) {
		$result[0] = 0.0 ;
		$result[1] = 1.0 ;
		$result[2] = 0.0 ;
	}
	else {
		$result[0] = 0.0 ;
		$result[1] = 0.0 ;
		$result[2] = 1.0 ;
	}
	string $forTheWarning = "Failed to compute active camera view direction." +
	"  Using the default (" + $result[0] + "," +
	$result[1] + "," + $result[2] + ")";
	if( $onlyOrtho && !`camera -q -o $cameraName` ) {
		return $result;
	}
	float $coiDistance = 0.0 ;
	if( catch( $coiDistance = `camera -q -coi $cameraName` )) {
		warning $forTheWarning;
		return $result ;
	}
	string $selectionList[] = `ls -sl`;
	string $ppm ;
	if( catch($ppm = `createNode pointMatrixMult`) ) {
		warning $forTheWarning;
		select -r $selectionList;
		return $result ;
	}
	select -r $selectionList;
	setAttr ($ppm +".inPoint") -type double3 0.0 0.0 (-$coiDistance) ;
	setAttr ($ppm +".vectorMultiply") true ;
	connectAttr ($cameraName+".worldMatrix[0]") ($ppm+".inMatrix") ;
	float $coi[] = `getAttr ($ppm+".output")` ;
	delete $ppm ;
	int $i ;
	float $sum = 0;
	for( $i = 0 ; $i < 3 ; $i++ ) {
		$sum += ($coi[$i] * $coi[$i]);
		$result[$i] = $coi[$i];
	}
	if( $sum > 0 ) {
		$sum = -1.0/sqrt($sum);
		for( $i = 0 ; $i < 3 ; $i++ ) {
			$result[$i] = $result[$i] * $sum;
		}
	}
	return $result ;
}
proc string Loc(float $Points[]){
	string $LocObjects[] = `spaceLocator -p 0 0 0`;
	setAttr ($LocObjects[0]+".translate")  $Points[0] $Points[1] $Points[2];
	return $LocObjects[0];
}
proc string getTypeItemString(string $selectionFindType[]){
	$selectionFindType= `ls -fl $selectionFindType`;
	string $idnodeType2;
	string $Relativesselection[];
	if(`size($selectionFindType)`>0){
		$Relativesselection = `listRelatives $selectionFindType[0]`;
		if (`size($Relativesselection)` == 0){ string $idnodeType3[] = `nodeType -inherited $selectionFindType[0]`;
			int $Value = stringArrayGmatchFind($idnodeType3, "controlPoint");
			if($Value == 1){ $idnodeType2="controlPoint";}else{ $idnodeType2=$idnodeType3[(`size($idnodeType3)`)-1];}
		}else{ $idnodeType2 = `nodeType $Relativesselection[0]`;}
	}else{ $idnodeType2 = "EMPTY";}
	return $idnodeType2;
}
proc int [] stringArrayGmatchArrayIndex(string  $itemA[], string $list[]){
	int $sizeitem = `size($itemA)`;
	int $result = false;
	int $ResultIndex[];
	int $Index = 0;
	int $BreakTrigger = 0;
	string $listItem;
	for ($EachlistItem in $list) {
		for ($EachlistA in $itemA) {
			if ( $EachlistItem == $EachlistA ){
				$result = true; $ResultIndex[`size($ResultIndex)`] =  $Index;
				$BreakTrigger++;
				if ( $BreakTrigger == $sizeitem ){	break;	}
			}
		}
		$Index++;
	}
	return $ResultIndex;
}
proc int stringArrayGmatchFind(string $itemsA[], string $Item){
	int $result = false;
	for ($EachlistA in $itemsA) {
		if ( $EachlistA == $Item ){
			$result = true; 
			break;	}
	}	return $result;
}
proc float [] ArrayDistancesVecTofloat(vector $allVec[], float $point[]){
	float $AllDistances[];
	for ($each in $allVec){
		$AllDistances[`size($AllDistances)`] = distance2Pts( $each, $point);
	}
	return $AllDistances;
}
proc float [] MovePointDirectionAndDistance( float $Direction[], float $Distance, float $PointA[]){
	float $MultDirDist[] = multiplyFloat($Distance ,$Direction);
	float $FloatPointLoc[] = AddFloats($PointA, $MultDirDist);
	return $FloatPointLoc;
}
proc SetItemColorString( string $isSelectedZz, int $Color ){
	if ( `objExists $isSelectedZz` == 1  ) {
		$ColorN = $Color;
		if ( $Color > 31  ) { $ColorN = $ColorN -31;}
		string $isSelectedZx[];
		$isSelectedZx = `listRelatives $isSelectedZz`;
		setAttr ($isSelectedZx[0]+".overrideEnabled ") 1;
		if (catch (`setAttr ($isSelectedZx[0]+".overrideColor ") $ColorN `)){
			setAttr ($isSelectedZx[0]+".overrideColor ") 1;}
	}
}
proc MoveObject2(float $FloatPos[]){
	move -ws $FloatPos[0] $FloatPos[1] $FloatPos[2] ;
}
proc float[] AverageVectorPoint(vector $worldPosZ[]) {
	int $vectorSize = `size($worldPosZ)`;
	int $vecCount = `size($worldPosZ)`;
	float $Added_floats[] = { 0.0, 0.0, 0.0};
	float $FloatFromVec[];
	float $VposA;
	float $VposB;
	float $VposC;
	int $Vii = 0;
	while ($Vii < $vecCount){
		float $FloatFromVecA[] = $worldPosZ[$Vii];
		$VposA = $FloatFromVecA[0];
		$VposB =  $FloatFromVecA[1];
		$VposC =  $FloatFromVecA[2];
		$Added_floats = {($FloatFromVecA[0]+$Added_floats[0]), ($FloatFromVecA[1]+$Added_floats[1]), ($FloatFromVecA[2]+$Added_floats[2])} ;
		$Vii++;
	}
	float $a = ($Added_floats[0])/float($vectorSize);
	float $b = ($Added_floats[1])/float($vectorSize);
	float $c = ($Added_floats[2])/float($vectorSize);
	float $PointsAverage[] = {$a , $b , $c};
	return $PointsAverage;
}
global proc int[] ArrayToIntList(string  $singleStringItemB[]){
	int $Numberlist[];
	int $triggerendsB = 0;
	int $newlistSize = size($singleStringItemB);
	int $ci = 0;
	while ( $triggerendsB < $newlistSize ) { 
		$Numberlist[$ci] = $singleStringItemB[$ci];
		$ci++;
		$triggerendsB = $triggerendsB + 1;
	}
	return $Numberlist;
}
proc int[] ReverseIntArray(int $array[]){
	int	$arrayOut[];
	for($i=0;$i<size($array);$i++){
		$arrayOut[$i]=$array[(size($array)-1-$i)];}
	return $arrayOut;
}
proc string[] ReverseStringArray(string $array[]){
	string	$arrayOut[];
	for($i=0;$i<size($array);$i++){
		$arrayOut[$i]=$array[(size($array)-1-$i)];}
	return $arrayOut;
}
proc vector[] ReverseVectorArray(vector $array[]){
	vector	$arrayOut[];
	for($i=0;$i<size($array);$i++){
		$arrayOut[$i]=$array[(size($array)-1-$i)];}
	return $arrayOut;
}
proc vector[] MagTimesUnitVecs(vector  $vectorZFlatYHigher, vector $vectorZFlatYLower){
	float $MagVectorZYHigher = mag ($vectorZFlatYHigher); 
	float $MagVectorZYLower = mag ($vectorZFlatYLower); 
	vector $unitVectormagZYHL[];
	$unitVectormagZYHL[0] = $MagVectorZYHigher *  unit($vectorZFlatYHigher);
	$unitVectormagZYHL[1] = $MagVectorZYLower * unit ($vectorZFlatYLower);
	return $unitVectormagZYHL;
}
proc float[] AddFloats(float $posA[], float  $posB[]){
	float $AddposA_AND_posB_float[];
	$AddposA_AND_posB_float = {($posA[0] + $posB[0]),  ($posA[1] + $posB[1]), ($posA[2] + $posB[2])} ;
	return $AddposA_AND_posB_float;
}
proc float[] SubtractFloats(float $posA[], float  $posB[]){
	float $SubtractposA_AND_posB_float[];
	$SubtractposA_AND_posB_float = {($posA[0] -  $posB[0]), ($posA[1] - $posB[1]), ($posA[2] -  $posB[2])} ;
	return $SubtractposA_AND_posB_float;
}
proc float[] multiplyFloatArray(float  $posA, float $posB[]){
	float $Timespos[];
	for($eachF in $posB){
		$Timespos[`size($Timespos)`] = $eachF*$posA;
	}
	return $Timespos;
}
proc vector FloatToVec(float $posA[]){
	vector $xvex = << $posA[0], $posA[1], $posA[2] >>  ;
	return $xvex;
}
proc float[] MakeCleanFloats(float $FloatZ[]){
	string $POSAe = $FloatZ[0]; string $POSBe =  $FloatZ[1];
	string $POSCe = $FloatZ[2];
	string $nameAe; string $nameBe; string $nameCe;
	$nameAe = `match "e" $POSAe`;
	$nameBe = `match "e" $POSBe`;
	$nameCe = `match "e" $POSCe`;
	int $zeroORZe1 = `gmatch "e" $nameAe`;
	int $zeroORZe2 = `gmatch "e" $nameBe`;
	int $zeroORZe3 = `gmatch "e" $nameCe`;
	if ( $zeroORZe1 == 1){ $FloatZ[0] = 0.0; }
	if ( $zeroORZe2 == 1){ $FloatZ[1] = 0.0; }
	if ( $zeroORZe3 == 1){ $FloatZ[2] = 0.0; }
	return $FloatZ;
}
proc float[] MakeCleanFloatsZ(float $FloatZ[]){
	string $POSAe[] = FloatArrayToStringArray( $FloatZ);
	float $FloatZi[];
	int $index =0;
	for ($eachS in $POSAe){
		string $POSAe = $eachS;
		string $nameAe;
		$nameAe = `match "e" $POSAe`;
		int $zeroORZe1 = `gmatch "e" $nameAe`;
		if (( $zeroORZe1 == 1)||( $eachS == -0)){ $FloatZi[$index] = 0.0;
		}else{$FloatZi[$index] = $FloatZ[$index];}
		$index++;
	}
	return $FloatZi;
}
proc float[] MidPoint(float $loc1[],  float $loc2[]) {
	float $a = ($loc2[0] + $loc1[0]) * (0.5);
	float $b = ($loc2[1] + $loc1[1]) * (0.5);
	float $c = ($loc2[2] + $loc1[2]) * (0.5);
	float $vPoint[] = {$a , $b , $c};
	return $vPoint;
}
proc PAUSE(){
	playButtonStepForward;
}
proc averagingNode(string $firstObjectz, string  $averageObjectz, string $LastObjectz){
	string $averaging[];
	$averaging[0] = `shadingNode -asUtility  plusMinusAverage`;
	setAttr ($averaging[0] + ".operation") 3;   
	connectAttr -force ( $firstObjectz +  ".translate")($averaging[0] + ".input3D[1]"); 
	connectAttr -force ($averaging[0] + ".output3D") ("|" + $averageObjectz + ".translate");                                          
	connectAttr -force ( $LastObjectz +  ".translate")($averaging[0] + ".input3D[0]"); 
}
proc ResetTranslation(string $oneItemz[]){
	xform -cp $oneItemz[0];
	vector $worldPos = `xform -q -ws -rp  $oneItemz[0]`;
	move -rpr 0 0 0  $oneItemz[0];
	makeIdentity -apply true  -t 1 -r 0 -s 0 $oneItemz[0];
	xform -t ($worldPos.x)  ($worldPos.y) ($worldPos.z) $oneItemz[0];
}
proc string[] RemoveNoLongerExistingFromArray (string $EdgeCurveZ1[]){
	int $SizeOfArrayA = size($EdgeCurveZ1);
	if ( $SizeOfArrayA > 0){
		int $SizeOfArray = size($EdgeCurveZ1) -1;
		int $i = -1;
		int $E = -1;
		while( $E < $SizeOfArray ){
			$i++;
			$E++;
			if ( `objExists $EdgeCurveZ1[$i]` == 0  ) {
				stringArrayRemoveAtIndex($i, $EdgeCurveZ1);
				if ($i == 0) { $i = -1;} else { $i = $i -1;}   
			}
		}
		int $SizeOfArrayB = size($EdgeCurveZ1);
	}
	return $EdgeCurveZ1;
}
proc int ISobjectSelectedTypeCurve(){
	string $C[];
	$C = `ls -sl`;
	string $nametypeZ[] = `ls -showType $C`;
	string $nameA;
	$nameA = `match "[a-zA-Z]+" $nametypeZ[0]`;
	int $zeroOR1Z = `gmatch "Curve" $nameA`;
	return $zeroOR1Z;
}
proc int addNumbers(){
	int $CreatedObjectCurve =  `ISobjectSelectedTypeCurve`;
	return $CreatedObjectCurve; 
}
proc int  PtsEquivalentF( float $posA[],  float $posB[], float $TRange){
	int $pX = equivalentTol($posA[0], $posB[0], $TRange);
	int $pY = equivalentTol($posA[1], $posB[1], $TRange);
	int $pZ = equivalentTol($posA[2], $posB[2], $TRange);
	int $addedResults = $pX + $pY + $pZ;
	if ($addedResults == 3 ){return 1;
	}else{
		return 0;}
}
proc CurveIndexVecTracking(string $OBJ[]){
	string $OBJall[] = `sets -q CurveZSetOne` ;
	if(`size($OBJall)`>0){
		sets -remove CurveZSetOne $OBJall;
	}
	global string $GlobalObjOne[];
	global vector $ObjCurv[];
	sets -include CurveZSetOne $OBJ;
	eval("$GlobalObjOne= `sets -q CurveZSetOne`");
	eval("appendStringArray($GlobalObjListA,$GlobalObjOne, 1)");
	eval("vector $ObjCurv[] = PointArrayT($GlobalObjOne);");
	eval("$ObjVec[`size($ObjVec)`] =  $ObjCurv[0]");
	eval("sets -include ExistingCurveZSet $GlobalObjOne");
	sets -remove CurveZSetOne $OBJ;
}
proc EVALCamScripts(){
	$runit = "CatchMoveZCURVECAM2010($GlobalObjListA, $CamConeLocator, $ObjVec );";
	eval($runit); }
proc string [] IntArrayToStringArray(int $IntArray[]){
	string $Intnumbers;
	for($each in $IntArray){
		$Intnumbers += $each+" ";
	}
	string $array[];
	$array = stringToStringArray($Intnumbers, " ");
	return $array;
}
proc string [] FloatArrayToStringArray(float $FloatArray[]){
	string $floatnumbers;
	for($each in $FloatArray){
		$floatnumbers += $each+" ";
	}
	string $array[];
	$array = stringToStringArray($floatnumbers, " ");
	return $array;
}
proc int [] CreateIntIndex(int $ArraySize){
	int $iNdex = 0;
	int $IntArrayInex[];
	while($iNdex < $ArraySize){
		$IntArrayInex[$iNdex] = $iNdex;
		$iNdex++;
	}
	return $IntArrayInex;
}
proc string curve2points(float $TanEnd1[], float $intersectposD1[]){
	vector $FixVec[];
	$FixVec[0]  = << $TanEnd1[0], $TanEnd1[1], $TanEnd1[2]>>;
	$FixVec[1]  = <<$intersectposD1[0], $intersectposD1[1], $intersectposD1[2]>>;
	int $sIZes = 2;
	int $NUmers[] = CreateIntIndex($sIZes);
	string $K = "";
	for ($eachN in $NUmers){
		$K += "\-k"+" "+$eachN+" ";
	}
	string $curve = "curve -d 1";
	for ($eachVeCx in $FixVec){
		float $valuesBi[] = $eachVeCx;
		$curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
	}
	$curve += " "+ $K;
	string $Newcurvez = `eval($curve)`;
	return $Newcurvez;
}
proc float[] multiplyFloat(float  $posA, float $posB[]){
	float $AddposA_AND_posB_float[];
	$TimesposA_AND_posB_float = {($posA * $posB[0]),  ($posA * $posB[1]), ($posA * $posB[2])} ;
	return $TimesposA_AND_posB_float;
}
proc int ArrayInsertAtEnd( string $INarray[],  string $NewItem){ 
	int $SizeOfArray;
	$SizeOfArray = size($INarray);
	$INarray[$SizeOfArray] = ( $NewItem );
	return $SizeOfArray;
}
proc ResetTransEachSL(){
	string $oneItemz[] = `ls -sl`;
	for ($each in $oneItemz){
		xform -cp $each;
		vector $worldPos = `xform -q -ws -rp   $each`;
		move -rpr 0 0 0 $each;
		makeIdentity -apply true   -t 1 -r 0 -s 0 $each;
		xform -t ($worldPos.x)   ($worldPos.y) ($worldPos.z) $each;
	}
}
proc string [] NewArrayOrderWithIndexKey(string $stringIndexTrack[], string $ObjsCurve[]){
	string $newOrderArray[];
	int $iNew;
	for($each in $stringIndexTrack){
		$iNew = $each;
		stringArrayInsertAtIndex(`size($newOrderArray)`, $newOrderArray, $ObjsCurve[$iNew]);
	}
	return $newOrderArray;
}
proc float [] SortFloatArrayAndString( float $allFloatToSort[], string $ObjsCurve[], string $EmptyStringNewOrder[]){
	float $Floatlist[] = $allFloatToSort;
	int $sIze = `size($allFloatToSort)`-1;
	float $aF[] = $allFloatToSort;
	int $IndexTrack[] = CreateIntIndex(`size($aF)`);
	quickSort($aF, $IndexTrack, 0, $sIze);
	string $stringIndexTrack[]= IntArrayToStringArray($IndexTrack);
	string $newOrderArray[] = NewArrayOrderWithIndexKey($stringIndexTrack, $ObjsCurve);
	$EmptyStringNewOrder = $newOrderArray;
	return $aF;
}
proc string Circles_Direction(float $Point[], float $FloatDir[], float $FloatNum){
	string $circleItem[] = `circle -c $Point[0] $Point[1] $Point[2] 
	-nr $FloatDir[0] $FloatDir[1] $FloatDir[2] 
	-sw 360 
	-r $FloatNum 
	-d 3 -ut 0 -tol 0.001 -s 8 -ch 1`;
	return $circleItem[0];
}
proc  creatStereoCurve(){
	global string $VanishingPointsLinesTempGuides[];
	global int $addNumbersA;
	global string $StereoCurveZ[];
	global int $ifSingleCurve;
	global int $ForceOrthoOFFON;
	if(size($StereoCurveZ)>0){
		RemoveNoLongerExistingFromArray($StereoCurveZ);
	}
	if( $ForceOrthoOFFON == 1){
		$addNumbersA=-3;
		ForceOrtho($StereoCurveZ);
	}
	if( $ForceOrthoOFFON == 0){
		int $x = $addNumbersA;
		print ($addNumbersA + "\n");
		if ($x == 1){
			$VanishingPointsLinesTempGuides = VanishingCurves($StereoCurveZ);
			if( $ifSingleCurve==1){
				delete $VanishingPointsLinesTempGuides;
				clear $VanishingPointsLinesTempGuides;
				clear $StereoCurveZ;
				$addNumbersA =0;
				evalVectorIndexAdditionSubtract;
				EVALCamScripts;
				$ifSingleCurve=0;
			}
		}
		if ($x == 2){
			StereoCurveZ($StereoCurveZ[0], $StereoCurveZ[1]);
			$addNumbersA =0;
		}
	}
}
proc vector[] NewVecOrderWithINTKey(int $IntIndexTrack[], vector $ObjsCurve[]){
	vector $newOrderVec[];
	for($eachVi in $IntIndexTrack){
		$newOrderVec[`size($newOrderVec)`] = $ObjsCurve[$eachVi];
	}
	return $newOrderVec;
}
proc float [] MultLenToDirAddToPoint(float $Length, float $Dir[], float $Pos[]){
	float $MultLengthDir[] = multiplyFloat($Length, $Dir);
	float $AddMultDirPos[] = AddFloats($Pos, $MultLengthDir);
	return $AddMultDirPos;
}
proc int [] CreatePairIntIndex(int $AS){
	int $Ai = 0;
	int $Bi = 0;
	int $N = 0;
	int $store;
	int $IntA[];
	int $Times = $AS*2;
	while($Bi < $Times){
		if($Ai == 0){$IntA[$Bi] = $N;}
		if($Ai == 1){ $Ai = -1; $IntA[$Bi] = $N;
			$N++; }
		$Ai++;
		$Bi++;
	}
	return $IntA;
}
proc vector [] GetRotationVectorsMatrix(matrix $mAtRiX[][]){
	float $MatrizFloatiA[];
	$MatrizFloatiA = MatrixToFloat($mAtRiX);
	vector $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
	vector $VecR[];
	$VecR[0] = $VecAii;
	$VecAii = << $MatrizFloatiA[4], $MatrizFloatiA[5], $MatrizFloatiA[6]>>;
	$VecR[1] =$VecAii;
	$VecAii = << $MatrizFloatiA[8], $MatrizFloatiA[9], $MatrizFloatiA[10]>>;
	$VecR[2] = $VecAii;
	return $VecR;
}
proc vector MultPointMatrix( vector $PtsVec, matrix $mIA[][]){

	float $MatrizFloatiA[] = MatrixToFloat($mIA);
	vector $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
	vector $VecR[];
	$VecR[0] = $VecAii;
	$VecAii = << $MatrizFloatiA[4], $MatrizFloatiA[5], $MatrizFloatiA[6]>>;
	$VecR[1] =$VecAii;
	$VecAii = << $MatrizFloatiA[8], $MatrizFloatiA[9], $MatrizFloatiA[10]>>;
	$VecR[2] = $VecAii;
	float $RowA[] = $VecR[0];
	float $RowB[] = $VecR[1];
	float $RowC[] = $VecR[2];
	float $GivenPoint[] = $PtsVec;
	float $NewPoint[];
	float $NewPointa[];
	float $NewPointb[];
	float $NewPtMatrixMult[];
	$NewPoint = multiplyFloat($GivenPoint[0], $RowA);
	$NewPointa = multiplyFloat($GivenPoint[1], $RowB);
	$NewPointb = multiplyFloat($GivenPoint[2], $RowC);
	$NewPtMatrixMult = AddFloats($NewPoint, $NewPointa);
	$NewPtMatrixMult = AddFloats($NewPtMatrixMult, $NewPointb);
	$NewPoint[0] = (($RowA[0])*($GivenPoint[0])) + (($RowB[0])*$GivenPoint[1]) + (($RowC[0])*$GivenPoint[2]);
	$NewPoint[1] = (($RowA[1])*($GivenPoint[0])) + (($RowB[1])*$GivenPoint[1]) + (($RowC[1])*$GivenPoint[2]);
	$NewPoint[2] = (($RowA[2])*($GivenPoint[0])) + (($RowB[2])*$GivenPoint[1]) + (($RowC[2])*$GivenPoint[2]);
	vector $ReturnValVec = FloatToVec($NewPoint);
	return $ReturnValVec;
}
proc matrix FloatToMatrix(float $v[]){
	matrix $mat[4][4]=<<$v[0], $v[1], $v[2], $v[3];
	$v[4], $v[5], $v[6], $v[7];
	$v[8], $v[9], $v[10], $v[11];
	$v[12], $v[13], $v[14], $v[15]>>;
	return $mat;
}
proc float[] MatrixToFloat(matrix $FourByFour_matrix[][]){
	float $matrixFloat[];
	int $FLOATindex = 0;
	int $Inx = 0;
	int $Inxb = 0;
	for($Inx = 0; $Inx <= 3; $Inx++){
		for($Inxb = 0; $Inxb <= 3; $Inxb++){
			$matrixFloat[$FLOATindex] = $FourByFour_matrix[$Inx][$Inxb];
			$FLOATindex++;
		}
	}
	return $matrixFloat;
}
proc vector PointToPlaneN( vector $Veciiv, vector $Vec[]){
	vector $planePointN ;
	float $pAv[]=  AverageVectorPoint($Vec);
	float $n[] = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
	float $DistanceLoc = distance2Pts(  $Veciiv, $pAv);
	float $MultDirCam[] = multiplyFloat($DistanceLoc, $n);
	float $FloatDirectionCamNormalA[] = AddFloats($pAv, $MultDirCam);
	float $PointN[] = ClosestPoint2LineVec($n, $pAv, $Veciiv);
	int $CombA = PointsEquivalentTol ($PointN, $pAv);
	if($CombA != 3){
		float $FloatDirectionAi[] = DirectionFN($pAv,$PointN);
		float $DistanceLoc = distance2Pts( $PointN, $pAv );
		float $MultDirPC1[] = multiplyFloat($DistanceLoc, $FloatDirectionAi);
		float $AddMultMiiF[] = AddFloats($Veciiv, $MultDirPC1);
		$planePointN = << $AddMultMiiF[0], $AddMultMiiF[1], $AddMultMiiF[2]>>;
	}else{ $planePointN = $Veciiv;
	}
	return $planePointN;
}
proc string VecArrayToCurve(vector $FixVec[]){
	int $sIZes = `size $FixVec `;
	int $NUmers[] = CreateIntIndex($sIZes);
	string $K = "";
	for ($eachN in $NUmers){
		$K += "\-k"+" "+$eachN+" ";
	}
	string $curve = "curve -d 1";
	for ($eachVeCx in $FixVec){
		float $valuesBi[] = $eachVeCx;
		$curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
	}
	$curve += " "+ $K;
	string $Newcurvez = `eval($curve)`;
	return $Newcurvez;
}
proc float [] EulerAngB(float $pointB1[], float $pointB2[]){
	float $EulerAngleA[] = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
	return $EulerAngleA;
}
proc vector [] VecPtsToZMirrorPts(vector $AllLocPositionsZ[]){
	vector $AllPlaneLocs[];
	clear  $AllPlaneLocs;
	for ($eachVecEp in $AllLocPositionsZ){
		float $Zx[] = $eachVecEp;
		$Zx[0] *= -1.0;
		$AllPlaneLocs[`size($AllPlaneLocs)`] = `FloatToVec ($Zx)`;
	}
	return $AllPlaneLocs;
}
proc int ISSelectedTypeCurve(){
	string $C[];
	$C = `ls -sl`;
	string $nametypeZi;
	string $nameA;
	string $nameB;
	$nametypeZi= `getTypeItemString $C`;
	$nameA = `match "[a-zA-Z]+" $nametypeZi`;
	$nameB = `match ".urve" $nameA`;
	int $zeroOR1Z = `gmatch $nameB "*[C-c]urve*"`;
	return $zeroOR1Z;
}
proc int addCurveNumbers(int $addNumbersiA){
	$addNumbersiA++;
	if($addNumbersiA>2){$addNumbersiA=0;}
	return $addNumbersiA;
}
proc EvalAddingCurves(){
	global int $addNumbersA;
	$addNumbersA = addCurveNumbers($addNumbersA);
	print $addNumbersA;
}
proc float [] FloatPointsToCamPlane(float $LocPos1[]){
	float $Pi = 3.1415926535;
	float $pi = 3.1415926535;
	float $CamPos1[];
	$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
	float $LivePlanePos[];
	$LivePlanePos = `xform -q -ws -t LiveSurfaceB`;
	float $CamerasDirectionVectorNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
	float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
	float $FloatDirectionA[] = DirectionFN($CamPos1, $LocPos1);
	float $DistanceLoc = distance2Pts( $LocPos1, $CamPos1 );
	float $DistanceLocA = $DistanceLoc;
	$DistanceLoc = $DistanceLoc * -1;
	float $MultDirPC1[] = multiplyFloat($DistanceLoc, $CamerasDirectionVector);
	float $FloatDirectionCamNormal[] = AddFloats($CamPos1, $MultDirPC1);
	float $CamerasDirectionVectorA[] = DirectionFN($FloatDirectionCamNormal, $CamPos1);
	float $MultDirPC1A[] = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
	$FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1A);
	float $p1[] = $CamPos1;
	float $p2[] = $LocPos1;
	float $p3[] = $FloatDirectionCamNormal;
	float $center[]; 
	float $normal[];
	float $p1p2[3];
	float $p1p3[3];
	$p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
	$p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
	float $normal[3];
	$normal = crossProduct( $p1p2, $p1p3, 0, 0 );
	float $FloatPosZero[] = {0, 0, 0};
	float $FloatDirection[] = DirectionFN($FloatPosZero, $normal);
	float $mid1[3], $mid2[3], $mid3[3];
	$mid1 = midPoint2Pts( $p1, $p2 );
	$mid2 = midPoint2Pts( $p1, $p3 );
	$mid3 = midPoint2Pts( $p2, $p3 );
	float $perp_p1p2[3];
	float $perp_p1p3[3];
	$perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
	$perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
	float $center[] = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
	float $FloatDirPerpCenterC[] = DirectionFN($center,$mid2);
	float $FloatDirPointAC[] = DirectionFN($p1, $p3);
	float $center8[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
	float $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
	float $FloatDirLocToPerpIntersect[] = DirectionFN($center8,$p2);
	float $OnPlane[] = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );
	return $OnPlane;
}
proc float[] DirectionF(float $EACHCVposAZ[], float $EACHCVposBZ[]){
	vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
	vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
	float $MagVectorZ1 = mag($vectorZ1); 
	float $MagVectorZ2 = mag($vectorZ2);
	float $EACHCVposHigher[];
	float $EACHCVposLower[];
	$EACHCVposHigher = $EACHCVposBZ;
	$EACHCVposLower = $EACHCVposAZ;
	vector $UnitVectorMagPosHigher[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
	float $vector_SubUnitMagVec1[];
	$vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 


	vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
	float $UnitDirection[] = $vectorUnit;
	return $UnitDirection;
}
proc float [] lineIntersectionF(float $PosA[], float $PosB[], float $PosC[], float $PosD[]){ 
	float $DirAB[] = DirectionF ($PosA, $PosB);
	float $DirCD[] = DirectionF ($PosC, $PosD);
	float $locsA[] = lineIntersection($PosA, $DirAB, $PosC, $DirCD);
	return $locsA;
}
proc float[] pointMatrixMult( float $point[], float $matrix[] ){
	float $result[];
	$result[0] = 0.0;
	$result[1] = 0.0;
	$result[2] = 0.0;
	if ( size($point) != 3 || size($matrix) != 16 )
			{
				warning (uiRes("m_pointMatrixMult.kPointArray"));
				return $result;
			}
			string $multNode;
			if ( catch($multNode = `createNode pointMatrixMult`) ) 
	{
		warning (uiRes("m_pointMatrixMult.kCouldNotCreateNode"));
		return $result;
	}
	setAttr ($multNode+".vectorMultiply") true;
	setAttr ($multNode+".inPoint") -type "double3" $point[0] $point[1] $point[2];
	setAttr ($multNode+".inMatrix") -type "matrix" $matrix[0] $matrix[1] $matrix[2] $matrix[3] $matrix[4] $matrix[5] $matrix[6] $matrix[7] $matrix[8] $matrix[9] $matrix[10] $matrix[11] $matrix[12] $matrix[13] $matrix[14] $matrix[15];
	$result = `getAttr ($multNode+".output")`;
	delete $multNode;
	return $result;
}
proc matrix MatrixCleanNegZero(matrix $m[][]){
	float $MatrixA[] = `MatrixToFloat($m)`;
	int $iX =0;
	float $CleanFLoats[];
	for ($eachFloat in $MatrixA){
		if(($eachFloat == 0)||($eachFloat == -0)){
			$CleanFLoats[`size($CleanFLoats)`] = 0.0;
		}else{$CleanFLoats[`size($CleanFLoats)`] = $eachFloat;}
		$iX++;
	}
	$CleanFLoats = MakeCleanFloatsZ($CleanFLoats);
	matrix $MatrixClean[4][4]= FloatToMatrix($CleanFLoats);
	return $MatrixClean;
}
proc int  PointsEquivalentTol( float $posA[],  float $posB[]){
	int $pX = equivalentTol($posA[0], $posB[0],  0.001);
	int $pY = equivalentTol($posA[1], $posB[1],  0.001);
	int $pZ = equivalentTol($posA[2], $posB[2],  0.001);
	int $addedResults = $pX + $pY + $pZ;
	return $addedResults;
}
proc string IteratCurve(float $step, string $paramlocatorpointOnCurvex, float $curveMin, int $FindSteps){
	int $MasterCount= 0;
	$curve = "curve -d 3";
	vector $tan;
	vector $norm;
	vector $bi;
	while ($FindSteps < 4){
		$curve = "curve -d 3";
		int $Par = 0;
		int $a;
		int $ii = 0;
		int $CountSteps;
		float $values[];
		float $CurvatureRadi;
		for($a = 0; $a <= $step;$a++){
			$ii = $ii + 1;
			$t =  $a/$step;
			$Par = ($a/$step);
			setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
			$values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
			$CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
			if ( $CurvatureRadi <=  $curveMin){   
				$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
				$CountSteps++;
			}
			if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
				$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
				$CountSteps++;
			}
			if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
				$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
				$CountSteps++;
			}
		}
		$FindSteps = $CountSteps;
		if($FindSteps < 10){$curveMin += 18.0; $curve = "curve -d 3";  }
		if($MasterCount== 4){break;}
		$MasterCount++;
	}
	return $curve;
}
proc string VecArrayToCurveB(vector $FixVec[]){
	int $sIZes = `size $FixVec `;
	int $NUmers[] = CreateIntIndex($sIZes);
	string $K = "";
	for ($eachN in $NUmers){
		$K += "\-k"+" "+$eachN+" ";
	}
	$K += "\-k"+" "+ $sIZes+" ";
	$sIZes++;
	$K += "\-k"+" "+ $sIZes+" ";
	string $curve = "curve -d 3";
	for ($eachVeCx in $FixVec){
		float $valuesBi[] = $eachVeCx;
		$curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
	}
	string $Newcurvez = `eval($curve)`;
	return $Newcurvez;
}
proc vector TwoVecsOrFloats(float $p1p2[], float $p1p3[]){
	vector $Ui = FloatToVec($p1p2);
	vector $Vi = FloatToVec($p1p3);
	vector $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;
	return $VEcLine;
}
proc int MostRightClockWiseInt ( vector $Vecs[], int $Two[]){
	string $ThreePoints[] = { "0", "1", "2"};
	float $point1[] =  FloatToVec($Vecs[0]);
	float $point2[] =  FloatToVec($Vecs[1]);
	float $point3[] =  FloatToVec($Vecs[2]);
	vector $U1 = TwoVecsOrFloats($point2, $point1);
	vector $V1 = TwoVecsOrFloats($point3, $point1);
	vector $U2 = TwoVecsOrFloats($point3, $point1);
	vector $V2 = TwoVecsOrFloats($point2, $point1);
	vector $U3 = TwoVecsOrFloats($point1, $point3);
	vector $V3 = TwoVecsOrFloats($point2, $point3);
	vector $normalV[];
	clear $normalV;
	$normalV[0] = FloatToVec( crossProduct( $U1, $V1, 0, 1 ) );
	$normalV[1] = FloatToVec( crossProduct( $U2, $V2, 0, 1 ) );
	float $normalA[] = `unit ($normalV[0])`;
	float $normalB[] = `unit ($normalV[1])`;
	float $normalAAdd = $normalA[0] + $normalA[1];
	float $normalAAdd2 = $normalB[0] + $normalB[1];
	int $TwoNew[];
	if( $normalAAdd< $normalAAdd2){
		$TwoNew ={$Two[1], $Two[0]};
	}else{ 
		$TwoNew ={$Two[0], $Two[1]};
	}
	return $TwoNew[0];
}
proc float [] CreateIntIndexF(int $ArraySize, float $Fstep){
	int $iNdex = 0;
	float $FArrayInex[];
	float $AddF =0;
	while($iNdex < $ArraySize){
		$AddF+= $Fstep;
		$FArrayInex[$iNdex] = $AddF;
		$iNdex++;
	}
	return $FArrayInex;
}
proc float AverageFloats(float $FloatArray[]){
	float $Ix=0;
	float $AddAll=0;
	for($eachF in $FloatArray){
		$AddAll+= $eachF;
		$Ix++;
	}
	float $Divide=$AddAll/$Ix;
	return $Divide;
}
proc float [] GatherDataRR(float $Xt[], float $Av){
	float $Vt[];
	float $PastF;
	int $count =0;
	for ($eachF in $Xt){
		if($eachF < $Av){
			$Vt[$count]= 1;
		}else{$Vt[$count]= -1;}
		if($count>0){
			if($PastF<$eachF){
				if($PastF<$Av){
					if(($PastF+$eachF/2.0)<$Av){
						$Vt[$count]= 1; }
				}
			}
		}
		$PastF = $eachF;
		$count++;
	}
	return $Vt;
}
proc string [] VecArrayToSplitCurve(vector $FixVec[]){
	int $sIZes = `size $FixVec `;
	int $evenOdd = fmod($sIZes, 2);
	int $sIZesHalf = (($sIZes)/2)+1; 
	int $NUmers[] = CreateIntIndex($sIZesHalf);
	string $K = "";
	for ($eachN in $NUmers){
		$K += "\-k"+" "+$eachN+" ";
	}
	int $countN=0;
	string $curveA = "curve -d 1";
	float $valuesBi[];
	for ($eachVeCx in $NUmers){
		$valuesBi  = $FixVec[$countN];
		$curveA += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
		$countN++;
	}
	$curveA += " "+ $K;
	string $curveB = "curve -d 1";
	float $valuesBi[];
	$countN--;
	for ($eachVeCx in $NUmers){
		$valuesBi  = $FixVec[$countN];
		$curveB += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
		$countN++;
	}
	$curveB += " "+ $K;
	string $NewcurvezA = `eval($curveA)`;
	string $NewcurvezB = `eval($curveB)`;
	string $NewcurvezAB[];
	$NewcurvezAB = {$NewcurvezA , $NewcurvezB};
	return $NewcurvezAB;
}
proc vector [] LineIntersectPlaneCam( vector $Vecii[], float $CamP[], vector $Vec[]){
	float $pAv[]=  AverageVectorPoint($Vec);
	float $n[] = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
	vector $OnPlane[];
	int $CountVV=0;
	vector $eachVecLine;
	float $FloatDirA[];
	float $FloatDirNormalA[],$MultDirA[],$DistanceLocA,$MultDirCam[],$FloatDirectionCamNormalA[],$PointN[],$FloatDirectionAi[],$DistanceLoc,$MultDirPC1[],$FloatDirNormalDist[],$PointNii[],$FloatDirectionAii[];
	for($eachVecLine in $Vecii){
		$FloatDirA  = DirectionF($eachVecLine, $CamP);
		$FloatDirNormalA = multiplyFloat(2, $FloatDirA);
		$MultDirA = AddFloats( $FloatDirNormalA, $eachVecLine);
		$DistanceLocA = distance2Pts(  $eachVecLine, $pAv);
		$MultDirCam  = multiplyFloat($DistanceLocA, $n);
		$FloatDirectionCamNormalA  = AddFloats($pAv, $MultDirCam);
		$PointN  = ClosestPoint2Line($n, $pAv, $eachVecLine);
		$FloatDirectionAi  = DirectionF($PointN, $pAv);
		$DistanceLoc = distance2Pts( $PointN, $pAv );
		$MultDirPC1  = multiplyFloat($DistanceLoc, $FloatDirectionAi);
		$FloatDirNormalDist  = AddFloats($eachVecLine, $MultDirPC1);
		$PointNii  = ClosestPoint2Line(DirectionF($PointN, $pAv), $eachVecLine, $MultDirA);
		$FloatDirectionAii  = DirectionF($PointNii, $MultDirA);
		$OnPlane[$CountVV] = FloatToVec (lineIntersection( $FloatDirNormalDist, $FloatDirectionAii, $eachVecLine, $FloatDirA));
		$CountVV++;
	}
	return $OnPlane;
}
proc vector FindIfCurveIsOrthoEpipol(vector $EpipolD[], vector $CRV_ENDS[], float $DistEnds, vector $LineMid){
	global float $AngleEpiPole;
	global int $IsOrthoLineTrue;
	global int $AxisOrthoLine;
	vector $Xdirect;
	vector $Ydirect;
	vector $Zdirect;
	if(`size($EpipolD)` == 3){
		$Xdirect = $EpipolD[0];
		$Ydirect = $EpipolD[1];
		$Zdirect = $EpipolD[2];
	}else{
		$Xdirect = << 1,0,0>>;
		$Ydirect = << 0,1,0>>;
		$Zdirect = << 0,0,1>>;
	}
	vector $XYZdirect[];
	$XYZdirect[0] = $Xdirect;
	$XYZdirect[1] = $Ydirect;
	$XYZdirect[2] = $Zdirect;
	vector $NewDirectionZ;
	float $Anglei;
	float $EulerAngleA[],$EulerAngleB[],$EulerAngleC[],$EulerABCi[2];
	string $stringF[];
	$LineAMain = PositiveDirectionLine($CRV_ENDS[0], $CRV_ENDS[1]);
	$EulerAngleA  = EulerAngB($Xdirect,$LineAMain);
	$EulerAngleB  = EulerAngB($Ydirect,$LineAMain);
	$EulerAngleC  = EulerAngB($Zdirect,$LineAMain);
	$EulerABCi[0]= $EulerAngleA[3];
	$EulerABCi[1]= $EulerAngleB[3];
	$EulerABCi[2]= $EulerAngleC[3]; 
	string $stringF[]= FloatArrayToStringArray($EulerABCi);
	string $EmptyIndx[];
	clear $EmptyIndx;
	int $index[] = CreateIntIndex(3);
	string $stringIndTr[]= IntArrayToStringArray($index);
	SortFloatArrayAndString( $EulerABCi, $stringIndTr, $EmptyIndx);
	$EmptyIndx = ReverseStringArray($EmptyIndx);
	int $xyz = $EmptyIndx[0];
	$AxisOrthoLine = $xyz;
	$Anglei = $EulerABCi[$xyz];
	$NewDirectionZ = $XYZdirect[$xyz];
	$DistEnds= distance2Pts($CRV_ENDS[0], $CRV_ENDS[1]);
	$LineMid = ($CRV_ENDS[0] + $CRV_ENDS[1])/2.0;
	$AngleEpiPole = $Anglei;
	int $isOrthoTrueZi=0;
	if($Anglei < 8.55){
		$isOrthoTrueZi = 1;  print ("IsOrthoLineTrue :Anglei "+$Anglei+"\n");
	}
	print ("IsOrthoLineTrue :Anglei "+$Anglei+"\n");
	$IsOrthoLineTrue = $isOrthoTrueZi;
	return $NewDirectionZ;
}
proc int isCurveEndAtZY(vector $EndVectors[]){
	float $ThreeFs[];
	int $Number =0;
	for($eachVec in $EndVectors){
		$ThreeFs = $eachVec;
		if($ThreeFs[0] == 0){
			$Number++;
		}}
	return $Number;
}
proc string [] ForceOrtho(string  $CurveItemAX[]){
	global string $StereoCurveZ[];
	global int $addNumbersA;
	global float $AngleEpiPole;
	global int $IsOrthoLineTrue;
	global int $AxisOrthoLine;
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemAX[0];
	vector $Positions[];
	$Positions = VecCurveEps($CurveItemAX[0]);
	$TempCrv = VecArrayToCurve($Positions);
	delete $CurveItemAX[0];
	vector $VecCurEnds[] = VecCurveEnds({$TempCrv});
	string $queryLocCurveEnds[] = queryLocOnLivePlaneBLayer(); 
	string $queryLocCurveEndsOLD[] = $queryLocCurveEnds;
	int $edgeZsetA;
	int $edgeZsetB;
	$edgeZsetA = 0;
	$edgeZsetB = 0;
	string $newNames;
	float $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
	float $NdistA,$NdistB;
	string $NearCurvesEnds[];
	string $BothCurves[];
	if(`size($queryLocCurveEnds)` >= 2){
		vector $LocCurveEndsVec[] = PointArray($queryLocCurveEnds);
		string $EmptyStringNewOrderA[];
		float $distancesEachToCurve[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
		float $distancesEachToCurveB[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
		int $ReducedIndexA[] = floatArrayCountDuplicates($distancesEachToCurve);
		int $ReducedIndexB[] = floatArrayCountDuplicates($distancesEachToCurveB);
		float $distAz[];
		float $distBz[];
		for($eachInt in $ReducedIndexA){
			$distAz[`size($distAz)`]= $distancesEachToCurve[$eachInt];
		}
		for($eachInt in $ReducedIndexB){
			$distBz[`size($distBz)`]= $distancesEachToCurveB[$eachInt];
		}
		int $NearestInt[] = SortNumbersIntIndex($distAz);
		int $NearestIntB[] = SortNumbersIntIndex($distBz);
		int $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
		int $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];
		$EmptyStringNewOrderA[0] = $queryLocCurveEnds[$ReducedIndexA[$NearestInt[0]]];
		$EmptyStringNewOrderA[1] = $queryLocCurveEnds[$ReducedIndexB[$NearestIntB[0]]];
		$NearestInt[0] =  $NewIntIndexAA;
		$NearestIntB[0] = $NewIntIndexBB;
		$NdistA = $distancesEachToCurve[$NearestInt[0]];
		$NdistB= $distancesEachToCurveB[$NearestIntB[0]];
		string $LocA = $queryLocCurveEnds[$NearestInt[0]];
		string $LocB = $queryLocCurveEnds[$NearestIntB[0]];
		vector $EndSnapAndEndProject[];
		clear $EndSnapAndEndProject;
		string $LocName;
		string $Loc_AorB="";
		int $NearestIndex;
		vector $endNotNearZ[];
		vector $NearEndZ;
		int $NearestIndexEach;
		if($NdistA<$NdistB){
			$LocName =$LocA;
			$NearestIndex=$NearestInt[0];
			$NearEndZ = $VecCurEnds[0];
			$endNotNearZ[0] = $VecCurEnds[1];
			$Loc_AorB="B";
		}else{
			$Loc_AorB="A";
			$LocName =$LocB;
			$NearestIndex=$NearestIntB[0];
			$NearEndZ = $VecCurEnds[1];
			$endNotNearZ[0] = $VecCurEnds[0];}
		if($NdistA==$NdistB){
			$Loc_AorB="A";
			$LocName =$LocA;
			$NearestIndex=$NearestInt[0];
			$NearEndZ = $VecCurEnds[0];
			$endNotNearZ[0] = $VecCurEnds[1];
		}
		if($NearestInt[0]==$NearestIntB[0]){
			$LocName =$LocA;
			$NearestIndex=$NearestInt[0];
		}
		string $newNames = stringArrayToString($queryLocCurveEnds, " ");
		string $newNamesResultAX = substituteAllString($newNames, "Plane", "");
		string $AllarrayCurvesNear[];
		$AllarrayCurvesNear = stringToStringArray($newNamesResultAX, " ");
		string $NewFoundLocs[];
		$NewFoundLocs[0]  = $AllarrayCurvesNear[$NearestIndex];
		string $arrayCurvesNear[];
		$arrayCurvesNear[0] = $queryLocCurveEnds[$NearestIndex];

		vector $LocOnPlaneVec[] = PointArray($arrayCurvesNear );
		vector $Loc3D_Vec[] = PointArray($NewFoundLocs );
		vector $ALLLoc3D_VecAB[] = PointArray($AllarrayCurvesNear);
		vector $ReducedVecAB[];
		int $ReducedIndexXAB[];
		if($Loc_AorB == "A"){
			$ReducedIndexXAB = $ReducedIndexA;
			$ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexA,$ALLLoc3D_VecAB);
		}
		if($Loc_AorB == "B"){
			$ReducedIndexXAB = $ReducedIndexB;
			$ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexB,$ALLLoc3D_VecAB);
		}
		vector $ALLLoc3D_Vec[];
		$ALLLoc3D_Vec = $ReducedVecAB;
		vector $MovedEndPointPlane[] = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
		vector $CRV_ENDSi[];
		$CRV_ENDSi[0]= $LocOnPlaneVec[0];
		$CRV_ENDSi[1]= $MovedEndPointPlane[0];
		float $CamPos_A[];	 
		$CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
		float $EpipolXx[] = {0.0,$CamPos_A[1],$CamPos_A[2]};
		float $PlaneEpipolXx[]= FloatPointsToCamPlane( $EpipolXx); 
		float $EpipolYx[] = {$CamPos_A[0],0.0,$CamPos_A[2]};
		float $PlaneEpipolYx[]= FloatPointsToCamPlane( $EpipolYx); 
		float $EpipolZx[] = {$CamPos_A[0],$CamPos_A[1],0.0};
		float $PlaneEpipolZx[]= FloatPointsToCamPlane( $EpipolZx);
		float $MidCurveA[] = MidPoint($CRV_ENDSi[0], $CRV_ENDSi[1]);
		float $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
		vector $DDirEpipolXYZ[];
		$DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
		$DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
		$DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
		vector $EpipolD[];
		$EpipolD = $DDirEpipolXYZ;
		vector $AllEpipolXYZ[];
		$AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
		$AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
		$AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);
		vector $XYZdirectL[];
		$XYZdirectL[0] = << 1,0,0>>;
		$XYZdirectL[1] = << 0,1,0>>;
		$XYZdirectL[2] = << 0,0,1>>;
		vector $LineMidi;
		vector $NewDirZi;
		$NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
		vector $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
		vector $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
		int $AxisOrthoLineA = $AxisOrthoLine;
		vector $Dir_CamRay;
		$Dir_CamRay =  DirectionFN($MovedEndPointPlane[0],$CamPos_A);
		string $CurvesV[];
		string $LocsV[];
		vector $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
		vector $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);
		float  $FPointN_LineC[];
		float $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);
		vector $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC)); 
		float $Xx, $Yy, $Zz;
		float $Xxi, $Yyi, $Zzi;
		float $XY[];
		float $XYZi[];
		$XYZi  = $PointN_LineC;
		float $XYZadd[];
		$XYZadd  = $PointN_LineC; 
		$XYZi[0] = $XYZadd[0]+$XYZadd[1];
		$XYZi[1] = $XYZadd[1]+$XYZadd[2];
		$XYZi[2] = $XYZadd[0]+$XYZadd[2]; 
		int $iVc=0;
		vector $One;
		int $TrackFoundN[];
		int $TrackN[];
		clear $TrackFoundN;
		float $Xd;
		float $Yd;
		float $Zd;
		int $TwoPointsi[];
		if($AxisOrthoLineA ==2){
			$TwoPointsi[0] = 0;
		}
		if($AxisOrthoLineA ==1){
			$TwoPointsi[0] = 2;
		}
		if($AxisOrthoLineA ==0){
			$TwoPointsi[0] = 1;
		}
		int $AXIS = $AxisOrthoLineA;
		int $ALLlikeness[];
		int $ALLlikenessForce[];
		clear $ALLlikeness;
		float $Dx,$Dy,$Dz;
		vector $each;
		int $i =0;
		int $TriggerPoints;
		float $All_X[];
		float $All_Y[];
		float $All_Z[];
		float $All_ZYX[];
		float $All_ZYXDiff[];
		float $diffXYZ;
		float $Dist_3DNear = (($Dist_3D/3.0)*2.0);
		for ($each in $ALLLoc3D_Vec){
			$One = $ALLLoc3D_Vec[$i];
			$XY[0] = $Xx  = $One.x;
			$XY[1] = $Yy  = $One.y;
			$XY[2] = $Zz  = $One.z;
			if( $ReducedIndexXAB[$iVc]!= $NearestIndex ){
				$TriggerPoints=0;
				if( (equivalentTol($XYZadd[0], $Xx,  0.01) )==1){
					$All_X[$i] = $Xx;
					$TriggerPoints++;
				}
				if( (equivalentTol($XYZadd[1], $Yy,  0.01) )==1){
					$All_Y[$i] = $Yy;
					$TriggerPoints++;
				}
				if( (equivalentTol($XYZadd[2], $Zz,  0.01) )==1){
					$All_Z[$i] = $Zz;
					$TriggerPoints++;
				}
				if( $TriggerPoints<2){
					$diffXYZ = `abs ($XY[$AXIS] - $XYZadd[$AXIS])`;
					if(($diffXYZ< $Dist_3DNear)&&($diffXYZ!=0)){
						$All_ZYX[`size($All_ZYX)`] =$XY[$AXIS];
						$All_ZYXDiff[`size($All_ZYXDiff)`] = $diffXYZ;
					}
				}
				if( $TriggerPoints==2){
					$ALLlikeness[`size($ALLlikeness)`] = $ReducedIndexXAB[$i];
				}
			}
			$i++;
			$iVc++;
		}
		int $SortedForce[];
		float $newOrderFloat;
		if(`size($All_ZYXDiff)`> 0){
			$SortedForce = SortNumbersIntIndex($All_ZYXDiff);
			$newOrderFloat = $All_ZYX[$SortedForce[0]];
		}
		if(`size($ALLlikeness)`> 0){
			select -cl;  
			for($eachIn in $ALLlikeness){
				select -add $AllarrayCurvesNear[$eachIn];
				PAUSE;
			}
			vector $NearPointsXYZ[] ;
			clear $NearPointsXYZ;
			$iVc =0;
			for($eachIn in $ALLlikeness){
				if( $iVc!= $NearestIndex ){
					$NearPointsXYZ[`size($NearPointsXYZ )`] =  $ALLLoc3D_VecAB[$eachIn];
				}
				$iVc++;
			}
			float $distTo3DCurveEnd[] = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
			int $Sorted[] = SortNumbersIntIndex($distTo3DCurveEnd);
			$NearPointsXYZ = NewVecOrderWithINTKey($Sorted,$NearPointsXYZ);
			float $SdistTo3DCurveEnd[]; 
			clear $SdistTo3DCurveEnd;
			for($eachIn in $Sorted){
				$SdistTo3DCurveEnd[`size($SdistTo3DCurveEnd)`] = $distTo3DCurveEnd[$eachIn];
			}
			int $ReducedIndex[] = floatArrayCountDuplicates($SdistTo3DCurveEnd);
			vector $ReducedVec[];
			$ReducedVec = NewVecOrderWithINTKey($ReducedIndex,$NearPointsXYZ);
			vector $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
			vector $VecLineDirMi;
			float $Additi[];
			float $AdditiB[];
			float $AdditRi;
			float $AdditRiX;
			$VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
			$Additi = $VecLineDirMi ;
			$AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
			$Additi = $LineDirect_3D;
			$AdditiB = $DirLineCrossXYZi ;
			$AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
			int $OntheSameLine =0;
			if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
				$OntheSameLine =1;
			}
			vector $PointN_LineXYZ ;
			float $DistSnap;
			vector $SnapN;
			vector $SnapPlaceN;
			int $CountN=0;
			for($eachVec in $ReducedVec){
				vector $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $eachVec);
				vector $VecLineDirMi;
				float $Additi[];
				float $AdditiB[];
				float $AdditRi;
				float $AdditRiX;
				$VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
				$Additi = $VecLineDirMi ;
				$AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
				$Additi = $LineDirect_3D;
				$AdditiB = $DirLineCrossXYZi ;
				$AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
				if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
					$PointN_LineXYZ = $eachVec;
					print " on same Line ";
				}else{
					$PointN_LineXYZ  = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $eachVec);
				}
				if( (distance2Pts($PointN_LineXYZ, $PointN_LineC))>0.001){
					$LocsV[`size($LocsV)`] = `Loc $PointN_LineXYZ`;
					$CurvesV[`size($CurvesV)`] = curve2points($eachVec, $PointN_LineXYZ);
					PAUSE;
				}
				if($CountN==0){
					$DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
					$SnapN = $eachVec;
					$SnapPlaceN = $PointN_LineXYZ;
				}
				if($CountN!=0){
					print  $DistSnap;
					if((distance2Pts($PointN_LineXYZ, $PointN_LineC))<  $DistSnap){
						$SnapN = $eachVec;
						$DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
						$SnapPlaceN = $PointN_LineXYZ;
					}
				}
				$CountN++;
			}
			vector $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
			vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
			vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);
			delete $CurvesV;
			delete $LocsV;
			float $EulerAngleA[];
			if(($EulerAngleA[3] >85)&&($EulerAngleA[3]<95)){
				float $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
				if($Dist_3DSnap<($Dist_3D/2.0)){
					cycleBackgroundColor;
					PAUSE;
					vector $VecLineDirM;
					float $Addit[];
					float $AdditR;
					$VecLineDirM = ($DirLineAA-$DirLineBB);
					$Addit = $VecLineDirM ;
					$AdditR = $Addit[0]+$Addit[1]+$Addit[2];
					int $AddInt = $AdditR;
					if($AddInt == 0){
						$PointN_LineC = $SnapPlaceN;
						PAUSE; PAUSE; PAUSE;
						cycleBackgroundColor;
						PAUSE;
						cycleBackgroundColor;
						PAUSE;
						cycleBackgroundColor;
						PAUSE;
						cycleBackgroundColor;
						PAUSE;
						cycleBackgroundColor;
						PAUSE;
						cycleBackgroundColor;
						PAUSE;
					}
				}
			}else{ 
				if(`size($All_ZYXDiff)`> 0){
					cycleBackgroundColor;
					PAUSE; PAUSE;
					cycleBackgroundColor;
					PAUSE; PAUSE;
					$FPointN_LineC =  $PointN_LineC;
					$FPointN_LineC[$AXIS] = $newOrderFloat;
					vector $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
					vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
					vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
					vector $VecLineDirM;
					float $Addit[];
					float $AdditR;
					$VecLineDirM = ($DirLineAA-$DirLineBB);
					$Addit = $VecLineDirM ;
					$AdditR = $Addit[0]+$Addit[1]+$Addit[2];
					print ("AdditR : "+$AdditR +"\n"); 
					int $AddInt = $AdditR;
					if($AddInt == 0){
						print ("AdditR WENT THROUGHT: "+$AdditR +"\n"); 
						$PointN_LineC = $PointN_TEMP;
						cycleBackgroundColor;
						PAUSE;
						cycleBackgroundColor;
						PAUSE;
						cycleBackgroundColor;
						PAUSE;
					}
				}
			}
		}else{
			if(`size($All_ZYXDiff)`> 0){
				cycleBackgroundColor;
				PAUSE; PAUSE;
				cycleBackgroundColor;
				PAUSE; PAUSE;
				vector $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
				vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
				vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
				vector $VecLineDirM;
				float $Addit[];
				float $AdditR;
				$VecLineDirM = ($DirLineAA-$DirLineBB);
				$Addit = $VecLineDirM ;
				$AdditR = $Addit[0]+$Addit[1]+$Addit[2];
				print ("AdditR : "+$AdditR +"\n"); 
				int $AddInt = $AdditR;
				if($AddInt == 0){
					print ("AdditR WENT THROUGHT: "+$AdditR +"\n"); 
					$PointN_LineC = $PointN_TEMP;
					cycleBackgroundColor;
					PAUSE;
					cycleBackgroundColor;
					PAUSE;
					cycleBackgroundColor;
					PAUSE;
				}
			}
		}
		vector $Points3DPair_And_2DPair[];
		$Points3DPair_And_2DPair[0]= $Loc3D_Vec[0];
		$Points3DPair_And_2DPair[1]= $PointN_LineC;
		$Points3DPair_And_2DPair[2]= $LocOnPlaneVec[0];
		$Points3DPair_And_2DPair[3]= $NewPlanePoint;
		delete $TempCrv;
		string $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 10 -d 3 -tol 0.05 $CurvesVi;
		vector $Crv_Pts[]; 
		$Crv_Pts = VecCurveEps($CurvesVi );
		vector $MirrorAcrossPlaneVecs[] = VecMultMatrixMirror($Crv_Pts);
		string $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
		clear $StereoCurveZ;
		$BothCurves[0] = $CurvesVi;
		$BothCurves[1] = $TheSecondCurve;
		$StereoCurveZ = $BothCurves;
		$addNumbersA =-3;
		ResetTranslation($BothCurves);
		CurveIndexVecTracking($BothCurves);  
		editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $BothCurves;
		evalVectorIndexAdditionSubtract;
		EVALCamScripts;
		clear $StereoCurveZ;
	}
	return $BothCurves;
}
proc int [] floatArrayCountDuplicates(float $listX[]){
	float $list[] = $listX;
	float $item, $result[], $CollectR[];
	int $index = 0;
	int $X = 0;
	int $Xi = 0;
	int $C = 0;
	int $NumberE[];
	int $NoneDup[];
	$result = $list;
	for ($item in $list) {
		$NumberE[$X] = floatArrayCount($item, $result);
		if (1 == $NumberE[$X]) {
			$NoneDup[`size($NoneDup)`] = $Xi;
		}else{
			if (1 < $NumberE[$X]) {
				floatArrayRemoveAtIndex($X, $result);
				$X--;
			}
		}
		$Xi++;
		$X++;	}
	return $NoneDup;
}
proc int floatArrayCount(float $item, float $list[]){
	int $result = 0;
	float $listItem;
	for ($listItem in $list) {
		if ($item == $listItem) $result++;	}
	return $result;
}
proc int floatArrayRemoveAtIndex( int $index, float $list[] ){
	int     $i;
	float  $result[];
	int     $len = size( $list );
	if( $index > $len  || $index < 0 ){
		return( false );
	}
	for( $i = 0; $i < $index; $i++ ){
		$result[$i] = $list[$i];
	}
	for( ; $i < $len - 1; $i++ ){
		$result[$i] = $list[$i + 1];
	}	 
	$list = $result;
	return( true );
}
proc vector [] VecMultMatrixMirror(vector $pointZ[]){
	matrix $m2[4][4]= <<	-1.0, 0.0, 0.0, 0.0;
	0.0, 1.0, 0.0, 0.0;
	0.0, 0.0, 1.0, 0.0;
	0.0, 0.0, 0.0, 1.0>>;
	float $MatrixB[] = `MatrixToFloat($m2)`;
	vector $FLoatPointA[];
	for($eachVec in $pointZ){
		$FLoatPointA[`size($FLoatPointA)`] = FloatToVec(pointMatrixMult( $eachVec, $MatrixB ));
	}
	return $FLoatPointA;
}
proc vector [] MoveVectors(vector $Pos_A, vector $VecLoc, vector $Crv_Pts[]){
	vector $DirLine = DirectionFN( $VecLoc, $Pos_A);
	float $DistToPoint = distance2Pts($Pos_A, $VecLoc);
	vector $TranstatedVecs[];
	clear $TranstatedVecs;
	for($eachVector in $Crv_Pts){
		$TranstatedVecs[`size($TranstatedVecs)`] = ($eachVector+($DistToPoint*$DirLine));
	}
	return $TranstatedVecs;
}
proc string [] VanishingCurves( string  $CurveItemA[]){
	global string $VanishingPointsLinesTempGuides[];
	global int $ifSingleCurve;
	string $VanishingLOC[];
	float $SnapD = 0.003;
	global vector $TempVectorsCrv[];
	vector $Positions[];
	if(size($TempVectorsCrv)>0){
		clear $TempVectorsCrv;}
	$Positions = VecCurveEps($CurveItemA[0]);
	$TempCrv = VecArrayToCurve($Positions);
	delete $CurveItemA[0];
	$CurveItemA[0] = VecArrayToCurve($Positions);
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 3 -tol 0.05 $CurveItemA[0];
	SetItemColorString ($CurveItemA[0], 9);
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $TempCrv;
	vector $PositionsZ_Ax[];
	$PositionsZ_Ax = VecCurveEps($TempCrv);
	vector $ZYplaneMatrix[];
	$ZYplaneMatrix[0] = <<0, 0, 0>>;
	$ZYplaneMatrix[1] = <<0, 1, 0>>;
	$ZYplaneMatrix[2] = <<0, 0, 1>>;
	float $CamPos1[];
	$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
	$TempVectorsCrv  = LineIntersectPlaneCam( $PositionsZ_Ax, $CamPos1, $ZYplaneMatrix);
	delete $TempCrv;
	float $Pi = 3.1415926535;
	float $pi = 3.1415926535;
	float $CamPos1[];
	$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
	float $CamerasDirectionVectorNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
	float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
	float $MultDirForWard[] = multiplyFloat(-1, $CamerasDirectionVector);
	float $MultDirCam[] = multiplyFloat(-3, $CamerasDirectionVector);
	float $FloatDirectionCamNormalA[] = AddFloats($CamPos1, $MultDirCam);
	float $DirectionVectorXn[] = {-2,0,0};
	float $DirectionVectorX[] = {2,0,0};
	float $DirectionVectorY[] = {0,-2,0};
	float $DirectionVectorYn[] = {0,2,0};
	float $DirectionVectorZn[] = {0,0,-2};
	float $DirectionVectorZ[] = {0,0,2};
	vector $VecDirection_A_XYZ[];
	$VecDirection_A_XYZ[0] = <<-2,0,0>>;
	$VecDirection_A_XYZ[1] = <<2,0,0>>;
	$VecDirection_A_XYZ[2] = <<0,2,0>>;
	$VecDirection_A_XYZ[3] = <<0,-2,0>>;
	$VecDirection_A_XYZ[4] = <<0,0,-2>>;
	$VecDirection_A_XYZ[5] = <<0,0,2>>;
	vector $VecDirectionXYZ[];
	$VecDirectionXYZ[0] = <<-1,0,0>>;
	$VecDirectionXYZ[1] = <<1,0,0>>;
	$VecDirectionXYZ[2] = <<0,1,0>>;
	$VecDirectionXYZ[3] = <<0,-1,0>>;
	$VecDirectionXYZ[4] = <<0,0,-1>>;
	$VecDirectionXYZ[5] = <<0,0,1>>;
	float $FloatPointDirectionXn[] = AddFloats($CamPos1, $DirectionVectorXn);
	float $FloatPointDirectionX[] = AddFloats($CamPos1, $DirectionVectorX);
	float $FloatPointDirectionY[] = AddFloats($CamPos1, $DirectionVectorY);
	float $FloatPointDirectionYn[] = AddFloats($CamPos1, $DirectionVectorYn);
	float $FloatPointDirectionZn[] = AddFloats($CamPos1, $DirectionVectorZn);
	float $FloatPointDirectionZ[] = AddFloats($CamPos1, $DirectionVectorZ);
	vector $VecXYZs[5];
	clear $VecXYZs;
	$VecXYZs[0] = FloatToVec($FloatPointDirectionXn);
	$VecXYZs[1] = FloatToVec($FloatPointDirectionX);
	$VecXYZs[2] = FloatToVec($FloatPointDirectionY);
	$VecXYZs[3] = FloatToVec($FloatPointDirectionYn);
	$VecXYZs[4] = FloatToVec($FloatPointDirectionZn);
	$VecXYZs[5] = FloatToVec($FloatPointDirectionZ);
	vector $VecXYZsOnPlane[]= VecPointsToCameraPlane($VecXYZs);
	float $AverageVecXYZsOnP[] =  AverageVectorPoint($VecXYZsOnPlane);
	string $DirectionsZ[] = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
	vector $FloatDirxyz[5];
	$FloatDirxyz[0] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[0]));
	$FloatDirxyz[1] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[1]));
	$FloatDirxyz[2] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[3]));
	$FloatDirxyz[3] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[2]));
	$FloatDirxyz[4] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[4]));
	$FloatDirxyz[5] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[5]));
	string $Alll ="";
	string $AllStrings[];
	float $AnglesAll[];
	clear $AllStrings $AnglesAll ;
	for ($eachOrthD in $VecDirectionXYZ){
		float $EulerAngleA[] = EulerAngB($eachOrthD, $CamerasDirectionVector);
		$AnglesAll[`size($AnglesAll)`]= $EulerAngleA[3];
		string $stringFloat[]= FloatArrayToStringArray($EulerAngleA);
		$Alll  = stringArrayToString($stringFloat, " ");
		$AllStrings[`size($AllStrings)`]= $Alll;
	}
	string $EmptyIndxNewOrder[];
	clear $EmptyIndxNewOrder;
	int $indexAx[] = CreateIntIndex(6);
	string $stringIndTr[]= IntArrayToStringArray($indexAx);
	float $ANgnew[] = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
	$EmptyIndxNewOrder = ReverseStringArray($EmptyIndxNewOrder);
	string $BestThree[];
	$BestThree = {$EmptyIndxNewOrder[0], $EmptyIndxNewOrder[1], $EmptyIndxNewOrder[2]};
	$BestThree = ReverseStringArray($BestThree);
	$BestThree = stringArrayRemoveDuplicates ($BestThree);
	int $indexAxNew[] = ArrayToIntList( $BestThree);
	vector $VecCurEnds[] = VecCurveEnds($CurveItemA);
	float $LengCRV_a = `arclen $CurveItemA`;
	float $DistEndsi; 
	$DistEndsi = distance2Pts($VecCurEnds[0], $VecCurEnds[1]);
	float $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
	float $AverageVecCurEndsP[] =  AverageVectorPoint($VecCurEnds);
	vector $VecXYZsOnPlaneiY[]; 
	float $FloatPointDirectionZniY[];
	float $CurveDirectionZiY[];
	float $FloatPointDirectionZniiY[];
	vector $VecXYZsOnPlaneiiY[];
	float $CurveDirectionZiiY[];
	int $Count =0;
	float  $CurvePsD[] =  DirectionF($VecCurEnds[0], $VecCurEnds[1]);
	float  $FloatPointDirectVpoint[]; 
	vector  $VecXYZsOnPlaneVpoint[];
	float  $CurveDirectionVpoint[];
	size($EmptyIndxNewOrder);
	string $DirectionsZ[] = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
	int $color;
	int $colori[];
	clear $colori;
	int $iiX =0;
	for($eachDirection in $indexAxNew){
		if($eachDirection ==0 || $eachDirection ==1){$colori[`size($colori)`] = 13;}
		if($eachDirection ==3 || $eachDirection ==2){$colori[`size($colori)`] = 14;}
		if($eachDirection ==4 || $eachDirection ==5){$colori[`size($colori)`] = 6;}
	}
	string $CurvesV[];
	clear $CurvesV;
	string $CirTemp[];
	string $CirTempi[];
	float $locsAi[];
	int $Cindex =0;
	vector $EpipLolar[];
	for ($eachDii in $indexAxNew){
		int $IndexZ = $indexAxNew[$Count];
		$FloatPointDirectionZniY  = AddFloats( $VecCurEnds[1], $VecDirection_A_XYZ[$IndexZ]);
		$VecXYZsOnPlaneiY = VecPointsToCameraPlane($FloatPointDirectionZniY);
		$CurveDirectionZiY =  DirectionF($VecCurEnds[1],  $VecXYZsOnPlaneiY[0]);
		$FloatPointDirectionZniiY = AddFloats( $VecCurEnds[0], $VecDirection_A_XYZ[$IndexZ]);
		$VecXYZsOnPlaneiiY = VecPointsToCameraPlane($FloatPointDirectionZniiY);
		$CurveDirectionZiiY =  DirectionF($VecCurEnds[0],  $VecXYZsOnPlaneiiY[0]);
		$locsAi = lineIntersection($VecCurEnds[1], $CurveDirectionZiY, $VecCurEnds[0],  $CurveDirectionZiiY);
		$EpipLolar[$Count] = FloatToVec($locsAi);
		$CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[0], $locsAi);
		$CirTemp = `ls -sl`;
		SetItemColorString ($CirTemp[0], $colori[$Cindex]);
		$CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[1], $locsAi);
		$CirTempi = `ls -sl`;
		SetItemColorString ($CirTempi[0], $colori[$Cindex]);
		editDisplayLayerMembers -noRecurse VanishingPointsLines $CurvesV;
		$Cindex++;
		$Count++;
	}
	$ifSingleCurve = 0;
	string $newCurveii;
	string $CurveAv[];
	vector $PositionsZ_A[];
	vector $PositionsZ_Aii[];
	float $CamPos_A[];
	$CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
	float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;
	float $CamNormM[] = ` MirrorFloatXYZ 0 $MultDirCam`;
	float $MidEpipolZx[] = MidPoint($CamPos_M, $CamPos_A);
	float $MidEpipolPosFCam[]= FloatPointsToCamPlane($MidEpipolZx);
	vector $HighCurvePoints[];
	$HighCurvePoints = CurvatureUtilityCurvature($CurveItemA[0], 60);
	int $Cindex =0;
	if(`size($HighCurvePoints)`>0){
		for ($eachVec in $HighCurvePoints){
			$CurvesV[`size($CurvesV)`] = curve2points($eachVec, $MidEpipolPosFCam);
			$CirTemp = `ls -sl`;
			SetItemColorString ($CirTemp[0], 11);
		}
	}
	vector $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
	vector $Dir_VecA;
	float $Addit[];
	float $AdditR;
	$Dir_VecA =   PositiveDirectionLine($VecCurEnds[0],$VecCurEnds[1]);
	$VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
	$Addit = $VecLineDirM ;
	$AdditR = $Addit[0]+$Addit[1]+$Addit[2];
	float $INTERSECTIONLA[] = lineIntersectionF($VecCurEnds[0], $EpipLolar[0], $VecCurEnds[1],  $EpipLolar[1]);
	float $INTERSECTIONLB[] = lineIntersectionF($VecCurEnds[1], $EpipLolar[0], $VecCurEnds[0],  $EpipLolar[1]);
	$CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[0],$INTERSECTIONLA);
	$CirTempi = `ls -sl`;
	SetItemColorString ($CirTempi[0], 14);
	$CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[1],$INTERSECTIONLB);
	$CirTempi = `ls -sl`;
	SetItemColorString ($CirTempi[0], 14);
	$CurvesV[`size($CurvesV)`] = curve2points($EpipLolar[2],$INTERSECTIONLA);
	$CirTempi = `ls -sl`;
	SetItemColorString ($CirTempi[0], 4);
	$CurvesV[`size($CurvesV)`] = curve2points($EpipLolar[2],$INTERSECTIONLB);
	$CirTempi = `ls -sl`;
	SetItemColorString ($CirTempi[0], 4);
	vector  $VecPtsMirrorEnds_A[];
	$VecPtsMirrorEnds_A= VecPtsToZMirrorPts( $VecCurEnds);
	vector $VIntersectEnds_A[];
	int $triggerMiddle =0;
	string $newNamesResultA1;
	string $ThreeDCurvesNear[];
	vector $ObjLoc3DCurv[];
	$VIntersectEnds_A[0] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[1], $CamPos_M, $VecPtsMirrorEnds_A[0]));
	$VIntersectEnds_A[1] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[0], $CamPos_M, $VecPtsMirrorEnds_A[1]));
	string $queryLocCurveEnds3D[];
	$queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
	int $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
	float $IntersectEnds_Ai[];
	float $IntersectEnds_Bi[];
	$IntersectEnds_Ai =  FloatPointsToCamPlane($VIntersectEnds_A[0]);
	$IntersectEnds_Bi = FloatPointsToCamPlane($VIntersectEnds_A[1]);
	string $CurveItemAa[] ;
	$CurveItemAa[0] = $CurveItemA[0];
	string $queryLocCurveEnds[] = queryLocOnLivePlaneBLayer(); 
	string $queryLocCurveEndsOLD[] = queryLocOnLivePlaneBLayer();
	int $edgeZsetA;
	int $edgeZsetB;
	$edgeZsetA = 0;
	$edgeZsetB = 0;
	string $newNames;
	float $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
	float $NdistA,$NdistB;
	string $NearCurvesEnds[];
	if(`size($queryLocCurveEnds)` > 2){
		vector $LocCurveEndsVec[] = PointArray($queryLocCurveEnds);
		string $EmptyStringNewOrderA[];
		float $distancesEachToCurve[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
		int $NearestInt[] = SortNumbersIntIndex($distancesEachToCurve);
		$EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[0]];
		float $distancesEachToCurveB[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
		int $NearestIntB[] = SortNumbersIntIndex($distancesEachToCurveB);
		$EmptyStringNewOrderA[1] = $queryLocCurveEnds[$NearestIntB[0]];
		$NdistA = $distancesEachToCurve[$NearestInt[0]];
		$NdistB= $distancesEachToCurveB[$NearestIntB[0]];
		string $StringAllNearA[];
		if(($NdistA<$SnapD)||($NdistB<$SnapD)){
			int $i;
			int $iv =-1;
			float $distsA = $NdistA;
			float $distsB = $NdistB;
			for (  $i = 1; $i < 5; $i++) {
				if( $distsA < $distsB){
					$NdistA = $distancesEachToCurve[$NearestInt[$i]];
					if($iv==-1){
						$iv++;
						$StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[0]];}
					if (equivalentTol($NdistA, $distsA, 0.001) == 1){  
						$StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[$i]];
					}
				}
			}
			$newNames = stringArrayToString( $StringAllNearA, " ");
			string $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
			string $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
			string $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
			string $arrayCurvesNearA[];
			$arrayCurvesNearA = stringToStringArray($newNamesResultC, " ");
			int $CRV_index_number =0;
			int $CRc =0;
			int $CRcT =0;
			for($eachCurve in $arrayCurvesNearA){
				if(`sets -im ZEdgeCurvesSet $eachCurve` ==1){
					$CRV_index_number = $CRc;
					$CRcT++;
					break;
				}
				$CRc++;
			}
			if($CRcT ==1){
				$EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[$CRc]];
			}
		}
		$NdistA = $distancesEachToCurve[$NearestInt[0]];
		$NdistB= $distancesEachToCurveB[$NearestIntB[0]];
		$newNames = stringArrayToString($EmptyStringNewOrderA, " ");
		string $newNamesResultAx = substituteAllString($newNames, "Plane", "");
		string $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
		string $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
		string $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
		string $arrayCurvesNear[];
		$arrayCurvesNear = stringToStringArray($newNamesResultC, " ");
		$NearCurvesEnds[0] = $arrayCurvesNear[0];
		$NearCurvesEnds[1] = $arrayCurvesNear[1];
		string $arrayCurvesNearA1[];
		$arrayCurvesNearA1 = stringToStringArray($newNamesResultAx, " ");
		vector $LocCurveEndsVec_3D[] = PointArray($arrayCurvesNearA1);
		string $VanishingLOC[]; clear $VanishingLOC;
		vector $LoCz_3D[];
		$LoCz_3D = $LocCurveEndsVec_3D;
		vector $TXI = << -1.0 , 1.0, 1.0>>;
		$LoCz_3D[2] = MultVec($LoCz_3D[0],$TXI);
		$LoCz_3D[3] = MultVec($LoCz_3D[1], $TXI);
		int $countS =0;
		for($eachItemVEC in $LoCz_3D){
			$VanishingLOC[ size($VanishingLOC) ] = Loc($eachItemVEC);
			if(($countS==0)||($countS==2)){
				SetItemColorString ($VanishingLOC[ size($VanishingLOC) -1], 19);
				setAttr ( $VanishingLOC[ size($VanishingLOC) -1]+".scale") 4.0 4.0 4.0;
			}else{SetItemColorString ($VanishingLOC[size($VanishingLOC)-1], 18);
				setAttr ( $VanishingLOC[ size($VanishingLOC) -1]+".scale") 9.0 9.0 9.0;
			}
			$countS++;
		}
		float $PtsM_Ai[];
		float $PtsM_Bi[];
		$PtsM_Ai = FloatPointsToCamPlane($LoCz_3D[2]);
		$PtsM_Bi = FloatPointsToCamPlane($LoCz_3D[3]);
		float $INTERSECTIONLC[] = lineIntersectionF($EpipLolar[0], $PtsM_Ai, $INTERSECTIONLA, $EpipLolar[2]);
		$CurvesV[`size($CurvesV)`] = curve2points($PtsM_Ai,$INTERSECTIONLC);
		$CirTempi = `ls -sl`;
		SetItemColorString ($CirTempi[0], 14);
		float $INTERSECTIONL2C[] = lineIntersectionF($EpipLolar[0], $VecCurEnds[0], $INTERSECTIONLC, $EpipLolar[2]);
		$CurvesV[`size($CurvesV)`] = curve2points($INTERSECTIONLC,$INTERSECTIONL2C);
		$CirTempi = `ls -sl`;
		SetItemColorString ($CirTempi[0], 4);
		float $INTERSECTIONL2D[] = lineIntersectionF($EpipLolar[1],$INTERSECTIONLC, $VecCurEnds[1],  $EpipLolar[2]);
		float $INTERSECTIONL3D[] = lineIntersectionF($EpipLolar[0],$INTERSECTIONL2D,$PtsM_Ai,  $EpipLolar[1]);
		$CurvesV[`size($CurvesV)`] = curve2points($INTERSECTIONL2D,$INTERSECTIONL3D);
		$CirTempi = `ls -sl`;
		SetItemColorString ($CirTempi[0], 14);
		$CurvesV[`size($CurvesV)`] = curve2points($PtsM_Ai,$INTERSECTIONL3D);
		$CirTempi = `ls -sl`;
		SetItemColorString ($CirTempi[0], 6);
		$CurvesV[`size($CurvesV)`] = curve2points($INTERSECTIONLC,$INTERSECTIONL2D);
		$CirTempi = `ls -sl`;
		SetItemColorString ($CirTempi[0], 6);
		$CurvesV[`size($CurvesV)`] = curve2points($INTERSECTIONL2C,$VecCurEnds[1]);
		$CirTempi = `ls -sl`;
		SetItemColorString ($CirTempi[0], 6);
		appendStringArray($CurvesV, $VanishingLOC, size($VanishingLOC));
		$edgeZsetA = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[0]`;
		$edgeZsetB = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[1]`;
		float $ThreepointVecs[];
		int $COuntN =0;
		int $EDGEpoints[];
		for($eachVec in $LocCurveEndsVec_3D){
			$ThreepointVecs = $eachVec;
			if (equivalentTol($ThreepointVecs[0], 0.00, 0.001) == 1){  
				$EDGEpoints[$COuntN]= 1;
			}else{$EDGEpoints[$COuntN]= 0;}
			$COuntN++;
		}
		$edgeZsetA =$EDGEpoints[0];
		$edgeZsetB =$EDGEpoints[1];
		if(($NdistA<$SnapD)||($NdistB<$SnapD)){
			if(($NearCurvesEnds[0] == $NearCurvesEnds[1])&&( ($edgeZsetA+$edgeZsetB) ==2)){
				if($NdistA<$NdistB){
					$edgeZsetA =1;
					$edgeZsetB =0;
				}
				if($NdistA>$NdistB){
					$edgeZsetA =0;
					$edgeZsetB =1;
				}
				if($edgeZsetA==0){$NdistA=100;}
				if($edgeZsetB==0){$NdistB=100;}
			}
		}
		if(($NdistA>$SnapD)&&($NdistB>$SnapD)){
			$edgeZsetA =0;
			$edgeZsetB =0; 
		}
	} 
	int $pointNearEdgeCurve[];
	if(($edgeZsetA==1)&&($NdistA<$SnapD)){
		$pointNearEdgeCurve[0]= 1;
	}
	if(($edgeZsetA==1)&&($NdistA>$SnapD)){
		$pointNearEdgeCurve[0]= 0;
	}
	if(($edgeZsetA==0)&&($NdistA>$SnapD)){
		$pointNearEdgeCurve[0]= 0;
	}
	if(($edgeZsetA==0)&&($NdistA<$SnapD)){
		$pointNearEdgeCurve[0]= 2;
	}
	if(($edgeZsetB==1)&&($NdistB<$SnapD)){
		$pointNearEdgeCurve[1]= 1;
	}
	if(($edgeZsetB==1)&&($NdistB>$SnapD)){
		$pointNearEdgeCurve[1]= 0;
	}
	if(($edgeZsetB==0)&&($NdistB>$SnapD)){
		$pointNearEdgeCurve[1]= 0;
	}
	if(($edgeZsetB==0)&&($NdistB<$SnapD)){
		$pointNearEdgeCurve[1]= 2;
	}
	float $EdgeDist;
	if($edgeZsetA==1){
		$EdgeDist =$NdistA;
	}else{$EdgeDist=$NdistB;}
	int $SnappingVector=0;
	float $smallestDistance;
	if($NdistA<$NdistB){
		$SnappingVector=0;
	}else{$SnappingVector=1;}
	if($NdistA>$SnapD){
		$edgeZsetA = 0;
	}
	if($NdistB>$SnapD){
		$edgeZsetB = 0;
	}
	int $OneIsNotNearThePlane =0;
	if(($NdistA>$SnapD)||($NdistB<$SnapD)){
		if(($NdistA<$SnapD)||($NdistB>$SnapD)){
			$OneIsNotNearThePlane =1;
		}
	}
	if(($NdistA<$SnapD)||($NdistB<$SnapD)){ 
		if(($edgeZsetA==1)||($edgeZsetB==1)){
			$EdgeDist =0.001;
		}
	}
	if($pointNearEdgeCurve[0]+$pointNearEdgeCurve[1]== 1){
		$newNamesResultA1 = substituteAllString($newNames, "Plane", "");
		$ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
		$ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
		float $A[], $B[];
		$A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
		$A= `MakeCleanFloats($A)`;
		$B= `MakeCleanFloats($B)`;
		if(($A[0] ==0)||($B[0] ==0)){
			$triggerMiddle =2;
			$ifSingleCurve=1;
			vector $NearVecPts[];
			if($edgeZsetA==1){
				$NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
				$NearVecPts[1]= $VecCurEnds[1];
			}else{
				$NearVecPts[0]= $VecCurEnds[0];
				$NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
			}
			rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
			vector $PositionsZ_A[];
			clear $PositionsZ_A;
			$PositionsZ_A = VecCurveEps($CurveItemA[0]);
			vector $PositionsZ_Aii[];  
			if($EdgeDist<2.5){
				$PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A); 	 
				$PositionsZ_Aii = $PositionsZ_Ai;
			} 
			vector $PositionsZ_Aiix[];
			$PositionsZ_Aiix[0] = <<0, 0, 0>>;
			$PositionsZ_Aiix[1] = <<0, 1, 0>>;
			$PositionsZ_Aiix[2] = <<0, 0, 1>>;
			float $CamPos1[];
			$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
			vector $VecTest[];
			if($EdgeDist<2.5){
				$VecTest  = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
			}else{$VecTest  = LineIntersectPlaneCam($PositionsZ_A, $CamPos1, $PositionsZ_Aiix);
			}
			$CurveAv[0] = VecArrayToCurveB($VecTest);
		}
	}
	if( $pointNearEdgeCurve[1]==1){
		$newNamesResultA1 = substituteAllString($newNames, "Plane", "");	 
		$ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
		$ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
		float $A[], $B[];
		$A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
		$A = MakeCleanFloatsZ($A);
		$B = MakeCleanFloatsZ($B);
		if(($A[0] ==0)&&($B[0] ==0)){
			$triggerMiddle =2;
			$ifSingleCurve=1;
			vector $NearVecPts[];
			$NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
			$NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
			rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
			vector $PositionsZ_A[];
			clear $PositionsZ_A;
			$PositionsZ_A = VecCurveEps($CurveItemA[0]);
			delete $CurveItemA;
			$CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);
			string $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
			$evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
			eval($evalSmooth);
			vector $PositionsZ_A[];
			clear $PositionsZ_A;
			$PositionsZ_A = VecCurveEps($CurveItemA[0]);
			$PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
			vector $PositionsZ_Aii[];  
			if($DiffMathA >97.0){				 
				$PositionsZ_Aii[0] = $NearVecPts[0];
				$PositionsZ_Aii[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
				$PositionsZ_Aii[2]= $NearVecPts[1];
			} else{
				$PositionsZ_Aii = $PositionsZ_Ai;}
			vector $PositionsZ_Aiix[];
			$PositionsZ_Aiix[0] = <<0, 0, 0>>;
			$PositionsZ_Aiix[1] = <<0, 1, 0>>;
			$PositionsZ_Aiix[2] = <<0, 0, 1>>;
			float $CamPos1[];
			$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
			vector $VecTest[] = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
			if($DiffMathA >95.0){	$CurveAv[0] = VecArrayToCurve($VecTest);}else{
				$CurveAv[0] = VecArrayToCurve($VecTest);}
		}
	} 
	if($triggerMiddle==0){
		if($GetSizeOfCRV_ends>0){  
			vector $LocCurveEndsVec3D[] = PointArray($queryLocCurveEnds3D);
			float $distancesTo3DCurveEnd[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
			int $Sorted[] = SortNumbersIntIndex($distancesTo3DCurveEnd);
			float $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
			float $distancesTo3DCurveEndi[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
			int $Sortedi[] = SortNumbersIntIndex($distancesTo3DCurveEndi);
			float $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
			vector $FistAndSecond[];
			$FistAndSecond[0]=$LocCurveEndsVec3D[$Sorted[0]];
			$FistAndSecond[1]=$LocCurveEndsVec3D[$Sortedi[0]];
			string $LocNames[];
			$LocNames[0]=$queryLocCurveEnds3D[$Sorted[0]];
			$LocNames[1]=$queryLocCurveEnds3D[$Sortedi[0]];
			$LocNames[2]=$queryLocCurveEnds3D[$Sorted[1]];
			$LocNames[3]=$queryLocCurveEnds3D[$Sortedi[1]];
			vector $VecA= $FistAndSecond[0];
			vector $VecB= $FistAndSecond[1];
			float $XX= $VecA.x;
			float $XXX= $VecB.x;
			if( ($XX*-1)==$XXX){    
				if($NptsDist<2.5){   
					vector $NearVecPts[];
					$NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($VecA));
					$NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($VecB));
					rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];				 
					$PositionsZ_A = VecCurveEps($CurveItemA[0]);
					delete $CurveItemA;
					$CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);
					string $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
					$evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
					eval($evalSmooth);
					vector $PositionsZ_A[];
					clear $PositionsZ_A;
					vector $PositionsZ_Ai[];
					if($DiffMathA >97.0){
						$PositionsZ_Ai[0] = $NearVecPts[0];
						$PositionsZ_Ai[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
						$PositionsZ_Ai[2]= $NearVecPts[1];
					}else{
						$PositionsZ_A = VecCurveEps($CurveItemA[0]);
						$PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
					}
					vector $ReversePositionsZ_Ai[] = ReverseVectorArray($PositionsZ_Ai);
					vector  $PtsMirrorAi[];
					clear $PtsMirrorAi;
					$PtsMirrorAi= VecPtsToZMirrorPts($ReversePositionsZ_Ai);
					int $iiz = 0;
					vector $XIntersect_Ax[];
					clear $XIntersect_Ax;
					for ($eachVecx in  $ReversePositionsZ_Ai){
						$XIntersect_Ax[`size($XIntersect_Ax)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_Ai[$iiz], $CamPos_M, $PtsMirrorAi[$iiz]));
						$iiz++;
					}
					if($DiffMathA >97.0){
						$XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
					}
					$CurveAv =  VecArrayToSplitCurve($XIntersect_Ax);
					rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
					rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
					string $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
					$evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
					eval($evalSmooth);
					string $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
					$evalSmoothi += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
					eval($evalSmoothi);
					$ifSingleCurve=1;
				}
			} 
		}
	}
	if(( $ifSingleCurve == 1)&&($triggerMiddle ==0)){
		delete $CurveItemA[0];
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
		ResetTranslation($CurveAv);
		CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
		editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[1];
		sets -include ZEdgeCurvesSet $CurveAv;
	}else{
		if(( $ifSingleCurve == 1)&&($triggerMiddle ==1)){
			delete $CurveItemA[0];
			rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
			rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
			ResetTranslation($CurveAv);
			CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
		} 
	}
	if( ($ifSingleCurve == 1)&&($triggerMiddle ==2)){
		delete $CurveItemA[0];
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv;
		string $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
		$evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
		eval($evalSmooth);
		sets -include ZEdgeCurvesSet $CurveAv;
		ResetTranslation($CurveAv);
		CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
	}
	$VanishingPointsLinesTempGuides = $CurvesV;
	editDisplayLayerMembers -noRecurse VanishingPointsLines $CurvesV;
	select -cl  ;
	return $CurvesV;
} 
proc vector [] VecPointsToCameraPlane(vector $V[]){
	vector $p = `xform -q -ws -t "LiveSurfaceB"`;
	vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
	vector $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0); 
	float $D, $D1;
	vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
	int $C1;
	$C1=0; 
	for($e in $V){
		$F = DirectionF($C, $e);
		$M = $e+($F);
		$D = distance2Pts($e, $p);
		$F2 = $p+($D*$n1);
		$P1 = ClosestPoint2LineVec($n1, $p, $e);
		$F3 = DirectionF($P1, $p);
		$D1 = distance2Pts($P1, $p);
		$F4 = $e+($D1*$F3);
		$P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
		$F1 = DirectionF($P, $M);
		$O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));
		$C1++;
	}	 
	return $O;
}
proc vector [] CurvatureUtilityCurvature(string $curvesZ, int $NumberofSteps){
	string $myCurve = $curvesZ;
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
	int $numEPs = size ($CurveSelection);
	int $numEPrealNum2 = (( $numEPs -1 ) * 2 ); 
	$numEPrealNum2 = $NumberofSteps;
	string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
	float $step = $numEPrealNum2;  
	int $a;
	float $StepCycle =0;
	int $ii = 0;
	float $CurvatureRadi[];
	vector $CurveVectors[];
	float $values[];
	for($a = 0; $a <= $step;$a++){
		$t =  $a/$step;
		$Par = ($a/$step);
		setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
		$values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
		$CurvatureRadi[$ii] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
		$CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
		$ii++;
	}
	$CurvatureRadi = AverageCurveFloat( $CurvatureRadi);
	float $AverageC=AverageFloats($CurvatureRadi);
	float $AboveOrBelow[] = GatherDataRR($CurvatureRadi, ($AverageC-(($AverageC/6.0)*5.0)));
	vector $ReturnVec[];
	int $COuntNN =0;
	for($eachFloat in $AboveOrBelow){
		if($eachFloat ==1){
			$ReturnVec[`size($ReturnVec)`] = $CurveVectors[$COuntNN];
		}
		$COuntNN++;
	}
	delete $paramlocatorpointOnCurvex;
	return $ReturnVec; 
}
proc float [] AverageCurveFloat( float $newVec[]){
	int $range, $TotalS, $indexState, $indexLeft, $indexRight, $countS, $Xs, $indexLeftS[], $indexRightS[];
	$range = 3;
	$TotalS = `size($newVec)`;
	$indexState = 0;
	float $AVvects[];
	float $Aver;
	while($indexState<$TotalS){
		$countS=1;
		$Xs=0;
		while($countS<$range){
			$indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
			$indexRight = fmod(($indexState + $countS),$TotalS);
			$indexLeftS[$Xs] = $indexLeft;
			$indexRightS[$Xs]= $indexRight;
			$countS++;
			$Xs++;
		}
		$Aver = ((($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0) + ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec [$indexState])/4.0;
		$AVvects[$indexState] = $Aver;
		clear $indexLeftS;
		clear $indexRightS;
		$indexState++;
	}
	return $AVvects;
}
proc vector [] VecCurveEnds(string $CurveItem[]){
	string $CRVendPts[];
	vector $CRV_EndsVec[];
	int $numCVsL,$numCVsSL;
	$numCVsL = `getAttr -size ($CurveItem[0]+".controlPoints")`-1;
	$numCVsSL = $numCVsL-1;
	$CRVendPts[0] = ($CurveItem[0] + ".cv[0]") ;
	$CRVendPts[1] = ($CurveItem[0] + ".cv[" +  $numCVsL + "]") ;
	for($i = 0; $i < 2;$i++){
		$CRV_EndsVec[$i]= `pointPosition -w ($CRVendPts[$i])`;
	}
	return $CRV_EndsVec;
}
proc vector ClosestPoint2LineVecX(float $DirectionLineF[], float $PointOnLine[], float  $PointN[]){
	vector $VlocA;
	vector $VecLineDiri = DirectionFN($PointOnLine, $PointN);
	vector $VecLineDir = $VecLineDiri;
	float $locsA[];
	float $MultDirOne[] = multiplyFloat(1.0, $DirectionLineF);
	float $AddMultF[] = AddFloats($PointOnLine, $MultDirOne);
	float $FDirNorA[] = Normal3Points($PointOnLine, $AddMultF, $PointN);
	float $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
	float $MultDirMx[] = multiplyFloat($DistToLineSTart, $FDirNorA);
	float $AddMultMiiFx[] = AddFloats($PointOnLine, $MultDirMx);
	float $FDirNorB[] = Normal3Points($PointOnLine, $AddMultMiiFx,  $AddMultF);
	float $MultDirMxz[] = multiplyFloat($DistToLineSTart,  $FDirNorB);
	float $AddMultMiiFxz[] = AddFloats($PointOnLine, $MultDirMxz);
	$locsA = lineIntersection($PointN, $FDirNorB, $PointOnLine,  $DirectionLineF);
	$VlocA = <<$locsA[0],$locsA[1],$locsA[2]>>;
	return $VlocA;
}
proc vector [] CRVEndNormals( string $CurveItem ){
	string $CRVendPts[];
	vector $CRV_EndsVec[];
	int $numCVsL,$numCVsSL;
	$numCVsL = `getAttr -size ($CurveItem+".controlPoints")`-1;
	$numCVsSL = $numCVsL-1;
	$CRVendPts[0] = ($CurveItem + ".cv[0]") ;
	$CRVendPts[1] = ($CurveItem + ".cv[1]") ;		 
	$CRVendPts[2] = ($CurveItem + ".cv[" +  $numCVsSL + "]") ;
	$CRVendPts[3] = ($CurveItem + ".cv[" +  $numCVsL + "]") ;
	int $In[]={1,0,2,3};
	for($i = 0; $i < 4;$i++){
		$CRV_EndsVec[$i]= `pointPosition -w ($CRVendPts[$i])`;
	}
	vector $CRV_PlaneNorm[];
	for($i = 0; $i < 2;$i++){
		$CRV_PlaneNorm[$i]= unit( FloatToVec(DirectionFN($CRV_EndsVec[$In[(($i*2)+1)]],$CRV_EndsVec[$In[($i*2)]])));
	}
	return $CRV_PlaneNorm;
}
proc float[ ] BBoxInfo2D(string $i)
{
	float $bbInfo[5];
	select $i;
	PolySelectConvert 3;
	float $test[ ] = `xform -query -ws -t`;
	$sizeTest = ((`size $test`) / 3);
	for ($a=1, $bbInfo[0] = $test[0], $bbInfo[3] = $test[0], $x=3, $bbInfo[1] = $test[1], $bbInfo[4] = $test[1], $y=4, $bbInfo[2] = $test[2], $bbInfo[5] = $test[2], $z=5; $a < $sizeTest; $a++)
	{
		$tempX = $test[$x];
		$x = $x + 3;
		$bbInfo[0] = `min $bbInfo[0] $tempX`;
		$bbInfo[3] = `max $bbInfo[3] $tempX`;
		$tempY = $test[$y];
		$y = $y + 3;
		$bbInfo[1] = `min $bbInfo[1] $tempY`;
		$bbInfo[4] = `max $bbInfo[4] $tempY`;
		$tempZ = $test[$z];
		$z = $z + 3;
		$bbInfo[2] = `min $bbInfo[2] $tempZ`;
		$bbInfo[5] = `max $bbInfo[5] $tempZ`;
	}
	return $bbInfo;
}
proc vector [] ProjectCrv2PlaneNormal(vector $vecRs[],vector $AvN,vector $Midp){
	vector $NewPtsP[];
	vector $PtsVec;
	vector $Tran;
	float $RowA[],$RowB[],$RowC[],$Pts[],$AxisO[],$PtZ[];
	$RowC = $AvN;
	$AxisO = $Tran = $Midp;
	int $SizeVp =`size($vecRs)`;
	for($Ind=0; $Ind<$SizeVp; $Ind++){
		$PtsVec=$vecRs[$Ind];
		$Pts = $PtsVec;
		$PtZ[2] = ($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2]));
		$NewPtsP[$Ind] = (($AvN*-1.0)*$PtZ[2])+$PtsVec;
	}
	return $NewPtsP;
}
proc float  VAnglesofThreeVec(vector $VecA, vector $VecB, vector $VecC){
	float $SideA = distance2Pts( $VecA, $VecB);
	float $SideB = distance2Pts( $VecB, $VecC);
	float $SideC = distance2Pts( $VecC, $VecA);
	float $Pi = 3.1415926535;
	float $ArcangleB = acos((((`pow $SideA 2.000`) + (`pow $SideC 2.000`) - (`pow $SideB 2.000`) )/(2.000*$SideA*$SideC)));
	float $AngleNPiB =  ($ArcangleB*180)/$Pi;
	float $AngleNB = $AngleNPiB;
	return $AngleNB;
}
proc vector [] MultPointMatrixArray( vector $Vec_Array[], matrix $mIA[][],matrix $mIB[][]){
	vector $Tran,$TranB,$ReturnValVec;
	float $RowA[],$RowB[],$RowC[],$RowAi[],$RowBi[],$RowCi[],$MtxF[],$Pts[],$AxisO[],$PtZ[],$PtZT[];
	$MtxF  = MatrixToFloat($mIA);
	$RowA = {$MtxF[0], $MtxF[1], $MtxF[2]};
	$RowB = {$MtxF[4], $MtxF[5], $MtxF[6]};
	$RowC = {$MtxF[8], $MtxF[9], $MtxF[10]};
	$AxisO = $Tran = << $mIA[3][0], $mIA[3][1], $mIA[3][2]>>;
	$MtxFB  = MatrixToFloat($mIB);
	$RowAi = {$MtxFB[0], $MtxFB[1], $MtxFB[2]};
	$RowBi = {$MtxFB[4], $MtxFB[5], $MtxFB[6]};
	$RowCi = {$MtxFB[8], $MtxFB[9], $MtxFB[10]};
	vector $newVecs[];
	for ( $ii = 0; $ii < (`size($Vec_Array)` ); $ii++ ){
		$Pts = $Vec_Array[$ii];
		$PtZ[0] = (($RowA[0]*($Pts[0]-$AxisO[0])) + ($RowA[1]*($Pts[1]-$AxisO[1])) + ($RowA[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
		$PtZ[1] = (($RowB[0]*($Pts[0]-$AxisO[0])) + ($RowB[1]*($Pts[1]-$AxisO[1])) + ($RowB[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
		$PtZ[2] = (($RowC[0]*($Pts[0]-$AxisO[0])) + ($RowC[1]*($Pts[1]-$AxisO[1])) + ($RowC[2]*($Pts[2]-$AxisO[2])))*$MtxFB[15];
		$PtZT[0] = (($RowAi[0])*($PtZ[0])) + (($RowBi[0])*$PtZ[1]) + (($RowCi[0])*$PtZ[2])+$MtxF[3];
		$PtZT[1] = (($RowAi[1])*($PtZ[0])) + (($RowBi[1])*$PtZ[1]) + (($RowCi[1])*$PtZ[2])+$MtxF[7];
		$PtZT[2] = (($RowAi[2])*($PtZ[0])) + (($RowBi[2])*$PtZ[1]) + (($RowCi[2])*$PtZ[2])+$MtxF[11];
		$ReturnValVec = << $PtZT[0], $PtZT[1], $PtZT[2]>>;
		$TranB = << $mIB[3][0], $mIB[3][1], $mIB[3][2]>>;
		$ReturnValVec += $TranB;
		$newVecs[$ii]=$ReturnValVec;
	}
	return $newVecs;
}
proc vector [] Matrix_Curve_TranslationCC(vector $VecPairA[],vector $VecPairB[], vector $CurveVecPointZ[]){
	matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
	0.0, 0.0, 0.0, 0.0;
	0.0, 0.0, 0.0, 0.0;
	0.0, 0.0, 0.0, 1.0 >>;
	matrix $matrixB[4][4] = << 0.0, 0.0, 0.0, 0.0;
	0.0, 0.0, 0.0, 0.0;
	0.0, 0.0, 0.0, 0.0;
	0.0, 0.0, 0.0, 1.0 >>;
	vector $EmptyVecA[];
	$matrixA = TwoPointMatrixPlusAxisWorld($VecPairA, $EmptyVecA, 1);
	vector $EmptyVecB[];
	$matrixB = TwoPointMatrixPlusAxisWorld($VecPairB, $EmptyVecB, 1);
	float $LengthA = distance2Pts ($VecPairA[0], $VecPairA[1]);
	float $LengthB = distance2Pts ($VecPairB[0], $VecPairB[1]);
	float $LengthAB ;
	float $Sign_F;
	if($LengthA<$LengthB){$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}else{$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}
	$LengthAB *= $Sign_F;
	$matrixB[3][3] =$LengthAB;
	vector $NVecPointZ[];
	$NVecPointZ = MultPointMatrixArray($CurveVecPointZ, $matrixA,$matrixB);
	return $NVecPointZ;
}
proc vector MatrixAxisTranlation(vector $SVeci, matrix $mIA, matrix $mIB){
	float $TransL[];
	$TransL[0] = $mIA[3][0];
	$TransL[1] = $mIA[3][1];
	$TransL[2] = $mIA[3][2];
	vector $VecROne[] =  GetRotationVectorsMatrix($mIA );
	vector $tranSVec = << $TransL[0], $TransL[1], $TransL[2]>>;
	vector $tranSVecA = $VecROne[0]+$tranSVec ;	vector $tranSVecB = $VecROne [1]+$tranSVec ;
	vector $tranSVecC = $VecROne[2]+$tranSVec ;
	vector $SVecii[];
	clear $SVecii;
	$SVecii[0] = $tranSVecB;	$SVecii[1] = $tranSVecC;
	$SVecii[2] = $tranSVec;
	vector $SVecPoint =  $SVeci ;
	vector $YZvec = PointToPlaneN($SVecPoint, $SVecii);
	vector $SVecii[];
	clear $SVecii;
	$SVecii[0] = $tranSVecC;	$SVecii[1] = $tranSVecA;
	$SVecii[2] = $tranSVec;
	vector $ZXvec = PointToPlaneN($SVecPoint, $SVecii);
	vector $SVecii[];
	clear $SVecii;
	$SVecii[0] = $tranSVecA;	$SVecii[1] = $tranSVecB;
	$SVecii[2] = $tranSVec;
	vector $XYvec = PointToPlaneN($SVecPoint, $SVecii);
	vector $VecPlanes[];
	$VecPlanes[0] = $YZvec; $VecPlanes[1] = $ZXvec; $VecPlanes[2] = $XYvec;
	vector $VecLineDirM, $VecLineDiri;
	vector $VecLineDirM_All[];
	for($EachVec in $VecPlanes){
		$VecLineDirM_All[`size($VecLineDirM_All)`] = FloatToVec(DirectionFN($EachVec,$SVeci));
	}
	vector $SIgnA[] = GetVectorFloatSign( $VecLineDirM_All);
	vector $SIgnB[] = GetVectorFloatSign($VecROne);
	float $DistToPlane[];
	int $CombA=0;
	int $CountN = 0;
	vector $EachVec;
	for($EachVec in $VecPlanes){
		$CombA = PtsEquivalentF ($EachVec,  $SVeci, 0.001);
		if($CombA != 3){
			$DistToPlane[$CountN]= distance2Pts($SVeci,$EachVec);
		}else{$DistToPlane[$CountN]= 0.0;}
		$CountN++;
	}
	int $CombA=0;
	int $CountN = 0;
	vector $EachVecT;
	float $EachFloatA;
	float $Subs[];
	float $AddF;
	for($EachFloatA in $DistToPlane){
		if($EachFloatA != 0){
			$EachVecT = $SIgnA[$CountN] * $SIgnB[$CountN];
			$Subs =$EachVecT; 
			$AddF = $Subs[0]+$Subs[1]+$Subs[2];
			if($AddF==3){
				$DistToPlane[$CountN]*= 1.0;
			}
			if($AddF==-9){
				$DistToPlane[$CountN]*= -1.0;
			}
		}
		$CountN++;
	}
	float $SCale = $mIB[3][3];
	$SCale *= -1.0;
	$DistToPlane = multiplyFloat($SCale, $DistToPlane);
	vector $NewAXis;
	$NewAXis = MultPointMatrix($DistToPlane, $mIB);
	float $TransLb[];
	$TransLb[0] = $mIB[3][0];
	$TransLb[1] = $mIB[3][1];
	$TransLb[2] = $mIB[3][2];
	float $NewPos[] = AddFloats($TransLb, $NewAXis);
	vector $NewPosVec = <<$NewPos[0], $NewPos[1], $NewPos[2]>>;
	return $NewPosVec;
}
proc vector [] GetVectorFloatSign(vector $VecLineDirM_All[]){
	vector $VecSIGNDirM[]; 
	clear $VecSIGNDirM;
	float $XYZsAxis[];
	float $EachFloat;
	float $SignPN[];
	int $CountIntA =0;
	int $CountInt =0;
	for($EachVeci in $VecLineDirM_All){
		$XYZsAxis = $EachVeci;
		for($EachFloat in $XYZsAxis){
			$SignPN[$CountInt] = `sign $EachFloat`;
			if($SignPN[$CountInt]==0){
				$SignPN[$CountInt] = 1;
			}
			$CountInt++;
		}
		$CountInt=0;
		$VecSIGNDirM[$CountIntA] =FloatToVec($SignPN);
		clear $XYZsAxis;
		$CountIntA++;
	}
	return $VecSIGNDirM;
}
proc matrix TwoPointMatrixPlusAxisWorld(vector $PtsVecii[], vector $EmptyDirVector[],  int $ZeroOne){
	vector $PtsVec[];
	$PtsVec = $PtsVecii;
	vector $Line_Y_zeroMain;
	float $MidPt[];
	$MidPt = MidPoint($PtsVec[0], $PtsVec[1]);
	$Line_Y_zeroMain = PositiveDirectionLine($PtsVec[0], $PtsVec[1]);
	vector $Dir_VecA;
	int $CombA =0;
	vector $eachPointVd;
	int $CountIndexV = 0;
	vector $VecLineDirM;
	float $Addit[];
	float $AdditR;
	for ($eachPointVd in $PtsVec){
		$Dir_VecA = FloatToVec (DirectionFN($eachPointVd, $MidPt));
		$VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
		$Addit = $VecLineDirM ;
		$AdditR = $Addit[0]+$Addit[1]+$Addit[2];
		if($AdditR != 0.0){break;}else{
			$CountIndexV++;}
	}
	if($CountIndexV == 1){
		$PtsVec = ReverseVectorArray($PtsVec);
	}
	float $CamDirVecNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM",  0);
	$CamDirVecNormal= multiplyFloat(-1.0, $CamDirVecNormal);
	vector $DirLine = PositiveDirectionLine($PtsVec[0], $PtsVec[1]);
	vector $Vperp = crossProduct( $DirLine, $CamDirVecNormal, 0, 0 );
	vector $BInomalV = FloatToVec(MultLenToDirAddToPoint(2, $Vperp, $PtsVec[0]));
	vector $BInomalVDirLine = PositiveDirectionLine($PtsVec[0], $BInomalV);
	$BInomalV = FloatToVec(MultLenToDirAddToPoint(4, $BInomalVDirLine, $PtsVec [0]));
	vector $TangentV = FloatToVec(MultLenToDirAddToPoint(4,$CamDirVecNormal,  $PtsVec[0]));
	vector $norm, $bi, $tan;
	vector $norm = FloatToVec($CamDirVecNormal);
	vector $bi = $BInomalVDirLine;
	vector $tan = $DirLine;
	matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
	0.0, 1.0, 0.0, 0.0;
	0.0, 0.0, 1.0, 0.0;
	0.0, 0.0, 0.0, 1.0 >>;
	vector $DirectionVector[2]; 
	$DirectionVector[0] =  $norm;
	$DirectionVector[1] =  $bi;
	$DirectionVector[2] =  $tan;
	$EmptyDirVector = $DirectionVector;

	vector $bi_two = `cross $tan $norm`;
	if($ZeroOne== 0){
		$mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;     
		($bi.x), ($bi.y), ($bi.z),  0.0;     
		($tan.x), ($tan.y), ($tan.z), 0.0;     
		0.0, 0.0, 0.0, 1.0  >>;  
	}
	if($ZeroOne== 1){
		$mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;     
		($bi.x), ($bi.y), ($bi.z),  0.0;     
		($tan.x), ($tan.y), ($tan.z), 0.0;     
		$MidPt[0], $MidPt[1], $MidPt[2], 1.0  >>;  
	}
	float $MatrizFloati[] = MatrixToFloat($mI);
	return $mI;
}
proc matrix TwoPointMatrix(vector $FixVecii[]){
	vector $FixVeci[];
	$FixVeci = $FixVecii;
	vector $LineAMain;
	$LineAMain =FloatToVec (DirectionFN($FixVeci[0], $FixVeci[1]));
	float $MidPt[];
	$MidPt = MidPoint($FixVeci[0], $FixVeci[1]);
	$LineAMain = PositiveDirectionLine($FixVeci[0], $FixVeci[1]);
	vector $DirMTestVec;
	int $CombA =0;
	vector $eachPointVd;
	int $CountIndexV = 0;
	vector $VecLineDirM;
	float $Addit[];
	float $AdditR;
	for ($eachPointVd in $FixVeci){
		$DirMTestVec = FloatToVec (DirectionFN($eachPointVd, $MidPt));
		$VecLineDirM = ( $DirMTestVec+$LineAMain );
		$Addit = $VecLineDirM ;
		$AdditR = $Addit[0]+$Addit[1]+$Addit[2];
		if($AdditR != 0.0){break;}else{
			$CountIndexV++;}
	}
	if($CountIndexV == 1){
		$FixVeci= ReverseVectorArray($FixVeci);
	}
	vector $ZeroA = <<0.0, 0.0, 0.0>>;
	float $Va[] = $FixVeci[0];
	float $Vb[] = $FixVeci[1];
	vector $FixVecB[1];
	$FixVecB[0]= << $Va[0], 0.0, $Va[2] >>;
	$FixVecB[1]= << $Vb[0], 0.0, $Vb[2] >>;
	vector $LineA = PositiveDirectionLine($FixVecB[0], $FixVecB[1]);
	vector $pointYVec = ClosestPoint2LineVec($LineA, $FixVecB[0], $ZeroA);
	vector $LineDirYT = PositiveDirectionLine($pointYVec, $ZeroA);
	vector $DirLine = PositiveDirectionLine($FixVeci[0], $FixVeci[1]);
	vector $Vperp = crossProduct( $DirLine, $LineDirYT, 0, 0 );
	vector $BInomalV = FloatToVec(MultLenToDirAddToPoint(2, $Vperp, $FixVeci[0]));
	vector $BInomalVDirLine = PositiveDirectionLine($FixVeci[0], $BInomalV);
	$BInomalV = FloatToVec(MultLenToDirAddToPoint(4, $BInomalVDirLine, $FixVeci [0]));
	vector $TangentV = FloatToVec(MultLenToDirAddToPoint(4, $LineDirYT, $FixVeci[0]));
	float $FloatDirMajor[] = $DirLine;
	float $FDirNorAi[] = $LineDirYT;
	vector $DirNormi = $LineDirYT;
	float $normal[3];
	$normal = $BInomalVDirLine;
	matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
	0.0, 1.0, 0.0, 0.0;
	0.0, 0.0, 1.0, 0.0;
	0.0, 0.0, 0.0, 1.0 >>;
	vector $norm, $bi, $tan;
	$norm = $LineDirYT;
	$bi = $BInomalVDirLine;
	$tan = $DirLine;
	$tan  = `unit << ($tan.x), ($tan.y), ($tan.z) >>`;
	$norm = `unit << ($norm.x), ($norm.y), ($norm.z) >>`;
	$bi = `unit $bi`;

	$tan = FloatToVec(MakeCleanFloatsZ($tan));
	$norm = FloatToVec(MakeCleanFloatsZ($norm));
	$bi = FloatToVec(MakeCleanFloatsZ($bi));
	$mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;     
	($bi.x), ($bi.y), ($bi.z),  0.0;     
	($tan.x), ($tan.y), ($tan.z), 0.0;     
	$MidPt[0], $MidPt[1], $MidPt[2], 1.0  >>;  
	$mI = MatrixCleanNegZero($mI);
	float $MatrizFloati[] = MatrixToFloat($mI);
	return $mI;
}
proc float [] ClosestPoint2Line(float $DirectionLineF[], float $PointOnLine[], float  $PointN[]){
	vector $VlocA;
	vector $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
	vector $VecLineDir = PositiveDir($DirectionLineF);
	vector $VecLineDirM = $VecLineDiri-$VecLineDir;
	float $locsA[];
	float $Addit[] = $VecLineDirM ;
	float $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
	if($AdditR != 0.0){
		float $MultDirOne[] = multiplyFloat(1.0, $DirectionLineF);
		float $AddMultF[] = AddFloats($PointOnLine, $MultDirOne);
		float $FDirNorA[] = Normal3Points($PointOnLine, $AddMultF, $PointN);
		float $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
		float $MultDirMx[] = multiplyFloat($DistToLineSTart, $FDirNorA);
		float $AddMultMiiFx[] = AddFloats($PointOnLine, $MultDirMx);
		float $FDirNorB[] = Normal3Points($PointOnLine, $AddMultMiiFx,  $AddMultF);
		float $MultDirMxz[] = multiplyFloat($DistToLineSTart,  $FDirNorB);
		float $AddMultMiiFxz[] = AddFloats($PointOnLine, $MultDirMxz);
		$locsA = lineIntersection($PointN, $FDirNorB, $PointOnLine,  $DirectionLineF);
	}else{$locsA =  $PointN ;}
	return $locsA;
}
proc vector ClosestPoint2LineVec(float $DirectionLineF[], float $PointOnLine[], float  $PointN[]){
	vector $VlocA;
	vector $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
	vector $VecLineDir = PositiveDir($DirectionLineF);
	float $locsA[];
	vector $VecLineDirM = $VecLineDiri-$VecLineDir;
	float $Addit[] = $VecLineDirM ;
	float $AdditR = $Addit[0]+$Addit[1]+$Addit[2];
	if($AdditR != 0.0){
		float $MultDirOne[] = multiplyFloat(1.0, $DirectionLineF);
		float $AddMultF[] = AddFloats($PointOnLine, $MultDirOne);
		float $FDirNorA[] = Normal3Points($PointOnLine, $AddMultF, $PointN);
		float $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
		float $MultDirMx[] = multiplyFloat($DistToLineSTart, $FDirNorA);
		float $AddMultMiiFx[] = AddFloats($PointOnLine, $MultDirMx);
		float $FDirNorB[] = Normal3Points($PointOnLine, $AddMultMiiFx,  $AddMultF);
		float $MultDirMxz[] = multiplyFloat($DistToLineSTart,  $FDirNorB);
		float $AddMultMiiFxz[] = AddFloats($PointOnLine, $MultDirMxz);
		$locsA = lineIntersection($PointN, $FDirNorB, $PointOnLine,  $DirectionLineF);
		$VlocA = <<$locsA[0],$locsA[1],$locsA[2]>>;
	}else{$VlocA = FloatToVec($PointN);}
	return $VlocA;
}
proc int Partition(float $a[], int $Index[], int $p, int $r) {
	float $x = $a[$r];
	int $xIndex = $Index[$r];
	int $j = $p - 1;
	int $i;
	for (  $i = $p; $i < $r; $i++) {
		if ($x <= $a[$i]) {
			$j = $j + 1;
			float $temp = $a[$j];
			float $tempIndex = $Index[$j];
			$a[$j] = $a[$i];
			$Index[$j] = $Index[$i];
			$a[$i] = $temp;
			$Index[$i] = $tempIndex;
		}
	}
	$a[$r] = $a[$j + 1];
	$Index[$r] = $Index[$j + 1];
	$a[$j + 1] = $x;
	$Index[$j + 1] = $xIndex;
	return ($j + 1);
}
proc  quickSort(float $a[], int $Index[], int $p, int $r) {
	if ($p < $r) {
		int $q = Partition($a, $Index, $p, $r);
		quickSort($a, $Index, $p, $q - 1);
		quickSort($a, $Index, $q + 1, $r);
	}
}
proc float [] Normal3Points(float $p1[],float $p2[],float $p3[]){ 
	float $center[]; 
	float $normal[];
	float $p1p2[3];
	float $p1p3[3];
	$p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		 $p1p2[2]= $p2[2]-$p1[2];
	$p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		 $p1p3[2]= $p3[2]-$p1[2];
	vector $normalV[];
	$normalV = crossProduct( $p1p2, $p1p3, 0, 0 );
	float $normal[] = `unit $normalV[0]`;
	return $normal;
}
proc int FindLineCross( vector $Vecbv[], vector $Vecbvi[]){
	vector $DirecA = FloatToVec(DirectionFN($Vecbv[0],$Vecbvi[1]));
	vector $DirecB = FloatToVec(DirectionFN($Vecbv[1],$Vecbvi[0]));
	float $centerCross[] = lineIntersection( $Vecbv[0], $DirecA, $Vecbv[1], $DirecB);
	int $trueOrFalse= IsPointInLine ($Vecbv[0], $Vecbv[1], $centerCross);
	return $trueOrFalse;
}
proc int IsPointInLine (float $a[], float $b[], float $c[]){
	vector $VecC[];
	$VecC[0] = FloatToVec($a);
	$VecC[1] = FloatToVec($b);
	$VecC[2] = FloatToVec($c);
	float $DPi =  (distance2Pts($VecC[0], $VecC[1]))/2.0;
	vector $MidPoint = FloatToVec (MidPoint($VecC[0], $VecC[1]));
	float $DPiMid = distance2Pts($VecC[0], $MidPoint);
	float $DPa = distance2Pts( $MidPoint, $VecC[2]);
	int $returnVal=0;
	if($DPa<=$DPiMid){
		$returnVal=1;}
	print $returnVal;
	return $returnVal;
}
proc float[] DirectionFN(float $posAZ[], float $posBZ[]){
	vector $Vai = << $posAZ[0], $posAZ[1], $posAZ[2] >> ;
	vector $Vbi = << $posBZ[0],  $posBZ[1], $posBZ[2] >> ;
	float $xi, $yi, $zi, $x, $y, $z;
	$xi = $Vai.x;
	$yi = $Vai.y;
	$zi = $Vai.z;
	$x = $Vbi.x;
	$y = $Vbi.y;
	$z = $Vbi.z;
	float $u= $xi - $x;
	float $v= $yi - $y;
	float $w= $zi - $z;
	vector $VbiUnit = << $u, $v, $w >> ;
	vector $VbiUnitA = `unit $VbiUnit`;

	float $UnitDirection[];
	$UnitDirection = $VbiUnitA;
	return $UnitDirection;
}
proc vector PositiveDir(float $VecOrFloatA[]){
	vector $VecA = FloatToVec($VecOrFloatA);
	vector $Va = $VecA;
	float $xi, $yi, $zi, $x, $y, $z;
	$xi = $Va.x;
	$yi = $Va.y;
	$zi = $Va.z;
	float $e = 1;
	if(`sign $xi` == -1){
		$e = -1.0;
	}
	if((`sign $xi` == -1)&&(`sign $yi` == -1)){
		$e = -1.0;
	}
	if((`sign $xi` == -1)&&(`sign $zi` == -1)){
		$e = -1.0;
	}
	float $Y = ($e*$xi);
	float $U = ($e*$yi);
	float $V = ($e*$zi);
	vector $YUV = << $Y, $U, $V>>;
	return $YUV;
}
proc vector PositiveDirectionLine(vector $VecA, vector $VecB){
	vector $Va = $VecA;
	vector $Vb = $VecB;
	float $xi, $yi, $zi, $x, $y, $z;
	$xi = $Va.x;
	$yi = $Va.y;
	$zi = $Va.z;
	$x = $Vb.x;
	$y = $Vb.y;
	$z = $Vb.z;
	float $u= $xi - $x;
	float $v= $yi - $y;
	float $w= $zi - $z;
	float $e = 1.0;
	if(`sign $v` == -1){
		$e = -1.0;
	}
	if((`sign $v` == -1)&&(`sign $u` == -1)){
		$e = -1.0;
	}
	if((`sign $v` == -1)&&(`sign $w` == -1)){
		$e = -1.0;
	}
	float $Y = $u/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
	float $U = $v/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
	float $V = $w/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
	vector $YUV = << $Y, $U, $V>>;
	return $YUV;
}
proc PAUSEn(int $n){
	int $i=0;
	while($i < $n){
		eval("playButtonStepForward");
		$i++;
	}
}
proc  float [] Circle3PtsM(float $p1[], float $p2[], float $p3[]){ 
	float $center[]; 
	float $normal[];
	float $p1p2[3];
	float $p1p3[3];
	float $p1p4[3];
	$p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
	$p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
	float $normal[3];
	$normal = crossProduct( $p1p2, $p1p3, 0, 0 );
	float $FloatPosZero[] = {0, 0, 0};
	float $FloatDirection[] = DirectionF($FloatPosZero, $normal);
	float $mid1[3], $mid2[3];
	$mid1 = midPoint2Pts( $p1, $p2 );
	$mid2 = midPoint2Pts( $p1, $p3 );
	float $perp_p1p2[3];
	float $perp_p1p3[3];
	$perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
	$perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
	float $center[] = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
	float $radiusZ = distance2Pts( $p1, $center );
	float $CenterRadius[];
	$CenterRadius = $center;
	$CenterRadius[`size($CenterRadius)`]= $radiusZ;
	return $CenterRadius;
}
proc  float [] Circle3PtZFloats(float $p1[], float $p2[], float $p3[]){
	float $center[];
	float $p1p2[3];
	float $p1p3[3];
	$p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
	$p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
	float $normal[3];
	$normal = crossProduct( $p1p2, $p1p3, 0, 0 );
	float $mid1[3], $mid2[3], $mid3[3];
	$mid1 = midPoint2Pts( $p1, $p2 );
	$mid2 = midPoint2Pts( $p1, $p3 );	 
	float $perp_p1p2[3];
	float $perp_p1p3[3];
	$perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
	$perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
	float $center[] = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
	float $radiusZ = distance2Pts( $p1, $center );
	float $CenterRadius[];
	$CenterRadius = $center;
	$CenterRadius[`size($CenterRadius)`]= $radiusZ;
	return $CenterRadius;
}
proc float [] Circle3PtZFloatsI(float $p1[], float $p2[], float $p3[]){ 
	float $center[]; 
	float $normal[];
	float $p1p2[3];
	float $p1p3[3];
	float $p1p4[3];
	$p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
	$p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
	$p1p4[0] = $p2[0]-$p3[0]; 		$p1p4[1] = $p2[1]-$p3[1]; 		$p1p4[2]= $p2[2]-$p3[2];
	float $normal[3];
	$normal = crossProduct( $p1p2, $p1p3, 0, 0 );
	float $FloatPosZero[] = {0, 0, 0};
	float $FloatDirection[] = DirectionF($FloatPosZero, $normal);
	float $MultDirP[] = multiplyFloat(2, $FloatDirection);
	float $mid1[3], $mid2[3], $mid3[3];
	$mid1 = midPoint2Pts( $p1, $p2 );
	$mid2 = midPoint2Pts( $p1, $p3 );
	$mid3 = midPoint2Pts( $p2, $p3 );
	float $perp_p1p2[3];
	float $perp_p1p3[3];
	float $perp_p1p4[3];
	$perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
	$perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
	$perp_p1p4 = crossProduct( $normal, $p1p4, 0, 1 );
	float $center[] = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
	float $FloatDirPerpCenter[] = DirectionF($center, $mid3);
	float $FloatDirPerpCenterB[] = DirectionF($center,$mid1);
	float $FloatDirPerpCenterC[] = DirectionF($center,$mid2);
	float $FloatDirPointAB[] = DirectionF($p1, $p2);
	float $FloatDirPointBC[] = DirectionF($p2, $p3);
	float $FloatDirPointAC[] = DirectionF($p1, $p3);
	float $center6[] = lineIntersection( $p1, $FloatDirPerpCenter, $p2, $FloatDirPointBC );
	float $center7[] = lineIntersection( $p3,  $FloatDirPerpCenterB, $p1, $FloatDirPointAB );
	float $center8[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );
	curve2points($center, $mid1);
	curve2points($center,$mid2);
	curve2points($center,$mid3);
	float $center9[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPerpCenter );
	float $OrthoCenterCir[] = midPoint2Pts( $center9, $center );
	float $Radius2HalfTimes2 = (distance2Pts( $center9, $center ))*2;
	float $Radius2BHalf = (distance2Pts( $center9, $center ));
	float $radiusZ = distance2Pts( $p1, $center );
	float $Radius3Half = $radiusZ/2;
	string $circlesItemA[];
	$circlesItemA[0] = Circles_Direction($OrthoCenterCir, $FloatDirection, $Radius3Half);
	string $circlesItem[];
	$circlesItem[0] = Circles_Direction($center, $FloatDirection, $radiusZ);
	float $radiusZ = distance2Pts( $p1, $center );
	float $CenterRadius[];
	$CenterRadius = $center;
	$CenterRadius[`size($CenterRadius)`]= $radiusZ;
	return $CenterRadius;
}
proc vector [] VecArrayDiff(int $IndeXxz[]){
	global vector $AllVecsG[];
	global vector $WorkingAllVecsG[];
	vector $VecS[]= $AllVecsG;
	vector $newVec[];
	int $Ixx = 0;
	int $EIndex[];
	$EIndex = $IndeXxz;
	$EIndex = `sort $EIndex`;
	int $Ii=0;
	int $one;
	for ($eachVc in $VecS){
		$one =$EIndex[$Ii];
		if(!($Ixx==$one)){
			$newVec[`size($newVec)`] = $VecS[$Ixx];
		}else{$Ii++;}
		$Ixx++;
	}
	$WorkingAllVecsG = $newVec;
	return $newVec;
}
proc vector [] VecArrayInclude(int $IndeXxz[]){
	global vector $AllVecsG[];
	global vector $WorkingAllVecsG[];
	vector $VecS[]= $AllVecsG;
	vector $newVec[];
	int $Ixx = 0;
	int $EIndex[];
	$EIndex = $IndeXxz;
	$EIndex = `sort $EIndex`;
	int $Ii=0;
	int $one;
	for ($eachVc in $VecS){
		$one =$EIndex[$Ii];
		if(($Ixx==$one)){
			$newVec[`size($newVec)`] = $VecS[$Ixx];
		}else{$Ii++;}
		$Ixx++;
	}
	$WorkingAllVecsG = $newVec;
	return $newVec;
}
proc string AddItemString(int $iN, string $NumLetorSy){
	int $Xz =0;
	string $AddItem ="";
	while($iN > $Xz){
		$AddItem+= $NumLetorSy;
		$Xz++;
	}
	return $AddItem;
}
proc StereoCurveZ(string $CurveItemZai, string $CurveItemZbi){
	global string $StereoCurveZ[];
	global string $VanishingPointsLinesTempGuides[];
	global int $addNumbersA;	
	global float $VanishingPointGlobal[];
	global string $PlaneCurveS[];
	global float $AngleEpiPole;
	global int $IsOrthoLineTrue;
	global int $AxisOrthoLine;
$IsOrthoLineTrue =0;
	float $SnapR = 2.59;
	float $Smooth = 398;
	float $DiffSumTol =97.95;
int $START_END[];
string $CrvNA[];
	int $EndsAtZero;
	vector $EndrEndsa[];
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 1 -tol 0.05 $CurveItemZai;
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 1 -tol 0.05 $CurveItemZbi;
	vector $AllLocPositionsZi[];
	clear $AllLocPositionsZi;
	$AllLocPositionsZi = VecCurveCvs( $CurveItemZai);
	string $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
	ResetTranslation({$newPlaneCurveA});
	delete $CurveItemZai;
	$CurveItemZai = $newPlaneCurveA;
	clear $AllLocPositionsZi;
	$AllLocPositionsZi = VecCurveCvs( $CurveItemZbi);
	$newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
	ResetTranslation({$newPlaneCurveA});
	delete $CurveItemZbi;
	$CurveItemZbi = $newPlaneCurveA;
	vector $VecCurEndsa[] = VecCurveEnds({$CurveItemZai});
	vector $VecCurEndsb[] = VecCurveEnds({$CurveItemZbi});
	$StereoCurveZ[0]= $CurveItemZai;
	$StereoCurveZ[1]= $CurveItemZbi;
	vector $PositionsZ_A[];
	clear $PositionsZ_A;
	$PositionsZ_A = VecCurveCvs($CurveItemZai );
	vector $PositionsZ_B[];
	clear $PositionsZ_B;
	$PositionsZ_B = VecCurveCvs($CurveItemZbi );
	vector  $VecPtsMirrorA[];
	clear $VecPtsMirrorA;
	vector  $VecPtsMirrorB[];
	clear $VecPtsMirrorB;
	$VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
	$VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
	float $CamPos_A[];
	float $CamPlane1[];
	$CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
	$CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
	float $CamDirVecNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
	float $MultDirCam[] = multiplyFloat(-1, $CamDirVecNormal);
	float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;
	vector  $VecPtsMirrorEnds_A[];
	clear $VecPtsMirrorEnds_A;	
	vector  $VecPtsMirrorEnds_B[];
	clear $VecPtsMirrorEnds_B;	
	$VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
	$VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
	float $CamNormM[] = ` MirrorFloatXYZ 0 $MultDirCam`;		
	float $MidEpipolZx[] = MidPoint($CamPos_M, $CamPos_A);	
	float $MidEpipolPosFCam[]= FloatPointsToCamPlane($MidEpipolZx);
	float $EpipolPosCamM[] = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;	
	float $MidPosFCam[]= $CamPlane1;
	float $FloatDirEpipol[] = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
	float $FloatDirEpipolB[] = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
	vector $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
	vector $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);
	float $DistTOEpipol_CurEndA;
	float $DistTOEpipol_CurEndB;
	$DistTOEpipol_CurEndA = distance2Pts($PointN_Epi, $VecCurEndsb[0]);
	$DistTOEpipol_CurEndB = distance2Pts($PointN_EpiB, $VecCurEndsb[0]);
	float $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
	float $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
	float $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;
	float $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
	float $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
	float $BCDiff = abs($BCurEndB - $BCurEndBNN);
	float $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd ;
	float $BCDiffi = abs($BCurEndB - $BCurEndBNNi);
	int $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);
	float $FloatDirEndPtsA[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
	float $EulerAngleA[] = EulerAngB($FloatDirEndPtsA, $FloatDirEpipol);	
	float $EulerAngle_A = $EulerAngleA[3];
	float $FloatDirEndPtsB[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
	float $EulerAngleB[] = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);	
	float $EulerAngle_B = $EulerAngleB[3];
	float $FloatDirEndPtsAi[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
	float $EulerAngleAi[] = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);	
	float $EulerAngle_Ai = $EulerAngleAi[3];
	float $FloatDirEndPtsBi[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
	float $EulerAngleBi[] = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);	
	float $EulerAngle_Bi = $EulerAngleBi[3];
	float $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
	float $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;
	float $EpipolXx[] = {0.0,$CamPos_A[1],$CamPos_A[2]};	
	float $PlaneEpipolXx[]= FloatPointsToCamPlane( $EpipolXx);
	float $EpipolYx[] = {$CamPos_A[0],0.0,$CamPos_A[2]};	
	float $PlaneEpipolYx[]= FloatPointsToCamPlane( $EpipolYx);
	float $EpipolZx[] = {$CamPos_A[0],$CamPos_A[1],0.0};	
	float $PlaneEpipolZx[]= FloatPointsToCamPlane( $EpipolZx);

	vector $Vecbv[];
	vector $Vecbvi[];
	$Vecbv  = $VecCurEndsa;
	$Vecbvi = $VecCurEndsb;
	int $IfTrue;
	$IfTrue = FindLineCross( $Vecbv , $Vecbvi );
	int $weighedtFindings=0;
	int $weighedtFindingsZ=0;
	int $weighedtFindingsN=0;
	if($IfTrue=1){
		$weighedtFindings++;
		$weighedtFindingsZ++;
	}else{$weighedtFindings--;
		$weighedtFindingsN++;
	}
	if($IntIfNearZero==1){
		$weighedtFindings++;
		$weighedtFindingsZ++;
	}else{$weighedtFindings--;
		$weighedtFindingsN++;}
	if($EulerAngle_AB<$EulerAngle_AiBi){
		$weighedtFindings++;
		$weighedtFindingsZ++;
	}else{$weighedtFindings--;
		$weighedtFindingsN++;}

	vector $NewVecENDsi[];
	float $LengCRV_a = `arclen $CurveItemZai`;
	vector $CRV_ENDSi[];
	$CRV_ENDSi = $VecCurEndsa;
	float $DistEndsi; 
	$DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
	float $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
	//float $DiffMathA = ($LengCRV_a-$DistEndsi) / ($DistEndsi/100.0);

	float $LengCRV_b = `arclen $CurveItemZbi`;
	vector $CRV_ENDSii[];
	$CRV_ENDSii = $VecCurEndsb;
	float $DistEndsii; 
	$DistEndsii = distance2Pts($CRV_ENDSii[0], $CRV_ENDSii[1]);
	float $DiffMathB = $DistEndsii / ($LengCRV_b/100.0);

	float $PerDiffSum = ($DiffMathA+$DiffMathB)/2.0;

	//print (" DiffMathA " +$DiffMathA + " DiffMathB " +$DiffMathB +"\n");
	//if(($DiffMathA> 96.5) && ($DiffMathB > 96.5)){
	//$PerDiffSum =99;
	//}else{$PerDiffSum =1;}

	int $triggerStraitCRV=0;
	vector $FoundEpipol;
	int $triggerNoTransENDA=0;
	int $triggerNoTransENDB=0;
	int $First_Second_Both_None=0;
	vector $PointsA[];
	vector $PointsB[];
	//print ("START FindIfCurveIsOrthoEpipol" +"\n");
	float $MidCurveA[];
	float $MidCurveB[];
	vector $XYZdirectL[];
	$XYZdirectL[0] = << 1,0,0>>;
	$XYZdirectL[1] = << 0,1,0>>;
	$XYZdirectL[2] = << 0,0,1>>;
	vector $LineDirect_3D;
	int $trigger_straitC =0;
	if( $PerDiffSum>$DiffSumTol){
		print ("FIRST IF : ENGAGED PerDiffSum" +$PerDiffSum +"\n");
		print ("ENGAGED FindIfCurveIsOrthoEpipol" +"\n");
		$triggerStraitCRV=1;
		float $DDirEpipol[] = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
		$MidCurveA  = MidPoint($VecCurEndsa[0], $VecCurEndsa[1]);
		$MidCurveB  = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);
		vector $DDirEpipolXYZ[];
		$DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
		$DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
		$DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
		vector $AllEpipolXYZ[];
		$AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
		$AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
		$AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);

		vector $EpipolD[];
		$EpipolD = $DDirEpipolXYZ;
		vector $LineMidi;
		vector $NewDirZi;
		float $AngleXi;
		int $Trueii=0;

		$NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
		//print ("FindIfCurveIsOrthoEpipol" +"\n");
		//print ($NewDirZi +"\n");  
		//print ("FindIfCurveIsOrthoEpipol" +"\n");
		//print ($NewDirZi +"\n");  
		//print ("FindIfCurveIsOrthoEpipol" +"\n");
		//print ($NewDirZi +"\n");      
		$FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
		$LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
		
	}
print ("IsOrthoLineTrue = "+$IsOrthoLineTrue+"\n");   

	if($weighedtFindingsZ<$weighedtFindingsN){
		/////////////////////////////REMOVED

		/////////////////////////////
		//if(($DistB<$DistA)||($weighedtFindingsZ<$weighedtFindingsN)){
		if( ($weighedtFindingsZ<$weighedtFindingsN)){

			cycleBackgroundColor;			
			$PositionsZ_B = ReverseVectorArray($PositionsZ_B);
			$VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);
			$VecCurEndsb = ReverseVectorArray($VecCurEndsb);
			$VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
		}
	}

	string $queryLocCurveEnds3D[];
	$queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
	$queryLocCurveEnds3D = `sort $queryLocCurveEnds3D`;
	int $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
	int $TrackAllExisting3DCrv[] = CreatePairIntIndex($SizeCrvi);
	string $LayerCurvesRangeA[];
	$LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;
	int $SizeCrvR =  `size($LayerCurvesRangeA)` ;
	int $triggerNoTrans = 0;
	int $triggerNoTransA = 0;
	int $triggerNoTransB = 0;
	int $triggerNoTrans = 0;
	vector $VecOnPlaneA[];	 
	vector $VecOnPlaneB[];
	vector $IntersectEnds_Ax[];
	clear $IntersectEnds_Ax;
	int $iia = 0;
	vector $Intersect_A[]; 
	float $PointToCamDir[];
	float $PointsClos[];
	vector $PositionsZ_Ai[];
	vector $PositionsZ_Bi[];
	string $ThefirstCurve;
	string $ThefirstCurvei;

	if(!(`size($queryLocCurveEnds3D)` > 2)){

		if($PerDiffSum >$DiffSumTol){
			print ("ENGAGED PerDiffSum " +$PerDiffSum +"\n");
			print (" MAKING STRAIT  " +"\n");
			vector $PositionsZ_Bii[];
			vector $PositionsZ_Aii[];	
			int $iis = 0;
			vector $XIntersect_Ax[2];						 
			for ($eachVecx in  $VecCurEndsb){
				$XIntersect_Ax[$iis] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsb[$iis], $CamPos_M, $VecPtsMirrorEnds_A[$iis]));		
				$iis++;
			}
			$XIntersect_Ax[2] =  $XIntersect_Ax[1];
			$XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));	
			$XIntersect_Ax[0] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[0]);
			$XIntersect_Ax[2] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[2]);
			$PositionsZ_Bii= $XIntersect_Ax;							
			$PositionsZ_Aii= VecPtsToZMirrorPts($PositionsZ_Bii);
			$ThefirstCurve = VecArrayToCurve($XIntersect_Ax);
			vector  $PtsMirrorAi[];					
			$PtsMirrorAi= VecPtsToZMirrorPts($XIntersect_Ax);
			$ThefirstCurvei = VecArrayToCurve($PtsMirrorAi);	

			$trigger_straitC =1;
		}
	}

	////////////
	if(`size( $queryLocCurveEnds3D)`>2){	
		
		vector $LocCurveEndsVec3D[] = PointArray($queryLocCurveEnds3D);		
		for ($eachVecx in  $VecCurEndsa)
		{
			$IntersectEnds_Ax[$iia] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsa[$iia], $CamPos_M, $VecPtsMirrorEnds_B[$iia]));
			$iia++;
		}

		float $distToCurveE_A[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[0]);
		int $AllLocsi[] = CreateIntIndex(`size($LocCurveEndsVec3D)`);
		string $AllLocs_String[] = IntArrayToStringArray($AllLocsi);
		string $EmptyStringNewOrderA[];
		float $newOrdersZA[] = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
		$EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
		int $New_AllLocs_A[];
		$New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
		int $Near_index_A = $New_AllLocs_A[0];
		float $Distance_A = $distToCurveE_A[$Near_index_A];
		float $Found_pt_A[] = $LocCurveEndsVec3D[$Near_index_A];		
		float $newOrdersZAM[] = $Found_pt_A;
		$newOrdersZAM[0] = $Found_pt_A[0] *-1;	
		float $distToCurveE_B[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[1]);		
		string $EmptyStringNewOrderB[];
		float $newOrdersZB[] = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
		$EmptyStringNewOrderB = ReverseStringArray($EmptyStringNewOrderB);
		int $New_AllLocs_B[];
		$New_AllLocs_B = ArrayToIntList($EmptyStringNewOrderB);
		int $Near_index_B = $New_AllLocs_B[0];
		float $Distance_B = $distToCurveE_B[$Near_index_B];
		float $Found_pt_B[] = $LocCurveEndsVec3D[$Near_index_B];
		float $newOrdersZBM[] = $Found_pt_B;
		$newOrdersZBM[0] = $Found_pt_B[0] *-1;
		
		$PointsA[0] = FloatToVec($Found_pt_A);
		$PointsA[1] = FloatToVec($Found_pt_B);
		vector $PointsB[];
		$PointsB[0] = FloatToVec($newOrdersZAM); // negative mirror of first endpoint of first curve
		$PointsB[1] = FloatToVec($newOrdersZBM);		
		
		$VecOnPlaneA = VecPointsToCameraPlane($PointsA);		 
		$VecOnPlaneB = VecPointsToCameraPlane($PointsB);
		
		string $NewFoundLocs[];
		$NewFoundLocs[0] = $queryLocCurveEnds3D[$Near_index_A];
		$NewFoundLocs[1] = $queryLocCurveEnds3D[$Near_index_B];

 print($NewFoundLocs[0]+"\n");
 print($NewFoundLocs[1]+"\n");
// string $XLocsA = "LOCcurve259START";
// string $XLocsB = "LOCcurve200START";

string $XLocsA = $NewFoundLocs[0];
string $XLocsB = $NewFoundLocs[1];

$START_END[0] = gmatch ((match("END",$XLocsA)),"END");
$START_END[1] = gmatch ((match("END",$XLocsB)),"END");
$CrvNA[0] =$CrvNA[1]="curve";
string $Na=(match ("[0-9]+", $XLocsA));
string $Nb=(match ("[0-9]+", $XLocsB));
$CrvNA[0] = $CrvNA[0]+$Na;
$CrvNA[1] = $CrvNA[1]+$Nb;

select -r $CrvNA;
PAUSEn(1); 





		string $arrayCurvesNear[];
		$arrayCurvesNear[0] = ("Plane"+$NewFoundLocs[0]);
		$arrayCurvesNear[1] = ("Plane"+$NewFoundLocs[1]);



		$NewFoundLocs = $arrayCurvesNear;
		vector $LocOnPlaneVec[] = PointArray($NewFoundLocs);
		float $distToPlaneLoc[];
		$distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocOnPlaneVec[0]);
		$distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocOnPlaneVec[1]);
		vector $LoCz_3D[];
		vector $TXI = << -1.0 , 1.0, 1.0>>;
		$LoCz_3D[0] = MultVec($IntersectEnds_Ax[0],$TXI);
		$LoCz_3D[1] = MultVec($IntersectEnds_Ax[1], $TXI);

		////////////////////////
		float $DistToIntersectTOnear[];
		$DistToIntersectTOnear[0] = distance2Pts($IntersectEnds_Ax[0], $PointsA[0]);
		$DistToIntersectTOnear[1] = distance2Pts($IntersectEnds_Ax[1], $PointsA[1]);
		$DistToIntersectTOnear[2] = distance2Pts($LoCz_3D[0], $PointsB[0]);
		$DistToIntersectTOnear[3] = distance2Pts($LoCz_3D[1], $PointsB[1]);

		float $distToPlaneLoc3D[];
		$distToPlaneLoc3D[0] = distance2Pts($VecCurEndsa[0], $PointsA[0]);
		$distToPlaneLoc3D[1] = distance2Pts($VecCurEndsa[1], $PointsA[1]);
		$distToPlaneLoc3D[2] = distance2Pts($VecCurEndsb[0], $PointsB[0]);
		$distToPlaneLoc3D[3] = distance2Pts($VecCurEndsb[1], $PointsB[1]);
		//////////////////////////				
		
		float $DiffMathA =  $DistToIntersectTOnear[0]/ ($distToPlaneLoc3D[0]/100.0);
		float $DiffMathB =  $DistToIntersectTOnear[1] / ($distToPlaneLoc3D[1]/100.0);
		float $DiffMathAm =  $DistToIntersectTOnear[2]/ ($distToPlaneLoc3D[2]/100.0);
		float $DiffMathBm =  $DistToIntersectTOnear[3] / ($distToPlaneLoc3D[3]/100.0);

		float $relativeDistanceA = ($DiffMathA+$DiffMathAm)/2.0;
		float $relativeDistanceB = ( $DiffMathB+$DiffMathBm)/2.0;
		//////////////
		//REMOVED AND PLACE BELOW
		/////////////

//print ("relativeDistanceA" + $relativeDistanceA+"\n");
//print ("relativeDistanceB" + $relativeDistanceB+"\n");

		if($relativeDistanceA<$SnapR){			
			$triggerNoTransA++;
		}
		if($relativeDistanceB <$SnapR){			
			$triggerNoTransB++;
		}

		if(!($relativeDistanceA<$SnapR)){
			$VecOnPlaneA[0] = $VecCurEndsa[0];
			$VecOnPlaneB[0] = $VecCurEndsb[0];
			$triggerNoTransENDA=1;
		}else{$triggerNoTrans++;
			$First_Second_Both_None =0;
		}

		if(!($relativeDistanceB<$SnapR)){
			$VecOnPlaneA[1] = $VecCurEndsa[1];
			$VecOnPlaneB[1] = $VecCurEndsb[1];
			$triggerNoTransENDB=1;
		}else{$triggerNoTrans++;
			$First_Second_Both_None =1;

			if($triggerNoTransENDA==0){ $First_Second_Both_None =-2;}

		}


		if($triggerNoTrans==0){
			$First_Second_Both_None =-1;}

		//if(($triggerNoTransENDA +$triggerNoTransENDB)== 2){
		//}

		//if(($triggerNoTransENDA +$triggerNoTransENDB)== 0){
		//}

		int $ConnectedEnds = $triggerNoTransENDA + $triggerNoTransENDB;
		vector $UnconnectedEnds[];
		if($triggerNoTransENDA==1){
			$UnconnectedEnds[0]= $VecOnPlaneA[0];
			$UnconnectedEnds[1]= $VecOnPlaneB[0];
		}else{$UnconnectedEnds[0]= $VecOnPlaneA[1];
			$UnconnectedEnds[1]= $VecOnPlaneB[1];}

		string $arrayCurvesNearA[];
		clear $arrayCurvesNearA;
		string $arrayCurvesNearB[];
		clear $arrayCurvesNearA;
		int $AddAB = $triggerNoTransA+$triggerNoTransB;
		int $New_AllLocs_AB[];
		float $distToCurveE_AB[];

		if($triggerNoTrans!=0){
			vector $PositionsZ_A[];
			
			$PositionsZ_A = VecCurveCvs($CurveItemZai );
			$PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEndsa,$VecOnPlaneA, $PositionsZ_A);
			$PositionsZ_Bi = Matrix_Curve_TranslationCC($VecCurEndsb, $VecOnPlaneB, $PositionsZ_B);
			clear $VecPtsMirrorA;
			$VecPtsMirrorA= VecPtsToZMirrorPts( $PositionsZ_Ai);
			clear $VecPtsMirrorB;
			$VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_Bi);
			$PositionsZ_A = $PositionsZ_Ai;
			$PositionsZ_B = $PositionsZ_Bi;
			cycleBackgroundColor;
		}

	}
	vector $Intersect_LineB_a;
	vector $Intersect_LineB_b;

	//print (" IsOrthoTrueZi Eq  "+$IsOrthoLineTrue +"\n");
	int $PairInt[];

	if(($triggerNoTrans==0)&&($PerDiffSum >$DiffSumTol)){


		vector $PositionsZ_Bii[];
		vector $PositionsZ_Aii[];		
		int $iis = 0;
		vector $XIntersect_Ax[2];						 
		for ($eachVecx in  $VecCurEndsb){
			$XIntersect_Ax[$iis] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsb[$iis], $CamPos_M, $VecPtsMirrorEnds_A[$iis]));		
			$iis++;
		}
		$XIntersect_Ax[2] =  $XIntersect_Ax[1];
		$XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
		$XIntersect_Ax[0] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[0]);
		$XIntersect_Ax[2] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[2]);

		$PositionsZ_Bii= $XIntersect_Ax;							
		$PositionsZ_Aii= VecPtsToZMirrorPts($PositionsZ_Bii);

		$ThefirstCurve = VecArrayToCurve($XIntersect_Ax);
		vector  $PtsMirrorAi[];					
		$PtsMirrorAi= VecPtsToZMirrorPts($XIntersect_Ax);
		$ThefirstCurvei = VecArrayToCurve($PtsMirrorAi);			

		$trigger_straitC =1;
		
	}
float $Point3DAM[];	
float $Point3DA[] ;	

	if($triggerNoTrans!=0){
		print ("triggerNoTrans Doesnt not Eq ZERO" +"\n");
		if($IsOrthoLineTrue==1){
			print ("IsOrthoLineTrue Eq ONE" +"\n");	
			
			//############HERE
			
			if($AxisOrthoLine!=0){

			if($First_Second_Both_None>=0){

	$FloatDirEpipol = DirectionFN($VecOnPlaneA[$First_Second_Both_None], $FoundEpipol);
					$FloatDirEpipolB= DirectionFN($VecOnPlaneB[$First_Second_Both_None], $FoundEpipol);
				}

			}	
	
			if($AxisOrthoLine==0){
	print ("HERE IS THE SPOT" +"\n");	
			
			float $lineEPointA[]= MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);			
				vector $Xdirection = << 1.0,0.0,0.0>>;
				$Intersect_LineB_a = FloatToVec (lineIntersection($PointsA[$First_Second_Both_None], $Xdirection, $lineEPointA,(DirectionFN( $CamPos_A,$lineEPointA)) ));
				Loc $Intersect_LineB_a;
				float $Point3DA[] = $Intersect_LineB_a;
				float $Point3DAM[] = {($Point3DA[0]*-1), $Point3DA[1],$Point3DA[2]};

			}
			if($AxisOrthoLine!=0){
				print ("AxisOrthoLine Doesnt not Eq ZERO" +"\n");
				 if($First_Second_Both_None>=0){
				if($First_Second_Both_None==1){
					print ("First_Second_Both_None Eq ONE! " +"\n");
					$PairInt={0,1};
				}else{ $PairInt={2,3};
					print ("First_Second_Both_None NOT Eq ONEZZZ! " +"\n");
				}
				}
			}

				
				vector $Intersect_BX[];	
		vector $PairVectors[];				
			vector $EpipolXLine;
		//PROBLEM HERE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 if($First_Second_Both_None>=0){
					if($AxisOrthoLine!=0){

						$Intersect_BX= VecPtsToZMirrorPts($IntersectEnds_Ax);

			$PairVectors[0]=FloatToVec(FloatPointsToCamPlane($IntersectEnds_Ax[0]));
				$PairVectors[1]= FloatToVec(FloatPointsToCamPlane($Intersect_BX[0]));
				$PairVectors[2]=FloatToVec(FloatPointsToCamPlane($IntersectEnds_Ax[1]));
				$PairVectors[3]= FloatToVec(FloatPointsToCamPlane($Intersect_BX[1]));
				 $EpipolXLine = DirectionFN( $MidEpipolPosFCam, $PairVectors[$PairInt[0]]) ;
	print ("HERE IS THE SPOT AAAAAA" +"\n");	
				}else{
				
				
				$PairVectors[0]=FloatToVec(FloatPointsToCamPlane($Point3DA));
				$PairVectors[1]= FloatToVec(FloatPointsToCamPlane($Point3DAM));
				$PairVectors[2]=FloatToVec(FloatPointsToCamPlane($Point3DA));
				$PairVectors[3]= FloatToVec(FloatPointsToCamPlane($Point3DAM));
				 $EpipolXLine = DirectionFN( $MidEpipolPosFCam, $PairVectors[$PairInt[0]]) ;	
					print ("HERE IS THE SPOT BBBBBB" +"\n");	
				}
			
 
				$Intersect_LineB_a = FloatToVec (lineIntersection($VecOnPlaneA[$First_Second_Both_None], $FloatDirEpipol, $MidEpipolPosFCam,$EpipolXLine));
				$Intersect_LineB_b = FloatToVec (lineIntersection($VecOnPlaneB[$First_Second_Both_None], $FloatDirEpipolB, $MidEpipolPosFCam,$EpipolXLine));
				
		// Loc $Intersect_LineB_a;
		// Loc $Intersect_LineB_b;
	
				clear $PositionsZ_A;
				clear $PositionsZ_B;
				clear $VecPtsMirrorEnds_A;
				clear $VecPtsMirrorEnds_B;
				clear $VecPtsMirrorA;
				clear $VecPtsMirrorB;
				
				
				$PositionsZ_A[0] = $VecOnPlaneA[$First_Second_Both_None];
				$PositionsZ_A[1] = FloatToVec (MidPoint($VecOnPlaneA[$First_Second_Both_None],$Intersect_LineB_a));
				$PositionsZ_A[2] = $Intersect_LineB_a;
				$PositionsZ_B[0] = $VecOnPlaneB[$First_Second_Both_None];
				$PositionsZ_B[1] = FloatToVec (MidPoint($VecOnPlaneB[$First_Second_Both_None], $Intersect_LineB_b));
				$PositionsZ_B[2] = $Intersect_LineB_b;
				
				$VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
				$VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
				$VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
				$VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
			 
			}
			
			
			
			
			
		}
	}

	if($trigger_straitC!=1){
		int $iiz = 0;
	
		for ($eachVecx in  $VecPtsMirrorA)
		{
			$Intersect_A[`size($Intersect_A)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_B[$iiz], $CamPos_M, $VecPtsMirrorA[$iiz]));
			$iiz++;
		}

if($triggerNoTrans==2){

vector $CrvNormalA[] = CRVEndNormals( $CrvNA[0] );
vector $CrvNormalB[] = CRVEndNormals( $CrvNA[1] );
vector $aveNorm = unit(($CrvNormalA[$START_END[0]]+$CrvNormalB[$START_END[1]])/2.0);
vector $MidPointC = ($Intersect_A[0]+$Intersect_A[`size($Intersect_A)`-1])/2.0;
vector $DirectC = DirectionFN($Intersect_A[0], $MidPointC);

//$Intersect_A= VecPointsToPlaneX($Intersect_A,$aveNorm,$MidPointC);
vector $NormPts =(($aveNorm*2.5)+$MidPointC);
vector $P1 = ClosestPoint2LineVecX($DirectC, $MidPointC, $NormPts);
vector $NewNormal = (DirectionFN($NormPts, $P1));
$Intersect_A=ProjectCrv2PlaneNormal($Intersect_A,$NewNormal,$MidPointC);
}

if(($triggerNoTransA+$triggerNoTransB)==1){
/*
vector $AB_endPts[];
$AB_endPts[$triggerNoTransA] =$Intersect_A[0] ;
$AB_endPts[$triggerNoTransB] =$Intersect_A[`size($Intersect_A)`-1] ;
	//print ("HERE IS THE SPOT XXXX" +"\n");	
	//print ("HERE IS THE SPOT XXXXHERE" +"\n");
vector $NewFvec[];
$NewFvec = VecEndsOrthoEqual($Intersect_A, $AB_endPts[1],  $AB_endPts[0], 8.5);	
if(`size($NewFvec)`!=0){
$Intersect_A = $NewFvec;
}
*/

}
		
		$ThefirstCurve = VecArrayToCurve($Intersect_A);
		modifySelectedCurves smooth $Smooth 0;
		//float $arcL3 = (`arclen $ThefirstCurve`)*10.0;
		//SmoothCurvatureB3($arcL3);
		//vector $Intersect_ACD[];
		//$Intersect_ACD = VecCurveEps( $ThefirstCurve);
		vector $Intersect_B[];	
		$Intersect_B= VecPtsToZMirrorPts($Intersect_A);
		$ThefirstCurvei = VecArrayToCurve($Intersect_B);
		modifySelectedCurves smooth $Smooth 0;
		$EndrEndsa  = VecCurveEnds({$ThefirstCurvei});	
		$EndsAtZero= isCurveEndAtZY($EndrEndsa);

		$EndsAtZero= isCurveEndAtZY($EndrEndsa);
		if($EndsAtZero>0){
			sets -include ZEdgeCurvesSet ({$ThefirstCurvei,$ThefirstCurve});
		}

	}
	$EndrEndsa = VecCurveEnds({$ThefirstCurvei});	
	$EndsAtZero = isCurveEndAtZY($EndrEndsa);
	if($EndsAtZero>0){
		sets -include ZEdgeCurvesSet ({$ThefirstCurvei,$ThefirstCurve});
	}

	delete $VanishingPointsLinesTempGuides;
	delete $CurveItemZai $CurveItemZbi;
	clear $VanishingPointsLinesTempGuides;
	clear $StereoCurveZ;
	$addNumbersA =0;
	clear $VanishingPointGlobal;

	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $ThefirstCurve;
smoothCurve -ch 0 -rpo 1 -s 95.60 ($ThefirstCurve +".cv [*]");
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $ThefirstCurvei;
smoothCurve -ch 0 -rpo 1 -s 95.60 ($ThefirstCurvei +".cv [*]");
//string $NewCircDX[];
//string $NewCircD[] = {$ThefirstCurve,$ThefirstCurvei};
//$NewCircDX = SphereDeform($NewCircD);
//$ThefirstCurve = $NewCircDX[0];
//$ThefirstCurvei = $NewCircDX[1];

//$ThefirstCurve = Strait_ARC_or_FreeFormSS($ThefirstCurve, 5.5, 2.5 );
	

//$ThefirstCurvei = Strait_ARC_or_FreeFormSS($ThefirstCurvei, 5.5, 2.5 );

	ResetTranslation({$ThefirstCurve});
	CurveIndexVecTracking({$ThefirstCurve});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ThefirstCurve;

	ResetTranslation({$ThefirstCurvei});
	CurveIndexVecTracking({$ThefirstCurvei});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ThefirstCurvei;
	evalVectorIndexAdditionSubtract;
	EVALCamScripts;

} 
proc vector [] FlattenSnap(vector $Vec_A[], int $XYZvec ,float $Val){
	float $xyz[];
	vector $Vi;
	vector $ViNew[];
	for($i=0;  $i < `size($Vec_A)`; $i++){
		$Vi= $Vec_A[$i];
		$xyz[0] = $Vi.x;
		$xyz[1] = $Vi.y;
		$xyz[2] = $Vi.z;
		$xyz[$XYZvec]= $Val;
		$ViNew[$i] = <<$xyz[0], $xyz[1], $xyz[2]>>;
	}
	return $ViNew;
}
proc vector MultVec(float $Va[],float $Vb[]){
	vector $VecMult;
	float $PtsC[];
	$PtsC[0]= $Va[0] * $Vb[0];
	$PtsC[1]= $Va[1] * $Vb[1];
	$PtsC[2]= $Va[2] * $Vb[2];
	$VecMult = << $PtsC[0],  $PtsC[1],  $PtsC[2] >>;
	return $VecMult;
}
proc AutoCurveScriptsTwoCurve(){
	global string $StereoCurveZ[];
	string $itemAll[] = `ls -sl`;
	int $ifCond_is_True =  `ISSelectedTypeCurve`;
	if ($ifCond_is_True == 1){
		//   This is just the curve script you need this  to be where the switch is
		string $item[] = `ls -sl`;
		$StereoCurveZ[`size($StereoCurveZ)`]= $item[0];
		EvalAddingCurves;
		creatStereoCurve;
	}
} 

proc string[] CreateCAMforIntCurveScript(){
CreateCameraOnly;
rename ZCURVEModelingCAM;
lookThroughModelPanelClipped ZCURVEModelingCAM  modelPanel4 0.001 1000;
nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr  1 -n "LiveSurfaceB";
editDisplayLayerMembers -noRecurse  layerYZYXPlains "LiveSurfaceB";
 string $CamConeLocator[];
clear $CamConeLocator;
curve -d 3 -p 0 0 0 -p 0 0 -4 -p 0 0 -8 -p 0 0 - 12 -k 0 -k 0 -k 0 -k 12 -k 12 -k 12 -n  Deletethiscurve ;
extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
$objectZcurv = `ls -sl`;
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($objectZcurv[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($objectZcurv[0] + ".cv[0]")  ;			
$CurveSelection[1] = ($objectZcurv[0] + ".cv[" +  $numCVrealNum + "]") ;
	string $each;
for ($each in $CurveSelection) {
        float $eachCVpos[]; $eachCVpos =  `pointPosition -w ( $each  )`;
string $MakespaceLocator[]; $MakespaceLocator =  `spaceLocator -p 0 0 0 -n LocatorA`;
ArrayInsertAtEnd($CamConeLocator,  $MakespaceLocator[0]);
move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakespaceLocator[0];
}
string $objectZ[]; clear $objectZ; string  $MakespaceLocator[]; clear $MakespaceLocator ;  
int $LocatorLoop = 0; int $LocatorLoopA = -1;
while ($LocatorLoop++ < 7) {
$LocatorLoopA = $LocatorLoopA +1; 
if ($LocatorLoopA == 0){
clear $objectZ; 
stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
stringArrayInsertAtIndex(1, $objectZ,  "LocatorA1");
}
if ($LocatorLoopA > 0){
clear $objectZ; 
stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
stringArrayInsertAtIndex(1, $objectZ,  $MakespaceLocator[0]);
}
if ($LocatorLoopA < 7){
$MakespaceLocator = `spaceLocator -p 0 0 0 -n  LocatorMiddleDistance`;
ArrayInsertAtEnd($CamConeLocator,  $MakespaceLocator[0]);
averagingNode($objectZ[0], $MakespaceLocator[0],  $objectZ[1]);
}
}
ArrayInsertAtEnd( $CamConeLocator,  $CamConeLocator[0]);
stringArrayRemoveAtIndex(0, $CamConeLocator);
parentConstraint -mo -weight 1 ZCURVEModelingCAM  LocatorA1 ;
parentConstraint -mo -weight 1 ZCURVEModelingCAM  LocatorA;
delete  Deletethiscurve;
align -atl -x Mid -y Mid -z Mid LiveSurfaceB  ZCURVEModelingCAM;
move -r -os -wd 0 5 5 ZCURVEModelingCAM ;
setAttr "ZCURVEModelingCAM.rotateX" -45;
setAttr "LiveSurfaceB.rotateX" (`getAttr  ("ZCURVEModelingCAM" + ".rotateX")`+90);
setAttr "LiveSurfaceB.rotateY" `getAttr  ("ZCURVEModelingCAM" + ".rotateY")`;
setAttr "LiveSurfaceB.rotateZ" `getAttr  ("ZCURVEModelingCAM" + ".rotateZ")`;
align -atl -x Mid -y Mid -z Mid LiveSurfaceB  ZCURVEModelingCAM;
move -r -os -wd 0 -0.7 0 LiveSurfaceB ;
move -r -os -wd 0 0 0.210031 LiveSurfaceB ;
parentConstraint -mo -weight 1 ZCURVEModelingCAM  LiveSurfaceB;
setAttr "ZCURVEModelingCAM.translateX" 48 ;
setAttr "ZCURVEModelingCAM.translateY" 41 ;
setAttr "ZCURVEModelingCAM.translateZ" 48 ;
setAttr "ZCURVEModelingCAM.rotateX" -25 ;
setAttr "ZCURVEModelingCAM.rotateY" 45;
setAttr "ZCURVEModelingCAM.rotateZ" 0;
return $CamConeLocator;
}



