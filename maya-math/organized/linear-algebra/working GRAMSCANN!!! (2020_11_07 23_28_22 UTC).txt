proc float [] AnglesofTriangle(float $SideA, float $SideB, float $SideC){

float $Pi = 3.1415926535;
float $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleNA = $AngleNPi;

float $ArcangleB = acos((((`pow $SideA 2.000`) + (`pow $SideC 2.000`) - (`pow $SideB 2.000`) )/(2.000*$SideA*$SideC)));
float $AngleNPiB =  ($ArcangleB*180)/$Pi;
float $AngleNB = $AngleNPiB;

float $ArcangleC = acos((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
float $AngleNPiC =  ($ArcangleC*180)/$Pi;
float $AngleNC = $AngleNPiC;

// acos is the Arc Cos which is sometime called cos pow-1 which does not mean cos raised to the Neg One power but
// is the opposite angle called acos if you move cos to the other side of the equal sign when solving an equation.
//simple ass hell.. but wont find these answers any place but from me since reality is fucked. Luck has it the internet exists. 
//and knowledge WANTS to grow.
// acos atan asin same thing

float $Angle_a = $AngleNA; 
float $Angle_b = $AngleNB; 
float $Angle_c = $AngleNC;
float $Add = $Angle_a + $Angle_b + $Angle_c;
float $Angle_ABC[] = {$Angle_a, $Angle_b, $Angle_c} ;
return $Angle_ABC;
}

///////////////////////////

proc float [] MultLenToDirAddToPoint(float $Length, float $Dir[], float $Pos[]){
float $MultLengthDir[] = multiplyFloat($Length, $Dir);
float $AddMultDirPos[] = AddFloats($Pos, $MultLengthDir);
return $AddMultDirPos;
}

proc float [] RotMultLenToDirAddToPoint(float $PosA[], float $PosB[], int $PosOrNegOne, float $Length, float $DirNormAx[], float $Radian){
vector $DirecOfPointAB = FloatToVec ( DirectionF($PosA, $PosB));
$DirecOfPointAB = FloatToVec ( multiplyFloat($PosOrNegOne, $DirecOfPointAB));
vector $DirNorm = FloatToVec ($DirNormAx);
float $rotatsA[] = `rot $DirecOfPointAB $DirNorm $Radian`;
float $MultLengthDir[] = multiplyFloat($Length, $rotatsA);
float $AddMultDirPos[] = AddFloats($PosA, $MultLengthDir);
return $AddMultDirPos;
}

/////////////////////////////////////////////////////////////

proc float [] RotDirToPoint(float $PosA[], float $PosB[], int $PosOrNegOne, float $DirNormAx[], float $Radian){
vector $DirecOfPointAB = FloatToVec ( DirectionF($PosA, $PosB));
float $Length = distance2Pts ($PosA, $PosB);
$DirecOfPointAB = FloatToVec ( multiplyFloat($PosOrNegOne, $DirecOfPointAB));
vector $DirNorm = FloatToVec ($DirNormAx);
float $rotatsA[] = `rot $DirecOfPointAB $DirNorm $Radian`;
float $MultLengthDir[] = multiplyFloat($Length, $rotatsA);
float $AddMultDirPos[] = AddFloats($PosA, $MultLengthDir);
return $AddMultDirPos;
}
////////////////


proc float [] ArcLengthArray(string $Objs[]){
float $ArcLengths[];
for($each in $Objs){
$ArcLengths[`size($ArcLengths)`]= `arclen $each`;
}
return $ArcLengths;
}

proc vector TwoVecsOrFloats(float $p1p2[], float $p1p3[]){
vector $Ui = FloatToVec($p1p2);
vector $Vi = FloatToVec($p1p3);
vector $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;
return $VEcLine;
}


proc RotateItX(float $Rotation[]){
rotate -r -ws $Rotation[0] $Rotation[1] $Rotation[2];
}


proc float [] EulerAng(float $pointB1[], float $pointB2[]){
float $EulerAngleA[] = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
return $EulerAngleA;
}

proc string [] GetNearestINDEX(int $Nn, string $index[],float $pointA1[], vector $objectListV[]){
float $distanceA[];
for ($eachVecs in $objectListV){
$distanceA[`size($distanceA)`] = distance2Pts( $pointA1 , $eachVecs);
}
string $EmptyStringX[];
clear $EmptyStringX;
float $NewfloatsX[];
$NewfloatsX = SortFloatArrayAndString($distanceA, $index, $EmptyStringX);
$EmptyStringX = ReverseStringArray($EmptyStringX);
float $NewfloatsXi[] = ReverseFloatArray($NewfloatsX);
string $returnZi[];
int $iX= 0;
while ($Nn > $iX){
$returnZi[`size($returnZi)`] = $EmptyStringX[$iX];
$iX++; 
}
return $returnZi;
}


proc string [] GetNearest(int $Nn, string $OneObject, string $diff[]){
string $objectList[] = $diff;
float $pointA1[];
$pointA1 = `xform -query -worldSpace - translation ($OneObject)`;
float $distanceA[];
clear  $distanceA;
int $Indx=0;
float $pointA2[];
for ($eachZx in $objectList){
if (catch($pointA2 = `xform -q -ws -t $objectList[$Indx]`)){
$pointA2 = `pointPosition -w $objectList[$Indx]`;
} 

$Indx++;
$dAx = $pointA1[0] - $pointA2[0];
$dAy = $pointA1[1] - $pointA2[1];
$dAz = $pointA1[2] - $pointA2[2];
$distanceA[`size($distanceA)`] = `sqrt( ($dAx * $dAx) + ($dAy * $dAy)  + ($dAz * $dAz) )`;
}


string $EmptyStringX[];
clear $EmptyStringX;
float $NewfloatsX[];
$NewfloatsX = SortFloatArrayAndString($distanceA, $objectList, $EmptyStringX);
$EmptyStringX = ReverseStringArray($EmptyStringX);
float $NewfloatsXi[] = ReverseFloatArray($NewfloatsX);

string $returnZi[];
int $iX= 0;
while ($Nn > $iX){
$returnZi[`size($returnZi)`] = $EmptyStringX[$iX];
$iX++; 
}

return $returnZi;
}


string $ObjectList[]= `ls -sl`;
vector $Vecs[]= PointArrayT($ObjectList);

/*
//select Curves distance.. which you have
string $ObjectListZ[]= `ls -sl`;
float $rotationSz[]= ArcLengthArray($ObjectListZ);
AnglesofTriangle($rotationSz[0] , $rotationSz[1] ,$rotationSz[2]);
*/

float $DistA = distance2Pts ($Vecs[0], $Vecs[1]);
float $DistB = distance2Pts ($Vecs[1], $Vecs[2]);
float $DistC = distance2Pts ($Vecs[2], $Vecs[0]);
float $angelsZ[] = AnglesofTriangle($DistA , $DistB ,$DistC);



// Get the vector p1-p2, p3-p4
	// Get the vector  p3-p4
//THREE POINTS get angel that is point 2 & 3 to point 1 (the V shape joining at first po $U3 = TwoVecsOrFloats($point2, $point3);


vector $V3 = TwoVecsOrFloats($point1, $point3);

Loc $U1; Loc $U2; Loc $U3;
Loc $V1; Loc $V2; Loc $V3;

float $Rotation1[] = EulerAng($U1, $V1);
float $Rotation2[] = EulerAng($U2, $V2);
float $Rotation3[] = EulerAng($U3, $V3);

float $Rot1 = `abs $Rotation1[1]`;
float $Rot2 = `abs $Rotation2[1]`;
float $Rot3 = `abs $Rotation3[1]`;

float $Rot1 =  $Rotation1[1] ;
float $Rot2 =  $Rotation2[1] ;
float $Rot3 =  $Rotation3[1] ;

print ($Rot1+" "+ $Rot2+" "+ $Rot3);


float $Rot1R = `deg_to_rad $Rot1`;
float $Rot2R = `deg_to_rad $Rot2`;
float $Rot3R = `deg_to_rad $Rot3`;


float $AddRots = $Rot1 + $Rot2 + $Rot3;
// Result: 180 // Perfict
	vector $normalV[];
	$normalV = crossProduct( $U1, $V1, 0, 0 );
float $normal[] = `unit ($normalV[0])`;



float $rotats1[] = RotDirToPoint($point1, $point2, 1, $normal, $Rot1R);
Loc $rotats1;
float $rotats2[] = RotDirToPoint($point3, $point2, 1, $normal, $Rot3R);
Loc $rotats2;
float $rotats3[] = RotDirToPoint($point2, $point1, 1, $normal, $Rot2R);
Loc $rotats3;



proc ShakeHands(){
string $itemA[] = `ls -sl`;
string $itemBackUp[] = $itemA;
int $Xvi =0;
for($each in $itemBackUp){
  string $itemsToRemove[] = { $itemA[0] };
  string $diff[] = stringArrayRemoveExact($itemsToRemove, $itemA);
for($eachOther in $diff){
select -r $eachOther $itemsToRemove;
playButtonStepForward;
CreateCurveFromTwoSelected;
playButtonStepForward;
}
$itemA = $diff;

}
}

proc float [] EulerAngB(float $pointB1[], float $pointB2[]){
float $EulerAngleA[] = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
return $EulerAngleA;
}


/*




string $ObjectList[]= `ls -sl`;
vector $Vecs[]= PointArrayT($ObjectList);
print $ObjectList;
string $ThreePoints[] = { "0", "1", "2"};

// Get the vector p1-p2, p3-p4
	// Get the vector  p3-p4
//THREE POINTS get angel that is point 2 & 3 to point 1 (the V shape joining at first point)

///////////////////////////////////////////////////////////
float $point1[] =  FloatToVec($Vecs[0]);
float $point2[] =  FloatToVec($Vecs[1]);
float $point3[] =  FloatToVec($Vecs[2]);

vector $U1 = TwoVecsOrFloats($point2, $point1);
vector $V1 = TwoVecsOrFloats($point3, $point1);
vector $U2 = TwoVecsOrFloats($point3, $point1);
vector $V2 = TwoVecsOrFloats($point2, $point1);

//vector $U2 = TwoVecsOrFloats($point3, $point2);
//vector $V2 = TwoVecsOrFloats($point1, $point2);

vector $U3 = TwoVecsOrFloats($point1, $point3);
vector $V3 = TwoVecsOrFloats($point2, $point3);


	vector $normalV[];
clear $normalV;
	$normalV[0] = FloatToVec( crossProduct( $U1, $V1, 0, 1 ) );
$normalV[1] = FloatToVec( crossProduct( $U2, $V2, 0, 1 ) );
print $normalV;

//float $normal[] = `unit ($normalV[0])`;

float $normalA[] = `unit ($normalV[0])`;
float $normalB[] = `unit ($normalV[1])`;

float $normalAAdd = $normalA[0] + $normalA[1];
float $normalAAdd2 = $normalB[0] + $normalB[1];


if( $normalAAdd< $normalAAdd2){
select -r $ObjectList[2];
}else{ select -r $ObjectList[1];}



proc string [] MostRightClockWise (string $ObjectList[], vector $Vecs[], int $Two[]){

string $ThreePoints[] = { "0", "1", "2"};

// Get the vector p1-p2, p3-p4
	// Get the vector  p3-p4
//THREE POINTS get angel that is point 2 & 3 to point 1 (the V shape joining at first point)

///////////////////////////////////////////////////////////
float $point1[] =  FloatToVec($Vecs[0]);
float $point2[] =  FloatToVec($Vecs[1]);
float $point3[] =  FloatToVec($Vecs[2]);

vector $U1 = TwoVecsOrFloats($point2, $point1);
vector $V1 = TwoVecsOrFloats($point3, $point1);
vector $U2 = TwoVecsOrFloats($point3, $point1);
vector $V2 = TwoVecsOrFloats($point2, $point1);

//vector $U2 = TwoVecsOrFloats($point3, $point2);
//vector $V2 = TwoVecsOrFloats($point1, $point2);

vector $U3 = TwoVecsOrFloats($point1, $point3);
vector $V3 = TwoVecsOrFloats($point2, $point3);


	vector $normalV[];
clear $normalV;
	$normalV[0] = FloatToVec( crossProduct( $U1, $V1, 0, 1 ) );
$normalV[1] = FloatToVec( crossProduct( $U2, $V2, 0, 1 ) );

//float $normal[] = `unit ($normalV[0])`;

float $normalA[] = `unit ($normalV[0])`;
float $normalB[] = `unit ($normalV[1])`;

float $normalAAdd = $normalA[0] + $normalA[1];
float $normalAAdd2 = $normalB[0] + $normalB[1];
int $TwoNew[];
string $ReturnObj[];
if( $normalAAdd< $normalAAdd2){
//select -r $ObjectList[2];
$TwoNew ={$Two[1], $Two[0]};
$ReturnObj ={ $ObjectList[1], $ObjectList[0]};

}else{ 
//select -r $ObjectList[1];
$TwoNew ={$Two[0], $Two[1]};
$ReturnObj ={ $ObjectList[0], $ObjectList[1]};
}

$Two = $TwoNew;

return $ReturnObj;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////
//////////////////////////////////
//////////////////////////////////
//////////////////////////////////
//////////////////////////////////







	string $oneItemz[] = `ls -sl -fl`;
vector $FixVec[];
clear $FixVec;
vector $FixVec[] = PointArrayT($oneItemz);
int $IndeXxTrax1[] = CreateIntIndex(`size( $FixVec)`);
string $stringIndexTrack1[]= IntArrayToStringArray($IndeXxTrax1);

float $Xx, $Yy, $Zz;
float $XY[];
clear  $XY;
int $iVc=0;
for ($each in $FixVec){
//Loc $FixVec[$iVc];
vector $One = $FixVec[$iVc];
$XY[$iVc] = $One.x + $One.y +$One.z;
$Xx += $One.x;
$Yy += $One.y;
$Zz += $One.z;
$iVc++;
}

float $Floatlist[] = $XY;
string $EmptyStringNewOrderxyZA[];
clear $EmptyStringNewOrderxyZA;
float $NewfloatsZ[];
$NewfloatsZ = SortFloatArrayAndString($Floatlist, $stringIndexTrack1, $EmptyStringNewOrderxyZA);

//This does above^

string $newOrderStringA[] = NewArrayOrderWithIndexKey($EmptyStringNewOrderxyZA, $oneItemz);
vector $FixVec2[] =  NewVecOrderWithIndexKey($EmptyStringNewOrderxyZA, $FixVec);

int $IndeXEvalWorking[] = CreateIntIndex(`size( $newOrderStringA)`);
string $WorkingStringA[] = $newOrderStringA;
vector $WorkingVecA[] = $FixVec2;

string $WorkingString[] = $WorkingStringA;
vector $WorkingVec[] = $WorkingVecA;
int $TempWorkingIndeX[] = $IndeXEvalWorking;

string $ALLEdges[];
clear $ALLEdges;
int $oneCurrent = $IndeXEvalWorking[0];
int $BreakTrigger = $IndeXEvalWorking[0];
int $BreakTriggerB = -2;
///////////////
///start of Loop..
int $Loops = 0;


 

int $InDexRem[0];
$InDexRem[0] = $oneCurrent ;

int $TempIndex[];
string $stringIndexTrack[];
vector $OneVec;
vector $newVecs[];
//GET NEAREST two
 string $indexTrackV[];
int $NearOneT[];
int $TempIndexB2[];
string $TwoItems[];
vector $ThreeVecsB[];
int $NearIntXiB[];
string $MostRightOfFirstA[];



for ($eachItem in $TempWorkingIndeX){
if( $Loops == 30){$BreakTrigger =$oneCurrent; break;}


	$ALLEdges[`size($ALLEdges)`] = $WorkingStringA[$oneCurrent];

		$InDexRem[0] = $oneCurrent ;
		$TempIndex = RemoveINTAtIndex($IndeXEvalWorking,$InDexRem);
	$stringIndexTrack = IntArrayToStringArray($TempIndex);
	$OneVec= $WorkingVec[$InDexRem[0]];
$newVecs = RemoveVecAtOneIndex($WorkingVec, $IndeXEvalWorking[0]);
//GET NEAREST two
	 $indexTrackV = GetNearestINDEX(1, $stringIndexTrack, $OneVec, $newVecs);
	 $NearOneT[0] = $indexTrackV[0];
$TempIndexB2= RemoveINTAtIndex($TempIndex,$NearOneT);
	PAUSE;
	select -r $WorkingStringA[$oneCurrent] $WorkingStringA[$NearOneT[0]] $WorkingStringA[$TempIndexB2[0]];
int $sizeA = `size($TempIndexB2)`;

for ($eachINT in $TempIndexB2){


$ThreeVecsB = {$OneVec,  $WorkingVecA[$NearOneT[0]], $WorkingVecA[$eachINT]};
$NearIntXiB = {$NearOneT[0] ,$eachINT};

$TwoItems = {$WorkingString[$NearIntXiB[0]], $WorkingString[$NearIntXiB[1]]};
$MostRightOfFirstA = MostRightClockWise ($TwoItems, $ThreeVecsB, $NearIntXiB);

PAUSE;
select -r $WorkingString[$NearIntXiB[0]];
PAUSE;
$NearOneT[0] = $NearIntXiB[0];

}

//////////////////
//I DID IT HELL YEAH

PAUSE;
select -r $WorkingStringA[$oneCurrent] $WorkingStringA[$NearOneT[0]];
$oneCurrent = $NearOneT[0];
PAUSE;


if($Loops>2){
 $BreakTriggerB = $oneCurrent;
if($BreakTrigger== $BreakTriggerB){ select -r $ALLEdges; PAUSE; polySphere -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 -ch 1 ;
 select -r $ALLEdges;  break;
}
}
$Loops++;

if( $Loops == 30){$BreakTrigger = $oneCurrent; break;}


}




clear  $TempIndex;
clear  $stringIndexTrack;
clear  $newVecs;
//GET NEAREST two
clear $indexTrackV;
clear  $NearOneT;
clear  $TempIndexB2;
clear $TwoItems;
clear $ThreeVecsB;
clear  $NearIntXiB;
clear $MostRightOfFirstA;


/////////////////////////////////////////////////////////////////


$TempIndexB2  = RemoveINTAtIndex($TempIndex,$NearOneT);




//////////////////////////////////////////////////////
//string $TwoNeari1[] =  IncludeStringAtIndex($WorkingStringA,$NearIntXiB);
//string $TwoNeari2[] =  IncludeStringAtIndex($WorkingString,$NearIntXiB);

string $TwoNearB[] =  { $WorkingString[$NearIntXi[0]], $WorkingString[$eachVecBi]};







proc string [] GetNearestINDEX(int $Nn, string $index[],float $pointA1[], vector $objectListV[]){
float $distanceA[];
for ($eachVecs in $objectListV){
$distanceA[`size($distanceA)`] = distance2Pts( $pointA1 , $eachVecs);
}
string $EmptyStringX[];
clear $EmptyStringX;
float $NewfloatsX[];
$NewfloatsX = SortFloatArrayAndString($distanceA, $index, $EmptyStringX);
$EmptyStringX = ReverseStringArray($EmptyStringX);
float $NewfloatsXi[] = ReverseFloatArray($NewfloatsX);
string $returnZi[];
int $iX= 0;
while ($Nn > $iX){
$returnZi[`size($returnZi)`] = $EmptyStringX[$iX];
$iX++; 
}
return $returnZi;
}




vector $OneVec= $WorkingVec[$IndeXEvalWorking[0]];
vector $newVecs[] = RemoveVecAtOneIndex($WorkingVec, $IndeXEvalWorking[0]);

int $InDexRem[0];
$InDexRem[0] = $IndeXEvalWorking[0] ;
int $TempIndex[] = RemoveINTAtIndex($IndeXEvalWorking,$InDexRem);


string $stringIndexTrack[]= IntArrayToStringArray($TempIndex);

//GET NEAREST two
 string $indexTrackV[] = GetNearestINDEX(2, $stringIndexTrack,$OneVec, $newVecs);



int $NearInt[] = StringToInt( $indexTrackV);
string $TwoNear[] =  IncludeStringAtIndex($WorkingString, $NearInt);
select -r  $TwoNear $OneItem ;

vector $ThreeVecs[] = {$OneVec,  $newVecs[$NearInt[0]], $newVecs[$NearInt[1]]};
int $NearIntXi[] = $NearInt;

string $MostRightOfFirst[] = MostRightClockWise ($TwoNear, $ThreeVecs, $NearIntXi);

print $NearIntXi;
select -r  $OneItem $WorkingString[$NearIntXi[0]] ;


string $WorkingStringSTageTwoA[] = RemoveStringAtIndex($WorkingStringSTageTwo,$NearIntXi);
select -r $WorkingStringSTageTwo;
select -r $WorkingStringSTageTwoA;
int $TempIndex2[] = RemoveINTAtIndex($TempIndex,$NearIntXi);


vector $FixVec2[] = PointArrayT($EmptyStringNewOrderxyZA);

print $TempIndex2;
string $AllMostRIGHT[];
clear $AllMostRIGHT;
int $TempIndex3[];
clear $TempIndex3;

for ($eachVecBi in $TempIndex2){

//int $iXt =0;

//int $eachVecBi = $TempIndex2[$iXt];
//$iXt++;
//select -r  $WorkingStringA[$eachVecBi];
//select -r  $OneItem $WorkingString[$NearIntXi[0]] ;

//All But One the First
//select -r $WorkingString;

//All 
//select -r $WorkingStringA;

//select -r  $OneItem $WorkingString[$NearIntXi[0]] $WorkingString[$eachVecBi] ;

vector $ThreeVecsB[] = {$OneVec,  $newVecs[$NearIntXi[0]], $newVecs[$eachVecBi]};
int $NearIntXiB[] = {$NearIntXi[0] , $eachVecBi};

//string $TwoNeari1[] =  IncludeStringAtIndex($WorkingStringA,$NearIntXiB);
//string $TwoNeari2[] =  IncludeStringAtIndex($WorkingString,$NearIntXiB);

string $TwoNearB[] =  { $WorkingString[$NearIntXi[0]], $WorkingString[$eachVecBi]};
select -r $TwoNearB;
PAUSE;
string $MostRightOfFirstA[] = MostRightClockWise ($TwoNearB, $ThreeVecsB, $NearIntXiB);
$AllMostRIGHT[`size($AllMostRIGHT)`] = $MostRightOfFirstA[0];
$TempIndex3[`size($TempIndex3)`] = $NearIntXiB[0];

select -r $WorkingStringA[$oneCurrent];
PAUSE; PAUSE; PAUSE; PAUSE;
select -r $WorkingString[$NearIntXiB[1]] ;
PAUSE; PAUSE; PAUSE; PAUSE;
select -r $WorkingString[$NearIntXiB[0]];
PAUSE; PAUSE; PAUSE; PAUSE;


PAUSE;
select -r $AllMostRIGHT;
PAUSE; PAUSE;

}


print $TempIndex3;


select -r $WorkingStringA[$oneCurrent] $WorkingString[$NearIntXi[0]]; 
select -r $AllMostRIGHT;

string $TestTrack[]= IntArrayToStringArray($TempIndex3);
string $shorterList[] = stringArrayRemoveDuplicates($TestTrack);
int $newIndexTest[] = StringToInt( $shorterList);
string $AllMostRIGHTB[];
clear $AllMostRIGHTB;
for ($eachVecCi in $newIndexTest){
$AllMostRIGHTB[`size($AllMostRIGHTB)`] = $WorkingString[$eachVecCi];
}

select -r  $WorkingStringA;

select -r  $AllMostRIGHTB;
string $AllMostRIGHTC[];
clear $AllMostRIGHTC;
for ($eachVecBi in $TempIndex2){
$AllMostRIGHTC[`size($AllMostRIGHTC)`] = $WorkingStringA[$eachVecBi];

}

select -r  $AllMostRIGHTC;

print $NearIntXi[0] ;
print $TempIndex;
print $NearIntXi;
print $TempIndex2;
string $Others[] =  IncludeStringAtIndex($WorkingStringSTageTwoA,$TempIndex2);
print $Others;
select -r  $Others;

print $WorkingString
print $WorkingStringA;
select -r $WorkingString[0] $WorkingString[1];
select -r $WorkingStringA[0] $WorkingStringA[1];




//int $IndeXxTrax[] = CreateIntIndex(`size( $FixVec2)`);
//string $stringIndexTrack[]= IntArrayToStringArray($IndeXxTrax);
//vector [] RemoveVecAtIndex($FixVec1, int $IndeXxz[])







	for ($eachVecBi in $FixVec){
$firstReduction[`size($firstReduction)`]=  $eachVecB ;
stringArrayInsertAtIndex(`size($NewObjList)`, $NewObjList, $diffCZ[$iXn]); 
$iXn++;
	}


// NewArrayOrderWithIndexKey

vector $FixVec2[] = PointArrayT($EmptyStringNewOrderxyZA);

int $IndeXxTrax[] = CreateIntIndex(`size( $FixVec2)`);
string $stringIndexTrack[]= IntArrayToStringArray($IndeXxTrax);

// vector [] RemoveVecAtIndex(vector $VecS[],int $IndeXxz[])

string $OneObject = $EmptyStringNewOrderxyZA[$IndeXxTrax[0]];
  string $diff[] = stringArrayRemoveExact({$OneObject}, $EmptyStringNewOrderxyZA);
int $Nn =2;



// string $threeNTrack[] = GetNearest(2, string $OneObject, string $diff[]);


 string $indexTrackV[] =  GetNearestINDEX($Nn, $stringIndexTrack ,float $pointA1[], vector $objectListV[])


//  distance2Pts


for (eachVecOther in $FixVec2){

if (!(eachVecOther== $FixVec2){











select -r $EmptyStringX[0] $EmptyStringX[1] $EmptyStringX[2];


select -r $EmptyStringNewOrderxyZA[0];
select -r $objectList[2] $objectList[3];

int $IndexLoc=0;
int $IndexLocb=1;
for ($eachXa in $objectList){
select -add $objectList[$IndexLoc] $objectList[$IndexLocb];
// curve2points($FixVec2[$IndexLoc], $FixVec2[$IndexLocb]);

$IndexLoc++;
$IndexLocb++;
playButtonStepForward;
}

print $objectList[$IndexLoc-1];
int $IndexLoc=0;
int $IndexLocb=1;
for ($each in $EmptyStringNewOrderxyZA){
select -r $EmptyStringNewOrderxyZA[$IndexLoc] $EmptyStringNewOrderxyZA[$IndexLocb];
//curve2points($FixVec2[$IndexLoc], $FixVec2[$IndexLocb]);
$IndexLoc++;
$IndexLocb++;
playButtonStepForward;
}


print $Xx;
print $Yy;
float $XxYyZz[]={ `abs $Xx`, `abs $Yy`, `abs $Zz`};

string $DirIndex[] = { "x", "y", "z"};
string $EmptyStringNewOrderxyZA[];
float $NewfloatsZ[];
$NewfloatsZ = SortFloatArrayAndString($XxYyZz, $DirIndex, $EmptyStringNewOrderxyZA);
print $EmptyStringNewOrderxyZA[2];
string $w = $EmptyStringNewOrderxyZA[2];





float $NUmb[];
clear $NUmb;
vector $OneV;

if($w== "x"){
int $iVc=0;
for ($each in $FixVec){
vector $One = $FixVec[$iVc];
$iVc++;
$NUmb[`size($NUmb)`]= $One.x;
}
}
print $NUmb;
if($w== "y"){
int $iVc=0;
for ($each in $FixVec){
vector $One = $FixVec[$iVc];
$iVc++;$NUmb[`size($NUmb)`]= $One.y;
}
}

if($w== "z"){
int $iVc=0;
for ($each in $FixVec){
vector $One = $FixVec[$iVc];
$iVc++;
$NUmb[`size($NUmb)`]= $One.z;
}
}




print $NUmb;
float $newNumb[];
for ($each in $NUmb){

 $newNumb[`size($newNumb)`] = abs ($each+0) ;
}

clear $NUmb;

$NUmb = {1.2, -2.4, -5.6, 4, -234 , 3,5,6,2 ,7,10,2,9,7, -23  }

string $ArrayZ[] = `FloatArrayToStringArray $NUmb`;
float $Test[] =  StringArrayToFloatArray ($ArrayZ) ;
sort $Test
print $Test

sort $XY;

float $Floatlist[] = $XY;
string $EmptyStringNewOrderxyZA[];
float $NewfloatsZ[];
$NewfloatsZ = SortFloatArrayAndString($Floatlist, $DirIndex, $EmptyStringNewOrderxyZA);
print $NewfloatsZ;


string $EmptStrNewOrderxyZ[];
clear $EmptStrNewOrderxyZ;
float $NewXyZ[];
clear $NewXyZ;
$NewXyZ = SortFloatArrayAndString($XY, $oneItemz, $EmptStrNewOrderxyZ);
print $NewXyZ;
print $oneItemz;
print  $EmptStrNewOrderxyZ;

string $EmptStrNewOrderxyZi[];
float $NewXyZi[];
$NewXyZi = SortFloatArrayAndString($NewXyZ, $EmptStrNewOrderxyZ, $EmptStrNewOrderxyZi);
print $NewXyZi;
print $oneItemz;


print $EmptStrNewOrderxyZ
for ($each in $EmptStrNewOrderxyZ){
select -r $each ;
PAUSE;
}


int $OneIndexA = $EmptyStringNewOrderxyZA[2];
int $OneIndexB = $EmptyStringNewOrderxyZA[1];
int $OneIndexC = $EmptyStringNewOrderxyZA[0];

float $p1[]= $FixVec[$OneIndexA];
float $p2[]= $FixVec[$OneIndexB];
float $p3[]= $FixVec[$OneIndexC];


float $p1p2[3];
	float $p1p3[3];

	$p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
	$p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
  

	// Get the normal to the plane formed by p1, p2, p3, which is the
	// cross prod of p1-p2 and p1-p3
	
	float $normal[3];
	$normal = crossProduct( $p1p2, $p1p3, 0, 0 );

// int Cross_product(Point p1, Point p2, Point p3) {
//		 return (p2.x - p1.x)*(p3.y - p1.y) - (p3.x - p1.x)*(p2.y - p1.y);	
//	 }

////////////////////////[[[[[[[
float $FloatPos1[] = `AverageVectorPoint($veCPos1)`;


string $DirIndex[] = { "0", "1", "2", "3", "4", "5"};
string $EmptyStringNewOrderxyZA[];
float $NewfloatsZ[];
$NewfloatsZ = SortFloatArrayAndString($DistDirsZz, $DirIndex, $EmptyStringNewOrderxyZA);












*/


proc CreateVectorInfoAtSelected(){

string $oneItemz[] = `ls -sl -fl`;
for ($each in $oneItemz){
xform -cp $each;
	vector $worldPos = `xform -q -ws -t  $each`;
string $type = getTypeItemString({$each});
if(!($type == "controlPoint")){
			move -rpr 0 0 0 $each;
			makeIdentity -apply true  -t 1 -r 0 -s 0 $each;
			xform -t ($worldPos.x)  ($worldPos.y) ($worldPos.z) $each;
}

float $worldPosF[] = `xform -q -ws -t $each`;
string $resultZa =("<< " +  $worldPos+" >>");
string $textN[] = `textCurves -ch 0 -f "Times New Roman|h-2|w400|c0" -t $resultZa`;
toggle -cv -state 0-ep -hull -normal -sf -origin;
move -ws $worldPosF[0] $worldPosF[1] $worldPosF[2] $textN;
string $UserCaM = `modelEditor -q -camera modelPanel4`; 
aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $UserCaM $textN;
}


}


proc string Circles_Direction(float $Point[], float $FloatDir[], float $FloatNum){
string $circleItem[] = `circle -c $Point[0] $Point[1] $Point[2] 
-nr $FloatDir[0] $FloatDir[1] $FloatDir[2] 
-sw 360 
-r $FloatNum 
-d 3 -ut 0 -tol 0.001 -s 8 -ch 1`;

//setRotationAxisFloat(string $objectitem1[], float $rotationsA[])
return $circleItem[0];
}

proc ResetTransEachSL(){
string $oneItemz[] = `ls -sl`;
for ($each in $oneItemz){
xform -cp $each;
	vector $worldPos = `xform -q -ws -rp $each`;
			move -rpr 0 0 0 $each;
			makeIdentity -apply true -t 1 -r 0 -s 0 $each;
			xform -t ($worldPos.x) ($worldPos.y) ($worldPos.z) $each;
}
}


proc float [] ArcLengthArray(string $Objs[]){
float $ArcLengths[];
for($each in $Objs){
$ArcLengths[`size($ArcLengths)`]= `arclen $each`;
}
return $ArcLengths;
}

//CircleFromCurveZYX 0 0 1;

	proc CircleFromCurveT(){
string $StraitCurve[] = `ls -sl`;
ResetTransEachSL;
float $ArcLengthOne = `arclen $StraitCurve[0]`;
$ArcLengthOne = $ArcLengthOne/2;
float $CurvPos[] = `xform -q -ws -rp $StraitCurve[0]`;
float $tangent[] = `pointOnCurve -t -pr 0.5 $StraitCurve[0]`;
$tangent = `unit <<$tangent[0], $tangent[1], $tangent[2]>>`;
string $circles = Circles_Direction($CurvPos, $tangent, $ArcLengthOne);
ResetTransEachSL;
}

proc float [] lineIntersectionF(float $PosA[], float $PosB[], float $PosC[], float $PosD[]){ 
float $DirAB[] = DirectionF ($PosA, $PosB);
float $DirCD[] = DirectionF ($PosC, $PosD);
 float $locsA[] = lineIntersection($PosA, $DirAB, $PosC, $DirCD);
return $locsA;
}

	proc CircleFromCurveN(int $X, int $Y, int $Z ){
string $StraitCurve[] = `ls -sl`;
ResetTransEachSL;
float $ArcLengthOne = `arclen $StraitCurve[0]`;
$ArcLengthOne = $ArcLengthOne/2;
float $CurvPos[] = `xform -q -ws -rp $StraitCurve[0]`;
float $t[3], $n[3];
  vector $tan, $norm, $bi;

   //$t $n are just directions....
    $t = `pointOnCurve -ch off -pr 0.5 -nt $StraitCurve[0]`;
    $n = `pointOnCurve -ch off -pr 0.5 -nn $StraitCurve[0]`;
    // Maya promises normalized tangent and normal,
    // but they really aren't.    
    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
//## Note the int One 1 inthe middle...
    $norm = `unit << $n[0], $n[0], $n[0] >>`;    
    // Calculate the binormal.   
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
                 << ($norm.x), ($norm.y), ($norm.z) >>`;
    $bi = `unit $bi`;
string $circles = Circles_Direction($CurvPos,$bi, $ArcLengthOne);
ResetTransEachSL;
}

// CircleFromCurveZYX 1 0 0;

	proc CircleFromCurveZYX(int $X, int $Y, int $Z ){
string $StraitCurve[] = `ls -sl`;
ResetTransEachSL;
float $ArcLengthOne = `arclen $StraitCurve[0]`;
$ArcLengthOne = $ArcLengthOne/2;
float $CurvPos[] = `xform -q -ws -rp $StraitCurve[0]`;
float $t[3], $n[3];
  vector $tan, $norm, $bi;
   //$t $n are just directions....
    $t = `pointOnCurve -ch off -pr 0.5 -nt $StraitCurve[0]`;
    $n = `pointOnCurve -ch off -pr 0.5 -nn $StraitCurve[0]`;
    // Maya promises normalized tangent and normal,
    // but they really aren't.    
    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
//## Note the int One 1 inthe middle...
    $norm = `unit << $X, $Y, $Z >>`;    
    // Calculate the binormal.   
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
                 << ($norm.x), ($norm.y), ($norm.z) >>`;
    $bi = `unit $bi`;
string $circles = Circles_Direction($CurvPos,$bi, $ArcLengthOne);
ResetTransEachSL;
}

proc float CirclesRadius(string $selectedObjects[]){
string $CurveSelectionA[] = `ls -fl ($selectedObjects[0]+".ep[0]")`; 
 float $FloatPointA[] = `pointPosition -w  $CurveSelectionA[0]`;
 float $worldPosA[];
       $worldPosA = `xform -q -ws -a -rp $selectedObjects[0]`;
 float $CircleRadiusA = getDistance($FloatPointA, $worldPosA);
return $CircleRadiusA;
}


proc float [] CirclesRadiusDirection(vector $directionAB[], vector $PosAB[]){

string $selectedObjects[];
clear $selectedObjects;
$selectedObjects = `ls -sl`;
string $CurveSelectionA[] = `ls -fl ($selectedObjects[0]+".ep[0]")`; 
string $CurveSelection_a2[] = `ls -fl ($selectedObjects[0]+".ep[3]")`; 

string $CurveSelectionB[] = `ls -fl ($selectedObjects[1]+".ep[0]")`; 
string $CurveSelection_b2[] = `ls -fl ($selectedObjects[1]+".ep[3]")`; 

 float $FloatPointa2[] = `pointPosition -w  $CurveSelection_a2[0]`; 

 float $FloatPointb2[] = `pointPosition -w  $CurveSelection_b2[0]`;	
 float $FloatPointA[] = `pointPosition -w  $CurveSelectionA[0]`;
 float $FloatPointB[] = `pointPosition -w  $CurveSelectionB[0]`;

 float $worldPosA[];
       $worldPosA = `xform -q -ws -a -rp $selectedObjects[0]`;
 float $CircleRadiusA = getDistance($FloatPointA, $worldPosA);
 float $worldPosB[];
	$worldPosB= `xform -q -ws -a -rp $selectedObjects[1]`;

$directionAB[0] = FloatToVec (DirectionF($worldPosA,$worldPosB));
$directionAB[1] = FloatToVec (DirectionF($worldPosB,$worldPosA));
$PosAB[0] = FloatToVec ($worldPosA);
$PosAB[1] = FloatToVec ($worldPosB);
 float $CirclesDistance  = getDistance ($worldPosA, $worldPosB);

float $FloatDirNormalCurveA[] = Normal3Points($worldPosA,$FloatPointa2,$FloatPointA);
$directionAB[2] = FloatToVec ($FloatDirNormalCurveA);

 float $CircleRadiusB = getDistance ($FloatPointB, $worldPosB);
 float $RadiusAB[] = {$CircleRadiusA, $CircleRadiusB,$CirclesDistance};
return $RadiusAB;
}

proc string Circles_Direction(float $Point[], float $FloatDir[], float $FloatNum){
string $circleItem[] = `circle -c $Point[0] $Point[1] $Point[2] 
-nr $FloatDir[0] $FloatDir[1] $FloatDir[2] 
-sw 360 
-r $FloatNum 
-d 3 -ut 0 -tol 0.001 -s 8 -ch 1`;

//setRotationAxisFloat(string $objectitem1[], float $rotationsA[])
return $circleItem[0];
}

proc MoveObject2(float $addfloatVector1[]){
string $VectorUnitLoc[] = `ls -sl`;
move -r $addfloatVector1[0] $addfloatVector1[1] $addfloatVector1[2] $VectorUnitLoc[0];
}

/*

proc vector [] PointToCircleTangents(float $CircleRadiusA, float $worldPosA[], float $worldPosB[], float $FloatDirNormal[]){

vector $directionABs[];
float $R1 = $CircleRadiusA;

$directionABs[0] = FloatToVec (DirectionF($worldPosA,$worldPosB));
$directionABs[1] = FloatToVec (DirectionF($worldPosB,$worldPosA));

// P is the distance between 2 circles
float $P = distance2Pts ($worldPosA, $worldPosB);
float $r1 = $R1;
float $r1Z = $R1*2;
//HightsOfIsoscelesTriangle($P, $r1Z, $P);
float $Pi = 3.1415926535;
float $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1Z 2.000`) - (`pow $P 2.000`) )/(2.000*$P*$r1Z)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN =   $AngleNPi;
//float $ts = atand( (`abs ($r1 - $r2)`) /$P);
float $MultDirPC1[] = multiplyFloat($r1, $directionABs[0]);
float $AddMultDirPCA1[] = AddFloats($worldPosA, $MultDirPC1);

$AngleN = $Arcangle;
float $tsDAR = ( $AngleN)*-1;
float $tsDBR = ( $AngleN)*1;
//The first argument represents a point, the second an axis and the third an angle in radians
float $rotatsA[] = `rot $directionABs[0] $FloatDirNormal $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($worldPosA, $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $FloatDirNormal $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($worldPosA, $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);

vector $pointsT[];
$pointsT[0] = FloatToVec ($AddMultDirPCA1);
$pointsT[1] = FloatToVec ($AddMultDirPCA2);
return $pointsT;
}

*/




proc vector[] PointArrayT(string $ObjectList[]){

float $pointAZ1[];
vector $VecArray[];
int $XiV = 0;
for ($each in $ObjectList){
if (catch($pointAZ1 = `xform -q -ws -t ($each)`)){
$pointAZ1 = `pointPosition -w ($each)`;
} 
$VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
$XiV++;
}
return $VecArray;
}




proc TangentPointCircles(){

ResetTransEachSL;
vector $directionABs[];
vector $PosABs[];
float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
//float $FloatDirXn[] = DirectionF($AverageVecXYZsOnP, $VecXYZs[0]);
float $R1=$ObjsCircles[0];

// P is the distance between 2 circles
float $P = $ObjsCircles[2];
float $r1 = $R1;
float $r1Z = $R1*2;
HightsOfIsoscelesTriangle($P, $r1Z, $P);
float $Pi = 3.1415926535;
float $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1Z 2.000`) - (`pow $P 2.000`) )/(2.000*$P*$r1Z)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN =   $AngleNPi;
//float $ts = atand( (`abs ($r1 - $r2)`) /$P);
float $MultDirPC1[] = multiplyFloat($r1, $directionABs[0]);
float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);

$AngleN = $Arcangle;
float $tsDAR = ( $AngleN)*-1;
float $tsDBR = ( $AngleN)*1;
//The first argument represents a point, the second an axis and the third an angle in radians
//the normal $directionABs[2]
float $rotatsA[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);


float $rotatsC[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPCB1[] = multiplyFloat($r1, $rotatsC);
float $AddMultDirPCB1[] = AddFloats($PosABs[1], $MultDirPCB1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB1);
float $rotatsD[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPCB2[] = multiplyFloat($r1, $rotatsD);
float $AddMultDirPCB2[] = AddFloats($PosABs[1], $MultDirPCB2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB2);
curve2points($AddMultDirPCA1, $AddMultDirPCB1);
curve2points($AddMultDirPCA2, $AddMultDirPCB2);

curve2points($AddMultDirPCA1, $PosABs[0]);
curve2points($AddMultDirPCA2, $PosABs[0]);
curve2points($AddMultDirPCA1, $PosABs[1]);
curve2points($AddMultDirPCA2, $PosABs[1]);

}



Loc { 5 , 5,5};

proc Loc(float $Points[]){
string $LocObjects[] = `spaceLocator -p 0 0 0`;
setAttr ($LocObjects[0]+".translate")  $Points[0] $Points[1] $Points[2];
}


proc CircleBetweenCircle(){

string $selectedObjects[];
clear $selectedObjects;
$selectedObjects = `ls -sl`;

// select -r $selectedObjects[0]; // CIRCLE A
string $CurveSelectionA[] = `ls -fl ($selectedObjects[0]+".ep[0]")`; 
string $CurveSelectionB[] = `ls -fl ($selectedObjects[1]+".ep[0]")`; 
 float $FloatPointA[];	
	$FloatPointA = `pointPosition -w  $CurveSelectionA[0]`;
 float $worldPosA[];
       $worldPosA = `xform -q -ws -a -rp $selectedObjects[0]`;
 float $CircleRadiusA = getDistance($FloatPointA, $worldPosA);

 float $FloatPointB[];	
	$FloatPointB = `pointPosition -w  $CurveSelectionB[0]`;
float $worldPosB[];
	$worldPosB= `xform -q -ws -a -rp $selectedObjects[1]`;
 float $CircleRadiusB = getDistance ($FloatPointB, $worldPosB);

float $MidPoints[];
$MidPoints = MidPoint($worldPosA,  $worldPosB);
spaceLocator -p $MidPoints[0] $MidPoints[1] $MidPoints[2];
ResetTransEachSL;
float $DirectionToMid[] = DirectionTwoPoints($worldPosA, $worldPosB);
float $DirectionToMid2R[] = DirectionTwoPoints($worldPosB, $worldPosA);
/////////////////////////
float $PointA[] = multiplyFloat($CircleRadiusA, $DirectionToMid2R);
//then Add $PointToMid to
float $CircPointA[] = AddFloats($worldPosA,$PointA);
Loc($CircPointA);


/////////////////////////
float $PointB[] = multiplyFloat($CircleRadiusB, $DirectionToMid);
//then Add $PointToMid to
float $CircPointB[] = AddFloats($worldPosB,$PointB);
Loc($CircPointB);
/////////////////////////
float $GlobalMiddle[] = MidPoint($CircPointA, $CircPointB);
Loc($GlobalMiddle);
float $CircleDistanceAB = `getDistance $worldPosB $worldPosA`;
float $GlobalDistanceAB = (`getDistance $CircPointA $CircPointB`)/2;
float $DistanceABRadusB = $CircleDistanceAB/2;


////////////////
float $CircleSTotalDistanceD =  $DistanceABRadusB + $CircleRadiusA + $CircleRadiusB;
float $FinalRadus = `abs ($CircleDistanceAB - $CircleRadiusA - $CircleRadiusB)`;
float $FinalRadusB = $FinalRadus/2;
float $DistanceToMiddle = $FinalRadusB + $CircleRadiusB;
$DistanceToMiddle = $DistanceToMiddle *-1;
float $PointToMid[] = multiplyFloat($DistanceToMiddle, $DirectionToMid);
Loc($PointToMid);

//then Add $PointToMid to
float $CirclePoint[] = AddFloats($worldPosB,$PointToMid);
Loc($CirclePoint);
string $circlesDAB[] = `circle -c $CirclePoint[0] $CirclePoint[1] $CirclePoint[2] -nr 0 1 0 -sw 360 -r $FinalRadusB -d 3 -ut 0 -tol 0.001 -s 8 -ch 1`;
ResetTransEachSL;

}

/*
float $ObjsCirclesRad[];
vector $PosABs[];
vector $directionABs[];
vector $CurveInter[] = TangentPointCirVectors( $ObjsCirclesRad, $PosABs, $directionABs);
*/

proc vector [] TangentPointCirVectors(float $ObjsCirclesRad[], vector $PosABs[], vector $directionABs2[] ){

vector $CircIntersectABs[];
float $R1=$ObjsCirclesRad[0];
float $R2=$ObjsCirclesRad[1];
// P is the distance between 2 circles
vector $directionABs[];
float $P = distance2Pts ($PosABs[0], $PosABs[1]);
$directionABs[0] = FloatToVec (DirectionF($PosABs[0],$PosABs[1]));
$directionABs[1] = FloatToVec (DirectionF($PosABs[1],$PosABs[0]));
float $r1 = $R1;
float $r2 = $R2;
float $Pi = 3.1415926535;
float $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN = $AngleNPi;
float $Lengths[] = HightsOfIsoscelesTriangle($P, $r1, $r2);
float $MultDirPCR1[] = multiplyFloat($r1, $directionABs[0]);
float $AddMultDirPCR1[] = AddFloats($PosABs[0], $MultDirPCR1);
float $MultDirPCR2[] = multiplyFloat($r2, $directionABs[1]);
float $AddMultDirPCR2[] = AddFloats($PosABs[1], $MultDirPCR2);
float $MidPointsA[];
$MidPointsA = MidPoint($AddMultDirPCR1, $AddMultDirPCR2);
float $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
float $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
////////////////////////////////////////////////
////////////////////////////////////////////////
$AngleN = $Arcangle;
float $tsDAR = ( $AngleN)*-1;
float $tsDBR = ( $AngleN)*1;
//The first argument represents a point, the second an axis and the third an angle in radians
//the normal $directionABs[2]
float $rotatsA[] = `rot $directionABs[0] $directionABs2[0] $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $directionABs2[0] $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);

$CircIntersectABs[0] = << $AddMultDirPCA1[0], $AddMultDirPCA1[1], $AddMultDirPCA1[2] >>;
$CircIntersectABs[1] = << $AddMultDirPCA2[0], $AddMultDirPCA2[1], $AddMultDirPCA2[2] >>;
return $CircIntersectABs;
}



proc vector [] TangentPointCirclesVec2(){
ResetTransEachSL;
vector $CircIntersectABs[];
vector $directionABs[];
vector $PosABs[];
float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
float $R1=$ObjsCircles[0];
float $R2=$ObjsCircles[1];
// P is the distance between 2 circles

float $P = distance2Pts ($PosABs[0], $PosABs[1]);
float $r1 = $R1;
float $r2 = $R2;
float $Pi = 3.1415926535;
float $Arcangle = acos ((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1))) ;
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN = $AngleNPi;
float $Lengths[] = HightsOfIsoscelesTriangle($P, $r1, $r2);
float $MultDirPCR1[] = multiplyFloat($r1, $directionABs[0]);
float $AddMultDirPCR1[] = AddFloats($PosABs[0], $MultDirPCR1);
float $MultDirPCR2[] = multiplyFloat($r2, $directionABs[1]);
float $AddMultDirPCR2[] = AddFloats($PosABs[1], $MultDirPCR2);
float $MidPointsA[];
$MidPointsA = MidPoint($AddMultDirPCR1, $AddMultDirPCR2);
float $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
float $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
////////////////////////////////////////////////
////////////////////////////////////////////////
$AngleN = $Arcangle;
float $tsDAR = ( $AngleN)*-1;
float $tsDBR = ( $AngleN)*1;
//The first argument represents a point, the second an axis and the third an angle in radians
//the normal $directionABs[2]
float $rotatsA[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);

$CircIntersectABs[0] = << $AddMultDirPCA1[0], $AddMultDirPCA1[1], $AddMultDirPCA1[2] >>;
$CircIntersectABs[1] = << $AddMultDirPCA2[0], $AddMultDirPCA2[1], $AddMultDirPCA2[2] >>;
return $CircIntersectABs;
}

/////////////////////////

/*
string $StraitCurve[] = `ls -sl`;
float $ArcLengthOne = `arclen $StraitCurve[0]`;
float $ArcLengthRadius = $ArcLengthOne/2;
float $ArcLenRadiusSDi = (`hypot $ArcLengthRadius $ArcLengthRadius`)*2;
float $ArcLenRadiusSRa = (`hypot $ArcLengthRadius $ArcLengthRadius`);

ResetTransEachSL;
vector $directionABs[];
vector $PosABs[];
float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
float $R1=$ObjsCircles[0];
float $R2=$ObjsCircles[1];

float $RadiusSRa1 = (`hypot $R1 $R1`);
float $RadiusSDi1 = $RadiusSRa1 *2;
float $RadiusSRa2 = (`hypot $R2 $R2`);
float $RadiusSDi2 = $RadiusSRa2 *2;

string $LargeCir[] = `ls -sl`;
float $CirclesRadiusLarge = CirclesRadius($LargeCir);
float $LarCirPos[] = `xform -q -ws -a -rp $LargeCir[0]`;

string $LargeCirIN[] = `ls -sl`;
float $CirclesRadiusLargeIN = CirclesRadius($LargeCirIN);
float $LarCirPosIN[] = `xform -q -ws -a -rp $LargeCirIN[0]`;

string $SmallCir[] = `ls -sl`;
float $CirclesRadiusSmall = CirclesRadius($SmallCir);
float $SmallCirPos[] = `xform -q -ws -a -rp $SmallCir[0]`;

float $r1 = $R1;
float $r2 = $R2;
float $r3 = $R1+$R2;


float $MultDirPCR1[] = multiplyFloat($r1, $directionABs[0]);
float $AddMultDirPCR1[] = AddFloats($PosABs[0], $MultDirPCR1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCR1);
float $MultDirPCR2[] = multiplyFloat($r2, $directionABs[1]);
float $AddMultDirPCR2[] = AddFloats($PosABs[1], $MultDirPCR2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCR2);

float $rad90 = `deg_to_rad 90`;
float $rad45 = `deg_to_rad 45`;
float $rad180 = `deg_to_rad 180`;

float $rotats90A[] = `rot $directionABs[0] $directionABs[2] $rad90`;
float $MultDir90PC1[] = multiplyFloat($r1, $rotats90A);
float $TopLargeInsideC[] = AddFloats($PosABs[0], $MultDir90PC1);
spaceLocator -p 0 0 0;
MoveObject2($TopLargeInsideC);
//Top Large Inside C
float $rotats90Az[] = `rot $directionABs[0] $directionABs[2] $rad180`;
float $MultDir90PC1z[] = multiplyFloat($r1, $rotats90Az);
float $pointX[] = AddFloats($PosABs[0], $MultDir90PC1z);
spaceLocator -p 0 0 0;
MoveObject2($pointX);
//Top Left Side Large Inside C pointX
float $rotats90B[] = `rot $directionABs[0] $directionABs[2] $rad90`;
float $MultDir90PC2[] = multiplyFloat($r2, $rotats90B);
float $TopSmallInsideC[] = AddFloats($PosABs[1], $MultDir90PC2);
spaceLocator -p 0 0 0;
MoveObject2($TopSmallInsideC);
//Top Small Inside C
float $rotats90Bz[] = `rot $directionABs[0] $directionABs[2] $rad45`;
float $MultDir90PC2z[] = multiplyFloat($RadiusSRa2, $rotats90Bz);
float $TopSmallInsideCz[] = AddFloats($PosABs[1], $MultDir90PC2z);
spaceLocator -p 0 0 0;
MoveObject2($TopSmallInsideCz);
float $rotz[] = `rot $directionABs[1] $directionABs[2] $rad180`;
float $Multz[] = multiplyFloat($r2, $rotz);
float $TopSmallz[] = AddFloats($PosABs[1], $Multz);
spaceLocator -p 0 0 0;
MoveObject2($TopSmallz);

float $RDirZ[] = DirectionF ($pointX, $TopSmallInsideCz);
float $RDirX[] = DirectionF ($PosABs[0], $TopLargeInsideC);
curve2points($pointX, $TopSmallInsideCz);
curve2points($PosABs[0], $TopLargeInsideC);

 float $GothlocsA[] = lineIntersection($AddMultDirPCR1, $RDirX, $pointX, $RDirZ );
spaceLocator -p 0 0 0;
MoveObject2($GothlocsA);

float $DisBetweenGothLocs = distance2Pts($AddMultDirPCR1,$GothlocsA);
float $DisAdding = $DisBetweenGothLocs;
vector $GothVecs[];
clear $GothVecs;
$GothVecs[0] = `FloatToVec($GothlocsA)`;
int $ixV = 0;
int $nNVi = 12;
float $Mul[],$Add[];
while ($nNVi > $ixV){
	$Mul = multiplyFloat($DisAdding, $RDirX);
	$Add = AddFloats($GothlocsA, $Mul);
$GothVecs[`size($GothVecs)`] = `FloatToVec($Add)`; 
$DisAdding += $DisBetweenGothLocs;
$ixV++;
}

print $GothVecs;
for ($each in $GothVecs){
Loc $each;
}


   
float $Z_zero[] = $pointX; 
float $intersectCPoint2[] = lineIntersectionF( $Z_zero, $GothVecs[1], $TopSmallz, $TopLargeInsideC);
spaceLocator -p 0 0 0;
MoveObject2($intersectCPoint2);

float $intersectCPoint3[] = lineIntersectionF( $LarCirPos, $GothVecs[1], $SmallCirPos, $GothVecs[3]);
spaceLocator -p 0 0 0;
MoveObject2($intersectCPoint3);

curve2points($Z_zero, $GothVecs[1]);
curve2points($TopSmallz, $TopLargeInsideC);

curve2points($LarCirPos, $GothVecs[1]);
curve2points($SmallCirPos, $GothVecs[3]);

//Pos 1 // $TopLargeInsideC//radius 1 // $RadiusSRa1//Pos 2 // $TopSmallInsideC//radius 2 //$RadiusSRa2
vector $PosABsZ[];
clear $PosABsZ;
float $ObjsCirclesRadZ[];
vector $directionABsZ[];
clear $directionABsZ;
$directionABsZ[0] = $directionABs[2];

$PosABsZ[0]= `FloatToVec $TopLargeInsideC`;
$ObjsCirclesRadZ[0]= $RadiusSRa1;
$PosABsZ[1]= `FloatToVec $LarCirPos`;
$ObjsCirclesRadZ[1]=  $CirclesRadiusLarge;
///////////////
///////////////
vector $CurveInter[];
clear $CurveInter;
	$CurveInter = TangentPointCirVectors( $ObjsCirclesRadZ, $PosABsZ, $directionABsZ);
print $CurveInter;
///////////////
//Below Compare Both Vecs to $pointX which is the point 
//where Both Larg inner Cirs Touch Outer Largest Circle Every other Circle is nested in
vector $CurveInterOne[];
clear $CurveInterOne;
 int $IFequivalent;
if(`size($CurveInter)`>1){
for ($eachVec in $CurveInter){
 $IFequivalent = PointsEquivalentTol ($pointX, $eachVec );
  	if (!($IFequivalent == 3)){  $CurveInterOne[`size($CurveInterOne)`]=$eachVec; 
$CurveInter = $CurveInterOne; break;
}
}
}

print  $CurveInterOne;
///////////////
///////////////

$PosABsZ[0]= `FloatToVec $TopLargeInsideC`;
$ObjsCirclesRadZ[0]= $RadiusSRa1;
$PosABsZ[1]= `FloatToVec $SmallCirPos`;
$ObjsCirclesRadZ[1]=  $CirclesRadiusSmall;

vector $CurveInter2[];
clear $CurveInter2;
	$CurveInter2 = TangentPointCirVectors( $ObjsCirclesRadZ, $PosABsZ, $directionABsZ);

//Below Compare Both Vecs to $AddMultDirPCR2 which is the point 
//where Both Larg & Small inner Cirs Touch

vector $CurveInterOneB[];
clear $CurveInterOneB;
 int $IFequivalent;
if(`size($CurveInter2)`>1){
for ($eachVec in $CurveInter2){
 $IFequivalent = PointsEquivalentTol ($AddMultDirPCR2, $eachVec );
  	if (!($IFequivalent == 3)){  $CurveInterOneB[`size($CurveInterOneB)`]=$eachVec; 
$CurveInter2 = $CurveInterOneB; break;
}
}
}

print $CurveInterOneB;
///////////////
///////////////

// Circle3PtZFloats($CurveInterOne[0], $CurveInterOneB[0], $intersectCPoint2);
 Circle3PtZFloats($CurveInterOne[0], $CurveInterOneB[0], $intersectCPoint2);
//####FIXXXXXXXXXXX
ResetTransEachSL;
string $NCir[] = `ls -sl`;
float $CirclesRadNCir = CirclesRadius($NCir);
float $NCirPos[] = `xform -q -ws -a -rp $NCir[0]`;

//$intersectCPoint2 
print $directionABs[2]

float $GothF[] = $GothVecs[1];
float $DirectF[] = $directionABs[2];
vector $PointTan[] = PointToCircleTangents($r1, $LarCirPosIN, $GothVecs[1],  $DirectF);
print $PointTan;

vector $PointTanOne[];
clear $PointTanOne;
 int $IFequivalent;
if(`size($PointTan)`>1){
for ($eachVecC in $PointTan){
 $IFequivalent = PointsEquivalentTol ($pointX, $eachVecC );
  	if (!($IFequivalent == 3)){  $PointTanOne[`size($PointTanOne)`]=$eachVecC; 
$PointTan = $PointTanOne; break;
}
}
}

Loc $PointTan[0];


float $intersectMiiPoint3[] = lineIntersectionF( $GothVecs[0], $CurveInterOneB[0], $TopSmallz, $TopSmallInsideCz);
spaceLocator -p 0 0 0;
MoveObject2($intersectMiiPoint3);

float $intersectMiiiP[] = lineIntersectionF( $CurveInterOneB[0], $GothVecs[0], $pointX, $TopSmallz);
spaceLocator -p 0 0 0;
MoveObject2($intersectMiiiP);


float $RDirXs[] = DirectionF ($TopSmallz,$intersectMiiPoint3);
float $DisBetween45DegSmalF = distance2Pts($TopSmallz,$intersectMiiPoint3);
float $DisAdding =  $DisBetween45DegSmalF ;
vector $s45Vecs[];
clear $s45Vecs;
$s45Vecs[0] = `FloatToVec($TopSmallz)`;
int $ixV = 0;
int $nNVi = 12;
float $Mul[],$Add[];
while ($nNVi > $ixV){
	$Mul = multiplyFloat($DisAdding, $RDirXs);
	$Add = AddFloats($TopSmallz, $Mul);
$s45Vecs[`size($s45Vecs)`] = `FloatToVec($Add)`; 
$DisAdding +=  $DisBetween45DegSmalF ;
$ixV++;
}

print $s45Vecs;
for ($each in $s45Vecs){
Loc $each;
}


int $Gg = 2;

// vector $PointTan[] = PointToCircleTangents($r1, $LarCirPosIN, $GothVecs[1],  $DirectF);
vector $PointTan2[] = PointToCircleTangents($CirclesRadiusLarge, $LarCirPos, $s45Vecs[$Gg], $DirectF);

$Gg = 4;
vector $PointTan3[] = PointToCircleTangents($CirclesRadNCir, $NCirPos, $s45Vecs[$Gg], $DirectF);
Loc $PointTan2[1];
Loc $PointTan3[1];
Loc $PointTan[0];

 Circle3PtZFloats($PointTan[0], $PointTan2[1], $PointTan3[1]);

ResetTransEachSL;
string $NCirB[]= `ls -sl` ;
float $CirclesRadNCir1 = CirclesRadius( $NCirB);
 float $NCirPosB[] = `xform -q -ws -a -rp $NCirB`;

int $Goth = 2;

int $Ag= 2;
int $Agg= 5;

$Gg = $Ag++;

vector $PointTan6[] = PointToCircleTangents($r1, $LarCirPosIN, $GothVecs[2],  $DirectF);

vector $PointTan4[] = PointToCircleTangents($CirclesRadiusLarge, $LarCirPos, $s45Vecs[3], $DirectF);

vector $PointTan5[] = PointToCircleTangents($CirclesRadNCir1, $NCirPosB, $s45Vecs[12], $DirectF);


$Goth++;

Loc $PointTan4[1];
Loc $PointTan5[0];
Loc $PointTan6[1];


 Circle3PtZFloats($PointTan4[1], $PointTan5[0], $PointTan6[1]);

ResetTransEachSL;
string $NCirB[]= `ls -sl` ;
float $CirclesRadNCir1 = CirclesRadius( $NCirB);
 float $NCirPosB[] = `xform -q -ws -a -rp $NCirB`;





vector $PointTan[] = PointToCircleTangents($r1, $LarCirPosIN, $GothVecs[1],  $DirectF);
vector $PointTan2[] = PointToCircleTangents($CirclesRadiusLarge, $LarCirPos, $s45Vecs[2], $DirectF);
vector $PointTan3[] = PointToCircleTangents($CirclesRadNCir, $NCirPos, $s45Vecs[4], $DirectF);
1
2
4

2
3
6
vector $PointTan6[] = PointToCircleTangents($r1, $LarCirPosIN, $GothVecs[2],  $DirectF);
vector $PointTan4[] = PointToCircleTangents($CirclesRadiusLarge, $LarCirPos, $s45Vecs[3], $DirectF);
vector $PointTan5[] = PointToCircleTangents($CirclesRadNCir1, $NCirPosB, $s45Vecs[6], $DirectF);


proc float[] EulerAngleofCurve(){
string $CurveItem[];
$CurveItem = `ls -sl`;
string $CurveSelection[];
int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 		
$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}
vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
float $MagVectorZ1 = mag($vectorZ1); 
float $MagVectorZ2 = mag($vectorZ2);
float $EACHCVposHigher[];
float $EACHCVposLower[];
if ( $MagVectorZ1 > $MagVectorZ2 ){
print (" posA is Higher " + "\n");
$EACHCVposHigher = $EACHCVposAZ;
$EACHCVposLower = $EACHCVposBZ;
}
if ( $MagVectorZ1 < $MagVectorZ2  ){
print (" posB is Higher " + "\n");
$EACHCVposHigher = $EACHCVposBZ;
$EACHCVposLower = $EACHCVposAZ;
}
float $pointCVAB_MidPoint[] = MidPointBetween ($EACHCVposHigher, $EACHCVposLower);
/////////////////////////////////////
vector $UnitVectorMagPosHigher[] =  MagTimesUnitVecs($EACHCVposHigher,  $pointCVAB_MidPoint);
float $vector_SubUnitMagVec1[];
$vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 
vector $UnitVectorMagPosLower[] =  MagTimesUnitVecs($EACHCVposLower,  $pointCVAB_MidPoint);
float $vector_SubUnitMagVec2[];
$vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]); 
///////////////////////////////////////////////// ////
float $curveArclenZ  = `arclen $CurveItem`;
float $DivideIt  = $curveArclenZ / 2.0;
float $DivideIt2  = $DivideIt * -1;
float $pointB1[] = {0.0 , 0.0 , $DivideIt} ;
float $pointB2[] = {0.0 , 0.0 , $DivideIt2} ;
/// NOTE curve ENds will not allways Line up and  may be inverted
//let $F1 be the first CV $F2 the last .. $F3  third point
int $Z = FindclosetTOcurveENDz($pointB1,  $pointB2, $vector_SubUnitMagVec2);
if ($Z == 1){ print "new floats"; $pointB1 =  $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
float $EulerAngleA[] = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2   $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2 [1] $vector_SubUnitMagVec2[2]`;
float $EulerAngleB[] = `angleBetween -euler -v1  $pointB2[0] $pointB2[1] $pointB2[2] -v2  $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1 [1] $vector_SubUnitMagVec1[2]`;

return $EulerAngleA;
}



string $ObjectList[]= `ls -sl`;
vector $Vecs[]= PointArrayT($ObjectList);

print $Vecs;
//clear $Vecs;
float $FloatM1= $Vecs[0]*5;
vector $Vecsa= abs($Vecs[0]+$Vecs[1])+ abs ($Vecs[2]+$Vecs[3]) ;

float $FloatDirT[] = DirectionF($Vecs[0], $Vecs[1]);

float $intersectPii[] = lineIntersectionF( $Vecs[0], $Vecs[1], $Vecs[2], $Vecs[3]);
Loc $intersectPii;
// Result: 8 0 10 // 

	// Get the vector p1-p2, p3-p4
	// Get the vector  p3-p4
vector $Ui= $Vecs[0];
vector $Vi= $Vecs[1];
float $p1[] =  FloatToVec($Vecs[0]);
float $p2[] =  FloatToVec($Vecs[1]);
float $p3[] =  FloatToVec($Vecs[0]);
float $p4[] =  FloatToVec($Vecs[2]);

vector $Doti = ($Ui.x * $Vi.x) + ($Ui.y * $Vi.y) + ($Ui.z * $Vi.z);
vector $perp = ($Ui.x * $Vi.y) - ($Ui.y * $Vi.x);  //2D

vector $A1 =$Vecs[0];
vector $A2 =$Vecs[1];
vector $B1 =$Vecs[2];
vector $B2 =$Vecs[3];


float $EulerAngleA[] = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $Vec2[0] $Vec2 [1] $Vec2[2]`;


sqrt (($A1.x*$A2.x) + ($A1.y*$A2.y) + ($A1.z*$A2.z));

vector $BB1 = `cross ($B2-$B1) ($A1-$B1)`;
vector $BB2 = `cross($A2-$A1) ($B2-$B1)`;
vector $AA1 = `cross ($A2-$A1) ($A1-$B1)`;
vector $AA2 = `cross($A2-$A1) ($B2-$B1)`;


float $nAa = `dot $BB1 $BB2`;
float $nBb = `dot $AA1 $AA2`;

// $nA = dot(cross($B2-$B1,$A1-$B1),cross($A2-$A1,$B2-$B1));
// $nB = dot(cross($A2-$A1,$A1-$B1),cross($A2-$A1,$B2-$B1));
// d = dot(cross($A2-$A1,$B2-$B1),cross($A2-$A1,$B2-$B1));
// A0 = $A1 + ($nA/d)*($A2-$A1);
// B0 = $B1 + ($nB/d)*($B2-$B1);

vector $DD1 =  `cross($A2-$A1) ($B2-$B1)`;
vector $CC1 =  `cross($A2-$A1) ($B2-$B1)`;


float $Dd = `dot  $DD1 $CC1` ;
float $A0 = $A1 + ($nAa/$Dd)*($A2-$A1);
float $B0 = $B1 + ($nBb/$Dd)*($B2-$B1);


	float $p1p2[3];
	float $p1p3[3];
	$p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
	$p1p3[0] = $p4[0]-$p3[0]; 		$p1p3[1] = $p4[1]-$p3[1]; 		$p1p3[2]= $p4[2]-$p3[2];

print $p1p2;
print $p1p3;
//////////////////////////////////////





proc float [] xyzRotation( float $theta, float $axis[])
//
//	Description:
//		Given an angle for rotation (in radians) and an axis about which to 
//		do the rotation, return the rotation about the X,Y,Z axes (in $rotation).
//
{

float $rotation[] ;
	// set up the xyzw quaternion values
	//
	$theta *= 0.5;
	float $w = cos($theta);
	float $factor = sin($theta);
	float $axisLen2 = dotProduct( $axis, $axis, 0 );
	if ( $axisLen2 != 1.0 && $axisLen2 != 0.0 ) $factor /= sqrt($axisLen2);
	float $x = $factor * $axis[0];
	float $y = $factor * $axis[1];
	float $z = $factor * $axis[2];

	// setup rotation in a matrix
	//
	float $matrix[];
	float $ww = $w*$w;
	float $xx = $x*$x;
	float $yy = $y*$y;
	float $zz = $z*$z;
	float $s = 2.0 / ($ww + $xx + $yy + $zz);
	float $xy = $x*$y;
	float $xz = $x*$z;
	float $yz = $y*$z;
	float $wx = $w*$x;
	float $wy = $w*$y;
	float $wz = $w*$z;
	$matrix[0] = 1.0 - $s * ($yy + $zz);
	$matrix[1] = $s * ($xy + $wz);
	$matrix[2] = $s * ($xz - $wy);
	$matrix[5] = 1.0 - $s * ($xx + $zz);
	$matrix[6] = $s * ($yz + $wx);
	$matrix[9] = $s * ($yz - $wx);
	$matrix[10] = 1.0 - $s * ($xx + $yy);

	// get x,y,z values for rotation
	//
	float $solution1[];
	float $solution2[];
	float $cosB = sqrt($matrix[0]*$matrix[0] + $matrix[1]*$matrix[1]);
	if ( $cosB > 1.0e-10 )
	{
		float $a, $b, $c;
		float $pi = 3.14159265;
 
		$solution1[0] = $a = atan2( $matrix[6], $matrix[10]);
		$solution1[1] = $b = atan2(-$matrix[2], $cosB);
		$solution1[2] = $c = atan2( $matrix[1], $matrix[0]);

		$solution2[0] = $a + (($a < $pi) ? $pi : -$pi);
		$solution2[1] = (($b > -$pi) ? $pi : -$pi) - $b;
		$solution2[2] = $c + (($c < $pi) ? $pi : -$pi);    

		if ( abs($solution2[0]) + abs($solution2[1]) + abs($solution2[2]) <
			abs($solution1[0]) + abs($solution1[1]) + abs($solution1[2]) )
		{
			$rotation = $solution2;
		}
		else 
		{
			$rotation = $solution1;
		}
	}
	else
	{
		$rotation[0] = atan2(-$matrix[9], $matrix[5]);
		$rotation[1] = atan2(-$matrix[2], $cosB);
		$rotation[2] = 0.0;
	}



return $rotation;
}








float $rotats1[] = RotDirToPoint($point1, $point2, 1, $normal, $Rot1R);
Loc $rotats1;
float $rotats2[] = RotDirToPoint($point3, $point2, 1, $normal, $Rot3R);
Loc $rotats2;

float $rotats3[] = RotDirToPoint($point2, $point1, 1, $normal, $Rot2R);
Loc $rotats3;




rotate -r -ws $Rotation1[1] $Rotation2[1] $Rotation3[1];


RotateItX $angleTanYi;
rotate -r -ws $Rotation[0] $Rotation[1] $Rotation[2];



///////////////////////////////////////////////////////////

	float $p1p2[3];
	float $p1p3[3];
	$p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
	$p1p3[0] = $p4[0]-$p3[0]; 		$p1p3[1] = $p4[1]-$p3[1]; 		$p1p3[2]= $p4[2]-$p3[2];

vector $Ui = FloatToVec($p1p2);
vector $Vi = FloatToVec($p1p3);

print $p1p3;
Loc $p1p2;
Loc $p1p3;

float $angleTan = atan2d($p1p2[0], $p1p3[1])

vector $Ui = FloatToVec($p1p2);
vector $Vi = FloatToVec($p1p3);

float $magU = `mag $Ui`;
float $magV = `mag $Vi`;

float $angleTan = atan2d($p1p3[0], $magV);
float $angleTanYi[] = {0.0 , $angleTan , 0.0};


//RotateItX $angleTanYi;
// arclen

float $Rotation[] = EulerAng($p1p2, $p1p3);

rotate -r -ws $Rotation[0] $Rotation[1] $Rotation[2];



float $intersectPii[] = lineIntersectionF( $Vecs[0], $Vecs[1], $Vecs[2], $Vecs[3]);
print  $Vecs;
// Result: 8 0 10 // 
print  $Vecs;
6 0 2
7 0 6
4 0 10
10 0 10

float $normal[3];
	$normal = crossProduct( $p1p2, $p1p3, 0, 0 );
Loc $normal;
$x=dot(FloatToVec($p1p2), FloatToVec($p1p3));
$w=cross(FloatToVec($p1p2), FloatToVec($p1p3));

Loc $intersectPii;
vector $VecT1= $Vecs[0]+0;
vector $VecT2= $Vecs[3]+0;
vector $Vec11= $Vecs[0]-$Vecs[1];
vector $Vec22= $Vecs[2]-$Vecs[3];
Loc $Vec11;
Loc $Vec22;

cross $Vecs[0] $Vecs[1]

// Result: 12 0 10 // 
print $Vecs[0];
12 0 12
12 0 7

5 0 10
8 0 10

<<12, 0, 12>>
 <<0, 0, 5>>

<<8, 0, 10>>
<<-3, 0, 0>>

vector $VecOone = `FloatToVec($intersectPii)`;


$LarCirPos
$LarCirPosIN
$SmallCirPos

$CirclesRadNCir
$NCirPos

Loc $s45Vecs[3];



    vector   $u = $A2 - $A1;
    vector   $v = $B2 - $B1;
    vector   $w = $A2 - $B2;
dot $u $u;

    float    $a = `dot $u $u `;        // always >= 0
    float    $b = `dot $u $v `;
    float    $c = `dot $v $v `;        // always >= 0
    float    $d = `dot $u $w `;
    float    $e = `dot $v $w `;
    float    $D = $a*$c - $b*$b;       // always >= 0
    float    $sc, $tc;

//dot(u,v)   ((u).x * (v).x + (u).y * (v).y + (u).z * (v).z)
vector $Doti = ($Ui.x * $Vi.x) + ($Ui.y * $Vi.y) + ($Ui.z * $Vi.z);

norm(v)    sqrt(`dot $v $v` )


proc float dist3D_Line_to_Line( Line $L1, Line $L2)
{

float $SMALL_NUM = 0.00000001;

    Vector   $u = L1.P1 - L1.P0;
    Vector   $v = L2.P1 - L2.P0;
    Vector   $w = L1.P0 - L2.P0;

    float    $a = dot($u,$u);        // always >= 0
    float    $b = dot($u,$v);
    float    $c = dot($v,$v);        // always >= 0
    float    $d = dot($u,$w);
    float    $e = dot($v,$w);
    float    $D = $a*$c - $b*$b;       // always >= 0
    float    $sc, $tc;

    // compute the line parameters of the two closest points
    if ($D < $SMALL_NUM) {         // the lines are almost parallel
        $sc = 0.0;
        $tc = ($b>$c ? $d/$b : $e/$c);   // use the largest denominator
    }
    else {
        $sc = ($b*$e - $c*$d) / $D;
        $tc = ($a*$e - $b*$d) / $D;
    }

    // get the difference of the two closest points
    vector   $dP 
= $w + ($sc * $u) - ($tc * $v);  // = $L1($sc) - $L2($tc)

 sqrt(`dot $u $u` )

float $XX = ($sc)-($tc);


    return norm($dP);   // return the closest distance
}


// float $CircleRadiusA=$r1;
// float $worldPosA[] = $LarCirPosIN;
// float $worldPosB[]=$GothF;
// float $FloatDirNormal[]=$DirectF;


proc vector [] PointToCircleTangents(float $CircleRadiusA, float $worldPosA[], float $worldPosB[], float $DirNormalF[]){

vector $directionABs[];
float $R1 = $CircleRadiusA;
vector $DirNormal = FloatToVec ($DirNormalF);
$directionABs[0] = FloatToVec (DirectionF($worldPosA,$worldPosB));
$directionABs[1] = FloatToVec (DirectionF($worldPosB,$worldPosA));

// P is the distance between 2 circles
float $P = distance2Pts ($worldPosA, $worldPosB);
float $r1 = $R1;
float $r1Z = $R1*2;
//HightsOfIsoscelesTriangle($P, $r1Z, $P);
float $Pi = 3.1415926535;
float $Arcangle = acos((((`pow $P 2.000`) +  ((`pow $r1Z 2.000`) - (`pow $P 2.000`)) ) /(2.000*$P*$r1Z)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN =   $AngleNPi;
//float $ts = atand( (`abs ($r1 - $r2)`) /$P);
float $MultDirPC1[] = multiplyFloat($r1, $directionABs[0]);
float $AddMultDirPCA1[] = AddFloats($worldPosA, $MultDirPC1);

$AngleN = $Arcangle;
float $tsDAR = ( $AngleN)*-1;
float $tsDBR = ( $AngleN)*1;
//The first argument represents a point, the second an axis and the third an angle in radians
//$directionABs[1] is reverse for a reason
float $rotatsA[] = `rot $directionABs[1] $DirNormal $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($worldPosA, $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $DirNormal $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($worldPosA, $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);

vector $pointsT[];
$pointsT[0] = FloatToVec ($AddMultDirPCA1);
$pointsT[1] = FloatToVec ($AddMultDirPCA2);
return $pointsT;
}










*/





proc TangentPointCircles2(){
ResetTransEachSL;
vector $directionABs[];
vector $PosABs[];
float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
//float $FloatDirXn[] = DirectionF($AverageVecXYZsOnP, $VecXYZs[0]);
float $R1=$ObjsCircles[0];
float $R2=$ObjsCircles[1];

// P is the distance between 2 circles
float $P = $ObjsCircles[2];
float $r1 = $R1;
float $r2 = $R2;

float $Pi = 3.1415926535;
float $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN = $AngleNPi;
float $Lengths[] = HightsOfIsoscelesTriangle($P, $r1, $r2);

//rotate -r -os 0 0 -29.65067 ;
// Result: Hight 4.990127 // 
// Result: BASE 8.77128 // 
// Result: BASE 5.953653 // 

//float $ts = atand( (`abs ($r1 - $r2)`) /$P);

float $MultDirPCR1[] = multiplyFloat($r1, $directionABs[0]);
float $AddMultDirPCR1[] = AddFloats($PosABs[0], $MultDirPCR1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCR1);
float $MultDirPCR2[] = multiplyFloat($r2, $directionABs[1]);
float $AddMultDirPCR2[] = AddFloats($PosABs[1], $MultDirPCR2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCR2);

float $MidPointsA[];
$MidPointsA = MidPoint($AddMultDirPCR1, $AddMultDirPCR2);
spaceLocator -p 0 0 0;
MoveObject2($MidPointsA);
float $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
float $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
spaceLocator -p 0 0 0;
MoveObject2($PosABs[0]);


////////////////////////////////////////////////
float $rRiP = $R1 + $R2;
float $PercentA = ((  $R2 /$rRiP) * (100.0) );
float $percentOf = $distCircToMidZ/ (100.0/$PercentA);
////////////////////////////////////////////////

float $distCircToMidA = $R1 - $percentOf;

float $MultDirPCRr1[] = multiplyFloat($distCircToMidA, $directionABs[0]);
float $AddMultDirPCRr1[] = AddFloats($PosABs[0], $MultDirPCRr1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCRr1);

//float $r1Z = $distCircToMidA*2;


$AngleN = $Arcangle;
float $tsDAR = ( $AngleN)*-1;
float $tsDBR = ( $AngleN)*1;
//The first argument represents a point, the second an axis and the third an angle in radians
//the normal $directionABs[2]
float $rotatsA[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);


float $rotatsC[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPCB1[] = multiplyFloat($r1, $rotatsC);
float $AddMultDirPCB1[] = AddFloats($PosABs[1], $MultDirPCB1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB1);
float $rotatsD[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPCB2[] = multiplyFloat($r1, $rotatsD);
float $AddMultDirPCB2[] = AddFloats($PosABs[1], $MultDirPCB2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB2);
curve2points($AddMultDirPCA1, $AddMultDirPCB1);
curve2points($AddMultDirPCA2, $AddMultDirPCB2);

curve2points($AddMultDirPCA1, $PosABs[0]);
curve2points($AddMultDirPCA2, $PosABs[0]);
curve2points($AddMultDirPCA1, $PosABs[1]);
curve2points($AddMultDirPCA2, $PosABs[1]);

}



TangentPointCircles;
CircleBetweenCircle;
TangentCircles;



proc TangentCircles(){
ResetTransEachSL;
vector $directionABs[];
vector $PosABs[];
float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
//float $FloatDirXn[] = DirectionF($AverageVecXYZsOnP, $VecXYZs[0]);
float $R1=$ObjsCircles[0];
float $R2=$ObjsCircles[1];

// P is the distance between 2 circles
float $P = $ObjsCircles[2];

float $DiCircleInBetween = $P -($R1 + $R2);
float $RadiCircleInBetween = $DiCircleInBetween/2;
float $DisCircBetweenFromR1 = $R1+$RadiCircleInBetween ;
//mult Direction Circ1 to Circ 2 by distance DisCircBetweenFromR1 
//add to Pos Circ R1 

float $MultDirM[] = multiplyFloat($DisCircBetweenFromR1, $directionABs[0]);
float $AddMultM[] = AddFloats($PosABs[0], $MultDirM);
spaceLocator -p 0 0 0;
MoveObject2($AddMultM);
string $circlesM = Circles_Direction($AddMultM,$directionABs[2], $RadiCircleInBetween);

float $Rn1 =  (1.0/(`sqrt $R1`)) + (1.0/(`sqrt $R2` ));
float $Rn = 1.0/$Rn1;
float $R = `pow $Rn 2`;
float $xc = `sqrt (4*$R1*$R)`;
float $yc = `sqrt (4*$R2*$R)`;
float $CurveL = $xc+$yc;
float $pi = 3.1415926535;

float $r1 = $R1;
float $r2 = $R2;
//float $ts = atand( (`abs ($r1 - $r2)`) /$P);

float $ts = acos ( (`abs ($r1 - $r2)`) /$P);
float $tsD = (`rad_to_deg $ts`);
float $tsDA = (`rad_to_deg $ts`)*1;
float $tsDB = (`rad_to_deg $ts`)*-1;
float $tsDAR = ( $ts)*1;
float $tsDBR = ( $ts)*-1;
//The first argument represents a point, the second an axis and the third an angle in radians
//the normal $directionABs[2]
float $rotatsA[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);
float $rotatsC[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPCB1[] = multiplyFloat($r2, $rotatsC);
float $AddMultDirPCB1[] = AddFloats($PosABs[1], $MultDirPCB1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB1);
float $rotatsD[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPCB2[] = multiplyFloat($r2, $rotatsD);
float $AddMultDirPCB2[] = AddFloats($PosABs[1], $MultDirPCB2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB2);
curve2points($AddMultDirPCA1, $AddMultDirPCB1);
curve2points($AddMultDirPCA2, $AddMultDirPCB2);


float $FloatDirectionTa1Tb2[] = DirectionF($AddMultDirPCA1, $AddMultDirPCB1);
float $MultDirT[] = multiplyFloat($xc, $FloatDirectionTa1Tb2);
float $FloatDirT[] = AddFloats($AddMultDirPCA1, $MultDirT);
float $FloatDirectionTCa[] = DirectionF($AddMultDirPCA1, $PosABs[0]);
float $MultDirTCa[] = multiplyFloat($R, $FloatDirectionTCa);
float $FloatDirTc[] = AddFloats($FloatDirT, $MultDirTCa);
spaceLocator -p 0 0 0;
MoveObject2($FloatDirTc);
string $circlesA = Circles_Direction($FloatDirTc,$directionABs[2], $R);
float $FloatDirectionTa1Tb3[] = DirectionF($AddMultDirPCA2, $AddMultDirPCB2);
float $MultDirTCb[] = multiplyFloat($xc, $FloatDirectionTa1Tb3);
float $FloatDirTb[] = AddFloats($AddMultDirPCA2, $MultDirTCb);
float $FloatDirectionTCb[] = DirectionF($AddMultDirPCA2, $PosABs[0]);
float $MultDirTCb[] = multiplyFloat($R, $FloatDirectionTCb);
float $FloatDirTcb[] = AddFloats($FloatDirTb, $MultDirTCb);
spaceLocator -p 0 0 0;
MoveObject2($FloatDirTcb);
string $circlesA = Circles_Direction($FloatDirTcb,$directionABs[2], $R);

}


///////////

proc  CreateCurveFromTwoSelected(){ 
string $selectedObjects[] = `ls -sl`;
vector $pointOne;
$pointOne = `xform -q -ws -sp $selectedObjects[0]`;
vector $pointTwo;
$pointTwo = `xform -q -ws -sp $selectedObjects[1]`;
curve2points $pointOne $pointTwo;
ResetTransEachSL;
}

proc float [] CirclesRadiiPos(string $CirObjects[], vector $PosAB[] ){

string $PointA[], $PointB[];
float $FloatPointA[], $FloatPointB[], $worldPosA[], $CircleRadii[];

for ($each in $CirObjects){
$PointA= `ls -fl ($each+".ep[0]")`; 
$PointB = `ls -fl ($each+".ep[3]")`; 
	$FloatPointA = `pointPosition -w  $PointA`;
	$FloatPointB = `pointPosition -w  $PointB`;	
       $worldPosA = `xform -q -ws -a -rp $each`;
$CircleRadii[`size($CircleRadii)`] = distance2Pts ($FloatPointA,$worldPosA) ;
$PosAB[`size($PosAB)`]= FloatToVec ($worldPosA);
}
return $CircleRadii;
}


proc float [] CircNormal(string $eachCirV){

string $PointA[], $PointB[];
float $FloatPointA[], $FloatPointB[], $worldPosA[];

$PointA = `ls -fl ($eachCirV+".ep[0]")`; 
$PointB = `ls -fl ($eachCirV+".ep[3]")`; 
	$FloatPointA = `pointPosition -w  $PointA `;
	$FloatPointB = `pointPosition -w  $PointB`;
     $worldPosA = `xform -q -ws -a -rp $eachCirV`;	
 float $FloatDirNormalCurveA[] = Normal3Points($worldPosA, $FloatPointA, $FloatPointB);
return $FloatDirNormalCurveA;
}

/*
int $indexNumberZ[] = stringArrayGmatchArrayIndex($diffBZ, $KnowObjList);

int $indexX= 0;
for ($eachVec in $indexNumberZ){
$firstReduction[`size($firstReduction)`]= $objVecMain[$eachVec];
}
}
*/






string $itemA[] = 
string $itemEach[], $diff[];
string $itemBackUp[] = $itemA; 
int $indexNumberZ[];
for($each in $itemBackUp){
//isolate one from list remove from list
//itemA will be reduced to zero

	string $itemEach[] = { $itemA[0] };
	$diff = stringArrayRemoveExact($itemEach, $itemA);
for($eachOther in $diff){
playButtonStepForward;
// $eachOther $itemEach;

float $FloatDirXn[] = DirectionF($PosABs[$CirA], $PosABs[$CirB]);

$indexNumberZ= stringArrayGmatchArrayIndex($diffBZ, $KnowObjList);


playButtonStepForward;
}
$itemA = $diff;

}
}


//////////////////////////////


///////////////////////////

//////////////////////////////

proc TANGENTSS(){

string $circles[] = `ls -sl`;
string $circlesShape[];
clear $circlesShape;
for ($eachCir in $circles){
$circlesShape[`size($circlesShape)`]  = stringArrayToString( `listRelatives $eachCir` , " ");
}
print $circlesShape;
 float $normalAxis[] = CircNormal($circles[0]);

ResetTransEachSL;
vector $directionABs[];
vector $PosABs[];
clear $PosABs;
float $ObjsCircles[] = CirclesRadiiPos($circles, $PosABs);

int $CirA;
int $CirB;

string $itemA[] = $circles;
string $itemEach[], $diff[];
string $itemBackUp[] = $itemA; 
int $indexNumberZ[];
string $TwoItemsZ[];
for($each in $itemBackUp){
//isolate one from list remove from list
//itemA will be reduced to zero

	string $itemEach[] = { $itemA[0] };
	$diff = stringArrayRemoveExact($itemEach, $itemA);
for($eachOther in $diff){
playButtonStepForward;
// $eachOther $itemEach;


$TwoItemsZ  = {$eachOther, $itemEach[0]};
$indexNumberZ= stringArrayGmatchArrayIndex($TwoItemsZ, $circles);

$CirA = $indexNumberZ[0];
$CirB = $indexNumberZ[1];

float $R1=$ObjsCircles[$CirA];
float $R2=$ObjsCircles[$CirB];
if($R1<$R2){$CirA = $indexNumberZ[1]; $CirB = $indexNumberZ[0];
 $R1=$ObjsCircles[$CirA];
 $R2=$ObjsCircles[$CirB];}

////////
playButtonStepForward;
select -r $circles[$CirA]; select -r $circles[$CirB];
///////

float $FloatDirXn[] = DirectionF($PosABs[$CirA], $PosABs[$CirB]);
float $R1=$ObjsCircles[$CirA];
float $R2=$ObjsCircles[$CirB];
//RotMultLenToDirAddToPoint(float $PosA[], float $PosB[], float $Length, float $DirNormAx[], float $Radian)


float $Rn1 =  (1.0/(`sqrt $R1`)) + (1.0/(`sqrt $R2` ));
float $Rn = 1.0/$Rn1;
float $R = `pow $Rn 2`;
float $xc = `sqrt (4*$R1*$R)`;
float $yc = `sqrt (4*$R2*$R)`;
float $CurveL = $xc+$yc;
float $pi = 3.1415926535;

float $r1 = $R1;
float $r2 = $R2;

// P is the distance between 2 circles
float $P = distance2Pts($PosABs[$CirA], $PosABs[$CirB]);
float $FloatDirXn[] = DirectionF($PosABs[$CirA], $PosABs[$CirB]);

float $DiCircleInBetween = `abs ($P -($R1 + $R2))`;
float $RadiCircleInBetween = $DiCircleInBetween/2;
float $DisCircBetweenFromR1 = $R1+$RadiCircleInBetween ;
//mult Direction Circ1 to Circ 2 by distance DisCircBetweenFromR1 
//add to Pos Circ R1 

float $MultDirM[] = multiplyFloat($DisCircBetweenFromR1,  $FloatDirXn);
float $AddMultM[] = AddFloats($PosABs[$CirA], $MultDirM);
spaceLocator -p 0 0 0;
MoveObject2($AddMultM);
string $circlesM = Circles_Direction($AddMultM,$normalAxis, $RadiCircleInBetween);


float $ts = acos ( (`abs ($r1 - $r2)`) /$P);
float $tsD = (`rad_to_deg $ts`);
float $tsDA = (`rad_to_deg $ts`)*1;
float $tsDB = (`rad_to_deg $ts`)*-1;
float $tsDAR = ( $ts)*1;
float $tsDBR = ( $ts)*-1;

//The first argument represents a point, the second an axis and the third an angle in radians
//the normal $directionABs[2]
//RotMultLenToDirAddToPoint(float $PosA[], float $PosB[], float $Length, float $DirNormAx[], float $Radian)


float $rotatsA[] = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $ObjsCircles[$CirA], $normalAxis, $tsDAR);
float $rotatsB[] = RotMultLenToDirAddToPoint($PosABs[$CirA], $PosABs[$CirB], 1, $ObjsCircles[$CirA], $normalAxis, $tsDBR);
float $rotatsC[] = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $ObjsCircles[$CirB], $normalAxis, $tsDBR);
float $rotatsD[] = RotMultLenToDirAddToPoint($PosABs[$CirB], $PosABs[$CirA], -1, $ObjsCircles[$CirB], $normalAxis, $tsDAR);
spaceLocator -p 0 0 0;
MoveObject2($rotatsA);
spaceLocator -p 0 0 0;
MoveObject2($rotatsB);
spaceLocator -p 0 0 0;
MoveObject2($rotatsC);
spaceLocator -p 0 0 0;
MoveObject2($rotatsD);
curve2points($rotatsA, $rotatsD);
curve2points($rotatsB,$rotatsC);

playButtonStepForward;
}
$itemA = $diff;

}
}




///////////////////////////////////////////
proc TangentCircleBetweenCircle(){




string $circles[] = `ls -sl`;
string $circlesShape[];
clear $circlesShape;
for ($eachCir in $circles){
$circlesShape[`size($circlesShape)`]  = stringArrayToString( `listRelatives $eachCir` , " ");
}
print $circlesShape;
 float $normalAxis[] = CircNormal($circles[0]);

ResetTransEachSL;
vector $directionABs[];
vector $PosABs[];
clear $PosABs;
float $ObjsCircles[] = CirclesRadiiPos($circles, $PosABs);

//float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
//from each to every other 




float $FloatDirXn[] = DirectionF($PosABs[0], $PosABs[1]);

//ResetTransEachSL;
//vector $directionABs[];
//vector $PosABs[];
//float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);


float $R1=$ObjsCircles[0];
float $R2=$ObjsCircles[1];

//RotMultLenToDirAddToPoint(float $PosA[], float $PosB[], float $Length, float $DirNormAx[], float $Radian)

float $Rn1 =  (1.0/(`sqrt $R1`)) + (1.0/(`sqrt $R2` ));
float $Rn = 1.0/$Rn1;
float $R = `pow $Rn 2`;

float $xc = `sqrt (4*$R1*$R)`;
float $yc = `sqrt (4*$R2*$R)`;
float $CurveL = $xc+$yc;
float $pi = 3.1415926535;

// P is the distance between 2 circles
float $P = distance2Pts($PosABs[0], $PosABs[1]);
float $r1 = $R1;
float $r2 = $R2;
//float $ts = atand( (`abs ($r1 - $r2)`) /$P);

float $DiCircleInBetween = `abs ($P -($R1 + $R2))`;
float $RadiCircleInBetween = $DiCircleInBetween/2;
float $DisCircBetweenFromR1 = $R1+$RadiCircleInBetween ;
//mult Direction Circ1 to Circ 2 by distance DisCircBetweenFromR1 
//add to Pos Circ R1 

float $MultDirM[] = multiplyFloat($DisCircBetweenFromR1, $directionABs[0]);
float $AddMultM[] = AddFloats($PosABs[0], $MultDirM);
float $MidPoints[];
$MidPoints = $AddMultM;

float $ts = acos ( (`abs ($r1 - $r2)`) /$P);
float $tsD = (`rad_to_deg $ts`);
float $tsDA = (`rad_to_deg $ts`)*1;
float $tsDB = (`rad_to_deg $ts`)*-1;
float $tsDAR = ( $ts)*1;
float $tsDBR = ( $ts)*-1;
//The first argument represents a point, the second an axis and the third an angle in radians
//the normal $directionABs[2]
//RotMultLenToDirAddToPoint(float $PosA[], float $PosB[], float $Length, float $DirNormAx[], float $Radian)
float $FloatDirXn[] = DirectionF($PosABs[0], $PosABs[1]);

float $rotatsA[] = RotMultLenToDirAddToPoint($PosABs[0], $PosABs[1], $ObjsCircles[0], $normalAxis, $tsDAR);

float $rotatsB[] = RotMultLenToDirAddToPoint($PosABs[0], $PosABs[1], $ObjsCircles[0], $normalAxis, $tsDBR);

float $rotatsC[] = RotMultLenToDirAddToPoint($PosABs[1], $PosABs[0], $ObjsCircles[1], $normalAxis, $tsDAR);

float $rotatsD[] = RotMultLenToDirAddToPoint($PosABs[1], $PosABs[0], $ObjsCircles[1], $normalAxis, $tsDBR);
curve2points($rotatsA, $rotatsD);
curve2points($rotatsB,$rotatsC);




print ($directionABs[0] +"\n");
print ($directionABs[2] +"\n");
print ($tsDAR +"\n");
$normalAxis = $directionABs[2];

float $rotatsA[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);

print $directionABs[0]

vector $DirecOfPointAB = FloatToVec ( DirectionF($PosABs[0], $PosABs[1]));
vector $DirNorm = FloatToVec ($normalAxis);
float $Radian = $tsDAR;


print ($DirecOfPointAB +"\n");
print ($DirNorm +"\n");
print ($Radian +"\n");

float $rotatsA[] = `rot $DirecOfPointAB $DirNorm $Radian`;
float $MultLengthDir[] = multiplyFloat($ObjsCircles[0], $rotatsA);

float $AddMultDirPos[] = AddFloats($PosABs[0], $MultLengthDir);


spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
spaceLocator -p 0 0 0;
MoveObject2($rotatsA);

float $rotatsB[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);
float $rotatsC[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPCB1[] = multiplyFloat($r2, $rotatsC);
float $AddMultDirPCB1[] = AddFloats($PosABs[1], $MultDirPCB1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB1);
float $rotatsD[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPCB2[] = multiplyFloat($r2, $rotatsD);
float $AddMultDirPCB2[] = AddFloats($PosABs[1], $MultDirPCB2);
spaceLocator -p 0 0 0;

MoveObject2($AddMultDirPCB2);
curve2points($AddMultDirPCA1, $AddMultDirPCB1);
curve2points($AddMultDirPCA2, $AddMultDirPCB2);











vector $directionABs[] = $PosABs;
clear $directionABs;

vector $directionABsZ = FloatToVec ($normalAxis)


vector $directionA = FloatToVec ($FloatDirXn);

float $rotatsC[] = `rot $directionA $directionABsZ $tsDAR`;
float $MultDirPCB1[] = multiplyFloat($r2, $rotatsC);
float $AddMultDirPCB1[] = AddFloats($PosABs[1], $MultDirPCB1);

float $rotatsD[] = `rot $directionA $directionABsZ $tsDBR`;
float $MultDirPCB2[] = multiplyFloat($r2, $rotatsD);
float $AddMultDirPCB2[] = AddFloats($PosABs[1], $MultDirPCB2);


curve2points($AddMultDirPCA1, $AddMultDirPCB1);
curve2points($AddMultDirPCA2, $AddMultDirPCB2);

curve2points($AddMultDirPCB1, $AddMultDirPCB2);

float $Uall[];


string $myCPOCA = `createNode closestPointOnCurve -name "CircleZzClosestPointOnCurve"`;

connectAttr -force ($circlesShape[0]+".worldSpace") ($myCPOCA+".inCurve");
clear $Uall;
setAttr ($myCPOCA+".inPosition") $AddMultDirPCA1[0] $AddMultDirPCA1[1] $AddMultDirPCA1[2];
float $U = `getAttr ($myCPOCA+".u")`;
$Uall[`size($Uall)`]= $U;
setAttr ($myCPOCA+".inPosition") $AddMultDirPCA2[0] $AddMultDirPCA2[1] $AddMultDirPCA2[2];
 $U = `getAttr ($myCPOCA+".u")`;
$Uall[`size($Uall)`]= $U;
disconnectAttr ($circlesShape[0]+".worldSpace") ($myCPOCA+".inCurve");



//PART 1//////////////////////////////////////////////////////////////

string $UpointCurveOne[];
$UpointCurveOne[0] = ($circles[0] + ".u[" + $Uall[0] + "]");
$UpointCurveOne[1] = ($circles[0] + ".u[" + $Uall[1] + "]");

//PART 2//////////////////////////////////////////////////////////////

connectAttr -force ($circlesShape[1]+".worldSpace[0]") ($myCPOCA+".inCurve");
clear $Uall;
setAttr ($myCPOCA+".inPosition") $AddMultDirPCB1[0] $AddMultDirPCB1[1] $AddMultDirPCB1[2];
float $U = `getAttr ($myCPOCA+".u")`;
$Uall[`size($Uall)`]= $U;
setAttr ($myCPOCA+".inPosition") $AddMultDirPCB2[0] $AddMultDirPCB2[1] $AddMultDirPCB2[2];
 $U = `getAttr ($myCPOCA+".u")`;
$Uall[`size($Uall)`]= $U;
disconnectAttr ($circlesShape[1]+".worldSpace[0]") ($myCPOCA+".inCurve");


string $UpointCurveOne2[];
$UpointCurveOne2[0] = ($circles[1] + ".u[" + $Uall[0] + "]");
$UpointCurveOne2[1] = ($circles[1] + ".u[" + $Uall[1] + "]");

/////////////////////////////////////////////////////////////////////////

string $NewcurvesA[] = `detachCurve -ch 1 -cos on -rpo 1 $UpointCurveOne[0] $UpointCurveOne[1]`;
ResetTransEachSL;

string $NewcurvesB[] = `detachCurve -ch 1 -cos on -rpo 1 $UpointCurveOne2[0] $UpointCurveOne2[1]`;
ResetTransEachSL;


int $ZeroOrOneC1 = 0;
string $CenterCurvesA[];
string $OuterCurvesA[];
vector $AposD1[];
int $iXv = 0;
for ($each in $NewcurvesA){
	$AposD1[$iXv] = `xform -q -ws -a -rp $each`;
if($iXv==1){
$ZeroOrOneC1 = FindclosetTOcurveENDz($AposD1[0], $AposD1[1], $MidPoints);
}
$iXv++;
}
int $OuterC1 = 0;
if($ZeroOrOneC1==0){ $OuterC1 = 1;}

$OuterCurvesA[0] = $NewcurvesA[$OuterC1];
$CenterCurvesA[0] = $NewcurvesA[$ZeroOrOneC1];

int $ZeroOrOneC2 = 0;
string $CenterCurvesB[];
string $OuterCurvesB[];
vector $AposD2[];
int $iIXv = 0;
for ($each in $NewcurvesB){
	$AposD2[$iIXv] = `xform -q -ws -a -rp $each`;
if($iIXv==1){
$ZeroOrOneC2 = FindclosetTOcurveENDz($AposD2[0], $AposD2[1], $MidPoints);
}
$iIXv++;
}


int $OuterC2 = 0;
if($ZeroOrOneC2==0){ $OuterC2 = 1;}

$OuterCurvesB[0] = $NewcurvesB[$OuterC2];
$CenterCurvesB[0] = $NewcurvesB[$ZeroOrOneC2];


select -r $OuterCurvesA $OuterCurvesB;
select -r $CenterCurvesA $CenterCurvesB;
delete $CenterCurvesA $CenterCurvesB;


}

/*


spaceLocator -p 0 0 0;
MoveObject2($AddMultM);
string $circlesM = Circles_Direction($AddMultM,$directionABs[2], $RadiCircleInBetween);



spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB2);

*/


proc TangentCirclesAtand(string $MathCommand){
ResetTransEachSL;
string $CirclesSelected[] =`ls -sl`;
vector $directionABs[];
vector $PosABs[];
float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
//float $FloatDirXn[] = DirectionF($AverageVecXYZsOnP, $VecXYZs[0]);
float $R1=$ObjsCircles[0];
float $R2=0;

float $Rn1 =  (1.0/(`sqrt $R1`)) ;
float $Rn = 1.0/$Rn1;
float $R = `pow $Rn 2`;
float $xc = `sqrt (4*$R1*$R)`;
float $yc = `sqrt (4*$R2*$R)`;
float $CurveL = $xc+$yc;
float $pi = 3.1415926535;
// P is the distance between 2 circles
float $P = $ObjsCircles[2];
float $r1 = $R1;
float $r2 = $R2;
//float $ts = acos( (`abs ($r1 - $r2)`) /$P);
float $ts ;
//$stringCommand = ("$ts = "+$MathCommand+"( (`abs ($r1 - $r2)`));");
string  $stringCommand = ( $MathCommand+"(($r1 - $r2)/$P);");
$ts = evalEcho($stringCommand);
print $ts ;

//float $ts =atand( (`abs ($r1 - $r2)`) /$P);
//float $ts = atand( ($r1 - $r2) /$P);

float $tsD = (`rad_to_deg $ts`);
float $tsDA = (`rad_to_deg $ts`)*1;
float $tsDB = (`rad_to_deg $ts`)*-1;
float $tsDAR = ( $ts)*1;
float $tsDBR = ( $ts)*-1;
//The first argument represents a point, the second an axis and the third an angle in radians
//the normal $directionABs[2]
float $rotatsA[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);
float $rotatsC[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPCB1[] = multiplyFloat($r2, $rotatsC);
float $AddMultDirPCB1[] = AddFloats($PosABs[1], $MultDirPCB1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB1);
float $rotatsD[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPCB2[] = multiplyFloat($r2, $rotatsD);
float $AddMultDirPCB2[] = AddFloats($PosABs[1], $MultDirPCB2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB2);
curve2points($AddMultDirPCA1, $AddMultDirPCB1);
curve2points($AddMultDirPCA2, $AddMultDirPCB2);
float $FloatDirectionTa1Tb2[] = DirectionF($AddMultDirPCA1, $AddMultDirPCB1);
float $MultDirT[] = multiplyFloat($xc, $FloatDirectionTa1Tb2);
float $FloatDirT[] = AddFloats($AddMultDirPCA1, $MultDirT);
float $FloatDirectionTCa[] = DirectionF($AddMultDirPCA1, $PosABs[0]);
float $MultDirTCa[] = multiplyFloat($R, $FloatDirectionTCa);
float $FloatDirTc[] = AddFloats($FloatDirT, $MultDirTCa);
spaceLocator -p 0 0 0;
MoveObject2($FloatDirTc);
string $circlesA = Circles_Direction($FloatDirTc,$directionABs[2], $R);
float $FloatDirectionTa1Tb3[] = DirectionF($AddMultDirPCA2, $AddMultDirPCB2);
float $MultDirTCb[] = multiplyFloat($xc, $FloatDirectionTa1Tb3);
float $FloatDirTb[] = AddFloats($AddMultDirPCA2, $MultDirTCb);
float $FloatDirectionTCb[] = DirectionF($AddMultDirPCA2, $PosABs[0]);
float $MultDirTCb[] = multiplyFloat($R, $FloatDirectionTCb);
float $FloatDirTcb[] = AddFloats($FloatDirTb, $MultDirTCb);
spaceLocator -p 0 0 0;
MoveObject2($FloatDirTcb);
string $circlesA = Circles_Direction($FloatDirTcb,$directionABs[2], $R);

select -r $CirclesSelected;
}


proc float [] Normal3Points(float $p1[],float $p2[],float $p3[]){ 

float $center[]; 
float $normal[];
	// Get the vector p1-p2, p1-p3
	//
	float $p1p2[3];
	float $p1p3[3];	
	$p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
	$p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
      	// Get the normal to the plane formed by p1, p2, p3, which is the
	// cross prod of p1-p2 and p1-p3	
	vector $normalV[];
	$normalV = crossProduct( $p1p2, $p1p3, 0, 0 );
float $normal[] = `unit $normalV[0]`;
return $normal;
}

proc MatchCurveLengthToCurve(){
string $Objs[] =`ls -sl`;
int $sizeCs = (`size($Objs)`)-1;
string $ObjsEnd[] =`ls -tl $sizeCs $Objs`;
string $ObjsFirst[] =`ls -hd 1 $Objs`;
float $compare = `arclen $ObjsFirst`;
float $ArcLengthAdd;
for($each in $ObjsEnd){
$ArcLengths = `arclen $each`;
$ArcLengthAdd = $compare - $ArcLengths;
if($ArcLengthAdd>0){
extendCurve -cos 0 -ch 1 -em 0 -et 0 -d $ArcLengthAdd  -s 0 -jn true -rmk true -rpo on $each ;
}

}
}


proc CurveLengthToFloat(float $Number){
string $Objs[] =`ls -sl`;
for($each in $Objs){
$ArcLengths = `arclen $each`;
$ArcLengthAdd = $Number - $ArcLengths;
if($ArcLengthAdd>0){
extendCurve -cos 0 -ch 1 -em 0 -et 0 -d $ArcLengthAdd  -s 0 -jn true -rmk true -rpo on $each ;
}
}
}

proc float TotalArcLength(){
string $Objs[] =`ls -sl`;
float $ArcLengths = 0.0;
for($each in $Objs){
$ArcLengths += `arclen $each`;
}
return $ArcLengths;
}

proc string makeCurvePointDirectionLength(float $Length, float $Direction[], float $posA[]){
float $MultDir[] = multiplyFloat($Length,  $Direction);
float $FloatDirectionNormalA[] = AddFloats($posA, $MultDir);
string $CurveBetween;
$CurveBetween = curve2points($posA,  $FloatDirectionNormalA);
return $CurveBetween;
}

proc vector[] PointArray(string $ObjectList[]){

float $pointAZ1[];
vector $VecArray[];
int $XiV = 0;
for ($each in $ObjectList){
if (catch($pointAZ1 = `pointPosition -w ($each)`)){
$pointAZ1 = `xform -q -ws - rp ($each)`;
} 
$VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
$XiV++;
}
return $VecArray;
}





proc float [] HightsOfIsoscelesTriangle(float $SideA, float $SideB, float $SideC){

float $Pi = 3.1415926535;
float $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN = $AngleNPi;
print $AngleN;
print "//";

float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
float $ArcangleC2 = $ArcangleC*2.0;
print $ArcangleC2;
float $AngleNB = 180.00 -($ArcangleC2 + $AngleNPi) ;
float $Angle_a = $ArcangleC2; 
float $Angle_b = $AngleN; 
float $Angle_c = $AngleNB;

float $AngleN2 = 180.0 -($Angle_b + $Angle_c) ;
//Two are the same//
float $Angle_A = $AngleN2; 
float $Angle_B = $AngleN; 
float $Angle_C = $AngleN;
//Angle of Right Tri in Isoceles
float $AngleOfRightAndA = (180.000 -($AngleN2 +90.000));
float $AngleOfRightA = ($AngleOfRightAndA/180.000)*$Pi;
float $AngleN2R = ($AngleN2/180.0000)*$Pi; 
float $HightfromB = sqrt ( ((`pow $SideA 2.000`) + (`pow $SideC 2.000`)) - ((2.000*$SideA*$SideC)*(`cos($AngleN2R+$AngleN2R )`)) )/2.000 ;
float $AngleOfRightA = ($AngleOfRightAndA/180.0000)*$Pi;
float $HightfromC = sqrt ( ((`pow $SideA 2.000`) + (`pow $SideC 2.000`)) - ((2.000*$SideA*$SideC)*(`cos ($AngleOfRightA*2.000 )`)) )/2.000 ;
float $HightsCandB[] = { $HightfromC, $HightfromB};
return $HightsCandB;

}

////////////////////////////////////////
proc float [] AnglesofTriangle(float $SideA, float $SideB, float $SideC){

float $Pi = 3.1415926535;
float $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN = $AngleNPi;

float $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN = $AngleNPi;

float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
float $ArcangleC2 = $ArcangleC*2.0;
float $AngleNB = 180.00 -($ArcangleC2 + $AngleNPi) ;
float $Angle_a = $ArcangleC2; 
float $Angle_b = $AngleN; 
float $Angle_c = $AngleNB;
float $Add = $Angle_a + $Angle_b + $Angle_c;
float $Angle_ABC[] = {$Angle_a, $Angle_b, $Angle_c} ;
return $Angle_ABC;
}
////////////////////////////////////////
//
/*
// AngleOfTriangle
string $ObjsCurve[] =`ls -sl`;
float $allcurveLengths[] = ArcLengthArray($ObjsCurve);
float $SideA = $allcurveLengths[0];
float $SideB = $allcurveLengths[1];
float $SideC = $allcurveLengths[2];

 AnglesofTriangle($SideA, $SideB, $SideC);
float $A = AnglesofTriangle($SideC, $SideA, $SideB);
 AnglesofTriangle($SideB, $SideC, $SideA);


float $A = $allcurveLengths*$allcurveLengths;

rotate -r -os 0 -75.605364 0 ;

*/

proc float [] ArcLengthArray(string $Objs[]){
float $ArcLengths[];
for($each in $Objs){
$ArcLengths[`size($ArcLengths)`]= `arclen $each`;
}
return $ArcLengths;
}

//CircleFromCurveZYX 1 0 0;

	proc CircleFromCurveT(){
string $StraitCurve[] = `ls -sl`;
ResetTransEachSL;
float $ArcLengthOne = `arclen $StraitCurve[0]`;
$ArcLengthOne = $ArcLengthOne/2;
float $CurvPos[] = `xform -q -ws -rp $StraitCurve[0]`;
float $tangent[] = `pointOnCurve -t -pr 0.5 $StraitCurve[0]`;
$tangent = `unit <<$tangent[0], $tangent[1], $tangent[2]>>`;
string $circles = Circles_Direction($CurvPos, $tangent, $ArcLengthOne);
ResetTransEachSL;
}

/*
string $StraitCurve[] = `ls -sl`;
float $ArcLengthOne = `arclen $StraitCurve[0]`;
float $ArcLengthRadius = $ArcLengthOne/2;
float $ArcLenRadiusSDi = (`hypot $ArcLengthRadius $ArcLengthRadius`)*2;
float $ArcLenRadiusSRa = (`hypot $ArcLengthRadius $ArcLengthRadius`);

ResetTransEachSL;
vector $directionABs[];
vector $PosABs[];
float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
float $R1=$ObjsCircles[0];
float $R2=$ObjsCircles[1];

float $ArcLenRadiusSRa1 = (`hypot $R1 $R1`);
float $ArcLenRadiusSDi1 = $ArcLenRadiusSRa1 *2;

*/

//CircleFromCurveRadiusZYX 1 0 0;

	proc CircleFromCurveRadiusZYX(int $X, int $Y, int $Z ){
string $StraitCurve[] = `ls -sl`;
ResetTransEachSL;
float $ArcLengthOne = `arclen $StraitCurve[0]`;
float $CurvPos[] = `xform -q -ws -rp $StraitCurve[0]`;
float $t[3], $n[3];
  vector $tan, $norm, $bi;
   //$t $n are just directions....
    $t = `pointOnCurve -ch off -pr 0.5 -nt $StraitCurve[0]`;
    $n = `pointOnCurve -ch off -pr 0.5 -nn $StraitCurve[0]`;
    // Maya promises normalized tangent and normal,
    // but they really aren't.    
    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
//## Note the int One 1 inthe middle...
    $norm = `unit << $X, $Y, $Z >>`;    
    // Calculate the binormal.   
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
                 << ($norm.x), ($norm.y), ($norm.z) >>`;
    $bi = `unit $bi`;
string $circles = Circles_Direction($CurvPos,$bi, $ArcLengthOne);
ResetTransEachSL;
}


	proc CircleFromCurveN(int $X, int $Y, int $Z ){
string $StraitCurve[] = `ls -sl`;
ResetTransEachSL;
float $ArcLengthOne = `arclen $StraitCurve[0]`;
$ArcLengthOne = $ArcLengthOne/2;
float $CurvPos[] = `xform -q -ws -rp $StraitCurve[0]`;
float $t[3], $n[3];
  vector $tan, $norm, $bi;

   //$t $n are just directions....
    $t = `pointOnCurve -ch off -pr 0.5 -nt $StraitCurve[0]`;
    $n = `pointOnCurve -ch off -pr 0.5 -nn $StraitCurve[0]`;
    // Maya promises normalized tangent and normal,
    // but they really aren't.    
    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
//## Note the int One 1 inthe middle...
    $norm = `unit << $n[0], $n[0], $n[0] >>`;    
    // Calculate the binormal.   
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
                 << ($norm.x), ($norm.y), ($norm.z) >>`;
    $bi = `unit $bi`;
string $circles = Circles_Direction($CurvPos,$bi, $ArcLengthOne);
ResetTransEachSL;
}





proc string [] SteinerChain(float $RAa, float $RBb){

//
//float $RA = 22.0;
//float $RB = 15.680;

float $pi = 3.1415926535;
float $Pi = 3.1415926535;
float $RA;
float $RB;

string $circleA[];
string $circleB[];
string $circles[];


if(!( $RAa==$RBb)){
if( $RAa<$RBb){
$RA = $RBb;
$RB = $RAa;}else{ $RA = $RAa; $RB =  $RBb;}

//float $RA = 22.0;
//float $RB = 15.68;



$circleA = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RA -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
$circleB = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RB -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
float $R2 = $RA;
float $R1 = $RB;
float $DCircle = (($R2 - $R1)/2.0) + $R1 ;
float $Rii = (($R2 - $R1)/2.0);

float $SideA = $RB + $Rii;
float $SideB = $Rii*2;

//GOT it for SURE
//HightsOfIsoscelesTriangle($SideA, $SideB, $SideA)
float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
float $ArcangleC2 = $ArcangleC*2.0;

float $Aii =  (`asin ($RB/($RB + $Rii))`);
//float $Ni = $pi/$Aii;
//  $Ni = (rad_to_deg($Aii)) ;


float $number3 = 360.0/$ArcangleC2; 

float $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
float $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
float $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );

float $NofCirclesa =  (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
float $NofCirclesb =  ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
float $NofCirclesc =   ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);

//float $subtract = ($NofCirclesa -($NofCirclesb + $NofCirclesc))*4;
//float $subtract = $NofCirclesB - $NofCirclesA;
//float $subtract = ($subtract + $NofCirclesC)/2;
//float $subtractA = (($NofCirclesB - $NofCirclesA)+ $NofCirclesC)/2;
//float $subtractB = ($NofCirclesA - $NofCirclesC+$NofCirclesB)/2;
//float $number3 = 360/$NofCirclesC; 
//
//float $Ni = (rad_to_deg($subtract)) ;
//float $Ni = $pi/ $subtract;
//float $number3 = 360/$Ni; 
//$number3 = $subtract;

//float $subtract = ($NofCirclesA - $NofCirclesC+$NofCirclesB)/2;
/*
float $dec = 1; 
 float $val= $subtract*0.1;
  	$sign = `sign $val`;
  	float $dec = `pow 10 $dec`;
  	$val = (int) (($val + $sign*5/($dec*10))  * $dec);
  	$val = ($val / $dec);
	$val = $val*10;
$subtract = $val;
//float $subtract = ($NofCirclesA - $NofCirclesC+$NofCirclesB)/2;
*/
int $NumberCs = $number3;
int $n = $NumberCs;
float $len = $DCircle;
float $r = $DCircle;
	float $x[] = createRegularPolygonX( $n, $r ) ;
	float $y[] = createRegularPolygonY( $n, $r ) ;
	// create the n-sided polygon. 
string $circlesC[];
	float $z = 0.0 ;
	int $i ;
	for( $i = 0 ; $i < $n ; $i++ ) {
$circlesC = `circle -c $x[$i] $y[$i] $z -nr 0 0 1 -sw 360 -r $Rii -d 3 -ut 0 -tol 0.001 -s 16 -ch 1`;

$circles[`size($circles)`] = $circlesC[0];
makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $circles[0];
xform -cp $circles[0];
//rotate -r -os 0 0 45 $circles[0];
//aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "scene" $circleB[0] $circles[0];
	
	}


//$circles[`size($circles)`] = $circleA[0];
//$circles[`size($circles)`] = $circleB[0];

select -r $circleA $circleB $circles ;
//select -r $circles ;
return $circles;
}
}


proc string[] CycleNumberString(string  $singleStringItemC[]){
int $SizeOfArray;
$SizeOfArray = size($singleStringItemC) -1;
string $last[0] = {$singleStringItemC [$SizeOfArray]};
string $first[0] = {$singleStringItemC[0]};
  stringArrayRemoveAtIndex(0,  $singleStringItemC);
  appendStringArray($singleStringItemC, $first,  1);
return $singleStringItemC; 
}


/*

string $Circ[] = SteinerChain(22.0, 17.00);

int $Sc = (`size($Circ)`);
int $ScH =($Sc/2)-3;
int $ix = 0;
int $ix2 = 1;
while($ix < $Sc){
select -r $Circ[0] $Circ[$ScH];
$Circ = CycleNumberString($Circ);
TangentCircles;
if($ix2==($Sc-1)){$ix2=-1;}
 $ix++;
$ix2++;
}

for ($each in $circles){
select -r $circleB ;
select -tgl $each;
TangentCircles;}



float $As = 22.0;
float $Bs = 0.05;
int $c;
int $S = 340;
int $sizeN ;
int $sizeNa ;
string $circ[];
string $circL[];
clear $circL;
  for($c = 1; $c <= $S; $c++ ){
$sizeNa = $sizeN;
if(`size( $circL)`>0){ delete $circL; clear $circL;
}
 $circ =  SteinerChain($As, $Bs) ;
$circL = $circ;
$sizeN = `size( $circ)`;
PAUSE; 

$As += 0.00;
$Bs += 0.00521;

}

print $Bs;
  proc float round(float $val,float $dec){
int $Xn = 5;
//float $dec = 0;
//float $val = 42.02;
int $Dn = $dec;
int $Dn2 = $dec;
float $divideAs = $val/2;
float $divideA = $val/5;
float $divideB = $val/10;
float $divideC = $val/100;
float $divideD = $val/1000;
if ($divideAs < 1) { $Xn = 1; $Dn = 2; $Dn2 = 1; }
if (($divideAs > 1) && ($divideA < 1)) { $Xn = 1; $Dn = 2; $Dn2 = 1;}
if (($divideA > 1) && ($divideB < 1)) { $Xn = 5; }
if (($divideB > 1) && ($divideC < 1)) { $Xn = 10; }
if (($divideC > 1) && ($divideD < 1)) { $Xn = 50; }
//print ($Xn + "\n");
$dec = $Dn;
$sign = `sign $val`;
  	float $dec = `pow 10 $dec`;
  	$val = (int) (($val + $sign*5/($dec*10)) * $dec);
  	$val = ($val / $dec);

float $divide = $val/$Xn;
 float $val2 = $divide;
float $dec2 = $Dn2;
$sign2 = `sign $val2`;
  	float $dec2 = `pow 10 $dec2`;
  	$val2 = (int) (($val2 + $sign*5/($dec2*10)) * $dec2);
  	$val2 = ($val2 / $dec2);
float $times = $val2 * $Xn;

  	return $times;
  }
  


string $Selection[];
$Selection = `ls -sl`;

for ($each in $Selection){

select -r $each;

  
  float $step = 700;  
  $curve = "curve -d 1";
  string $crShape[] = `listRelatives -s`;
  float $oldvalues[] = `pointOnCurve -top 1 -pr 0 $crShape[0]`;
  $oldvalues = {round($oldvalues[0],0),round($oldvalues[1],0),round($oldvalues[2],0)};
  for($a = 1; $a <= $step;$a++){
  	$t =  $a/$step;
  	float $values[] = `pointOnCurve -top 1 -pr $t $crShape[0]`;
  	$values = {round($values[0],0),round($values[1],0),round($values[2],0)};
  	if($values[0] != $oldvalues[0] && $values[2] != $oldvalues[2]){
  		$curve += " -p "+$oldvalues[0]+" "+$values[1]+" "+$values[2];
  	}	
  	$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
  	$oldvalues = $values;
  }
  eval($curve);
select -r $curve;

select -cl  ;
}


*/

proc float[] createRegularPolygonY( int $n, float $r )
{
	int $i ;
	float $x[] ;
	float $angle = 360.0 / $n ;

	for( $i = 0 ; $i < $n ; $i++ ) {
		float $a = $i * $angle ;	
		$x[$i] =  $r * cos(deg_to_rad($a)) ;
	}
	return $x ;	
}

proc float[] createRegularPolygonX( int $n,float $r )
{
	int $i ;
	float $x[] ;
	float $angle = 360.0 / $n ;
	for( $i = 0 ; $i < $n ; $i++ ) {
		float $a = $i * $angle ;	
		$x[$i] =  $r * sin(deg_to_rad($a)) ;
	}
	return $x ;	
}



/*

proc CurvatureUtility(float $curveM, $NumberofSteps ){

//


TangentCirclesAtand("sin");
TangentCirclesAtand("cos");
TangentCirclesAtand("tan");
TangentCirclesAtand("tand");
TangentCirclesAtand("atan");
TangentCirclesAtand("asin");
TangentCirclesAtand("acos");
TangentCirclesAtand("atand");
TangentCirclesAtand("asind");
TangentCirclesAtand("acosd");

string $failedMathCommand = "";

int $trigger = 0;


print ($MathFunc[0] +" "+ $MathFunc[1] +"\n");




string $MathFunc[] =  {"sin", "cos", "tan", "tand", "atan", "asin", "acos", "atand", "asind", "acosd"};

int $trigger = 0;
int $ColorLayer = 1;
string $failedMathCommand = "";
for ($eachA in $MathFunc){
for ($eachB in $MathFunc){
print ($eachA +" "+ $eachB +"\n");
string $MathCommandA = $eachA;
string $MathCommandB = $eachB;

//}
//}


//string $MathCommandA = $MathFunc[0];
//string $MathCommandB = $MathFunc[1];

float $r=2;
float $n = 10;

	float $step = 60;  
	$curve = "curve -d 3";

	float $x[] ;
       float $y[] ;
	float $angle = 360.0 / $n ;

$trigger = 0;
int $Par = 0;
float $a1;
float $iiZ =0.0;
int $i = 0;
float $directStep = 0.25;
float $G;

float $XYa;
float $XYb;

  for($a1 = 1; $a1 <= $step; $a1++ ){
  	$t =  $a1/$step;
 	$Par = ($a1/$step);
  	

	float $a2 = $i * $angle ;	


	$a2 = deg_to_rad($a2);
float $XYa;
float $XYb;
string  $stringCommandA = ( $MathCommandA +" "+ $a2 );
string  $stringCommandB = ( $MathCommandB +" "+ $a2 );
  if ( catch ( eval($stringCommandA) )  ) {
  $failedMathCommand += $MathCommandA;
   $trigger = 1; 
break;
  }   

if ( catch ( eval($stringCommandB) )  ) {
  $failedMathCommand += $MathCommandB;
   $trigger = 1; 
break;
  }

float $XYa = eval($stringCommandA);	
float $XYb = eval($stringCommandB);

$x[$i] = $r * $XYa ;
$y[$i] = $r * $XYb ;
		

	// $x[$i] =  $r * cos(deg_to_rad($a2)) ;
	// $y[$i] =  $r * sin(deg_to_rad($a2)) ;
if($iiZ>0){
 $G = `gamma $iiZ`;
}else{$G = $iiZ;}
float $values[] = { $x[$i], $y[$i], $G};
$i++;
 $iiZ += $directStep;
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];


}

///////
if($trigger==0){
string $Newcurvez = `eval($curve)`;
string $LayyerName = ($MathCommandA+"_"+$MathCommandB);
string $layer = `createDisplayLayer -name $LayyerName -empty`;
 setAttr ($layer+".color") $ColorLayer;
editDisplayLayerMembers -noRecurse $layer $Newcurvez;
$ColorLayer++;
}


}
}

print $failedMathCommand;



//float $valuesZYPlane[] = {0.0, $values[1], $values[2]};
//float $valuesZXPlane[] = {$values[0], 0.0, $values[2]};
//float $valuesZ[] = {0.0, 0.0, $values[2]};
//float $valuesX[] = {$values[0], 0.0, 0.0};



rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $Newcurvez;
float $numLength = (`arclen $Newcurvez`) +1; 
int $StepZNum = $numLength;
delete $paramlocatorpointOnCurvex $spaceLocatorB; 
//delete $curves;
///////////////////////////////////////////////// //////
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s $StepZNum -d 3 -tol 0.001  $Newcurvez;


//string $Newcurve[] = {$Newcurvez};
//rename $Newcurve $curves;  
//$Newcurve = {$curves[0]};
//return $Newcurve; 
}








proc MirrorANDrename(string $objectA[]){

ResetTranslation($objectA);
	float $posA[];	
	$posA = `xform -q -os -translation   $objectA[0]`;
xform -ws -pivots 0 $posA[1] $posA[2];
duplicate -rr -renameChildren $objectA; scale -r  -1 1 1; 
string $objectDup[] = `ls -sl`;
int $ifCurvetype = `ISobjectSelectedTypeCurve`;

string $firstcurveRelativesA1[] = `listRelatives  -shapes $objectDup`;

int $numa  = `match "[0-9]+" $objectA[0]`;
string $nameAZ;
$nameAZ = `match "[a-zA-Z]+" $objectA[0]`;

string $renamez = ("A" + $nameAZ + $numa + "A");
string $renameShape = ("A" + $nameAZ + "Shape" +  $numa + "A");
string $renameitzA[];
select -r $objectDup[0];
$renameitzA[0] = `rename $objectDup[0] $renamez`;
 makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;
ResetTranslation($renameitzA);

if ($ifCurvetype == 1){
string $ArcLOCZ[];
string $selectedCurve[];
clear $selectedCurve;
$selectedCurve = $objectA;
string $firstcurveRelatives1[];
$firstcurveRelatives1 = `listRelatives -shapes   $selectedCurve`;
string $firstcurveConnectionsz2[];
$firstcurveConnectionsz2 = ` listHistory -future   false -pruneDagObjects true   $firstcurveRelatives1`;
int $sizeOfConnections = `size ($firstcurveConnectionsz2)`;
if ($sizeOfConnections > 0){
string $ArcCURVEnode =   "makeThreePointCircularArc*";
int $IFArcCurveIStrue = stringArrayGmatch  ($ArcCURVEnode, $firstcurveConnectionsz2);

if ($IFArcCurveIStrue == 0){

string $renameitzA[];
string $renameitzB[];
//$renameitzA[0] = `rename $objectDup[0]  $renamez`;
$renameitzB[0] = `rename $firstcurveRelativesA1 [0] $renameShape`;

 makeIdentity -apply true -t 1 -r 1 -s 1 -n 0  $renameitzA;
ResetTranslation($renameitzA);

}else if ($IFArcCurveIStrue == 1){ 
	string $ArcCURVEnodeZ[];
	string $firstcurveRelatives3[];
	$ArcCURVEnodeZ = stringArrayGmatchToArray($ArcCURVEnode, $firstcurveConnectionsz2);
	$firstcurveRelatives3 = `listHistory -  future 0 -pruneDagObjects 0 $ArcCURVEnodeZ`;
	string $ArcCURVEnodeLOC = "ArcLocator*";

int $IFArcLOCIStrue = stringArrayGmatch  ($ArcCURVEnodeLOC, $firstcurveRelatives3);

if ($IFArcLOCIStrue == 1){ 
	$ArcLOCZ = stringArrayGmatchToArray  ($ArcCURVEnodeLOC, $firstcurveRelatives3);
float $getXLoc = `getAttr ($ArcLOCZ[0]   +".translateX")`;
float $MirrorXLoc = $getXLoc * -1; 

string $objectDupLocs[] = `duplicate -rr   $ArcLOCZ[0]`; 
select -r $objectDupLocs;
group -w; 
xform -os -piv 0 0 0;

scale -r -1 1 1;
//string $objectLOCDup[] = `listRelatives   $objectDup`; 
select -r $objectDupLocs;
 //capture trans, rot, and scale of object to   match
        $outmmesh = ($ArcLOCZ[0] + ".translate"); 
        $inmmesh = ($objectDupLocs[0] +   ".translate");
{
$connect = `connectAttr -f $outmmesh $inmmesh`;
}
select -r $ArcLOCZ;
string $objectDupLocs2[] = `duplicate -rr   $ArcLOCZ[0]`; 
setAttr ($objectDupLocs2[0] +".translateX")   $MirrorXLoc;
parentConstraint -mo -weight 1 $objectDupLocs[0]   $objectDupLocs2[0];
select -r $objectDupLocs2;
Make_Middle_of_Curve_ParamlocatorZMirror  ($renameitzA, $objectDupLocs2);
select -r $objectA ;
}
}
}
}

}








//returns the first single Item array if string matches that item  
//EX. string "red"  match array { "bluered", "blueblue", "greenblue" } returns "bluered" as a string array[].

//string $testGmatch = "red";  string $matcharrayTest[] = { "red", "blueblue", "greenblue" };
//string $matchedinArray[] = stringArrayGmatchToArray($testGmatch, $matcharrayTest);
// Result: red // 

global proc string[] stringArrayGmatchToArray(string $item, string $list[]){
	int $result = false;	
	string $listItem;
string $MatchedItem[];	
	for ($listItem in $list) {
		if ( `gmatch $listItem $item` == 1){
		$result = true;
if ($result == true ){ $MatchedItem = {$listItem};}
			break;	}
	}	
	return $MatchedItem;
}

/////////////

*/
