// ##REplaced zenReturnFirstStringItem with FirstStringItem##//////////////////////////

/////////////////////////////////////////////////
triangle;
DVY_HelixProfile;
DVY_ChainSet;
DVY_SprocketBuild;
DVY_GearBuild;
DVY_ChainBuild

string $arrayZZ[] = `ls -sl`; 
size($arrayZZ);

float $Pi = 3.141593;
float $PartArc = (($Pi) / ((12)/2));
float $degree = `rad_to_deg $PartArc`;
float $numbers = 360 / $degree;
float 


proc CreatePolyFromFloats(float $BoxPointsX[]){

float $bbox[] = $BoxPointsX;
float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox[2]};
float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox[5]};
float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox[2]};
float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox[5]};
///
vector $BoxPointZ[];
$BoxPointZ[0] = <<$bbox[0], $bbox[4], $bbox[2]>>;
$BoxPointZ[1] = <<$bbox[3], $bbox[4], $bbox[2]>>;
$BoxPointZ[2] = <<$bbox[3], $bbox[4], $bbox[5]>>;
$BoxPointZ[3] = <<$bbox[0], $bbox[4], $bbox[5]>>;

int $sizeVecBox = size($BoxPointZ);
string $polyZ = "polyCreateFacet";
int $ZiI = 0;
progressWindow -ii true -title "Working" -status "Moving Verts" -max (size($BoxPointZ)) -progress 0;
while ($ZiI < $sizeVecBox){
	float $values[] = $BoxPointZ[$ZiI];
$polyZ += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
$ZiI++;
	progressWindow -e -s 1;
				if(`progressWindow -q -ic`)
				{
					progressWindow -endProgress;
					error "User Interupt.";
				}


}
print $polyZ;
string $NewPolyZz[0] = `eval($polyZ)`;
progressWindow -endProgress;
select -r $NewPolyZz;
ResetTranslation($NewPolyZz);
}


//////////////////////////////////////////////////////////////////////////////////


global proc float GetDistancePointPositionFLOAT(string $objectFirst, string $objectSecond){
float $pointAZ1[]; float $pointAZ2[];
	$pointAZ1 = `pointPosition -w ($objectFirst)`;
	$pointAZ2 = `pointPosition -w ($objectSecond)`;
$dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
$dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2; 
float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
return $distanceA2; 
}

////////////////////////


string $FourPointsNurbSurfaceA = ( $nurbSurfaceSelectionZ[0] +".uv[0.9][0.5]");
string $FourPointsNurbSurfaceB = ( $nurbSurfaceSelectionZ[0] +".uv[0.1][0.5]");
string $FourPointsNurbSurfaceC = ( $nurbSurfaceSelectionZ[0] +".uv[0.5][0.9]");
string $FourPointsNurbSurfaceD = ( $nurbSurfaceSelectionZ[0] +".uv[0.5][0.1]");

string $FourPointsNurbSurfaceE = ( $nurbSurfaceSelectionZ[0] +".uv[0.9][0.9]");
string $FourPointsNurbSurfaceF = ( $nurbSurfaceSelectionZ[0] +".uv[0.1][0.1]");
string $FourPointsNurbSurfaceG = ( $nurbSurfaceSelectionZ[0] +".uv[0.1][0.9]");
string $FourPointsNurbSurfaceH = ( $nurbSurfaceSelectionZ[0] +".uv[0.9][0.1]");



//////////////////////////////////////////////

whatIs measure -s

//CORNER Verteces is $diffEdge //Good Starting point
/////////////////////////////////////////////////////////

global proc CreateCircleINpolyFaces(){
string $FirstPolyFaceslist[] = `ls -sl`;
string $bufferListShape[];
$numTokensA = `tokenize $FirstPolyFaceslist[0] "." $bufferListShape`;
print  $bufferListShape;
string $PolyName[0] = {$bufferListShape[0]};
string $nurbSurfaceSelectionC  = `ConvertPolyFacesIntoNurbSurface`;
print $nurbSurfaceSelectionC ;
string $FirstPolyEdgelist[] = `ls -sl`;

int $CurveEPzCount[];
int $Xiii = 0;
string $CurveEPzCountS[];
for ($eachEP in $FirstPolyEdgelist){
	string $CurveSelection[] = `ls -fl ($eachEP+".ep[0:*]")`; 
	 $CurveEPzCountS[$Xiii] = size($CurveSelection);
$Xiii++;
}

performSelectNurbsBorder 0;
	string $NurbsBorderSelection[] = `ls -sl -fl`; 
	 int $NurbsBorderCv = size($NurbsBorderSelection) -3;

print  $CurveEPzCountS;
  string $CurveEPNumbersList[] = stringArrayRemoveDuplicates( $CurveEPzCountS);
sort $CurveEPNumbersList;

int $SpanX = $CurveEPNumbersList[0];
int $SpanZ = $CurveEPNumbersList[1];
int $ifEqual = 0;
if ($SpanX == $SpanZ ){ $ifEqual = 1;}

string $ListofItemConvert[] = `stringToStringArray $nurbSurfaceSelectionC " "`;
//LOC
string $CLocators[] = { $ListofItemConvert[0], $ListofItemConvert[1], $ListofItemConvert[2], $ListofItemConvert[3]};
//SURF
string $nurbSurfaceSelectionZ[] =  {$ListofItemConvert[4]} ;
string $MiddleNurbSurface = ( $nurbSurfaceSelectionZ[0] +".uv[0.5][0.5]");
float $middlePoint[] = `pointPosition -w $MiddleNurbSurface`;
string $FourPointsNurbSurA = ( $nurbSurfaceSelectionZ[0] +".uv[0.9][0.5]");
string $FourPointsNurbSurB = ( $nurbSurfaceSelectionZ[0] +".uv[0.1][0.5]");
string $FourPointsNurbSurC = ( $nurbSurfaceSelectionZ[0] +".uv[0.5][0.9]");
string $FourPointsNurbSurD = ( $nurbSurfaceSelectionZ[0] +".uv[0.5][0.1]");
float $distancePointZ[] = {GetDistancePointPositionFLOAT($FourPointsNurbSurA, $FourPointsNurbSurB), GetDistancePointPositionFLOAT($FourPointsNurbSurC, $FourPointsNurbSurD)};
sort $distancePointZ;
float $CircleDZ = $distancePointZ[0] / 3.75;
string $circleshape[];
clear $circleshape;
string $circleshape[] = `circle -c 0 0 0 -nr 0 1 0 -sw 360 -r $CircleDZ -d 3 -ut 0 -tol 0.001 -s 8 -ch 1`;
move -ws $middlePoint[0] $middlePoint[1] $middlePoint[2] $circleshape;
normalConstraint -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $nurbSurfaceSelectionZ $circleshape;
string $myCurve =  $circleshape[0];
string $allcurvesB[];
clear $allcurvesB;
for($eachLOC in $CLocators){
      $myCPOC = `createNode closestPointOnCurve`;
      connectAttr ($myCurve+".worldSpace") ($myCPOC+".inCurve");
//delete THIS when done/////////////
      $spaceResultA = `spaceLocator -p 0 0 0 -n LocatorC`; 
      $LOCB = $spaceResultA[0];
      connectAttr ($myCPOC+".position") ($LOCB+".translate");
      $LocA = $eachLOC;
      connectAttr ($LocA+".translate") ($myCPOC+".inPosition");
float $valuesZ1[] = getAttr ($myCPOC+".position");
float $valuesZ2[];
//DEM0MODE ZZZ
select -r $spaceResultA;
playButtonStepForward;
//DEM0MODE ZZZ
$valuesZ2 = `pointPosition -w ($LocA)`;	
string $curveBetween[] = MakeCurveBetweenFloats($valuesZ1, $valuesZ2);
//DEM0MODE ZZZ
select -r $curveBetween;
playButtonStepForward;
//DEM0MODE ZZZ
appendStringArray($allcurvesB, $curveBetween,1);
delete $LOCB $myCPOC;
}
///////////////////////////////////

string $ProjecCurvs = "";
for($eachCurvB in $allcurvesB){
string $proJCurv[] = `projectCurve -ch true -rn false -un  true  -tol 0.001 $eachCurvB $nurbSurfaceSelectionZ `;
	$ProjecCurvs += $proJCurv[1]+"\+"+" "; }

    string $ProjecCurvresultA = substituteAllString($ProjecCurvs, "jectC", "jectionC");
print $ProjecCurvresultA;
string $ProjecCurvsB = $ProjecCurvresultA;
string $ProjecCurvresultB = substituteAllString($ProjecCurvsB, "+", "_Shape1");  
print $ProjecCurvresultB;    
string $ListProjecCurv[] = `stringToStringArray $ProjecCurvresultB " "`;

//## End of Corner Curves Start of Circle Projection //

string $proJCurvA[] = `projectCurve -ch true -rn false -un  true  -tol 0.001 $circleshape[0] $nurbSurfaceSelectionZ `;
string $ProjecCurvsA = "";
$ProjecCurvsA += $proJCurvA[1]+"\+"+" ";
    string $ProjecCurvresultC = substituteAllString($ProjecCurvsA, "jectC", "jectionC");
string $ProjecCurvsD = $ProjecCurvresultC;
    string $ProjecCurvresultE = substituteAllString($ProjecCurvsD, "+", "_Shape1");
string $ListProjecCurvF[] = `stringToStringArray $ProjecCurvresultE " "`;

print $ProjecCurvsD ;
print $ListProjecCurvF;

string $boundZ1[];

string $thelist[] = { $ListProjecCurv[0], $ListProjecCurv[1], $ListProjecCurv[2], $ListProjecCurv[3], $ListProjecCurvF[0] };
//DEMO Mode SELECTION BELOW

for($eachCurvPL in $thelist){
select -r $eachCurvPL;
playButtonStepForward;
select -cl  ;
}

string $surfaceA[] = `trim -ch on -o on -rpo off -lu 0.1 -lv 0.5 $nurbSurfaceSelectionZ[0] $thelist[0] $thelist[0] $thelist[1] $thelist[2] $thelist[3] $thelist[4]`;
string $surfaceB[] = `trim -ch on -o on -rpo off -lu 0.5 -lv 0.1 $nurbSurfaceSelectionZ[0] $thelist[0] $thelist[0] $thelist[1] $thelist[2] $thelist[3] $thelist[4]`;
string $surfaceC[] = `trim -ch on -o on -rpo off -lu 0.9 -lv 0.5 $nurbSurfaceSelectionZ[0] $thelist[0] $thelist[0] $thelist[1] $thelist[2] $thelist[3] $thelist[4]`;
string $surfaceD[] = `trim -ch on -o on -rpo off -lu 0.5 -lv 0.9 $nurbSurfaceSelectionZ[0] $thelist[0] $thelist[0] $thelist[1] $thelist[2] $thelist[3] $thelist[4]`;

string $AllsurfaceA_D[] = {$surfaceA[0], $surfaceB[0], $surfaceC[0], $surfaceD[0]};

select -r $surfaceA[0];
select -r $surfaceC[0];

performSelectNurbsBorder 0;
	string $NurbsBorderSelection[] = `ls -sl -fl`; select -cl  ;
	 int $NurbsBorderCvA = size($NurbsBorderSelection) -3;

select -r $surfaceC[0];
performSelectNurbsBorder 0;
	string $NurbsBorderSelection[] = `ls -sl -fl`; select -cl  ;
	 int $NurbsBorderCvC = size($NurbsBorderSelection) -3;

select -r $surfaceB[0];
performSelectNurbsBorder 0;
	string $NurbsBorderSelection[] = `ls -sl -fl`; select -cl  ;
	 int $NurbsBorderCvB = size($NurbsBorderSelection) -3;
select -r $surfaceD[0];
performSelectNurbsBorder 0;
	string $NurbsBorderSelection[] = `ls -sl -fl`; select -cl  ;
	 int $NurbsBorderCvD = size($NurbsBorderSelection) -3;



string $trimedSurfA[] = `rebuildSurface -ch 1 -rpo 1 -rt 6 -end 1 -kr 2 -kcp 0 -kc 0 -su 3 -du 0 -sv $NurbsBorderCvA -dv 0 -tol 0.001 -fr 0  -dir 2 $surfaceA[0]`;
string $trimedSurfB[] = `rebuildSurface -ch 1 -rpo 1 -rt 6 -end 1 -kr 2 -kcp 0 -kc 0 -su 3 -du 0 -sv $NurbsBorderCvB -dv 0 -tol 0.001 -fr 0  -dir 2 $surfaceB[0]`;
string $trimedSurfC[] = `rebuildSurface -ch 1 -rpo 1 -rt 6 -end 1 -kr 2 -kcp 0 -kc 0 -su 3 -du 0 -sv $NurbsBorderCvC -dv 0 -tol 0.001 -fr 0  -dir 2 $surfaceC[0]`; 
string $trimedSurfD[] = `rebuildSurface -ch 1 -rpo 1 -rt 6 -end 1 -kr 2 -kcp 0 -kc 0 -su 3 -du 0 -sv $NurbsBorderCvD -dv 0 -tol 0.001 -fr 0  -dir 2 $surfaceD[0]`;

print $trimedSurfA; 

string $finalSurface[] = `makeSingleSurface -mnd 1  -ch 1 -f 2 -pt 1 -pc 58 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.01 -es 0 -ntr 0 -stitchTolerance 0.6099 $trimedSurfA[0] $trimedSurfB[0] $trimedSurfC[0] $trimedSurfD[0]`;

select -r  $thelist; playButtonStepForward; playButtonStepForward;
select -r  $CLocators; playButtonStepForward; playButtonStepForward;
select -r  $nurbSurfaceSelectionZ; playButtonStepForward; playButtonStepForward;
select -r  $allcurvesB; playButtonStepForward; playButtonStepForward;
select -r $AllsurfaceA_D; playButtonStepForward; playButtonStepForward;
select -r  $finalSurface[0]; playButtonStepForward; playButtonStepForward;
delete -ch $finalSurface[0] $thelist $nurbSurfaceSelectionZ $allcurvesB;
delete $allcurvesB;
delete $thelist;
delete $CLocators $nurbSurfaceSelectionZ ;
delete -ch $AllsurfaceA_D;
delete $AllsurfaceA_D;
delete $FirstPolyEdgelist;

print $finalSurface;
print $PolyName;
print $circleshape;

}
///////////////////////END



 proc string ConvertPolyFacesIntoNurbSurface(){

string $PolyFaceslist[] = `ls -sl`;
string $NewPolyFaces[] = ` polyChipOff -ch 1 -kft 1 -dup 0 -off 0 $PolyFaceslist`;
print $NewPolyFaces;
string $HistoryConnections[] = ` listHistory -future true -pruneDagObjects false $NewPolyFaces`;
string $polySep[] = `polySeparate -rs 1 -ch 0 $HistoryConnections[1]`;
select -r $polySep[1];
string $PolygonNew[0] = {$polySep[1]};
parent -w $PolygonNew;
select -r $PolygonNew;
print $PolygonNew ;
string $PolyFaces = ( $PolygonNew[0] +".f[*]");
string $AllPolyFaces[] = `ls -fl $PolyFaces`;
string $AllPolyFaces2[] = `ls $PolyFaces`;

string $diffEdgeVertz[] = GetEdgeVertex($PolygonNew);
string $ReturnObjects = "";
float $valuesP[];

for ($eachP in $diffEdgeVertz){
$valuesP = `pointPosition -w ($eachP)`;	
string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorCX`; 
move -ws $valuesP[0] $valuesP[1] $valuesP[2] $spaceLocatorB;
$ReturnObjects += $spaceLocatorB[0]+" ";
}
string $DiffPolyBorderEdges[] = GetdiffEdgesOfBorder($PolygonNew);
string $SelectedPolyBorderEdges[] = PolyBorderEdges($PolygonNew);

	int $sizeBorderEdges = size($SelectedPolyBorderEdges) -1;
string $EdgeVertzStart[0] = {$diffEdgeVertz[0]};
stringArrayRemoveAtIndex(0, $diffEdgeVertz);
string $NearEdges[] = GetNearEdges($EdgeVertzStart);
string $NearEdgesOne[0] = {$NearEdges[0]};
string $NearEdgesSecond[0] = {$NearEdges[1]};
appendStringArray($DiffPolyBorderEdges, $NearEdgesSecond, 1);
 string $diffA[] = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdges);
string $orderedArray[0] = {$NearEdgesOne[0]};
int $Xi = 1;
while ($Xi < $sizeBorderEdges){
$Xi++;
string $NearEdgesA[] = GetNearEdges($NearEdgesOne);
select -r $NearEdgesA;
appendStringArray($DiffPolyBorderEdges, $NearEdgesOne, 1);
  string $diffB[] = stringArrayRemoveExact($DiffPolyBorderEdges,$NearEdgesA);
select -r $diffB;
string $EdgesVertex[] = ls("-fl",polyListComponentConversion("-toVertex",$diffB[0]));
int $ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
appendStringArray($orderedArray, $diffB, 1);
$NearEdgesOne = $diffB;
}
appendStringArray($orderedArray, $NearEdgesSecond, 1);

$EdgeLists = "";

int $iix = 0;
int $iiV = 0;
for ($each in $orderedArray){
string $oneItem[0] = {$each};
string $EdgesVertex[] = ls("-fl",polyListComponentConversion("-toVertex", $oneItem[0]));
playButtonStepForward;
select -r $EdgesVertex;
playButtonStepForward;
if ( $iix > 0){
$ifTrue = FindifArraysContain($EdgesVertex, $diffEdgeVertz);
if ( $ifTrue == 1){ $iiV++; if ( $iiV == 1){
$EdgeLists += " "+$oneItem[0]+" "+"VERT";} if ( $iiV == 2){ $EdgeLists += " "+$oneItem[0]; $iiV = 0; } }
if ( $ifTrue == 0){ $EdgeLists += " "+$oneItem[0]; }
}
if ( $iix == 0){  $EdgeLists += $oneItem[0]; }
$iix++;
}

string $bufferList[];
$numTokens = `tokenize $EdgeLists "VERT" $bufferList`;
string $EdgeCurves[];
clear $EdgeCurves;
string $EdgesVertexEach[];
string $ListA[];
  for($eachBuffer in $bufferList){
string $ListA[] = `stringToStringArray $eachBuffer " "`;
//string $EdgesVertexEach[] = ls("-fl",polyListComponentConversion("-toVertex", $ListA));
string $EdgesVertexEachOrder[] = VertLoopEdgeLoop($ListA);
	$curve = "curve -d 1";	
float $values[];
  for($eachVert in $EdgesVertexEachOrder){ playButtonStepForward; 
select -r $eachVert; playButtonStepForward;
$values = `pointPosition -w ($eachVert)`;		
	$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
}
string $Newcurvez = `eval($curve)`;
string $Newcurve[];
clear $Newcurve;
string $Newcurve[] = {$Newcurvez};
appendStringArray($EdgeCurves, $Newcurve, 1);

}

string $NurbSurfaceFromPolyFaces[0] = {`alternativeBoundry`};
delete -ch $NurbSurfaceFromPolyFaces;
delete -ch $EdgeCurves;
delete $PolygonNew;
$ReturnObjects += $NurbSurfaceFromPolyFaces[0];
select -r $EdgeCurves;
return $ReturnObjects;
}

/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////Procs Needed For Above Global Proc

global proc string[] GetNearEdges(string $edgeArray[]){
string $PolyVertexFromEdges[] = ls("-fl",polyListComponentConversion("-toVertex",$edgeArray[0]));
string $PolyEdgesFromVertex[] = ls("-fl",polyListComponentConversion("-toEdge", $PolyVertexFromEdges));
return $PolyEdgesFromVertex;
} 


global proc string alternativeBoundry(){
	int $hist = `constructionHistory -q -tgl`;
	global int $gSelectNurbsCurvesBit;
	global int $gSelectIsoparmsBit;
	global int $gSelectCurvesOnSurfacesBit;
	global int $gSelectSurfaceEdgeBit;
	string $curves[] = `filterExpand -ex true -sm $gSelectNurbsCurvesBit -sm $gSelectIsoparmsBit -sm $gSelectCurvesOnSurfacesBit -sm $gSelectSurfaceEdgeBit`;
	string $surface = "";
	int $n = size($curves);
	int $i;
	if( $n < 4 ) return $surface;
	string $cmd = "boundary -or 0 -ep 0 -rn 1 -po 0 -ept 0.001 -ch  " + $hist + " ";
	// Rebuild them into linears (keep cvs):
	for( $i=0; $i<$n; $i+=1 ) {
		string $now[] = `rebuildCurve -ch 0 -rpo 1 -kcp on -d 1 -rt 0 $curves[$i]`;
		$curves[$i] = $now[0];
		$cmd = $cmd + $curves[$i] + " ";
	}

	// Convert back into cubic:
	string $res[] = eval($cmd);
	if( size($res) > 0 ) {
		$surface = $res[0];
rebuildSurface -ch $hist -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kc 0 -su 0 -du 3 -sv 0 -dv 3 -tol 0.001 -fr 0  -dir 2 $surface;		
	}

	if( !$hist ) {
		for( $i=0; $i<$n; $i+=1 ) {
			delete $curves[$i];
		}
	}

	select -r $curves;
	return $surface;
}



global proc string[] VertLoopEdgeLoop(string $edgeZ[]){

	string	$verts[];
	string $v0[]=`polyListComponentConversion -tv $edgeZ[0]`;
		$v0=`ls -fl $v0`;
	string $v1[]=`polyListComponentConversion -tv $edgeZ[1]`;
		$v1=`ls -fl $v1`;
		$v0=`stringArrayRemove $v1 $v0`;
		$verts[0]=$v0[0];
		
		for($i=0;$i<size($edgeZ);$i++)
		{
			string 	$v0[]=`polyListComponentConversion -tv $edgeZ[$i]`;
			
				$v0=`ls -fl $v0`;
				$v0=`stringArrayRemove $verts $v0`;
				$verts[size($verts)]=$v0[0];
		}
		
	return	$verts;
}





global proc int FindifArraysContain(string $FirstList[], string $array2[]){
  int $found;
int $Trigger;
for ($each in $FirstList){
string $oneItemz = $each;
$found = stringArrayContains($oneItemz, $array2);
if ( $found == 1 ){ $Trigger = 1; break; }
}
return $Trigger;
}


global proc int IfIntersect(string $ArrayA[], string $ArrayB[]){
string $myIntersector = `stringArrayIntersector`;
stringArrayIntersector -edit -intersect $ArrayA $myIntersector;
stringArrayIntersector -edit -intersect $ArrayB $myIntersector;
string $findIntersection[] = `stringArrayIntersector -query $myIntersector`;
stringArrayIntersector -edit -reset $myIntersector;
int $sizeofItems = size($findIntersection);
return $sizeofItems;
}


global proc string[] PolyBorderEdges(string $polyZ[]){
string $PolyFaceZ = ( $polyZ[0] +".f[*]");
string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
string $PolyEdgesFromFaceZ[] =  ls("-fl",polyListComponentConversion("-toEdge",$AllPolyFaceZ));
select -r $PolyEdgesFromFaceZ;
polyConvertToShellBorder;
string $SelectedPolyBorderEdgeZ[] = `ls -sl -fl`;
return $SelectedPolyBorderEdgeZ;
}




global proc string[] GetdiffEdgesOfBorder(string $poly[]){
string $PolyFaceZ = ( $poly[0] +".f[*]");
string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
string $PolyEdgesFromFaceZ[] =  ls("-fl",polyListComponentConversion("-toEdge",$AllPolyFaceZ));
select -r $PolyEdgesFromFaceZ;
polyConvertToShellBorder;
string $SelectedPolyBorderEdgeZ[] = `ls -sl -fl`;
  string $diffEdgeZ[] = stringArrayRemoveExact($SelectedPolyBorderEdgeZ, $PolyEdgesFromFaceZ);
select -r $diffEdgeZ;
return $diffEdgeZ;
}


global proc string[] GetEdgeVertex(string $poly[]){
string $PolyFaceZ = ( $poly[0] +".f[*]");
string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
select -r $AllPolyFaceZ;
polyConvertToShellBorder;
ConvertSelectionToContainedEdges;
ConvertSelectionToContainedFaces;
string $EdgePolyFaceZ[] = `ls -sl -fl`;
string $PolyEdgelistA[] = ls("-fl",polyListComponentConversion("-border", "-toVertex", "-fromFace", $EdgePolyFaceZ));
select -r $PolyEdgelistA;
string $PolyEdgelistB[] = ls("-fl",polyListComponentConversion( "-toVertex", "-fromFace", $EdgePolyFaceZ));
select -r $PolyEdgelistB;
  string $diffEdgeZ[] = stringArrayRemoveExact($PolyEdgelistA, $PolyEdgelistB);
select -r $diffEdgeZ;
return $diffEdgeZ; 
}




global proc int stringArrayGmatchIndex(string $itemA[], string $list[]){
string $item = $itemA[0];
	int $result = false;	
int $ResultIndex = 0;
int $Index = 0;	
	string $listItem;	
	for ($EachlistItem in $list) {
		if ( $EachlistItem == $item ){
		$result = true; $ResultIndex = $Index;
			break;	}
$Index++;
	}	
	return $ResultIndex;
}





//  Input Arguments:
//      $method: the flag from the polySelect MEL command to use:
//				"edgeLoopPattern", "edgeRingPattern" or "edgeBorderPattern"
//
//  Return Value:
//      None.




global proc polySelectEdgesPattern(string $method)
{
	string $edges[] = `getEdges`;
	int $size = `size $edges`;

	if ($size > 1)
	{
		string $buffer[];

		tokenize $edges[0] "[]" $buffer;
		string $cmd = "polySelect -";
		$cmd += $method;
		$cmd += " ";
		$cmd += $buffer[1];

		tokenize $edges[1] "[]" $buffer;
		$cmd += " ";
		$cmd += $buffer[1];

		eval($cmd);
	}
}





/* This file downloaded from Highend3d.com
''  
''  Highend3d.com File Information:
''  
''    Script Name: Extract Curve From Edges
''    Author: ephemeros 
''    Last Updated: May 19, 2007
''    Update/Change this file at:
''    http://Highend3d.com/maya/downloads/mel_scripts/modeling/curve_tools/1395.html
''  
''  Please do not alter any information above this line
''  it is generated dynamically by Highend3d.com and will
''  be changed automatically on any updates.
*/
//
//mm_curveFromEdges v0.1 by Mihai Militaru (mihai.militaru@gmail.com)
//
// This script "extracts" a curve from a countiguous selection of polygon
//edges, the curve will have a CV for every vertex of the selection.
// For a linear curve, a selection of at least 2 edges (3 for a closed curve)
//is required and at least 3 for a cubic curve (4 for a closed one).
// Usage:
//  -run "mm_extractCurveFromEdgesGUI;" to initialize the GUI;
//  -choose the degree of the new curve;
//  -press the "Apply" button to create the curve or "Extract"
//to create it and close the window.
//
// for suggestions, bugs, etc, please write me an e-mail

global proc string[] mm_curveFromEdges()
{
	string $sel[] = `selectedNodes`;
	if(size($sel)!=1)
		error "Select some contiguous edges, on one poly object";
	string $edges[] = `filterExpand -sm 32`;
	int $len = size($edges);
	if(!$len)
		error "Select some contiguous edges";
	string $infoVerts[];
	string $fVerts[], $lVerts[];
	int $position[], $sticks[], $firstHeadPos, $headsNr;
	for($i=0; $i<$len; $i++)
	{
		$infoVerts = `polyInfo -ev $edges[$i]`;
		$infoVerts = `stringToStringArray $infoVerts[0] " "`;
		$fVerts[$i] = $infoVerts[2];
		$lVerts[$i] = $infoVerts[3];
	}
	for($i=0; $i<$len; $i++)
	{
		$sticks[$i] = 0;
		for($j=0; $j<$len; $j++)
		{
			if(($j!=$i))
			{
				if(($fVerts[$i]==$fVerts[$j]) || ($lVerts[$i]==$lVerts[$j]) || ($fVerts[$i]==$lVerts[$j]) || ($lVerts[$i]==$fVerts[$j]))
					$sticks[$i]+=1;
			}
		}
		if(($sticks[$i]<1) || ($sticks[$i]>2))
			error "Select some contiguous edges";
	}
	$firstHeadPos = 0;
	$headsNr = 0;
	for($i=0; $i<$len; $i++)
	{
		if($sticks[$i] == 1)
		{
			$headsNr++;
			if($headsNr>2)
				error "Select some contiguous edges";
			$firstHeadPos = $i;
		}
	}
	int $orderedEdgesIDs[];
	$orderedEdgesIDs[0] = $firstHeadPos;
	int $currentEdgePos = $firstHeadPos;
	int $jump = 0, $counter = 0, $max = size($edges)*size($edges);
	while(size($orderedEdgesIDs)<$len)
	{
		for($i=0; $i<$len; $i++)
		{
			for($j=0; $j<size($orderedEdgesIDs); $j++)
				if($orderedEdgesIDs[$j] == $i)
				{
					$jump = 1;
					break;
				}
			if(!$jump)
			{
				if(($fVerts[$i]==$fVerts[$currentEdgePos]) || ($lVerts[$i]==$lVerts[$currentEdgePos]) || ($fVerts[$i]==$lVerts[$currentEdgePos]) || ($lVerts[$i]==$fVerts[$currentEdgePos]))
				{
					$currentEdgePos = $i;
					$orderedEdgesIDs[size($orderedEdgesIDs)] = $i;
				}
			}
			$jump = 0;
			$counter++;
		}
		if($counter>=$max)
			break;
	}
	int $forstOrLast = 0, $orderedVerts[], $oeLen = size($orderedEdgesIDs);
	
	if(($fVerts[$orderedEdgesIDs[0]] == $fVerts[$orderedEdgesIDs[1]]) || ($fVerts[$orderedEdgesIDs[0]] == $lVerts[$orderedEdgesIDs[1]]))
		$orderedVerts[0] = $lVerts[$orderedEdgesIDs[0]];
	else if(($lVerts[$orderedEdgesIDs[0]] == $fVerts[$orderedEdgesIDs[1]]) || ($lVerts[$orderedEdgesIDs[0]] == $lVerts[$orderedEdgesIDs[1]]))
		$orderedVerts[0] = $fVerts[$orderedEdgesIDs[0]];
		
	for($i=0; $i<$oeLen-1; $i++)
	{
		if(($fVerts[$orderedEdgesIDs[$i]] == $fVerts[$orderedEdgesIDs[$i+1]]) || ($fVerts[$orderedEdgesIDs[$i]] == $lVerts[$orderedEdgesIDs[$i+1]]))
			$orderedVerts[size($orderedVerts)] = $fVerts[$orderedEdgesIDs[$i]];
		else if(($lVerts[$orderedEdgesIDs[$i]] == $fVerts[$orderedEdgesIDs[$i+1]]) || ($lVerts[$orderedEdgesIDs[$i]] == $lVerts[$orderedEdgesIDs[$i+1]]))
			$orderedVerts[size($orderedVerts)] = $lVerts[$orderedEdgesIDs[$i]];
	}
	int $ovLen = size($orderedVerts);
	if($fVerts[$orderedEdgesIDs[$oeLen-1]] == $orderedVerts[$ovLen-1])
	{
		$orderedVerts[$ovLen] = $lVerts[$orderedEdgesIDs[$oeLen-1]];
		$ovLen++;
	}
	else if($lVerts[$orderedEdgesIDs[$oeLen-1]] == $orderedVerts[$ovLen-1])
	{
		$orderedVerts[$ovLen] = $fVerts[$orderedEdgesIDs[$oeLen-1]];
		$ovLen++;
	}
	string $ret[];
	
	float $vertPos[] = `xform -a -ws -q -t ($sel[0]+".vtx["+$orderedVerts[0]+"]")`;
	$curve = `curve -d 1 -p $vertPos[0] $vertPos[1] $vertPos[2]`;
	if($orderedVerts[0] != $orderedVerts[$ovLen-1])
	{
		for($i=1; $i<$ovLen; $i++)
		{
			$vertPos = `xform -a -ws -q -t ($sel[0]+".vtx["+$orderedVerts[$i]+"]")`;
			curve -a -p $vertPos[0] $vertPos[1] $vertPos[2] $curve;
		}
		$ret[1] = "open";
	}
	else
	{
		for($i=1; $i<$ovLen-1; $i++)
		{
			$vertPos = `xform -a -ws -q -t ($sel[0]+".vtx["+$orderedVerts[$i]+"]")`;
			curve -a -p $vertPos[0] $vertPos[1] $vertPos[2] $curve;
		}
		closeCurve -ch 0 -ps 0 -rpo 1 -bb 0.5 -bki 0 -p 0.1 $curve;
		$ret[1] = "closed";
	}
	$ret[0] = $curve;
	return $ret;
}

global proc string mm_extractCurveFromEdges(int $degree)
{
	string $curve[] = `mm_curveFromEdges`;
	if($degree == 1)
	{
		select -r $curve[0];
		return $curve[0];
	}
	else if($degree == 3)
	{
		if($curve[1] == "open")
			rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 1 -kep 1 -kt 0 -s 4 -d 3 -tol 0 $curve[0];
		if($curve[1] == "closed")
		{
			closeCurve -ch 1 -ps 0 -rpo 1 -bb 0.5 -bki 0 -p 0.1 $curve[0];
			rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 1 -kep 1 -kt 0 -s 4 -d 3 -tol 0 $curve[0];
			closeCurve -ch 1 -ps 0 -rpo 1 -bb 0.5 -bki 0 -p 0.1 $curve[0];
		}
		select -r $curve[0];
		return $curve[0];
	}
	else
		error ("Degree not suported: "+$degree+". Use only 1 or 3.");
}
//mm_extractCurveFromEdges 3;

global proc mm_extractCurveFromEdgesGUI()
{
	if(`window -ex "mm_extCrvEdg_win"`)
		deleteUI "mm_extCrvEdg_win";
	window "mm_extCrvEdg_win";
	columnLayout "mm_extCrvEdg_cLay1";
	radioButtonGrp -nrb 2 -l "Degree" -l1 "Linear" -l2 "Cubic" -sl 1 -cw3 60 60 60 -p "mm_extCrvEdg_cLay1" "mm_extCrvEdg_rdb1";
	rowLayout -nc 3 "mm_extCrvEdg_cLay1";
	button -p "mm_extCrvEdg_cLay1" -l "Extract" -c "mm_extractCurveFromEdgesChooser `radioButtonGrp -q -sl \"mm_extCrvEdg_rdb1\"`; deleteUI \"mm_extCrvEdg_win\";" "mm_extCrvEdg_btn1";
	button -p "mm_extCrvEdg_cLay1" -l "Apply" -c "mm_extractCurveFromEdgesChooser `radioButtonGrp -q -sl \"mm_extCrvEdg_rdb1\"`;" "mm_extCrvEdg_btn2";
	button -p "mm_extCrvEdg_cLay1" -l "Close" -c "deleteUI \"mm_extCrvEdg_win\";" "mm_extCrvEdg_btn3";
	window -e -wh 245 47 "mm_extCrvEdg_win";
	showWindow "mm_extCrvEdg_win";
}

global proc mm_extractCurveFromEdgesChooser(int $degrSel)
{
	switch($degrSel)
	{
		case 1:
			mm_extractCurveFromEdges 1;
			break;
		case 2:
			mm_extractCurveFromEdges 3;
			break;
		default:
	}
}
mm_extractCurveFromEdgesGUI;














proc string[] SortEvenArrays(string $ArrayItems[]){
string $newItemsList[];
int $getsize = size($ArrayItems);
int $i = 0;	
$iX = 0;
	while($i < $getsize){
$iX++;
if ( $iX == 2){
string $oneitem[0] = {$ArrayItems[$i]};
appendStringArray($newItemsList, $oneitem, 1);
$iX = 0;
}
$i++;
}
return $newItemsList;
}


proc string[] ArrayFromAllinString(string $list){

string $singleStringItemB[];
string $singleStringItemA[];
int $i = 0;
int $Indexi = 0;
int $triggerends = 0;
string $listA = $list; 
while ( $triggerends < 1 ) { 
$i++;
$singleStringItemA = {`substring $listA $i $i`};
if (size($singleStringItemA[0]) == 0){
$triggerends = 2; } else {
appendStringArray($singleStringItemB, $singleStringItemA, 1);
}
$Indexi++;
if ($Indexi == 20){ $triggerends = 2;}
}
return $singleStringItemB;
}


proc int[] ArrayToIntList(string $singleStringItemB[]){
int $Numberlist[];
int $triggerendsB = 0;
int $newlistSize = size($singleStringItemB);
int $ci = 0;
while ( $triggerendsB < $newlistSize ) { 
$Numberlist[$ci] = $singleStringItemB[$ci];
$ci++;
$triggerendsB = $triggerendsB + 1;
}
print $Numberlist;
return $Numberlist;
}



proc string[] CycleNumberString(string $singleStringItemC[]){
int $SizeOfArray;
$SizeOfArray = size($singleStringItemC) -1;
string $last[0] = {$singleStringItemC[$SizeOfArray]};
string $first[0] = {$singleStringItemC[0]};
  stringArrayRemoveAtIndex(0, $singleStringItemC);
  appendStringArray($singleStringItemC, $first, 1);
return $singleStringItemC; 
}


string $startFaceRing[] = `ls -sl -fl`;


string $listZ = "0110011";

string $singleStringItemC[] = ArrayFromAllinString($listZ);

$singleStringItemC = CycleNumberString($singleStringItemC);
int $NumberlistA[] = ArrayToIntList( $singleStringItemC);
string $ArrayNewItems[] = SortPatternArrays($startFaceRing, $NumberlistA );
select -r $ArrayNewItems;



proc string[] SortPatternArrays(string $ArrayItems[], int $NumberlistA[]){

int $getsizeNlist = size($NumberlistA);
int $iN = 0;	
string $newItemsList[];
int $getsize = size($ArrayItems);
int $i = 0;	
$iX = 0;
	while($i < $getsize){
$iX++;
if ( $NumberlistA[$iN] == 0){
string $oneitem[0] = {$ArrayItems[$i]};
appendStringArray($newItemsList, $oneitem, 1);
if ( $iN == $getsizeNlist){ $iN = -1;}
$iX = 0;
}

$iN++;
$i++;
}
return $newItemsList;
}




proc string[] SortEvenArrays(string $ArrayItems[], int $Num){

int $Num = 011001
string $newItemsList[];
int $getsize = size($ArrayItems);
int $i = 0;	
$iX = 0;
	while($i < $getsize){
$iX++;
if ( $Num == 2){
if ( $iX == 2){
string $oneitem[0] = {$ArrayItems[$i]};
appendStringArray($newItemsList, $oneitem, 1);
$iX = 0;
}
}

if ( $Num == 1){
if ( $iX == 1){
string $oneitem[0] = {$ArrayItems[$i]};
appendStringArray($newItemsList, $oneitem, 1);
}
if ( $iX == 2){ $iX = 0;}
}

$i++;
}
return $newItemsList;
}











proc string[] CompareCurveIntersect (string $objectLoc[]){
string $objectLocZ[];
string $CurveintersectZ;
string $ItemLists[];
$objectLocZ = $objectLoc;
int $X = size($objectLocZ) -1;
int $Z = size($objectLocZ);
int $i = 1;
int $n = -1;
int $n2 = 0;
for( $i = 0; $i < $X; $i ++ ) {
$n = $n + 1;
$Z = $Z - 1;
$ix = 0;
$n2 = $n + 1;
while ($Z > $ix++){	
$CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2]`;
if (size($CurveintersectZ) > 0) {	
ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
} else { print "no Intersect"; }
$n2++;
}
}
return $ItemLists;
}

////////////


proc string[] CompareCurveIntersectTwoCurves(string $objectLocA[], string $objectAll[]){

string $CurveintersectZA;
string $CurveintersectZB;
string $ItemLists[];

int $Z = size($objectLocA) -1;
int $X = size( $objectAll) -1;
int $ix = 0;
int $n2 = 0;

while ($X > $ix++){	
$CurveintersectZA = `curveIntersect -ch 0 -tolerance 0.001 $objectLocA[0] $objectAll[$n2]`;
if (size($CurveintersectZA) > 0) {	
$CurveintersectZB = `curveIntersect -ch 0 -tolerance 0.001 $objectLocA[1] $objectAll[$n2]`;
if (size($CurveintersectZB) > 0) {	
ArrayInsertAtEnd( $ItemLists, $objectAll[$n2]);
}
} else { print "no Intersect"; }
$n2++;

}
return $ItemLists;
}








proc string[] CompareCurveIntersect4 (string $objectLoc[]){
string $objectLocZ[];
string $CurveintersectZ;
string $ItemLists[];
$objectLocZ = $objectLoc;
int $X = size($objectLocZ) -1;
int $Z = size($objectLocZ);
int $i = 1;
int $n = -1;
int $n2 = 0;
for( $i = 0; $i < $X; $i ++ ) {
$n = $n + 1;
$Z = $Z - 1;
$ix = 0;
$n2 = $n + 1;
while ($Z > $ix++){	
$CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2]`;
if (size($CurveintersectZ) > 0) {	
ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
} else { print "no Intersect"; }
$n2++;
}
}

  string $shorterList[] = stringArrayRemoveDuplicates($ItemLists);
$ItemLists = $shorterList;
return $ItemLists;
}



proc string[] CompareCurveIntersect2 (string $object[], string $objectlist[]){

int $X = size($objectlist);

string $ItemListsA[];
$ix = 0;
$iz = 1;
while ($X > $ix++){	

string $CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $object[0] $objectlist[$ix]`;
if (size($CurveintersectZ) > 0) {	
ArrayInsertAtEnd( $ItemListsA, $objectlist[$ix]);
} 
}
return $ItemListsA;
}



proc string[] CompareCurveIntersect5 (string $objectLoc[], string $objectLocB[]){
string $objectLocZ[];
string $CurveintersectZ;
string $ItemLists[];

$objectLocZ = $objectLoc;

int $X = size($objectLocZ) ;

int $Z = size($objectLocB);
int $i = 1;
int $n = -1;
int $n2 = 0;
for( $i = 0; $i < $X; $i ++ ) {
$n = $n + 1;
$Z = $Z - 1;
$ix = 0;
$n2 = $n + 1;
while ($Z > $ix++){	
$CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $objectLocZ[$n] $objectLocB[$n2]`;
if (size($CurveintersectZ) > 0) {	
ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
} else { print "no Intersect"; }
$n2++;
}
}

  string $shorterList[] = stringArrayRemoveDuplicates($ItemLists);
$ItemLists = $shorterList;
return $ItemLists;
}



proc setRotationAxis(string $objectitem1[]){
//
string $objectitem1[] = `ls -sl`;
select -cl  ;
string $groupRotAX;
$groupRotAX = `group -w -em -n RotAxiz`; xform -os -piv 0 0 0 $groupRotAX;
string $itemA = $objectitem1[0];
string $itemB = $objectitem1[1];
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $itemB;
float $rotationsA[] = `getAttr ($itemA+".rotate")`;
setAttr ($groupRotAX+".rotate") $rotationsA[0] $rotationsA[1] $rotationsA[2];
parent -absolute $itemB $groupRotAX;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $itemB; parent -w $itemB;
delete $groupRotAX;
}



proc string[] CIRCLESCRIPTZ(string $ObjectCurve[]) {

//CIRCLE SCRIPT

string $CIRCLEX[];

//string $newCircle[] = `CIRCLESCRIPTZ($drawcurve)`;
//string $ObjectCurve[] = $drawcurve;

string $ObjectCurveduplicate[] = `duplicate -rr $ObjectCurve`;
setAttr ($ObjectCurveduplicate[0] + ".translate") 0 0 0;
setAttr ($ObjectCurveduplicate[0] + ".rotate") 0 0 0;
select -cl  ;
float $rotationz[];
$rotationz = `xform -q -rotation $ObjectCurve`;
float $translationz[];
$translationz = `xform -q -translation $ObjectCurve`;
float $bbox[] = `exactWorldBoundingBox $ObjectCurveduplicate`;
//print("Bounding box ranges from: " +
//      $bbox[0] + "," + $bbox[1] + "," + $bbox[2] + ", to " +
//      $bbox[3] + "," + $bbox[4] + "," + $bbox[5] + ".\n");
spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
move -ws $bbox[0] $bbox[1] $bbox[2] BoxspaceLocatorA;
spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
move -ws $bbox[3] $bbox[4] $bbox[5] BoxspaceLocatorB;
spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
move -ws $bbox[3] $bbox[1] $bbox[2] BoxspaceLocatorC;
spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
move -ws $bbox[0] $bbox[4] $bbox[5] BoxspaceLocatorD;
spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;
// xform -query -worldSpace -translation;
/////////////////////////////////////////
float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox[2]};
float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox[5]};
float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox[2]};
float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox[5]};

$BoxPointA = `MakeCleanFloats($BoxPointA)`;
$BoxPointB = `MakeCleanFloats($BoxPointB)`;
$BoxPointC = `MakeCleanFloats($BoxPointC)`;
$BoxPointD = `MakeCleanFloats($BoxPointD)`;

float $BoxMPointAC[] = MidPointBetween($BoxPointA, $BoxPointC);
float $BoxMPointBD[] = MidPointBetween($BoxPointB, $BoxPointD);
float $BoxMPointAD[] = MidPointBetween($BoxPointA, $BoxPointD);
float $BoxMPointBC[] = MidPointBetween($BoxPointB, $BoxPointC);
//   MoveObjectSelection($BoxMPointAC);

float $BoxMPointAC[] = MidPointBetween($BoxPointA, $BoxPointC);
float $BoxMPointBD[] = MidPointBetween($BoxPointB, $BoxPointD);
float $BoxMPointAD[] = MidPointBetween($BoxPointA, $BoxPointD);
float $BoxMPointBC[] = MidPointBetween($BoxPointB, $BoxPointC);

float $CrossMPointAB[] = MidPointBetween($BoxPointA, $BoxPointB);
move -ws $bbox[0] $bbox[4] $bbox[5] BoxspaceLocatorD;
float $translationzMiddle[];
$translationzMiddle = `xform -q -translation BoxspaceLocatorMiddle`;

float $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
float $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);
$distanceAverage =  (($distanceA + $distanceB) * (0.5)) ;
$radiusX = ( $distanceAverage / 2);
//if / then 
float $squarePercentA;
float $squarePercentB;
if ( $distanceA > $distanceAverage) {
$squarePercentA = (( $distanceAverage / $distanceA ) * (100));
}
if ( $distanceA < $distanceAverage) {
$squarePercentA = (( $distanceA / $distanceAverage ) * (100));
}
if ( $distanceB > $distanceAverage) {
$squarePercentB = (( $distanceAverage / $distanceB ) * (100));
}
if ( $distanceB < $distanceAverage) {
$squarePercentB = (( $distanceB / $distanceAverage ) * (100));
}
/////////////////////
int $squareA;
$squareA = 0;
int $squareB;
$squareB = 0;
print $squarePercentA ;
if ( $squarePercentA > 55)  {
$squareA = (0 + 1); 
} else {
$squareA = (0);
}
print $squareA;
print $squarePercentB ;
if ( $squarePercentB > 55)  {
$squareB = ($squareB + 1);
} else {
$squareB = (0);
}
$addSquareResults = ($squareA + $squareB);
if ( $addSquareResults == 2 ){
 circle -nr 0 1 0 -c $translationzMiddle[0] $translationzMiddle[1] $translationzMiddle[2] -r $radiusX;
$CIRCLEX = `ls -sl`;
float $rotationz[];
$rotationz = `xform -q -rotation $ObjectCurve`;
setAttr ($CIRCLEX[0] + ".rotateX") $rotationz[0];
setAttr ($CIRCLEX[0] + ".rotateY") $rotationz[1];
setAttr ($CIRCLEX[0] + ".rotateZ") $rotationz[2];
float $translationz[];
$translationz = `xform -q -translation $ObjectCurve[0]`;
setAttr ($CIRCLEX[0] + ".translateX") $translationz[0];
setAttr ($CIRCLEX[0] + ".translateY") $translationz[1];
setAttr ($CIRCLEX[0] + ".translateZ") $translationz[2];
//TEMP CHANGE
//string $currPanel = `getPanel -withFocus` , $camera ;
//$camera = `modelPanel -q -camera $currPanel`;
//setAttr ($CIRCLEX[0] + ".rotate") `getAttr ($ObjectCurve[0] + ".rotate")`;
delete $ObjectCurve $ObjectCurveduplicate BoxspaceLocatorA BoxspaceLocatorB BoxspaceLocatorC BoxspaceLocatorD BoxspaceLocatorMiddle;
}
else {
delete $ObjectCurveduplicate BoxspaceLocatorA BoxspaceLocatorB BoxspaceLocatorC BoxspaceLocatorD BoxspaceLocatorMiddle;
}
string $NewNameZ = `rename $CIRCLEX "Curve"`;
$CIRCLEX = {$NewNameZ};
return $CIRCLEX;

}





/*

//AIM ARRAY
nurbsSelect -borderSelection;
nurbsSelect -growSelection 3;
select -r ls -fl nurbsSphere2.cv[0:"*"][0:"*"]  ;
$NurbsCVlist[] = `ls -fl nurbsSphere2.cv[0:"*"][0:"*"]`;
{



$list = `ls -sl`;
$surface = $list[0];
$object = $list[1];


string $arrayTypeZ[] = {"nurbsCurve", "nurbsSurface", "mesh"};
int $num = size($arrayTypeZ);
int $Typenum = 0;
for ($iC=0;$iC<$num;$iC++){
string $TypeZ[] = `ls -dag -sl -head 1 -type $arrayTypeZ[$iC] $surface `;
if (size($TypeZ) == 1){
$Typenum = $iC;}
}

print $Typenum; 


if ($Typenum == 2){ 

int $numVertexZ[] = `polyEvaluate -v $surface`;
float $pos[];
$count = 0;
while ($count < $numVertexZ[0]){
	select -r $object;
	$newobject = `duplicate -rr -un`;	
	$name = ($surface + ".vtx[" + $count + "]");
	
	float $pos[];	
	$pos = `pointPosition -w $name`;
	select -r $newobject;
	move  -ws $pos[0] $pos[1] $pos[2];
select -r $surface;
select -add $newobject;
aimConstraint -mo -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 0 1;
select -r $newobject;	
	currentTime 1;
	$count++;
}

}

if ($Typenum == 1){ 





int $add = (29 + 21);


	string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );

string $numcvnames[] = `ls -fl ($CurveItemA+".cv[*]")`; 
int $numcvs = size($numcvnames);

for ($iC=0;$iC<$numcvs;$iC++){

*/


global int $minNumber = 18; 


// SmoothCurvature3($minNumber);
// SmoothCurvature5($minNumber);
// SmoothCurvature4($minNumber, 22);
// SmoothCurvature3(18);
// SmoothCurvatureReverse6(18);
// 
//Removefromsurface;
// 
//
//string $renamed[] = `ls -sl`;
//
//
//$Zparentarcx = Strait_ARC_or_FreeForm($renamed, 3.5, 2.5 );

//EvalSmoothCurves;

proc EvalSmoothCurves(){
SmoothCurvature3(8);
//SmoothCurvatureReverse6(18);
}

//string $renamed[] = `ls -sl`;
//Make_Middle_of_Curve_ParamlocatorZ($renamed);


proc string[] Make_Middle_of_Curve_ParamlocatorZ(string $objectCurveSelected[]){

float $arclenghtzALL = `arclen $objectCurveSelected`;
float $arclenghtzDivide = $arclenghtzALL / 2.0;

int $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($objectCurveSelected[0] + ".cv[0]") ;			
$CurveSelection[1] = ($objectCurveSelected[0] + ".cv[" + $numCVrealNum + "]") ;
string $paramlocatorZARC[];
$paramlocatorZARC[0] = eval("paramLocator " +  $objectCurveSelected[0] + ".u[" + 0.0 + "]");

float $step = 10; 
int $a = 1;
  	float $t =  $a/$step;

setAttr ( $paramlocatorZARC[0] + ".localPositionX") $t;
string $paramANDCurve[] = `paramToCurvePts( $paramlocatorZARC )`;
float $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;

float $divZZ = $arclenghtzDivide / $arclenghtzparamZ ;
float $divZZ2 = $t * $divZZ ;
setAttr ( $paramlocatorZARC[0] + ".localPositionX") $divZZ2;
////////////////////// Moved ParamLoc to middle

float $posA[];
float $posB[];
float $posC[];
$posA = `pointPosition -w $CurveSelection[0]`;
$posB = `pointPosition -w $paramlocatorZARC[0]`;
$posC = `pointPosition -w $CurveSelection[1]`;
string $CircularArcFromCurve[];
$CircularArcFromCurve[0] = `createNode makeThreePointCircularArc`;
setAttr ($CircularArcFromCurve[0] + ".pt1") $posA[0] $posA[1] $posA[2] ;
setAttr ($CircularArcFromCurve[0] + ".pt2") $posB[0] $posB[1] $posB[2];
setAttr ($CircularArcFromCurve[0] + ".pt3") $posC[0] $posC[1] $posC[2];
setAttr ($CircularArcFromCurve[0] + ".d") 3;
setAttr ($CircularArcFromCurve[0] + ".s") 8;
string $ArcCurve[];
$ArcCurve[0] = `createNode nurbsCurve` ; 
connectAttr ($CircularArcFromCurve[0] + ".oc") ($ArcCurve[0] +".cr");
//delete $objectCurveSelected; 
string $ParentArc[];
$ParentArc = `listRelatives -parent $ArcCurve`;
ResetTranlation($ParentArc);
string $MakeArcLocator[]; $MakeArcLocator = `spaceLocator -p 0 0 0 -n ArcLocator`;
move -ws $posB[0] $posB[1] $posB[2] $MakeArcLocator;
$ConnectLocToPoint2 = `connectAttr -f ($MakeArcLocator[0] + ".translate") ( $CircularArcFromCurve[0] + ".pt2")`;

string $ArcZ[];
$ArcZ[0] = `rename $ParentArc $objectCurveSelected`; 
delete $paramlocatorZARC;
select -r $ArcZ;
return $ArcZ; 

}

//////////////////////////////////////////////////////////////////////

















////////////////////////////////////////////////////////////////////////
proc string[] Strait_ARC_or_FreeForm(string $renamed[], float $ArcN, float $StraitN ){


int $free = 0;
string $nameString = $renamed[0];
string $ParentArc[];
//smoothCurve -ch 1 -rpo 1 -s 6.60 ($nameString +".cv[*]");
float $objectAcurve01 = arclen ($renamed);

float $curveEndsDis01 = GetDistanceBetweenCurveEnds($renamed);
float $PercentENDsDiffL = XpercentLess_thenY($objectAcurve01, $curveEndsDis01);
int $straitTrigger = 0;

if ( $PercentENDsDiffL < 2 ){ $straitTrigger = 1; }

float $objectAcurveD01 = $objectAcurve01 / 1.5;
int $Cvz = $objectAcurveD01;
if( $objectAcurve01 < 1.0){ $Cvz = 4; }
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001 $renamed;

string $objectB[];
string $objectC[];

string $DeleteCurveA[];
string $DeleteCurveB[];


string $CurveBetween[];
float $PercentDiffS;
if ($straitTrigger == 1){
vector $VectorCurveEndZ[] = VecCurveEnds($renamed);
float $posA[] =  $VectorCurveEndZ[0];
float $posB[] =  $VectorCurveEndZ[1];
$CurveBetween = MakeCurveBetweenFloats($posA, $posB);
ResetTranlation($CurveBetween);
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001 $CurveBetween;
$ParentArc = $CurveBetween; $DeleteCurveA = $renamed; $DeleteCurveB = $objectB;
}


if ( $straitTrigger == 0 ){
string $objectB[] = Make_Middle_of_Curve_ParamlocatorZ($renamed);
ResetTranlation($objectB);
string $objectC[] = {$renamed[0], $objectB[0]};
ResetTranlationEach($objectC);
float $objectAcurveL = arclen ($renamed);
float $objectBcurveL = arclen ($objectB);
float $PercentDiffL = XpercentLess_thenY($objectBcurveL, $objectAcurveL);
if ($PercentDiffL  < $ArcN){

$ParentArc = $objectB;  $DeleteCurveA = $renamed; 
}else{ 

$free = 1;
 $ParentArc = $renamed; $DeleteCurveA = $objectB; }

}

delete $DeleteCurveA;
rename $ParentArc $nameString;
$ParentArc[0] = $nameString;


if ( $free == 1 ){ select -r $ParentArc; EvalSmoothCurves;
string $nameString = $ParentArc[0];
float $objectAcurve02 = arclen ($renamed);
float $objectAcurveD02 = $objectAcurve02 / 1.5;
int $Cvz2 = $objectAcurveD02;
if( $objectAcurve01 < 1.0){ $Cvz2 = 4; }
//rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001 $renamed;
 }

return $ParentArc; 

}



proc string[] SmoothCurvature4(float $curveM , int $Steps ){

string $curves[] = `ls -sl`;
string $myCurve = $curves[0];
rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp 1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv[*]");
	string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 3 );
if ($Steps > 8 ){ $numEPrealNum2 = $Steps; }  

string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`; 
$connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
int $trigger = 0;
$curve = "";
float $curveMin = $curveM;
while ( $trigger < 1 ){
	float $step = $numEPrealNum2;  
	$curve = "curve -d 3";
	
int $Par = 0;
int $a;
int $ii = 0;	
int $CVpoints = 0;	
  for($a = 0; $a <= $step;$a++){
$ii = $ii + 1;
  	$t =  $a/$step;
 	$Par = ($a/$step);
	setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
  	float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
	float $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
		if ( $CurvatureRadi <= $curveMin){
	$CVpoints++;
	$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
	}

if (( $CurvatureRadi > $curveMin) && ( $ii == 1 )){
$CVpoints++;
$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
}
if (( $CurvatureRadi > $curveMin) && ( $Par == 1.0 )){
$CVpoints++;
$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
}
}
if ( $CVpoints < 8 ){ $curveMin++; }
if ( $CVpoints >= 8 ){ $trigger = 1; }

}

string $Newcurvez = `eval($curve)`;
string $Newcurve[] = {$Newcurvez};
delete $paramlocatorpointOnCurvex $spaceLocatorB; 
delete $curves;
rename $Newcurve $myCurve;  
$Newcurve = {$myCurve};

return $Newcurve; 
}


proc string[] SmoothCurvature13(float $curveM ){

string $curves[] = `ls -sl`;
float $arcL1 = `arclen $curves[0]`;
float $arcL1B = ( $arcL1 + ((-1) * ( $arcL1 / 10 )));
string $myCurve = $curves[0];
string $crShape[] = `listRelatives -s $curves[0]`;
rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp 1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv[*]");
	string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 1 );  
string $Newcurve[];
string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`; 
$connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
int $trigger = 0;
$curve = "";
int $Par = 0;
int $b = 0;
int $ii = 0;
int $a = 0;
float $curveMin = $curveM;
float $CurvatureRadi2;
string $Newcurvez;
string $Newcurve[];
while ( $trigger < 1 ){
	float $step = $numEPrealNum2;  
	$curve = "curve -d 3";
int $CVpoints = 0;	
  for($a = 0; $a <= $step;$a++){	
$ii = $ii + 1;
  	$t =  $a/$step;
 	$Par = $a/$step;
	setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
if ( $Par > 0.0 ){ $b = $a -1; $Par2 = $b/$step;
	 $CurvatureRadi2 = `pointOnCurve -top 1 -pr $Par2 -cr $crShape[0]`; }
  	float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
	float $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;

float $AverageCurvatureRadi = (($CurvatureRadi + $CurvatureRadi2) / 2);

		if ( $AverageCurvatureRadi <= $curveMin){
	$CVpoints++;
	$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
	}

if (( $CurvatureRadi > $curveMin) && ( $ii == 1 )){
$CVpoints++;
$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
}
if (( $CurvatureRadi > $curveMin) && ( $Par == 1.0 )){
$CVpoints++;
$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
}
}
if ( $CVpoints < 8 ){ $curveMin++; }
if ( $CVpoints > 2 ){
string $Newcurvez = `eval($curve)`;
$Newcurve = {$Newcurvez};
float $arcL2 = `arclen $Newcurve[0]`;
if ( $arcL2 < $arcL1B ){ delete $Newcurve; $trigger = 0; $numEPrealNum2 = $numEPrealNum2 + 3;   }
if (( $CVpoints >= 8 )&& ( $arcL2 > $arcL1B )){ $trigger = 1; }
}
}

delete $paramlocatorpointOnCurvex $spaceLocatorB; 
delete $curves;
rename $Newcurve $myCurve;  
$Newcurve = {$myCurve};

return $Newcurve; 
}



proc string[] SmoothCurvature3(float $curveM ){

string $curves[] = `ls -sl`;
string $myCurve = $curves[0];
rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp 1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv[*]");
	string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 2 ); 
//Above was Times * 4 

string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`; 
$connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
	float $step = $numEPrealNum2;  
	$curve = "curve -d 3";
	float $curveMin = $curveM;
int $Par = 0;
int $a;
int $ii = 0;	
  for($a = 0; $a <= $step;$a++){
$ii = $ii + 1;
  	$t =  $a/$step;
 	$Par = ($a/$step);
	setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
  	float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
	float $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
		if ( $CurvatureRadi <= $curveMin){ PAUSE;
	$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
	}

if (( $CurvatureRadi > $curveMin) && ( $ii == 1 )){
$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
}


if (( $CurvatureRadi > $curveMin) && ( $Par == 1.0 )){
$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
}

}

string $Newcurvez = `eval($curve)`;
string $Newcurve[] = {$Newcurvez};
delete $paramlocatorpointOnCurvex $spaceLocatorB; 
delete $curves;
rename $Newcurve $myCurve;  
$Newcurve = {$myCurve};

return $Newcurve; 
}




proc string[] SmoothCurvatureReverse6(float $curveM ){

string $curves[] = `ls -sl`;
string $myCurve = $curves[0];
rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp 1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv[*]");
	string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 2 ); 
//Above was Times * 4 

string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`; 
$connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
	float $step = $numEPrealNum2;  
	$curve = "curve -d 3";
	float $curveMin = $curveM;
int $Par = 0;
int $a;
int $ii = 0;	
  for($a = 0; $a <= $step;$a++){
$ii = $ii + 1;
  	$t =  $a/$step;
 	$Par = ($a/$step);
	setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
  	float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
	float $CurvatureRadi = `getAttr ($paramlocatorpointOnCurvex + ".curvatureRadius")`;
		if ( $CurvatureRadi >= $curveMin){
	$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
	}

if (( $CurvatureRadi < $curveMin) && ( $ii == 1 )){
$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
}


if (( $CurvatureRadi < $curveMin) && ( $Par == 1.0 )){
$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
}

}

string $Newcurvez = `eval($curve)`;
string $Newcurve[] = {$Newcurvez};
delete $paramlocatorpointOnCurvex $spaceLocatorB; 
delete $curves;
rename $Newcurve $myCurve;  
$Newcurve = {$myCurve};

return $Newcurve; 
}





proc float XpercentLess_thenY(float $Ix, float $Iy){
float $N;
float $Ni;
if ( $Ix > $Iy){
 $Ni = $Ix; $N = $Iy; } else { $N = $Ix;  $Ni = $Iy; }
float $PercentA;
float $PercentB;
$PercentA = ((float($N) / $Ni) * (100) );
$PercentB = 100 - $PercentA;
return $PercentB;
}
//////////////////////////////////////

////////////////////////////////////




////////////////////////////////////////
proc EvalStrait_ARC_or_FreeForm(){
string $curveItem[] = `ls -sl`;
Strait_ARC_or_FreeForm($curveItem, 5.5, 2.5 );
}

//////////////////////////////////////////

proc int Strait_ARC_or_FreeFormFind(string $renamed[], float $ArcN, float $StraitN ){

int $SAF = 0;
string $nameString = $renamed[0];
string $ParentArc[];
//rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001 $renamed;
string $objectB[] = Make_Middle_of_Curve_ParamlocatorZ($renamed);
ResetTranlation($objectB);
string $objectC[] = {$renamed[0], $objectB[0]};
ResetTranlationEach($objectC);
float $objectAcurve = GET_AREA_OF_CURVE ($renamed);
float $objectBcurve = GET_AREA_OF_CURVE ($objectB);
/////////////////////////

float $PercentDiff = XpercentLess_thenY($objectBcurve, $objectAcurve);

float $objectAcurveL = arclen ($renamed);
float $objectBcurveL = arclen ($objectB);
float $PercentDiffL = XpercentLess_thenY($objectBcurveL, $objectAcurveL);
float $PercentAverage = ($PercentDiff + $PercentDiffL) /2;

vector $VectorCurveEndZ[] = VecCurveEnds($renamed);
float $posA[] =  $VectorCurveEndZ[0];
float $posB[] =  $VectorCurveEndZ[1];
string $CurveBetween[] = MakeCurveBetweenFloats($posA, $posB);
ResetTranlation($CurveBetween);
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001 $CurveBetween;
float $objectCcurveL = arclen ($CurveBetween);
float $PercentDiffS = XpercentLess_thenY($objectCcurveL, $objectAcurveL);
print ("PercentDiff_Curve_to_Arc AREA "+$PercentDiff + "\n");
print ("PercentDiff_Curve_to_Arc L "+$PercentDiffL + "\n");
print (" " + "\n");
print ("PercentDiff_Curve_to_Arc Average "+$PercentAverage + "\n");
print (" " + "\n");
print ("PercentDiff_Curve_to_STRAIT "+$PercentDiffS + "\n");

string $DeleteCurveA[];
string $DeleteCurveB[];
 
if (($PercentAverage< $ArcN) && ($PercentDiffS > $StraitN)){
print ("ARC Curve"+ "\n"); $SAF = 0;

}else if ($PercentDiffS < $StraitN){
print ("STRAIT Curve"+ "\n"); $SAF = 1;

} else { 
print ("FREEFORM Curve"+ "\n"); $SAF = 2;
 }

delete $CurveBetween  $objectB;

return $SAF; 

}



proc int AddorSubtract(int $Number, int $AorS){

if ($AorS == 1){ $Number++; return $Number;} 
if ($AorS == 0){ $Number--; return $Number;}
if ($AorS == 2){ $Number = 0; return $Number;}  

}
//////////////////////////////////////////////////

  proc float RoundFloat(float $val,float $dec){
  	$sign = `sign $val`;
  	float $dec = `pow 10 $dec`;
  	$val = (int) (($val + $sign*5/($dec*10)) * $dec);
  	$val = ($val / $dec);
  	return $val;
  }

//////////////////////////////////////




proc int IsCircle() {

//StraitCurves SCRIPT

int $IsCircle = 0;

string $ObjectCurve[];
string $StraitCurve[];
$ObjectCurve = `ls -selection`;
xform -cp;
resetPivot;
duplicatePreset(1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1);
string $ObjectCurveduplicate[];

$ObjectCurveduplicate = `ls -selection`;
setAttr ($ObjectCurveduplicate[0] + ".translate") 0 0 0;
setAttr ($ObjectCurveduplicate[0] + ".rotate") 0 0 0;
playButtonStepForward; select -cl  ;

float $rotationz[];
$rotationz = `xform -q -rotation $ObjectCurve`;
float $translationz[];
$translationz = `xform -q -translation $ObjectCurve`;
float $ArcLength = `arclen $ObjectCurve[0]`;

float $bbox[] = `exactWorldBoundingBox $ObjectCurveduplicate`;
print("Bounding box ranges from: " +
      $bbox[0] + "," + $bbox[1] + "," + $bbox[2] + ", to " +
      $bbox[3] + "," + $bbox[4] + "," + $bbox[5] + ".\n");


spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
move -ws $bbox[0] $bbox[1] $bbox[2] BoxspaceLocatorA;
spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
move -ws $bbox[3] $bbox[4] $bbox[5] BoxspaceLocatorB;
spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
move -ws $bbox[3] $bbox[1] $bbox[2] BoxspaceLocatorC;
spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
move -ws $bbox[0] $bbox[4] $bbox[5] BoxspaceLocatorD;
spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;

// xform -query -worldSpace -translation;


float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox[2]};
float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox[5]};
float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox[2]};
float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox[5]};

$BoxPointA = `MakeCleanFloats($BoxPointA)`;
$BoxPointB = `MakeCleanFloats($BoxPointB)`;
$BoxPointC = `MakeCleanFloats($BoxPointC)`;
$BoxPointD = `MakeCleanFloats($BoxPointD)`;

float $BoxMPointAC[] = MidPointBetween($BoxPointA, $BoxPointC);
float $BoxMPointBD[] = MidPointBetween($BoxPointB, $BoxPointD);
float $BoxMPointAD[] = MidPointBetween($BoxPointA, $BoxPointD);
float $BoxMPointBC[] = MidPointBetween($BoxPointB, $BoxPointC);
//   MoveObjectSelection($BoxMPointAC);

///////////////////////////////
///////////////////////////////

float $CrossMPointAB[] = MidPointBetween($BoxPointA, $BoxPointB);

// BoxspaceLocatorMiddle CHANGES need here in the future

float $translationzMiddle[];
$translationzMiddle = $CrossMPointAB;


float $CurveCVzero[] = GetCurveCVposENDS($ObjectCurveduplicate, 0);
float $CurveCVLast[] = GetCurveCVposENDS($ObjectCurveduplicate, 1);
float $distanceBetween = PointsGetDistanceFLOAT($CurveCVzero, $CurveCVLast);

int $pA1 = PointsEquivalentTol($CurveCVzero,$BoxPointA); 
int $pA2 = PointsEquivalentTol($CurveCVLast,$BoxPointA);
int $pC1 = PointsEquivalentTol($CurveCVzero,$BoxPointC); 
int $pC2 = PointsEquivalentTol($CurveCVLast,$BoxPointC); 

int $AorC = 0;
if (($pA1 == 3) || ($pA2 == 3)){
$AorC = 1;
}
if (($pC1 == 3) || ($pC2 == 3)){
$AorC = 2;
}  
float $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
float $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);

float $distanceC = PointsGetDistanceFLOAT($BoxPointA, $BoxPointD);

float $distanceAverage =  (($distanceA + $distanceB) * (0.5)) ;
float $radiusX = ( $distanceAverage / 2.0);

float $distanceAverageA = $distanceC ;
float $radiusXA = (($distanceC) * (0.5)) ;
// Result: 38.390151 // 

float $Pi = 3.141593;
float $circleArc = (($Pi) * ($distanceC));

float $percentLess = XpercentLess_thenY( $circleArc, $ArcLength);

float $squarePercentA;
float $squarePercentB;

if ( $distanceA > $distanceAverage) {
$squarePercentA = (( $distanceAverage / $distanceA ) * (100));
}

if ( $distanceA < $distanceAverage) {
$squarePercentA = (( $distanceA / $distanceAverage ) * (100));
}

if ( $distanceB > $distanceAverage) {
$squarePercentB = (( $distanceAverage / $distanceB ) * (100));
}
if ( $distanceB < $distanceAverage) {
$squarePercentB = (( $distanceB / $distanceAverage ) * (100));
}
/////////////////////


int $squareA = 0;
int $squareB = 0;
if ( $squarePercentA > 55){
$squareA = 1; 
}
if ( $squarePercentB > 55){
$squareB =  1; 
}

string $StraitCurve[];

$addSquareResults = ($squareA + $squareB);
if (( $addSquareResults == 2 ) && ( $percentLess < 12.0 )) {
$IsCircle = 1;

} else { 
// Not Diagonal curves
$IsCircle = 0;
}

/*
setAttr ($StraitCurve[0] + ".rotateX") $rotationz[0];
setAttr ($StraitCurve[0] + ".rotateY") $rotationz[1];
setAttr ($StraitCurve[0] + ".rotateZ") $rotationz[2];
setAttr ($StraitCurve[0] + ".translateX") $translationz[0];
setAttr ($StraitCurve[0] + ".translateY") $translationz[1];
setAttr ($StraitCurve[0] + ".translateZ") $translationz[2];
*/

select -r $ObjectCurveduplicate BoxspaceLocatorA BoxspaceLocatorB BoxspaceLocatorC BoxspaceLocatorD BoxspaceLocatorMiddle;
delete;
print ("IsCircle " + $IsCircle);
print ("percentLess " + $percentLess);
print ("addSquareResults " + $addSquareResults);
return $IsCircle;

}




//////////////////////////////////////////
//////////////////////////////////////////
//////////////////////////////////////////
//////////////////////////////////////////

//////////////////////////////////////////
//////###START_OF_CURVE_SCRIPTJOB##///////

global string $EdgeCurveZ2[];
global int $plainNum;

print $EdgeCurveZ2; 
print $plainNum; 
clear $EdgeCurveZ2; 
global int $plainNum = 0;
toggleUIComponentVisibility "Channel Box / Layer Editor";
toggleUIComponentVisibility "Command Line";
toggleUIComponentVisibility "Time Slider";
toggleUIComponentVisibility "Range Slider";
restoreLastPanelWithFocus(); updatePrefsMenu();

//string $shortname = "SEisnotLocSESet";
//select -r -ne $shortname;








proc AdvancedCurveMODprojectTAN(string $INarrayA[], int $plainNum ){

float $eachCVposSTART[];
float $eachCVposEND[];
string $MakespaceLocatorSTART[];
string $MakespaceLocatorEND[];
string $digitalSkeletonA[];

string $NewStraitCurve[];

$numInts = size($digitalSkeletonA);
if ( $numInts > 0 ){
clear $digitalSkeletonA;
}


$digitalSkeletonA = `StartofCurveScriptIntersectZX`;
//Huge re-occuring problem is here

string $AllCurveZ[];
$numInts = size($AllCurveZ);
if ( $numInts > 0 ){
clear $AllCurveZ;
} 
string $AllSpaceLocatorZ[];
$numInts = size($AllSpaceLocatorZ);
if ( $numInts > 0 ){
clear $AllSpaceLocatorZ;
} 
string $renamed[];
string $rebuildit[];
string $ZIntersectionCurveZA[];
string $intersectionCurve[]; 
string $MakeSpaceLocator[];
string $objectLocaterz[];
string $AllparamlocatorZ[];
clear $AllparamlocatorZ;
string $intersectZ[];
string $surf[];
string$ZBetween[];
string $objectCurve[];
float $EACHCVposA[];
float $EACHCVposB[];
float $p1Z; 	
int $moveCurve = 0;
int $SE = 0;

setAttr "subCurve1.minValue" 0.85;
setAttr "subCurve2.minValue" 0.85;

$surf[0] = ("IntersectLoftZ");

string $objectSelection[] = `editDisplayLayerMembers -q layerCurvesINRange1`;
int $EdgecurvesizeNUM = size($objectSelection);
	string $each;
for ($each in $objectSelection) {

	string $iSurf[] = `extrude -ch 1 -et 0 -l 0.05 -n AxisSelection ( $each )`;
if (catchQuiet($intersectZ = `intersect -ch 0 -cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ $iSurf[0] $surf[0]`)){
	
	delete `ls -sl`;
	} else {
///////////////GATHER ALL BUILDING STRUCTURE/////////##

///////////////
$objectCurve[0] = $each;
appendStringArray($AllCurveZ, $objectCurve, 1);
delete $intersectZ;
delete $iSurf;
}
}

setAttr "subCurve1.minValue" 0.0;
setAttr "subCurve2.minValue" 0.0;

setAttr "subCurve1.maxValue" 0.15;
setAttr "subCurve2.maxValue" 0.15;



int $EdgecurvesizeNUM = size($objectSelection);
	string $each;
for ($each in $objectSelection) {

	string $iSurf[] = `extrude -ch 1 -et 0 -l 0.05 -n AxisSelection ( $each )`;
if (catchQuiet($intersectZ = `intersect -ch 0 -cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ $iSurf[0] $surf[0]`)){
	
	delete `ls -sl`;
	} else {
///////////////GATHER ALL BUILDING STRUCTURE/////////##

///////////////
$objectCurve[0] = $each;
appendStringArray($AllCurveZ, $objectCurve, 1);
delete $intersectZ;
delete $iSurf;
}
}

setAttr "subCurve1.maxValue" 1.0;
setAttr "subCurve2.maxValue" 1.0;


  string $shorterListA[] = stringArrayRemoveDuplicates($AllCurveZ);
$AllCurveZ = $shorterListA;

/////////////////////////////////////////////////////
if (size($AllCurveZ) > 2){
print "Intersected 2 Curves";
string $ItemListsZ[];
$ItemListsZ = `CompareCurveIntersect($AllCurveZ)`;
  string $diffCurvesSame[] = stringArrayRemoveExact($ItemListsZ, $AllCurveZ);
if (size($diffCurvesSame) == 1){
ResetTranlationEach($ItemListsZ);
ArrayInsertAtEnd( $ItemListsZ, $diffCurvesSame[0]);
 string $NearestCurvesSame[] = NearestObjectArray(1, $ItemListsZ);
string $TwoCurvesBest[];
ArrayInsertAtEnd( $TwoCurvesBest, $diffCurvesSame[0]);
ArrayInsertAtEnd( $TwoCurvesBest, $NearestCurvesSame[0]);
$objectSelection = $TwoCurvesBest;
}
}
/////////////////////////////////////////////////////

setAttr "subCurve1.minValue" 0.85;
setAttr "subCurve2.minValue" 0.85;

$EdgecurvesizeNUM = size($objectSelection);
	string $each;
for ($each in $objectSelection) {

	string $iSurf[] = `extrude -ch 1 -et 0 -l 0.05 -n AxisSelection ( $each )`;
if (catchQuiet($intersectZ = `intersect -ch 0 -cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ $iSurf[0] $surf[0]`)){
	
	delete `ls -sl`;
	} else {
///////////////GATHER ALL BUILDING STRUCTURE/////////##
appendStringArray($digitalSkeletonA, $iSurf, 1);
appendStringArray($digitalSkeletonA, $intersectZ, 1); 
///////////////
$objectCurve[0] = $each;
string $objectCurveZ[] = `ls -sl -tl 1`;
appendStringArray($AllCurveZ, $objectCurve, 1);
string $curveIntersectZ[];
$curveIntersectZ[0] = `curveIntersect -ch 0 -tolerance 0.00001 $intersectZ $objectCurve[0]`;
string $buffer[];
$numTokens = `tokenize $curveIntersectZ[0] " " $buffer`;
$paramlocatorZ[0] = eval("paramLocator " +  $objectCurve[0] + ".u[" + $buffer[1] + "]");
appendStringArray($AllparamlocatorZ, $paramlocatorZ, 1);
appendStringArray($digitalSkeletonA, $paramlocatorZ, 1);
        float $intersectposA[];	
	$intersectposA = `pointPosition -w $paramlocatorZ[0]`;
string $objectLocaterzA[];
$objectLocaterzA = `spaceLocator -p 0 0 0 -n IntersectZLocaterZ3D`;
move  -ws $intersectposA[0] $intersectposA[1] $intersectposA[2] $objectLocaterzA[0];
///////////
appendStringArray($AllSpaceLocatorZ, $objectLocaterzA, 1);
///////////
}
}

setAttr "subCurve1.minValue" 0.0;
setAttr "subCurve2.minValue" 0.0;

setAttr "subCurve1.maxValue" 0.15;
setAttr "subCurve2.maxValue" 0.15;



$EdgecurvesizeNUM = size($objectSelection);
	string $each;
for ($each in $objectSelection) {

	string $iSurf[] = `extrude -ch 1 -et 0 -l 0.05 -n AxisSelection ( $each )`;
if (catch($intersectZ = `intersect -ch 0 -cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ $iSurf[0] $surf[0]`)){
	
	delete `ls -sl`;
	} else {
///////////////GATHER ALL BUILDING STRUCTURE/////////##
appendStringArray($digitalSkeletonA, $iSurf, 1);
appendStringArray($digitalSkeletonA, $intersectZ, 1); 
///////////////
$objectCurve[0] = $each;
string $objectCurveZ[] = `ls -sl -tl 1`;
appendStringArray($AllCurveZ, $objectCurve, 1);
string $curveIntersectZ[];
$curveIntersectZ[0] = `curveIntersect -ch 0 -tolerance 0.00001 $intersectZ $objectCurve[0]`;
string $buffer[];
$numTokens = `tokenize $curveIntersectZ[0] " " $buffer`;
$paramlocatorZ[0] = eval("paramLocator " +  $objectCurve[0] + ".u[" + $buffer[1] + "]");
appendStringArray($AllparamlocatorZ, $paramlocatorZ, 1);
appendStringArray($digitalSkeletonA, $paramlocatorZ, 1);
        float $intersectposA[];	
	$intersectposA = `pointPosition -w $paramlocatorZ[0]`;
string $objectLocaterzA[];
$objectLocaterzA = `spaceLocator -p 0 0 0 -n IntersectZLocaterZ3D`;
move  -ws $intersectposA[0] $intersectposA[1] $intersectposA[2] $objectLocaterzA[0];
///////////
appendStringArray($AllSpaceLocatorZ, $objectLocaterzA, 1);
///////////
}
}


setAttr "subCurve1.maxValue" 1.0;
setAttr "subCurve2.maxValue" 1.0;

//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////

appendStringArray($digitalSkeletonA, $AllSpaceLocatorZ, size($AllSpaceLocatorZ));
  string $shorterList[] = stringArrayRemoveDuplicates($AllCurveZ);
$AllCurveZ = $shorterList;

 int $CurvesCUTinto = size($AllCurveZ);
if ($CurvesCUTinto == 1){string $oneLocatorZ[] = {$AllparamlocatorZ[0]}; $AllparamlocatorZ = $oneLocatorZ; }

int $numparam = size($AllparamlocatorZ);
if (($CurvesCUTinto == 2) && ($numparam == 4)){
string $oneLocatorZa[] = {$AllparamlocatorZ[0]}; 
string $oneLocatorZb[] = {$AllparamlocatorZ[1]}; 
$AllparamlocatorZ = {$oneLocatorZa[0], $oneLocatorZb[0]}; 
}
$numparam = size($AllparamlocatorZ);

int $numInts = size($AllSpaceLocatorZ);
if (($CurvesCUTinto == 2) && ($numInts == 4)){
string $oneLocatorZ2a[] = {$AllSpaceLocatorZ[0]}; 
string $oneLocatorZ2b[] = {$AllSpaceLocatorZ[1]}; 
$AllSpaceLocatorZ = {$oneLocatorZ2a[0], $oneLocatorZ2b[0]}; 
}
$numInts = size($AllSpaceLocatorZ);



if ( $numparam > 0 ){
//$paramlocatorZ[0] = `rename ParamLocatorShape`;
  string $shorterList[] = stringArrayRemoveDuplicates($AllparamlocatorZ);
$AllparamlocatorZ = $shorterList;
}
$numparam = size($AllparamlocatorZ);
$numInts = size($AllSpaceLocatorZ);
if ( $numparam == 1 ){
float $EACHCVposA[];
$EACHCVposA = `positionOne($AllparamlocatorZ[0])`;
float $EACHCVposA[] = `positionOne($AllparamlocatorZ[0])`;
}
if ( $numparam == 1 ){
float $EACHCVposA[];
$EACHCVposA = `positionOne($AllparamlocatorZ[0])`;
float $EACHCVposA[] = `positionOne($AllparamlocatorZ[0])`;
}

select -cl  ;

print $AllparamlocatorZ ;

//clear $AllparamlocatorZ;

string $MakespaceLocatorZSE[];
string $SEspaceLocSetofSetz = `sets -name SEspaceLocSetofSets`;	
string $paramANDCurve3[] = `paramToCurvePts3( $AllparamlocatorZ )`;

string $paramANDCurve2[] = `paramToCurvePts2( $AllparamlocatorZ )`;
string $paramANDCurve[] = `paramToCurvePts( $AllparamlocatorZ )`;
string $paramCurveNAMES[] = `tokenizeparam( $paramANDCurve )`;
$MakespaceLocatorZSE = EvalMoveCurvesTOend($paramANDCurve, $paramCurveNAMES, $paramANDCurve3, $AllparamlocatorZ, $SEspaceLocSetofSetz);

//select -cl  ;

if (size($MakespaceLocatorZSE) > 0){
appendStringArray($digitalSkeletonA, $MakespaceLocatorZSE, size($MakespaceLocatorZSE));
}
int $setsNumber = `sets -q -size $SEspaceLocSetofSetz`;
if ($setsNumber > 0){
string $subsets[];
$subsets = `sets -q $SEspaceLocSetofSetz`;
//appendStringArray($digitalSkeletonA, $subsets, size($subsets));
}
PAUSE;

/////////////////////
/////////////////////
print $digitalSkeletonA; 


/////////////////////
/////////////////////
if ( $numparam == 0 ){

string $drawcurve[] = {"DrawCurve"}; 


  string $diffArrayRemoveEx[] = stringArrayRemoveExact($drawcurve, $digitalSkeletonA);
$digitalSkeletonA = $diffArrayRemoveEx;

EVALCamScripts2;
string $queryIntersectFormLayerB[] =  `editDisplayLayerMembers -q IntersectFormLayerINRange`  ;


string $NearestIntersectSurfaces[];
string $intersectionCurveSurfaces[];
string $NearestNurbSurfaces[] = $queryIntersectFormLayerB;

$NurbSurfacessizeNUM = size($NearestNurbSurfaces);
	string $eachS;
for ($eachS in $NearestNurbSurfaces) {

if (catch($intersectionCurveSurfaces = `intersect  -ch false -fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves" $eachS`)){
print "not the Surface";	
	} else {  
string $EachSurface[0] = {$eachS};
appendStringArray($NearestIntersectSurfaces, $EachSurface, 1);
}
}
//$intersectionCurveSurfaces = `intersect  -ch false -fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves" $NearestNurbSurfaces `;



if (size($NearestIntersectSurfaces) == 1){
delete $digitalSkeletonA;

print $digitalSkeletonA;

float $CamerasRotationz[];
//float $CamLengthVector[];
//============================================
//float $CamerasDirectionVector[] = nurbsViewDirectionVector(0);
//============================================ ;) nurbsViewDirectionVector =====
string $currPanel = `getPanel -withFocus` , $camera ;
string $Camera = `modelEditor -q -camera $currPanel`;
$CamerasRotationz = `camera -q -rotation $Camera`;



ResetTranlationEach($drawcurve);

// Result: -32.8 81.8 0 // 

string $objs[] = $drawcurve; float $eulerAngles[] = $CamerasRotationz;
// Result: -30.4 110.2 0 // 

//SetAxisOrient2($eulerAngles)

/*
	 makeIdentity -apply true -t 0 -r 1 -s 0 $objs;		
		xform -ws -r -ra 0 0 (-1 * $eulerAngles[2]) $objs;
		xform -ws -r -ra 0 (-1 * $eulerAngles[1]) 0 $objs;
		xform -ws -r -ra (-1 * $eulerAngles[0]) 0 0 $objs;

*/


xform -ws -r -ra (-1 * $eulerAngles[0]) 0 0 $objs;
xform -ws -r -ra 0 (-1 * $eulerAngles[1]) 0 $objs;
xform -ws -r -ra  0 0 (-1 * $eulerAngles[2]) $objs;

float $curveTranslation[] = `getAttr ($drawcurve[0] +".translate") `;
float $curveRotation[] = `getAttr ($drawcurve[0] +".rotate") `;
select -r $drawcurve;
int $TrueorFalseCircle = `IsCircle`;
if ($TrueorFalseCircle == 1){
/////////////////////////////////////////////////////////////////////////////00000000000000000000000000000000000

string $newCircle[] = `CIRCLESCRIPTZ($drawcurve)`;
rotate -r -os 90 0 0 ;

        float $eachCVpos[] = $curveTranslation;	
$MakeIntersectCurvez[0] = `curve -d 1 -p 0 0 0 -p 12 0 0 -k 0 -k 1 -n IntersectCurve` ;
extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos[2] $MakeIntersectCurvez[0];
aimConstraint -offset 0 0 0 -weight 0.5 -aimVector -1 0 0 -upVector 0 0 -1 -worldUpType "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM   $MakeIntersectCurvez[0];

string $iSurfC[] = `extrude -ch 1 -et 0 -l 0.05 -n AxisSelection $MakeIntersectCurvez`;
string $intersectionCurveSurfacesXC[0] = `intersect  -ch false -fs 0 -cos 0 -tol 0.001 $iSurfC[0] $NearestIntersectSurfaces[0]`;
print $intersectionCurveSurfacesXC[0];
string $Smallcurves[] = `listRelatives $intersectionCurveSurfacesXC[0]`;
ResetTranlationEach($Smallcurves);
string $ItemListsZC[] = $Smallcurves;
ArrayInsertAtEnd( $ItemListsZC, $newCircle[0]);
 string $NearestCutCurves[] = NearestObjectArray(1, $ItemListsZC);
select -r $NearestCutCurves;
select -cl  ;
select -r $intersectionCurveSurfacesXC;
string $objectCurveZ3[] = `ls -sl -tl 1`;

string $curveIntersectZ3[];
$curveIntersectZ3[0] = `curveIntersect -ch 0 -tolerance 0.00001 $NearestCutCurves[0] $MakeIntersectCurvez[0]`;
print $curveIntersectZ3[0]; 
string $buffer3[];
$numTokens3 = `tokenize $curveIntersectZ3[0] " " $buffer3`;
$paramlocatorZ3[0] = eval("paramLocator " +  $NearestCutCurves[0] + ".u[" + $buffer3[1] + "]");
     float $intersectposCIRCLE[];	
	$intersectposCIRCLE = `pointPosition -w $paramlocatorZ3[0]`;
print $curveTranslation;
float $distanceCAMCircle_to_Surface = PointsGetDistanceFLOAT($intersectposCIRCLE, $curveTranslation);
move  -ws $intersectposCIRCLE[0] $intersectposCIRCLE[1] $intersectposCIRCLE[2] $newCircle;
setAttr ($newCircle[0] + ".scale") $distanceCAMCircle_to_Surface $distanceCAMCircle_to_Surface $distanceCAMCircle_to_Surface;
delete $paramlocatorZ3 $Smallcurves $intersectionCurveSurfacesXC $iSurfC $MakeIntersectCurvez $intersectionCurveSurfaces;


normalConstraint -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $NearestIntersectSurfaces $newCircle;

string $DupCircleA[] =`duplicate -rr $newCircle`;
move -r -os -wd 0 9 0 $DupCircleA;

string $DupCircleB[] =`duplicate -rr $newCircle`;
move -r -os -wd 0 -8 0 $DupCircleB;
string $LofCircle[] = `loft -ch 1 -u 1 -c 0 -ar 1 -d 1 -ss 2 -rn 0 -po 0 -rsn true $DupCircleA $DupCircleB`;

string $circularFill[] = `circularFillet -ch true -pr -0.5461 -sr -0.5461 -pt 0.001 -tt 0.1 -cos true $LofCircle[0] $NearestIntersectSurfaces[0]`;
print $LofCircle;
print $circularFill;
string $TransformA[] = `listRelatives $LofCircle[0]`; string $TransformB[] = `listRelatives $circularFill[1]`;
string $trimedsurfaceCircle[] = `trim -ch on -o on -rpo off -lu 1.5 -lv 1.5 $TransformA[0] $TransformB[0]`;
trim -ch on -o on -rpo on -lu 5.5 -lv 5.5 $TransformA $TransformB ;
//trim -ch on -o on -rpo off -lu 0.0278738 -lv 0.475455 nurbsSphereShape1 transform2_Shape1 ;

}
}


if (size($NearestIntersectSurfaces) == 0){
 
print ("numparam IS 0" + "\n");
print ("numparam IS 0" + "\n");

string $intersectionCurveMake1[];
$intersectionCurveMake1 = `intersect  -ch false -fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves" "Xplane" `;
string $theintersect[];
$theintersect = $intersectionCurveMake1;
string $theintersectCURVEs[];
$theintersectCURVEs = `listRelatives -children $theintersect`;
parent -w $theintersectCURVEs;
select -r $theintersectCURVEs;

int $curveTypeSwitchC = `IsCircle`;
int $curveTypeSwitch;

if ( $curveTypeSwitchC == 1 ){

eval("int $plainNum = 5;");
delete $theintersect; delete $theintersectCURVEs; delete $digitalSkeletonA;
} else { $curveTypeSwitch = Strait_ARC_or_FreeFormFind($theintersectCURVEs, 8, 2.5 ); }


if (( $curveTypeSwitch < 2 ) && ($curveTypeSwitchC == 0)){
select -r $theintersectCURVEs;
$NewStraitCurve = `StraitCurvesSCRIPTZ`;

print $NewStraitCurve;
select -r $NewStraitCurve;
float $angleofStraitCurve[] = `EulerAngleofCurve`;
float $angleYofStraitCurve = $angleofStraitCurve[1];
float $angleNumberZ = RoundFloat($angleYofStraitCurve, 1);


if ( $angleNumberZ == 45.0){
polySphere -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 -ch 1;
$plainNum = 1; eval("int $plainNum = 1;");
}
if ( $angleNumberZ == -45.0){
polyCube -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 1;
$plainNum = 2; eval("int $plainNum = 2;");
}
if ( $angleNumberZ == 0.0){
$plainNum = 3; eval("int $plainNum = 3;");
}
if (( $angleNumberZ == -90.0) || ( $angleYofStraitCurve == 90.0)) {
polyCylinder -r 1 -h 2 -sx 20 -sy 1 -sz 2 -ax 0 1 0 -rcp 0 -cuv 3 -ch 1;
$plainNum = 4; eval("int $plainNum = 4;");
}
eval ("print $plainNum;");

delete $theintersect;
delete $NewStraitCurve;
delete $digitalSkeletonA;
} 

if (( $curveTypeSwitch == 2 )&& ($curveTypeSwitchC == 0)){ $plainNum = 0; eval("int $plainNum = 0;"); 
delete $theintersect; delete $theintersectCURVEs; delete $digitalSkeletonA;
 }

//if No surface intersect
}


} else if ( $numparam == 1 ){

print ("numparam IS 1" + "\n");
print ("numparam IS 1" + "\n");

//ONE LOCATOR // print $AllSpaceLocatorZ;
//ONE LOCATOR /////////////////////////////////////////////


//appendStringArray($digitalSkeletonA, $AllSpaceLocatorZ, 1);
string $objectSelection[0] = $AllSpaceLocatorZ;
string $cameraANDlocator[];
$cameraANDlocator[0] = "LiveSurfaceB"; 
float $point1[];
float $point2[];
	$point1 = `xform -query -worldSpace -translation ( $objectSelection[0])`;
	$point2 = `xform -query -worldSpace -translation ( $cameraANDlocator[0])`;
$dx = $point1[0] - $point2[0];
$dy = $point1[1] - $point2[1];
$dz = $point1[2] - $point2[2];
float $distance;
 $distance = `sqrt( ($dx * $dx) + ($dy * $dy) + ($dz * $dz) )`;
$scalePlane = $distance;
nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr 1 -n "cutingplaneAlign";
scale -r $scalePlane $scalePlane $scalePlane;
performRebuildSurfaceSet 1 1 0 0.001 4 4 3 3 1 2 1 0 2 1 0.05 0 0;
if ($plainNum == 0){
setAttr "cutingplaneAlign.rotateX" (`getAttr ("ZCURVEModelingCAM" + ".rotateX")`+90);
setAttr "cutingplaneAlign.rotateY" `getAttr ("ZCURVEModelingCAM" + ".rotateY")`;
setAttr "cutingplaneAlign.rotateZ" `getAttr ("ZCURVEModelingCAM" + ".rotateZ")`;
}

//  float $angleofStraitCurve[] = `EulerAngleofCurve`;

if ($plainNum == 1){ setAttr cutingplaneAlign.rotateZ 90; setAttr cutingplaneAlign.rotateX 45; }
if ($plainNum == 2){ setAttr cutingplaneAlign.rotateZ 90; setAttr cutingplaneAlign.rotateX -45; }
if ($plainNum == 3){ setAttr cutingplaneAlign.rotateZ 90; }
if ($plainNum == 4){ setAttr cutingplaneAlign.rotateX 90; } 
if ($plainNum == 5){ setAttr cutingplaneAlign.rotate 0.0 0.0 0.0; } 
print $objectSelection; 
        float $Locaterpos[];	
	$Locaterpos = `pointPosition -w ( $objectSelection[0] )`;
	move  -ws $Locaterpos[0] $Locaterpos[1] $Locaterpos[2] cutingplaneAlign ;
string $intersectionCurveMake1[];
$intersectionCurveMake1 = `intersect  -ch false -fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves" "cutingplaneAlign" `;
PAUSE;
string $theintersect[];
$theintersect = $intersectionCurveMake1;
string $theintersectCURVEs[];
$theintersectCURVEs = `listRelatives -children $theintersect`;
parent -w $theintersectCURVEs;
delete $theintersect;
select -r $theintersectCURVEs $AllCurveZ;

	 string $bufferCutCurve[];
	string $ZIntersectionCurveZ[];
	string $afterCut[];
	string $numTokensZ;
	int $n, $i;

cutCurvePreset(1,1,0.001,6,-0.7767,0.1104,-0.6201,1,2);
	$afterCut = `ls -sl`;
		$n = size($afterCut);
		for( $i=0; $i<$n; $i+=1 ) {
			// Now, two of these are bad, two are OK:
			if( `getAttr ($afterCut[$i] + ".spans")` < 1){ delete $afterCut[$i];
			} else {			
$numTokensZ = `tokenize $afterCut[$i] "." $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; }
		}
string $ZIntersectionCurveZA[];
 $ZIntersectionCurveZA = `listRelatives -shapes $ZIntersectionCurveZ`;


string $renamed[]; 
$renamed[0] = `rename $ZIntersectionCurveZ Curve`;
ResetTranlation($renamed);

//FindclosetTOcurveENDz($EACHCVposAZ, $EACHCVposBZ, float $b1[])

string $CurveSelection[]; 
int $numCVs = `getAttr -size ($renamed[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($renamed[0] + ".cv[0]") ;			
$CurveSelection[1] = ($renamed[0] + ".cv[" + $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA  )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}

//print $MakespaceLocatorZSE[0]
//select -r $MakespaceLocatorZSE;
 
if (size($MakespaceLocatorZSE) > 0){
int $ZEROorONE;
 int $foundA = stringArrayGmatch("SEspaceLocatorSTART3DZ*", $MakespaceLocatorZSE);
 int $foundB = stringArrayGmatch("SEspaceLocatorEND3DZ*", $MakespaceLocatorZSE);
if (( $foundA == 1 ) || ( $foundB == 1 )) {
float $eachCVposSTART[] = `pointPosition -w ($MakespaceLocatorZSE[0])`;
float $movePIVOT[];
$ZEROorONE = FindclosetTOcurveENDz($EACHCVposAZ, $EACHCVposBZ, $eachCVposSTART);
if ( $ZEROorONE == 0){ $movePIVOT = $EACHCVposAZ; move $movePIVOT[0] $movePIVOT[1] $movePIVOT[2] ($renamed[0] + ".scalePivot") ($renamed[0] +                     ".rotatePivot") ;}
if ( $ZEROorONE == 1){ $movePIVOT = $EACHCVposBZ; move $movePIVOT[0] $movePIVOT[1] $movePIVOT[2] ($renamed[0] + ".scalePivot") ($renamed[0] +                     ".rotatePivot") ; }

move -rpr $eachCVposSTART[0] $eachCVposSTART[1] $eachCVposSTART[2] $renamed[0];
xform -cp $renamed[0];
}
}



if (size($MakespaceLocatorZSE) == 0){
string $paramANDCurveA2[];
$paramANDCurveA2 = `paramToCurvePts2( $AllparamlocatorZ )`;
string $detachCurve1[] = `detachCurve -ch off -replaceOriginal off $paramANDCurveA2[0]`;

delete $AllCurveZ;
string $AllCurveZ2[];
string $newCurves1[];
for ($each in $detachCurve1){
string $newCurve;
$newCurve = `rename $each Curve`;
ArrayInsertAtEnd( $newCurves1, $newCurve);
}
string $objectLayerCurvesRange[] = `queryLayerRangeMembers`;

$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);
  string $diffdigitalSkeleton[] = stringArrayRemoveExact($AllparamlocatorZ, $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;

$AllCurveZ = $newCurves1;

}

delete $digitalSkeletonA cutingplaneAlign;
ResetTranlation($renamed);

//print $renamed; 
//select -r $renamed; 

string $renamed2[];
$renamed2 = $renamed;
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

// IF Drawn Curve is connected to the end of another curve thast is in EdgeSet
// the curve drawn can be on a edge curve which is eather protruding from the ZY plain 
// or it lies on the ZY plain. if it is at one of the two ends of a protruding EdgeCurve
// then the drawn curve intersecting at EdgeCurves Ends is eather also protruding from ZY plain or 
// is positioned freely at the other end.. which means it could be crossing the ZY plain which means     
 // It would need to be cut

int $ifNearEnds = size($MakespaceLocatorZSE);
int $AllCurveCVsZeroAndLast = FindIfCurveISonZ($AllCurveZ);
int $edgeZsetA = `sets -im ZEdgeCurvesSet $AllCurveZ[0]`;
int $ZeroX = 0;

if (( $ifNearEnds == 1) && ( $AllCurveCVsZeroAndLast == 1) && ( $edgeZsetA == 1)) {

vector $AllCurveCVENDs[] = `VecCurveEnds($AllCurveZ)`;
vector $renamed2CVENDs[] = `VecCurveEnds($renamed2)`;

float $renamed2CVENDAs[] = $renamed2CVENDs[0];
float $renamed2CVENDBs[] = $renamed2CVENDs[1];
float $AllCurveCVENDAs[] = $AllCurveCVENDs[0];
float $AllCurveCVENDBs[] = $AllCurveCVENDs[1];

float $FloatZ1[] = $renamed2CVENDAs;
float $FloatZ2[] = $renamed2CVENDBs;
float $FloatZ3[] = $AllCurveCVENDAs;
float $FloatZ4[] = $AllCurveCVENDBs;

$renamed2CVENDAs = `MakeCleanFloats($FloatZ1)`;
$renamed2CVENDBs = `MakeCleanFloats($FloatZ2)`;
$AllCurveCVENDAs = `MakeCleanFloats($FloatZ3)`;
$AllCurveCVENDBs = `MakeCleanFloats($FloatZ4)`;

int $CombA = PointsEquivalentTol($renamed2CVENDAs, $AllCurveCVENDAs);
int $CombB = PointsEquivalentTol($renamed2CVENDBs, $AllCurveCVENDBs);
int $CombC = PointsEquivalentTol($renamed2CVENDAs, $AllCurveCVENDBs);

float $intersectFloat[];
if ($CombA == 3 ){ $intersectFloat = $AllCurveCVENDAs;}
if ($CombB == 3 ){ $intersectFloat = $AllCurveCVENDBs;}
if ($CombC == 3 ){ $intersectFloat = $AllCurveCVENDBs;}
print $intersectFloat;
float $Zero0x = 0.0;
$ZeroX = equivalentTol($Zero0x, $intersectFloat[0], 0.001);

}

print ("intersect on ZY Plain " + $ZeroX); 

$intZplainF = 1;
if ($ZeroX == 1){
$intZplainF = `ZplainFlatten`;
if($intZplainF == 0){
FlattenCurveToZplain($renamed);
}
}

if ($AllCurveCVsZeroAndLast == 2){
$intZplainF = `ZplainFlatten`;
if($intZplainF == 0){
FlattenCurveToZplain($renamed);
}
}


int $trueORfalse = 0;
int $trueORfalse2 = 0;

if ($ZeroX == 0){
$trueORfalse = FindIfCurveCrossesZ($renamed2);
print ("IF_Curve_Crosses_Z True-OR-False"+" "+$trueORfalse);
string $newname[]; 
if (($trueORfalse == 1) && ($ZeroX == 0)){
$newname = CutCurveIFConditionTRUETransitZ($renamed2);
$trueORfalse2 = 1;
ResetTranlation($newname);
rename $newname $renamed; 
}
}  

/////////////////////////////////

print $renamed;
print $renamed2;
print "check Here777777777777777777777";
string $newnamed[0] = {$renamed2[0]};
ResetTranlation($renamed);

string $ParentArc[];
$ParentArc = Strait_ARC_or_FreeForm($newnamed, 5.5, 2.5 );

if($intZplainF > 0)  {
print "check Here MirrorANDrename";
print $ParentArc;
select -r $ParentArc;
MirrorANDrename($ParentArc);
}

if (($ZeroX == 1) || ($trueORfalse2 == 1)){
sets -include ZEdgeCurvesSet $ParentArc;
 }
print "check Here5";

print $ParentArc[0]; 

////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
//delete $renamed;

ArrayInsertAtEnd( $INarrayA, $ParentArc[0]);

////////////////////////////////ADDON
print "check Here6";
ResetTranlation($ParentArc);
editDisplayLayerMembers -noRecurse layerCurvesINRange1 $ParentArc;
select -r $ParentArc[0];
EvalAddingCurves;
EvalcreatSphere;



//////////////////////////////////////END OF ONE CURVE
//////////////////////////////////////

} else if ( $numparam > 2 ){

//
//appendStringArray($digitalSkeletonA, $AllSpaceLocatorZ, size($AllSpaceLocatorZ));

if (size($MakespaceLocatorZSE) > 0){
appendStringArray($digitalSkeletonA, $MakespaceLocatorZSE, size($MakespaceLocatorZSE));
}
delete $digitalSkeletonA;
//////////////////////////////////////
//////////////////////////////////////

} else if ( $numparam == 2 ){

//////////////////////////////////////
//////////////////////////////////////
print ("numparam IS 2" + "\n");
print ("numparam IS 2" + "\n");

int $boundSurfTrigger = 0;

string $BoundaryA[];
string $NewboundryA[];
string $objectCurveIntersectAZ[] = CompareCurveIntersect($AllCurveZ );

string $objectLayerCurvesRangeA[] = `queryLayerRangeMembers`;
//ResetTranlationEach($objectLayerCurvesRangeA);
int $numberofAllcurves = size($objectLayerCurvesRangeA);

if ($numberofAllcurves > 3){

  string $diffNearestCurvesWithIntersectsA[] = stringArrayRemoveExact($AllCurveZ, $objectLayerCurvesRangeA);
  string $diffNearestCurvesWithIntersectsB[] = stringArrayRemoveExact($AllCurveZ, $objectLayerCurvesRangeA);
string $AllCurveZA[0] = {$AllCurveZ[0]};
string $AllCurveZB[0] = {$AllCurveZ[1]};

SecondArrayInsertAtEndofArray( $diffNearestCurvesWithIntersectsA, $AllCurveZA);
SecondArrayInsertAtEndofArray( $diffNearestCurvesWithIntersectsB, $AllCurveZB);
print $diffNearestCurvesWithIntersectsB;
string $allNearcurves[];
print $numberofAllcurves;
if ($numberofAllcurves < 6){ 
  string $diffCurvesAll[] = stringArrayRemoveExact($AllCurveZ, $objectLayerCurvesRangeA);
 $allNearcurves = $diffCurvesAll; }else{
int $ni = 6;
// ifless then 6

	string $NearestCurvesZAi[] = (NearestObjectArray($ni, $diffNearestCurvesWithIntersectsA));
string $NearestCurvesZBi[] = (NearestObjectArray($ni, $diffNearestCurvesWithIntersectsB));
$allNearcurves = $NearestCurvesZAi;
appendStringArray($allNearcurves, $NearestCurvesZBi, size($NearestCurvesZBi));
  string $shorterListA[] = stringArrayRemoveDuplicates($allNearcurves);
$allNearcurves = $shorterListA;
}

string $allNearcurvesIntersects[] = CompareCurveIntersectTwoCurves($AllCurveZ, $allNearcurves);

if (size($allNearcurvesIntersects) == 2 ){
$BoundaryA = `boundary -ch 1 -or 0 -ep 1 -rn 1 -po 0 -ept 0.1 $AllCurveZ[0] $allNearcurvesIntersects[0] $AllCurveZ[1] $allNearcurvesIntersects[1]`;
PAUSE;
$NewboundryA = {$BoundaryA[0]};
appendStringArray($digitalSkeletonA, $NewboundryA, 1);
$boundSurfTrigger = 1;
}
}




print ("boundSurfTrigger " + $boundSurfTrigger);
// select -r $AllCurveZ;

int $paramloc = size($AllparamlocatorZ);
int $paramlocIndexA;
int $paramlocIndexB;
if ($paramloc > 2){
int $paramlocRealIndex = $paramloc -1;
$paramlocIndexA = $paramlocRealIndex -1;
$paramlocIndexB = $paramlocRealIndex;
} else {$paramlocIndexA = 0;
$paramlocIndexB = 1;}

float $EACHCVposA[] = `positionOne($AllparamlocatorZ[$paramlocIndexA])`;
float $EACHCVposB[] = `positionOne($AllparamlocatorZ[$paramlocIndexB])`;
$ZBetween[0] = `curve -d 1 -p $EACHCVposA[0] $EACHCVposA[1] $EACHCVposA[2] -p $EACHCVposB[0] $EACHCVposB[1] $EACHCVposB[2] -k 0 -k 2 -n          ZCurveBetween`;
string $duplicateCurvez1[];
string $duplicateCurvez2[];

$duplicateCurvez1 = `duplicateCurve -ch 0 -rn 0 -local 0  "LiveSurfaceBShape.u[0]" `;
xform -cp $duplicateCurvez1;
$duplicateCurvez2 = `duplicateCurve -ch 0 -rn 0 -local 0  "LiveSurfaceBShape.u[1]" `;
xform -cp $duplicateCurvez2;
ResetTranlation($duplicateCurvez1);
ResetTranlation($duplicateCurvez2);
move  -ws $EACHCVposA[0] $EACHCVposA[1] $EACHCVposA[2] $duplicateCurvez1;
move  -ws $EACHCVposB[0] $EACHCVposB[1] $EACHCVposB[2] $duplicateCurvez2;
//select -r $duplicateCurvez1 $duplicateCurvez2;
string $LoftduplicateCurvez[];
$LoftduplicateCurvez = `loft -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 4 -rn 0 -po 0 -rsn true $duplicateCurvez1 $duplicateCurvez2`;
extendSurface -ch 0 -em 0 -et 2 -d 100 -jn 1 -rpo 1 -es 2 -ed 0  $LoftduplicateCurvez;
PAUSE;

//RESET ITS 000 TRANS
ResetTranlation($ZBetween);
$ZBetweenDUP = `duplicate -rr $ZBetween[0]`;
$ZBetweenDUP2 = `duplicate -rr $ZBetween[0]`;
///////////////GATHER ALL BUILDING STRUCTURE/////////##
appendStringArray($digitalSkeletonA, $ZBetween, 1);
appendStringArray($digitalSkeletonA, $LoftduplicateCurvez, 1);
appendStringArray($digitalSkeletonA, $duplicateCurvez1, 1);
appendStringArray($digitalSkeletonA, $duplicateCurvez2, 1);
appendStringArray($digitalSkeletonA, $ZBetweenDUP, 1);
appendStringArray($digitalSkeletonA, $ZBetweenDUP2, 1);
appendStringArray($digitalSkeletonA, $AllSpaceLocatorZ, 2);
///////////////GATHER ALL BUILDING STRUCTURE/////////##
string $TANGENT[];
string $TANGENTloftA[];
string $TANGENTloft[];
$TANGENTA = `loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 4 -rn 0 -po 0 -rsn true -n TANGENTSURFACE $AllCurveZ[0] $AllCurveZ[1]`;
extendSurface -ch 0 -em 0 -et 0 -d 100 -jn 1 -rpo 1 -es 2 -ed 0 -n $TANGENTA $TANGENTA;
$TANGENT[0] = `curve -d 3 -p 0 0 0 -p 0 0 -1.5 -p 0 0 -3 -p 0 0 -4.5 -k 0 -k 0 -k 0 -k 4.5 -k 4.5 -k 4.5 -n TANGENTCURVE` ;
if ($boundSurfTrigger == 1){ normalConstraint -weight 1 -aimVector 0 0 1 -upVector 0 0 1 -worldUpType "vector" -worldUpVector 1 0 0 $NewboundryA TANGENTCURVE ;
}else{
normalConstraint -weight 1 -aimVector 0 0 1 -upVector 0 0 1 -worldUpType "vector" -worldUpVector 1 0 0 TANGENTSURFACE TANGENTCURVE ;
}
//AVERAGEbetween two Locators
shadingNode -asUtility plusMinusAverage;
rename plusMinusAverageA;
setAttr plusMinusAverageA.operation 3;                                              
connectAttr -force plusMinusAverageA.output3D ( "|" + "TANGENTCURVE" + ".translate");
connectAttr -f ( $AllSpaceLocatorZ[0] + ".translate") plusMinusAverageA.input3D[1];
connectAttr -f ( $AllSpaceLocatorZ[1] + ".translate") plusMinusAverageA.input3D[0];
string $CurveSelection2[]; 
int $numCVs = `getAttr -size ("TANGENTCURVE" + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );			
$CurveSelection2[1] = ("TANGENTCURVE" + ".cv[" + $numCVrealNum + "]") ;
        float $TANGENTCURVEposA[];	
	$TANGENTCURVEposA = `pointPosition -w ( $CurveSelection2[1]  )`;
move  -ws $TANGENTCURVEposA[0] $TANGENTCURVEposA[1] $TANGENTCURVEposA[2] ZCurveBetween1;
$TANGENTloft = `loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 4 -rn 0 -po 0 -rsn true -n PROJECTonTANGENTSURFACE ZCurveBetween ZCurveBetween1`;
PAUSE;
extendSurface -ch 0 -em 0 -et 0 -d 100 -jn 1 -rpo 1 -es 2 -ed 1  "PROJECTonTANGENTSURFACE";
PAUSE;
delete -ch PROJECTonTANGENTSURFACE;
float $TANCURVEAposA[];
	$TANCURVEAposA = `xform -query -worldSpace -translation TANGENTCURVE`;
string $TANGENTZ[];
$TANGENTZ[0] = `curve -d 3 -p 0 0 0 -p -1.5 0 0 -p -3 0 0 -p -4.5 0 0 -k 0 -k 0 -k 0 -k 4.5 -k 4.5 -k 4.5 -n TANGENTCURVEZ` ;
move  -ws $TANCURVEAposA[0] $TANCURVEAposA[1] $TANCURVEAposA[2] TANGENTCURVEZ;
aimConstraint -offset 0 0 0 -weight 0.5 -aimVector -1 0 0 -upVector 0 0 -1 -worldUpType "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM $TANGENTZ;
PAUSE;
///////////////GATHER ALL BUILDING STRUCTURE/////////##
appendStringArray($digitalSkeletonA, $TANGENTZ, 1);
appendStringArray($digitalSkeletonA, $TANGENTA, 1);
appendStringArray($digitalSkeletonA, $TANGENT, 1);
appendStringArray($digitalSkeletonA, $TANGENTloft, 1);
/////////////////////////////////////////////////////##
string $CurveSelectionZ[]; 
int $numCVsA = `getAttr -size ($TANGENTZ[0] + ".controlPoints")`;
int $numCVrealNumA = ( $numCVsA -1 );		
$CurveSelectionZ[0] = ($TANGENTZ[0] + ".cv[" + $numCVrealNumA + "]") ;
string $CurveSelectionX[]; 
int $numCVsB = `getAttr -size ($TANGENT[0] + ".controlPoints")`;
int $numCVrealNumB = ( $numCVsB -1 );			
$CurveSelectionX[0] = ($TANGENT[0] + ".cv[" + $numCVrealNumB + "]") ;
string $CurveSelectionY[]; 
$CurveSelectionY[0] = ($TANGENTZ[0] + ".cv[" + 0 + "]") ;

float $TANZfromTANX2;
$TANZfromTANX2 = GetDistancePointPositionFLOAT($CurveSelectionZ[0], $CurveSelectionX[0]);
        float $p1[];		
	$p1 = `pointPosition -w ( $CurveSelectionZ[0]  )`;
        float $p2[];		
	$p2 = `pointPosition -w ( $CurveSelectionX[0]  )`;
      float $p3[];		
	$p3 = `pointPosition -w ( $CurveSelectionY[0]  )`;
float $mid1[3];
	$mid1 = midPoint2Pts( $p1, $p2 );
string $TANGENTY[];
string $TANGENTloftY[];
$TANGENTY[0] = `curve -d 1 -p $p3[0] $p3[1] $p3[2] -p $mid1[0] $mid1[1] $mid1[2] -k 0 -k 2 -n TANGENTCURVEY`;
appendStringArray($digitalSkeletonA, $TANGENTY, 1);

move  -ws $mid1[0] $mid1[1] $mid1[2] $ZBetweenDUP2;
PAUSE;
$TANGENTloftY = `loft -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 4 -rn 0 -po 0 -rsn true -n PROJECTonTANGENTSURFACEY $ZBetweenDUP2 $ZBetween`;
PAUSE;
extendSurface -ch 0 -em 0 -et 2 -d 100 -jn 1 -rpo 1 -es 2 -ed 2  "PROJECTonTANGENTSURFACEY";
extendSurface -ch 0 -em 0 -et 2 -d 100 -jn 1 -rpo 1 -es 2 -ed 2  "PROJECTonTANGENTSURFACEY";
PAUSE;
appendStringArray($digitalSkeletonA, $TANGENTloftY, 1);

string $queryIntersectFormLayer[];
 $queryIntersectFormLayer = `editDisplayLayerMembers -q IntersectFormLayer`;
if (size( $queryIntersectFormLayer) > 0){
$TANGENTloft[0] = $queryIntersectFormLayer[0]; 
$TANGENTA[0] = $queryIntersectFormLayer[0]; 
$TANGENTloftY[0] = $queryIntersectFormLayer[0]; 
$LoftduplicateCurvez[0] = $queryIntersectFormLayer[0]; 
}



string $rebuildit[];
string $intersectionCurveMake[];
string $intersectionCurve[];
print $boundSurfTrigger;
if ($boundSurfTrigger == 1){ 
$intersectionCurveMake = `intersect  -ch false -fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves" $NewboundryA `;
}else{
$intersectionCurveMake = `intersect  -ch false -fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves" $TANGENTloft[0] `;
}

$intersectionCurve = `listRelatives $intersectionCurveMake`; 
if ((size($intersectionCurve) > 1) || ( $TANZfromTANX2 < 1.25 )) {
	delete $intersectionCurve; 
	delete $intersectionCurveMake;
	string $intersectionCurveMake2[];
	string $intersectionCurve2[];
 
	$intersectionCurveMake2 = `intersect  -ch false -fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves" $TANGENTA[0] `;
	$intersectionCurve2 = `listRelatives $intersectionCurveMake2`;
print $TANGENTA; print "intersectionCurve2"; 
		if (size($intersectionCurve2) > 1){
			delete $intersectionCurve2; 
			delete $intersectionCurveMake2;
			string $intersectionCurveMake3[];
			string $intersectionCurve3[];
 
			$intersectionCurveMake3 = `intersect  -ch false -fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves" $TANGENTloftY[0] `;
			$intersectionCurve3 = `listRelatives $intersectionCurveMake3`;
print "parent intersectionCurve0000000000002";
				if (size($intersectionCurve3) > 1) {
print "parent intersectionCurve0000000000002";
					delete $intersectionCurve3; 
					delete $intersectionCurveMake3;
					string $intersectionCurveMake4[];
					string $intersectionCurve4[];
					$intersectionCurveMake4 = `intersect  -ch false -fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves"   $LoftduplicateCurvez[0] `;
					$intersectionCurve4 = `listRelatives $intersectionCurveMake4`;
					parent -w $intersectionCurve4;
					string $renamed[]; 
					$renamed[0] = `rename $intersectionCurve4 Curve`; 
					$rebuildit = $renamed;
					ResetTranlation($rebuildit);
									} else { 
print "parent intersectionCurve3"; 
parent -w $intersectionCurve3;
//CHANGE
$rebuildit = $intersectionCurve3;
ResetTranlation($rebuildit);
select -r $intersectionCurve3 $AllCurveZ[0];

	 string $bufferCutCurve[];
	string $ZIntersectionCurveZ[];
	string $afterCut[];
	string $numTokensZ;
	int $n, $i;
cutCurvePreset(1,1,0.01,6,-0.7767,0.1104,-0.6201,1,2);
	$afterCut = `ls -sl`;
		$n = size($afterCut);
		for( $i=0; $i<$n; $i+=1 ) {
			// Now, two of these are bad, two are OK:
			if( `getAttr ($afterCut[$i] + ".spans")` < 1){ delete $afterCut[$i];
			} else {			
$numTokensZ = `tokenize $afterCut[$i] "." $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; 
}
		}
//string $ZIntersectionCurveZA[];
// $ZIntersectionCurveZA = `listRelatives -shapes $ZIntersectionCurveZ`;


if (catch(`select -r $bufferCutCurve[0] $AllCurveZ[1]`)){
select -r $intersectionCurve3 $AllCurveZ[1];
	} else { print "hereCUT2"; }


cutCurvePreset(1,1,0.001,6,-0.7767,0.1104,-0.6201,1,2);
	$afterCut = `ls -sl`;
		$n = size($afterCut);
		for( $i=0; $i<$n; $i+=1 ) {
			// Now, two of these are bad, two are OK:
			if( `getAttr ($afterCut[$i] + ".spans")` < 1){ delete $afterCut[$i];
			} else {			
$numTokensZ = `tokenize $afterCut[$i] "." $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; 
}
		}



$renamed[0] = `rename $ZIntersectionCurveZ[0] Curve`;
string $ZIntersectionCurveZB[];
 $ZIntersectionCurveZB = `listRelatives -shapes $renamed`;
if (size($ZIntersectionCurveZB) > 0 ){
string $ListCONCurveZA[];
 $ListCONCurveZA = `listConnections $ZIntersectionCurveZB`;
if (size( $ListCONCurveZA) > 0){
string $ListCONCurveZB[];
 $ListCONCurveZB = `listConnections -shapes 0 -source 0 $ListCONCurveZA`;
delete  $ListCONCurveZA $ListCONCurveZB;
}
}
$rebuildit = $renamed;

}} else {
print "parent intersectionCurve2"; 
parent -w $intersectionCurve2;
print "parent intersectionCurve0002"; 
string $renamed[]; 
$renamed[0] = `rename $intersectionCurve2 Curve`;
print $renamed;
//CHANGE
$rebuildit = $renamed;
print "rebuildit_END";
ResetTranlation($rebuildit); 
print "parent intersectionCurve0000000000002";

print "parent intersectionCurve002"; }
} else {
print "parent intersectionCurve0000000000002";
print "parent intersectionCurve1"; 
$intersectionCurve = `listRelatives $intersectionCurveMake`; 
parent -w $intersectionCurve;
string $renamed[]; 
$renamed[0] = `rename $intersectionCurve Curve`; 
$rebuildit = $renamed;
ResetTranlation($rebuildit);
} 
print $rebuildit;

if ( size($MakespaceLocatorZSE) == 0  ) {


string $paramANDCurveA2[];
$paramANDCurveA2 = `paramToCurvePts2( $AllparamlocatorZ )`;
string $detachCurve1[] = `detachCurve -ch off -replaceOriginal off $paramANDCurveA2[0]`;
string $detachCurve2[] = `detachCurve -ch off -replaceOriginal off $paramANDCurveA2[1]`;
delete $AllCurveZ;
string $newCurves1[];
string $newCurves2[];
for ($each in $detachCurve1){
string $newCurve;
$newCurve = `rename $each Curve`;
ArrayInsertAtEnd( $newCurves1, $newCurve);
}

for ($each in $detachCurve2){
string $newCurve;
$newCurve = `rename $each Curve`;
ArrayInsertAtEnd( $newCurves2, $newCurve);
}

string $objectLayerCurvesRange[] = `queryLayerRangeMembers`;
$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);
ArrayInsertAtEnd( $INarrayA, $newCurves2[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves2[1]);

ResetTranlationEach($newCurves1);
ResetTranlationEach($newCurves2);

  string $diffdigitalSkeleton[] = stringArrayRemoveExact($AllparamlocatorZ, $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;

$AllCurveZ = $newCurves1;
ArrayInsertAtEnd( $AllCurveZ, $newCurves2[0]);
ArrayInsertAtEnd( $AllCurveZ, $newCurves2[1]);
}
//////////////////
PAUSE;

///////////////PROBLEMS HERE ####################

int $ONEspaceLOC = 0;
string $newCurves1[];
if (size($MakespaceLocatorZSE) == 1){
$ONEspaceLOC = 1;

print "MakespaceLocatorZSE_is_ONE";

string $subsetsA[];
$subsetsA = `sets -q $SEspaceLocSetofSetz`;
string $subsetsB[]; string $subsetsB2[];

$subsetsB = `sets -q $subsetsA`;

$subsetsB2[0] = $subsetsB[0];
$subsetsB3[0] = $subsetsB[1];

//print $subsetsA ;
//print $subsetsB ;
//print $subsetsB2;
//print $subsetsB3;


///////////////////////
print $subsetsB2;
print $subsetsB3;
string $SetItemA = ($subsetsB2[0]);
string $SetItemB = ($subsetsB3[0]);

string $subsetItemNeeded[];

int $setATrueFalse = `gmatch $SetItemA "*->*"`;
int $setBTrueFalse = `gmatch $SetItemB "*->*"`;
if ($setATrueFalse == 1){
$subsetItemNeeded[0] = $subsetsB2[0];
}else{ $subsetItemNeeded[0] = $subsetsB3[0]; }

string $bufferZ[];
$numTokensX = `tokenize $subsetItemNeeded[0] "->" $bufferZ`;
print $bufferZ; 
string $CurveLOCZ[] =  {$bufferZ[1]};


//string $paramANDCurveA02[];
//$paramANDCurveA02 = `paramToCurvePts2( $AllparamlocatorZ )`;
//if (catch( $paramANDCurveA02 = `paramToCurvePts2( $CurveLOCZ )`)){
//$paramANDCurveA02 = `paramToCurvePts2( $subsetsB2 )`;
//	} else{ print "ParamToCurvePts2_DID_NOT_FAILED"; }

string $paramANDCurveA02[];
$paramANDCurveA02 = `paramToCurvePts2( $CurveLOCZ )`;
string $detachCurve1[] = `detachCurve -ch off -replaceOriginal off $paramANDCurveA02[0]`;

delete $subsetsB[0];
string $newCurves1[];
for ($each in $detachCurve1){
string $newCurve;
$newCurve = `rename $each Curve`;
ArrayInsertAtEnd( $newCurves1, $newCurve);
}

string $objectLayerCurvesRange[] = `queryLayerRangeMembers`;
$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);

  string $diffdigitalSkeleton[] = stringArrayRemoveExact($AllparamlocatorZ, $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;
RemoveNoLongerExistingFromArray($AllparamlocatorZ);
delete $AllparamlocatorZ; 
}

if ( size($MakespaceLocatorZSE) > 0  ) {
appendStringArray($digitalSkeletonA, $MakespaceLocatorZSE, size($MakespaceLocatorZSE));
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($rebuildit[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;			
$CurveSelection[1] = ($rebuildit[0] + ".cv[" + $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA  )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
$MakeXBetweenB[0] = `curve -d 1 -p $EACHCVposAZ[0] $EACHCVposAZ[1] $EACHCVposAZ[2] -p $EACHCVposBZ[0] $EACHCVposBZ[1] $EACHCVposBZ[2] -k 0 -k 2 -n                     XCurveBetweenB`;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 0 -d 1 -tol 0.001 $MakeXBetweenB[0];
appendStringArray($digitalSkeletonA, $MakeXBetweenB, 1);
}
}
wire -gw false -en 1.000000 -ce 0.000000 -li 1.000000 -w $MakeXBetweenB[0] -dds 0 50.000000 $rebuildit[0];
PAUSE;
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($MakeXBetweenB[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($MakeXBetweenB[0] + ".cv[0]") ;			
$CurveSelection[1] = ($MakeXBetweenB[0] + ".cv[" + $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA  )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
				}
int $ZEROorONEA;
int $ZEROorONEB;
string $locZSE0[];
string $locZSE1[];
 int $foundAZ0;
 int $foundBZ0;
 int $foundAX1;
 int $foundBX1;
int $i = 0;
int $iX = 0;
float $eachCVpos1[];
float $eachCVpos2[];
float $movePIVOT1[];
float $movePIVOT2[];
	if (size($MakespaceLocatorZSE) == 1){	$i = 1; }
	if (size($MakespaceLocatorZSE) == 2){ 	$iX = 2; }
	if (( $i == 1) || ( $iX == 2)){
$locZSE0[0] = $MakespaceLocatorZSE[0];
$eachCVpos1 = `pointPosition -w ($MakespaceLocatorZSE[0])`;
	if ( $iX == 2){
$locZSE1[0] = $MakespaceLocatorZSE[1];
$eachCVpos2 = `pointPosition -w ($MakespaceLocatorZSE[1])`;
	}
	if (( $i == 1) || ( $iX == 2)) {
// $EACHCVposAZ is CV 0 of $MakeXBetweenB
// $EACHCVposBZ is CV 1 of $MakeXBetweenB
$ZEROorONEA = FindclosetTOcurveENDz($EACHCVposAZ, $EACHCVposBZ, $eachCVpos1);
if ( $ZEROorONEA == 0){ $movePIVOT1 = $eachCVpos1; print "cv ZERO"; }
if ( $ZEROorONEA == 1){ $movePIVOT1 = $eachCVpos1; print "cv LAST"; }
if ( $iX == 2){
// $EACHCVposAZ is CV 0 of $MakeXBetweenB
// $EACHCVposBZ is CV 1 of $MakeXBetweenB
$ZEROorONEB = FindclosetTOcurveENDz($EACHCVposAZ, $EACHCVposBZ, $eachCVpos2);
if ( $ZEROorONEB == 0){ $movePIVOT2 = $eachCVpos2; print "cv ZERO"; }
if ( $ZEROorONEB == 1){ $movePIVOT2 = $eachCVpos2; print "cv LAST"; }
move -ws $movePIVOT2[0] $movePIVOT2[1] $movePIVOT2[2] $CurveSelection[$ZEROorONEB];
PAUSE;	}

move -ws $movePIVOT1[0] $movePIVOT1[1] $movePIVOT1[2] $CurveSelection[$ZEROorONEA];
PAUSE;				}
delete -ch $rebuildit;
delete $digitalSkeletonA; 					}
}
/////////////////////////////////////////////////////////////////////////////


int $CVsZeroAndLast;
if ( size($MakespaceLocatorZSE) > 0  ) {

if ( `objExists ZEdgeCurvesSet` == 1  ) {

//RemoveNoLongerExistingFromArray($AllparamlocatorZ);
//$newCurves1  This is super Complex not sure what this is doing below
// It doesnt look like it doing anything! fuck!
if ( $ONEspaceLOC == 0  ) {

int $edgeZsetA = `sets -im ZEdgeCurvesSet $AllCurveZ[0]`;
int $edgeZsetB = `sets -im ZEdgeCurvesSet $AllCurveZ[1]`;
$CVsZeroAndLast = FindIfCurveISonZ($rebuildit);

if (($edgeZsetA == 1) && ($edgeZsetB == 1)){
print "Intersects edgeZset Curves";
string $CurveSelectionZ[];
int $numCVs = `getAttr -size ($rebuildit[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );	
$CurveSelectionZ[0] = ($rebuildit[0] + ".cv[" + "0:" + $numCVrealNum + "]") ;

if ($CVsZeroAndLast == 2){
string $CurveSelectionX[];
$CurveSelectionX = `ls -fl $CurveSelectionZ[0]`;
for ($eachZA in $CurveSelectionX) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA  )`;
move -ws 0 $eachCVpos[1] $eachCVpos[2] $eachZA ; 
}
}
xform -cp;
}
}
}
}
PAUSE;
ResetTranlation($rebuildit);
select -r $rebuildit;
string $ParentArc[];
$ParentArc = Strait_ARC_or_FreeForm($rebuildit, 5.5, 2.5 );

if($CVsZeroAndLast < 2)  {
select -r $ParentArc;
MirrorANDrename($ParentArc);
}
if ( $CVsZeroAndLast > 0){ 
sets -include ZEdgeCurvesSet $ParentArc;
 }
//delete $rebuildit;
ArrayInsertAtEnd( $INarrayA, $ParentArc[0]);
////////////////////////////////ADDON
ResetTranlation($ParentArc);
editDisplayLayerMembers -noRecurse layerCurvesINRange1 $ParentArc;
select -r $ParentArc[0];
EvalAddingCurves;
////////////////////TRIGGER#############################////////////////
EvalcreatSphere;
////////////////////TRIGGER#############################////////////////
}
print "find this";

RemoveNoLongerExistingFromArray($digitalSkeletonA);
if (size($digitalSkeletonA) > 0){
delete $digitalSkeletonA;
}
RemoveNoLongerExistingFromArray($AllparamlocatorZ);
if (size($AllparamlocatorZ) > 0){
delete $AllparamlocatorZ;
} 

if ( `objExists $SEspaceLocSetofSetz` == 1  ) { 	
select -r -ne $SEspaceLocSetofSetz;
delete;
}
//delete -ch;

//ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);

///////////////////////////
//MirrorANDrename($rebuildit);
///////////////////////////
}


//find ZEdgeCurvesSet
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//###############_END_############################





proc float[] EulerAngleofTwoPoints(float $EACHCVposAZ[], float $EACHCVposBZ[]){

vector $vectorZ1 = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
vector $vectorZ2 = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
float $MagVectorZ1 = mag($vectorZ1); 
float $MagVectorZ2 = mag($vectorZ2);
float $EACHCVposHigher[];
float $EACHCVposLower[];
if ( $MagVectorZ1 > $MagVectorZ2 ){
print (" posA is Higher " + "\n");
$EACHCVposHigher = $EACHCVposAZ;
$EACHCVposLower = $EACHCVposBZ;
}
if ( $MagVectorZ1 < $MagVectorZ2  ){
print (" posB is Higher " + "\n");
$EACHCVposHigher = $EACHCVposBZ;
$EACHCVposLower = $EACHCVposAZ;
}
float $pointCVAB_MidPoint[] = MidPointBetween($EACHCVposHigher, $EACHCVposLower);
/////////////////////////////////////
vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $pointCVAB_MidPoint);
float $vector_SubUnitMagVec1[];
$vector_SubUnitMagVec1 = SubtractFloats($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 
vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposLower, $pointCVAB_MidPoint);
float $vector_SubUnitMagVec2[];
$vector_SubUnitMagVec2 = SubtractFloats($EACHCVposLower,$UnitVectorMagPosLower[1]); 
/////////////////////////////////////////////////////
float $curveArclenZ  = PointsGetDistanceFLOAT($EACHCVposAZ, $EACHCVposBZ);
float $DivideIt  = $curveArclenZ / 2.0;
float $DivideIt2  = $DivideIt * -1;
float $pointB1[] = {0.0 , 0.0 , $DivideIt} ;
float $pointB2[] = {0.0 , 0.0 , $DivideIt2} ;
/// NOTE curve ENds will not allways Line up and may be inverted
//let $F1 be the first CV $F2 the last .. $F3 third point
int $Z = FindclosetTOcurveENDz($pointB1, $pointB2, $vector_SubUnitMagVec2);
if ($Z == 1){ print "new floats"; $pointB1 = $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
float $EulerAngleA[] = `angleBetween -euler -v1 $pointB1[0] $pointB1[1] $pointB1[2] -v2  $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2[1]   $vector_SubUnitMagVec2[2]`;
float $EulerAngleB[] = `angleBetween -euler -v1 $pointB2[0] $pointB2[1] $pointB2[2] -v2 $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1[1]   $vector_SubUnitMagVec1[2]`;

return $EulerAngleA;
}

proc float[] getYrotationOFcam(){
float $CamerasDirectionVector[] ;
float $CamerasPositionz[];
float $CamLengthVector[];
//============================================
float $CamerasDirectionVector[] = nurbsViewDirectionVector(0);
//============================================ ;) nurbsViewDirectionVector =====
string $currPanel = `getPanel -withFocus` , $camera ;
string $Camera = `modelEditor -q -camera $currPanel`;
$CamerasPositionz = `camera -q -position $Camera`;
float $CP[] = $CamerasPositionz;

$CamLengthVector = AddFloats($CamerasDirectionVector, $CP);

float $CamEulerAngleN[] = {$CamLengthVector[0], 0.0, $CamLengthVector[2]};
float $CamEulerAngleNi[] = {$CamerasPositionz[0], 0.0, $CamerasPositionz[2]};
float $CamEulerAngle[] = EulerAngleofTwoPoints($CamEulerAngleN, $CamEulerAngleNi);

return $CamEulerAngle;
}
///////////////////////////////

//float $CamEulerAngleA[] = `getYrotationOFcam`;
//SetRotations($objectSet, $CamEulerAngleA);
//string $objectSet[];
//$objectSet = `ls -sl`;
////////////////////////////////

////////////////////////////////


proc int ZplainFlatten(){
int $Y = 0;
float $CamEulerAngle[] = `getYrotationOFcam`;
float $CamEulerAngleY = `abs $CamEulerAngle[1]`;
if ($CamEulerAngleY < 22.0){
$Y = 1; print "Less then 22";
}
return $Y;
}


////////////////////////////

////////////////////////////

proc float[] EulerAngleofCurve(){
string $CurveItem[];
$CurveItem = `ls -sl`;
string $CurveSelection[];
int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;			
$CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA  )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}
vector $vectorZ1 = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
vector $vectorZ2 = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
float $MagVectorZ1 = mag($vectorZ1); 
float $MagVectorZ2 = mag($vectorZ2);
float $EACHCVposHigher[];
float $EACHCVposLower[];
if ( $MagVectorZ1 > $MagVectorZ2 ){
print (" posA is Higher " + "\n");
$EACHCVposHigher = $EACHCVposAZ;
$EACHCVposLower = $EACHCVposBZ;
}
if ( $MagVectorZ1 < $MagVectorZ2  ){
print (" posB is Higher " + "\n");
$EACHCVposHigher = $EACHCVposBZ;
$EACHCVposLower = $EACHCVposAZ;
}
float $pointCVAB_MidPoint[] = MidPointBetween($EACHCVposHigher, $EACHCVposLower);
/////////////////////////////////////
vector $UnitVectorMagPosHigher[] = MagTimesUnitVecs($EACHCVposHigher, $pointCVAB_MidPoint);
float $vector_SubUnitMagVec1[];
$vector_SubUnitMagVec1 = SubtractFloats($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 
vector $UnitVectorMagPosLower[] = MagTimesUnitVecs($EACHCVposLower, $pointCVAB_MidPoint);
float $vector_SubUnitMagVec2[];
$vector_SubUnitMagVec2 = SubtractFloats($EACHCVposLower,$UnitVectorMagPosLower[1]); 
/////////////////////////////////////////////////////
float $curveArclenZ  = `arclen $CurveItem`;
float $DivideIt  = $curveArclenZ / 2.0;
float $DivideIt2  = $DivideIt * -1;
float $pointB1[] = {0.0 , 0.0 , $DivideIt} ;
float $pointB2[] = {0.0 , 0.0 , $DivideIt2} ;
/// NOTE curve ENds will not allways Line up and may be inverted
//let $F1 be the first CV $F2 the last .. $F3 third point
int $Z = FindclosetTOcurveENDz($pointB1, $pointB2, $vector_SubUnitMagVec2);
if ($Z == 1){ print "new floats"; $pointB1 = $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
float $EulerAngleA[] = `angleBetween -euler -v1 $pointB1[0] $pointB1[1] $pointB1[2] -v2  $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2[1]   $vector_SubUnitMagVec2[2]`;
float $EulerAngleB[] = `angleBetween -euler -v1 $pointB2[0] $pointB2[1] $pointB2[2] -v2 $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1[1]   $vector_SubUnitMagVec1[2]`;

return $EulerAngleA;
}

/////////////////////////////////////////////////////

/////////////////////////////////////////////////////

proc float [] MidPointBetween(float $loc1[], float $loc2[]) {
	float $a = ($loc2[0] + $loc1[0]) * (0.5);
	float $b = ($loc2[1] + $loc1[1]) * (0.5);
	float $c = ($loc2[2] + $loc1[2]) * (0.5);

	float $MidPoint[] = {$a , $b , $c};
	return $MidPoint;
	}
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////

proc int  PointsEquivalentTol( float $posA[], float $posB[]){
int $pX = equivalentTol($posA[0], $posB[0], 0.001);
int $pY = equivalentTol($posA[1], $posB[1], 0.001);
int $pZ = equivalentTol($posA[2], $posB[2], 0.001);
int $addedResults = $pX + $pY + $pZ;
if ($addedResults == 3 ){ print "Points equivalent"; 
}
return $addedResults;
}
/////////////////////////////////////////////////////

//////////////////////////////////////////
proc vector[] MagTimesUnitVecs(vector $vectorZFlatYHigher, vector $vectorZFlatYLower){
float $MagVectorZYHigher = mag($vectorZFlatYHigher); 
float $MagVectorZYLower = mag($vectorZFlatYLower); 
vector $unitVectormagZYHL[];
$unitVectormagZYHL[0] = $MagVectorZYHigher * unit($vectorZFlatYHigher);
$unitVectormagZYHL[1] = $MagVectorZYLower * unit($vectorZFlatYLower);
print $unitVectormagZYHL;
return $unitVectormagZYHL;
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float[] AppendFloatsZ(float $posA[], float $posB[], int $XYZ){
float $AddposA_AND_posB_float[];
if($XYZ == 0){ $AddposA_AND_posB_float = {$posB[0], $posA[1], $posA[2]} ; }
if($XYZ == 1){ $AddposA_AND_posB_float = {$posA[0], $posB[1], $posA[2]} ; }
if($XYZ == 2){ $AddposA_AND_posB_float = {$posA[0], $posA[1], $posB[2]} ; }
return $AddposA_AND_posB_float;
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float[] CycleFloatsZ(float $posA[], float $posB[], int $XYZ1, int $XYZ2){
float $AddposA_AND_posB_float[];
if(($XYZ1 == 0) && ($XYZ2 == 1)){ $AddposA_AND_posB_float = {$posA[1], $posA[0], $posA[2]} ; } //01 xy
if(($XYZ1 == 0) && ($XYZ2 == 2)){ $AddposA_AND_posB_float = {$posA[2], $posB[1], $posA[0]} ; } //02 xz
if(($XYZ1 == 1) && ($XYZ2 == 2)){ $AddposA_AND_posB_float = {$posA[0], $posA[2], $posB[1]} ; } //12 yz
return $AddposA_AND_posB_float;
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float[] AddFloats(float $posA[], float $posB[]){
float $AddposA_AND_posB_float[];
$AddposA_AND_posB_float = {($posA[0] + $posB[0]), ($posA[1] + $posB[1]), ($posA[2] + $posB[2])} ;
return $AddposA_AND_posB_float;
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float[] SubtractFloats(float $posA[], float $posB[]){
float $SubtractposA_AND_posB_float[];
$SubtractposA_AND_posB_float = {($posA[0] - $posB[0]), ($posA[1] - $posB[1]), ($posA[2] - $posB[2])} ;
return $SubtractposA_AND_posB_float;
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float[] Add_Float_to_3PointFloats(float $posA, float $posB[]){
float $AddposA_AND_posB_float[];
$AddposA_AND_posB_float = {($posA + $posB[0]), ($posA + $posB[1]), ($posA + $posB[2])} ;
return $AddposA_AND_posB_float;
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float[] SubtractFloat_to_3PointFloats(float $posA, float $posB[]){
float $SubtractposA_AND_posB_float[];
$SubtractposA_AND_posB_float = {($posA - $posB[0]), ($posA - $posB[1]), ($posA - $posB[2])} ;
return $SubtractposA_AND_posB_float;
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float GetDegreesFromFloat(float $posA[], float $posB[]){
vector $xvex = << $posA[0], $posA[1], $posA[2] >> ;
vector $yvex = << $posB[0], $posB[1], $posB[2] >> ;
float $xy_angle = angle ($xvex, $yvex) ;
float $Some_degrees = `rad_to_deg $xy_angle`;
print $Some_degrees;
return $Some_degrees; 
}

/////////////////////////////////////////////////////
proc SetRotations(string $objectSet[], float $EulerAngleA[]){
setAttr ($objectSet[0] + ".rotate") $EulerAngleA[0] $EulerAngleA[1] $EulerAngleA[2] ;
}
proc SetTranslations(string $objectSet[], float $EulerAngleA[]){
setAttr ($objectSet[0] + ".translate") $EulerAngleA[0] $EulerAngleA[1] $EulerAngleA[2] ;
}
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////


//////////TEST///////////////////////////
//string $ObjectSelectionz[];
//$ObjectSelectionz = `ls -sl`;

//string $curveObject[];
//$curveObject = `ls -sl`;
//float $translationZ[] = `ResetTranlation($curveObject)`;
//float $EulerAngleCurveObject[] = `EulerAngleofCurve`;
//SetRotations($ObjectSelectionz, $EulerAngleCurveObject);
//SetTranslations($ObjectSelectionz, $translationZ);
//////////////////////////////////////////

//float $pi = 3.141593 ;
float $pointZero[];
$pointZero = << 0, 0, 0 >>;
float $Axis_x[];
float $Axis_y[];
float $Axis_z[];
$AxisF_x = << 1, 0, 0 >>;
$AxisF_y = << 0, 1, 0 >>;
$AxisF_z = << 0, 0, 1 >>;
vector $Axis_X = << 1, 0, 0 >>;
vector $Axis_Y = << 0, 1, 0 >>;
vector $Axis_Z = << 0, 0, 1 >>;

//////////////////////////////////////////

proc float GetDistanceBetweenCurveEnds(string $CurveItem[]){
string $CurveSelection[];
int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;			
$CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA  )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}
$dAx = $EACHCVposAZ[0] - $EACHCVposBZ[0]; $dAy = $EACHCVposAZ[1] - $EACHCVposBZ[1];
$dAz = $EACHCVposAZ[2] - $EACHCVposBZ[2]; float $distanceA2; 
float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
return $distanceA2; 
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float GetDistancePointPositionFLOAT(string $objectFirst, string $objectSecond){
float $pointAZ1[]; float $pointAZ2[];
	$pointAZ1 = `pointPosition -w ($objectFirst)`;
	$pointAZ2 = `pointPosition -w ($objectSecond)`;
$dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
$dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2; 
float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
return $distanceA2; 
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float GetDistanceFLOAT(string $objectFirst, string $objectSecond){
float $pointAZ1[]; float $pointAZ2[];
	$pointAZ1 = `xform -query -worldSpace -translation ($objectFirst)`;
	$pointAZ2 = `xform -query -worldSpace -translation ($objectSecond)`;
$dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
$dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2; 
float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
return $distanceA2; 
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float PointsGetDistanceFLOAT(float $pointAZ1[], float $pointAZ2[]){
$dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
$dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2; 
float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
return $distanceA2; 
}
//////////////////////////////////////////

proc float GetDistanceBetweenCurveEnds(string $CurveItem[]){
string $CurveSelection[];
int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;			
$CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA  )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}
$dAx = $EACHCVposAZ[0] - $EACHCVposBZ[0]; $dAy = $EACHCVposAZ[1] - $EACHCVposBZ[1];
$dAz = $EACHCVposAZ[2] - $EACHCVposBZ[2]; float $distanceA2; 
float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
return $distanceA2; 

}



//////////////////////////////////////////
proc int ZeroOrONE(string $objectLoc[]){
string $objectLocZ[];
$objectLocZ = $objectLoc;
int $X = size($objectLocZ) -1;
int $Z = size($objectLocZ);
int $i = 1;
int $n = -1;
int $n2 = 0;
float $SubtractAB[];
float $posA[];
float $posB[];
int $Zero0rOne = 0;
for( $i = 0; $i < $X; $i ++ ) {
$n = $n + 1;
$Z = $Z - 1;
$ix = 0;
$n2 = $n + 1;
while ($Z > $ix++){

	$posA = `xform -q -wd -translation $objectLocZ[$n]`;
	$posB = `xform -q -wd -translation $objectLocZ[$n2]`;
$n2++;	
$SubtractAB = SubtractFloats($posA, $posB);
if (($SubtractAB[0] == 0) && ($SubtractAB[1] == 0) && ($SubtractAB[2] == 0 )){
print "yes AB";
$Zero0rOne = 1;
}
}
}
return $Zero0rOne;
}

//////////////////////////////////////////

//////////////////////////////////////////
proc MoveObject(float $addfloatVector1[], string $VectorUnitLoc[] ){
move -ws $addfloatVector1[0] $addfloatVector1[1] $addfloatVector1[2] $VectorUnitLoc[0];
}
proc MoveObjectSelection(float $addfloatVector1[]){
string $VectorUnitLoc[];
$VectorUnitLoc = `ls -selection`;
move -ws $addfloatVector1[0] $addfloatVector1[1] $addfloatVector1[2] $VectorUnitLoc[0];
}
//////////////////////////////////////////

proc float[] GetCurveCVposENDS(string $CurveItem[], int $ix){
string $CurveSelection[];
int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;			
$CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA  )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}
if ($ix == 0){
return $EACHCVposAZ; }
if ($ix == 1){
return $EACHCVposBZ; }
}

//////////////////////////////////////////

//////////////////////////////////////////

//////////////////////////////////////////
// $scriptt_jobNum = `scriptJob -event DagObjectCreated StraitCurvesSCRIPTZ -compressUndo true -protected`;


//////////////////////////////////////////


//////////////////////////////////////////

proc FlattenCurveToZplain(string $renamed[]){
string $CurveSelectionZ[];
int $numCVs = `getAttr -size ($renamed[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );	
$CurveSelectionZ[0] = ($renamed[0] + ".cv[" + "0:" + $numCVrealNum + "]") ;
string $CurveSelectionX[];
$CurveSelectionX = `ls -fl $CurveSelectionZ[0]`;
for ($eachZA in $CurveSelectionX) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA  )`;
move -ws 0 $eachCVpos[1] $eachCVpos[2] $eachZA ; 
}
}
//////////////////////////////////////////

//////////////////////////////////////////

proc vector[] VecCurveEnds(string $CurveItem[]){
string $CurveSelection[];
int $numCVs = `getAttr -size ($CurveItem[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;			
$CurveSelection[1] = ($CurveItem[0] + ".cv[" + $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA  )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}
vector $VectorCurveEnds[];
$VectorCurveEnds[0] = << $EACHCVposAZ[0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
$VectorCurveEnds[1] = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;

return $VectorCurveEnds; 
}

//////////////////////////////////////////

//////////////////////////////////////////

global proc string[] MakeCurveBetweenFloats(float $posA[], float $posB[]){
string $ZBetween[];
$ZBetween[0] = `curve -d 1 -p $posA[0] $posA[1] $posA[2] -p $posB[0] $posB[1] $posB[2] -k 0 -k 2 -n ZCurveBetween`;
return $ZBetween;
}
//////////////////////////////////////////

//////////////////////////////////////////

proc float[] MakeCleanFloats(float $FloatZ[]){
string $POSAe = $FloatZ[0]; string $POSBe = $FloatZ[1];
string $POSCe = $FloatZ[2];
string $nameAe; string $nameBe; string $nameCe;
$nameAe = `match "e" $POSAe`;
$nameBe = `match "e" $POSBe`;
$nameCe = `match "e" $POSCe`;
int $zeroORZe1 = `gmatch "e" $nameAe`;
int $zeroORZe2 = `gmatch "e" $nameBe`;
int $zeroORZe3 = `gmatch "e" $nameCe`;
if ( $zeroORZe1 == 1){ $FloatZ[0] = 0.0; }
if ( $zeroORZe2 == 1){ $FloatZ[1] = 0.0; }
if ( $zeroORZe3 == 1){ $FloatZ[2] = 0.0; }
return $FloatZ;
}

////////////////////////////////////////////

proc float MakeCleanFloat1(float $FloatZ){
string $POSAe = $FloatZ; 
string $nameAe; 
$nameAe = `match "e" $POSAe`;
int $zeroORZe1 = `gmatch "e" $nameAe`;
if ( $zeroORZe1 == 1){ $FloatZ = 0.0; }
return $FloatZ;
}
///////////////////////////////////////////

//////////////////////////////////////

//////////////////////////////////////

//////////////////////////////////////

//////////////////////////////////////








//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////

proc float PercentDiff_Curve_to_Arc(float $arclenghtzARC, float $arclenghtzDRAWN){
float $PercentA;
$PercentA = ((float($arclenghtzARC) / $arclenghtzDRAWN) * (100) );
return $PercentA;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////





proc string[] paramToCurvePts3( string $locatorShapes[] ){
	string $curveName[];
	int $i;
	int $numLocators = size($locatorShapes);
	for( $i = 0; $i < $numLocators; $i ++ ) {
// Get the parent transform above the locator shape
string $parent1[] = `listRelatives -p $locatorShapes[$i]`;
string $parent2[] = `listRelatives -p $parent1[0]`;
string $parent3[] = `listRelatives -p $parent2[0]`;		
$curveName[ size($curveName) ] = $parent3[0];
}
return $curveName;
}





/*

string $locatorShapes[] = {"locatorShape1", "locatorShape2" }; 

string $paramToCurveZZ[] = `paramToCurvePts3( $locatorShapes )`;
print $paramToCurveZZ; 



proc string[] paramToCurvePts3( string $locatorShapes[] ){
	string $curveNameZ[];
	int $i;
	int $numLocators = size($locatorShapes);
	for( $i = 0; $i < $numLocators; $i ++ ) {
// Get the parent transform above the locator shape
string $parent1[] = `listRelatives -p $locatorShapes[$i]`;
string $parent2[] = `listRelatives -p $parent1[0]`;
string $parent3[] = `listRelatives -p $parent2[0]`;		
$curveNameZ[ size($curveNameZ) ] = $parent2[0];
}
return $curveNameZ;
}




*/




/*
proc string[] paramToCurvePts3( string $locatorShapes[] ){
string $parent2A[]; 
	string $curveNameZ[];
	int $i;
	int $numLocators = size($locatorShapes);
	for( $i = 0; $i < $numLocators; $i ++ ) {
// Get the parent transform above the locator shape
string $parent1[] = `listRelatives -p $locatorShapes[$i]`;
string $parent2[] = `listRelatives -p $parent1[0]`;
string $ObjectParZ1[] = `ls -tl 1 $parent2`;
	 string $bufferCutCurveA[];
	string $numTokensZA;
$numTokensZA = `tokenize $ObjectParZ1[0] "|" $bufferCutCurveA`;
print $bufferCutCurveA[0]; 
string $ObjectParZ2[] = ` ls -head 1 $parent2`;
	 string $bufferCutCurveB[];
	string $numTokensZB;
$numTokensZB = `tokenize $ObjectParZ2[0] "|" $bufferCutCurveB`;
print $bufferCutCurveB[0]; 
string $nameA = `match "ACurve" $bufferCutCurveA[0]`;
int $zeroORZA = `gmatch "ACurve" $nameA`;
string $nameB = `match "ACurve" $bufferCutCurveB[0]`;
int $zeroORZB = `gmatch "ACurve" $nameB`;

if ( $zeroORZA == 1){ $parent2A = {$bufferCutCurveA[0]};  }
if ( $zeroORZB == 1){ $parent2A = {$bufferCutCurveA[0]};  }

string $parent3[] = `listRelatives $parent2A`;		
$curveNameZ[size($curveNameZ)] = $parent2A[0];
}
return  $curveNameZ;
}


*/



/*

string $locatorShapes[] = {"locatorShape1", "locatorShape2" }; 



paramToCurvePts2( $locatorShapes );


proc string[] paramToCurvePts2( string $locatorShapes[] ){
string $parent2A[]; 
	string $selectionList[];
	string $curveName;

string $nameA; 
string $parent1[];
string $parent2[];

string $ObjectParZ1[];
 string $bufferCutCurveA[];
string $numTokensZA;

string $ObjectParZ2[];
	 string $bufferCutCurveB[];
	string $numTokensZB;

string $nameA;
string $nameB;
int $zeroORZA;
int $zeroORZB;

	float $parm;
	int $i;
	int $numLocators = size($locatorShapes);
	for( $i = 0; $i < $numLocators; $i ++ ) {
// Get the parent transform above the locator shape
$parent1 = `listRelatives -p $locatorShapes[$i]`;

$parent2 = `listRelatives -p $parent1[0]`;

$ObjectParZ1 = `ls -tl 1 $parent2`;
$numTokensZA = `tokenize $ObjectParZ1[0] "|" $bufferCutCurveA`;
print $bufferCutCurveA[0]; 
$ObjectParZ2 = ` ls -head 1 $parent2`;

$numTokensZB = `tokenize $ObjectParZ2[0] "|" $bufferCutCurveB`;
print $bufferCutCurveB[0]; 
$nameA = `match "ACurve" $bufferCutCurveA[0]`;
$zeroORZA = `gmatch "ACurve" $nameA`;
$nameB = `match "ACurve" $bufferCutCurveB[0]`;
$zeroORZB = `gmatch "ACurve" $nameB`;

if ( $zeroORZA == 1){ $parent2A = {$bufferCutCurveA[0]};  }
if ( $zeroORZB == 1){ $parent2A = {$bufferCutCurveA[0]};  }

		$curveName = $parent2A[0];
		if( `nodeType $curveName` != "nurbsCurve" ) continue;

string $pmm;
		if( !catch($pmm = `createNode pointMatrixMult`) ) {
	float $pos[] = `getAttr ($locatorShapes[$i] + ".localPosition")`;
			$parm = `getAttr ($parent1[0] + ".translateX")`;
setAttr ($pmm +".inPoint") -type double3  $pos[0] $pos[1] $pos[2];
			setAttr ($pmm +".vectorMultiply") true ;
			connectAttr ($parent1[0]+".worldMatrix[0]") ($pmm+".inMatrix") ;
			float $result[] = `getAttr ($pmm+".output")` ;
			$parm = $result[0];

	string $selectionItem = $curveName + ".u[" + $parm + "]";
			$selectionList[ size($selectionList) ] = $selectionItem;

delete $pmm;
		}
	}
	return $selectionList;
}



*/



proc string[] paramToCurvePts2( string $locatorShapes[] ){

	string $selectionList[];
	string $curveName;
	float $parm;
	int $i;
	int $numLocators = size($locatorShapes);
	for( $i = 0; $i < $numLocators; $i ++ ) {
// Get the parent transform above the locator shape
string $parent1[] = `listRelatives -p $locatorShapes[$i]`;

string $parent2[] = `listRelatives -p $parent1[0]`;
		$curveName = $parent2[0];
		if( `nodeType $curveName` != "nurbsCurve" ) continue;

string $pmm;
		if( !catch($pmm = `createNode pointMatrixMult`) ) {
	float $pos[] = `getAttr ($locatorShapes[$i] + ".localPosition")`;
			$parm = `getAttr ($parent1[0] + ".translateX")`;
setAttr ($pmm +".inPoint") -type double3  $pos[0] $pos[1] $pos[2];
			setAttr ($pmm +".vectorMultiply") true ;
			connectAttr ($parent1[0]+".worldMatrix[0]") ($pmm+".inMatrix") ;
			float $result[] = `getAttr ($pmm+".output")` ;
			$parm = $result[0];

	string $selectionItem = $curveName + ".u[" + $parm + "]";
			$selectionList[ size($selectionList) ] = $selectionItem;

delete $pmm;
		}
	}
	return $selectionList;
}


////////////////////////////////////////////////////////
proc string[] paramToCurvePts( string $locatorShapes[] ){

	string $selectionList[];
	string $curveName;
	float $parm;
	int $i;
	int $numLocators = size($locatorShapes);
	for( $i = 0; $i < $numLocators; $i ++ ) {
// Get the parent transform above the locator shape
string $parent1[] = `listRelatives -p $locatorShapes[$i]`;

string $parent2[] = `listRelatives -p $parent1[0]`;
		$curveName = $parent2[0];
		if( `nodeType $curveName` != "nurbsCurve" ) continue;

string $pmm;
		if( !catch($pmm = `createNode pointMatrixMult`) ) {
	float $pos[] = `getAttr ($locatorShapes[$i] + ".localPosition")`;
			$parm = `getAttr ($parent1[0] + ".translateX")`;
setAttr ($pmm +".inPoint") -type double3  $pos[0] $pos[1] $pos[2];
			setAttr ($pmm +".vectorMultiply") true ;
			connectAttr ($parent1[0]+".worldMatrix[0]") ($pmm+".inMatrix") ;
			float $result[] = `getAttr ($pmm+".output")` ;
			$parm = $result[0];

	string $selectionItem = $curveName + ".u["  + "0.0" + ":" + $parm + "]";
			$selectionList[ size($selectionList) ] = $selectionItem;

delete $pmm;
		}
	}
	return $selectionList;
}
////////////////////////////////////////////////////////

////////////////////////////////////////////////////////

proc string[] tokenizeparam( string $paramANDCurveZ[] ){
	string $selectionList[];
	int $i;
	int $num = size($paramANDCurveZ);
	for( $i = 0; $i < $num; $i ++ ) {
string $bufferA[];
$numTokensA = `tokenize $paramANDCurveZ[$i] "." $bufferA`;
	string $selectionItem = $bufferA[0];
			$selectionList[ size($selectionList) ] = $selectionItem;
	}
	return $selectionList;
}
////////////////////////////////////////////////////////

////////////////////////////////////////////////////////

proc string[] EvalMoveCurvesTOend(string $paramANDCurveZ[], string $paramCurveNAMEZ[], string $paramANDCurve3[], string $AllparamlocatorZ[],    string   $set){
	int $i;
int $iX;
$iX = -1;
string $SEspaceLocSet;
	int $numparamANDCurveNAMEZ = size($paramCurveNAMEZ);
string $MakespaceLocatorSE[], $MakespaceLocatorEND[], $CurveSelection[], $MakespaceLocatorSTART[]; 
float $eachCVposSTART[], $eachCVposEnd[];

	for( $i = 0; $i < $numparamANDCurveNAMEZ; $i ++ ) {

float $arclenghtzIntersectZ = `eval("arclen" + " " + $paramANDCurveZ[$i])`;
float $arclenghtzALL = `arclen $paramCurveNAMEZ[$i]`;

int $arclenghtzIntTIMES = ($arclenghtzIntersectZ * 1000) ;
int $arclenghtzTOTALnumTIMEZ = ($arclenghtzALL *1000) ;
//asume there is only one curve intersect
int $PercentA;
$PercentA = ((float($arclenghtzIntTIMES) / $arclenghtzTOTALnumTIMEZ) * (100) );

if (( $PercentA > 85 ) || ( $PercentA < 15 )){
int $numCVs = `getAttr -size ($paramCurveNAMEZ[$i] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($paramCurveNAMEZ[$i] + ".cv[0]") ;			
$CurveSelection[1] = ($paramCurveNAMEZ[$i] + ".cv[" + $numCVrealNum + "]") ;

if ( $PercentA > 85 ) { 
// move to curve end
$MakespaceLocatorEND = `spaceLocator -p 0 0 0 -n SEspaceLocatorEND3DZ`;		
	$eachCVposEND = `pointPosition -w ($CurveSelection[1])`;
move  -ws $eachCVposEND[0] $eachCVposEND[1] $eachCVposEND[2] $MakespaceLocatorEND[0];
appendStringArray($MakespaceLocatorSE, $MakespaceLocatorEND, 1);
}

if ( $PercentA < 15 ) { 
$MakespaceLocatorSTART = `spaceLocator -p 0 0 0 -n SEspaceLocatorSTART3DZ`;	
	$eachCVposSTART = `pointPosition -w ($CurveSelection[0])`;
move  -ws $eachCVposSTART[0] $eachCVposSTART[1] $eachCVposSTART[2] $MakespaceLocatorSTART;
appendStringArray($MakespaceLocatorSE, $MakespaceLocatorSTART, 1);

		}
	}

if (( $PercentA < 85 ) && ( $PercentA > 15 )){
$iX = $iX +1;
select -cl;
print $AllparamlocatorZ[$i];
print ("_____not near ends_____" + "\n");
$SEspaceLocSet = `sets -name SEisnotLocSESet[$iX]`;
sets -include $SEspaceLocSet $paramANDCurve3[$i];
sets -include $SEspaceLocSet $AllparamlocatorZ[$i];
sets -include $set $SEspaceLocSet;
}
}
return $MakespaceLocatorSE;
}

////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
/*

GET_AREA_OF_CURVE ($curveItem);
string $curveItem[] = `ls -sl`;

string $obj[] = `ls -sl`;

 */

proc float GET_AREA_OF_CURVE (string $obj[]){

float $area = 0;
float $centroid[] = `xform -q -ws -t ($obj[0])`;
string $CurveItemA = $obj[0];
string $numcvnames[] = `ls -fl ($CurveItemA+".cv[*]")`; 
int $numcvs = size($numcvnames);

for ($iC=0;$iC<$numcvs;$iC++){
  if ($iC<($numcvs-1)){
     string $cvname0 = $obj[0] + ".cv[" + $iC + "]";
     string $getpos0 = "pointPosition " + $cvname0;
     float $pos0[] = `eval $getpos0`;
     string $cvname1 = $obj[0] + ".cv[" + ($iC+1) + "]";
     string $getpos1 = "pointPosition " + $cvname1;
     float $pos1[] = `eval $getpos1`;
 $pos0 = `MakeCleanFloats($pos0)`;
 $pos1 = `MakeCleanFloats($pos1)`;

     float $aP = `distanceBetween {$centroid[0],$centroid[1],$centroid[2]} {$pos0[0],$pos0[1],$pos0[2]}`;
     float $bP = `distanceBetween {$pos0[0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1[2]}`;
     float $cP = `distanceBetween {$pos1[0],$pos1[1],$pos1[2]} {$centroid[0],$centroid[1],$centroid[2]}`;
     float $triarea = 0.25* sqrt ( ($aP+$bP+$cP) * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP) );
	 clear $pos0;
	 clear $pos1;
     $area = $area + $triarea;


   } else{
     string $cvname0 = $obj[0] + ".cv[" + $iC + "]";
     string $getpos0 = "pointPosition " + $cvname0;
     float $pos0[] = `eval $getpos0`;
     string $cvname1 = $obj[0] + ".cv[" + ($iC+1) + "]";
     string $getpos1 = "pointPosition " + $cvname1;
     float $pos1[] = `eval $getpos1`;
 $pos0 = `MakeCleanFloats($pos0)`;
 $pos1 = `MakeCleanFloats($pos1)`;
     float $aP = `distanceBetween {$centroid[0],$centroid[1],$centroid[2]} {$pos0[0],$pos0[1],$pos0[2]}`;
     float $bP = `distanceBetween {$pos0[0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1[2]}`;
     float $cP = `distanceBetween {$pos1[0],$pos1[1],$pos1[2]} {$centroid[0],$centroid[1],$centroid[2]}`;
     float $triarea = 0.25* sqrt ( ($aP+$bP+$cP) * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP) );
	 clear $pos0;
	 clear $pos1;
     $area = $area + $triarea;
     }
  }
clear $numcvnames;
return $area;
}
////////////////////////////////////////////////////////
// string $objectCurveSelected[];
// $objectCurveSelected = `ls -sl`;
// Make_Middle_of_Curve_ParamlocatorZ($objectCurveSelected);
////////////////////////////////////////////////////////







//////////////////////////////////////////////////////////////////////////////////////

proc string[] Make_Middle_of_Curve_ParamlocatorZ002(string $objectCurveSelected[]){
float $arclenghtzALL = `arclen $objectCurveSelected`;
float $arclenghtzDivide = $arclenghtzALL / 2.0;
float $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;  
int $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($objectCurveSelected[0] + ".cv[0]") ;			
$CurveSelection[1] = ($objectCurveSelected[0] + ".cv[" + $numCVrealNum + "]") ;
int $numCVrealNumDivide = $numCVrealNum / 2; 
if ($numCVrealNumDivide > 2){ $numCVrealNumDivide = $numCVrealNumDivide -1; } 
float $arclenghtzHalf = `arclen ($objectCurveSelected[0] + ".u[0.0:" + $numCVrealNumDivide + "]")`;
float $arclenghtzHalfROUNDED = `RoundfloatingPointoff($arclenghtzHalf)`; 
float $iz = 0.0; int $M;
 if ( $arclenghtzDivideROUNDED > $arclenghtzHalfROUNDED){
print "Greater_then"; $M = 0;  $iz = 0.01;}
 if ( $arclenghtzDivideROUNDED < $arclenghtzHalfROUNDED){
print "Less_then"; $M = 1; $iz = -0.01;}
$paramlocatorZARC[0] = eval("paramLocator " +  $objectCurveSelected[0] + ".u[" + $numCVrealNumDivide + "]");
float $iX = float($numCVrealNumDivide); 
int $i = 1;
while ($i > 0){
$iX = $iX + $iz;
setAttr ( $paramlocatorZARC[0] + ".localPositionX") $iX;
string $paramANDCurve[] = `paramToCurvePts( $paramlocatorZARC )`;
float $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
float $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
if($M == 0){
if (($arclenghtzparamZROUNDED == $arclenghtzDivideROUNDED) || ($arclenghtzparamZROUNDED > $arclenghtzDivideROUNDED)){
$i = 0; }
}
if($M == 1){
if (($arclenghtzparamZROUNDED == $arclenghtzDivideROUNDED) || ($arclenghtzparamZROUNDED < $arclenghtzDivideROUNDED)){
$i = 0; }
}
}
float $posA[];
float $posB[];
float $posC[];
$posA = `pointPosition -w $CurveSelection[0]`;
$posB = `pointPosition -w $paramlocatorZARC[0]`;
$posC = `pointPosition -w $CurveSelection[1]`;
string $CircularArcFromCurve[];
$CircularArcFromCurve[0] = `createNode makeThreePointCircularArc`;
setAttr ($CircularArcFromCurve[0] + ".pt1") $posA[0] $posA[1] $posA[2] ;
setAttr ($CircularArcFromCurve[0] + ".pt2") $posB[0] $posB[1] $posB[2];
setAttr ($CircularArcFromCurve[0] + ".pt3") $posC[0] $posC[1] $posC[2];
setAttr ($CircularArcFromCurve[0] + ".d") 3;
setAttr ($CircularArcFromCurve[0] + ".s") 8;
string $ArcCurve[];
$ArcCurve[0] = `createNode nurbsCurve` ; 
connectAttr ($CircularArcFromCurve[0] + ".oc") ($ArcCurve[0] +".cr");
//delete $objectCurveSelected; 
string $ParentArc[];
$ParentArc = `listRelatives -parent $ArcCurve`;
ResetTranlation($ParentArc);

string $ArcZ[];
$ArcZ[0] = `rename $ParentArc $objectCurveSelected`; 
delete $paramlocatorZARC;
select -r $ArcZ;
return $ArcZ; 

}

///////////////////////////////////////////////////////////////////////////////////////////
// string $oneItemz[];
// $oneItemz = `ls -sl`;
// ResetTranlationEach( $oneItemz );
///////////////////////////////////////////////////////////////////////////////////////////
proc ResetTranlationEach(string $oneItemz[]){
for ($each in $oneItemz){
xform -cp $each;
	vector $worldPos = `xform -q -ws -rp $each`;
			move -rpr 0 0 0 $each;
			makeIdentity -apply true -t 1 -r 0 -s 0 $each;
			xform -t ($worldPos.x) ($worldPos.y) ($worldPos.z) $each;
}
}
///////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////

proc string[] CompareCurveIntersect (string $objectLoc[]){
string $objectLocZ[];
string $CurveintersectZ;
string $ItemLists[];
$objectLocZ = $objectLoc;
int $X = size($objectLocZ) -1;
int $Z = size($objectLocZ);
int $i = 1;
int $n = -1;
int $n2 = 0;
for( $i = 0; $i < $X; $i ++ ) {
$n = $n + 1;
$Z = $Z - 1;
$ix = 0;
$n2 = $n + 1;
while ($Z > $ix++){	
$CurveintersectZ = `curveIntersect -ch 0 -tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2]`;
if (size($CurveintersectZ) > 0) {	
ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
} else { print "no Intersect"; }
$n2++;
}
}
return $ItemLists;
}

///////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////
proc float RoundfloatingPointoff(float $floatingPointNumZ){
int $roundoff = $floatingPointNumZ *100;
float $roundoff2 = float($roundoff) * 0.01;
return $roundoff2;
}

///////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////
proc float[] Make_Middle_of_Curve_ParamlocatorFloat(string $objectCurveSelected[]){
float $arclenghtzALL = `arclen $objectCurveSelected`;
float $arclenghtzDivide = $arclenghtzALL / 2.0;
float $arclenghtzDivideROUNDED = `RoundfloatingPointoff($arclenghtzDivide)`;   
$paramlocatorZARC[0] = eval("paramLocator " +  $objectCurveSelected[0] + ".u[" + 0.00 + "]");
float $iX = 0.00; 
int $i = 1;
string $posALL[];
float $posB[];
while ($i > 0){
$iX = $iX + 0.01;
setAttr ( $paramlocatorZARC[0] + ".localPositionX") $iX;
string $paramANDCurve[] = `paramToCurvePts( $paramlocatorZARC )`;
float $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;
float $arclenghtzparamZROUNDED = `RoundfloatingPointoff($arclenghtzparamZ)`;
if (($arclenghtzparamZROUNDED == $arclenghtzDivideROUNDED) || ($arclenghtzparamZROUNDED > $arclenghtzDivideROUNDED)){
$i = 0;
}
}
	$posB = `pointPosition -w $paramlocatorZARC[0]`;
delete $paramlocatorZARC;
return $posB ; 
}

///////////////////////////////////////////////////////////////////
proc float [] MidPointBetween(float $loc1[], float $loc2[]) {
	float $a = ($loc2[0] + $loc1[0]) * (0.5);
	float $b = ($loc2[1] + $loc1[1]) * (0.5);
	float $c = ($loc2[2] + $loc1[2]) * (0.5);

	float $MidPoint[] = {$a , $b , $c};
	return $MidPoint;
	}

///////////////////////////////////////////////////////////////////

proc float distanceBetween(float $loc1[], float $loc2[]) {
	float $a = `pow ($loc2[0] - $loc1[0]) 2`;
	float $b = `pow ($loc2[1] - $loc1[1]) 2`;
	float $c = `pow ($loc2[2] - $loc1[2]) 2`;
	float $distance = `sqrt ( $a+$b+$c )`;
	return $distance;
	}
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
// string $objectA[0] = `ls -sl`;
// MirrorANDrename($objectA);
////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////

proc MirrorANDrename(string $objectA[]){
ResetTranlation($objectA);
	float $posA[];	
	$posA = `xform -q -os -translation $objectA[0]`;
xform -ws -pivots 0 $posA[1] $posA[2];
duplicate -rr; scale -r -1 1 1; 
string $objectDup[] = `ls -sl`;
/*
string $shapeA[] = `listRelatives -s $objectA[0]` ;
string $shapeB[] = `listRelatives -s $objectDup[0]` ;
	
		$inAttr = $shapeA[0] + ".worldSpace[0]" ;
		$oAttr = $shapeB[0] + ".create" ;
		connectAttr -f $inAttr $oAttr ;
*/

int $numa  = `match "[0-9]+" $objectA[0]`;
string $nameAZ;
$nameAZ = `match "[a-zA-Z]+" $objectA[0]`;
string $renamez;
$renamez = ("A" + $nameAZ + $numa + "A");
string $renameitzA[];
$renameitzA[0] = `rename $objectDup[0] $renamez`;
 makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;
ResetTranlation($renameitzA);
}

////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

proc createStageOne(){
nurbsPlane -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u 1 -v 1 -ch 1 -n Zplane;
editDisplayLayerMembers -noRecurse layerYZYXPlains "Zplane";
rotate -r -os 0 0 -90 ;
setAttr "Zplane.scaleX" 3000;
setAttr "Zplane.scaleY" 3000;
setAttr "Zplane.scaleZ" 3000; 
nurbsPlane -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u 1 -v 1 -ch 1 -n Xplane;
editDisplayLayerMembers -noRecurse layerYZYXPlains "Xplane";
setAttr "Xplane.scaleX" 3000;
setAttr "Xplane.scaleY" 3000;
setAttr "Xplane.scaleZ" 3000;
textCurves -ch 0 -f "Courier New|h-19|w700|c0" -t "Select The Z Axis OR the X Axis ";
rotate -r -os 0 90 0 ;
move -r 0 0 59.5 ;
move -r 0 19 0 ;
textCurves -ch 0 -f "Courier New|h-19|w700|c0" -t "by Drawing a Line Over One of The Curves";
rotate -r -os 0 90 0 ;
move -r 0 0 59.5 ;
move -r 0 12.5 0 ;
curve -d 3 -p 0 0 0 -p 0 0 4 -p 0 0 8 -p 0 0 12 -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -n Zcurvez;
curve -d 3 -p 0 0 0 -p 4 0 0 -p 8 0 0 -p 12 0 0 -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -n Xcurvez;
if ( `objExists layerZcurvez` == 0  ) {
createDisplayLayer -name "layerZcurvez" -number 1 -empty;
setAttr layerZcurvez.color 6;
editDisplayLayerMembers -noRecurse layerZcurvez Zcurvez;
}
//
if ( `objExists layerXcurvez` == 0  ) {
createDisplayLayer -name "layerXcurvez" -number 1 -empty;
setAttr layerXcurvez.color 13;
editDisplayLayerMembers -noRecurse layerXcurvez "Xcurvez";
}
}
///////////////////////////////////////////////////

///////////////////////////////////////////////////
proc float GetDistancePointPositionFLOAT(string $objectFirst, string $objectSecond){
float $pointAZ1[]; float $pointAZ2[];
	$pointAZ1 = `pointPosition -w ($objectFirst)`;
	$pointAZ2 = `pointPosition -w ($objectSecond)`;
$dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
$dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2; 
float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
float $distanceA2roundoff;  
float $distanceA2roundoff = $distanceA2; 
return $distanceA2roundoff; 
}
/////////////////////////////////////////////////

///////////////////////////////////////////////////
proc int FindIfCurveCrossesZ(string $rebuildit[]){
int $ZeroOneORTwo;
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($rebuildit[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;			
$CurveSelection[1] = ($rebuildit[0] + ".cv[" + $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];
	$EACHCVposAZ = `pointPosition -w ( $CurveSelection[0]  )`;		
	$EACHCVposBZ = `pointPosition -w ( $CurveSelection[1]  )`;
string $POSA = $EACHCVposAZ[0];
string $nameA;
$nameA = `match "-" $POSA`;
int $zeroOR1Z = `gmatch "-" $nameA`;
string $POSB = $EACHCVposBZ[0];
string $nameB;
$nameB = `match "-" $POSB`;
int $zeroOR2Z = `gmatch "-" $nameB`;
int $ZeroOneORTwo = $zeroOR1Z + $zeroOR2Z;
string $POSAe = `abs $EACHCVposAZ[0]`;
string $POSBe = `abs $EACHCVposBZ[0]`;
string $nameAe;
$nameAe = `match "e" $POSAe`;
string $nameBe;
$nameBe = `match "e" $POSBe`;
int $zeroOR1Ze = `gmatch "e" $nameAe`;
int $zeroOR2Ze = `gmatch "e" $nameBe`;
if (($zeroOR1Ze == 1 ) || ($zeroOR2Ze == 1 )){
print "is Zero";
$ZeroOneORTwo = 0;
print $ZeroOneORTwo;
}
return $ZeroOneORTwo;
}

///////////////////////////////////////////////////

///////////////////////////////////////////////////

proc int GetDistance(string $objectFirst, string $objectSecond){
float $pointAZ1[]; float $pointAZ2[];
	$pointAZ1 = `xform -query -worldSpace -translation ($objectFirst)`;
	$pointAZ2 = `xform -query -worldSpace -translation ($objectSecond)`;
$dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy = $pointAZ1[1] - $pointAZ2[1];
$dAz = $pointAZ1[2] - $pointAZ2[2]; float $distanceA2; 
$distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
int $distanceA2roundoff;  
int $distanceA2roundoff = $distanceA2; 
return $distanceA2roundoff; 
}

///////////////////////////////////////////////////

///////////////////////////////////////////////////
proc string[] CutCurveIFConditionTRUETransitZ(string $rebuildit[]){
int $XiScaleTimes;
int $XiScale;
string $remainingCurve[];
int $ZeroOneORTwoZ = FindIfCurveCrossesZ($rebuildit);
 if ($ZeroOneORTwoZ == 1){ 
float $CURVEAposA[];
	$CURVEAposA = `xform -query -worldSpace -translation $rebuildit[0]`;
float $CURVEA_AREA = `GET_AREA_OF_CURVE($rebuildit)`;
string $ZcutingplaneZZ[];
$ZcutingplaneZZ = `nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr 1 -n "ZcutingplaneZZ"`;
setAttr "ZcutingplaneZZ.rotateZ" 90;
$XiScale = GetDistance($rebuildit[0], $ZcutingplaneZZ[0]);
$XiScaleTimes = ($XiScale * 3) + $CURVEA_AREA;
scale -r $XiScaleTimes $XiScaleTimes $XiScaleTimes $ZcutingplaneZZ;
string $curveIntersectZ[];
string $intersectZZCUT[];
	string $iSurfZ[] = `extrude -ch 1 -et 0 -l 0.5 -n AxisSelectionZ ( $rebuildit )`;
$intersectZZCUT = `intersect -ch 0 -cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ $iSurfZ[0] $ZcutingplaneZZ[0]`;
select -r $intersectZZCUT;
$curveIntersectZ[0] = `curveIntersect -ch 0 -tolerance 0.00001 $intersectZZCUT $rebuildit[0]`;
string $buffer[];
int $numTokensZa;
string $paramlocatorZ[];
$numTokensZa = `tokenize $curveIntersectZ[0] " " $buffer`;
$paramlocatorZ[0] = `eval("paramLocator " +  $rebuildit[0] + ".u[" + $buffer[1] + "]")`;
int $X = 0;
string $paramANDCurve[];
$paramANDCurve  = `paramToCurvePts2( $paramlocatorZ)`;
string $curvesZ[];
$curvesZ = `detachCurve -ch 1 -cos on -rpo 1 $paramANDCurve`;
string $curveZ0[];
$curveZ0[0] = $curvesZ[0];
string $curveZ1[];
$curveZ1[0] = $curvesZ[1];
ResetTranlation($curveZ0);
ResetTranlation($curveZ1);
float $EACHCVposAZ[];
float $EACHCVposBZ[];
	$EACHCVposAZ = `xform -query -worldSpace -translation ( $curvesZ[0]  )`;		
	$EACHCVposBZ = `xform -query -worldSpace -translation ( $curvesZ[1]  )`;
string $POSA = $EACHCVposAZ[0];
string $nameA;
$nameA = `match "-" $POSA`;
int $zeroOR1Z = `gmatch "-" $nameA`;
string $POSB = $EACHCVposBZ[0];
string $nameB;
$nameB = `match "-" $POSB`;
int $zeroOR2Z = `gmatch "-" $nameB`;
if ($zeroOR1Z == 1){
delete $curvesZ[0];
$X = 1; }
if ($zeroOR2Z == 1){
delete $curvesZ[1]; 
$X = 2;}
if ($X == 2){
select -r $curvesZ[0]; }
if ($X == 1){
select -r $curvesZ[1]; }
$remainingCurve = `ls -sl`;
delete $intersectZZCUT $ZcutingplaneZZ AxisSelectionZ ; 
}
$rebuildit = $remainingCurve;
return $remainingCurve;
}
///////////////////////////////////////////////////

///////////////////////////////////////////////////
proc int FindIfCurveISonZ(string $rebuildit[]){
string $CurveSelection[];
int $iZ = 0; 
int $numCVs = `getAttr -size ($rebuildit[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;			
$CurveSelection[1] = ($rebuildit[0] + ".cv[" + $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];
	$EACHCVposAZ = `pointPosition -w ( $CurveSelection[0]  )`;		
	$EACHCVposBZ = `pointPosition -w ( $CurveSelection[1]  )`;
string $POSA = $EACHCVposAZ[0];
string $ScientNotationNameA;
$ScientNotationNameA = `match "e" $POSA`;
int $zeroOR1Z = `gmatch "e" $ScientNotationNameA`;
if (($EACHCVposAZ[0] == 0) || ($zeroOR1Z == 1)){
print "yes";
$iZ = $iZ + 1;
}
string $POSB = $EACHCVposBZ[0];
string $ScientNotationNameB;
$ScientNotationNameB = `match "e" $POSB`;
int $zeroOR2Z = `gmatch "e" $ScientNotationNameB`;
if (($EACHCVposBZ[0] == 0) || ($zeroOR2Z == 1)){
print "yes";
$iZ = $iZ + 1;
}
return $iZ;
}

///////////////////////////////////////////////////
///////////////////////////////////////////////////

proc PAUSE(){
playButtonStepForward;
}

///////////////////////////////////////////////////
///////////////////////////////////////////////////

proc averagingNode(string $firstObjectz, string $averageObjectz, string $LastObjectz){
string $averaging[];
$averaging[0] = `shadingNode -asUtility plusMinusAverage`;
setAttr ($averaging[0] + ".operation") 3;   
connectAttr -force ( $firstObjectz + ".translate")($averaging[0] + ".input3D[1]"); 
connectAttr -force ($averaging[0] + ".output3D")("|" + $averageObjectz + ".translate");                                        
connectAttr -force ( $LastObjectz + ".translate")($averaging[0] + ".input3D[0]"); 
}
////////////////////////////////////////////////////////

////////////////////////////////////////////////////////

proc int ArrayInsertAtEnd( string $INarray[], string $NewItem){ 
int $SizeOfArray;
$SizeOfArray = size($INarray);
$INarray[$SizeOfArray] = ( $NewItem );
return $SizeOfArray;
}
////////////////////////////////////////////////////////
proc ResetTranlation(string $oneItemz[]){
xform -cp $oneItemz[0];
	vector $worldPos = `xform -q -ws -rp $oneItemz[0]`;
			move -rpr 0 0 0 $oneItemz[0];
			makeIdentity -apply true -t 1 -r 0 -s 0 $oneItemz[0];
			xform -t ($worldPos.x) ($worldPos.y) ($worldPos.z) $oneItemz[0];
}
////////////////////////////////////////////////////////

////////////////////////////////////////////////////////

proc float[] positionOne(string $eachZA){       	
 float $eachCVpos[] = `pointPosition -w $eachZA`;
return $eachCVpos;
}
////////////////////////////////////////////////////////

////if ( eval("gmatch $list $item") == 1){
//print "yes"; }
// BELOW PROC Gmatches a list of items in an array to one "thing" like a shortname 
//ALL THE CHARAs in one sting and RETURNS - a Zero or one

////////////////////////////////////////////////////////

proc int stringArrayGmatch(string $item, string $list[]){
	int $result = false;	
	string $listItem;	
	for ($listItem in $list) {
		if ( `gmatch $listItem $item` == 1){
		$result = true;
			break;	}
	}	
	return $result;
}
////////////////////////////////////////////////////////

proc Removefromsurface(){

string $curves[] = `ls -sl`;
string $buffer[];
$numTokensz = `tokenize $curves[0] "->" $buffer`;
print $buffer; 
string $myCurve =  $buffer[1];
rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.001 $buffer[1];

if (size($buffer) < 2 ){ $myCurve =  $curves[0];}
	string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size ($CurveSelection);
int $numEPs = size ($CurveSelection);
print  ($numEPs + "\n"); 
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 1.5); 

string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`; 
$connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
	float $step = $numEPrealNum2;  
	$curve = "curve -d 1";
int $a;
  for($a = 0; $a <= $step;$a++){

  	$t =  $a/$step; 	
	setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
  	float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
	
	$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
}
string $Newcurvez = `eval($curve)`;
string $Newcurve[] = {$Newcurvez};
delete $curves;
delete $paramlocatorpointOnCurvex $spaceLocatorB; 
string $renamed = `rename $Newcurve "DrawCurve"`;  
$Newcurve = {$renamed};
rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.001 $Newcurve;
select -r $Newcurve; 
}

////////////////////////////////////////////////////////
/////
//OLD
/*

//proc Removefromsurface(){

string $curves[] = `ls -sl`;
string $buffer[];
$numTokensz = `tokenize $curves[0] "->" $buffer`;
print $buffer; 
string $myCurve =  $buffer[1];
if (size($buffer) < 2 ){ $myCurve =  $curves[0];}
	string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size ($CurveSelection);
int $numEPs = size ($CurveSelection);
print  ($numEPs + "\n"); 
int $numEPrealNum = ( $numEPs -1 );
	$curve = "curve -d 1";
	int $a = 0;
float $values[];
  for($a = 0; $a < $numEPs;$a++){
$values = `pointPosition -w $CurveSelection[$a]`;		
	$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
}
string $Newcurvez = `eval($curve)`;
string $Newcurve[] = {$Newcurvez};
delete $curves;
string $renamed = `rename $Newcurve "DrawCurve"`;  
$Newcurve = {$renamed};
rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.001 "curve2";
select -r $Newcurve; 
}

*/

////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
//let $a1 be the first CV $a2 the last .. $b1 a locator

proc int FindclosetTOcurveENDz(float $a1[], float $a2[], float $b1[]){
int $binaryAnswer;
float $distance1;
float $distance2;
float $pointA1[];
float $pointA2[];
float $pointB1[];
float $dAx;
float $dAy;
float $dAz;
$pointA1 = $a1;
$pointA2 = $b1;
$dAx = $pointA1[0] - $pointA2[0];
$dAy = $pointA1[1] - $pointA2[1];
$dAz = $pointA1[2] - $pointA2[2];
$distanceA = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
$distance1 = $distanceA;
$pointB1 = $a2;
$dAx = $pointB1[0] - $pointA2[0];
$dAy = $pointB1[1] - $pointA2[1];
$dAz = $pointB1[2] - $pointA2[2];
$distanceB = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
$distance2 = $distanceB;
if ($distance1 < $distance2){ 
$binaryAnswer = 0;
return $binaryAnswer; 
}
if ( $distance2 < $distance1 ){
$binaryAnswer = 1;
return $binaryAnswer;
}

}

////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

proc string[] NearestObjectArray(int $n, string $ItemsSelectedinArray[]){
int $NearestObjectN = $n;
string $NearestCurvesZ[];
$numIntx = size($NearestCurvesZ);
if ( $numIntx > 0 ){
clear $NearestCurvesZ;
}
string $array1[] = $ItemsSelectedinArray;
string $array2[] = $ItemsSelectedinArray;
string $arrayMainObject1[] = $ItemsSelectedinArray;
string $ArrayTwoObjectX[0];
int $indexN = 0;
int $NearestObjectNumbers = $NearestObjectN;
$ObjN = 0;
$ObjN2 = 0;
while($ObjN++ < $NearestObjectNumbers ){
string $array1Count = size ($array1) -1;
int $array1Number = $array1Count;
stringArrayRemoveAtIndex($array1Count, $array1);
string $diff[] = stringArrayRemoveExact($array1, $arrayMainObject1);
string $CompareAllShapesCount = size ($array1);
int $curvenumbers = $CompareAllShapesCount;
$i = 1;
while($i++ < $curvenumbers ){
//DISTANCE A
float $pointA1[];
float $pointA2[];
	$pointA1 = `xform -query -worldSpace -translation ( $diff)`;
	$pointA2 = `xform -query -worldSpace -translation ($array1[0])`;
$dAx = $pointA1[0] - $pointA2[0];
$dAy = $pointA1[1] - $pointA2[1];
$dAz = $pointA1[2] - $pointA2[2];
float $distanceA;
$distanceA = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
//DISTANCE B
float $pointB1[];
float $pointB2[];
	$pointB1 = `xform -query -worldSpace -translation ( $diff)`;
	$pointB2 = `xform -query -worldSpace -translation ( $array1[1])`;
$dBx = $pointB1[0] - $pointB2[0];
$dBy = $pointB1[1] - $pointB2[1];
$dBz = $pointB1[2] - $pointB2[2];
float $distanceB;
$distanceB = `sqrt( ($dBx * $dBx) + ($dBy * $dBy) + ($dBz * $dBz) )`;
if( $distanceA < $distanceB ){
stringArrayRemoveAtIndex(1, $array1);
}
if( $distanceA > $distanceB ){
stringArrayRemoveAtIndex(0, $array1);
}
}
appendStringArray($NearestCurvesZ, $array1, 1);
string $oneitem[];
$oneitem[0] = $array1[0];
string $arrayLast[] = stringArrayRemoveExact($oneitem, $arrayMainObject1);
$array1 = $arrayLast;
$array2 = $arrayLast;
$arrayMainObject1 = $arrayLast;
$indexN++;
stringArrayInsertAtIndex(($indexN), $ArrayTwoObjectX, $arrayLast[0]);
}
string $array1[]; 
clear $array1;
string $array2[];
clear $array2;
string $arrayMainObject1[];
clear $arrayMainObject1;
string $return[];
$return = $NearestCurvesZ;
return $return; 
}
////////////////////////////////////////////////////////


proc string[] CreateCAMforIntCurveScript(){

CreateCameraOnly;
rename ZCURVEModelingCAM;
lookThroughModelPanelClipped ZCURVEModelingCAM modelPanel4 0.001 1000;
nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr 1 -n "LiveSurfaceB";
editDisplayLayerMembers -noRecurse layerYZYXPlains "LiveSurfaceB";


//////////////////
string $CamConeLocator[];
clear $CamConeLocator;
curve -d 3 -p 0 0 0 -p 0 0 -4 -p 0 0 -8 -p 0 0 -12 -k 0 -k 0 -k 0 -k 12 -k 12 -k 12 -n Deletethiscurve ;
extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
$objectZcurv = `ls -sl`;
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($objectZcurv[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($objectZcurv[0] + ".cv[0]") ;			
$CurveSelection[1] = ($objectZcurv[0] + ".cv[" + $numCVrealNum + "]") ;
	string $each;
for ($each in $CurveSelection) {
        float $eachCVpos[]; $eachCVpos = `pointPosition -w ( $each  )`;
string $MakespaceLocator[]; $MakespaceLocator = `spaceLocator -p 0 0 0 -n LocatorA`;
ArrayInsertAtEnd($CamConeLocator, $MakespaceLocator[0]);
move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos[2] $MakespaceLocator[0];
}
string $objectZ[]; clear $objectZ; string $MakespaceLocator[]; clear $MakespaceLocator ;  
int $LocatorLoop = 0; int $LocatorLoopA = -1;
while ($LocatorLoop++ < 7) {
$LocatorLoopA = $LocatorLoopA +1; 
if ($LocatorLoopA == 0){
clear $objectZ; 
stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
stringArrayInsertAtIndex(1, $objectZ, "LocatorA1");
}
if ($LocatorLoopA > 0){
clear $objectZ; 
stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
stringArrayInsertAtIndex(1, $objectZ, $MakespaceLocator[0]);
}
if ($LocatorLoopA < 7){
$MakespaceLocator = `spaceLocator -p 0 0 0 -n LocatorMiddleDistance`;
ArrayInsertAtEnd($CamConeLocator, $MakespaceLocator[0]);
averagingNode($objectZ[0], $MakespaceLocator[0], $objectZ[1]);
}
}
ArrayInsertAtEnd( $CamConeLocator, $CamConeLocator[0]);
stringArrayRemoveAtIndex(0, $CamConeLocator);
parentConstraint -mo -weight 1 ZCURVEModelingCAM LocatorA1 ;
parentConstraint -mo -weight 1 ZCURVEModelingCAM LocatorA;
delete  Deletethiscurve;
align -atl -x Mid -y Mid -z Mid LiveSurfaceB ZCURVEModelingCAM;
move -r -os -wd 0 5 5 ZCURVEModelingCAM ;
setAttr "ZCURVEModelingCAM.rotateX" -45;
setAttr "LiveSurfaceB.rotateX" (`getAttr ("ZCURVEModelingCAM" + ".rotateX")`+90);
setAttr "LiveSurfaceB.rotateY" `getAttr ("ZCURVEModelingCAM" + ".rotateY")`;
setAttr "LiveSurfaceB.rotateZ" `getAttr ("ZCURVEModelingCAM" + ".rotateZ")`;
align -atl -x Mid -y Mid -z Mid LiveSurfaceB ZCURVEModelingCAM;
move -r -os -wd 0 -1 0 LiveSurfaceB ;
parentConstraint -mo -weight 1 ZCURVEModelingCAM LiveSurfaceB;
setAttr "ZCURVEModelingCAM.translateX" 48 ;
setAttr "ZCURVEModelingCAM.translateY" 41 ;
setAttr "ZCURVEModelingCAM.translateZ" 48 ;
setAttr "ZCURVEModelingCAM.rotateX" -25 ;
setAttr "ZCURVEModelingCAM.rotateY" 45;
setAttr "ZCURVEModelingCAM.rotateZ" 0;
return $CamConeLocator;
}
////////////////////////////////////////////////////////

////////////////////////////////////////////////////////


proc Removefromsurface(){

string $curves[] = `ls -sl`;
string $buffer[];
$numTokensz = `tokenize $curves[0] "->" $buffer`;
print $buffer; 
string $myCurve =  $buffer[1];
rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.001 $buffer[1];

if (size($buffer) < 2 ){ $myCurve =  $curves[0];}
	string $CurveSelection[] = `ls -fl ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size ($CurveSelection);
int $numEPs = size ($CurveSelection);
print  ($numEPs + "\n"); 
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 1.5); 

string $paramlocatorpointOnCurvex = `pointOnCurve -ch on -pr 0.0 -p $myCurve`;
string $spaceLocatorB[] = `spaceLocator -p 0 0 0 -n LocatorX`; 
$connectPositionToPointNode1 = `connectAttr ($paramlocatorpointOnCurvex + ".position") ($spaceLocatorB[0] + ".translate")`;
	float $step = $numEPrealNum2;  
	$curve = "curve -d 1";
int $a;
  for($a = 0; $a <= $step;$a++){

  	$t =  $a/$step; 	
	setAttr ($paramlocatorpointOnCurvex + ".parameter") $t ;
PAUSE;
  	float $values[] = `getAttr ($paramlocatorpointOnCurvex + ".position")`;
	
if (($values[0] == 0.0 ) && ($values[1] == 0.0 ) && ($values[2] == 0.0 )){
//print "error Curve CVs";
  	float $values[] = `pointPosition -w $CurveSelection[$numEPrealNum]`;
$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
} else {
	$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];}
}
string $Newcurvez = `eval($curve)`;
string $Newcurve[] = {$Newcurvez};
delete $curves;
delete $paramlocatorpointOnCurvex $spaceLocatorB; 
string $renamedX = `rename $Newcurve "DrawCurve"`;  
$Newcurve = {$renamedX};
rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.001 $Newcurve;
select -r $Newcurve; 
}


//START

proc string[] StartofCurveScriptIntersectZX(){
Removefromsurface;

//
string $digitalSkeleton[];
$numInts = size($digitalSkeleton);
if ( $numInts > 0 ){
clear $digitalSkeleton;
}
string $objectcurv[];
$objectcurv = `ls -sl`;
///////////////GATHER ALL BUILDING STRUCTURE/////////##
appendStringArray($digitalSkeleton, $objectcurv, 1);
/////////////////////////////////////////////////////##
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($objectcurv[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($objectcurv[0] + ".cv[0]") ;			
$CurveSelection[1] = ($objectcurv[0] + ".cv[" + $numCVrealNum + "]") ;

float $EACHCVposA[];
float $EACHCVposB[];	
string $AllIntersectCurveZ[];
$numInts = size($AllIntersectCurveZ);
if ( $numInts > 0 ){
clear $AllIntersectCurveZ;
}

string $IntersectCurves[];
string $MakeExtrudeSurface[];
string $MakeBirailSurface[];
string $MakeXBetween[];
string $MakeIntersectCurvez[];
string $MakespaceLocator[];
	string $each;
for ($each in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $each  )`;
$MakespaceLocator = `spaceLocator -p 0 0 0 -n IntersectZLocaterZ3D`;
$MakeIntersectCurvez[0] = `curve -d 1 -p 0 0 0 -p 12 0 0 -k 0 -k 1 -n IntersectCurve` ;
appendStringArray($AllIntersectCurveZ, $MakeIntersectCurvez, 1);
appendStringArray($digitalSkeleton, $MakespaceLocator, 1);
$numInts = size($AllIntersectCurveZ);
extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0", "1","0","0","100","0","0","0","0","1","1","1"} );
move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos[2] $MakespaceLocator[0];
move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos[2] $MakeIntersectCurvez[0];
aimConstraint -offset 0 0 0 -weight 0.5 -aimVector -1 0 0 -upVector 0 0 -1 -worldUpType "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM   $MakeIntersectCurvez[0];
if ( $numInts == 1 ){
$EACHCVposA = $eachCVpos;
}
if ( $numInts == 2 ){
$EACHCVposB = $eachCVpos;
$MakeXBetween[0] = `curve -d 1 -p $EACHCVposA[0] $EACHCVposA[1] $EACHCVposA[2] -p $EACHCVposB[0] $EACHCVposB[1] $EACHCVposB[2] -k 0 -k 2 -n   XCurveBetween`;
appendStringArray($digitalSkeleton, $MakeXBetween, 1);
}
}

$MakeExtrudeSurface = `extrude -ch true -rn 0 -po 0 -et 0 -upn 0 -fixedPath 1 -d 0 0 0 -length 3 -rotation 0 -scale 1 -dl 3 -n CURVEZextrude   $objectcurv` ;

$MakeBirailSurface = `singleProfileBirailSurface -ch 1 -po 0 -tm 1 -tp1 0 -n SurfaceinterectCurves CURVEZextrude.v[0] $AllIntersectCurveZ[0]   $AllIntersectCurveZ[1]`;

string $curveFromSurfaceDup[] = `duplicateCurve -ch 1 -rn 0 -local 0  "SurfaceinterectCurves.u[1]"` ;
string $curveFromSurfaceLoft[] = `loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 4 -rn 1 -po 0 -rsn true -n IntersectLoftZ $curveFromSurfaceDup[0]   $objectcurv` ;

// Result: duplicatedCurve1 curveFromSurfaceIso2 //


// GATHER ALL BUILDING STRUCTURE//
appendStringArray($digitalSkeleton, $curveFromSurfaceDup, 1);
appendStringArray($digitalSkeleton, $curveFromSurfaceLoft, 1);
appendStringArray($digitalSkeleton, $MakeExtrudeSurface, 1);
appendStringArray($digitalSkeleton, $MakeBirailSurface, 1);
appendStringArray($digitalSkeleton, $AllIntersectCurveZ, 2);
////
return $digitalSkeleton; 
}

///////////////////////////////////////////////////
///////////////////////////////////////////////////






proc int ArrayInsertAtEnd( string $INarray[], string $NewItem){ 
int $SizeOfArray;
$SizeOfArray = size($INarray);
$INarray[$SizeOfArray] = ( $NewItem );
return $SizeOfArray;
}
/////////////////////////////////
proc int SecondArrayInsertAtEndofArray( string $INarray[], string $NewItem[]){ 
int $SizeOfArray;
$SizeOfArray = size($INarray);
$INarray[$SizeOfArray] = ( $NewItem[0] );
return $SizeOfArray;
}
/////////////////////////////////

/////////////////////////////////


//THe Begining 
if ( `objExists IntersectFormLayer` == 0  ) {
createDisplayLayer -name "IntersectFormLayer" -number 1 -empty;
setAttr IntersectFormLayer.color 30;
}

if ( `objExists IntersectFormLayerOutofRange` == 0  ) {
createDisplayLayer -name "IntersectFormLayerOutofRange" -number 1 -empty;
setAttr IntersectFormLayerOutofRange.color 2;
}

if ( `objExists IntersectFormLayerINRange` == 0  ) {
createDisplayLayer -name "IntersectFormLayerINRange" -number 1 -empty;
setAttr IntersectFormLayerINRange.color 3;
}


if ( `objExists layerYZYXPlains` == 0  ) {
createDisplayLayer -name "layerYZYXPlains" -number 1 -empty;
}

if ( `objExists layerAllCurves1` == 0  ) {
createDisplayLayer -name "layerAllCurves1" -number 1 -empty;
}
if ( `objExists layerEdgeCurveZ1` == 0  ) {
createDisplayLayer -name "layerEdgeCurveZ1" -number 1 -empty;
}
if ( `objExists layerCurvesOutofRange1` == 0  ) {
createDisplayLayer -name "layerCurvesOutofRange1" -number 1 -empty;
setAttr layerCurvesOutofRange1.color 12;
}
if ( `objExists layerCurvesINRange1` == 0  ) {
createDisplayLayer -name "layerCurvesINRange1" -number 1 -empty;
setAttr layerCurvesINRange1.color 6;
}
string $newSet1 = `sets -name TheLastCurvesSet`;
if ( `objExists ZEdgeCurvesSet` == 0  ) {
string $newSet1 = `sets -name ZEdgeCurvesSet`;
}
if ( `objExists ZPlaneCurvesSet` == 0  ) {
string $newSet2 = `sets -name ZPlaneCurvesSet`;
}

//////////////////////////////////////////////////////////////////////////////
//string $listofallcurves[];
//$listofallcurves = `queryLayerRangeMembers`;

//$EdgeCurves = $listofallcurves;


proc string[] RemoveNoLongerExistingFromArray(string $EdgeCurveZ1[]){
int $SizeOfArrayA = size($EdgeCurveZ1);
if ( $SizeOfArrayA > 0){
int $SizeOfArray = size($EdgeCurveZ1) -1;
int $i = -1;
int $E = -1;
while( $E < $SizeOfArray ){
$i++;
$E++;

if ( `objExists $EdgeCurveZ1[$i]` == 0  ) {
 stringArrayRemoveAtIndex($i, $EdgeCurveZ1);
if ($i == 0) { $i = -1;} else { $i = $i -1;}   
}

}
print $EdgeCurveZ1;
int $SizeOfArrayB = size($EdgeCurveZ1);

return $EdgeCurveZ1;
}
}

//////


/*

//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################


//<synopsis> copys 2 arrays into one

proc appendMultiStringArray( string $copyTo[], string $copyFrom1[], string $copyFrom2[] )
{
$numberToCopy1 = size($copyFrom1);
if( $numberToCopy1 > 0){
	int $i;
	int $j = size($copyTo);
	for( $i = 0; $i < $numberToCopy1; $i++, $j++ ){
		$copyTo[$j] = $copyFrom1[$i]; }
}
$numberToCopy2 = size($copyFrom2);
if( $numberToCopy2 > 0){
	int $k = size($copyTo);
	for( $i = 0; $i < $numberToCopy2; $i++, $k++ ){
		$copyTo[$k] = $copyFrom2[$i]; }
}
}




//

/*
string $queryIntersectFormLayerA[] = `editDisplayLayerMembers -q IntersectFormLayerOutofRange`;
string $queryIntersectFormLayerB[] =  `editDisplayLayerMembers -q IntersectFormLayerINRange`  ;

string $queryIntersectFormLayerC[];
clear $queryIntersectFormLayerC; 
appendMultiStringArray( $queryIntersectFormLayerC, $queryIntersectFormLayerA, $queryIntersectFormLayerB );
print $queryIntersectFormLayerC;

if (size( $queryIntersectFormLayerC) > 0){

proc EVALCamScripts2(){
$runit = "MoveZSURFACEModelingCAM($EdgeCurveZ2, $CamConeLocator);";
 eval($runit); }
EVALCamScripts2;
string $queryIntersectFormLayerB[] =  `editDisplayLayerMembers -q IntersectFormLayerINRange`  ;


*/


	proc MoveZSURFACEModelingCAM(string $ConeLocator[]){

string $queryIntersectFormLayerA[] = `editDisplayLayerMembers -q IntersectFormLayerOutofRange`;
string $queryIntersectFormLayerB[] =  `editDisplayLayerMembers -q IntersectFormLayerINRange`  ;

string $queryIntersectFormLayerC[];
clear $queryIntersectFormLayerC; 
appendMultiStringArray( $queryIntersectFormLayerC, $queryIntersectFormLayerA, $queryIntersectFormLayerB );
print $queryIntersectFormLayerC;

if (size( $queryIntersectFormLayerC) > 0){

string $listofallSurfaces[];
$listofallSurfaces = $queryIntersectFormLayerC;


string $ObjectsINcamLightCone[];
string $OutofRange[];
layerEditorRemoveObjects IntersectFormLayerINRange ;
editDisplayLayerMembers -noRecurse "defaultLayer" $ObjectsINcamLightCone;
layerEditorRemoveObjects IntersectFormLayerOutofRange ;
editDisplayLayerMembers -noRecurse "defaultLayer" $OutofRange;
clear $ObjectsINcamLightCone;
string $objectZ[];
if (size($objectZ) > 0){ clear $objectZ; }  
stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
stringArrayInsertAtIndex(1, $objectZ, "LocatorA1");
float $pointA1[];
float $pointA2[];
	$pointA1 = `xform -query -worldSpace -translation ( $objectZ[0])`;
	$pointA2 = `xform -query -worldSpace -translation ($objectZ[1])`;
$dAx = $pointA1[0] - $pointA2[0];
$dAy = $pointA1[1] - $pointA2[1];
$dAz = $pointA1[2] - $pointA2[2];
float $distanceAz;
$distanceAz = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
int $radiusZ;
int $distanceAzNUM;
$distanceAzNUM = $distanceAz;
$radiusZ = $distanceAzNUM /2;
int $loopLocatorsCam = 0;
int $loopA = -1;
int $z = -1;
string $currentLocatorZ[];
while ($loopLocatorsCam++ < 7){
$loopA = $loopA +1;
if ($loopA > 0){
$distanceAzNUM = $radiusZ;
}
$radiusZ = $distanceAzNUM /2;
$z = $z +1;
string $currentLocatorZ[];
$currentLocatorZ[0] = $ConeLocator[$z];
//string all locators in order
for ($each in $listofallSurfaces) {


float $pointAZ1[];
float $pointAZ2[];
	$pointAZ1 = `xform -query -worldSpace -translation ($currentLocatorZ)`;
	$pointAZ2 = `xform -query -worldSpace -translation ($each)`;
$dAx = $pointAZ1[0] - $pointAZ2[0];
$dAy = $pointAZ1[1] - $pointAZ2[1];
$dAz = $pointAZ1[2] - $pointAZ2[2];
float $distanceA2;
$distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;

if ( $distanceA2 < $radiusZ ){
stringArrayInsertAtIndex(0, $ObjectsINcamLightCone, $each);
}
}
}
  string $shorterList[] = stringArrayRemoveDuplicates($ObjectsINcamLightCone);
$ObjectsINcamLightCone = $shorterList;
  $OutofRange = stringArrayRemoveExact($ObjectsINcamLightCone, $listofallSurfaces);
editDisplayLayerMembers -noRecurse IntersectFormLayerOutofRange $OutofRange;
editDisplayLayerMembers -noRecurse IntersectFormLayerINRange $ObjectsINcamLightCone;
}
}

//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################
//########################################################################################################



////////////////////

proc MoveZCURVEModelingCAM(string $EdgeCurves[], string $ConeLocator[]){

string $listofallcurves[];
$listofallcurves = $EdgeCurves;

string $ObjectsINcamLightCone[];
string $OutofRange[];
layerEditorRemoveObjects layerCurvesINRange1 ;
editDisplayLayerMembers -noRecurse "defaultLayer" $ObjectsINcamLightCone;
layerEditorRemoveObjects layerCurvesOutofRange1 ;
editDisplayLayerMembers -noRecurse "defaultLayer" $OutofRange;
clear $ObjectsINcamLightCone;
string $objectZ[];
if (size($objectZ) > 0){ clear $objectZ; }  
stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
stringArrayInsertAtIndex(1, $objectZ, "LocatorA1");
float $pointA1[];
float $pointA2[];
	$pointA1 = `xform -query -worldSpace -translation ( $objectZ[0])`;
	$pointA2 = `xform -query -worldSpace -translation ($objectZ[1])`;
$dAx = $pointA1[0] - $pointA2[0];
$dAy = $pointA1[1] - $pointA2[1];
$dAz = $pointA1[2] - $pointA2[2];
float $distanceAz;
$distanceAz = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;
int $radiusZ;
int $distanceAzNUM;
$distanceAzNUM = $distanceAz;
$radiusZ = $distanceAzNUM /2;
int $loopLocatorsCam = 0;
int $loopA = -1;
int $z = -1;
string $currentLocatorZ[];
while ($loopLocatorsCam++ < 7){
$loopA = $loopA +1;
if ($loopA > 0){
$distanceAzNUM = $radiusZ;
}
$radiusZ = $distanceAzNUM /2;
$z = $z +1;
string $currentLocatorZ[];
$currentLocatorZ[0] = $ConeLocator[$z];
//string all locators in order
for ($each in $listofallcurves) {
float $pointAZ1[];
float $pointAZ2[];
	$pointAZ1 = `xform -query -worldSpace -translation ($currentLocatorZ)`;
	$pointAZ2 = `xform -query -worldSpace -translation ($each)`;
$dAx = $pointAZ1[0] - $pointAZ2[0];
$dAy = $pointAZ1[1] - $pointAZ2[1];
$dAz = $pointAZ1[2] - $pointAZ2[2];
float $distanceA2;
$distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy * $dAy) + ($dAz * $dAz) )`;

if ( $distanceA2 < $radiusZ ){
stringArrayInsertAtIndex(0, $ObjectsINcamLightCone, $each);
}
}
}
  string $shorterList[] = stringArrayRemoveDuplicates($ObjectsINcamLightCone);
$ObjectsINcamLightCone = $shorterList;
  $OutofRange = stringArrayRemoveExact($ObjectsINcamLightCone, $listofallcurves);
editDisplayLayerMembers -noRecurse layerCurvesOutofRange1 $OutofRange;
editDisplayLayerMembers -noRecurse layerCurvesINRange1 $ObjectsINcamLightCone;
}


proc LockModelingCAM(){
setAttr -lock true "ZCURVEModelingCAM.tx";
setAttr -lock true "ZCURVEModelingCAM.ty";
setAttr -lock true "ZCURVEModelingCAM.tz";
setAttr -lock true "ZCURVEModelingCAM.rx";
setAttr -lock true "ZCURVEModelingCAM.ry";
setAttr -lock true "ZCURVEModelingCAM.rz";
}

proc UnLockModelingCAM(){
setAttr -lock false "ZCURVEModelingCAM.tx";
setAttr -lock false "ZCURVEModelingCAM.ty";
setAttr -lock false "ZCURVEModelingCAM.tz";
setAttr -lock false "ZCURVEModelingCAM.rx";
setAttr -lock false "ZCURVEModelingCAM.ry";
setAttr -lock false "ZCURVEModelingCAM.rz";
}





//////////////////////////////////////////

//////////////////////////////////////////

//////////////////////////////////////////

//////////////////////////////////////////
//////////////////////////////////////////


proc int stringArrayMatch(string $item, string $list[]){
	int $result = false;	
	string $listItem;
string $listMatch;	
	for ($listItem in $list) {
$listMatch = `match $item $listItem`;
		if ( size($listMatch) > 0){
		$result = true; break; }
	}	
	return $result;
}
//////////////////////////////////////////

//////////////////////////////////////////
proc int ISobjectSelectedTypeCurve2(){
	int $result = false;	
string $C[];
$C = `ls -sl`;
string $nametypeZ[] = `ls -showType $C`;
string $names1 = "curve";
string $names2 = "Curve";
string $names3 = "cv";
string $names4 = "ep";
int $zeroOR1A = stringArrayMatch($names1, $nametypeZ);
int $zeroOR1B = stringArrayMatch($names2, $nametypeZ);
int $zeroOR1C = stringArrayMatch($names3, $nametypeZ);
int $zeroOR1D = stringArrayMatch($names4, $nametypeZ);
int $zeroOR1B = stringArrayMatch($names1, $nametypeZ);
if (( $zeroOR1A == 1) || ( $zeroOR1B == 1)){
if (( $zeroOR1C == 1) || ( $zeroOR1D == 1)){
$result = false;
} else { $result = true; }
}
	return $result;
}
//-conditionTrue
//$scriptt_jobNum = `scriptJob -conditionTrue ISobjectSelectedTypeCurve2 -compressUndo true -protected`;
//////////////////////////////////////////


proc int ISobjectSelectedTypeCurve(){
string $C[];
$C = `ls -sl`;
string $nametypeZ[] = `ls -showType $C`;
string $nameA;
$nameA = `match "[a-zA-Z]+" $nametypeZ[0]`;
int $zeroOR1Z = `gmatch "Curve" $nameA`;
print $zeroOR1Z;
return $zeroOR1Z;
}



//SWITCH///////////////////////////////////////////////////////////////
global string $proc = "StartofCurveScriptIntersectXYZ;";

proc stringsStart(){
string $stringsStart = ("global string $proc = " +"\"StartofCurveScriptIntersectXYZ;"+"\";");
eval( $stringsStart );
print $stringsStart;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
proc stringsA(){
string $stringsA = ("global string $proc = " +"\"EvalDrawCurveDisConnectA;"+"\";");
eval( $stringsA );

}

proc stringsB(){
string $stringsB = ("global string $proc = " +"\"EvalDrawCurveDisConnectB;"+"\";");
eval( $stringsB );
}
proc stringsC(){
string $stringsC = ("global string $proc = " +"\"RUNprojectTAN;"+"\";");
eval( $stringsC );
}
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////
proc EvalStart(){
evalDeferred start; }

proc start(){
stringsStart; }

/////////////////////////////////////////////////////////////////

proc StartofCurveScriptIntersectXYZ(){
string $deleteLiveCurveShape;
string $deleteLiveCurve;
int $firstcurveswitch;
string $objectcurV[];
clear $objectcurV;
$objectcurV = `ls -sl`;
ResetTranlation($objectcurV);
string $objectSelection[] = { "Zcurvez", "Xcurvez" };
string $oneSelection[];
clear $oneSelection;
for ($each in $objectSelection) {
int $ISTRUE03B = catchQuiet($intersectCurveZ03 = `curveIntersect -ch 0 -ud 0 -tol 0.01 $objectcurV $each`);
int $numIntZ03 = size($intersectCurveZ03);
	if (($ISTRUE03B > 0) || ($numIntZ03 > 0)) {
 stringArrayInsertAtIndex(0, $oneSelection, $each);
}
}
int $getSize = size ($oneSelection);
	if ( $getSize > 1){
	print "wrong";
//run once scriptjob... JUst run again
$firstcurveswitch = 0;
}
if ( $getSize == 1){
if ( `gmatch $oneSelection[0] "Zcurvez"` == 1){ 
print "Zcurvez";
$firstcurveswitch = 1;
 }
if ( `gmatch $oneSelection[0] "Xcurvez"` == 1){ 
print "Zcurvez";
$firstcurveswitch = 2;
 }
}
switch($firstcurveswitch) {
	case 0:
	print "wrong";
delete $objectcurV;
EvalStart;
break;
	case 1:
select -r Zplane;
rebuildSurface -ch 0 -rpo 1 -rt 6 -end 1 -kr 2 -kcp 0 -kc 1 -su 98 -du 3 -sv 98 -dv 3 -tol 0.001 -fr 0  -dir 2 "Zplane";
select -cl  ;
select -r Zplane;
PAUSE;
select -cl  ;
PAUSE;
select -r Zplane;
PAUSE;
select -cl  ;
rebuildSurface -ch 0 -rpo 1 -rt 6 -end 1 -kr 2 -kcp 0 -kc 1 -su 1 -du 3 -sv 1 -dv 3 -tol 0.001 -fr 0  -dir 2 "Zplane";
makeLive Zplane;
delete $objectcurV;

stringsA;

break;
	case 2:
select -r Xplane;
rebuildSurface -ch 0 -rpo 1 -rt 6 -end 1 -kr 2 -kcp 0 -kc 1 -su 98 -du 3 -sv 98 -dv 3 -tol 0.001 -fr 0  -dir 2 "Xplane";
select -cl  ;
select -r Xplane;
PAUSE;
select -cl  ;
PAUSE;
select -r Xplane;
PAUSE;
select -cl  ;
rebuildSurface -ch 0 -rpo 1 -rt 6 -end 1 -kr 2 -kcp 0 -kc 1 -su 1 -du 3 -sv 1 -dv 3 -tol 0.001 -fr 0  -dir 2 "Xplane";
makeLive Xplane;
delete $objectcurV;
string $deleteLiveCurveShape;
$deleteLiveCurveShape = "XplaneShape->drawCurveShape";
string $deleteLiveCurve;
$deleteLiveCurve = "XplaneShape->drawCurve";

stringsB;


break;
}

}



////////////////////////////////////////////////////////

global int $xii;
global int $xii = 0;


////////////////////////////////////////////////////////


proc DrawCurveDisConnectA(int $xii){
global string $EdgeCurveZ2[];
global int $xii;
int $xi = $xii;
rename drawCurve;
duplicateCurve -ch 1 -rn 0 -local 0 ;
rename drawCurveA;
if ($xi == 0 ){

DeleteHistory ZplaneShape->drawCurveShape;
delete ZplaneShape->drawCurveShape;
delete ZplaneShape->drawCurve;
}
string $Renamed1[];
string $Renamed2[];
$Renamed1[0] = `rename drawCurveA Curve`;
ResetTranlation($Renamed1); 
if ( `gmatch $Renamed1[0] "Curve"` == 1){
$Renamed2[0] = `rename $Renamed1 Curve0`;
$Renamed1 = $Renamed2;
}
ResetTranlation($Renamed1); 
select -r $Renamed1;
string $ParentArc[];
$ParentArc = `Make_Middle_of_Curve_ParamlocatorZ($Renamed1)`;
delete $Renamed1;
rename $ParentArc $Renamed1;
sets -include ZEdgeCurvesSet $Renamed1;
select -r ZEdgeCurvesSet;
editDisplayLayerMembers -noRecurse layerAllCurves1 $Renamed1;
evalEdgecurvesZ2;
EvalAddingCurves;
RUNMoveZCURVEM;
eval(" $jobNumtranslateCAM = `scriptJob -attributeChange ZCURVEModelingCAM.translate RUNMoveZCURVEM`;");
eval(" $jobNumrotateCAM = `scriptJob -attributeChange ZCURVEModelingCAM.rotate RUNMoveZCURVEM`;");
makeLive LiveSurfaceB ;
stringsC;

}



////////////////////////////////////////////////////////

proc DrawCurveDisConnectB(int $xii){
global string $EdgeCurveZ2[];
global int $xii;
int $xi = $xii;
rename drawCurve;
duplicateCurve -ch 1 -rn 0 -local 0 ;
rename drawCurveA;
if ($xi == 0 ){

DeleteHistory XplaneShape->drawCurveShape;
delete XplaneShape->drawCurveShape;
delete XplaneShape->drawCurve;
}
string $Renamed1[];
string $Renamed2[];
$Renamed1[0] = `rename drawCurveA Curve`; 
ResetTranlation($Renamed1); 
int $trueORfalse = FindIfCurveCrossesZ($Renamed1);
print $trueORfalse;
if ( $trueORfalse == 1){ 
CutCurveIFConditionTRUETransitZ($Renamed1); }
select -r $Renamed1;
string $rebuildfirstcurve[];
$rebuildfirstcurve = `rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 16 -d 3 -tol 0.001 $Renamed1`;
string $ParentArc[];
$ParentArc = `Make_Middle_of_Curve_ParamlocatorZ($rebuildfirstcurve)`;
print $ParentArc;
delete $Renamed1;
rename $ParentArc Curve;
$ParentArc = {"Curve"};
$Renamed1 = $ParentArc;
if ( $trueORfalse == 1){ 
sets -include ZEdgeCurvesSet $ParentArc;
 }

if ( `gmatch $Renamed1[0] "Curve"` == 1){
$Renamed2[0] = `rename $Renamed1 Curve0`;
$Renamed1 = $Renamed2;
}

MirrorANDrename($Renamed1);
editDisplayLayerMembers -noRecurse layerAllCurves1 $Renamed1;
select -r $Renamed1;
evalEdgecurvesZ2;
EvalAddingCurves;
RUNMoveZCURVEM;
eval(" $jobNumtranslateCAM = `scriptJob -attributeChange ZCURVEModelingCAM.translate RUNMoveZCURVEM`;");
eval(" $jobNumrotateCAM = `scriptJob -attributeChange ZCURVEModelingCAM.rotate RUNMoveZCURVEM`;");
makeLive LiveSurfaceB ;
stringsC;

}


////////////////////////////////////////////////////////


proc EvalDrawCurveDisConnectA(){
eval("DrawCurveDisConnectA($xii);");
}
proc EvalDrawCurveDisConnectB(){
eval("DrawCurveDisConnectB($xii);");
}


////////////////////////////////////////////////////////



//////////////////////////////////////////
//this is very imortant

proc int ifCurveToolsCTX1(){
string $whichCtx;
$whichCtx = `currentCtx`;
string $list[] = { "pencilContext"};   
	int $result = false;	
	string $listItem;
string $listMatch;	
	for ($listItem in $list) {
$listMatch = `match $whichCtx $listItem`;
		if ( size($listMatch) > 0){
		$result = true; break; }
	}	
	return $result;
}

///////////////

///////////////

proc int ifCurveToolsCTX2(){
string $whichCtx;
$whichCtx = `currentCtx`;
string $list[] = {"curveContextEP", "curveAddPtContext"};   
	int $result = false;	
	string $listItem;
string $listMatch;	
	for ($listItem in $list) {
$listMatch = `match $whichCtx $listItem`;
		if ( size($listMatch) > 0){
		$result = true; break; }
	}	
	return $result;
}

//

proc int ifCurveToolsCTX3(){
string $whichCtx;
$whichCtx = `currentCtx`;
string $list[] = {"threePointArcContext"};   
	int $result = false;	
	string $listItem;
string $listMatch;	
	for ($listItem in $list) {
$listMatch = `match $whichCtx $listItem`;
		if ( size($listMatch) > 0){
		$result = true; break; }
	}	
	return $result;
}

///////////////

proc int ifCurveToolsCTX4(){
string $whichCtx;
$whichCtx = `currentCtx`;
string $list[] = {"selectSuperContext", "moveSuperContext", "lassoSelectContext", "RotateSuperContext",
 "scaleSuperContext", "xformManipContext", "softModContext" };   
	int $result = false;	
	string $listItem;
string $listMatch;	
	for ($listItem in $list) {
$listMatch = `match $whichCtx $listItem`;
		if ( size($listMatch) > 0){
		$result = true; break; }
	}	
	return $result;
}



///////////////


///////////////


proc EvalAutoCurvesScripts(){

int $IsCurveToolSelected1 = `ifCurveToolsCTX1`;
if ($IsCurveToolSelected1 == 1){
eval("$xii = 0;");
eval("EVALKILLjobB($scriptt_jobAllCurvesToolsNumB);");
EvalAllCurvesTools; }

int $IsCurveToolSelected2 = `ifCurveToolsCTX2`;
if ($IsCurveToolSelected2 == 1){
eval("$xii = 0;");
eval("EVALKILLjobA($scriptt_jobAllCurvesToolsNumA);");
EvalAllCurvesTools2;
 }

int $IsCurveToolSelected3 = `ifCurveToolsCTX3`;
if ($IsCurveToolSelected3 == 1){
eval("$xii = 1;");
eval("EVALKILLjobA($scriptt_jobAllCurvesToolsNumA);");
EvalAllCurvesTools2;
 }

int $IsCurveToolSelected4 = `ifCurveToolsCTX4`;
if ($IsCurveToolSelected4 == 1){
setAttr layerYZYXPlains.visibility 0;
string $itemsCurrentlySelectedZ[] = `ls -sl`;
select -cl  ;
makeLive;
select -r $itemsCurrentlySelectedZ; 
 } 

if ($IsCurveToolSelected4 == 0){
string $queryCURVESz[] = `queryLayerRangeMembers`;
if  (size($queryCURVESz) > 0){
setAttr layerYZYXPlains.visibility 1;
makeLive LiveSurfaceB;
}
 }

}

///////////////

///////////////

///////////////
proc AutoCurveScripts(){
int $ifCond_is_True = `ISobjectSelectedTypeCurve2`;
if ($ifCond_is_True == 1){
//   This is just the curve script you need this to be where the switch is
eval"evalEcho($proc);";
}
}
///////////////
print $proc;

int $script_jobToolChangedNum1;
int $scriptt_jobAllCurvesToolsNumA;
int $scriptt_jobAllCurvesToolsNumB;
int $script_jobToolChangedNum2;
int $script_jobToolChangedNum1;
int $jobNumtranslateCAM;
int $jobNumrotateCAM;
///////////////
proc AutoCurveScripts2(){
EvalKillToolChangedNum1;
 EvalCurveToolChanged2;
evalDeferred("int $script_jobToolChangedNum1 = `scriptJob -event ToolChanged EvalAutoCurvesScripts`;");
}

proc EvalAllCurvesTools(){
eval("int $scriptt_jobAllCurvesToolsNumA = `scriptJob -event DagObjectCreated AutoCurveScripts -compressUndo true -protected `;");
}
proc EvalAllCurvesTools2(){
eval("int $scriptt_jobAllCurvesToolsNumB = `scriptJob -event DagObjectCreated AutoCurveScripts2 -compressUndo true -protected `;");
}

proc EvalCurveToolChanged2(){
eval("int $script_jobToolChangedNum2 = `scriptJob -runOnce 1 -event ToolChanged AutoCurveScripts`;");
}


proc EVALKILLjobA(int $scriptt_jobAllCurvesToolsNumA ){
if (! $scriptt_jobAllCurvesToolsNumA == 0  ) {
EvalKilljobAllCurvesToolsNumA; }
}

proc EVALKILLjobB(int $scriptt_jobAllCurvesToolsNumB ){
if (! $scriptt_jobAllCurvesToolsNumB == 0  ) {
EvalKilljobAllCurvesToolsNumB; }
}

//eval("EVALKILLjobA($scriptt_jobAllCurvesToolsNumA);");
//eval("EVALKILLjobB($scriptt_jobAllCurvesToolsNumB);");




//if (! $scriptt_jobAllCurvesToolsNumB == 0  ) {
//EvalKilljobAllCurvesToolsNumB;
//print "Yes"; }



proc EvalKilljobAllCurvesToolsNumA(){
eval("scriptJob -kill $scriptt_jobAllCurvesToolsNumA -force;");
}

proc EvalKilljobAllCurvesToolsNumB(){
eval("scriptJob -kill $scriptt_jobAllCurvesToolsNumB -force;");
}

proc EvalKillToolChangedNum1(){
eval("scriptJob -kill $script_jobToolChangedNum1 -force;");
}




proc EvalRUNToolChangedNum1(){
eval("int $script_jobToolChangedNum1 = `scriptJob -event ToolChanged EvalAutoCurvesScripts`;");
}


//// ##############   
//$scriptXYZ_jobNum = `scriptJob -runOnce 1 -event DagObjectCreated StartofCurveScriptIntersectXYZ -protected`;




proc RUNprojectTAN(){

$runitA = "AdvancedCurveMODprojectTAN($EdgeCurveZ2, $plainNum);";
eval($runitA);

}

int $addNumbersA;
$addNumbersA = 0;

global int $script_jobNumIdle_MoveZCURVEM;

proc RUNMoveZCURVEM(){
int $script_jobNumIdle_MoveZCURVEM = `scriptJob  -runOnce 1 -event idle EVALCamScripts`;
}


proc int addNumbers(){
int $CreatedObjectCurve = `ISobjectSelectedTypeCurve`;
return $CreatedObjectCurve; 
}

proc int addedNumbers(int $addNumbersA){
int $numerOfCreatedCurve = `addNumbers`;
int $numerOfCreated = $numerOfCreatedCurve; 
if ($numerOfCreated == 1){
int $addNumberZ = $addNumbersA + $numerOfCreatedCurve;
$addNumbersA = $addNumberZ;
print $addNumbersA;
}
return $addNumbersA;
}

proc EvalAddingCurves(){
$runitA = "$addNumbersA = addedNumbers($addNumbersA);";
eval($runitA);
}

proc EvalcreatSphere(){
$runitA = "creatSphere($addNumbersA);";
eval($runitA);
}

proc evalEdgecurvesZ2(){
eval("$EdgeCurveZ2 = `editDisplayLayerMembers -q layerAllCurves1`;");
}


proc creatSphere(int $addNumbersA ){
int $x = $addNumbersA;
print ($addNumbersA + "\n");
if ($x == 8){
//LockModelingCAM;
print "FOUR CURVES";
MakeAutoBoundryUI;
}
}

proc makeSurfaceAndclose(string $dialogBoxWin){
eval("deleteUI $dialogBoxWin;");
eval("int $script_jobNumIdle_KILLtanCurveRUNautoboundry = `scriptJob  -runOnce 1 -event idle KILLtanCurveRUNautoboundry`;");
eval("$addNumbersA = 0;");

}

proc SkipAutoBoundry(string $dialogBoxWin){
eval("deleteUI $dialogBoxWin;");
eval("$addNumbersA = 0;");
}

global string $dialogBoxWin;

global proc MakeAutoBoundryUI(){

//deleteUI $dialogBoxWin;
global string $dialogBoxWin;
$dialogBoxWin = `window 
- title "JFS AutoBoundry" 
-resizeToFitChildren true 
-interactivePlacement 
-toolbox true`;

columnLayout -adjustableColumn true;

nodeIconButton -style "iconAndTextHorizontal"
-label "Make Surface From Curve Network"
-width 90
-height 40
-image1 "skin.xpm"
-command "makeSurfaceAndclose($dialogBoxWin)";

string $button2 = `nodeIconButton -style "textOnly"
-label "Skip"
-width 60
-height 30
-marginWidth 5
 -command "SkipAutoBoundry($dialogBoxWin)"`;
showWindow $dialogBoxWin;
eval("$dialogBoxWin = $dialogBoxWin;");
}


proc KILLtanCurveRUNautoboundry(){
eval("scriptJob -kill $jobNumtranslateCAM -force;");
eval("scriptJob -kill $jobNumrotateCAM -force;");
eval("scriptJob -kill $script_jobToolChangedNum1 -force;");
evalDeferred BOUNDRYeveryNthCurve;
}



//global int $script_jobToolChangedNum1;
//global int $script_jobNumIdle_KILLtanCurveRUNautoboundry;
//global int $jobNumtranslateCAM;
//global int $jobNumrotateCAM;

proc TRIGGER_RUNjobNumTAN(){
eval("$script_jobToolChangedNum1 = `scriptJob -event ToolChanged EvalAutoCurvesScripts`;");
eval("$jobNumtranslateCAM = `scriptJob -attributeChange ZCURVEModelingCAM.translate RUNMoveZCURVEM`;");
eval("$jobNumrotateCAM = `scriptJob -attributeChange ZCURVEModelingCAM.rotate RUNMoveZCURVEM`;");
}

// scriptJob -kill $scripttt_jobNumTAN -force;

//      scriptJob -listJobs ;

//eval("int $scripttt_jobNumTAN = `scriptJob -event DagObjectCreated RUNprojectTAN -compressUndo true -protected`;");

////////////////////////////////////////////////////////////////////

proc EVALCamScripts(){
$runit = "CatchMoveZCURVECAM($EdgeCurveZ2, $CamConeLocator);";
 eval($runit); }


proc EVALCamScripts2(){
$runit = "MoveZSURFACEModelingCAM($CamConeLocator);";
 eval($runit); }

//old 
// proc EVALCamScripts(){
// $runit = "MoveZCURVEModelingCAM($EdgeCurveZ2, $CamConeLocator);";
// eval($runit); }

//NEw
////////////////////////////////////////////////////////////////////

proc CatchMoveZCURVECAM(string $EdgeCurveZ2[], string $CamConeLocator[]){
if ( catchQuiet(MoveZCURVEModelingCAM($EdgeCurveZ2, $CamConeLocator))) {
RemoveNoLongerExistingFromArray( $EdgeCurveZ2);
MoveZCURVEModelingCAM($EdgeCurveZ2, $CamConeLocator);
  } else {
      print "move Cam";
  }
}

////////////////////////////////////////////////////////////////////





//Text_SelectxThexZxAxisxORxthexXxAxisx_1
//Text_byxDrawingxaxLinexOverxOnexofxThexCurves_1;

handleScriptEditorAction "toggleSuppressInfos";
handleScriptEditorAction "toggleSuppressWarnings";
handleScriptEditorAction "toggleSuppressErrors";

setWireframeOnShadedOption 1 modelPanel4;

createStageOne;
$CamConeLocator = `CreateCAMforIntCurveScript`;
select -r $CamConeLocator;
HideSelectedObjects;
//hideKeepSelection `ls -sl`;


//$scriptXYZ_jobNum = `scriptJob -runOnce 1 -event DagObjectCreated StartofCurveScriptIntersectXYZ -protected`;

shadingNode -asShader lambert;
$material = `shadingNode -asShader lambert -name LIVEsurfaceslambert`;
	$sg = `sets -renderable true -noSurfaceShader true -empty -name ($material + "SG")`;
setAttr "LIVEsurfaceslambert.transparency" -type double3 1 1 1 ;

defaultNavigation -source LIVEsurfaceslambert -destination |LiveSurfaceB|LiveSurfaceBShape.instObjGroups[0] -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert", "LiveSurfaceBShape.instObjGroups[0]");

defaultNavigation -source LIVEsurfaceslambert -destination |Zplane|ZplaneShape.instObjGroups[0] -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert", "ZplaneShape.instObjGroups[0]");

defaultNavigation -source LIVEsurfaceslambert -destination |Xplane|XplaneShape.instObjGroups[0] -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert", "XplaneShape.instObjGroups[0]");



///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////// BOUNDRYeveryNthCurve;
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

/*
string $queryIntersectFormLayer[];
 $queryIntersectFormLayer = `editDisplayLayerMembers -q IntersectFormLayer`;
*/


proc string[] queryLayerRangeMembers(){
string $query[];
string $queryOutofRangeLayer[];
string $queryINRangeLayer[];
 $queryOutofRangeLayer = `editDisplayLayerMembers -q layerCurvesOutofRange1`;
 $queryINRangeLayer = `editDisplayLayerMembers -q layerCurvesINRange1`;
if (size($queryOutofRangeLayer) > 0){
  appendStringArray($query, $queryOutofRangeLayer, size($queryOutofRangeLayer));
}
if (size($queryINRangeLayer) > 0){
  appendStringArray($query, $queryINRangeLayer, size($queryINRangeLayer));
}  
return $query;
}


proc BOUNDRYeveryNthCurve(){
string $everyFirstCurveShapeset[];
string $query[];
clear $query;
string $queryOutofRangeLayer[];
string $queryINRangeLayer[];
 $queryOutofRangeLayer = `editDisplayLayerMembers -q layerCurvesOutofRange1`;
 $queryINRangeLayer = `editDisplayLayerMembers -q layerCurvesINRange1`;
if (size($queryOutofRangeLayer) > 0){
  appendStringArray($query, $queryOutofRangeLayer, size($queryOutofRangeLayer));
}
if (size($queryINRangeLayer) > 0){
  appendStringArray($query, $queryINRangeLayer, size($queryINRangeLayer));
}  
///////////////////////
$everyFirstCurveShapeset = `ls -assemblies $query`;
string $newEdgeCurve[];
clear $newEdgeCurve;
$newEdgeCurve = `AutoBoundryScript($everyFirstCurveShapeset)`;
print $newEdgeCurve; 
layerEditorEmpty layerCurvesINRange1;
layerEditorEmpty layerCurvesOutofRange1;
layerEditorEmpty layerEdgeCurveZ1;
editDisplayLayerMembers -noRecurse layerEdgeCurveZ1 $newEdgeCurve;
eval("$EdgeCurveZ2 = `editDisplayLayerMembers -q layerEdgeCurveZ1`;");
UnLockModelingCAM;
evalDeferred TRIGGER_RUNjobNumTAN;
}







//##_START_OF_AUTOBOUNDRY_########################################################////////////////////
//##_AutoBoundryScript_########################################################///////////////////////

proc string[] AutoBoundryScript(string $everyFirstCurveShapeset[]){


string $EdgeCurveZ[];
string $EdgeCurveZ2[];
clear $EdgeCurveZ2;
string $EdgeCurveZ3[];
string $newallCurves[];
$newallCurves = $everyFirstCurveShapeset;

int $EndAll = 0;

int $everycurveSize = size($everyFirstCurveShapeset);
while( size($everyFirstCurveShapeset) > 2 ){ 
$EndAll++;

if ( $EndAll == 1000 ){
clear $everyFirstCurveShapeset;
} 
if (size($everyFirstCurveShapeset) == 3 ){
 stringArrayInsertAtIndex(0, $EdgeCurveZ2, $everyFirstCurveShapeset[0]);
 stringArrayInsertAtIndex(0, $EdgeCurveZ2, $everyFirstCurveShapeset[1]);
 stringArrayInsertAtIndex(0, $EdgeCurveZ2, $everyFirstCurveShapeset[2]);
}

int $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
string $FirstCurvesZ[];
$FirstCurvesZ[0] = $everyFirstCurveShapeset[$everycurveSizeIndex];

string $firstcurveRelatives[];
$firstcurveRelatives = `listRelatives -shapes $FirstCurvesZ`;
string $firstcurveConnectionsz[];
$firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
string $firstcurveConn[] = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;
int $numberofconnections = size($firstcurveConn);

if ( $numberofconnections >= 2 ) {
stringArrayRemoveAtIndex($everycurveSizeIndex, $everyFirstCurveShapeset);
int $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
string $FirstCurvesZ[];
$FirstCurvesZ[0] = $everyFirstCurveShapeset[$everycurveSizeIndex];
}
int $everycurveSize = size($everyFirstCurveShapeset);
int $divide;
int $switchNumber;
if (( $everycurveSize < 1000 ) && ( $everycurveSize >= 500 )){
$divide = $everycurveSize / 50;
$switchNumber = 0; 
print $divide;}
if (( $everycurveSize < 500 ) && ( $everycurveSize >= 250 )){
$divide = $everycurveSize / 25; 
$switchNumber = 0;}
if (( $everycurveSize < 250 ) && ( $everycurveSize >= 100 )){
$divide = $everycurveSize / 12; }
if (( $everycurveSize < 100 ) && ( $everycurveSize >= 50 )){
$divide = $everycurveSize / 5; 
$switchNumber = 0;}
if (( $everycurveSize < 50 ) && ( $everycurveSize >= 20 )){
$divide =$everycurveSize / 4; 
$switchNumber = 0;}
if (( $everycurveSize < 20 ) && ( $everycurveSize > 18 )){
$divide = $everycurveSize / 2;
$switchNumber = 0;
print $divide;
 }
if ( $everycurveSize <= 18 ){
$switchNumber = 1;
 }

int $n;

switch($switchNumber) 

{
	case 0:
	int $n = $divide;
	string $NearestCurvesZ[] = (NearestObjectArray($n, $everyFirstCurveShapeset));
	int $n2 = $n * 2;
	string $NearestCurvesZn2[] = (NearestObjectArray($n2, $everyFirstCurveShapeset));
break;

	case 1:
	string $NearestCurvesZ[] = $everyFirstCurveShapeset;
	string $NearestCurvesZn2[] = $everyFirstCurveShapeset;
break;

}

print $NearestCurvesZ; 

string $TEMPzCurveAAb[];
if ( size($TEMPzCurveAAb) > 0){
clear $TEMPzCurveAAb;
}
int $ISTRUE0A1;
int $numIntZZ;
for ( $eachZ in $NearestCurvesZ ) {

int $ISTRUE0A1 = catchQuiet($intersectCurveZ0 = `curveIntersect -ch 0 -ud 0 -tol 0.01 $FirstCurvesZ $eachZ`);
int $numIntZZ = size($intersectCurveZ0);
	if (($ISTRUE0A1 > 0) || ($numIntZZ > 0)) {
stringArrayInsertAtIndex(0, $TEMPzCurveAAb, $eachZ);
}
}


$NearestCurvesZ = $TEMPzCurveAAb;
int $numIntAX1 = size($TEMPzCurveAAb);

int $switchNumberA;
if ( $numIntAX1 == 0 ){
 string $removeoneFromeveryFirstA[];
$removeoneFromeveryFirstA = stringArrayRemove($FirstCurvesZ, $everyFirstCurveShapeset);
$everyFirstCurveShapeset = $removeoneFromeveryFirstA;
$switchNumberA = 0;
}


string $TEMPzCurveA[0];
$numInts2 = size($TEMPzCurveA);
if ( $numInts2 > 0 ){
clear $TEMPzCurveA;
}


if ( $numIntAX1 == 0 ){
$switchNumberA = 0;
}


string $diff[];
if ( size($diff) > 0){
clear $diff;
}
$diff = stringArrayRemove($NearestCurvesZ, $NearestCurvesZn2);


if( size($diff) == 0 ) {
clear $everyFirstCurveShapeset;
clear $NearestCurvesZ; 
$switchNumberA = 1;
} else if( size($diff) > 0 ){
$switchNumberA = 2;
} 

if(( size($NearestCurvesZ) == 3 ) && ($everycurveSize == 3)) {
$switchNumberA = 1; }

switch($switchNumberA) 

{
	case 0:

stringArrayRemoveAtIndex($everycurveSizeIndex, $everyFirstCurveShapeset);
int $everycurveSizeIndex = size($everyFirstCurveShapeset) -1;
string $FirstCurvesZ[];
$FirstCurvesZ[0] = $everyFirstCurveShapeset[$everycurveSizeIndex];

	print "next";
break;

	case 1:
print "done";
 stringArrayInsertAtIndex(0, $EdgeCurveZ, $NearestCurvesZ[0]);
 stringArrayInsertAtIndex(0, $EdgeCurveZ, $NearestCurvesZ[1]);
 stringArrayInsertAtIndex(0, $EdgeCurveZ, $NearestCurvesZ[2]);
break;

	case 2:

for ( $eachAB in $diff ) {
int $ISTRUE0B = catchQuiet($intersectCurveZ1 = `curveIntersect -ch 0 -ud 0 -tol 0.01 $FirstCurvesZ $eachAB`);
int $numIntZZZ = size($intersectCurveZ1);
	if (($ISTRUE0B > 0) || ($numIntZZZ > 0)) {
 stringArrayInsertAtIndex(0, $TEMPzCurveA, $eachAB);
}
}
string $NearestCurvesZA[];
int $numInts2a;
$numInts2a = size($NearestCurvesZA);
if ( $numInts2a > 0 ){
clear $NearestCurvesZA;
} 
$NearestCurvesZA = stringArrayCatenate($NearestCurvesZ, $TEMPzCurveA);
$NearestCurvesZ = $NearestCurvesZA;
string $diffremove[];
int $numInts2a;
$numInts2a = size($diffremove);
if ( $numInts2a > 0 ){
clear $diffremove;
} 
$diffremove = stringArrayRemove($TEMPzCurveA, $diff);
string $TEMPAlldiffCurveZBBBB[];
$numInts = size($TEMPAlldiffCurveZBBBB);
if ( $numInts > 0 ){
clear $TEMPAlldiffCurveZBBBB;
} 
$TEMPAlldiffCurveZBBBB = $diffremove;
//////////////////////////////////////////////////////

string $diffX[]; clear $diffX; string $boundaryCurves[]; clear $boundaryCurves; 
int $numIntxZB; string $OtherCurves[]; clear $OtherCurves; string $oneboundaryCurve[]; clear $oneboundaryCurve;
string $boundaryCurvesAA[]; string $oneboundaryCurve[]; clear $oneboundaryCurve;
string $boundaryCurves[]; 
clear $boundaryCurves;
string $boundaryCurves1[]; 
clear $boundaryCurves1;
	int $X = 1;
	int $ENDLOOPA;
	int $i = 1;
	int $ENDLOOP;
	int $B = 0;
	int $ISTRUE0A001;
	int $numIntZZA;
	int $numIntZZAB;
	int $ISTRUE0B002;
	int $endtrigger = 0;
	int $NEARsize;

	while (size($NearestCurvesZ) > 0 ){
	 if ( $endtrigger == 2 ){ 
	clear $NearestCurvesZ;
	size($NearestCurvesZ); }
int $NEARsize = size($NearestCurvesZ);
 if ( $NEARsize == 1 ){ 
clear $NearestCurvesZ;
} 
for ( $each in $NearestCurvesZ ) {
stringArrayInsertAtIndex(0, $boundaryCurves1, $each);
clear $oneboundaryCurve; 
stringArrayInsertAtIndex(0, $oneboundaryCurve, $boundaryCurves1[0]);
 $X = 1;
$ENDLOOPA = size($TEMPAlldiffCurveZBBBB);
for ( $eachA in $TEMPAlldiffCurveZBBBB ) {
stringArrayInsertAtIndex(0, $boundaryCurves1, $each);
clear $oneboundaryCurve; 
stringArrayInsertAtIndex(0, $oneboundaryCurve, $boundaryCurves1[0]);
int $ISTRUE0A001 = catchQuiet($intersectCurveZ0A = `curveIntersect -ch 0 -ud 0 -tol 1.0 $each $eachA`);
$ENDLOOPA = size($TEMPAlldiffCurveZBBBB);
$X++;
int $numIntZZA = size($intersectCurveZ0A);
if ((($ISTRUE0A001 == 0) && ( $X == $ENDLOOPA)) || (($numIntZZA == 0) && ( $X == $ENDLOOPA))) {
string $removecurveAz2[];
$removecurveAz2[0] = $each;
$NearestCurvesZ = stringArrayRemove($removecurveAz2, $NearestCurvesZ);
int $NEARsize = size($NearestCurvesZ);
 
} else if (($ISTRUE0A001 > 0) || ($numIntZZA > 0)){
	string $diffX[];
	clear $diffX;
	$diffX = stringArrayRemoveExact($oneboundaryCurve, $NearestCurvesZ);
$ENDLOOP = size($diffX);

int $XendtriggerSearch = 1;

	for ( $eachB in $diffX ) {
$XendtriggerSearch++;
PAUSE;
select -r $eachB ;
PAUSE;

 if ( $endtrigger == 2 ){ 
clear $NearestCurvesZ; } 

int $ISTRUE0B002 = catchQuiet($intersectCurveZAB = `curveIntersect -ch 0 -ud 0 -tol 0.001 $eachA $eachB`);

int $numIntZZAB = size($intersectCurveZAB);
int $numsizeNearest = size($NearestCurvesZ); 
int $numsizediffX = size($diffX); 
//
//

if (( $endtrigger == 0 ) && ( $numsizeNearest < 2 )){
 string $removeoneFromeveryFirstA[];
$removeoneFromeveryFirstA = stringArrayRemove($FirstCurvesZ, $everyFirstCurveShapeset);
$everyFirstCurveShapeset = $removeoneFromeveryFirstA;
 }
	if (($ISTRUE0B002 > 0) || ($numIntZZAB > 0)) {
string $Intersectboundarycurves[];
string $myIntersector = `stringArrayIntersector`;
string $Foundboundarycurves[];
clear $Foundboundarycurves;
stringArrayInsertAtIndex(0, $Foundboundarycurves, $FirstCurvesZ[0]);
stringArrayInsertAtIndex(0, $Foundboundarycurves, $each);
stringArrayInsertAtIndex(0, $Foundboundarycurves, $eachA);
stringArrayInsertAtIndex(0, $Foundboundarycurves, $eachB);
for ( $eachboundry in $Foundboundarycurves ) {
PAUSE;
select -r $eachboundry; 
PAUSE;
string $selectedCurve[];
clear $selectedCurve;
$selectedCurve[0] = $eachboundry;
string $firstcurveRelatives[];
$firstcurveRelatives = `listRelatives -shapes $selectedCurve`;
string $firstcurveConnectionsz[];
$firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
string $firstcurveshapes[];
$firstcurveshapes = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;
stringArrayIntersector -edit -allowDuplicates false -intersect $firstcurveshapes $myIntersector;
}
$Intersectboundarycurves = `stringArrayIntersector -query $myIntersector`;
if (size($Intersectboundarycurves) == 1){
clear $NearestCurvesZ; 
}



stringArrayIntersector -edit -reset $myIntersector;
PAUSE; PAUSE; 
select -r $FirstCurvesZ $each $eachA $eachB;

	boundary -ch 1 -or 0 -ep 1 -rn 1 -po 0 -ept 0.1 $FirstCurvesZ $each $eachA $eachB;
string $objectA[] =`ls -sl`;
MirrorANDrename($objectA);
PAUSE; PAUSE;
$endtrigger = $endtrigger +1;

if ((size($Intersectboundarycurves) == 0)&&($endtrigger == 1)&&(size($everyFirstCurveShapeset)<= 4)) {
clear $NearestCurvesZ; clear $everyFirstCurveShapeset; break;
}

if ( $endtrigger == 1 || $endtrigger == 2 ) {
stringArrayInsertAtIndex(0, $boundaryCurves, $each);
stringArrayInsertAtIndex(0, $boundaryCurves, $eachB);
stringArrayInsertAtIndex(0, $boundaryCurves, $eachA);
}
if ( $endtrigger < 2 ){
string $removecurveAz[]; string $removecurveBz[]; string $removecurveCz[]; 
	$removecurveAz[0] = $each;	
	$removecurveBz[0] = $eachB;
	$removecurveCz[0] = $eachA;
string $NearestCurvesZ[] = stringArrayRemove($removecurveAz, $NearestCurvesZ);
string $NearestCurvesZ[] = stringArrayRemove($removecurveBz, $NearestCurvesZ);
string $TEMPAlldiffCurveZBBBB[] = stringArrayRemove($removecurveCz, $TEMPAlldiffCurveZBBBB); }
else if ( $endtrigger == 2 ){ 
clear $NearestCurvesZ; }
  
		     } 
	}
//end of if
}
//end of For
}
}
}

PAUSE; PAUSE;
select -r $boundaryCurves;
PAUSE; PAUSE;
int $boundaryCurvessize = size($boundaryCurves); 
if( $boundaryCurvessize > 0 ) {
for ( $eachboundry in $boundaryCurves ) {
string $selectedCurve[];
clear $selectedCurve;
$selectedCurve[0] = $eachboundry;
string $firstcurveRelatives[];
$firstcurveRelatives = `listRelatives -shapes $selectedCurve`;
string $firstcurveConnectionsz[];
$firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
string $firstcurveConn[] = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;
int $numberofconnectionsFIRST = size($firstcurveConn);

if (( $endtrigger == 1 ) && ( $numberofconnectionsFIRST == 1 )) {

 stringArrayInsertAtIndex(0, $EdgeCurveZ3, $FirstCurvesZ[0]); }

if ( $numberofconnectionsFIRST == 2 ) {
string $firstcurveConn[] = stringArrayRemove($selectedCurve, $everyFirstCurveShapeset);
$everyFirstCurveShapeset = $firstcurveConn;

}
}

}


string $selectedCurve[];
clear $selectedCurve;
$selectedCurve[0] = $FirstCurvesZ[0];
string $firstcurveRelatives[];
$firstcurveRelatives = `listRelatives -shapes $selectedCurve`;
string $firstcurveConnectionsz[];
$firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
string $firstcurveConn[] = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;
int $numberofconnectionsFIRST = size($firstcurveConn);

if (( $endtrigger == 1 ) && ( $numberofconnectionsFIRST == 1 )) {

 stringArrayInsertAtIndex(0, $EdgeCurveZ2, $FirstCurvesZ[0]); }

if ( $endtrigger == 0 ){
 stringArrayInsertAtIndex(0, $EdgeCurveZ2, $FirstCurvesZ[0]); }

string $removeoneFromeveryFirst[];
$removeoneFromeveryFirst = stringArrayRemove($FirstCurvesZ, $everyFirstCurveShapeset);
$everyFirstCurveShapeset = $removeoneFromeveryFirst;
clear $FirstCurvesZ; 
break;
}
}


string $newfoundEdge[];
for ( $eachboundry in $newallCurves ) {
string $selectedCurve[];
clear $selectedCurve;
$selectedCurve[0] = $eachboundry;
string $firstcurveRelatives[];
$firstcurveRelatives = `listRelatives -shapes $selectedCurve`;
string $firstcurveConnectionsz[];
$firstcurveConnectionsz = ` listHistory -future true -pruneDagObjects true $firstcurveRelatives`;
string $firstcurveshapes[];
$firstcurveshapes = `listConnections -shapes 1 -type nurbsSurface $firstcurveConnectionsz`;

if (size($firstcurveshapes) == 1){
 appendStringArray($newfoundEdge, $selectedCurve, 1);
}
if (size($firstcurveshapes) == 0){
 appendStringArray($newfoundEdge, $selectedCurve, 1);
}
}

select -r $newfoundEdge;
return $newfoundEdge;

}



int $script_jobToolChangedNum1;

proc StartupItems(){
optionVar -fv "totalAnimateRollTime" 0.9;
select -r Text_byxDrawingxaxLinexOverxOnexofxThexCurves_1;
allViewFit(0);
allViewFit(1);
select -cl  ;
goToView -1;
pause -sec 2;
optionVar -fv "totalAnimateRollTime" 2.5;
goToView -1;
optionVar -fv "totalAnimateRollTime" 0.4;
setAttr "ZCURVEModelingCAM.centerOfInterest" 72.916917;
int $script_jobToolChangedNum1 = `scriptJob -event ToolChanged EvalAutoCurvesScripts`;
PencilCurveTool;
curveSketchCtx -e -d 3 `currentCtx`;
setAttr layerYZYXPlains.visibility 1;
}

evalDeferred StartupItems;


//////////


//string $objectA[] = `ls -sl`;
//MirrorANDrename($objectA)


proc MirrorANDrename(string $objectA[]){

ResetTranlation($objectA);
	float $posA[];	
	$posA = `xform -q -os -translation $objectA[0]`;
xform -ws -pivots 0 $posA[1] $posA[2];
duplicate -rr; scale -r -1 1 1; 
string $objectDup[] = `ls -sl`;
int $ifCurvetype = `ISobjectSelectedTypeCurve`;

/*
string $shapeA[] = `listRelatives -s $objectA[0]` ;
string $shapeB[] = `listRelatives -s $objectDup[0]` ;	
		$inAttr = $shapeA[0] + ".worldSpace[0]" ;
		$oAttr = $shapeB[0] + ".create" ;
		connectAttr -f $inAttr $oAttr ;
*/

int $numa  = `match "[0-9]+" $objectA[0]`;
string $nameAZ;
$nameAZ = `match "[a-zA-Z]+" $objectA[0]`;
string $renamez;
$renamez = ("A" + $nameAZ + $numa + "A");
string $renameitzA[];
$renameitzA[0] = `rename $objectDup[0] $renamez`;
 makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;
ResetTranlation($renameitzA);

if ($ifCurvetype == 1){
string $ArcLOCZ[];
string $selectedCurve[];
clear $selectedCurve;
$selectedCurve = $objectA;
string $firstcurveRelatives1[];
$firstcurveRelatives1 = `listRelatives -shapes $selectedCurve`;
string $firstcurveConnectionsz2[];
$firstcurveConnectionsz2 = ` listHistory -future false -pruneDagObjects true $firstcurveRelatives1`;

string $ArcCURVEnode = "makeThreePointCircularArc*";
int $IFArcCurveIStrue = stringArrayGmatch($ArcCURVEnode, $firstcurveConnectionsz2);

if ($IFArcCurveIStrue == 1){ 
	string $ArcCURVEnodeZ[];
	string $firstcurveRelatives3[];
	$ArcCURVEnodeZ = stringArrayGmatchToArray($ArcCURVEnode, $firstcurveConnectionsz2);
	$firstcurveRelatives3 = `listHistory -future 0 -pruneDagObjects 0 $ArcCURVEnodeZ`;
	string $ArcCURVEnodeLOC = "ArcLocator*";

int $IFArcLOCIStrue = stringArrayGmatch($ArcCURVEnodeLOC, $firstcurveRelatives3);

if ($IFArcLOCIStrue == 1){ 
	$ArcLOCZ = stringArrayGmatchToArray($ArcCURVEnodeLOC, $firstcurveRelatives3);
float $getXLoc = `getAttr ($ArcLOCZ[0] +".translateX")`;
float $MirrorXLoc = $getXLoc * -1; 

string $objectDupLocs[] = `duplicate -rr $ArcLOCZ[0]`; 
select -r $objectDupLocs;
group -w; 
xform -os -piv 0 0 0;

scale -r -1 1 1;
//string $objectLOCDup[] = `listRelatives $objectDup`; 
select -r $objectDupLocs;
 //capture trans, rot, and scale of object to match
        $outmmesh = ($ArcLOCZ[0] + ".translate"); 
        $inmmesh = ($objectDupLocs[0] + ".translate");
{
$connect = `connectAttr -f $outmmesh $inmmesh`;
}
select -r $ArcLOCZ;
string $objectDupLocs2[] = `duplicate -rr $ArcLOCZ[0]`; 
setAttr ($objectDupLocs2[0] +".translateX") $MirrorXLoc;
parentConstraint -mo -weight 1 $objectDupLocs[0] $objectDupLocs2[0];
select -r $objectDupLocs2;
Make_Middle_of_Curve_ParamlocatorZMirror($renameitzA, $objectDupLocs2);
select -r $objectA ;
}
}
}

}




proc string[] Make_Middle_of_Curve_ParamlocatorZMirror(string $objectCurveSelected[], string $MakeArcLocatorZ[]){

float $arclenghtzALL = `arclen $objectCurveSelected`;
float $arclenghtzDivide = $arclenghtzALL / 2.0;

int $numCVs = `getAttr -size ($objectCurveSelected[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($objectCurveSelected[0] + ".cv[0]") ;			
$CurveSelection[1] = ($objectCurveSelected[0] + ".cv[" + $numCVrealNum + "]") ;
string $paramlocatorZARC[];
$paramlocatorZARC[0] = eval("paramLocator " +  $objectCurveSelected[0] + ".u[" + 0.0 + "]");

float $step = 10; 
int $a = 1;
  	float $t =  $a/$step;

setAttr ( $paramlocatorZARC[0] + ".localPositionX") $t;
string $paramANDCurve[] = `paramToCurvePts( $paramlocatorZARC )`;
float $arclenghtzparamZ = `eval("arclen" + " " + $paramANDCurve[0])`;

float $divZZ = $arclenghtzDivide / $arclenghtzparamZ ;
float $divZZ2 = $t * $divZZ ;
setAttr ( $paramlocatorZARC[0] + ".localPositionX") $divZZ2;
////////////////////// Moved ParamLoc to middle

float $posA[];
float $posB[];
float $posC[];
$posA = `pointPosition -w $CurveSelection[0]`;
$posB = `pointPosition -w $paramlocatorZARC[0]`;
$posC = `pointPosition -w $CurveSelection[1]`;
string $CircularArcFromCurve[];
$CircularArcFromCurve[0] = `createNode makeThreePointCircularArc`;
setAttr ($CircularArcFromCurve[0] + ".pt1") $posA[0] $posA[1] $posA[2] ;
setAttr ($CircularArcFromCurve[0] + ".pt2") $posB[0] $posB[1] $posB[2];
setAttr ($CircularArcFromCurve[0] + ".pt3") $posC[0] $posC[1] $posC[2];
setAttr ($CircularArcFromCurve[0] + ".d") 3;
setAttr ($CircularArcFromCurve[0] + ".s") 8;
string $ArcCurve[];
$ArcCurve[0] = `createNode nurbsCurve` ; 
connectAttr ($CircularArcFromCurve[0] + ".oc") ($ArcCurve[0] +".cr");
//delete $objectCurveSelected; 
string $ParentArc[];
$ParentArc = `listRelatives -parent $ArcCurve`;
ResetTranlation($ParentArc);

$ConnectLocToPoint2 = `connectAttr -f ($MakeArcLocatorZ[0] + ".translate") ( $CircularArcFromCurve[0] + ".pt2")`;

string $ArcZ[];
$ArcZ[0] = `rename $ParentArc $objectCurveSelected`; 
delete $paramlocatorZARC;
delete $objectCurveSelected;

return $ArcZ; 

}


proc int stringArrayGmatch(string $item, string $list[]){
	int $result = false;	
	string $listItem;
	
	for ($listItem in $list) {
		if ( `gmatch $listItem $item` == 1){
		$result = true;
			break;	}
	}	
	return $result;
}


proc string[] stringArrayGmatchToArray(string $item, string $list[]){
	int $result = false;	
	string $listItem;
string $MatchedItem[];	
	for ($listItem in $list) {
		if ( `gmatch $listItem $item` == 1){
		$result = true;
if ($result == true ){ $MatchedItem = {$listItem};}
			break;	}
	}	
	return $MatchedItem;
}



/////////////

proc string[] StraitCurvesSCRIPTZ() {

//StraitCurves SCRIPT 5000

string $ObjectCurve[];
string $StraitCurve[];
$ObjectCurve = `ls -selection`;
xform -cp;
resetPivot;
duplicatePreset(1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1);
string $ObjectCurveduplicate[];

$ObjectCurveduplicate = `ls -selection`;
setAttr ($ObjectCurveduplicate[0] + ".translate") 0 0 0;
setAttr ($ObjectCurveduplicate[0] + ".rotate") 0 0 0;
playButtonStepForward; select -cl  ;

float $rotationz[];
$rotationz = `xform -q -rotation $ObjectCurve`;
float $translationz[];
$translationz = `xform -q -translation $ObjectCurve`;

float $bbox[] = `exactWorldBoundingBox $ObjectCurveduplicate`;
print("Bounding box ranges from: " +
      $bbox[0] + "," + $bbox[1] + "," + $bbox[2] + ", to " +
      $bbox[3] + "," + $bbox[4] + "," + $bbox[5] + ".\n");

spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
move -ws $bbox[0] $bbox[1] $bbox[2] BoxspaceLocatorA;
spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
move -ws $bbox[3] $bbox[4] $bbox[5] BoxspaceLocatorB;
spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
move -ws $bbox[3] $bbox[1] $bbox[2] BoxspaceLocatorC;
spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
move -ws $bbox[0] $bbox[4] $bbox[5] BoxspaceLocatorD;
spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;

// xform -query -worldSpace -translation;


float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox[2]};
float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox[5]};
float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox[2]};
float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox[5]};

$BoxPointA = `MakeCleanFloats($BoxPointA)`;
$BoxPointB = `MakeCleanFloats($BoxPointB)`;
$BoxPointC = `MakeCleanFloats($BoxPointC)`;
$BoxPointD = `MakeCleanFloats($BoxPointD)`;

float $BoxMPointAC[] = MidPointBetween($BoxPointA, $BoxPointC);
float $BoxMPointBD[] = MidPointBetween($BoxPointB, $BoxPointD);
float $BoxMPointAD[] = MidPointBetween($BoxPointA, $BoxPointD);
float $BoxMPointBC[] = MidPointBetween($BoxPointB, $BoxPointC);
//   MoveObjectSelection($BoxMPointAC);

///////////////////////////////
///////////////////////////////

float $CrossMPointAB[] = MidPointBetween($BoxPointA, $BoxPointB);

// BoxspaceLocatorMiddle CHANGES need here in the future

float $translationzMiddle[];
$translationzMiddle = $CrossMPointAB;



float $CurveCVzero[] = GetCurveCVposENDS($ObjectCurveduplicate, 0);
float $CurveCVLast[] = GetCurveCVposENDS($ObjectCurveduplicate, 1);

int $pA1 = PointsEquivalentTol($CurveCVzero,$BoxPointA); 
int $pA2 = PointsEquivalentTol($CurveCVLast,$BoxPointA);
int $pC1 = PointsEquivalentTol($CurveCVzero,$BoxPointC); 
int $pC2 = PointsEquivalentTol($CurveCVLast,$BoxPointC); 

int $AorC = 0;
if (($pA1 == 3) || ($pA2 == 3)){
$AorC = 1;
}
if (($pC1 == 3) || ($pC2 == 3)){
$AorC = 2;
}  
float $distanceA = PointsGetDistanceFLOAT($BoxPointA, $BoxPointC);
float $distanceB = PointsGetDistanceFLOAT($BoxPointB, $BoxPointC);

float $distanceAverage =  (($distanceA + $distanceB) * (0.5)) ;
float $radiusX = ( $distanceAverage / 2.0);

float $squarePercentA;
float $squarePercentB;
if ( $distanceA > $distanceAverage) {
$squarePercentA = (( $distanceAverage / $distanceA ) * (100));
}
if ( $distanceA < $distanceAverage) {
$squarePercentA = (( $distanceA / $distanceAverage ) * (100));
}
if ( $distanceB > $distanceAverage) {
$squarePercentB = (( $distanceAverage / $distanceB ) * (100));
}
if ( $distanceB < $distanceAverage) {
$squarePercentB = (( $distanceB / $distanceAverage ) * (100));
}
/////////////////////

print $squarePercentA ;
print $squarePercentB ;

int $squareA = 0;
int $squareB = 0;
if ( $squarePercentA > 55){
$squareA = 1; 
}
if ( $squarePercentB > 55){
$squareB =  1; 
}

string $StraitCurve[];

$addSquareResults = ($squareA + $squareB);
if ( $addSquareResults == 2 ){

//Eval Diaginal curve

// USE $radiusX for curve points


if ( $AorC == 1){
$StraitCurve[0] = `curve -d 1 -p $BoxPointA[0] $BoxPointA[1] $BoxPointA[2] -p $BoxPointB[0] $BoxPointB[1] $BoxPointB[2]`;
}
if ( $AorC == 2){
$StraitCurve[0] = `curve -d 1 -p $BoxPointC[0] $BoxPointC[1] $BoxPointC[2] -p $BoxPointD[0] $BoxPointD[1] $BoxPointD[2]`;
}

} else { 


// Not Diagonal curves


int $XZ = 0;
if ( $distanceA > $distanceB) {
$XZ = 1;
}
if ( $distanceA < $distanceB) {
$XZ = 2;
}

if ($XZ == 1){
//$BoxMPointAD  $BoxMPointBC
$StraitCurve[0] = `curve -d 1 -p $BoxMPointAD[0] $BoxMPointAD[1] $BoxMPointAD[2] -p $BoxMPointBC[0] $BoxMPointBC[1] $BoxMPointBC[2]`;
}
if ($XZ == 2){
//$BoxMPointAC $BoxMPointBD
$StraitCurve[0] = `curve -d 1 -p $BoxMPointAC[0] $BoxMPointAC[1] $BoxMPointAC[2] -p $BoxMPointBD[0] $BoxMPointBD[1] $BoxMPointBD[2]`;
}
}

setAttr ($StraitCurve[0] + ".rotateX") $rotationz[0];
setAttr ($StraitCurve[0] + ".rotateY") $rotationz[1];
setAttr ($StraitCurve[0] + ".rotateZ") $rotationz[2];
setAttr ($StraitCurve[0] + ".translateX") $translationz[0];
setAttr ($StraitCurve[0] + ".translateY") $translationz[1];
setAttr ($StraitCurve[0] + ".translateZ") $translationz[2];


select -r $ObjectCurve $ObjectCurveduplicate BoxspaceLocatorA BoxspaceLocatorB BoxspaceLocatorC BoxspaceLocatorD BoxspaceLocatorMiddle;
delete;
select -r $StraitCurve;

return $StraitCurve;

}
