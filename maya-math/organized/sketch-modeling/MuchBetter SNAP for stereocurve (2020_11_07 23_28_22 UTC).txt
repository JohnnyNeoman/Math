////////////////////////////////////////////////////////////////////////

//		START of Matrix Axis Translation 		//

////////////////////////////////////////////////////////////////////////




//STart up the engine
/*

EvalAllCurvesToolZ;
int $scriptt_jobNumConnectionChanged = `scriptJob -conditionChange delete evalVectorIndexAdditionSubtract`;
eval(" $jobNumtranslateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.translate  RUNMoveZCURVEM`;");
eval(" $jobNumrotateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.rotate  RUNMoveZCURVEM`;");

select -r LiveSurfaceB ;
MakeLive;
PencilCurveTool;


//int $scriptt_jobNumConnectionChanged = `scriptJob -conditionChange delete evalUndoIfStereoScriptActive`;

*/

//  print $gLastAction;    $ForceOrthoOFFON = 0;

/*
  $scriptt_jobAllCurvesToolsNumAZ =  `scriptJob -event DagObjectCreated  AutoCurveScriptsTwoCurve -compressUndo true -protected  `;
scriptJob -kill  $scriptt_jobAllCurvesToolsNumAZ -force;


	clear $StereoCurveZ;
  	clear $VanishingPointsLinesTempGuides;
		 $addNumbersA =0;
	quickFix;


string $CurveItems[] =`ls -sl`;

	ResetTranslation($CurveItems);
	CurveIndexVecTracking($CurveItems);  
	editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveItems;

	evalVectorIndexAdditionSubtract;
	EVALCamScripts;

*/

////////////////////////////////////
global string $VanishingPointsLinesTempGuides[];
////////////////////////////////////

////////////////////////////////////
global int $scriptt_jobAllCurvesToolsNumAZ;
////////////////////////////////////

////////////////////////////////////
global int $StereoCurveNumber;
global string $StereoCurveZ[];
global float $VanishingPointGlobal[];
global int $ifSingleCurve;
global vector $TempVectorsCrv[];
/////////////////////////////////////
$ifSingleCurve=0;

proc RUNMoveZCURVEM(){
int $script_jobNumIdle_MoveZCURVEM = `scriptJob   -runOnce 1 -event idle EVALCamScripts`;
}


proc EvalAllCurvesToolZ(){
eval("int $scriptt_jobAllCurvesToolsNumAZ =  `scriptJob -event DagObjectCreated  AutoCurveScriptsTwoCurve -compressUndo true -protected  `;");
}




proc AutoCurveScriptsTwoCurve(){
global string $StereoCurveZ[];
string $itemAll[] = `ls -sl`;
int $ifCond_is_True =  `ISSelectedTypeCurve`;
if ($ifCond_is_True == 1){
//   This is just the curve script you need this  to be where the switch is
string $item[] = `ls -sl`;
$StereoCurveZ[`size($StereoCurveZ)`]= $item[0];
EvalAddingCurves;
creatStereoCurve;
}
}



	//clear $StereoCurveZ


proc  creatStereoCurve(){

	global string $VanishingPointsLinesTempGuides[];
	global int $addNumbersA;
	global string $StereoCurveZ[];
global int $ifSingleCurve;
global int $ForceOrthoOFFON;

if(size($StereoCurveZ)>0){
	RemoveNoLongerExistingFromArray($StereoCurveZ);
}

if( $ForceOrthoOFFON == 1){
	$addNumbersA=-3;
 ForceOrtho($StereoCurveZ);

}
if( $ForceOrthoOFFON == 0){

	int $x = $addNumbersA;
	print ($addNumbersA + "\n");
	if ($x == 1){
undoInfo -openChunk;

		//LockModelingCAM;
		//print "One CURVE";
		$VanishingPointsLinesTempGuides = VanishingCurves($StereoCurveZ);

if( $ifSingleCurve==1){

delete $VanishingPointsLinesTempGuides;	
clear $VanishingPointsLinesTempGuides;	
	clear $StereoCurveZ;
undoInfo -closeChunk;	
	$addNumbersA =0;
	evalVectorIndexAdditionSubtract;
	EVALCamScripts;
$ifSingleCurve=0;
}

	}

	if ($x == 2){
	
		//print "TWO CURVES";		
		StereoCurveZ($StereoCurveZ[0], $StereoCurveZ[1]);
undoInfo -closeChunk;	
		 $addNumbersA =0;
	}

}


}

////////////////////////////////////////////////////




global vector $EmptyVectorArrayA[];
global vector $EmptyVectorArrayB[];

$TFCircleORnotCircle=0;
print $TFCircleORnotCircle;
/*
proc  creatStereoCurve(){

	global string $VanishingPointsLinesTempGuides[];
	global int $addNumbersA;
	global string $StereoCurveZ[];
global vector $EmptyVectorArrayA[];
global vector $EmptyVectorArrayB[];
global int $ifSingleCurve;
global int $TFCircleORnotCircle;
global int $MostRL_Int;
	RemoveNoLongerExistingFromArray($StereoCurveZ);
	int $x = $addNumbersA;
	print ("addNumbersA "+$addNumbersA + "\n");
 print ("TFCircleORnotCircle "+$TFCircleORnotCircle+"\n");


	if ($x == 1){
		//LockModelingCAM;
		print "One CURVE";


int $TFNS = 0;
string $CurveNS;
$CurveNS = IScircleTF($StereoCurveZ[0],$TFNS);
select -r $StereoCurveZ[0];



if( $TFCircleORnotCircle!=1){

		$VanishingPointsLinesTempGuides = VanishingCurves($StereoCurveZ);
if( $ifSingleCurve==1){
delete $VanishingPointsLinesTempGuides;	
clear $VanishingPointsLinesTempGuides;	
	clear $StereoCurveZ;
	$addNumbersA =0;
	evalVectorIndexAdditionSubtract;
	EVALCamScripts;
$ifSingleCurve=0;
	}

}


if($TFCircleORnotCircle==1){
delete $StereoCurveZ[0];
$StereoCurveZ[0]= $CurveNS;
$StereoCurveZ[0] = EllipesSketchFitting($StereoCurveZ[0], $EmptyVectorArrayA);

}

}


	if ($x == 2){


		//LockModelingCAM;
		// RUN Script

		print "TWO CURVES";
		if (!(`size($EmptyVectorArrayA)` >0)){
		StereoCurveZ($StereoCurveZ[0], $StereoCurveZ[1]); }

		if (`size($EmptyVectorArrayA)` >0){

	float $CamPos_A[];
	$CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
	float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;	
	float $MidEpipolZx[] = MidPoint($CamPos_M, $CamPos_A);	
	float $MidEpipolPosFCam[]= FloatPointsToCamPlane($MidEpipolZx);
Loc $MidEpipolPosFCam;


	int $NewArrayAEllipZ[] = NewVecOrderEllipZ($StereoCurveZ[0], $EmptyVectorArrayA, $MidEpipolPosFCam);
int $LR_A = $MostRL_Int;
	vector $EmptyVectorArrayB[];
	string $NewOneCurveSB;
	 $NewOneCurveSB = EllipesSketchFitting($StereoCurveZ[1], $EmptyVectorArrayB);
	int $NewArrayBEllipZ[] = NewVecOrderEllipZ($NewOneCurveSB, $EmptyVectorArrayB, $MidEpipolPosFCam);
int $LR_B = $MostRL_Int;
if($LR_B!=$LR_A){
$EmptyVectorArrayB = ReverseVectorArray($EmptyVectorArrayB);
}

////////////////////////////////////////////
	vector $A_CrvCentroid =  FloatToVec(AverageVectorPoint($EmptyVectorArrayA));
	vector $DirLineE = DirectionFN($A_CrvCentroid, $MidEpipolPosFCam);
	vector $B_CrvCentroid =  FloatToVec(AverageVectorPoint($EmptyVectorArrayB));
vector $PointN_Line = ClosestPoint2LineVec($DirLineE, $MidEpipolPosFCam, $B_CrvCentroid);
	vector $DirLine = DirectionFN($PointN_Line, $B_CrvCentroid);
	float $DistToPoint = distance2Pts($PointN_Line, $B_CrvCentroid);

// DISTANCE TIMES DIRECTION VEC PLUS POINT VECTOR To translate

vector $TranstatedVecs[];
clear $TranstatedVecs;
for($eachVector in $EmptyVectorArrayB){
$TranstatedVecs[`size($TranstatedVecs)`] = ($eachVector+($DistToPoint*$DirLine));
}
$EmptyVectorArrayB = $TranstatedVecs;
////////////////////////////////////////////

	string $StereoCircle[]= Eval3DCircleStereo( $NewArrayBEllipZ  , $EmptyVectorArrayB ,  $NewArrayAEllipZ , $EmptyVectorArrayA );
	clear $EmptyVectorArrayA;
	clear $EmptyVectorArrayB;
	 delete $StereoCurveZ[0];
	 delete $NewOneCurveSB;
	ResetTranslation($StereoCircle);
	CurveIndexVecTracking($StereoCircle);  
	editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $StereoCircle;
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $StereoCircle;
	$TFCircleORnotCircle =0;	
	evalVectorIndexAdditionSubtract;
	EVALCamScripts;

					}



 $addNumbersA =0;
}
		


		//eval("print $gLastAction");
		// delete $StereoCurveZ;		
		//////////////////////////////
		// delete $VanishingPointsLinesTempGuides;
		// clear $VanishingPointsLinesTempGuides;


		
	
}



*/
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	proc string [] Eval3DCircleStereo(int $NewArrayBEllipZ[] ,vector $EmptyVectorArrayB[], int $NewArrayIntX[],vector $EmptyVectorArrayA[]){
vector $PositionsZ_B[] = $EmptyVectorArrayB;
vector $VecPtsMirrorA[];
	$VecPtsMirrorA = VecPtsToZMirrorPts( $EmptyVectorArrayA);
	float $CamPos_A[];
	$CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;
vector $Intersect_A[];
	int $iiz = 0;
	for ($eachVecx in  $VecPtsMirrorA)	{
		$Intersect_A[`size($Intersect_A)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_B[$NewArrayBEllipZ[$iiz]], $CamPos_M, $VecPtsMirrorA[$NewArrayIntX[$iiz]]));
		$iiz++;
	}
	string $ThefirstCurve = VecArrayToCurveB($Intersect_A);
 	vector $Intersect_B[];	 
	$Intersect_B= VecPtsToZMirrorPts($Intersect_A);
	string $ThefirstCurvei = VecArrayToCurveB($Intersect_B);
string $BothCurves[];
$BothCurves[0] = $ThefirstCurve;
$BothCurves[1] = $ThefirstCurvei;
return  $BothCurves;

}
global  int $MostRL_Int;
$MostRL_Int =0;
proc int [] NewVecOrderEllipZ(string $NewOneCurveS, vector $EmptyVectorArrayA[], float $MidEpipolPosFCam[]){ 
	float $EllipesPos_A[];
	$EllipesPos_A = `xform -q -ws -t $NewOneCurveS`;
	vector $Dir_VecMAIN;
		$Dir_VecMAIN =  DirectionFN($MidEpipolPosFCam, $EllipesPos_A);	
int $IndexTrackE[];
$IndexTrackE = CreateIntIndex(`size($EmptyVectorArrayA)`);

float $allAngiX[];
float $DIff;
vector $threeVecs[];
vector $threeVecsG[];
int $TwoZeroOne[] = {0,1};
int $TwoZeroOneG[] = {0,1};
int $TFmostRArray[];
clear $allAngiX; clear $TFmostRArray;
$threeVecs[0] = FloatToVec($MidEpipolPosFCam); 
$threeVecs[1] = FloatToVec($EllipesPos_A); 

for($EachVector in $EmptyVectorArrayA){

$DIff = FindDirectionDiff($Dir_VecMAIN, $MidEpipolPosFCam, $EachVector);
if($DIff!= 0){
 $allAngiX[`size($allAngiX)`]=  VAnglesofThreeVec($MidEpipolPosFCam, $EllipesPos_A, $EachVector);
$threeVecs[2] = $EachVector;
 $TFmostRArray[`size($TFmostRArray)`] = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);

}else{ $allAngiX[`size($allAngiX)`]= 0;  $TFmostRArray[`size($TFmostRArray)`] =0;}

}

//print  $allAngiX;
//print  $TFmostRArray;

float $AllAngiX_RIGHT[];
float $AllAngiX_LEFT[];
int $LargestIntR_KEY[];
int $LargestIntL_KEY[];
clear $LargestIntR_KEY;
clear $LargestIntL_KEY;
clear $AllAngiX_LEFT;
clear $AllAngiX_RIGHT;
int $COUNT_Nlr=0;
for($EachIntarray in $TFmostRArray){
if($EachIntarray==1){
$AllAngiX_RIGHT[`size($AllAngiX_RIGHT)`]= $allAngiX[$COUNT_Nlr];
$LargestIntR_KEY[`size($LargestIntR_KEY)`]=$COUNT_Nlr;
}
if($EachIntarray==0){
$AllAngiX_LEFT[`size($AllAngiX_LEFT)`]= $allAngiX[$COUNT_Nlr];
$LargestIntL_KEY[`size($LargestIntL_KEY)`]=$COUNT_Nlr;
}
$COUNT_Nlr++;
}

int $LargestIntR[] = SortNumbersIntIndex($AllAngiX_RIGHT);
$LargestIntR = ReverseIntArray($LargestIntR);
// Loc $EmptyVectorArrayA[$LargestIntR_KEY[$LargestIntR[0]]];
int $LargestIntL[] = SortNumbersIntIndex($AllAngiX_LEFT);
$LargestIntL = ReverseIntArray($LargestIntL);
// Loc $EmptyVectorArrayA[$LargestIntL_KEY[$LargestIntL[0]]];

print $LargestIntR_KEY[$LargestIntR[0]];
print $LargestIntL_KEY[$LargestIntL[0]];
// Loc $EmptyVectorArrayA[$LargestIntL_KEY[$LargestIntL[0]]];
// test 
int $NewStartInt = $LargestIntL_KEY[$LargestIntL[0]];
//  $IndexTrackE
int $SizeE = `size($EmptyVectorArrayA)`;
int $NewArrayInt;
int $NewArrayIntX[];
int $Add=0;
for($EachIntX in $IndexTrackE){
$NewArrayIntX[`size($NewArrayIntX)`] = fmod(($NewStartInt+$Add),$SizeE);
$Add++;
}
 Loc $EmptyVectorArrayA[$NewArrayIntX[0]];
 Loc $EmptyVectorArrayA[$NewArrayIntX[12]];
 curve2points($EmptyVectorArrayA[$NewArrayIntX[0]],$EllipesPos_A);
 curve2points($EmptyVectorArrayA[$NewArrayIntX[0]],$EmptyVectorArrayA[$NewArrayIntX[12]]);
$threeVecsG[0] = $EmptyVectorArrayA[$NewArrayIntX[0]];
$threeVecsG[1] = FloatToVec($EllipesPos_A);
$threeVecsG[2] = $EmptyVectorArrayA[$NewArrayIntX[12]];
$MostRL_Int = MostRightClockWiseInt ($threeVecsG, $TwoZeroOneG);
return $NewArrayIntX;

}



////////////////////////

proc float [] CurvatureIsCircle(string $curvesZ, int $NumberofSteps, float $angleZ[], float $TotalDeg, int $low, float $C[]){

	string $myCurve = $curvesZ;
	//smoothCurve -ch 0 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
		vector $PositionsZ_A[];
		clear $PositionsZ_A;
		$PositionsZ_A = VecCurveEps($curvesZ);
float $AverageVecCurve[] =  AverageVectorPoint($PositionsZ_A);
	float $CIrceP[];
	$CIrceP = `xform -q -ws -t $myCurve`;
$AverageVecCurve =$CIrceP;
Loc $AverageVecCurve;
vector $VecAverage = FloatToVec($AverageVecCurve);

	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 4 ); 

	$numEPrealNum2 = $NumberofSteps;
string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
float $CN[];
float $step = $NumberofSteps;  
int $Par = 0;
int $a;
float $StepCycle =0;
int $ii = 0;
int $iX = 0;
int $Trigger= 0;
int $Lowest = 11110;
int $Past = 0;
float $pastA =0.0;
float $t, $EachAngle, $angleTii, $allAngi[], $NumbersA[], $values[], $valuesXYZ[];		
vector $CurveVectors[];
vector $FlushVectors[];
float $AddAngles=0.0;
 $allAngi[`size($allAngi)`] = 0;
float  $allAngiX[];
 $allAngiX[`size($allAngiX)`] = 0;	
int $TFmostR, $TwoZeroOne[];
$TwoZeroOne = {0,1};	
$C[0] = 0;
$CN[0] = 0;
int $TF = 0;
int $CountEVEN = 0;
int $Even_Odd;
float $DistancesCycle[];

vector $PresentV, $PastV, $threeVecs[];
  for($a = 0; $a <= $step;$a++){

  	$t =  $a/$step;
 	$Par = ($a/$step);
	setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
  	  $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
 	 $valuesXYZ  = {$values[0], $values[1], $values[2]};
$CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
$FlushVectors[`size($FlushVectors)`] = <<$values[0], $values[1], $values[2]>>;
$PresentV = FloatToVec($values);
// creat a vator array thatclears every time it passes 360 deg.. so the last few steps are recored..
// then take the last angle find the persect it is of 360  divide that by the number of septs then use that as a float step

 if($ii>0){$Past=$ii-1;
 $EachAngle = VAnglesofThreeVec($VecAverage, $PositionsZ_A[0], $CurveVectors[$ii]);
$threeVecs[0] = $PositionsZ_A[0]; $threeVecs[1] = $VecAverage; $threeVecs[2] = $PresentV;
$TFmostR = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);
$C[$iX] = $TFmostR;
if($ii==1){ $C[$iX-1]= $C[$iX]; 
$CN[`size($CN)`-1]=$C[$iX];
}
 $allAngi[$iX] =$EachAngle;
if($Trigger== 1){
$allAngi[$iX] = (abs($pastA - $EachAngle))+$allAngi[$iX-1];
if($allAngi[$iX]> 360){ $allAngi[$iX]=$EachAngle; $allAngi[$iX-1]=0;  $Trigger= 0; $TF++; }
}

if($C[$iX]!=$C[$iX-1]){
//Loc $valuesXYZ;
$CN[`size($CN)`]= $iX;
$CN[`size($CN)`]=$C[$iX];
$Even_Odd = fmod($CountEVEN,2);
if($Even_Odd ==1){
$DistancesCycle[`size($DistancesCycle)`]= distance2Pts ($PositionsZ_A[0], $PresentV);
}
$CountEVEN++;
 $angleTii = (180.00- $allAngi[$iX]) +(180.00- $allAngi[$iX-1]);
$allAngi[$iX] =  $angleTii +$allAngi[$iX-1];
$Trigger= 1;
}
$pastA = $EachAngle;
$AddAngles+= abs($EachAngle - $allAngiX[`size($allAngiX)`-1]);
if($allAngi[`size($allAngi)`-1]>=360){
clear $FlushVectors;
$StepCycle =  abs ($StepCycle -$a);
float $FXiI =$StepCycle;
float $Fnumbers = 100.0/$FXiI;
float $floatZ[];
$floatZ = CreateIntIndexF($FXiI, $Fnumbers);
$StepCycle = $a;
//Loc $CurveVectors[$ii];
$AddAngles=0;
}
}
if($StepCycle < $Lowest){
if($StepCycle!=0){
$Lowest = $StepCycle;
}
}
$PastV = FloatToVec($values);
$iX++;
$ii++;	
if( $ii == 990){
break;
}
}
$CN[`size($CN)`]= $iX;
//$low = $StepCycle;
$low = $TF;
//print $TF;
$angleZ = $DistancesCycle;
$low = $TF;
delete $paramlocatorpointOnCurvex;
$TotalDeg = $AddAngles;
//$angleZ = $allAngi;
//print $CN;
return $CN; 
}


// 
//
/*
int $TFCXX =0;
 string $EachCrvXi[] =`ls -sl`;  
string $EachCrvX = $EachCrvXi[0]; 
IScircleTF($EachCrvX, $TFCXX);
print $TFCXX;
*/
////////////////////////////////////

global int $TFCircleORnotCircle;

proc string IScircleTF(string $EachCrvX, int $TFCc){

global int $TFCircleORnotCircle;
string $EachCrv;
  $TFCircleORnotCircle =0;
 vector $PositionsZ_Aii[]; 
 $PositionsZ_Aii = VecCurveEps($EachCrvX );

string $firstCurveii;
	$EachCrv = VecArrayToCurveB($PositionsZ_Aii);
$firstCurveii = $EachCrv;
ResetTransEachSL;
int $sizeZ =`size($PositionsZ_Aii)`;

float $Arc = `arclen $EachCrv`;
float $Arc = ($Arc /3.5);
 float $ArcX = ($Arc /3.5) + 5.0;
 rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s $sizeZ -d 3 -tol 0.05 $EachCrv;
string $curvesZi = $EachCrv;

float $angleZi[];
vector $CurveCollectVec[];
float $CollectCii[];
float $TotalDegi;
int $LowX;
float $TrackCi[];
$CollectCii = CurvatureIsCircle($curvesZi, 130, $angleZi, $TotalDegi, $LowX, $TrackCi);
float $CycleDIstAv = $angleZi[0];
if(`size($angleZi)`>1){ $CycleDIstAv = AverageFloats($angleZi);}

float $AverNumber[] = GatherDataC($TrackCi);
float $Even_Odd = fmod((`size($AverNumber)` ),2);	
float $AverageUnits=AverageFloats($AverNumber);
int $CirTrigger =0;
float $NewFarray[];
if($TrackCi[`size($TrackCi)`-1]<$AverageUnits){
int $Count =0;
int $XnN = `size($AverNumber)`-1;

	if($XnN>1){
	for($eachFl in $AverNumber){
if($Count!= $XnN){
$NewFarray[`size($NewFarray)`] = $eachFl;
}
$Count++;
}
$CirTrigger =1;
}else{$CirTrigger =0;}
}

//print ($CirTrigger+"\n");

float $MathA;
float $DivideArc;
float $SegArc;
float $MathADX;
float $DiffFromAv[];
clear $DiffFromAv;
float $AverageDiffA;
float $MathAD;
float $DiffMathA;

if($CirTrigger==1){
$Even_Odd = fmod((`size($NewFarray)` ),2);
	$SegArc = `size($NewFarray)`;
	$DivideArc = $Arc/$SegArc;
 $AverageUnits=AverageFloats($NewFarray);
$MathA= $Arc/$AverageUnits;
$DiffFromAv=GatherDataDiff($NewFarray,$AverageUnits);
	$AverageDiffA=AverageFloats($DiffFromAv);
	$DiffMathA =  $AverageDiffA / ($AverageUnits/100.0);
	$MathAD= `abs ($AverageDiffA-$AverageUnits)`;
	$MathADX = $DivideArc/$MathAD;
//print ( "DiffMathA "+$DiffMathA+"\n");
//print ("CycleDIstAv "+$CycleDIstAv+"\n");

if(($DiffMathA<14.5)&&($CycleDIstAv<$Arc)){
$TFCircleORnotCircle=1;
$TFCc++;
}else{ $TFCircleORnotCircle=0;}

}else{ $TFCircleORnotCircle=0;}

// print ("TFCircleORnotCircle "+$TFCircleORnotCircle+"\n");
if($TFCircleORnotCircle==1){
$TFCc += 1;
}
if($TFCircleORnotCircle==1){
// delete $EachCrvX ;
}
if($TFCircleORnotCircle==0){
 delete $EachCrv ;
}

return $firstCurveii;
}



              proc vector[] NewVecOrderWithINTKey(int $IntIndexTrack[], vector $ObjsCurve[]){
vector $newOrderVec[];
for($eachVi in $IntIndexTrack){
$newOrderVec[`size($newOrderVec)`] = $ObjsCurve[$eachVi];
}
return $newOrderVec;
}


proc vector [] CurvatureUtilityAngles(string $curvesZ, int $NumberofSteps, float $angleZ[], float $TotalDeg, int $low, int $C[]){

	string $myCurve = $curvesZ;
	//smoothCurve -ch 0 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
		vector $PositionsZ_A[];
		clear $PositionsZ_A;
		$PositionsZ_A = VecCurveEps($curvesZ);

float $AverageVecCurve[] =  AverageVectorPoint($PositionsZ_A);
//Loc $AverageVecCurve;
vector $VecAverage = FloatToVec($AverageVecCurve);


	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 4 ); 

	$numEPrealNum2 = $NumberofSteps;
string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;

float $step = $NumberofSteps;  
int $Par = 0;
int $a;
float $StepCycle =0;
int $ii = 0;
int $iX = 0;
int $Trigger= 0;
int $Lowest = 11110;
int $Past = 0;
float $pastA =0.0;
float $t, $EachAngle, $angleTii, $allAngi[], $NumbersA[], $values[], $valuesXYZ[];		
vector $CurveVectors[];
vector $FlushVectors[];
float $AddAngles=0.0;
 $allAngi[`size($allAngi)`] = 0;
float  $allAngiX[];
 $allAngiX[`size($allAngiX)`] = 0;	
int $TFmostR, $TwoZeroOne[];
$TwoZeroOne = {0,1};	
$C[0] = 0;

vector $PresentV, $PastV, $threeVecs[];
  for($a = 0; $a <= $step;$a++){

  	$t =  $a/$step;
 	$Par = ($a/$step);

	setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
  	  $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
 	 $valuesXYZ  = {$values[0], $values[1], $values[2]};
$CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
$FlushVectors[`size($FlushVectors)`] = <<$values[0], $values[1], $values[2]>>;
$PresentV = FloatToVec($values);


float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
// creat a vator array thatclears every time it passes 360 deg.. so the last few steps are recored..
// then take the last angle find the persect it is of 360  divide that by the number of septs then use that as a float step

 if($ii>0){$Past=$ii-1;

 $EachAngle = VAnglesofThreeVec($VecAverage, $PositionsZ_A[0], $CurveVectors[$ii]);
$threeVecs[0] = $PositionsZ_A[0]; $threeVecs[1] = $VecAverage; $threeVecs[2] = $PresentV;

$TFmostR = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);

$C[$iX] = $TFmostR;
if($ii==1){ $C[$iX-1]= $C[$iX]; }


 $allAngi[$iX] =$EachAngle;

if($Trigger== 1){
$allAngi[$iX] = (abs($pastA - $EachAngle))+$allAngi[$iX-1];
if($allAngi[$iX]> 360){ $allAngi[$iX]=$EachAngle; $allAngi[$iX-1]=0;  $Trigger= 0;}
}


if($C[$iX]!=$C[$iX-1]){
 $angleTii = (180.00- $allAngi[$iX]) +(180.00- $allAngi[$iX-1]);
$allAngi[$iX] =  $angleTii +$allAngi[$iX-1];
$Trigger= 1;
}

$pastA = $EachAngle;
$AddAngles+= abs($EachAngle - $allAngiX[`size($allAngiX)`-1]);


if($allAngi[`size($allAngi)`-1]>=360){
clear $FlushVectors;
$StepCycle =  abs ($StepCycle -$a);
float $FXiI =$StepCycle;
float $Fnumbers = 100.0/$FXiI;
float $floatZ[];
$floatZ = CreateIntIndexF($FXiI, $Fnumbers);

$StepCycle = $a;
//Loc $CurveVectors[$ii];
$AddAngles=0;

}
}

if($StepCycle < $Lowest){
if($StepCycle!=0){
$Lowest = $StepCycle;
}
}

$PastV = FloatToVec($values);

$iX++;
$ii++;	

if( $ii == 990){
break;
}

}
$low = $StepCycle;


delete $paramlocatorpointOnCurvex;
$TotalDeg = $AddAngles;
$angleZ = $allAngi;
return $CurveVectors; 
}

///////////////


proc string EllipesSketchFitting(string $curveItemC, vector $EmptyVectorArray[]){

// string $CurveItemZai[]; $CurveItemZai[0] = $CurveNS;
string $CurveItemZai[];
$CurveItemZai[0] = $curveItemC;

float $Arc = `arclen $CurveItemZai[0]`;
$Arc = $Arc /3.5;

 rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 130 -d 3 -tol 0.05 $CurveItemZai[0];

string $curvesZi = $CurveItemZai[0];
float $angleZi[];
vector $CurveCollectVec[];
float $TotalDegi;
int $Low_X;
int $TrackC[];
$CurveCollectVec = CurvatureUtilityAngles($curvesZi, 130, $angleZi, $TotalDegi,$Low_X, $TrackC);


int $NewIndex[];
clear $NewIndex;
$NewIndex  = SortNumbersIntIndex($angleZi);
vector $nevVec[] = NewVecOrderWithINTKey($NewIndex,$CurveCollectVec);
vector $vectorZnewX[];
 $vectorZnewX =$nevVec;
string $TestCurveC;
int $Xv=0;
while($Xv < 22){
 $vectorZnewX = AverageCurveVec($vectorZnewX);
$Xv++; 
}
 $TestCurveC = VecArrayToCurveB($vectorZnewX);
ResetTransEachSL;

float $AverageVecCurve[] =  AverageVectorPoint($vectorZnewX);
//Loc $AverageVecCurve;

	float $CIrceP[];
	$CIrceP = `xform -q -ws -t $TestCurveC`;
//Loc $CIrceP;
$AverageVecCurve =$CIrceP;

float $AddedCurvA, $angleZii[];
vector $CurveCollectVec[];
clear $angleZii;  clear $CurveCollectVec;
int $TrackC[];
int $Mini[];
//select -r $TestCurveC;

$CurveCollectVec = CurvatureUtility($TestCurveC, 3, $angleZii, $TrackC, $AddedCurvA);


int $NewIndexAi[];
clear $NewIndexAi;
$NewIndexAi  = SortNumbersIntIndex($angleZii);


//curve2points($CurveCollectVec[$NewIndexAi[0]],$AverageVecCurve);

float $DPiMidi = distance2Pts($CurveCollectVec[$NewIndexAi[0]],$AverageVecCurve);
float $FloatDirMA[] = DirectionFN($AverageVecCurve,$CurveCollectVec[$NewIndexAi[0]]);

  vector $MidVecDir = FloatToVec($FloatDirMA);
  vector $AveVec = FloatToVec($AverageVecCurve);
vector $NewPvec;
 $NewPvec = ($MidVecDir * $DPiMidi)+ $AveVec;
//Loc $NewPvec;
// the three vectors needed to make the ellipse
//$CurveCollectVec[$NewIndexAi[0]] , $NewPvec and any point one curve (close to first vec)


int $MidAngle = (`size($NewIndexAi)`-1)/2;

float $LowestAngle = $angleZii[$NewIndexAi[0]];
float $MiddleAngle = $angleZii[$NewIndexAi[$MidAngle]];
float $HighestAngle = $angleZii[$NewIndexAi[`size($NewIndexAi)`-1]];
float $AvAllangles = ($LowestAngle+$MiddleAngle+$HighestAngle)/3.0;

int $xc =0;
float $eachAi;
int $findLowestGroup[];
clear $findLowestGroup;
for($eachAi in $angleZii){
if($eachAi< $AvAllangles){
$findLowestGroup[`size($findLowestGroup)`]=$xc;
//Loc  $CurveCollectVec[$xc];
}
$xc++;
}

$findLowestGroup = `sort $findLowestGroup`;

 $xc =0;
int $Pastint;
int $ChangeOver;
int $Sub;
for($eachInt in $findLowestGroup){
if($xc>0){
$Sub =$eachInt -$Pastint;
if(($eachInt -$Pastint)> 3){
$ChangeOver =  $Pastint;
//Loc  $CurveCollectVec[$ChangeOver];
}
}
$Pastint = $eachInt;
$xc++;
}


// the three vectors needed to make the ellipse
//$CurveCollectVec[$NewIndexAi[0]] , $NewPvec and any point one curve (close to first vec)
//$CurveCollectVec[$NewIndexAi[0]] , $NewPvec, $CurveCollectVec[$ChangeOver];

vector $ThreeEllipVecP[];
$ThreeEllipVecP[0] = $CurveCollectVec[$NewIndexAi[0]] ;
$ThreeEllipVecP[1] = $NewPvec;
$ThreeEllipVecP[2] = $CurveCollectVec[$ChangeOver];
vector $NewEllipesCurve[];

$NewEllipesCurve = calculateEllipseCurve($ThreeEllipVecP, 300);
string $NewCurveE[]= `ls -sl`;
$EmptyVectorArray = $NewEllipesCurve;

 delete $CurveItemZai[0];
 delete $TestCurveC;
return $NewCurveE[0];

}

// END of Ellipse
/////////////////
proc float [] MultLenToDirAddToPoint(float $Length, float $Dir[], float $Pos[]){
	float $MultLengthDir[] = multiplyFloat($Length, $Dir);
	float $AddMultDirPos[] = AddFloats($Pos, $MultLengthDir);
	return $AddMultDirPos;
}

////////////////


proc string SimpleEllipse3Pts(string $TestCurveC, vector $EmptyVectorArray[]){
	float $CIrceP[];
	$CIrceP = `xform -q -ws -t $TestCurveC`;
$AverageVecCurve =$CIrceP;

float $AddedCurvA, $angleZii[];
vector $CurveCollectVec[];
clear $angleZii;  clear $CurveCollectVec;
int $TrackC[];
int $Mini[];
$CurveCollectVec = CurvatureUtility($TestCurveC, 3, $angleZii, $TrackC, $AddedCurvA);

int $NewIndexAi[];
clear $NewIndexAi;
$NewIndexAi  = SortNumbersIntIndex($angleZii);
//##
curve2points($CurveCollectVec[$NewIndexAi[0]],$AverageVecCurve);

float $DPiMidi = distance2Pts($CurveCollectVec[$NewIndexAi[0]],$AverageVecCurve);
float $FloatDirMA[] = DirectionFN($AverageVecCurve,$CurveCollectVec[$NewIndexAi[0]]);
  vector $MidVecDir = FloatToVec($FloatDirMA);
  vector $AveVec = FloatToVec($AverageVecCurve);
vector $NewPvec;
 $NewPvec = ($MidVecDir * $DPiMidi)+ $AveVec;
// the three vectors needed to make the ellipse
//$CurveCollectVec[$NewIndexAi[0]] , $NewPvec and any point one curve (close to first vec)
int $MidAngle = (`size($NewIndexAi)`-1)/2;
float $LowestAngle = $angleZii[$NewIndexAi[0]];
float $MiddleAngle = $angleZii[$NewIndexAi[$MidAngle]];
float $HighestAngle = $angleZii[$NewIndexAi[`size($NewIndexAi)`-1]];
float $AvAllangles = ($LowestAngle+$MiddleAngle+$HighestAngle)/3.0;
int $xc =0;
float $eachAi;
int $findLowestGroup[];
clear $findLowestGroup;
for($eachAi in $angleZii){
if($eachAi< $AvAllangles){
$findLowestGroup[`size($findLowestGroup)`]=$xc;
 Loc  $CurveCollectVec[$xc];
}
$xc++;
}

$findLowestGroup = `sort $findLowestGroup`;
 $xc =0;
int $Pastint;
int $ChangeOver;
int $Sub;
for($eachInt in $findLowestGroup){
if($xc>0){
$Sub =$eachInt -$Pastint;
if(($eachInt -$Pastint)> 3){
$ChangeOver =  $Pastint;
 Loc  $CurveCollectVec[$ChangeOver];
}
}
$Pastint = $eachInt;
$xc++;
}


// the three vectors needed to make the ellipse
//$CurveCollectVec[$NewIndexAi[0]] , $NewPvec and any point one curve (close to first vec)
//$CurveCollectVec[$NewIndexAi[0]] , $NewPvec, $CurveCollectVec[$ChangeOver];

vector $ThreeEllipVecP[];
$ThreeEllipVecP[0] = $CurveCollectVec[$NewIndexAi[0]] ;
$ThreeEllipVecP[1] = $NewPvec;
$ThreeEllipVecP[2] = $CurveCollectVec[$ChangeOver];
vector $NewEllipesCurve[];

$NewEllipesCurve = calculateEllipseCurve($ThreeEllipVecP, 300);
string $NewCurveE[]= `ls -sl`;
$EmptyVectorArray = $NewEllipesCurve;

return $NewCurveE[0];
}

createDisplayLayer -name "layer1" -number 1 -empty;
setAttr layer1.visibility 1; setAttr layer1.displayType 0; setAttr layer1.color 5; rename layer1 VecToCurve; 
createDisplayLayer -name "layer1" -number 1 -empty; 
setAttr layer1.visibility 1; setAttr layer1.displayType 0; setAttr layer1.color 28; rename layer1 VecToCurveB;



proc float[] Matrix4ToFloat(matrix $m[][]){
float $MatrixPoints[];
$MatrixPoints = {($m[0][0]), ($m[0][1]), ($m[0][2]), ($m[0][3]), 
                 ($m[1][0]), ($m[1][1]), ($m[1][2]), ($m[1][3]), 
                 ($m[2][0]), ($m[2][1]), ($m[2][2]), ($m[2][3]), 
                 ($m[3][0]), ($m[3][1]), ($m[3][2]), ($m[3][3])};
return $MatrixPoints;
}

proc int [] CreatePairIntIndexEven(int $ArraySize){
int $iNdexi = 0;
int $iNdex = 0;
int $store;
int $IntArrayInex[];
while($iNdex < $ArraySize){
if($iNdexi == 0){ 
$IntArrayInex[$iNdex] = $iNdex;
$store =$iNdex;
}
if($iNdexi == 1){ $iNdexi = -1;
$IntArrayInex[$iNdex] = $store;
}
$iNdexi++;
$iNdex++;
}
return $IntArrayInex;
}

//int $TrackAllExisting3DCrv[] = CreatePairIntIndex($SizeCrvi);

proc int [] CreatePairIntIndex(int $AS){
int $Ai = 0;
int $Bi = 0;
int $N = 0;
int $store;
int $IntA[];
int $Times = $AS*2;
while($Bi < $Times){
if($Ai == 0){$IntA[$Bi] = $N;}
if($Ai == 1){ $Ai = -1; $IntA[$Bi] = $N;
$N++; }
$Ai++;
$Bi++;
}
return $IntA;
}


proc int [] CreateIntIndexExpand(int $IndexArray[], int $ExpandSize){
int $IntArrayInex[];
for ($eachNumber in $IndexArray){
for ($i=0;$i<$ExpandSize; $i++){
$IntArrayInex[`size($IntArrayInex)`] = $eachNumber;
}
}
return $IntArrayInex;
}

proc vector VecMultMatrix(vector $PtsVec, matrix $Matrix_m0){
  matrix $Matrix_m1[1][4]= << $PtsVec.x, $PtsVec.y, $PtsVec.z, 1 >>;
  matrix $Matrix_m2[1][4]= $Matrix_m1 * $Matrix_m0;
vector $New_Three_Pt_Vec = << $Matrix_m2[0][0], $Matrix_m2[0][1], $Matrix_m2[0][2] >>;
  return $New_Three_Pt_Vec;
}
proc vector MatrixAddCol(matrix $mat[][]) {
float $uvwF[2];
 $uvwF[0] = $mat[0][0]+$mat[1][0]+$mat[2][0]+$mat[3][0];
 $uvwF[1] = $mat[0][1]+$mat[1][1]+$mat[2][1]+$mat[3][1];
 $uvwF[2] = $mat[0][2]+$mat[1][2]+$mat[2][2]+$mat[3][2];
vector $UVW = <<$uvwF[0],$uvwF[1],$uvwF[2] >>;
    return $UVW;
  }
proc vector [] GetRotationVectorsMatrix(matrix $mAtRiX[][]){
float $MatrizFloatiA[];
 $MatrizFloatiA = MatrixToFloat($mAtRiX);
  vector $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
 vector $VecR[];
 $VecR[0] = $VecAii;
 $VecAii = << $MatrizFloatiA[4], $MatrizFloatiA[5], $MatrizFloatiA[6]>>;
 $VecR[1] =$VecAii;
 $VecAii = << $MatrizFloatiA[8], $MatrizFloatiA[9], $MatrizFloatiA[10]>>;
 $VecR[2] = $VecAii;
return $VecR;
}
proc vector MultPointMatrix( vector $PtsVec, matrix $mIA[][]){
/*
Given an input vector (a, b, c) and an input matrix:
       A B C D
       E F G H
       I J K L
       M N O P       
Then Vector Matrix Product is defined as follows:
       x = (a*A) + (b*B) + (c*C)
       y = (a*E) + (b*F) + (c*G)
       z = (a*I) + (b*J) + (c*K)
And the Point Matrix Product is defined as follows:
       x = (a*A) + (b*B) + (c*C) + D
       y = (a*E) + (b*F) + (c*G) + H
       z = (a*I) + (b*J) + (c*K) + L
*/
float $MatrizFloatiA[] = MatrixToFloat($mIA);
 vector $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
 vector $VecR[];
 $VecR[0] = $VecAii;
 $VecAii = << $MatrizFloatiA[4], $MatrizFloatiA[5], $MatrizFloatiA[6]>>;
 $VecR[1] =$VecAii;
 $VecAii = << $MatrizFloatiA[8], $MatrizFloatiA[9], $MatrizFloatiA[10]>>;
 $VecR[2] = $VecAii;
float $RowA[] = $VecR[0];
float $RowB[] = $VecR[1];
float $RowC[] = $VecR[2];
float $GivenPoint[] = $PtsVec;
float $NewPoint[];
float $NewPointa[];
float $NewPointb[];
float $NewPtMatrixMult[];
$NewPoint = multiplyFloat($GivenPoint[0], $RowA);
$NewPointa = multiplyFloat($GivenPoint[1], $RowB);
$NewPointb = multiplyFloat($GivenPoint[2], $RowC);
$NewPtMatrixMult = AddFloats($NewPoint, $NewPointa);
$NewPtMatrixMult = AddFloats($NewPtMatrixMult, $NewPointb);
$NewPoint[0] = (($RowA[0])*($GivenPoint[0])) + (($RowB[0])*$GivenPoint[1]) + (($RowC[0])*$GivenPoint[2]);
$NewPoint[1] = (($RowA[1])*($GivenPoint[0])) + (($RowB[1])*$GivenPoint[1]) + (($RowC[1])*$GivenPoint[2]);
$NewPoint[2] = (($RowA[2])*($GivenPoint[0])) + (($RowB[2])*$GivenPoint[1]) + (($RowC[2])*$GivenPoint[2]);
vector $ReturnValVec = FloatToVec($NewPoint);
return $ReturnValVec;
}
proc vector MultPointMatrixProduct( vector $PtsVec, matrix $mIA[][]){
/*
Given an input vector (a, b, c) and an input matrix:
       A B C D
       E F G H
       I J K L
       M N O P       
Then Vector Matrix Product is defined as follows:
       x = (a*A) + (b*B) + (c*C)
       y = (a*E) + (b*F) + (c*G)
       z = (a*I) + (b*J) + (c*K)
And the Point Matrix Product is defined as follows:
       x = (a*A) + (b*B) + (c*C) + D
       y = (a*E) + (b*F) + (c*G) + H
       z = (a*I) + (b*J) + (c*K) + L
*/
float $MatrizFloatiA[] = MatrixToFloat($mIA);
 vector $VecAii = << $MatrizFloatiA[0], $MatrizFloatiA[1], $MatrizFloatiA[2]>>;
 vector $VecR[];
 $VecR[0] = $VecAii;
 $VecAii = << $MatrizFloatiA[4], $MatrizFloatiA[5], $MatrizFloatiA[6]>>;
 $VecR[1] =$VecAii;
 $VecAii = << $MatrizFloatiA[8], $MatrizFloatiA[9], $MatrizFloatiA[10]>>;
 $VecR[2] = $VecAii;
float $RowA[] = $VecR[0];
float $RowB[] = $VecR[1];
float $RowC[] = $VecR[2];
float $GivenPoint[] = $PtsVec;
float $NewPoint[];
float $NewPointa[];
float $NewPointb[];
float $NewPtMatrixMult[];
$NewPoint = multiplyFloat($GivenPoint[0], $RowA);
$NewPointa = multiplyFloat($GivenPoint[1], $RowB);
$NewPointb = multiplyFloat($GivenPoint[2], $RowC);
$NewPtMatrixMult = AddFloats($NewPoint, $NewPointa);
$NewPtMatrixMult = AddFloats($NewPtMatrixMult, $NewPointb);
$NewPoint[0] = (($RowA[0])*($GivenPoint[0])) + (($RowB[0])*$GivenPoint[1]) + (($RowC[0])*$GivenPoint[2])+$MatrizFloatiA[3];
$NewPoint[1] = (($RowA[1])*($GivenPoint[0])) + (($RowB[1])*$GivenPoint[1]) + (($RowC[1])*$GivenPoint[2])+$MatrizFloatiA[7];
$NewPoint[2] = (($RowA[2])*($GivenPoint[0])) + (($RowB[2])*$GivenPoint[1]) + (($RowC[2])*$GivenPoint[2])+$MatrizFloatiA[11];
vector $ReturnValVec = FloatToVec($NewPoint);
return $ReturnValVec;
}
proc matrix FloatToMatrix(float $v[]){
  matrix $mat[4][4]=<<$v[0], $v[1], $v[2], $v[3];
             $v[4], $v[5], $v[6], $v[7];
             $v[8], $v[9], $v[10], $v[11];
             $v[12], $v[13], $v[14], $v[15]>>;
return $mat;
}
proc float[] MatrixToFloat(matrix $FourByFour_matrix[][]){
float $matrixFloat[];
int $FLOATindex = 0;
int $Inx = 0;
int $Inxb = 0;
  for($Inx = 0; $Inx <= 3; $Inx++){
 for($Inxb = 0; $Inxb <= 3; $Inxb++){
$matrixFloat[$FLOATindex] = $FourByFour_matrix[$Inx][$Inxb];
$FLOATindex++;
}
}
return $matrixFloat;
}
////////////////////NEW 
proc matrix TwoPointMatrixPlusAxisWorld(vector $PtsVec[], vector $EmptyDirVector[], int $ZeroOne){
	vector $Line_Y_zeroMain;
	$Line_Y_zeroMain =FloatToVec (DirectionFN($PtsVec[0], $PtsVec[1]));
	float $MidPt[];
	$MidPt = MidPoint($PtsVec[0], $PtsVec[1]);
	$Line_Y_zeroMain = PositiveDirectionLine($PtsVec[0], $PtsVec[1]);
	vector $Dir_VecA;
	int $CombA =0;
	vector $eachPointVd;
	int $CountIndexV = 0;
	for ($eachPointVd in $PtsVec){
		$Dir_VecA = FloatToVec (DirectionFN($eachPointVd, $MidPt));
		$CombA = PointsEquivalentTol ($Dir_VecA, $Line_Y_zeroMain);
		if($CombA == 3){break;}else{
			$CountIndexV++;}
	}
	if($CountIndexV == 1){
		$PtsVec = ReverseVectorArray($PtsVec);
	}
	float $CamDirVecNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
	$CamDirVecNormal= multiplyFloat(-1.0, $CamDirVecNormal);
	vector $DirLine = PositiveDirectionLine($PtsVec[0], $PtsVec[1]);	
	vector $Vperp = crossProduct( $DirLine, $CamDirVecNormal, 0, 0 );
	vector $BInomalV = FloatToVec(MultLenToDirAddToPoint(2, $Vperp, $PtsVec[0]));
	vector $BInomalVDirLine = DirectionFN($PtsVec[0], $BInomalV);
	$BInomalV = FloatToVec(MultLenToDirAddToPoint(4, $BInomalVDirLine, $PtsVec[0]));
	vector $TangentV = FloatToVec(MultLenToDirAddToPoint(4,$CamDirVecNormal, $PtsVec[0]));
	// $BInomalVDirLine
	// $CamDirVecNormal
	// $DirLine
	vector $norm, $bi, $tan;
	vector $norm = FloatToVec($CamDirVecNormal);
	vector $bi = $BInomalVDirLine;
	vector $tan = $DirLine;
	matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
	0.0, 1.0, 0.0, 0.0;
	0.0, 0.0, 1.0, 0.0;
	0.0, 0.0, 0.0, 1.0 >>;
	///////////////////////////////////////###
	// I dont understand it //pretty weird
	vector $DirectionVector[2]; 
	$DirectionVector[0] =  $norm;
	$DirectionVector[1] =  $bi;
	$DirectionVector[2] =  $tan;
	$EmptyDirVector = $DirectionVector;
	/*
	string $curveAxis ="";
	$curveAxis += makeCurvePointDirectionLength((6), $norm, $MidPt); //
	$curveAxis += makeCurvePointDirectionLength((6), $bi, $MidPt); // 
	$curveAxis += makeCurvePointDirectionLength((6), $tan, $MidPt); //
*/
	vector $bi_two = `cross $tan $norm`;
	print (" bi_two : "+"\n");
	print $bi_two;
	print (" "+"\n");
	print (" bi : "+"\n");
	print $bi;
	print (" "+"\n");
	if($ZeroOne== 0){
		$mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
		($bi.x), ($bi.y), ($bi.z),  0.0;     // Y axis
		($tan.x), ($tan.y), ($tan.z), 0.0;     // Z axis
		0.0, 0.0, 0.0, 1.0  >>;  // Position
	}
	if($ZeroOne== 1){
		$mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
		($bi.x), ($bi.y), ($bi.z),  0.0;     // Y axis
		($tan.x), ($tan.y), ($tan.z), 0.0;     // Z axis
		$MidPt[0], $MidPt[1], $MidPt[2], 1.0  >>;  // Position
	}
	$mI = MatrixCleanNegZero($mI);
	float $MatrizFloati[] = MatrixToFloat($mI);
	return $mI;
}

proc matrix TwoPointMatrixPlusAxisWorld(vector $PtsVec[], vector $EmptyDirVector[], int $ZeroOne){
	vector $Line_Y_zeroMain;
	$Line_Y_zeroMain =FloatToVec (DirectionFN($PtsVec[0], $PtsVec[1]));
	float $MidPt[];
	$MidPt = MidPoint($PtsVec[0], $PtsVec[1]);
	$Line_Y_zeroMain = PositiveDirectionLine($PtsVec[0], $PtsVec[1]);
	vector $Dir_VecA;
	int $CombA =0;
	vector $eachPointVd;
	int $CountIndexV = 0;
	vector $VecLineDirM;
	for ($eachPointVd in $PtsVec){
		$Dir_VecA = FloatToVec (DirectionFN($eachPointVd, $MidPt));
		
		 $VecLineDirM = $Dir_VecA*$Line_Y_zeroMain;

if((($VecLineDirM.x) == ($VecLineDirM.y))&&(($VecLineDirM.x) == ($VecLineDirM.z))){
		
			//$CombA = PointsEquivalentTol ($Dir_VecA, $Line_Y_zeroMain);
		//if($CombA == 3){break;}
		
		break;}else{
			$CountIndexV++;}
	}
	if($CountIndexV == 1){
		$PtsVec = ReverseVectorArray($PtsVec);
	}
	float $CamDirVecNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
	$CamDirVecNormal= multiplyFloat(-1.0, $CamDirVecNormal);
	vector $DirLine = PositiveDirectionLine($PtsVec[0], $PtsVec[1]);	
	vector $Vperp = crossProduct( $DirLine, $CamDirVecNormal, 0, 0 );
	vector $BInomalV = FloatToVec(MultLenToDirAddToPoint(2, $Vperp, $PtsVec[0]));
	vector $BInomalVDirLine = DirectionFN($PtsVec[0], $BInomalV);
	$BInomalV = FloatToVec(MultLenToDirAddToPoint(4, $BInomalVDirLine, $PtsVec[0]));
	vector $TangentV = FloatToVec(MultLenToDirAddToPoint(4,$CamDirVecNormal, $PtsVec[0]));
	// $BInomalVDirLine
	// $CamDirVecNormal
	// $DirLine
	vector $norm, $bi, $tan;
	vector $norm = FloatToVec($CamDirVecNormal);
	vector $bi = $BInomalVDirLine;
	vector $tan = $DirLine;
	matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
	0.0, 1.0, 0.0, 0.0;
	0.0, 0.0, 1.0, 0.0;
	0.0, 0.0, 0.0, 1.0 >>;
	///////////////////////////////////////###
	// I dont understand it //pretty weird
	vector $DirectionVector[2]; 
	$DirectionVector[0] =  $norm;
	$DirectionVector[1] =  $bi;
	$DirectionVector[2] =  $tan;
	$EmptyDirVector = $DirectionVector;
	/*
	string $curveAxis ="";
	$curveAxis += makeCurvePointDirectionLength((6), $norm, $MidPt); //
	$curveAxis += makeCurvePointDirectionLength((6), $bi, $MidPt); // 
	$curveAxis += makeCurvePointDirectionLength((6), $tan, $MidPt); //
*/
	vector $bi_two = `cross $tan $norm`;
	print (" bi_two : "+"\n");
	print $bi_two;
	print (" "+"\n");
	print (" bi : "+"\n");
	print $bi;
	print (" "+"\n");
	if($ZeroOne== 0){
		$mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
		($bi.x), ($bi.y), ($bi.z),  0.0;     // Y axis
		($tan.x), ($tan.y), ($tan.z), 0.0;     // Z axis
		0.0, 0.0, 0.0, 1.0  >>;  // Position
	}
	if($ZeroOne== 1){
		$mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
		($bi.x), ($bi.y), ($bi.z),  0.0;     // Y axis
		($tan.x), ($tan.y), ($tan.z), 0.0;     // Z axis
		$MidPt[0], $MidPt[1], $MidPt[2], 1.0  >>;  // Position
	}
	$mI = MatrixCleanNegZero($mI);
	float $MatrizFloati[] = MatrixToFloat($mI);
	return $mI;
}

proc vector MatrixAxisTranlation(vector $SVeci, matrix $mIA, matrix $mIB){
	float $TransL[];
	$TransL[0] = $mIA[3][0];
	$TransL[1] = $mIA[3][1];
	$TransL[2] = $mIA[3][2];
	vector $VecROne[] =  GetRotationVectorsMatrix($mIA );

	vector $tranSVec = << $TransL[0], $TransL[1], $TransL[2]>>;
	//X
	vector $tranSVecA = $VecROne[0]+$tranSVec ;
	//Loc $tranSVecA;
	//Y
	vector $tranSVecB = $VecROne[1]+$tranSVec ;
	//Loc $tranSVecB;
	//Z
	vector $tranSVecC = $VecROne[2]+$tranSVec ;
	//Loc $tranSVecC;
	//YZ
	//ZX
	//XY
	vector $SVecii[];
	clear $SVecii;
	$SVecii[0] = $tranSVecB;
	$SVecii[1] = $tranSVecC;
	$SVecii[2] = $tranSVec;
	vector $SVecPoint =  $SVeci ;
	vector $YZvec = PointToPlaneN($SVecPoint, $SVecii);
	vector $SVecii[];
	clear $SVecii;
	$SVecii[0] = $tranSVecC;
	$SVecii[1] = $tranSVecA;
	$SVecii[2] = $tranSVec;
	vector $ZXvec = PointToPlaneN($SVecPoint, $SVecii);
	vector $SVecii[];
	clear $SVecii;
	$SVecii[0] = $tranSVecA;
	$SVecii[1] = $tranSVecB;
	$SVecii[2] = $tranSVec;
	vector $XYvec = PointToPlaneN($SVecPoint, $SVecii);
	//dist
	// distance2Pts
	vector $VecPlanes[];
	$VecPlanes[0] = $YZvec;
	$VecPlanes[1] = $ZXvec;
	$VecPlanes[2] = $XYvec;

float $SCale = $mIB[3][3];
	int $CombA=0;
	int $CombB =0;
	vector $CHeckVecOnLine = <<-1, -1, -1>>;
	vector $VecLineDirM;
	vector $VecLineDiri;
	float $DistToPlane[];
	int $CountN = 0;
	vector $EachVec;
	int $Time;
	float $XYZs[];
	for($EachVec in $VecPlanes){
	
if (catch($VecLineDiri = DirectionFN($SVeci,$EachVec))){
	//$VecLineDiri = DirectionFN($SVeci,$EachVec);

		$VecLineDirM = $VecLineDiri*$VecROne[$CountN];

if(!(($VecLineDirM.x) == ($VecLineDirM.y))&&(($VecLineDirM.x) == ($VecLineDirM.z))){

		//if($CombA != 3){
//KEY				
$VecLineDiri = DirectionFN($SVeci,$EachVec);
			$XYZs = $VecLineDiri;
			$DistToPlane[$CountN]= distance2Pts($SVeci,$EachVec);			
			$Time = `sign $XYZs[$CountN]`;

			if(1 !=$Time){
				//$DistToPlane[$CountN]*= -1.0;
				$DistToPlane[$CountN]*= $Time;
			}
		}else{$DistToPlane[$CountN]= 0.0;}
}else{$DistToPlane[$CountN]= 0.0;}

		$CountN++;
	}
	//print $DistToPlane;
	// $DistToPlane is Zero cord
$DistToPlane = multiplyFloat($SCale, $DistToPlane);
	vector $NewAXis;
	 $NewAXis = MultPointMatrix($DistToPlane, $mIB);
	//$NewAXis = MultPointMatrixProduct($DistToPlane, $mIB);
	float $TransLb[];
	$TransLb[0] = $mIB[3][0];
	$TransLb[1] = $mIB[3][1];
	$TransLb[2] = $mIB[3][2];
	float $NewPos[] = AddFloats($TransLb, $NewAXis);
	//Loc $NewPos;
	vector $NewPosVec = <<$NewPos[0], $NewPos[1], $NewPos[2]>>;
	//vector $NewPosVec = $NewAXis;
	return $NewPosVec;
}
/////////////////////////////////////////////////
proc vector PointToPlaneN( vector $Veciiv, vector $Vec[]){
	vector $planePointN ;
	float $pAv[]=  AverageVectorPoint($Vec);
	float $n[] = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
	float $DistanceLoc = distance2Pts(  $Veciiv, $pAv);
	float $MultDirCam[] = multiplyFloat($DistanceLoc, $n);
	float $FloatDirectionCamNormalA[] = AddFloats($pAv, $MultDirCam);
	float $PointN[] = ClosestPoint2LineVec($n, $pAv, $Veciiv);
//CHANGE_HERE useing distance
//int $CombA = distance2Pts($PointN, $pAv);
	int $CombA = PointsEquivalentTol ($PointN, $pAv);
	//if($CombA != 0){
	 if($CombA != 3){
//KEY switch these to findthe one that makes sence
		float $FloatDirectionAi[] = DirectionFN($pAv,$PointN);
		//float $FloatDirectionAi[] = DirectionFN($PointN,$pAv);
		float $DistanceLoc = distance2Pts( $PointN, $pAv );
		float $MultDirPC1[] = multiplyFloat($DistanceLoc, $FloatDirectionAi);
		float $AddMultMiiF[] = AddFloats($Veciiv, $MultDirPC1);
		$planePointN = << $AddMultMiiF[0], $AddMultMiiF[1], $AddMultMiiF[2]>>;
	}else{ $planePointN = $Veciiv;
	}
	return $planePointN;
}

proc vector [] Matrix_Curve_Translation(vector $VecPairA[],vector $VecPairB[], vector $CurveVecPointZ[]){
matrix $matrixA[4][4] = << 0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 1.0 >>;
matrix $matrixB[4][4] = << 0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 1.0 >>;
vector $EmptyVecA[];
$matrixA = TwoPointMatrixPlusAxisWorld($VecPairA, $EmptyVecA, 1);
vector $EmptyVecB[];
$matrixB = TwoPointMatrixPlusAxisWorld($VecPairB, $EmptyVecB, 1);
// Get scale changerelative to multiply in matrix
// 3 7 11 // shear 
// float matrix size 16 numbers its index Number for Scale is 15 
// matrix [3][3]
float $LengthA = distance2Pts ($VecPairA[0], $VecPairA[1]);
float $LengthB = distance2Pts ($VecPairB[0], $VecPairB[1]);
float $LengthAB ;
float $Sign_F;

if($LengthA<$LengthB){$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}else{$LengthAB = $LengthB/$LengthA; $Sign_F=1.0;}
$LengthAB *= $Sign_F;
float $MatrixFB[] = MatrixToFloat($matrixB);
size $MatrixFB;
//PrintMatrix($matrixB, 4);
$MatrixFB[15] = $LengthAB;
matrix $matrixNB[4][4];
$matrixNB = FloatToMatrix($MatrixFB);
//PrintMatrix($matrixNB, 4);
vector $NewCurveVecPts[];
float $AddMepi[];
string $curvei = "curve -d 1";
vector $eachCurveVec;
vector $newTranVec ;
$CountCpts =0;
for($eachCurveVec in $CurveVecPointZ){

//Key MatrixAxisTranlation
	$newTranVec = MatrixAxisTranlation($eachCurveVec, $matrixA, $matrixNB);
	$AddMepi = $newTranVec;
	$NewCurveVecPts[$CountCpts] = <<$AddMepi[0],$AddMepi[1],$AddMepi[2]>>;
	$curvei += " -p "+$AddMepi[0]+" "+$AddMepi[1]+" "+$AddMepi[2];
	$CountCpts++;
}
//eval($curvei);
//ResetTransEachSL;
return $NewCurveVecPts;
}


//END of Matrix Axis Translation 
///////////////////////////////////////////////////////////////////////////


proc float VectorsComp(int $ZeroOneTwo , vector $veci){
string $xyz[] = {"x", "y", "z"};
vector $v = $veci;
float $ni;
string $command = ("\$ni ="+"$v"+"."+$xyz[$ZeroOneTwo]);
return  eval($command);
}

proc string VecArrayToCurve(vector $FixVec[]){
int $sIZes = `size $FixVec `;
int $NUmers[] = CreateIntIndex($sIZes);
string $K = "";
for ($eachN in $NUmers){
$K += "\-k"+" "+$eachN+" ";
}
string $curve = "curve -d 1";
for ($eachVeCx in $FixVec){
float $valuesBi[] = $eachVeCx;
$curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
}
$curve += " "+ $K;
string $Newcurvez = `eval($curve)`;
return $Newcurvez;
}
proc PointCurvesToPlaneCurve(string $CurveItemZ[]){
for ($eachCurve in $CurveItemZ){
vector $AllLocPositionsZ[];
clear $AllLocPositionsZ;
$AllLocPositionsZ = VecCurveEps( $eachCurve );
vector $AllPlaneLocPositionZ[]= VecPointsToCameraPlane($AllLocPositionsZ);
 string $newPlaneCurve = VecArrayToCurve($AllPlaneLocPositionZ);
ResetTranslation({$newPlaneCurve});
}
}
proc float [] EulerAngB(float $pointB1[], float $pointB2[]){
float $EulerAngleA[] = `angleBetween -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2  $pointB2[0] $pointB2[1]  $pointB2[2]`;
return $EulerAngleA;
}

proc float [] MirrorPointFrom3PointPlane(vector $SelectVec[], float $oneItemFLoats[]){
  float $p[3];
  float $t[3];
  float $n[3];
	//p t n Are just a directions....
    $p = $SelectVec[0];
    $t = $SelectVec[1];
    $n = $SelectVec[2];
    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
    $norm = `unit << $n[0], $n[1], $n[2] >>`;    
    // Calculate the binormal.    
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
                 << ($norm.x), ($norm.y), ($norm.z) >>`;
    // Normalize our vector.    
    $bi = `unit $bi`;
	float $x= $oneItemFLoats[0];
	float $y= $oneItemFLoats[1];
	float $z= $oneItemFLoats[2];
$bi *=-1.0;	
	float $normal[]=  $bi;
	float $p[]=  AverageVectorPoint($SelectVec);
	float $mp[3] ;
    float $d = $normal[0] * $p[0] + $normal[1] * $p[1] + $normal[2] * $p[2] ;
    float $dist = $x * $normal[0] + $y * $normal[1] + $z * $normal[2] - $d ;
$dist *=-1.0;	
	$mp[0] = $x ;
	$mp[1] = $y ;
	$mp[2] = $z ;
	$dist *= 1.0 ;
	$dist += -1.0;
	$mp[0] = ($x + 2.0 * $normal[0] * ($dist))   ;
	$mp[1] = ($y + 2.0 * $normal[1] * ($dist))   ;
	$mp[2] = ($z + 2.0 * $normal[2] * ($dist))   ;

return $mp;
}

/*
string $itemOne[] = `ls -sl`;
float $LivePlanePosX[];
$LivePlanePosX = `xform -q -ws -t $itemOne[0]`;
float $MirrorF[] = MirrorPointFrom3PointPlane( PointArrayT(`ls -sl`), $LivePlanePosX);
Loc $MirrorF;

*/


proc vector [] PointCurvesToMirrorPoint(string $CurveItemZ[], vector $SelectVec[]){
vector $AllPlaneLocs[];
clear  $AllPlaneLocs;
vector $AllLocPositionsZ[];
clear $AllLocPositionsZ;
$AllLocPositionsZ = VecCurveEps($CurveItemZ[0] );
for ($eachVecEp in $AllLocPositionsZ){
$AllPlaneLocs[`size($AllPlaneLocs)`] = `FloatToVec (MirrorPointFrom3PointPlane( $SelectVec, $eachVecEp))`;
}
 string $newCurvei = VecArrayToCurve($AllPlaneLocs);
ResetTranslation({$newCurvei});
return $AllPlaneLocs;
}
proc vector [] PtCurvesToZMirrorPt(string $CurveItemZ[]){
vector $AllPlaneLocs[];
clear  $AllPlaneLocs;
vector $AllLocPositionsZ[];
clear $AllLocPositionsZ;
$AllLocPositionsZ = VecCurveEps($CurveItemZ[0] );
for ($eachVecEp in $AllLocPositionsZ){
float $Zx[] = $eachVecEp;
$Zx[0] *= -1.0;
$AllPlaneLocs[`size($AllPlaneLocs)`] = `FloatToVec ($Zx)`;
}
 string $newCurvei = VecArrayToCurve($AllPlaneLocs);
ResetTranslation({$newCurvei});
return $AllPlaneLocs;
}
proc vector [] VecPtsToZMirrorPts(vector $AllLocPositionsZ[]){
vector $AllPlaneLocs[];
clear  $AllPlaneLocs;
for ($eachVecEp in $AllLocPositionsZ){
float $Zx[] = $eachVecEp;
$Zx[0] *= -1.0;
$AllPlaneLocs[`size($AllPlaneLocs)`] = `FloatToVec ($Zx)`;
}
return $AllPlaneLocs;
}



proc int addStereoCurve(){
int $CreatedObjectCurve =  `ISSelectedTypeCurve`;
return $CreatedObjectCurve; 
}
/////////////////
proc int ISSelectedTypeCurve(){
string $C[];
$C = `ls -sl`;
string $nametypeZi;
string $nameA;
string $nameB;
$nametypeZi= `getTypeItemString $C`;
$nameA = `match "[a-zA-Z]+" $nametypeZi`;
$nameB = `match ".urve" $nameA`;
int $zeroOR1Z = `gmatch $nameB "*[C-c]urve*"`;
return $zeroOR1Z;
}
///////////////////

////////////////////
proc int addCurveNumbers(int $addNumbersiA){
$addNumbersiA++;
if($addNumbersiA>2){$addNumbersiA=0;}
return $addNumbersiA;
}
///////////////
proc EvalAddingCurves(){
global int $addNumbersA;
$addNumbersA = addCurveNumbers($addNumbersA);
print $addNumbersA;
}
//////////////////
//////////////////

proc float [] FloatPointsToCamPlane(float $LocPos1[]){
float $Pi = 3.1415926535;
float $pi = 3.1415926535;
float $CamPos1[];
$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
float $LivePlanePos[];
$LivePlanePos = `xform -q -ws -t LiveSurfaceB`;
float $CamerasDirectionVectorNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
float $FloatDirectionA[] = DirectionFN($CamPos1, $LocPos1);
float $DistanceLoc = distance2Pts( $LocPos1, $CamPos1 );
float $DistanceLocA = $DistanceLoc;
$DistanceLoc = $DistanceLoc * -1;
float $MultDirPC1[] = multiplyFloat($DistanceLoc, $CamerasDirectionVector);
float $FloatDirectionCamNormal[] = AddFloats($CamPos1, $MultDirPC1);
float $CamerasDirectionVectorA[] = DirectionFN($FloatDirectionCamNormal, $CamPos1);
 float $MultDirPC1A[] = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
$FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1A);
    float $p1[] = $CamPos1;
    float $p2[] = $LocPos1;
    float $p3[] = $FloatDirectionCamNormal;
float $center[]; 
float $normal[];
 	float $p1p2[3];
	float $p1p3[3];
	$p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
	$p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
  	float $normal[3];
	$normal = crossProduct( $p1p2, $p1p3, 0, 0 );
  float $FloatPosZero[] = {0, 0, 0};
float $FloatDirection[] = DirectionFN($FloatPosZero, $normal);
 		float $mid1[3], $mid2[3], $mid3[3];
	$mid1 = midPoint2Pts( $p1, $p2 );
	$mid2 = midPoint2Pts( $p1, $p3 );
       $mid3 = midPoint2Pts( $p2, $p3 );
    	float $perp_p1p2[3];
	float $perp_p1p3[3];
	$perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
	$perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
 	float $center[] = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
float $FloatDirPerpCenterC[] = DirectionFN($center,$mid2);
float $FloatDirPointAC[] = DirectionFN($p1, $p3);
	float $center8[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );	
float $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
float $FloatDirLocToPerpIntersect[] = DirectionFN($center8,$p2);
	float $OnPlane[] = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );	
return $OnPlane;
}

//PROBLEM

proc float[] DirectionF(float $EACHCVposAZ[], float $EACHCVposBZ[]){
	vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
	vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
	float $MagVectorZ1 = mag($vectorZ1); 
	float $MagVectorZ2 = mag($vectorZ2);
	float $EACHCVposHigher[];
	float $EACHCVposLower[];
	//This is freaky since it is reversed!! not sure I could ever fix this
	$EACHCVposHigher = $EACHCVposBZ;
	$EACHCVposLower = $EACHCVposAZ;
	/////////////////////////////////////
	vector $UnitVectorMagPosHigher[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
	float $vector_SubUnitMagVec1[];
	$vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 
	/*
vector $UnitVectorMagPosLower[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
float $vector_SubUnitMagVec2[];
$vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]); 
*/
	vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
	float $UnitDirection[] = $vectorUnit;
	///////////////////////////////////////////////// ////
	return $UnitDirection;
}


proc float[] DirectionFN(float $posAZ[], float $posBZ[]){

/*

vector $Vai = $VecbvA[0];
vector $Vbi = $VecbvA[1];

*/

vector $Vai = << $posAZ[0], $posAZ[1], $posAZ[2] >> ;
vector $Vbi = << $posBZ[0],  $posBZ[1], $posBZ[2] >> ;
float $xi, $yi, $zi, $x, $y, $z;

$xi = $Vai.x;
$yi = $Vai.y;
$zi = $Vai.z;
$x = $Vbi.x;
$y = $Vbi.y;
$z = $Vbi.z;
float $u= $xi - $x;
float $v= $yi - $y;
float $w= $zi - $z;


vector $VbiUnit = << $u, $v, $w >> ;
vector $VbiUnitA = `unit $VbiUnit`;
/*
float $e = 1;
//float $Mult = $e*$v;
float $Y = $u/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
float $U = $v/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
float $V = $w/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
vector $YUV = << $Y, $U, $V>>;
float $UnitDirection[] = $YUV;
*/
float $UnitDirection[];
$UnitDirection = $VbiUnitA;

//////////
return $UnitDirection;
}


/*
proc float[] DirectionF(float $posAZ[], float $posBZ[]){

vector $Va = << $posAZ[0], $posAZ[1], $posAZ[2] >> ;
vector $Vb = << $posBZ[0],  $posBZ[1], $posBZ[2] >> ;
float $xi, $yi, $zi, $x, $y, $z;

$xi = $Va.x;
$yi = $Va.y;
$zi = $Va.z;
$x = $Vb.x;
$y = $Vb.y;
$z = $Vb.z;
float $u= $xi - $x;
float $v= $yi - $y;
float $w= $zi - $z;
float $e = 1;
//float $Mult = $e*$v;
float $Y = $u/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
float $U = $v/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
float $V = $w/($e* (sqrt ((`pow $u 2`) + (`pow $v 2`) + (`pow $w 2`))));
vector $YUV = << $Y, $U, $V>>;
float $UnitDirection[] = $YUV;
//////////
return $UnitDirection;
}
*/


///////////////////////////////////////////////////////////////////////////



//STart up the engine
/*

EvalAllCurvesToolZ;
int $scriptt_jobNumConnectionChanged = `scriptJob -conditionChange delete evalVectorIndexAdditionSubtract`;
eval(" $jobNumtranslateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.translate  RUNMoveZCURVEM`;");
eval(" $jobNumrotateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.rotate  RUNMoveZCURVEM`;");

select -r LiveSurfaceB ;
MakeLive;
PencilCurveTool;

*/










//eval("print $gLastAction");

///////////////////










//////////////////////////////////////////////////////////End of all known used Stereo_curve


proc setTranslationObj(string $objectitem1[], float  $tranlate[] ){
setAttr ($objectitem1[0]+".translate") $tranlate[0] $tranlate[1] $tranlate[2];
}
proc SetObjectsToROundPoints( string $objectZ[], vector $FixVec[]){
int $IndeXa=0;
for ($eachObject in $FixVec){
float $newF[];
$newF  = roundFloatsInt($eachObject);
setTranslationObj( {$objectZ[$IndeXa]}, $newF );
$IndeXa++;
}
}

proc DisRotPiv(){
string $CurveItemZ[]=`ls -sl`;
for ($eachItemC in $CurveItemZ){
setAttr ($eachItemC +".displayRotatePivot") 1;
}
}

proc cubic(float $a, float $b, float $c, float $d, float $resultReal[] , float $resultImaginary[]) {
/*
  if ( abs(a) < 0.000001) { 
// 
if a=0 equation is quadratic
    // handle seperately to avoid divide by zero
	quadratic(b,c,d,$resultReal,$resultImaginary);
	// the quadratic function is defined on this page:
    // http://www.euclideanspace.com/maths/algebra/equations/polynomial/quadratic/
	return;
  }
*/
float $a = 7.5;
 float $b = 3.4;
 float $c = 5.3;
 float $d = 1.7;
 float $resultReal[] , $resultImaginary[];
  // recuring terms
//proc cubic(float $a, float $b, float $c, float $d, float $resultReal[] , float $resultImaginary[]) {
  float $t1=((2*$a*$a*$a) - (9*$a*$b) +(27*$c));
  float $t2=((-$a*$a) + (3*$b));
  float $t3= $t1*$t1 + 4*$t2*$t2*$t2;
  // if ($t3<0) handle complex roots;
  float $t4=((-$t1 + (`sqrt $t3`))/54);
  float $t41=((-$t1 - (`sqrt $t3`))/54);
  float $t5=((-$a*$a) + (3*$b));
  float $t6= `sqrt($t1*$t1 + (4*$t5*$t5*$t5))`;
  float $t7=((-$t1 - $t6)/54);
float $TimesOne = 1.0;
if($t7<0){ $TimesOne = -1.0;}
//print $t4;
//print $t7;
//print $t41;
 float $N=1;
if($t7<0){$N=-1;}
float $Ni=1;
if($t41<0){$Ni=-1;}
  $resultReal[0] = (-$a/3) + (` pow  $t4 (1.0/3.0)` ) +  $N*(` pow  ($t7*$N) (1.0/3.0)`) ;
  $resultReal[1] = (-$a/3) - (0.5*(`pow $t4 (1.0/3.0)`)) +  (-0.5*(`pow $t4 (1.0/3.0)`));
  $resultReal[2] = (-$a/3) + (`pow $t4 (1.0/3.0) `) + $Ni*(`pow ($Ni*$t41) (1.0/3.0)`);
  $resultImaginary[0] = 0;
  $resultImaginary[1] =  (`sqrt $t3`) * 0.5 * (`pow $t4 (1.0/3.0)`) +  (`sqrt $t3` )*0.5*(`pow $t4 (1.0/3.0) `) ;
  $resultImaginary[2] = 0;
print $resultReal;
print("\n");
print  $resultImaginary;
print("\n");
} 
proc float DoubleDeterminant(matrix $mat[][]) {
    float $valueA;
    float $valueB;
    float $valueC;
    float $valueD;
    float $valueE;
    float $valueF;
    float $valueG;
$valueA = $mat[0][3] * $mat[1][2] * $mat[2][1] * $mat[3][0]-$mat[0][2] * $mat[1][3] * $mat[2][1] * $mat[3][0];
$valueB = $mat[0][3] * $mat[1][1] * $mat[2][2] * $mat[3][0]+$mat[0][1] * $mat[1][3] * $mat[2][2] * $mat[3][0]+ $mat[0][2] * $mat[1][1] * $mat[2][3] * $mat[3][0]-$mat[0][1] * $mat[1][2] * $mat[2][3] * $mat[3][0];
$valueC = $mat[0][3] * $mat[1][2] * $mat[2][0] * $mat[3][1]+$mat[0][2] * $mat[1][3] * $mat[2][0] * $mat[3][1]+ $mat[0][3] * $mat[1][0] * $mat[2][2] * $mat[3][1]-$mat[0][0] * $mat[1][3] * $mat[2][2] * $mat[3][1];
$valueD = $mat[0][2] * $mat[1][0] * $mat[2][3] * $mat[3][1]+$mat[0][0] * $mat[1][2] * $mat[2][3] * $mat[3][1]+ $mat[0][3] * $mat[1][1] * $mat[2][0] * $mat[3][2]-$mat[0][1] * $mat[1][3] * $mat[2][0] * $mat[3][2];
$valueE = $mat[0][3] * $mat[1][0] * $mat[2][1] * $mat[3][2]+$mat[0][0] * $mat[1][3] * $mat[2][1] * $mat[3][2]+ $mat[0][1] * $mat[1][0] * $mat[2][3] * $mat[3][2]-$mat[0][0] * $mat[1][1] * $mat[2][3] * $mat[3][2];
$valueF = $mat[0][2] * $mat[1][1] * $mat[2][0] * $mat[3][3]+$mat[0][1] * $mat[1][2] * $mat[2][0] * $mat[3][3]+ $mat[0][2] * $mat[1][0] * $mat[2][1] * $mat[3][3]-$mat[0][0] * $mat[1][2] * $mat[2][1] * $mat[3][3];
$valueG = $mat[0][1] * $mat[1][0] * $mat[2][2] * $mat[3][3]+$mat[0][0] * $mat[1][1] * $mat[2][2] * $mat[3][3];
float $value = $valueA - $valueB - $valueC - $valueD - $valueE - $valueF - $valueG;
    return $value;
  }
/////////////////////////
proc Quaternion()
{
string $ObjectSel[] = `ls -sl`;
float $ParamX;
float $ParamY;
float $ParamZ;
float $x;
float $y;
float $z;
float $cx;
float $cy;
float $cz;
float $sx;
float $sy;
float $sz;
float $cycz;
float $sysz;
float $sycz;
float $cysz;
float $Qx;
float $Qy;
float $Qz;
float $Qw;
float $l;
///////WRONG Attr!
$ParamX =  getAttr ($ObjectSel[0]+".rx") ;
$ParamY =  getAttr ($ObjectSel[0]+".ry") ;
$ParamZ =  getAttr ($ObjectSel[0]+".rz") ;
$x = deg_to_rad($ParamX );
$y = deg_to_rad($ParamY );
$z = deg_to_rad($ParamZ );
$x = -$x * 0.5;
$y = -$y * 0.5;
$z = -$z * 0.5;
$cx =  cos($x) ;
$cy =  cos($y) ;
$cz =  cos($z) ;
$sx =  sin($x) ;
$sy =  sin($y) ;
$sz =  sin($z) ;
$cycz = $cy * $cz;
$sysz = $sy * $sz;
$sycz = $sy * $cz;
$cysz = $cy * $sz;
$Qw = $cycz * $cx + $sysz * $sx;
$Qx = $cycz * $sx + $sysz * $cx;
$Qy = $sycz * $cx - $cysz * $sx;
$Qz = $cysz * $cx - $sycz * $sx;
$l = sqrt( $Qx*$Qx + $Qy*$Qy + $Qz*$Qz + $Qw*$Qw );
if( $l == 0 )
{
$Qx = 0;
$Qy = 0;
$Qz = 0;
}
else
{
$Qx /= $l;
$Qy /= $l;
$Qz /= $l;
$Qw /= $l;
}
$angle = acosd($Qw) * 2;
$sinHalfAngle = sqrt(1 - ($Qw * $Qw));
if ($sinHalfAngle != 0)
{
$Qx = $Qx / $sinHalfAngle;
$Qy = $Qy / $sinHalfAngle;
$Qz = $Qz / $sinHalfAngle;
}
else
{
$Qx = 1;
$Qy = 0;
$Qz = 0;
}
$angleN = $angle;
// this is just for the other print that truncates to 0.00//
int $rAngle = $angle;
int $rX = $Qx*100; float $fx = $rX; float $xxx = $fx/100;
int $rY = $Qy*100; float $fy = $rY; float $yyy = $fy/100;
int $rZ = $Qz*100; float $fz = $rZ; float $zzz = $fz/100;
// truncated print is muted, DOES NOT ROUND OFF //
//print ($xxx+" "+-$zzz+" "+$yyy+" "+$rAngle);
print ($Qx+" "+-$Qz+" "+$Qy+" "+$angleN);
}
proc cubic(float $a, float $b, float $c, float $d, float $resultReal[] , float $resultImaginary[]) {
  float $t1=((2*$a*$a*$a) - (9*$a*$b) +(27*$c));
  float $t2=((-$a*$a) + (3*$b));
  float $t3= $t1*$t1 + 4*$t2*$t2*$t2;
  // if ($t3<0) handle complex roots;
  float $t4=((-$t1 + (`sqrt $t3`))/54);
  float $t41=((-$t1 - (`sqrt $t3`))/54);
  float $t5=((-$a*$a) + (3*$b));
  float $t6= `sqrt($t1*$t1 + (4*$t5*$t5*$t5))`;
  float $t7=((-$t1 - $t6)/54);
float $TimesOne = 1.0;
if($t7<0){ $TimesOne = -1.0;}
 float $Nin=1;
if($t4<0){$Nin=-1;}
 float $N=1;
if($t7<0){$N=-1;}
float $Ni=1;
if($t41<0){$Ni=-1;}
float $Niin=1;
if($t3<0){$Niin=-1;}
  $resultReal[0] = (-$a/3) + $Nin*(` pow ($Nin*$t4) (1.0/3.0)` ) +  $N*(` pow  ($t7*$N) (1.0/3.0)  `) ;
  $resultReal[1] = (-$a/3) - (0.5*($Nin*(` pow ($Nin*$t4) (1.0/3.0)` ))) +  (-0.5*($Nin*(` pow ($Nin*$t4) (1.0/3.0)` )));
  $resultReal[2] = (-$a/3) + $Nin*(` pow ($Nin*$t4) (1.0/3.0)` ) + $Ni*(`pow ($Ni*$t41) (1.0/3.0) `);
  $resultImaginary[0] = 0;
  $resultImaginary[1] =  (`sqrt $t3`) * 0.5 * ($Nin*(` pow ($Nin*$t4) (1.0/3.0)` )) +  (`sqrt $t3` )*0.5*($Nin*(` pow ($Nin*$t4) (1.0/3.0)` )) ;
  $resultImaginary[2] = 0;
print $resultReal;
print("\n");
print  $resultImaginary;
print("\n");
}
proc float [] lineIntersectionF(float $PosA[], float $PosB[], float $PosC[], float $PosD[]){ 
float $DirAB[] = DirectionF ($PosA, $PosB);
float $DirCD[] = DirectionF ($PosC, $PosD);
 float $locsA[] = lineIntersection($PosA, $DirAB, $PosC, $DirCD);
return $locsA;
}
// Get a matrix
proc matrix screenSpaceGetMatrix(string $attr){
  float $v[]=`getAttr $attr`;
  matrix $mat[4][4]=<<$v[0], $v[1], $v[2], $v[3];
             $v[4], $v[5], $v[6], $v[7];
             $v[8], $v[9], $v[10], $v[11];
             $v[12], $v[13], $v[14], $v[15]>>;
 return $mat;
}
// Multiply the vector v by the 4x4 matrix m, this is probably
// already in mel but I cant find it.
proc vector screenSpaceVecMult(vector $v, matrix $m){
  matrix $v1[1][4]=<<$v.x, $v.y, $v.z, 1>>;
  matrix $v2[1][4]=$v1*$m;
  return <<$v2[0][0], $v2[0][1],  $v2[0][2]>>;
}
proc vector matrixSpaceVecMult(vector $v, matrix $m){
  matrix $v1[1][4]=<<$v.x, $v.y, $v.z, 1>>;
  matrix $v2[1][4]=$v1*$m;
  return <<$v2[0][0], $v2[0][1],  $v2[0][2]>>;
}
proc matrix GetworldMatrix(string $object){
string $attr = $object +".worldMatrix";
  float $v[]=`getAttr $attr`;
  matrix $mat[4][4]= `FloatToMatrix($v)`;
 return $mat;
}
proc matrix GetworldInverseMatrix(string $object){
string $attr = $object +".worldInverseMatrix";
  float $v[]=`getAttr $attr`;
  matrix $mat[4][4]= `FloatToMatrix($v)`;
 return $mat;
}
proc matrix GetInverseMatrix(string $object){
string $attr = $object +".inverseMatrix";
  float $v[]=`getAttr $attr`;
  matrix $mat[4][4]= `FloatToMatrix($v)`;
 return $mat;
}
proc matrix GetMatrix(string $object){
string $attr = $object +".matrix";
  float $v[]=`getAttr $attr`;
  matrix $mat[4][4]= `FloatToMatrix($v)`;
 return $mat;
}

// matrix // float $MatrixSUrfaceB[]  matrix $SbMatrix[4][4];  $SbMatrix= GetMatrix("LiveSurfaceB");  float $MatrixSUrfaceB[] = MatrixToFloat($SbMatrix);

//<description>
//  	This script returns the multiplication of a point and a 
//		matrix as an array of 3 doubles:
//<pre>
//      vector * matrix = result

//		<b>Note:</b> The matrix is assumed to be a single dimension
//		array of 16 elements.
//<BR>
//		<b>Remember:</b> That the arrays are 0-based.
//		e.g. [1][0] is matrix[4] element
//<flags>
//		float $point[]	Co-ordinates of the point.
//		float $matrix[]	The matrix to be used.
//<returns>
//		float[] : Result as an array of 3 doubles.
//
//<examples>
//	float $p[] = {1,2,3};
//	float $m[] = {1,0,0,0,0,2,0,0,0,0,3,0,0,0,0,0};
//	pointMatrixMult($p, $m);
//	// Results: 1 4 9 //

 proc float[] pointMatrixMult( float $point[], float $matrix[] ){
    float $result[];
	$result[0] = 0.0;
	$result[1] = 0.0;
	$result[2] = 0.0;
	if ( size($point) != 3 || size($matrix) != 16 )
	{
		warning (uiRes("m_pointMatrixMult.kPointArray"));
		return $result;
	}
	// create the node that will do the actual computation
	//
    string $multNode;
	if ( catch($multNode = `createNode pointMatrixMult`) ) 
	{
		warning (uiRes("m_pointMatrixMult.kCouldNotCreateNode"));
		return $result;
	}
	// set the matrix and point inputs to the node
	//
    setAttr ($multNode+".vectorMultiply") true;
    setAttr ($multNode+".inPoint") -type "double3" $point[0] $point[1] $point[2];
    setAttr ($multNode+".inMatrix") -type "matrix" $matrix[0] $matrix[1] $matrix[2] $matrix[3] $matrix[4] $matrix[5] $matrix[6] $matrix[7] $matrix[8] $matrix[9] $matrix[10] $matrix[11] $matrix[12] $matrix[13] $matrix[14] $matrix[15];
	// get the result and delete the node since it is no longer required
	//
    $result = `getAttr ($multNode+".output")`;
    delete $multNode;
    return $result;
}

proc  PrintMatrix(matrix $MatriXM[][] , int $MatrixN){

int $MatrixNi = $MatrixN-1;
float $FLoatMatrixA[] = MatrixToFloat($MatriXM);
$FLoatMatrixA = MakeCleanFloatsZ($FLoatMatrixA);
string $stringFloat[]= FloatArrayToStringArray($FLoatMatrixA);
int $BytNum[];
clear $BytNum;
for ($eachFloatz in $stringFloat){
$BytNum[`size($BytNum)`] = (`sizeBytes $eachFloatz`)+2;
}
int $BytNumSort[] = $BytNum;
$BytNumSort = `sort $BytNumSort`;
int $BytNumLarg = $BytNumSort[`size($BytNumSort)`-1];
int $BytNumSmall = $BytNumSort[0];
int $BytNumDiff[];
clear $BytNumDiff;
for ($eachBytNum in $BytNum){
$BytNumDiff[`size($BytNumDiff)`] = (`abs ($eachBytNum - $BytNumLarg)`)+2;
}

int $IndXeF =0;
int $IndXeFi =0;
string $Syb = " ";
string $printcommand="";
for ($eachItemF in $stringFloat){
string $AddedSPaces = AddItemString($BytNumDiff[$IndXeF], $Syb);
if($IndXeFi==$MatrixNi){ $printcommand += $AddedSPaces + $eachItemF + "|"+ "\n" ;
$IndXeFi= -1; }else{ if($IndXeFi==0){$printcommand += "|"+$AddedSPaces + $eachItemF;}else{ $printcommand += $AddedSPaces + $eachItemF;}}
$IndXeFi++;
$IndXeF++;
}
print $printcommand; 
}


proc string AddItemString(int $iN, string $NumLetorSy){
int $Xz =0;
string $AddItem ="";
while($iN > $Xz){
$AddItem+= $NumLetorSy;
$Xz++;
}
return $AddItem;
}


proc matrix MatrixMirrorX(matrix $m[][]){
float $MatrixA[] = `MatrixToFloat($m)`;
  matrix $m2[4][4]=<<1.0, 0.0, -1.0, 0.0;
             -1.0, 1.0, 1.0, 0.0;
             -1.0, 1.0, 1.0, 0.0;
             -1.0, 1.0, 1.0, 1.0>>;
float $MatrixB[] = `MatrixToFloat($m2)`;
int $iX =0;
float $DividedFLoats[];
for ($eachFloat in $MatrixA){
if(!($MatrixB[$iX]==0)){
$DividedFLoats[`size($DividedFLoats)`] = $eachFloat * $MatrixB[$iX];
}else{$DividedFLoats[`size($DividedFLoats)`] = $eachFloat;}
$iX++;
}
matrix $MatrixDiv[4][4]= FloatToMatrix($DividedFLoats);
return $MatrixDiv;
}

proc float [] MultMatrixMirrorX(float $point[]){

  matrix $m2[4][4]=<<1.0, 0.0, -1.0, 0.0;
             -1.0, 1.0, 1.0, 0.0;
             -1.0, 1.0, 1.0, 0.0;
             -1.0, 1.0, 1.0, 1.0>>;
float $MatrixB[] = `MatrixToFloat($m2)`;
float $FLoatPointA[] = pointMatrixMult( $point, $MatrixB );
return $FLoatPointA;
}

proc matrix MatrixTimesFloat(matrix $m[][], float $X){
float $MatrixA[] = `MatrixToFloat($m)`;

int $iX =0;
float $DividedFLoats[];
for ($eachFloat in $MatrixA){
$DividedFLoats[`size($DividedFLoats)`] = $eachFloat * $X;

$iX++;
}
matrix $MatrixDiv[4][4]= FloatToMatrix($DividedFLoats);
return $MatrixDiv;
}

proc matrix MatrixDivide(matrix $m[][], matrix $m2[][]){
float $MatrixA[] = `MatrixToFloat($m)`;
float $MatrixB[] = `MatrixToFloat($m2)`;
int $iX =0;
float $DividedFLoats[];
for ($eachFloat in $MatrixA){
if(!($MatrixB[$iX]==0)){
$DividedFLoats[`size($DividedFLoats)`] = $eachFloat/ $MatrixB[$iX];
}else{$DividedFLoats[`size($DividedFLoats)`] = $eachFloat;}
$iX++;
}
matrix $MatrixDiv[4][4]= FloatToMatrix($DividedFLoats);
return $MatrixDiv;
}

proc matrix MatrixCleanNegZero(matrix $m[][]){
float $MatrixA[] = `MatrixToFloat($m)`;

int $iX =0;
float $CleanFLoats[];
for ($eachFloat in $MatrixA){
if(($eachFloat == 0)||($eachFloat == -0)){
$CleanFLoats[`size($CleanFLoats)`] = 0.0;
}else{$CleanFLoats[`size($CleanFLoats)`] = $eachFloat;}
$iX++;
}
$CleanFLoats = MakeCleanFloatsZ($CleanFLoats);
matrix $MatrixClean[4][4]= FloatToMatrix($CleanFLoats);
return $MatrixClean;
}

proc TransformRelByMatrixXform(matrix $m[][], string $item){
string $itemD[] = `duplicate -rr $item`;
vector $VecLi[]; 
$VecLi = PointArrayT($itemD);
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3]) 
                 ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3]) 
                 ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3]) 
                 (0) (0) (0) (1) $itemD[0];
vector $NewVeci;
 $NewVeci = VecMultMatrix($VecLi[0], $m);
 xform -ws -t ($NewVeci.x) ($NewVeci.y) ($NewVeci.z) $itemD[0];
}

proc TransformRelByMatrixXformM(matrix $m[][], string $itemA[]){
string $itemD[];
vector $VecLi[]; 
$VecLi = PointArrayT($itemA);
vector $NewVeci;
int $count = 0;
for($item in $itemA){
 $itemD  = `duplicate -rr $item`;
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3]) 
                 ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3]) 
                 ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3]) 
                 (0) (0) (0) (1) $itemD[0];
 $NewVeci = VecMultMatrix($NewVeci, $m);
 xform -ws -t ($NewVeci.x) ($NewVeci.y) ($NewVeci.z) $itemD[0];
$count++;
}
}

proc TransformItemByMatrixXform(matrix $m[][], string $item){
string $itemD[] = `duplicate -rr $item`;
    xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3]) 
                 ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3]) 
                 ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3]) 
                 ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $itemD[0];
}
proc TransformItemByMatrixXformObjSpace(matrix $m[][], string $item){
string $itemD[] = `duplicate -rr $item`;
    xform -os -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3]) 
                 ($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3]) 
                 ($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3]) 
                 ($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $itemD[0];
}


//////////////////






//LOCcurve268END
//LOCcurve208END



//////////////////
/// StereoCurveZ($StereoCurveZ[0], $StereoCurveZ[1]);
//modifySelectedCurves smooth 18 0;
/////////////////////////////////////////////////////////////////////


/*

//////////////////////////////////////////////////////////////////////
proc string AverageANdCLoseSketchFittingCircle(string $curveItemC){
///////////////////////////////
string $CurveItemZai[];
$CurveItemZai[0] = $curveItemC;
float $Arc = `arclen $CurveItemZai[0]`;
$Arc = $Arc /3.5;
 rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s $Arc -d 3 -tol 0.05 $CurveItemZai[0];
string $curvesZi = $CurveItemZai[0];
float $angleZi[];
vector $CurveCollectVec[];
float $TotalDegi;
int $Low_X;
int $TrackC[];
$CurveCollectVec = CurvatureUtilityAngles($curvesZi, 130, $angleZi, $TotalDegi,$Low_X, $TrackC);
int $NewIndex[];
clear $NewIndex;
$NewIndex  = SortNumbersIntIndex($angleZi);
vector $nevVec[] = NewVecOrderWithINTKey($NewIndex,$CurveCollectVec);
vector $vectorZnewX[];
 $vectorZnewX =$nevVec;
string $TestCurveC;
int $Xv=0;
while($Xv < 22){
 $vectorZnewX = AverageCurveVec($vectorZnewX);
$Xv++; 
}
 $TestCurveC = VecArrayToCurveB($vectorZnewX);
ResetTransEachSL;
// Error: line 70: No object matches name: layer1 // 
createDisplayLayer -name "layer1" -number 1 -empty;
// Problem with return values above N kinds.. maya errors 
////////////////////////////////////////////////



string $OneCurve[] = `ls -sl`;
string $OneCurveS = $OneCurve[0];
int $TFNS = 1;
string $CurveNS;
$CurveNS = IScircleTF($OneCurveS,$TFNS);
print $TFNS;

vector $EmptyVectorArrayA[];
string $NewOneCurveS;

if($TFNS==1){
 $NewOneCurveS = EllipesSketchFitting($CurveNS, $EmptyVectorArrayA);
}else{  $NewOneCurveS = $OneCurveS;}

print $EmptyVectorArrayA;

select -r $NewOneCurveS;

	
	float $Ellipes_A[];
	$Ellipes_A = `xform -q -ws -t $NewOneCurveS`;


	
	float $CamPos_A[];
	$CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
	float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;
	float $MidEpipolZx[] = MidPoint($CamPos_M, $CamPos_A);
	float $MidEpipolPosFCam[]= FloatPointsToCamPlane($MidEpipolZx);	

Loc $MidEpipolPosFCam;

float  $AngleX[];

for($EachVec in $EmptyVectorArrayA){

//if line betweens average centor  is not the line between N vec point from curve find its angle becuase if the vector point on curve
// if it happens to be exactly on the line i would be tring to find the angle  of three point of a line which is zero........

$AngleX[`size($AngleX)`] = AngleofTwoLines($EachVec,$MidEpipolPosFCam,$Ellipes_A ,$MidEpipolPosFCam);


}

int $NewIndex[];
clear $NewIndex;
$NewIndex  = SortNumbersIntIndex($AngleX);

Loc  $EmptyVectorArrayA[$NewIndex[0]];
Loc  $EmptyVectorArrayA[$NewIndex[1]];

int $IndexTrack[];
$IndexTrack = $NewIndex;
$IndexTrack = ReverseIntArray($IndexTrack);
Loc  $EmptyVectorArrayA[$IndexTrack[0]];
Loc  $EmptyVectorArrayA[$IndexTrack[1]];

print $IndexTrack[0]
161;

print $AngleX;




*/



// need for some reason
createDisplayLayer -name "layer1" -number 1 -empty;

proc float AngleofTwoLines(vector $vecA,vector $vecB,vector $vecC,vector $vecD){
float $angleA;
float $AngleB[] = EulerAngB((DirectionFN($vecA, $vecB)), (DirectionFN($vecC, $vecD)));
$angleA = $AngleB[3];
return $angleA;
}





proc CurvesToPlane(string $CurveItemZ[]){
global string $PlaneCurveS[];
	string $PCurvesName = "Plane";
string $Combine;
string $PlaneCurvA[];
int $CountN=0;
 string $newPlaneCurve;
for ($eachCurve in $CurveItemZ){
vector $AllLocPositionsZ[];
clear $AllLocPositionsZ;
$AllLocPositionsZ = VecCurveEps( $eachCurve );
vector $AllPlaneLocPositionZ[]= VecPointsToCameraPlane($AllLocPositionsZ);
 $newPlaneCurve = VecArrayToCurve($AllPlaneLocPositionZ);
//$Combine = ($PCurvesName+$eachCurve);
//$newPlaneCurve = `rename $newPlaneCurve  $Combine`; 
ResetTranslation({$newPlaneCurve});
$PlaneCurvA[$CountN]= $newPlaneCurve;
$CountN++;
}
$PlaneCurveS = $PlaneCurvA;

}

/*
global string $PlaneCurveS[];

string $LayerCurvesRangeA[] =  `queryLayerRangeMembers`;
CurvesToPlane($LayerCurvesRangeA);
select -r $PlaneCurveS;

//setAttr "locator1.scaleX" 0.085;
*/

global float $AngleEpiPole;
global int $IsOrthoLineTrue;
global int $AxisOrthoLine;



proc StereoCurveZ(string $CurveItemZai, string $CurveItemZbi){

/*
temp debug

	vector $PositionsZ_A[];
	clear $PositionsZ_A;
	$PositionsZ_A = VecCurveEps($CurveItemZai );

float $AverageVecCurve[] =  AverageVectorPoint($PositionsZ_A);
Loc $AverageVecCurve;
	float $CamDirVecNormalA[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);



int $TrueorFalseCircle = `IsCircle`;
if ($TrueorFalseCircle == 1){
string $newCircle[] = `MakeCIRCLE($StereoCurveZ)`;
}
//////////////////////////////////////////////////////////////

$StereoCurveZ= `ls -sl`;
string $CurveItemZai = $StereoCurveZ[0];
string $CurveItemZbi = $StereoCurveZ[1];

global string $PlaneCurveS[];

string $LayerCurvesRangeA[];
$LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;

CurvesToPlane($LayerCurvesRangeA);
select -r $PlaneCurveS;

vector $AllLocPositionsZi[];
clear $AllLocPositionsZi;
$AllLocPositionsZi = VecCurveEps( $eachCurve );



*/


	global string $StereoCurveZ[];
	global string $VanishingPointsLinesTempGuides[];
	global int $addNumbersA;	
	global float $VanishingPointGlobal[];

global float $AngleEpiPole;
global int $IsOrthoLineTrue;
global int $AxisOrthoLine;
	

	vector $VecCurEndsa[] = VecCurveEnds({$CurveItemZai});
	vector $VecCurEndsb[] = VecCurveEnds({$CurveItemZbi});
	
	rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 1 -tol 0.05 $CurveItemZai;
	rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 1 -tol 0.05 $CurveItemZbi;
	//gathering all Curve Points

	vector $PositionsZ_A[];
	clear $PositionsZ_A;
	$PositionsZ_A = VecCurveEps($CurveItemZai );
	vector $PositionsZ_B[];
	clear $PositionsZ_B;
	$PositionsZ_B = VecCurveEps($CurveItemZbi );

	// mirroring across ZY plane or X axis
	vector  $VecPtsMirrorA[];
	clear $VecPtsMirrorA;
	vector  $VecPtsMirrorA[]= VecPtsToZMirrorPts( $PositionsZ_A);
	vector  $VecPtsMirrorB[];
	clear $VecPtsMirrorB;
	$VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
	float $CamPos_A[];
	float $CamPlane1[];
	$CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
	$CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
	float $CamDirVecNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
	float $MultDirCam[] = multiplyFloat(-1, $CamDirVecNormal);
	float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;

	vector  $VecPtsMirrorEnds_A[];
	clear $VecPtsMirrorEnds_A;	
	vector  $VecPtsMirrorEnds_A[]= VecPtsToZMirrorPts( $VecCurEndsa);
	vector  $VecPtsMirrorEnds_B[];
	clear $VecPtsMirrorEnds_B;	
	$VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
	
	float $CamNormM[] = ` MirrorFloatXYZ 0 $MultDirCam`;		
	float $MidEpipolZx[] = MidPoint($CamPos_M, $CamPos_A);	

	//Key Element
	float $MidEpipolPosFCam[]= FloatPointsToCamPlane($MidEpipolZx);

      // Loc $MidEpipolPosFCam;
      // Loc $CamPos_A;

	float $EpipolPosCamM[] = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;	
	//float $MidPosFCam[]= FloatPointsToCamPlane($centerCam);
	float $MidPosFCam[]= $CamPlane1;
	
	float $FloatDirEpipol[] = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
	 float $FloatDirEpipolB[] = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);

	float $EpipolXx[] = {0.0,$CamPos_A[1],$CamPos_A[2]};	
	float $PlaneEpipolXx[]= FloatPointsToCamPlane( $EpipolXx);
//Loc $PlaneEpipolXx;
	float $EpipolYx[] = {$CamPos_A[0],0.0,$CamPos_A[2]};	
	float $PlaneEpipolYx[]= FloatPointsToCamPlane( $EpipolYx);
//Loc $PlaneEpipolYx;
	float $EpipolZx[] = {$CamPos_A[0],$CamPos_A[1],0.0};	
	float $PlaneEpipolZx[]= FloatPointsToCamPlane( $EpipolZx);
//Loc $PlaneEpipolZx;

// The end Points of the first curve Drawn to the Epipol of CAMERA one //##
vector $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
vector $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);

// Loc $PointN_Epi;
// Loc $PointN_EpiB;
//Loc $VecCurEndsb[0];

float $DistTOEpipol_CurEndA;
float $DistTOEpipol_CurEndB;

//below I use a if statement to weigh if the two curves start and end points are corrosponding to its mirror symetry
 $DistTOEpipol_CurEndA = distance2Pts($PointN_Epi, $VecCurEndsb[0]);
 $DistTOEpipol_CurEndB = distance2Pts($PointN_EpiB, $VecCurEndsb[0]);

// if( $DistTOEpipol_CurEndA > $DistTOEpipol_CurEndB){ //

//curve2points ($PointN_Epi, $VecCurEndsb[0]);
//curve2points ($PointN_EpiB, $VecCurEndsb[0]);

float $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
float $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
float $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;


float $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
float $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
// $BCurEndBNN -= $BCurEndBiiAdd ;
float $BCDiff = abs($BCurEndB - $BCurEndBNN);


float $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd ;
 float $BCDiffi = abs($BCurEndB - $BCurEndBNNi);
//int $IntIfNearZero = equivalentTol($BCurEndB, $BCurEndBNNi,  0.0001);
int $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);

//Loc $PointN_Epi;
//Loc $PointN_EpiB;

	float $FloatDirEndPtsA[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
	float $EulerAngleA[] = EulerAngB($FloatDirEndPtsA, $FloatDirEpipol);	
	float $EulerAngle_A = $EulerAngleA[3];
	float $FloatDirEndPtsB[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
	float $EulerAngleB[] = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);	
	float $EulerAngle_B = $EulerAngleB[3];

	float $FloatDirEndPtsAi[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
	float $EulerAngleAi[] = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);	
	float $EulerAngle_Ai = $EulerAngleAi[3];
	float $FloatDirEndPtsBi[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
	float $EulerAngleBi[] = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);	
	float $EulerAngle_Bi = $EulerAngleBi[3];

print ($EulerAngle_A+"\n");
print ($EulerAngle_B+"\n");
print ($EulerAngle_Ai+"\n");
print ($EulerAngle_Bi+"\n");

float $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
float $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;


vector $Vecbv[];
vector $Vecbvi[];
$Vecbv  = $VecCurEndsa;
$Vecbvi = $VecCurEndsb;
int $IfTrue;
 $IfTrue = FindLineCross( $Vecbv , $Vecbvi );
int $weighedtFindings=0;
int $weighedtFindingsZ=0;
int $weighedtFindingsN=0;


	if($IfTrue==0){
$weighedtFindings++;
$weighedtFindingsZ++;
}else{$weighedtFindings--;
$weighedtFindingsN++;
}



	if($IntIfNearZero==1){
$weighedtFindings++;
$weighedtFindingsZ++;
}else{$weighedtFindings--;
$weighedtFindingsN++;}


	if($EulerAngle_AB<$EulerAngle_AiBi){
$weighedtFindings++;
$weighedtFindingsZ++;
}else{$weighedtFindings--;
$weighedtFindingsN++;}

print ($weighedtFindings+"\n");
print ($weighedtFindingsZ+"\n");
print ($weighedtFindingsN+"\n");

////////////////PLace find otrtho Curve here 

vector $NewVecENDsi[];

 float $LengCRV_a = `arclen $CurveItemZai`;

vector $CRV_ENDSi[];
 $CRV_ENDSi = $VecCurEndsa;
float $DistEndsi; 
$DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
float $PerDiff = percent_of( $LengCRV_a, $DistEndsi);

 float $LengCRV_b = `arclen $CurveItemZbi`;
vector $CRV_ENDSii[];
 $CRV_ENDSii = $VecCurEndsb;
float $DistEndsii; 
$DistEndsii = distance2Pts($CRV_ENDSii[0], $CRV_ENDSii[1]);
float $PerDiffii = percent_of( $LengCRV_b, $DistEndsii);

float $PerDiffSum = ($PerDiff+$PerDiffii)/2.0;
int $triggerStraitCRV=0;

		//START of StraitCurve//

	if( $PerDiffSum<5.5){

$triggerStraitCRV=1;


float $DDirEpipol[] = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
float $MidCurveA[] = MidPoint($VecCurEndsa[0], $VecCurEndsa[1]);
float $MidCurveB[] = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);

vector $DDirEpipolXYZ[];
$DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
$DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
$DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);


vector $AllEpipolXYZ[];
$AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
$AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
$AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);

//PositiveDirectionLine
//    Loc $MidEpipolPosFCam;
//$VecCurEndsa


vector $EpipolD[];
 $EpipolD = $DDirEpipolXYZ;

vector $LineMidi;
vector $NewDirZi;
float $AngleXi;
int $Trueii=0;
$NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
//print $IsOrthoLineTrue;
//print $AxisOrthoLine;
//print $LineMidi;
//print $NewDirZi;
//found Direction

vector $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];


if($IsOrthoLineTrue==1){


$NewVecENDsi  = makeCurvePointDirectionLengthN($DistEndsi, $NewDirZi, $MidCurveA); 
//delete;

$VecCurEndsa[0] = $NewVecENDsi[0];
$VecCurEndsa[1] = $NewVecENDsi[1];

if($AxisOrthoLine!=0){

$FloatDirEpipol = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
$FloatDirEpipolB= DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
//float $DistEndsii = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
float $MidCurveB[] = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);

float $DDirEpipolB[] = DirectionFN($MidCurveB, $FoundEpipol);
float $DDirEpipolA[] = DirectionFN($FoundEpipol,$MidCurveB);


vector $Intersect_LineB_a;
$Intersect_LineB_a = FloatToVec (lineIntersection($MidCurveB, $DDirEpipolB, $VecCurEndsa[0],$FloatDirEpipol));
vector $Intersect_LineB_b = FloatToVec (lineIntersection($MidCurveB, $DDirEpipolA, $VecCurEndsa[1],$FloatDirEpipolB));
//Loc $Intersect_LineB_a;
//Loc $Intersect_LineB_b;

$VecCurEndsb[0] = $Intersect_LineB_a;
$VecCurEndsb[1] = $Intersect_LineB_b;

clear $PositionsZ_A;
clear $PositionsZ_B;
clear $VecPtsMirrorEnds_A;
clear $VecPtsMirrorEnds_B;
clear $VecPtsMirrorA;
clear $VecPtsMirrorB;

$PositionsZ_A[0] =  $NewVecENDsi[0];
$PositionsZ_A[1]= FloatToVec (MidPoint($NewVecENDsi[0],$NewVecENDsi[1]));
$PositionsZ_A[2] =  $NewVecENDsi[1];

$PositionsZ_B[0] =  $Intersect_LineB_a;
$PositionsZ_B[1]= FloatToVec (MidPoint($Intersect_LineB_a, $Intersect_LineB_b));
$PositionsZ_B[2] =  $Intersect_LineB_b;

	$VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
	$VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
	$VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
	$VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
			
}



}
}

	if($weighedtFindingsZ<$weighedtFindingsN){

cycleBackgroundColor;
		//reverseCurve  -ch 0 -rpo 1 -cos on $CurveItemZai;
		//$VecCurEndsa = ReverseVectorArray($VecCurEndsa);
		$PositionsZ_B = ReverseVectorArray($PositionsZ_B);
		// $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
 $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);

	}



	 
	string $queryLocCurveEnds3D[];
	$queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;

	vector $IntersectEnds_A[];
		clear $IntersectEnds_A;
		int $iia = 0;
		vector $Intersect_A[];
		clear $Intersect_A;
		vector $Intersect_ATwo[1];
		clear $Intersect_ATwo;
		vector $IntersectForce_A[];
		clear $IntersectForce_A;
		vector $IntersectAverage_A[];
		clear $IntersectAverage_A;
		float $PointToCamDir[];
		float $PointsClos[];

vector $PositionsZ_Ai[];
vector $PositionsZ_Bi[];


	if(`size( $queryLocCurveEnds3D)`>3){	
	
		vector $LocCurveEndsVec3D[] = PointArray($queryLocCurveEnds3D);
	
		for ($eachVecx in  $VecCurEndsa)
		{

		$IntersectEnds_A[$iia] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsa[$iia], $CamPos_M, $VecPtsMirrorEnds_B[$iia]));
			$iia++;
		}

		///////// find nearest for both curve ends on one curve with those two points they become four points mirrored X

		float $distToCurveE_A[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[0]);
int $AllLocsi[] = CreateIntIndex(`size($LocCurveEndsVec3D)`);
string $AllLocs_String[] = IntArrayToStringArray($AllLocsi);
		string $EmptyStringNewOrderA[];
		float $newOrdersZA[] = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
$EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
int $New_AllLocs_A[];
$New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
int $Near_index_A = $New_AllLocs_A[0];
float $Distance_A = $distToCurveE_A[$Near_index_A];
float $Found_pt_A[] = $LocCurveEndsVec3D[$Near_index_A];		
		float $newOrdersZAM[] = $Found_pt_A;
		$newOrdersZAM[0] = $Found_pt_A[0] *-1;	

		float $distToCurveE_B[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[1]);		
		string $EmptyStringNewOrderB[];
		float $newOrdersZB[] = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
$EmptyStringNewOrderB = ReverseStringArray($EmptyStringNewOrderB);
int $New_AllLocs_B[];
$New_AllLocs_B = ArrayToIntList($EmptyStringNewOrderB);
int $Near_index_B = $New_AllLocs_B[0];
float $Distance_B = $distToCurveE_B[$Near_index_B];
float $Found_pt_B[] = $LocCurveEndsVec3D[$Near_index_B];
		float $newOrdersZBM[] = $Found_pt_B;
		$newOrdersZBM[0] = $Found_pt_B[0] *-1;

		vector $PointsA[];
		$PointsA[0] = FloatToVec($Found_pt_A);
		$PointsA[1] = FloatToVec($Found_pt_B);
		vector $PointsB[];
		$PointsB[0] = FloatToVec($newOrdersZAM); // negative mirror of first endpoint of first curve
		$PointsB[1] = FloatToVec($newOrdersZBM);
		// vec points to plane 
		//them matrix transformation
		//  know that the camera may be in the positive or negative x axis ... try to make it so that
		//  it will not matter what order  the curve is drawn for the first curve might represent the positive axis or 
		// the negitive where is the camera is what you know first  .. what you know second is what the first curve represents
//Loc $PointsA[0];


		vector $VecOnPlaneA[];
		$VecOnPlaneA = VecPointsToCameraPlane($PointsA);
		vector $VecOnPlaneB[];
		$VecOnPlaneB = VecPointsToCameraPlane($PointsB);

//print $Distance_A;
//print $Distance_B;

int $triggerNoTrans =0;
string $NewFoundLocs[];

$NewFoundLocs[0] = $queryLocCurveEnds3D[$Near_index_A];
$NewFoundLocs[1] = $queryLocCurveEnds3D[$Near_index_B];
	string $arrayCurvesNear[];
$arrayCurvesNear[0] = ("Plane"+$NewFoundLocs[0]);
$arrayCurvesNear[1] = ("Plane"+$NewFoundLocs[1]);
$NewFoundLocs = $arrayCurvesNear;

	vector $LocOnPlaneVec[] = PointArray($NewFoundLocs);
float $distToPlaneLoc[];
$distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocOnPlaneVec[0]);
$distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocOnPlaneVec[1]);
 print $distToPlaneLoc;



//if($distToPlaneLoc[0]<0.0025){

 if(!($Distance_A<2.0005)){
//if((!($Distance_B<1.0005))&&(!($distToPlaneLoc[1]<0.00195))){
$VecOnPlaneA[0] = $VecCurEndsa[0];
$VecOnPlaneB[0] = $VecCurEndsb[0];
PAUSE;
$triggerNoTrans++;
}

//}

//if($distToPlaneLoc[1]<0.0025){

 if(!($Distance_B<2.0005)){
//if((!($Distance_B<1.0005))&&(!($distToPlaneLoc[1]<0.00195))){
$VecOnPlaneA[1] = $VecCurEndsa[1];
$VecOnPlaneB[1] = $VecCurEndsb[1];
PAUSE;
$triggerNoTrans++;
}

//}


if($triggerNoTrans!=2){

	 vector $PositionsZ_A[];
	 clear $PositionsZ_A;
	 $PositionsZ_A = VecCurveEps($CurveItemZai );



$PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEndsa,$VecOnPlaneA, $PositionsZ_A);



$PositionsZ_Bi = Matrix_Curve_TranslationCC($VecCurEndsb, $VecOnPlaneB, $PositionsZ_B);




	clear $VecPtsMirrorA;
	$VecPtsMirrorA= VecPtsToZMirrorPts( $PositionsZ_Ai);
	clear $VecPtsMirrorB;
	$VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_Bi);
$PositionsZ_A = $PositionsZ_Ai;
$PositionsZ_B = $PositionsZ_Bi;
cycleBackgroundColor;
}

	}


	//////////////////////////////////////////////////////////////////////////////////////
	//Closest Point to Line !! is you want to make it more true to the curve drawn.
	//cool!
	///////////////      ///////////////
	///////////////      ///////////////

			//$IntersectEnds_A[$iia] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsa[$iia], $CamPos_M, $VecPtsMirrorEnds_B[$iia]));
			//ADDED
			//$PointToCamDir = DirectionFN($CamPos_A, $VecCurEndsa[$iia]);

			//$IntersectForce_A[$iia] = FloatToVec (ClosestPoint2Line($PointToCamDir, $CamPos_A,  $IntersectEnds_A[$iia]));
			//$Intersect_ATwo[0] = $IntersectEnds_A[$iia];
			//$Intersect_ATwo[1] = $IntersectForce_A[$iia];
			//$IntersectAverage_A[$iia] =  FloatToVec(AverageVectorPoint($Intersect_ATwo));
			///
			//$iia++;


	int $iiz = 0;
	vector $IntersectEnds_A[];
		clear $IntersectEnds_A;
		int $iia = 0;
		vector $Intersect_A[];
		clear $Intersect_A;
		vector $Intersect_ATwo[1];
		clear $Intersect_ATwo;
		vector $IntersectForce_A[];
		clear $IntersectForce_A;
		vector $IntersectAverage_A[];
		clear $IntersectAverage_A;
		float $PointToCamDir[];
		float $PointsClos[];


	int $colori[];
	$colori[`size($colori)`] = 13;
	$colori[`size($colori)`] = 14;
	
string $AllCirTemp[];
	string $CirTemp[];
	
	for ($eachVecx in  $VecPtsMirrorA)
	{
		$Intersect_A[`size($Intersect_A)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_B[$iiz], $CamPos_M, $VecPtsMirrorA[$iiz]));
	//DEMO	
if((fmod($iiz, 12))== 2){
curve2points($PositionsZ_B[$iiz], $Intersect_A[`size($Intersect_A)`-1]);
	$CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[0]);
$AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
PAUSE;
		curve2points($VecPtsMirrorA[$iiz], $Intersect_A[`size($Intersect_A)`-1]);
	$CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[1]);
$AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
PAUSE;
}

		$iiz++;
	}


delete $AllCirTemp;

	string $ThefirstCurve = VecArrayToCurve($Intersect_A);
	//string $ThefirstCurve = VecArrayToCurve($IntersectAverage_A);
	modifySelectedCurves smooth 18 0;
//  string $NewCurveA[] = SmoothCurvature3(6);
	//rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 28 -d 1 -tol 0.05 $ThefirstCurve;
	///////////////
/*
	$iiz = 0;
	vector $Intersect_B[];
	clear $Intersect_B;
	/////	
	////////
	for ($eachVecxi in  $VecPtsMirrorA)
	{
		$Intersect_B[`size($Intersect_B)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_A[$iiz], $CamPos_M,   $VecPtsMirrorB[$iiz]));
		$iiz++;
	}
*/
	vector $Intersect_B[];
	clear $Intersect_B;
	$Intersect_B= VecPtsToZMirrorPts($Intersect_A);
	string $ThefirstCurvei = VecArrayToCurve($Intersect_B);
	modifySelectedCurves smooth 18 0;
// string $NewCurveB[] = SmoothCurvature3(6);
	//rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 28 -d 1 -tol 0.05 $ThefirstCurvei;
	///////////////      ///////////////
	///////////////      ///////////////
//offsetCurve  -ch on -rn false -cb 2 -st true -cl true -cr 0 -d 1 -tol 0.01 -sd 5 -ugn false  $ThefirstCurve ;
//offsetCurve  -ch on -rn false -cb 2 -st true -cl true -cr 0 -d 1 -tol 0.01 -sd 5 -ugn false  $ThefirstCurvei ;
	
	delete $VanishingPointsLinesTempGuides;
	clear $VanishingPointsLinesTempGuides;
	delete $CurveItemZai $CurveItemZbi;
	clear $StereoCurveZ;
	$addNumbersA =0;
	clear $VanishingPointGlobal;
	ResetTranslation({$ThefirstCurve});
	CurveIndexVecTracking({$ThefirstCurve});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 
	$ThefirstCurve;
	ResetTranslation({$ThefirstCurvei});
	CurveIndexVecTracking({$ThefirstCurvei});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 
	$ThefirstCurvei;
	evalVectorIndexAdditionSubtract;
	EVALCamScripts;
}

//getAttr "ZCURVEModelingCAMShape.centerOfInterest" 559.102043;
//-worldCenterOfInterest

//getAttr "ZCURVEModelingCAMShape.worldCenterOfInterest"
//camera -q -worldCenterOfInterest "ZCURVEModelingCAMShape"
//////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
/*
temp debug

	vector $PositionsZ_A[];
	clear $PositionsZ_A;
	$PositionsZ_A = VecCurveEps($CurveItemZai );

float $AverageVecCurve[] =  AverageVectorPoint($PositionsZ_A);
Loc $AverageVecCurve;
	float $CamDirVecNormalA[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);



int $TrueorFalseCircle = `IsCircle`;
if ($TrueorFalseCircle == 1){
string $newCircle[] = `MakeCIRCLE($StereoCurveZ)`;
}
//////////////////////////////////////////////////////////////

proc string CreateCrvInter( string $crv1, string $crv2,
	int $useDir, float $tolerance,
	float $intersections1[], float $intersections2[] )
{
	// Create the intersect node	
	string $intersectNode = `createNode curveIntersect`;
	setAttr ($intersectNode + ".tolerance") $tolerance;
	connectAttr ($crv1 + ".worldSpace") ($intersectNode + ".inputCurve1");
	connectAttr ($crv2 + ".worldSpace") ($intersectNode + ".inputCurve2");
	setAttr ($intersectNode + ".useDirection") $useDir;
	// Check if there are any intersections.  If not, then delete
	// the node and return nothing.
	//
	$intersections1 = `getAttr ($intersectNode + ".parameter1")`;
	int $numIparms = size($intersections1);
	if( $numIparms == 0 ) {
		delete $intersectNode;
		$intersectNode = "";
	} else {
		$intersections2 = `getAttr ($intersectNode + ".parameter2")`;
	}
// remenber to 
delete $intersectNode;
	return $intersectNode;
}


proc int [] CreateCrvInterTF( string $crv1, string $Allcrv2[],
	int $useDir, float $tolerance,
	float $intersections1[], float $intersections2[] )
{

int $TF=0;
	// Create the intersect node
int $CurveIndexInter[];
float $intersectionsA[];	
float $intersections1A[];	
float $intersections1B[];	
for($eachCurve in $Allcrv2){
	string $intersectNode = `createNode curveIntersect`;
	setAttr ($intersectNode + ".tolerance") $tolerance;
	connectAttr ($crv1 + ".worldSpace") ($intersectNode + ".inputCurve1");
	connectAttr ($eachCurve + ".worldSpace") ($intersectNode + ".inputCurve2");
	setAttr ($intersectNode + ".useDirection") $useDir;
	// Check if there are any intersections.  If not, then delete
	// the node and return nothing.	 
	$intersectionsA = `getAttr ($intersectNode + ".parameter1")`;
	int $numIparms = size($intersectionsA);
	if( $numIparms == 0 ) {
	$TF=0; 
	} else {
		$TF=1;
$intersections1A = `getAttr ($intersectNode + ".parameter1")`;
$intersections1B = `getAttr ($intersectNode + ".parameter2")`;
AppendFloatArray($intersections1,$intersections1A);
AppendFloatArray($intersections1,$intersections1B);
print $eachCurve;
	}
$CurveIndexInter[`size($CurveIndexInter)`] = $TF;
delete $intersectNode;
}
// remenber to 

	return $CurveIndexInter;
}




$StereoCurveZ= `ls -sl`;
string $CurveItemZai = $StereoCurveZ[0];
string $CurveItemZbi = $StereoCurveZ[1];

// $VanishingPointsLinesTempGuides = VanishingCurves({$StereoCurveZ[0]});


global string $PlaneCurveS[];
string $LayerCurvesRangeA[];
$LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;
CurvesToPlane($LayerCurvesRangeA);
select -r $PlaneCurveS;

float $interVecA[];
float $interVecB[];
int $NodeCurveIndex[] = CreateCrvInterTF($CurveItemZai, $PlaneCurveS,0,0.001,$interVecA, $interVecB);
print $NodeCurveIndex;



print $TwoCurveA;
 $intersectCURVEiA = `listRelatives -children  $TwoCurveA[0]`;
 $intersectCURVEiB = `listRelatives -children  $TwoCurveA[1]`;

///
string $curveIntersectZ="";
$curveIntersectZ = `curveIntersect -ch 0 -tolerance 0.00001 $CurveItemZai $CurveItemZbi`;
$curveIntersectZ = `curveIntersect -ch 0 -tolerance 0.00001 $TwoCurveA[0] $TwoCurveA[1]`;
string $buffer[];
$numTokens = `tokenize $curveIntersectZ " "  $buffer`;
print $buffer;
string $param = eval("paramLocator "+ $TwoCurveA[1] + ".u[" + $buffer[7] + "]");
        float $intersectposA[];	
$intersectposA = `pointPosition -w  $param`;
Loc $intersectposA;


///

string $paramANDCurve[];
$paramANDCurve  = `paramToCurvePts2({$param})`;
delete $param;
string $curvesZ[];
$curvesZ = `detachCurve -ch 1 -cos on -rpo 1  $paramANDCurve`;

print $NodeCurveA;
print $NodeCurveA;

              proc float[] NewFloatOrderWithIndexKey(int $IndexTrack[], float $NewFloat[]){
float $newOrderVec[];
for($eachV in $IndexTrack){
$newOrderVec[`size($newOrderVec)`] = $NewFloat[$eachV];
}
return $newOrderVec;
}


select -r Planecurve12 ;
select -r curve69 ;

	string $intersectNode = `createNode curveIntersect`;
setAttr ($intersectNode + ".tolerance") 0.001;
	connectAttr ("curve69" + ".worldSpace") ($intersectNode + ".inputCurve1");
	connectAttr ("Planecurve12" + ".worldSpace") ($intersectNode + ".inputCurve2");
	setAttr ($intersectNode + ".useDirection") 0; 
	$intersectionsA = `getAttr ($intersectNode + ".parameter2")`;
 $param = eval("paramLocator "+"Planecurve12"+".u["+$intersectionsA[0]+"]");

*/

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

proc int [] CreateCrvInterTF( string $crv1, string $Allcrv2[],
	int $useDir, float $tolerance,
	string $intersections1[])
{

int $TF=0;
	// Create the intersect node
int $CurveIndexInter[];
float $intersectionsA[];	
float $intersections1A[];	

int $COuntN=0;	
for($eachCurve in $Allcrv2){
	string $intersectNode = `createNode curveIntersect`;
//listAttr $intersectNode;
	setAttr ($intersectNode + ".tolerance") $tolerance;
	connectAttr ($crv1 + ".worldSpace") ($intersectNode + ".inputCurve1");
	connectAttr ($eachCurve + ".worldSpace") ($intersectNode + ".inputCurve2");
	setAttr ($intersectNode + ".useDirection") $useDir; 
	$intersectionsA = `getAttr ($intersectNode + ".parameter1")`;
	int $numIparms = size($intersectionsA);
	if( $numIparms == 0 ) {
	$TF=0; 
	} else {
		$TF=1;
$intersections1A = `getAttr ($intersectNode + ".parameter2")`;
print $intersections1A;
string $FloatSTRING[] = FloatArrayToStringArray($intersections1A);
string $Ax = stringArrayToString($FloatSTRING, " ");
/*
$intersections1A = `getAttr ($intersectNode + ".parameter2")`;
print $intersections1A;
string $FloatSTRING[] = FloatArrayToStringArray($intersections1A);
string $Axi = stringArrayToString($FloatSTRING, " ");
$Ax += (" "+$Axi);
*/
$intersections1[`size($intersections1)`] = $Ax;
//AppendFloatArray($intersections1,$intersections1A);
//print $eachCurve;
$CurveIndexInter[`size($CurveIndexInter)`] = $COuntN;
	}

delete $intersectNode;
$COuntN++;
}
// remenber to 

	return $CurveIndexInter;
}

proc int [] FindEqualVec(vector $VectorA[], vector $Vec){
int $CountN=0;
int $foundN[];
int $CombA;
for($eachMvec in $VectorA){
$CombA = PointsEquivalentTol ($eachMvec, $Vec);
if($CombA ==3){
$foundN[`size($foundN)`]= $CountN;
}
$CountN++;

}

return $foundN;
}

proc AppendIntArray(int $ExistingInt[],int $AddtoExistingInt[]){
for($eachInt in $AddtoExistingInt){
$ExistingInt[`size($ExistingInt)`]= $eachInt;
}

}

proc AppendFloatArray(float $ExistingF[],float $AddtoExistingF[]){
float $eachFloat;
for($eachFloat in $AddtoExistingF){
$ExistingF[`size($ExistingF)`]= $eachFloat;
}

}

proc float [] DistanceSortStereoCrv(float $distToCurveE_A[], vector $LocCurveEndsVec3D[], vector $IntersectEnds_Ai, int $New_AllLocs_AI[] , float $Distance_A){ 
		 $distToCurveE_A = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ai);
		int $AllLocsi[] = CreateIntIndex(`size($LocCurveEndsVec3D)`);
		string $AllLocs_String[] = IntArrayToStringArray($AllLocsi);
		string $EmptyStringNewOrderA[];
		float $newOrdersZA[] = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
		$EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
		int $New_AllLocs_A[];
		$New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
		int $Near_index_A = $New_AllLocs_A[0];
		 $Distance_A = $distToCurveE_A[$Near_index_A];
		float $Found_pt_A[] = $LocCurveEndsVec3D[$Near_index_A];		 
$New_AllLocs_AI = $New_AllLocs_A;
return $Found_pt_A;
}

// clear $StereoCurveZ;

global string $PlaneCurveS[];
/*

$StereoCurveZ= `ls -sl`;
string $CurveItemZai = $StereoCurveZ[0];
string $CurveItemZbi = $StereoCurveZ[1];


*/












////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


proc int isCurveEndAtZY(vector $EndVectors[]){
float $ThreeFs[];
int $Number =0;
for($eachVec in $EndVectors){
$ThreeFs = $eachVec;
if($ThreeFs[0] == 0){
$Number++;
}
}
return $Number;
}

//CUT CURVE

/*



		
		if((fmod($iiz, 12))== 2){
			curve2points($PositionsZ_B[$iiz], $Intersect_A[`size($Intersect_A)`-1]);
			$CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[0]);
			$AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
			PAUSE;
			curve2points($VecPtsMirrorA[$iiz], $Intersect_A[`size($Intersect_A)`-1]);
			$CirTemp = `ls -sl`;SetItemColorString ($CirTemp[0], $colori[1]);
			$AllCirTemp[`size($AllCirTemp)`] = $CirTemp[0];
			PAUSE;
		}









						if($AddAB==1){

//START of one End Intersect
//START of one End Intersect


if($triggerNoTransA==1){
$New_AllLocs_AB = $New_AllLocs_A;
$distToCurveE_AB = $distToCurveE_A;
}
if($triggerNoTransB==1){
$New_AllLocs_AB = $New_AllLocs_B;
$distToCurveE_AB = $distToCurveE_B;
}


string $LayerCurvesRangeA[];
$LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;
$ExpandedString = `sort $ExpandedString`;
string $SortedRangeCrv[];
$SortedRangeCrv = `sort $LayerCurvesRangeA`;
CurvesToPlane($SortedRangeCrv);

float $OffsetTol = 1.0005;
float $Distance_Aii;
int $CollectN_index[];
clear $CollectN_index;
string $newNames;

// index pair of Locs and Curves   $TrackAllExisting3DCrv

int $COLLECT_INDEX[];
int $COLLECTN_INDEX[];
int $COLLECT_Wanted_INDEX[];
clear $COLLECT_INDEX;
clear $COLLECTN_INDEX;
clear $COLLECT_Wanted_INDEX;

//print $New_AllLocs_AB;
//print $distToCurveE_AB;
//print $distToCurveE_AB[$New_AllLocs_AB[0]];

for($eachIndex in $New_AllLocs_AB){

$Distance_Aii = $distToCurveE_AB[$eachIndex];
			if($Distance_Aii<=$OffsetTol){
//print $eachIndex;
$CollectN_index[`size($CollectN_index)`] =  $eachIndex;
$COLLECT_INDEX[`size($COLLECT_INDEX)`] = $TrackAllExisting3DCrv[$eachIndex];
}else{ 
$COLLECT_Wanted_INDEX[`size($COLLECT_Wanted_INDEX)`] = $TrackAllExisting3DCrv[$eachIndex];}
}

//print $CollectN_index;
//print $queryLocCurveEnds3D;
//print $ExpandedString;
//print $TrackAllExisting3DCrv;
//print $SortedRangeCrv;
//print $CollectN_index
// print size($queryLocCurveEnds3D);
// print $COLLECT_INDEX;
// print $COLLECT_Wanted_INDEX;
// print $ExpandedString;
//print $COLLECT_Wanted_INDEX;

string $ExpandedStringi[];
clear $ExpandedStringi;
string $ExpandedStringiS[];
clear $ExpandedStringiS;
int $Cni=0;
for($eachIntCCi in $COLLECT_Wanted_INDEX){
$ExpandedStringi[$Cni] = $SortedRangeCrv[$eachIntCCi];
$ExpandedStringiS[$Cni] = $PlaneCurveS[$eachIntCCi];
$Cni++;
}

// print $ExpandedStringi;

string $ExpandedStringii[];
clear $ExpandedStringii;
string $ExpandedStringiiS[];
clear $ExpandedStringiiS;
int $Cnii=0;
for($eachIntCCii in $COLLECT_INDEX){
$ExpandedStringii[$Cnii] = $SortedRangeCrv[$eachIntCCii];
$ExpandedStringiiS[$Cnii] = $PlaneCurveS[$eachIntCCii];
$Cnii++;
}
// print $ExpandedStringii;
// print $COLLECT_INDEX;



// PROBLEM what if the curve that is draw interesects the curve its end is attached to?.... can fix later if needed

  string $diff[] = stringArrayRemoveDuplicates($ExpandedStringi);
$diff = stringArrayRemoveExact($ExpandedStringii, $diff);

  string $diffS[] = stringArrayRemoveDuplicates($ExpandedStringiS);
$diffS = stringArrayRemoveExact($ExpandedStringiiS, $diffS);

//select -r $ExpandedStringii;
//select -r $diffS;
//select -r $diff;
//PAUSE;
// print $CollectN_index;
// print $COLLECT_INDEX;


float $VEcF[];
vector $LocSMirror[];
clear $LocSMirror;
string $newNames;
for($eachIndex in $CollectN_index){
 $VEcF = $LocCurveEndsVec3D[$eachIndex];
$VEcF[0] = $VEcF[0]*-1.0;
$LocSMirror[`size($LocSMirror)`] = FloatToVec($VEcF);
}
//////////////////////////////////////////////////////
//print $LocSMirror;
// Loc $LocSMirror[0];


int $AllM[];
 int $ExistingIntA[];
clear $AllM;
clear $ExistingIntA;
for($eachFvec in $LocSMirror){
$AllM = FindEqualVec($LocCurveEndsVec3D, $eachFvec);
if(`size($AllM)`>0){
AppendIntArray($ExistingIntA,$AllM);}
clear $AllM;
}


//print $ExistingIntA;
string $arrayCurvesNearABM[];
clear $arrayCurvesNearABM;
string $arrayCurvesNearS[];
clear $arrayCurvesNearS;

int $COLLECT_INDEX_M[];
clear $COLLECT_INDEX_M;
int $eachIntE;
for($eachIntE in $ExistingIntA){
$arrayCurvesNearABM[`size($arrayCurvesNearABM)`] = $ExpandedString[$eachIntE];
$arrayCurvesNearS[`size($arrayCurvesNearS)`] = $PlaneCurveS[$TrackAllExisting3DCrv[$eachIntE]];
$COLLECT_INDEX_M[`size($COLLECT_INDEX_M)`] = $TrackAllExisting3DCrv[$eachIntE];
}
//print $TrackAllExisting3DCrv;
//print $arrayCurvesNearS;
//print $arrayCurvesNearABM;
//print $COLLECT_INDEX_M;
//print $TrackAllExisting3DCrv;
//select -r $arrayCurvesNearABM;

string $ExpandedStringiim[];
clear $ExpandedStringiim;
int $Cniim=0;
for($eachIntCCiim in $COLLECT_INDEX_M){
$ExpandedStringiim[$Cniim] = $SortedRangeCrv[$eachIntCCiim];
$Cniim++;
}
//print $ExpandedStringiim;
//print $ExpandedString;

  string $diffB[] = stringArrayRemoveExact($arrayCurvesNearABM, $diff);

  string $diffB_s[] = stringArrayRemoveExact($arrayCurvesNearS, $diffS);

//select -r $diffB;
//select -r $diffB_s;
//PAUSE;

//////////////////////////////////////////////////////

	string $interVecAx[];
	clear $interVecAx;
	int $NodeCurveIndex[];
	clear $NodeCurveIndex;
$NodeCurveIndex = CreateCrvInterTF($CurveItemZai, $diffB_s,0,0.001,$interVecAx);

//print $interVecAx;
// select -r $diffB[$NodeCurveIndex[0]];
//PAUSE; PAUSE;
//print $NodeCurveIndex;
//print $interVecAx;

//select -r $CurveItemZai;


	string $interVecAy[];
	clear $interVecAy;
	int $NodeCurveIndexi[];
	clear $NodeCurveIndexi;
$NodeCurveIndexi = CreateCrvInterTF($CurveItemZbi, $diffB_s,0,0.001,$interVecAy);
//print $NodeCurveIndexi;
// select -r $diffB[$NodeCurveIndexi[0]];
//PAUSE; PAUSE;
//////////////////////////////////////////////////////

if((`size($NodeCurveIndexi)` >0 )&&(`size($NodeCurveIndex)` >0 )){ 




float $EveryPara[];
vector $AllNearestVecCA[]; 
string $CURVEiA[];
float $EachPara;
vector $VecPointOnCrv[];
clear $VecPointOnCrv;
float $posA[];
string $param;
int $CountPara =0;
float $ParaFloat[];
int $ParaSize[];
int $CurveSFoundS = `size($NodeCurveIndexi)`;
//print $diffB;
for($EachIndC in $NodeCurveIndexi){

 $CURVEiA = `listRelatives -children  $diffB_s[$EachIndC]`;
$ParaFloat = StringArrayToFloatArray(stringToStringArray($interVecAy[$CountPara], " "));
if($CountPara>0){
$ParaSize[$CountPara] = `size($ParaFloat)`+$ParaSize[$CountPara-1];}
if($CountPara==0){
$ParaSize[$CountPara] = `size($ParaFloat)`;}
for($EachPara in $ParaFloat){

$EveryPara[`size($EveryPara)`] = $EachPara;
 $param = eval("paramLocator "+$CURVEiA[0]+".u["+$EachPara+"]");
        $posA = `pointPosition -w $param`;
//print $posA;
$VecPointOnCrv[`size($VecPointOnCrv)`] = FloatToVec($posA);
delete  $param;
}
$CountPara++;

}


//for($eachVVec in $VecPointOnCrv){
//Loc $eachVVec;
//}

	float $distCA[] = ArrayDistancesVecTofloat($VecPointOnCrv, $UnconnectedEnds[1]);
		int $PointOnCrvIND[] = CreateIntIndex(`size($VecPointOnCrv)`);
		string $PointOnCrv_String[] = IntArrayToStringArray($PointOnCrvIND);
		string $EmptyCA[];
clear $EmptyCA;
		float $newCA[] = SortFloatArrayAndString($distCA, $PointOnCrv_String, $EmptyCA);
		$EmptyCA = ReverseStringArray($EmptyCA);
		int $New_PointOnCrvIND_A[];
		$New_PointOnCrvIND_A = ArrayToIntList($EmptyCA);
int $FOUNDc = $New_PointOnCrvIND_A[0];
float $NearestDistCA = $distCA[$New_PointOnCrvIND_A[0]];
vector $NearestVecCA = $VecPointOnCrv[$New_PointOnCrvIND_A[0]];
//Loc $NearestVecCA;
//PAUSE;
int $WhatCurve;
int $CountWhatCurve=-1;
//print $ParaSize;
for($eachIntPara in $ParaSize){
$CountWhatCurve++;
if(($ParaSize[$CountWhatCurve]-1)>=$FOUNDc){
$WhatCurve=$CountWhatCurve;
break;
}
}

//select -r $diffB_s[$NodeCurveIndexi[$WhatCurve]];
//PAUSE;

//print $interVecAx;

float $EveryParab[];
vector $AllNearestVecCAb[]; 
string $CURVEiAb[];
float $EachParab;
vector $VecPointOnCrvb[];
clear $VecPointOnCrvb;
float $posAb[];
string $paramb;
int $CountParab =0;
float $ParaFloatb[];
int $ParaSizeb[];
int $CurveSFoundSb = `size($NodeCurveIndex)`;
//print $diffB;
for($EachIndCb in $NodeCurveIndex){

 $CURVEiAb = `listRelatives -children  $diffB_s[$EachIndCb]`;
$ParaFloatb = StringArrayToFloatArray(stringToStringArray($interVecAx[$CountParab], " "));
if($CountParab>0){
$ParaSizeb[$CountParab] = `size($ParaFloatb)`+$ParaSizeb[$CountParab-1];}
if($CountParab==0){
$ParaSizeb[$CountParab] = `size($ParaFloatb)`;}
for($EachParab in $ParaFloatb){

$EveryParab[`size($EveryParab)`] = $EachParab;
 $paramb = eval("paramLocator "+$CURVEiAb[0]+".u["+$EachParab+"]");
        $posAb = `pointPosition -w $paramb`;
//print $posAb;
$VecPointOnCrvb[`size($VecPointOnCrvb)`] = FloatToVec($posAb);
delete  $paramb;
}
$CountParab++;

}


// for($eachVVec in $VecPointOnCrvb){
// Loc $eachVVec;
// }

	float $distCAb[] = ArrayDistancesVecTofloat($VecPointOnCrvb, $UnconnectedEnds[0]);
		int $PointOnCrvINDb[] = CreateIntIndex(`size($VecPointOnCrvb)`);
		string $PointOnCrv_Stringb[] = IntArrayToStringArray($PointOnCrvINDb);
		string $EmptyCAb[];
clear $EmptyCAb;
		float $newCAb[] = SortFloatArrayAndString($distCAb, $PointOnCrv_Stringb, $EmptyCAb);
		$EmptyCAb = ReverseStringArray($EmptyCAb);
		int $New_PointOnCrvIND_Ab[];
		$New_PointOnCrvIND_Ab = ArrayToIntList($EmptyCAb);
int $FOUNDcb = $New_PointOnCrvIND_Ab[0];
float $NearestDistCAb = $distCA[$New_PointOnCrvIND_Ab[0]];
vector $NearestVecCAb = $VecPointOnCrvb[$New_PointOnCrvIND_Ab[0]];

//Loc $NearestVecCAb;
//PAUSE;
int $WhatCurveb;
int $CountWhatCurveb=-1;
print $ParaSize;
for($eachIntParab in $ParaSizeb){
$CountWhatCurveb++;
if(($ParaSize[$CountWhatCurve]-1)>=$FOUNDcb){
$WhatCurveb=$CountWhatCurveb;
break;
}
}

//select -r $diffB_s[$NodeCurveIndex[$WhatCurveb]];
//PAUSE;


///////////////////////////////////////////////////////////////////
//select -r $diffB_s[$NodeCurveIndex[$WhatCurveb]];
//PAUSE;
//select -r $diffB[$NodeCurveIndex[$WhatCurveb]];
//PAUSE;
//select -r $diffB_s[$NodeCurveIndexi[$WhatCurve]];
//PAUSE;
//select -r $diffB[$NodeCurveIndexi[$WhatCurve]];
//PAUSE;




string $CurveA = $diffB[$NodeCurveIndexi[$WhatCurve]];
string $CurveB = $diffB[$NodeCurveIndex[$WhatCurveb]];
	//string $newNamesCA = substituteAllString($CurveA, "Plane", "");
	//string $newNamesCB = substituteAllString($CurveB, "Plane", "");
	string $newNamesCA = $CurveA;
	string $newNamesCB = $CurveB;
Loc $NearestVecCA;
Loc $NearestVecCAb;

vector $CUT_CrvMirrorEnds_A[] = VecPtsToZMirrorPts({$NearestVecCAb});
vector $CUT_CrvIntersectEnds_A = FloatToVec (lineIntersectionF($CamPos_A, $NearestVecCA, $CamPos_M, $CUT_CrvMirrorEnds_A[0]));
vector $CUT_CrvIntersectMirrorEnds_A[] = VecPtsToZMirrorPts({$CUT_CrvIntersectEnds_A});


// this places CUT_CrvIntersectEnds_A the 3d ifnferance Points of the two curve intersection points into the assumed curve end vectors
// the trigger signifies the vector that which was not connecting directly to another curve end that which the other end will be attached to
// since the new end of the drawn curve that intersects an existing 3d curve is not drwan with mathmatical percision its intersecting will 
// have a slightly different end
// if have not gone so far as to program a choice between cutting the drawn vs. shifting the end to meet the found 3d intersecting 
// projected on the plane


// float $ParaB = $EveryParab[$FOUNDcb];
// string $selectionItemB = $CurveB + ".u[" + $ParaB + "]";
// string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $selectionItemB`;

    $myCPOC = `createNode closestPointOnCurve`;
      connectAttr ($newNamesCB+".worldSpace")  ($myCPOC+".inCurve");
float $PointBc[] = $CUT_CrvIntersectMirrorEnds_A[0];
float $uParam = `closestPointOnCurve -ip $PointBc[0] $PointBc[1] $PointBc[2] -q -paramU $newNamesCB`;
 $paramZ = eval("paramLocator "+$newNamesCB+".u["+$uParam+"]");
 $paramZA = eval("paramLocator "+$newNamesCA+".u["+$uParam+"]");
delete $myCPOC;


 string $selectionItemB = $CurveB + ".u[" +$uParam+ "]";
 string $selectionItemA = $CurveA + ".u[" +$uParam+ "]";
delete  $paramZ;
delete  $paramZA;
 string $detachCurve1[] = `detachCurve -ch off - replaceOriginal on $selectionItemB`;
 string $detachCurve2[] = `detachCurve -ch off - replaceOriginal on $selectionItemA`;

CurveIndexVecTracking({$detachCurve1[0]});
CurveIndexVecTracking({$detachCurve2[0]});

        float $interposA[];	
$interposA = `pointPosition -w  $paramZ`;
        float $interposB[];	
$interposB = `pointPosition -w  $paramZA`;
vector $VecIntCB,  $VecIntCA;
$VecIntCB = FloatToVec ($interposB);
$VecIntCA = FloatToVec ($interposA);

Loc $CUT_CrvIntersectEnds_A;
Loc $CUT_CrvIntersectMirrorEnds_A[0];

vector $VecCUT_CrvA= FloatToVec (FloatPointsToCamPlane($VecIntCB));
vector $VecCUT_CrvB= FloatToVec (FloatPointsToCamPlane($VecIntCA));

if($triggerNoTransENDA==1){
$VecOnPlaneA[0]= $VecCUT_CrvA;
$VecOnPlaneB[0]= $VecCUT_CrvB;
}else{$VecOnPlaneA[1]= $VecCUT_CrvA;
$VecOnPlaneB[1]= $VecCUT_CrvB;}
 
 //END of one End Intersect
  //END of one End Intersect
   //END of one End Intersect
    //END of one End Intersect
	 //END of one End Intersect

}
}
*/

///CUT CURVE ^





// clear $StereoCurveZ;

/*
		float $distToCurveE_A[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[0]);
		int $AllLocsi[] = CreateIntIndex(`size($LocCurveEndsVec3D)`);
		string $AllLocs_String[] = IntArrayToStringArray($AllLocsi);
		string $EmptyStringNewOrderA[];
		float $newOrdersZA[] = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
		$EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
		int $New_AllLocs_A[];
		$New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
		int $Near_index_A = $New_AllLocs_A[0];
		float $Distance_A = $distToCurveE_A[$Near_index_A];
		float $Found_pt_A[] = $LocCurveEndsVec3D[$Near_index_A];		
		float $newOrdersZAM[] = $Found_pt_A;
		$newOrdersZAM[0] = $Found_pt_A[0] *-1;
	
		float $distToCurveE_B[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_A[1]);		
		string $EmptyStringNewOrderB[];
		float $newOrdersZB[] = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
		$EmptyStringNewOrderB = ReverseStringArray($EmptyStringNewOrderB);
		int $New_AllLocs_B[];
		$New_AllLocs_B = ArrayToIntList($EmptyStringNewOrderB);
		int $Near_index_B = $New_AllLocs_B[0];

		float $Distance_B = $distToCurveE_B[$Near_index_B];
		float $Found_pt_B[] = $LocCurveEndsVec3D[$Near_index_B];
		float $newOrdersZBM[] = $Found_pt_B;
		$newOrdersZBM[0] = $Found_pt_B[0] *-1;


*/



//////////////////////


/*

// if($EulerAngle_B <$EulerAngle_A ){ 
if($BCurEndBiiAdd>$BCDiff){
if($IntIfNearZero==0){
//if( $DistTOEpipol_CurEndA > $DistTOEpipol_CurEndB){
PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
cycleBackgroundColor;
PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE; PAUSE;
	//if($DistTOEpipol_CurEndA > $DistTOEpipol_CurEndB){
PAUSE;
 $IfTrue = FindLineCross( $Vecbv , $Vecbvi );
	if($IfTrue==1){
cycleBackgroundColor;
		//reverseCurve  -ch 0 -rpo 1 -cos on $CurveItemZai;
		//$VecCurEndsa = ReverseVectorArray($VecCurEndsa);
		$PositionsZ_B = ReverseVectorArray($PositionsZ_B);
		// $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
 $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);
	}
 }
//}
}
//}

 if($EulerAngle_B <$EulerAngle_A ){ 
	if($DistTOEpipol_CurEndA > $DistTOEpipol_CurEndB){
		print "Reverse_it";
PAUSE;
makeCurvePointDirectionLength((6), $FloatDirEpipol, $VecCurEndsa[1]); 
PAUSE; PAUSE; 
	}
	if($DistTOEpipol_CurEndA>$DistTOEpipol_CurEndB){
		reverseCurve  -ch 0 -rpo 1 -cos on $CurveItemZai;
	}
	if($DistTOEpipol_CurEndA>$DistTOEpipol_CurEndB){
		$VecCurEndsb = ReverseVectorArray($VecCurEndsb);
		$PositionsZ_B = ReverseVectorArray($PositionsZ_B);
		 $VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
 $VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);
	}
}

*/

////////////////////




proc int  PointsEquivalentTol( float $posA[],  float $posB[]){
int $pX = equivalentTol($posA[0], $posB[0],  0.001);
int $pY = equivalentTol($posA[1], $posB[1],  0.001);
int $pZ = equivalentTol($posA[2], $posB[2],  0.001);
int $addedResults = $pX + $pY + $pZ;
return $addedResults;
}


proc vector ClosestPoint2LineVec(float $DirectionLineF[], float $PointOnLine[], float $PointN[]){
vector $VlocA;
vector $VecLineDiri = PositiveDirectionLine($PointOnLine, $PointN);
vector $VecLineDir = PositiveDir($DirectionLineF);
float $locsA[];

vector $VecLineDirM = $VecLineDiri-$VecLineDir;
//if on line Result: <<1, 1, 1>>  a point on the line and the point in question directions vector Mult// 

float $Addit[] = $VecLineDirM ;
float $AdditR = $Addit[0]+$Addit[1]+$Addit[2];

if($AdditR != 0.0){
		float $MultDirOne[] = multiplyFloat(1.0, $DirectionLineF);
	float $AddMultF[] = AddFloats($PointOnLine, $MultDirOne);
float $FDirNorA[] = Normal3Points($PointOnLine, $AddMultF, $PointN);
float $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
		float $MultDirMx[] = multiplyFloat($DistToLineSTart, $FDirNorA);
	float $AddMultMiiFx[] = AddFloats($PointOnLine, $MultDirMx);
float $FDirNorB[] = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);
		float $MultDirMxz[] = multiplyFloat($DistToLineSTart,  $FDirNorB);
	float $AddMultMiiFxz[] = AddFloats($PointOnLine, $MultDirMxz);
 $locsA = lineIntersection($PointN, $FDirNorB, $PointOnLine, $DirectionLineF);
 
 $VlocA = <<$locsA[0],$locsA[1],$locsA[2]>>;
}else{$VlocA = FloatToVec($PointN);}

return $VlocA;
}

proc vector PointDirTang2LineVec(float $DirectionLineF[], float $PointOnLine[], float $PointN[]){
		float $MultDirOne[] = multiplyFloat(1.0, $DirectionLineF);
	float $AddMultF[] = AddFloats($PointOnLine, $MultDirOne);
float $FDirNorA[] = Normal3Points($PointOnLine, $AddMultF, $PointN);
float $DistToLineSTart = distance2Pts( $PointN , $PointOnLine);
		float $MultDirMx[] = multiplyFloat($DistToLineSTart, $FDirNorA);
	float $AddMultMiiFx[] = AddFloats($PointOnLine, $MultDirMx);
float $FDirNorB[] = Normal3Points($PointOnLine, $AddMultMiiFx, $AddMultF);

vector $VlocA = <<$FDirNorB[0],$FDirNorB[1],$FDirNorB[2]>>;

return $VlocA;
}

/*
float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
float $CircleCenter[] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureCenter")`;

//-curvatureCenter

  vector $tan;
  vector $norm;

  vector $bi;
       $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
                 << ($norm.x), ($norm.y), ($norm.z) >>`;

*/

//SmoothCurvature3(6);
//attachCurveTangent( 1 );

          proc string[] SmoothCurvature3(float $curveM ){
string $curves[] = `ls -sl`;
string $myCurve = $curves[0];
//rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
//smoothCurve -ch 0 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 4 ); 
 string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`; 
$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] +  ".translate")`;
	float $step = $numEPrealNum2;  
	$curve = "curve -d 3";
	float $curveMin = $curveM;
int $FindSteps;

$curve = IteratCurve( $step, $paramlocatorpointOnCurvex, $curveMin, $FindSteps);

 string $Newcurvez = `eval($curve)`;
 
//rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $Newcurvez;
float $numLength = (`arclen $Newcurvez`) +1; 
int $StepZNum = $numLength;
delete $paramlocatorpointOnCurvex $spaceLocatorB; 
delete $curves;
// rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s $StepZNum -d 3 -tol 0.001  $Newcurvez;
string $Newcurve[] = {$Newcurvez};
rename $Newcurve $curves;  
$Newcurve = {$curves[0]};
return $Newcurve; 
}


proc string IteratCurve(float $step, string $paramlocatorpointOnCurvex, float $curveMin, int $FindSteps){

int $MasterCount= 0;
$curve = "curve -d 3";

  vector $tan;
  vector $norm;
  vector $bi;
float $CircleCenter[];

string $circlesZ[];

while ($FindSteps < 4){
$curve = "curve -d 3";

int $Par = 0;
int $a;
int $ii = 0;	
int $CountSteps;
float $values[];
float $CurvatureRadi;
  for($a = 0; $a <= $step;$a++){
$ii = $ii + 1;
  	$t =  $a/$step;
 	$Par = ($a/$step);
	setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
  	 $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
	 $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
         $CircleCenter = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureCenter")`;
	$tan = `getAttr  ($paramlocatorpointOnCurvex +  ".normal")`;
	 $norm = `getAttr  ($paramlocatorpointOnCurvex +  ".tangent")`;
       $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
                 << ($norm.x), ($norm.y), ($norm.z) >>`;


		if ( $CurvatureRadi <=  $curveMin){   
	$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
if((fmod($CountSteps, 12))== 2){
$circlesZ[`size($circlesZ)`] = Circles_Direction($CircleCenter, $bi, $CurvatureRadi);
}
$CountSteps++;
	}
if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
if((fmod($CountSteps, 12))== 2){
$circlesZ[`size($circlesZ)`] =Circles_Direction($CircleCenter, $bi, $CurvatureRadi);
}
$CountSteps++;
}
if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
if((fmod($CountSteps, 12))== 2){
$circlesZ[`size($circlesZ)`] =Circles_Direction($CircleCenter, $bi, $CurvatureRadi);
}
$CountSteps++;
}
}
$FindSteps = $CountSteps;
if($FindSteps < 4){$curveMin += 8.0; $curve = "curve -d 3"; delete $circlesZ;}
if($MasterCount== 4){break;}
$MasterCount++;

}

return $curve;
}

proc string IteratCurve(float $step, string $paramlocatorpointOnCurvex, float $curveMin, int $FindSteps){

int $MasterCount= 0;
$curve = "curve -d 3";

  vector $tan;
  vector $norm;
  vector $bi;

while ($FindSteps < 4){
$curve = "curve -d 3";

int $Par = 0;
int $a;
int $ii = 0;	
int $CountSteps;
float $values[];
float $CurvatureRadi;
  for($a = 0; $a <= $step;$a++){
$ii = $ii + 1;
  	$t =  $a/$step;
 	$Par = ($a/$step);
	setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
  	 $values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
	 $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
  
		if ( $CurvatureRadi <=  $curveMin){   
	$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];

$CountSteps++;
	}
if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];

$CountSteps++;
}
if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];

$CountSteps++;
}
}
$FindSteps = $CountSteps;
if($FindSteps < 10){$curveMin += 18.0; $curve = "curve -d 3";  }
if($MasterCount== 4){break;}
$MasterCount++;

}

return $curve;
}

proc vector [] makeCurvePointDirectionLengthN(float $Length, float $Direction[], float $posA[]){
float $MultDirA[] = multiplyFloat(($Length/2.0),  $Direction);
float $DirectionN[];
$DirectionN = multiplyFloatArray(-1.0,$Direction);
float $MultDirB[] = multiplyFloat(($Length/2.0),  $DirectionN);
float $FDirA[] = AddFloats($posA, $MultDirA);
float $FDirB[] = AddFloats($posA, $MultDirB);
vector $Avec[];
$Avec[0]= FloatToVec($FDirA);
$Avec[1]= FloatToVec($FDirB);
string $CurveBetween;
$CurveBetween = curve2points($FDirA,  $FDirB);
return $Avec;
}

proc vector [] LockEndsAverageCurveVec( vector $newVec[]){

int $range, $TotalS, $indexState, $indexLeft, $indexRight, $countS, $Xs, $indexLeftS[], $indexRightS[];
	$range = 3;
	$TotalS = `size($newVec)`;
	$indexState = 0;
vector $AVvects[];
vector $Aver;
while($indexState<$TotalS){	
 $countS=1;
 $Xs=0;
while($countS<$range){
	$indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
	$indexRight = fmod(($indexState + $countS),$TotalS);	
$indexLeftS[$Xs] = $indexLeft;
$indexRightS[$Xs]= $indexRight;
$countS++;
$Xs++;
}

if(($indexState<=2)||($indexState>=($TotalS-3))){
if($indexState<=2){
$Aver = (( ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec[$indexState])/2.5;
$AVvects[$indexState] = $Aver;
}
if($indexState>=($TotalS-3)){
$Aver = (( ($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0))+$newVec[$indexState])/2.5;
$AVvects[$indexState] = $Aver;
}
}else{
$Aver = ((($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0) + ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec [$indexState])/4.0;
$AVvects[$indexState] = $Aver;
}
clear $indexLeftS;
clear $indexRightS;
$indexState++;
}
return $AVvects;
}

global int $SortDistanceIntG;
proc vector [] CurvatureUtility(string $curvesZ, int $NumberofSteps, float $curvature[], int $C[], float $TotalCA){
global int $SortDistanceIntG;
float $step = $NumberofSteps;
vector $CurveVectors[];
	string $myCurve = $curvesZ;
	int $ii = 0;
		float $a ,$t, $TotalCAX, $values[];
float $CRVRadi[];	
$TotalCAX =0;
$t=0.0;
		string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;


	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );

	float $CIrceP[];
	$CIrceP = `xform -q -ws -t $curvesZ`;
	 float $DistanceS[];
	for($a = 0.0; $t < $numEPrealNum;$a++){

		$t =  $a/$step;		
		setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
		$values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
		$CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
 $CRVRadi[$ii] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;



 $DistanceS[$ii] = distance2Pts($values,$CIrceP);

$ii++;
}
 int $NewIndexN[];
$NewIndexN = SortNumbersIntIndex($DistanceS);
$SortDistanceIntG = $NewIndexN[0];
	delete $paramlocatorpointOnCurvex;

for($eachCURVA in $CRVRadi){
$TotalCAX +=  $eachCURVA;
}
$TotalCA = $TotalCAX;
$curvature = $CRVRadi;
return $CurveVectors;
}

proc vector [] AverageCurveVec( vector $newVec[]){

int $range, $TotalS, $indexState, $indexLeft, $indexRight, $countS, $Xs, $indexLeftS[], $indexRightS[];
	$range = 3;
	$TotalS = `size($newVec)`;
	$indexState = 0;
vector $AVvects[];
vector $Aver;
while($indexState<$TotalS){
	
 $countS=1;
 $Xs=0;
while($countS<$range){
	$indexLeft = fmod(($TotalS+($indexState - $countS)),$TotalS);
	$indexRight = fmod(($indexState + $countS),$TotalS);	
$indexLeftS[$Xs] = $indexLeft;
$indexRightS[$Xs]= $indexRight;
$countS++;
$Xs++;
}
$Aver = ((($newVec[$indexLeftS[0]]+$newVec[$indexLeftS[1]]/2.0) + ($newVec[$indexRightS[0]]+$newVec[$indexRightS[1]]/2.0))+$newVec [$indexState])/4.0;
$AVvects[$indexState] = $Aver;
clear $indexLeftS;
clear $indexRightS;
$indexState++;
}
return $AVvects;
}


proc string VecArrayToCurveB(vector $FixVec[]){
int $sIZes = `size $FixVec `;
int $NUmers[] = CreateIntIndex($sIZes);
string $K = "";
for ($eachN in $NUmers){
$K += "\-k"+" "+$eachN+" ";
}
$K += "\-k"+" "+ $sIZes+" ";
 $sIZes++;
$K += "\-k"+" "+ $sIZes+" ";
string $curve = "curve -d 3";
for ($eachVeCx in $FixVec){
float $valuesBi[] = $eachVeCx;
$curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
}
string $Newcurvez = `eval($curve)`;
return $Newcurvez;
}


proc vector TwoVecsOrFloats(float $p1p2[], float $p1p3[]){
	vector $Ui = FloatToVec($p1p2);
	vector $Vi = FloatToVec($p1p3);
	vector $VEcLine = << ($Ui.x - $Vi.x), ($Ui.y - $Vi.y),($Ui.z - $Vi.z)>>;
	return $VEcLine;
}

proc int MostRightClockWiseInt ( vector $Vecs[], int $Two[]){
	string $ThreePoints[] = { "0", "1", "2"};
	float $point1[] =  FloatToVec($Vecs[0]);
	float $point2[] =  FloatToVec($Vecs[1]);
	float $point3[] =  FloatToVec($Vecs[2]);
	vector $U1 = TwoVecsOrFloats($point2, $point1);
	vector $V1 = TwoVecsOrFloats($point3, $point1);
	vector $U2 = TwoVecsOrFloats($point3, $point1);
	vector $V2 = TwoVecsOrFloats($point2, $point1);
	vector $U3 = TwoVecsOrFloats($point1, $point3);
	vector $V3 = TwoVecsOrFloats($point2, $point3);
	vector $normalV[];
	clear $normalV;
	$normalV[0] = FloatToVec( crossProduct( $U1, $V1, 0, 1 ) );
	$normalV[1] = FloatToVec( crossProduct( $U2, $V2, 0, 1 ) );
	float $normalA[] = `unit ($normalV[0])`;
	float $normalB[] = `unit ($normalV[1])`;
	float $normalAAdd = $normalA[0] + $normalA[1];
	float $normalAAdd2 = $normalB[0] + $normalB[1];
	int $TwoNew[];

	if( $normalAAdd< $normalAAdd2){
		$TwoNew ={$Two[1], $Two[0]};
		
	}else{ 
		$TwoNew ={$Two[0], $Two[1]};
		
	}
	//$Two = $TwoNew;
	return $TwoNew[0];
}

proc AppendFloat(float $A[] , float $B[]){
for($eachF in $B){
$A[`size($A)`]= $eachF;
}
} 

proc float [] CreateIntIndexF(int $ArraySize, float $Fstep){
int $iNdex = 0;
float $FArrayInex[];
float $AddF =0;
while($iNdex < $ArraySize){
$AddF+= $Fstep;
$FArrayInex[$iNdex] = $AddF;
$iNdex++;
}
return $FArrayInex;
}

proc vector [] calculateEllipseCurve(vector $FixVeci[], float $steps){

// $a == Major Axis
// $b == Minor Axis

float $x,$y,$a,$b,$angle,$steps;



 	$x=8;
	$y=8;
float $z= 8;
float $Lengthi = distance2Pts ($FixVeci[0], $FixVeci[1]);
float $MidPt[] = MidPoint($FixVeci[0], $FixVeci[1]);
float $FloatDirMajor[] = DirectionFN($FixVeci[0], $FixVeci[1]);

float $Lengthiii = distance2Pts ($MidPt, $FixVeci[2]);
float $FDirNorAi[] = Normal3Points($FixVeci[0], $FixVeci[1], $FixVeci[2]);
vector $DirNormi = FloatToVec ($FDirNorAi);
float $normal[3];
	$normal = crossProduct( $FloatDirMajor, $FDirNorAi, 0, 0 );

  matrix $mI[4][4] = << 1.0, 0.0, 0.0, 0.0;
                       0.0, 1.0, 0.0, 0.0;
                       0.0, 0.0, 1.0, 0.0;
                       0.0, 0.0, 0.0, 1.0 >>;
  vector $norm = FloatToVec($FloatDirMajor);
  vector $bi = FloatToVec($FDirNorAi);
  vector $tan = FloatToVec( $normal);
  vector $MidVec = FloatToVec( $MidPt);
float $LENGTH = $Lengthi/2.0;
// length times direction add to Point to move it??
vector $ABC[];
$ABC[0] = $FixVeci[0];
$ABC[1] = ($tan * $LENGTH)+ $MidVec;
$ABC[2] = $FixVeci[1];

float $C_radius[] = Circle3PtsM($ABC[0], $ABC[1], $ABC[2]);
float $ObjsCirclesRad =  $C_radius[3];

vector $VecLineDir = PositiveDirectionLine($ABC[1],$MidVec);
float $PointN[] = ClosestPoint2Line($VecLineDir, $FixVeci[2], $MidVec);
float $Di = distance2Pts( $MidVec , $PointN);
float $DiffL = ($ObjsCirclesRad-$Di)*2.0;

int $returnValue=1;
if($Di<$ObjsCirclesRad){
$returnValue =1;}
if($Di==$ObjsCirclesRad){
$returnValue =0;}
if($Di>$ObjsCirclesRad){
$returnValue =-1;}

 float $PointNii[];
 float $PointNiii[];
 float $PointNiiiB[];

if($returnValue==1){
float $FloatDirXn[] = DirectionFN( $MidVec, $FixVeci[2]);
 $PointNii = MultLenToDirAddToPoint($Di, DirectionFN( $MidVec, $PointN), $PointN);
float $DistAddiR2 = $Di*2.0;
float $HightD = sqrt (abs ((`pow $Di 2`) - (`pow $ObjsCirclesRad 2`)));
 $PointNiii = MultLenToDirAddToPoint($HightD,($tan), $PointN);
 $PointNiiiB = MultLenToDirAddToPoint($HightD,($tan*-1), $PointN);
}

float $DiX = distance2Pts( $FixVeci[2] , $PointNiii);
float $DiY = distance2Pts( $FixVeci[2] , $PointNiiiB);
float $ClosestPoint[];
if($DiX<$DiY){
$ClosestPoint=$PointNiii;
}
if($DiX>$DiY){
$ClosestPoint=$PointNiiiB;
}

float $RadiOfOuter= distance2Pts($MidVec, $ClosestPoint);
float $DirRaytoIntersectC[];
 $DirRaytoIntersectC  = DirectionFN($MidVec, $ClosestPoint);
float $CircleRayPointN[];
 $CircleRayPointN = ClosestPoint2Line($DirRaytoIntersectC, $MidVec, $FixVeci[2]);
float $SecondIntersectCsmall[] = lineIntersection( $MidVec, $DirRaytoIntersectC, $FixVeci[2], $norm);


float $RadiOfInnerC= distance2Pts($MidVec,$SecondIntersectCsmall);

    $mI = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
            ($bi.x),   ($bi.y),   ($bi.z),   0.0;     // Y axis
            ($tan.x),  ($tan.y),  ($tan.z),  0.0;     // Z axis
            $MidPt[0], $MidPt[1], $MidPt[2],     1.0 >>;  // Position
float $MatrizFloati[] = MatrixToFloat($mI);
float $x=$MidPt[0];
float $y=$MidPt[2];
float $z= $MidPt[1];
  float $a=$Lengthi/2.0;

////////////////////////
float $b= $RadiOfInnerC;
///////////////////////////

 float $angle= 0;
 float $points[];  

vector $DirecOfPointABi = FloatToVec ( DirectionFN($FixVeci[0], $FixVeci[1]));
string $curvei = "curve -d 3";
vector $VecH[];
clear $VecH;
int $vi =0;
float $Pi = 3.1415926535;
float $points[];
float $newLocP[]; 

float $VecAngle = VAnglesofThreeVec($MidPt, $FixVeci[1], $FixVeci[2]);

   float $beta = `deg_to_rad ($angle)`; 
   float $sinbeta =  sin($beta);
   float $cosbeta =  cos($beta);
float $valuesiiA[] ={$x,0.0,$y} ;
float $valuesiAi[] ={$x, 0, $y} ;
float $valuesiAi[] ={$x, 0, $y} ;
float $i;

float $bx,$by;

  for ( $i = 0; $i < 360; $i += 360.0/$steps) 
  {
    $alpha = $i * ( $Pi / 180.00) ; 
     $sinalpha =  sin($alpha);
     $cosalpha =  cos($alpha); 

     float $X = $x + ($a * $cosalpha * $cosbeta - $b * $sinalpha * $sinbeta);
     float $Y = $y + ($a * $cosalpha * $sinbeta + $b * $sinalpha * $cosbeta);

float $valuesA[] ={$X, 0, $Y} ;
float $MidTwoDtoElPoint = distance2Pts ($valuesiiA, $valuesA);
float $FloatDirEpoint[] = DirectionFN($valuesiiA, $valuesA);
$newLocP = pointMatrixMult(  $FloatDirEpoint, $MatrizFloati );
float $MultDii[] = multiplyFloat($MidTwoDtoElPoint, $newLocP);
float $AddMepi[] = AddFloats($MidPt, $MultDii);  	
vector $aV = FloatToVec($valuesA);
vector $bV = FloatToVec($valuesiAi);

 $VecH[`size($VecH)`]= `FloatToVec $AddMepi`;

$curvei += " -p "+$AddMepi[0]+" "+$AddMepi[1]+" "+$AddMepi[2];
   }

   eval($curvei);
ResetTransEachSL;
  return $VecH;
}

global int $TrackDirectionChange;

proc vector [] CurvatureIsCircleData(string $curvesZ, int $NumberofSteps, float $angleZ[], float $TotalDeg[], int $low, float $C[], float $Ang[]){

	string $myCurve = $curvesZ;
	//smoothCurve -ch 0 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
		vector $PositionsZ_A[];
		clear $PositionsZ_A;
		$PositionsZ_A = VecCurveEps($curvesZ);

float $AverageVecCurve[] =  AverageVectorPoint($PositionsZ_A);

	float $CIrceP[];
	$CIrceP = `xform -q -ws -t $myCurve`;
$AverageVecCurve =$CIrceP;
//Loc $AverageVecCurve;
vector $VecAverage = FloatToVec($AverageVecCurve);


	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 4 ); 

	$numEPrealNum2 = $NumberofSteps;
string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -top 1 -p $myCurve`;
vector $SharpValuesTan[];
$SharpValuesTan[0] = $PositionsZ_A[0];
float $CN[];
float $step = $NumberofSteps;  
int $Par = 0;
int $a;
float $StepCycle =0;
int $ii = 0;
int $iX = 0;
int $Trigger= 0;
int $Lowest = 11110;
int $Past = 0;
float $pastA =0.0;
float $t, $EachAngle, $angleTii, $allAngi[], $NumbersA[], $values[], $valuesXYZ[];		
vector $CurveVectors[];
vector $FlushVectors[];
float $AddAngles=0.0;
 $allAngi[`size($allAngi)`] = 0;
float  $allAngiX[];
 $allAngiX[`size($allAngiX)`] = 0;	
int $TFmostR, $TFmostRT, $TwoZeroOne[], $TwoZeroOneT[];
$TwoZeroOne = {0,1};	
$TwoZeroOneT = {0,1};
float $Ct[];
 $Ct[0] = 0.0;	
$C[0] = 0.0;
$CN[0] = 0;
int $TF = 0;
int $CountEVEN = 0;
int $Even_Odd;
float $DistancesCycle[];
float $CurvatureRadi[];
vector $valuesTan[];
vector $valuesTanSpace[];
vector $valuesTanPastSpace;
vector $valuesTanPast;
vector $DeepPastTan;
vector $DeepPast;
float $AngleB[];
vector $threeVecsT[];
vector $CurrentVecT;
global int $TrackDirectionChange;
$TrackDirectionChange=0;

vector $PresentV, $PastV, $threeVecs[];
  for($a = 0; $a <= $step;$a++){

  	$t =  $a/$step;
 	$Par = ($a/$step);

	setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
	$values  = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
	$valuesTan[$ii]  = `getAttr  ($paramlocatorpointOnCurvex + ".tangent")`;

	$CurvatureRadi[$ii] = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
	$valuesXYZ  = {$values[0], $values[1], $values[2]};
	$CurveVectors[$ii] = <<$values[0], $values[1], $values[2]>>;
	$valuesTanSpace[$ii] = $CurveVectors[$ii]+$valuesTan[$ii];

$FlushVectors[`size($FlushVectors)`] = <<$values[0], $values[1], $values[2]>>;
$PresentV = FloatToVec($values);

// creat a vator array thatclears every time it passes 360 deg.. so the last few steps are recored..
// then take the last angle find the persect it is of 360  divide that by the number of septs then use that as a float step

 if($ii>0){$Past=$ii-1;

 $EachAngle = VAnglesofThreeVec($VecAverage, $PositionsZ_A[0], $CurveVectors[$ii]);
 $threeVecs[0] = $PositionsZ_A[0]; $threeVecs[1] = $VecAverage; $threeVecs[2] = $PresentV;
 $TFmostR = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);

// for copy past  $valuesTanPastSpace = $valuesTanSpace[$ii];
 $threeVecsT[0] = $valuesTanPastSpace; $threeVecsT[1] = $PastV; $threeVecsT[2] = $PresentV;
 $TFmostRT = MostRightClockWiseInt ($threeVecsT, $TwoZeroOneT);
 $allAngiX[`size($allAngiX)`]= $EachAngle;

		$Ct[$iX] =  $TFmostRT;
		$C[$iX] = $TFmostR;
	if($ii==1){
		$C[$iX-1]= $C[$iX]; 
		$Ct[$iX-1]= $Ct[$iX]; 
		$CN[`size($CN)`-1]=$C[$iX];
	$DeepPastTan = $valuesTanPast;
	$DeepPast= $PastV;
}

$AngleB = EulerAngB($DeepPastTan, $valuesTan[$ii]);
float $AngleNine = $AngleB[3];
//if((($AngleNine>82)&&($AngleNine<98))||(($AngleNine>39)&&($AngleNine<51))){

if($Ct[$iX]==$Ct[$iX-1]){
if(($AngleNine>82)&&($AngleNine<98)){
//print ("direction Same "+$AngleNine+"\n");

 $CurrentVecT = $CurveVectors[$ii]+$valuesTan[$ii];
//Loc $CurrentVecT;

	//Loc $valuesXYZ;
$SharpValuesTan[`size($SharpValuesTan)`]= FloatToVec (lineIntersectionF($DeepPast, ($DeepPast+$DeepPastTan), $valuesXYZ, $CurrentVecT));
	//Loc $SharpValuesTan[`size($SharpValuesTan)`-1];
$SharpValuesTan[`size($SharpValuesTan)`]= $CurveVectors[$ii];
//$SharpValuesTan[`size($SharpValuesTan)`]= $CurrentVecT;

$DeepPastTan =  $valuesTan[$ii];
$DeepPast= $CurveVectors[$ii];
}
}

 $allAngi[$iX] =$EachAngle;

if($Trigger== 1){
$allAngi[$iX] = (abs($pastA - $EachAngle))+$allAngi[$iX-1];
if($allAngi[$iX]> 360){ $allAngi[$iX]=$EachAngle; $allAngi[$iX-1]=0;  $Trigger= 0; $TF++; }
}

		if($Ct[$iX]!=$Ct[$iX-1]){
//means it changed direction left or right from past tangent ..exe: the road that was curved right is now starting to curve left
$TrackDirectionChange++;
//print ("Direction CHANGE! "+$AngleNine+"\n");
 $CurrentVecT = $CurveVectors[$ii]+$valuesTan[$ii];
	//Loc $CurrentVecT;
	//Loc $valuesXYZ;
//Cube $valuesXYZ;


//if(($AngleNine>82)&&($AngleNine<98)){

if(!(($AngleNine>135)||($AngleNine==0))){
$SharpValuesTan[`size($SharpValuesTan)`]= FloatToVec (lineIntersectionF($DeepPast, ($DeepPast+$DeepPastTan), $valuesXYZ, $CurrentVecT));}
	//Loc $SharpValuesTan[`size($SharpValuesTan)`-1];
$SharpValuesTan[`size($SharpValuesTan)`]= $CurveVectors[$ii];
	$DeepPastTan =  $valuesTan[$ii];
	$DeepPast= $CurveVectors[$ii];

//}else{ if($AngleNine>90){$SharpValuesTan[`size($SharpValuesTan)`]= $CurveVectors[$ii];
//	$DeepPastTan =  $valuesTan[$ii];
//	$DeepPast= $CurveVectors[$ii];
//}


}

	if($C[$iX]!=$C[$iX-1]){
	//Loc $valuesXYZ;
	//Loc $valuesTanPast;
$CN[`size($CN)`]= $iX;
$CN[`size($CN)`]=$C[$iX];
		$Even_Odd = fmod($CountEVEN,2);
	if($Even_Odd ==1){
		$DistancesCycle[`size($DistancesCycle)`]= distance2Pts ($PositionsZ_A[0], $PresentV);

	}

	$CountEVEN++;
	$angleTii = (180.00- $allAngi[$iX]) +(180.00- $allAngi[$iX-1]);
	$allAngi[$iX] =  $angleTii +$allAngi[$iX-1];
	$Trigger= 1;

				}

$pastA = $EachAngle;
$AddAngles+= abs($EachAngle - $allAngiX[`size($allAngiX)`-1]);


if($allAngi[`size($allAngi)`-1]>=360){
clear $FlushVectors;
$StepCycle =  abs ($StepCycle -$a);
float $FXiI =$StepCycle;
float $Fnumbers = 100.0/$FXiI;
float $floatZ[];
$floatZ = CreateIntIndexF($FXiI, $Fnumbers);
$StepCycle = $a;
//Loc $CurveVectors[$ii];
$AddAngles=0;
}
}

if($StepCycle < $Lowest){
if($StepCycle!=0){
$Lowest = $StepCycle;
}
}

$PastV = FloatToVec($values);
$valuesTanPast = $valuesTan[$ii];
$valuesTanPastSpace = $valuesTanSpace[$ii];

$iX++;
$ii++;	



}

/////////END of Loop

$SharpValuesTan[`size($SharpValuesTan)`]= $PastV;

$CN[`size($CN)`]= $iX;
$low = $TF;
$angleZ = $DistancesCycle;
delete $paramlocatorpointOnCurvex;
$TotalDeg = $CurvatureRadi;
$Ang = $allAngiX;
 
VecArrayToCurve($SharpValuesTan);
ResetTransEachSL;
editDisplayLayerMembers -noRecurse VecToCurve `ls -selection`;
toggle -editPoint;
VecArrayToCurveB($SharpValuesTan);
ResetTransEachSL;
editDisplayLayerMembers -noRecurse VecToCurveB `ls -selection`;
 
return $CurveVectors; 

}

//////////////////////////////////////

global float $x0W;
global float $x1W;
global float $LearningCoeff;
global float $Threshold;
global float $Out;

proc CPerceptron_CPerceptron(){
global float $LearningCoeff;
global float $Threshold;
global float $x0W;
global float $x1W;
	//srand((unsigned)(time(NULL)));
	$LearningCoeff = 0.2;
	$Threshold = 0.5;
	$x0W =  (float)(rand(32007))/(32767/2) - 1;
	$x1W =  (float)(rand(32007))/(32767/2) - 1;


$x0W = 0.1;
$x1W = 0.1;

}


 //Setting up parameters
proc CPerceptron_SetValues(float $x0WeightPar, float $x1WeightPar, float $LearningC, float $Thresh)
{
global float $x0W;
global float $x1W;
	$x0W = $x0WeightPar;
	$x1W = $x1WeightPar;
	$LearningCoeff = $LearningC;
	$Threshold = $Thresh;
}


 //Training function
proc float CPerceptron_Train(float $x0, float $x1, float $r)
{
global float $x0W;
global float $x1W;
global float $LearningCoeff;
global float $Threshold;
global float $Out;
	float $Sum;

	float $Result;
	float $Output;
	float $Correction;
	float $Error;
	$Sum = ($x0*$x0W)+($x1*$x1W)+((-1)*$Threshold);
//print ("Sum "+$Sum+"\n");
	$Result = Sigmoid($Sum);

	$Out = ($x0*$x0W)+($x1*$x1W);
	if($Out>$Threshold){ $Output = 1.0;
	}else{ $Output = 0.0;}

	$Error = ((float)$r)-($Output);
	$Correction = $LearningCoeff*$Error;
	
	if($x0==1){ $x0W += $Correction;}
	if($x1==1){ $x1W += $Correction;}
	return $Result;
}

 //Sigmoid function
proc float CPerceptron_Sigmoid(float $x){
	 float $S = (1.0/(1.0+`exp(-$x)`));
	return $S;
}


 //Get current weight values function
proc float CPerceptron_Getx0Weight()
{
global float $x0W;
	return $x0W;
}
proc float CPerceptron_Getx1Weight()
{
global float $x1W;
	return $x1W;
}


 //Run function, return y value
proc float CPerceptron_Run(float $x0, float $x1)
{
global float $x0W;
global float $x1W;
global float $Threshold;
	float $Sum;
	float $Result;
	$Sum = ($x0*$x0W)+($x1*$x1W);
	if($Sum>$Threshold){ $Result = 1;
	}else{ $Result = 0;}
	 $Result = Sigmoid($Sum);
	return $Result;
}


proc float CPerceptron_RunX(float $x0)
{

global float $Threshold;
	float $Result;
	if($x0>$Threshold){ $Result = 1;
	}else{ $Result = 0;}
	//$Result = Sigmoid($Sum);
	return $Result;
}

proc int PrintMod(int $StepN, float $Mod ){
if ( fmod($StepN, $Mod) == ($Mod-1)  ) {
return 1;
}else {return 0;}
}



proc float [] GatherDataR(float $Xt[], float $Av){
float $Vt[];
for ($eachInt in $Xt){
if($eachInt > $Av){
$Vt[`size($Vt)`]= 0;
}else{$Vt[`size($Vt)`]= 1;}}
return $Vt;
}



proc float [] GatherDataDiff(float $Xt[], float $Av){

float $Vt[];
for ($eachInt in $Xt){
$Vt[`size($Vt)`]= `abs ($Av-$eachInt)`;
}
return $Vt;
}


proc float AverageFloats(float $FloatArray[]){
float $Ix=0;
float $AddAll=0;
for($eachF in $FloatArray){
$AddAll+= $eachF;
$Ix++;
}
float $Divide=$AddAll/$Ix;
return $Divide;
}


proc float [] AverageFloatArrays(float $FloatArrayA[], float $FloatArrayB[]){
int $Ix=0;
float $AddAll[];
for($eachF in $FloatArrayA){
$AddAll[$Ix] = ($eachF + $FloatArrayB[$Ix])/2.0;
$Ix++;
}
return $AddAll;
}

proc float [] AddFloatArrays(float $FloatArrayA[], float $FloatArrayB[]){
int $Ix=0;
float $AddAll[];
for($eachF in $FloatArrayA){
$AddAll[$Ix] = ($eachF + $FloatArrayB[$Ix]);
$Ix++;
}
return $AddAll;
}

proc float [] DivideFloatArrays(float $FloatArrayA[], float $DivideX){
int $Ix=0;
float $AddAll[];
for($eachF in $FloatArrayA){
$AddAll[$Ix] =  $eachF/$DivideX;
$Ix++;
}
return $AddAll;
}

proc float [] DiffFloatArrays(float $FloatArrayA[], float $FloatArrayB[]){
int $Ix=0;
float $AddAll[];
for($eachF in $FloatArrayA){
$AddAll[$Ix] = abs (($eachF - $FloatArrayB[$Ix]));
$Ix++;
}
return $AddAll;
}


proc float PercentDiffZeroOneArrays(float $FloatArrayA[], float $FloatArrayB[]){
int $Ix=0;
float $Fx=0.0;
float $AddAll;
for($eachF in $FloatArrayA){
if ($eachF != $FloatArrayB[$Ix]){
$AddAll+= 1.0;
}
$Fx++;
$Ix++;
}

//print ($AddAll +" "+$Fx+"\n"); 

float $DiffMathA;
if($AddAll != 0){
  $DiffMathA =  $AddAll / ($Fx/100.0);
}else{ $DiffMathA = 0;}

return $DiffMathA;
}




proc float [] GatherDataC(float $Xt[]){

float $Vt[];
int $Count=0;
int $CountP=0;
//$Vt[`size($Vt)`] =0;
for ($eachInt in $Xt){

if($Count>0){
if($Xt[$Count-1]!=$Xt[$Count]){

$Vt[`size($Vt)`]= $CountP;
$CountP = 0;
}
}
$CountP++;
$Count++;
}
$Vt[`size($Vt)`]= $CountP;

return $Vt;
}

proc int [] GatherData(int $Xt[]){

if(`size($Xt)`>0){
return $Xt;
}
}
proc float [] GatherDataF(float $Xt[]){

if(`size($Xt)`>0){
return $Xt;
}
}


proc float CPerceptron_TrainX(float $x0, float $x1)
{

global float $Threshold;
	float $Sum;
	float $Result;
	$Sum = ($x0)+($x1)+((-1)*$Threshold);
//print ("Sum "+$Sum+"\n");
	$Result = Sigmoid($Sum);
return $Result;
}


 //Sigmoid function
proc float CPerceptron_Sigmoid(float $x){
	 float $S = (1.0/(1.0+`exp(-$x)`));
	return $S;
}


proc float [] GatherDataZeroOne(float $Xt[]){
int $count =0;
float $ZO[];
for ($eachF in $Xt){
if($eachF == 1){
$ZO[$count] = 1;
}
if($eachF == -1){
$ZO[$count] = 0;
}
 $count++;

}
return $ZO;
}


proc GatherDataRRV(float $Xt[], vector $Pts[]){
int $count =0;
for ($eachF in $Xt){
if($eachF == 1){
Loc $Pts[$count];
}
 $count++;

}
}




proc float [] GatherDataRR(float $Xt[], float $Av){
float $Vt[];
float $PastF;
int $count =0;

for ($eachF in $Xt){

if($eachF < $Av){
$Vt[$count]= 1;
}else{$Vt[$count]= -1;}

if($count>0){

if($PastF<$eachF){
if($PastF<$Av){
if(($PastF+$eachF/2.0)<$Av){
$Vt[$count]= 1; }
}
}

}

$PastF = $eachF;
 $count++;
}
return $Vt;
}

proc float [] GatherDataRRZO(float $Xt[], float $Av){
float $Vt[];
float $PastF;
int $count =0;

for ($eachF in $Xt){

if($eachF < $Av){
$Vt[$count]= 1;
}else{$Vt[$count]= 0;}

if($count>0){

if($PastF<$eachF){
if($PastF<$Av){
if(($PastF+$eachF/2.0)<$Av){
$Vt[$count]= 1; }
}
}

}

$PastF = $eachF;
 $count++;
}
return $Vt;
}

proc float [] GatherDataAboveBelowT(float $Xt[], float $Av){
float $Vt[];
int $count =0;
for ($eachF in $Xt){
if($eachF < $Av){
$Vt[$count]= 1;
}else{$Vt[$count]= 0;}
 $count++;
}
return $Vt;
}




proc float [] CPerceptronZ_Train(float $x0[], float $x1[], float $r)
{

global float $x0WX[];
global float $x1WX[];
global float $LearningCoeff;
global float $Threshold;
global float $Out;
	float $Sum;

	float $Result[];
	float $Output;
	float $Correction;
	float $Error;

int $Size= size($x0);	
	for($i=0; $i<$Size; $i++){
	$Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i])+((-1)*$Threshold);
//print ("Sum "+$Sum+"\n");
	$Result[$i] = Sigmoid($Sum);

	$Out = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
	if($Out>$Threshold){ $Output = 1.0;
	}else{ $Output = 0.0;}

	$Error = ((float)$r)-($Output);
	$Correction = $LearningCoeff*$Error;
	
	if($x0[$i]==1){ $x0WX[$i] += $Correction;}
	if($x1[$i]==1){ $x1WX[$i] += $Correction;}

}

	return $Result;
}
/*
GatherDataF($x1WX);
9.906

	$Out = (-1*3.01)+(1*3.01);
	if($Out>$Threshold){ $Output = 1.0;
	}else{ $Output = 0.0;}
print $Output;
	$Error = ((float)0.99)-($Output);
	$Correction = $LearningCoeff*$Error;

	$Sum = (-1*3.01)+(1*3.01)+((-1)*$Threshold);
//print ("Sum "+$Sum+"\n");
	Sigmoid($Sum);

1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1
print $x1WX[29];
print $x0WX[29];
*/
proc float [] CPerceptronZ_TrainX(float $x0[], float $x1[])
{

global float $Threshold;
	float $Sum;
	float $Result[];
int $Size= size($x0);	
	for($i=0; $i<$Size; $i++){
	$Sum = ($x0[$i])+($x1[$i])+((-1)*$Threshold);
//print ("Sum "+$Sum+"\n");
	$Result[$i] = Sigmoid($Sum);
}
return $Result;
}




proc float [] CPerceptronZ_RunXZ(float $x0[], float $x1[])
{
global float $x0WX[];
global float $x1WX[];
global float $Threshold;
	float $Sum;
	float $Result[];
int $Size= size($x0);
	
	for($i=0; $i<$Size; $i++){

	$Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
	if($Sum>$Threshold){ $Result[$i] = 1;
	}else{ $Result[$i] = 0;}
	 $Result[$i] = Sigmoid($Sum);
}
	return $Result;
}

proc float [] CPerceptronZ_RunXYZ(float $x0[], float $x1[])
{
global float $x0WX[];
global float $x1WX[];
global float $Threshold;
	float $Sum;
	float $Result[];
int $Size= size($x0);
	
	for($i=0; $i<$Size; $i++){

	$Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i])+((-1)*$Threshold);
	 $Result[$i] = Sigmoid($Sum);
}
	return $Result;
}



proc float [] CPerceptronZ_RunOUTPUT(float $x0[], float $x1[])
{
global float $x0WX[];
global float $x1WX[];
global float $Threshold;
	float $Sum;
	float $Result[];
int $Size= size($x0);
	
	for($i=0; $i<$Size; $i++){

	$Sum = ($x0[$i]*$x0WX[$i])+($x1[$i]*$x1WX[$i]);
	if($Sum>$Threshold){ $Result[$i] = 1;
	}else{ $Result[$i] = 0;}
 $Result[$i] = Sigmoid($Sum);
	
}
	return $Result;
}

proc float [] Sum_PerceptronZ_TrainX(float $x0[], float $x1[])
{

 float $ThresholdX =1.5;
	float $Sum;
	float $Result[];
int $Size= size($x0);	
	for($i=0; $i<$Size; $i++){
	$Sum = ($x0[$i] + $x1[$i] );
//print ("Sum "+$Sum+"\n");
if($Sum > $ThresholdX){ $Result[$i] = 1;
	}else{ $Result[$i] = -1;}
}
return $Result;
}
proc string [] VecArrayToSplitCurve(vector $FixVec[]){

// the middle curve will always be even!

int $sIZes = `size $FixVec `;
int $evenOdd = fmod($sIZes, 2);

int $sIZesHalf = (($sIZes)/2)+1; 
int $NUmers[] = CreateIntIndex($sIZesHalf);
string $K = "";
for ($eachN in $NUmers){
$K += "\-k"+" "+$eachN+" ";
}
int $countN=0;
string $curveA = "curve -d 1";
float $valuesBi[];
for ($eachVeCx in $NUmers){
  $valuesBi  = $FixVec[$countN];
$curveA += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
$countN++;
}
$curveA += " "+ $K;
string $curveB = "curve -d 1";
float $valuesBi[];
$countN--;
for ($eachVeCx in $NUmers){
  $valuesBi  = $FixVec[$countN];
$curveB += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
$countN++;
}
$curveB += " "+ $K;
string $NewcurvezA = `eval($curveA)`;
string $NewcurvezB = `eval($curveB)`;
string $NewcurvezAB[];
 $NewcurvezAB = {$NewcurvezA , $NewcurvezB};
return $NewcurvezAB;
}

proc vector [] LineIntersectPlaneCam( vector $Vecii[], float $CamP[], vector $Vec[]){

	float $pAv[]=  AverageVectorPoint($Vec);
	float $n[] = Normal3Points($Vec[0], $Vec[1], $Vec[2]);
	vector $OnPlane[];
	int $CountVV=0;
vector $eachVecLine;
float $FloatDirA[];
float $FloatDirNormalA[],$MultDirA[],$DistanceLocA,$MultDirCam[],$FloatDirectionCamNormalA[],$PointN[],$FloatDirectionAi[],$DistanceLoc,$MultDirPC1[],$FloatDirNormalDist[],$PointNii[],$FloatDirectionAii[];
	for($eachVecLine in $Vecii){
 $FloatDirA  = DirectionF($eachVecLine, $CamP);
 $FloatDirNormalA = multiplyFloat(2, $FloatDirA);
	  $MultDirA = AddFloats( $FloatDirNormalA, $eachVecLine);

	 $DistanceLocA = distance2Pts(  $eachVecLine, $pAv);
	 $MultDirCam  = multiplyFloat($DistanceLocA, $n);
	 $FloatDirectionCamNormalA  = AddFloats($pAv, $MultDirCam);	
	
	 $PointN  = ClosestPoint2Line($n, $pAv, $eachVecLine);
	 $FloatDirectionAi  = DirectionF($PointN, $pAv);
	 $DistanceLoc = distance2Pts( $PointN, $pAv );
	
	 $MultDirPC1  = multiplyFloat($DistanceLoc, $FloatDirectionAi);
	 $FloatDirNormalDist  = AddFloats($eachVecLine, $MultDirPC1);
	 $PointNii  = ClosestPoint2Line(DirectionF($PointN, $pAv), $eachVecLine, $MultDirA);
	 $FloatDirectionAii  = DirectionF($PointNii, $MultDirA);

	 $OnPlane[$CountVV] = FloatToVec (lineIntersection( $FloatDirNormalDist, $FloatDirectionAii, $eachVecLine, $FloatDirA));	
	//Loc $OnPlane[$CountVV];
	$CountVV++;
}	
	return $OnPlane;	
}

proc vector FindIfCurveIsOrthoEpipol(vector $EpipolD[], vector $CRV_ENDS[], float $DistEnds, vector $LineMid){

global float $AngleEpiPole;
global int $IsOrthoLineTrue;
global int $AxisOrthoLine;


// when working with the plane get the vanishing points directions
vector $Xdirect;
vector $Ydirect;
vector $Zdirect;


if(`size($EpipolD)` == 3){

//print "EpiPolar";

 $Xdirect = $EpipolD[0];
 $Ydirect = $EpipolD[1];
 $Zdirect = $EpipolD[2];
}else{
 $Xdirect = << 1,0,0>>;
 $Ydirect = << 0,1,0>>;
 $Zdirect = << 0,0,1>>;
}

vector $XYZdirect[];
 $XYZdirect[0] = $Xdirect;
 $XYZdirect[1] = $Ydirect;
 $XYZdirect[2] = $Zdirect;
vector $NewDirectionZ;
float $Anglei;

float $EulerAngleA[],$EulerAngleB[],$EulerAngleC[],$EulerABCi[2];
string $stringF[];

 $LineAMain = PositiveDirectionLine($CRV_ENDS[0], $CRV_ENDS[1]);
	$EulerAngleA  = EulerAngB($Xdirect,$LineAMain);
	$EulerAngleB  = EulerAngB($Ydirect,$LineAMain);
	$EulerAngleC  = EulerAngB($Zdirect,$LineAMain);
$EulerABCi[0]= $EulerAngleA[3];
$EulerABCi[1]= $EulerAngleB[3];
$EulerABCi[2]= $EulerAngleC[3]; 
	string $stringF[]= FloatArrayToStringArray($EulerABCi);
	string $EmptyIndx[];
	clear $EmptyIndx;
	int $index[] = CreateIntIndex(3);
	string $stringIndTr[]= IntArrayToStringArray($index);
	SortFloatArrayAndString( $EulerABCi, $stringIndTr, $EmptyIndx);
	$EmptyIndx = ReverseStringArray($EmptyIndx);
int $xyz = $EmptyIndx[0];
$AxisOrthoLine = $xyz;
$Anglei = $EulerABCi[$xyz];
//print $Anglei;
$NewDirectionZ = $XYZdirect[$xyz];
$DistEnds= distance2Pts($CRV_ENDS[0], $CRV_ENDS[1]);
$LineMid = ($CRV_ENDS[0] + $CRV_ENDS[1])/2.0;
$AngleEpiPole = $Anglei;

int $isOrthoTrueZi=0;
if($Anglei < 8.55){
$isOrthoTrueZi = 1;
}
$IsOrthoLineTrue = $isOrthoTrueZi;
//print $IsOrthoLineTrue;
return $NewDirectionZ;
}




/*
$StereoCurveZ= `ls -sl`;
string $CurveItemZai = $StereoCurveZ[0];
string $CurveItemZbi = $StereoCurveZ[1];
*/
 
global string $PlaneCurveS[];


proc StereoCurveZ(string $CurveItemZai, string $CurveItemZbi){
	global string $StereoCurveZ[];
	global string $VanishingPointsLinesTempGuides[];
	global int $addNumbersA;	
	global float $VanishingPointGlobal[];
	global string $PlaneCurveS[];
	global float $AngleEpiPole;
	global int $IsOrthoLineTrue;
	global int $AxisOrthoLine;
		float $SnapR = 1.55;
		float $Smooth = 398;
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 1 -tol 0.05 $CurveItemZai;
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 200 -d 1 -tol 0.05 $CurveItemZbi;
	vector $AllLocPositionsZi[];
	clear $AllLocPositionsZi;
	$AllLocPositionsZi = VecCurveCvs( $CurveItemZai);
	string $newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
	ResetTranslation({$newPlaneCurveA});
	delete $CurveItemZai;
	$CurveItemZai = $newPlaneCurveA;
	clear $AllLocPositionsZi;
	$AllLocPositionsZi = VecCurveCvs( $CurveItemZbi);
	$newPlaneCurveA = VecArrayToCurve($AllLocPositionsZi);
	ResetTranslation({$newPlaneCurveA});
	delete $CurveItemZbi;
	$CurveItemZbi = $newPlaneCurveA;
	vector $VecCurEndsa[] = VecCurveEnds({$CurveItemZai});
	vector $VecCurEndsb[] = VecCurveEnds({$CurveItemZbi});
	$StereoCurveZ[0]= $CurveItemZai;
	$StereoCurveZ[1]= $CurveItemZbi;
	vector $PositionsZ_A[];
	clear $PositionsZ_A;
	$PositionsZ_A = VecCurveCvs($CurveItemZai );
	vector $PositionsZ_B[];
	clear $PositionsZ_B;
	$PositionsZ_B = VecCurveCvs($CurveItemZbi );
	vector  $VecPtsMirrorA[];
	clear $VecPtsMirrorA;
	vector  $VecPtsMirrorB[];
	clear $VecPtsMirrorB;
	$VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
	$VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
	float $CamPos_A[];
	float $CamPlane1[];
	$CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
	$CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
	float $CamDirVecNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
	float $MultDirCam[] = multiplyFloat(-1, $CamDirVecNormal);
	float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;
	vector  $VecPtsMirrorEnds_A[];
	clear $VecPtsMirrorEnds_A;	
	
	vector  $VecPtsMirrorEnds_B[];
	clear $VecPtsMirrorEnds_B;	
	$VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
	$VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
	float $CamNormM[] = ` MirrorFloatXYZ 0 $MultDirCam`;		
	float $MidEpipolZx[] = MidPoint($CamPos_M, $CamPos_A);	
	float $MidEpipolPosFCam[]= FloatPointsToCamPlane($MidEpipolZx);
	float $EpipolPosCamM[] = ` MirrorFloatXYZ 0 $MidEpipolPosFCam`;	
	float $MidPosFCam[]= $CamPlane1;
	float $FloatDirEpipol[] = DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam);
	float $FloatDirEpipolB[] = DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam);
	vector $PointN_Epi = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[0], $MidEpipolPosFCam)), $VecCurEndsa[0], $VecCurEndsb[0]);
	vector $PointN_EpiB = ClosestPoint2LineVec((DirectionFN($VecCurEndsa[1], $MidEpipolPosFCam)), $VecCurEndsa[1], $VecCurEndsb[1]);
	float $DistTOEpipol_CurEndA;
	float $DistTOEpipol_CurEndB;
	$DistTOEpipol_CurEndA = distance2Pts($PointN_Epi, $VecCurEndsb[0]);
	$DistTOEpipol_CurEndB = distance2Pts($PointN_EpiB, $VecCurEndsb[0]);
	float $BCurEndBi = distance2Pts($VecCurEndsb[0], $PointN_Epi);
	float $BCurEndBii = distance2Pts($VecCurEndsb[1], $PointN_EpiB);
	float $BCurEndBiiAdd = $BCurEndBi+$BCurEndBii;
	float $BCurEndB = distance2Pts($VecCurEndsb[0], $VecCurEndsb[1]);
	float $BCurEndBNN = distance2Pts($PointN_Epi, $PointN_EpiB);
	float $BCDiff = abs($BCurEndB - $BCurEndBNN);
	float $BCurEndBNNi = $BCurEndBNN -$BCurEndBiiAdd ;
	float $BCDiffi = abs($BCurEndB - $BCurEndBNNi);
	
	int $IntIfNearZero = equivalentTol($BCDiffi, 0.000,  0.0001);
	float $FloatDirEndPtsA[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[0]);
	float $EulerAngleA[] = EulerAngB($FloatDirEndPtsA, $FloatDirEpipol);	
	float $EulerAngle_A = $EulerAngleA[3];
	float $FloatDirEndPtsB[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[1]);
	float $EulerAngleB[] = EulerAngB($FloatDirEndPtsB, $FloatDirEpipolB);	
	float $EulerAngle_B = $EulerAngleB[3];
	float $FloatDirEndPtsAi[] = DirectionFN($VecCurEndsa[1], $VecCurEndsb[0]);
	float $EulerAngleAi[] = EulerAngB($FloatDirEndPtsAi, $FloatDirEpipol);	
	float $EulerAngle_Ai = $EulerAngleAi[3];
	float $FloatDirEndPtsBi[] = DirectionFN($VecCurEndsa[0], $VecCurEndsb[1]);
	float $EulerAngleBi[] = EulerAngB($FloatDirEndPtsBi, $FloatDirEpipolB);	
	float $EulerAngle_Bi = $EulerAngleBi[3];
	float $EulerAngle_AB = $EulerAngle_A+$EulerAngle_B;
	float $EulerAngle_AiBi = $EulerAngle_Ai+$EulerAngle_Bi;
	float $EpipolXx[] = {0.0,$CamPos_A[1],$CamPos_A[2]};	
	float $PlaneEpipolXx[]= FloatPointsToCamPlane( $EpipolXx);
	float $EpipolYx[] = {$CamPos_A[0],0.0,$CamPos_A[2]};	
	float $PlaneEpipolYx[]= FloatPointsToCamPlane( $EpipolYx);
	float $EpipolZx[] = {$CamPos_A[0],$CamPos_A[1],0.0};	
	float $PlaneEpipolZx[]= FloatPointsToCamPlane( $EpipolZx);

	vector $Vecbv[];
	vector $Vecbvi[];
	$Vecbv  = $VecCurEndsa;
	$Vecbvi = $VecCurEndsb;
	int $IfTrue;
	$IfTrue = FindLineCross( $Vecbv , $Vecbvi );
	int $weighedtFindings=0;
	int $weighedtFindingsZ=0;
	int $weighedtFindingsN=0;
	if($IfTrue=1){
		$weighedtFindings++;
		$weighedtFindingsZ++;
	}else{$weighedtFindings--;
		$weighedtFindingsN++;
	}
	if($IntIfNearZero==1){
		$weighedtFindings++;
		$weighedtFindingsZ++;
	}else{$weighedtFindings--;
		$weighedtFindingsN++;}
	if($EulerAngle_AB<$EulerAngle_AiBi){
		$weighedtFindings++;
		$weighedtFindingsZ++;
	}else{$weighedtFindings--;
		$weighedtFindingsN++;}

	vector $NewVecENDsi[];
	float $LengCRV_a = `arclen $CurveItemZai`;
	vector $CRV_ENDSi[];
	$CRV_ENDSi = $VecCurEndsa;
	float $DistEndsi; 
	$DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
	float $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
	//float $DiffMathA = ($LengCRV_a-$DistEndsi) / ($DistEndsi/100.0);

	float $LengCRV_b = `arclen $CurveItemZbi`;
	vector $CRV_ENDSii[];
	$CRV_ENDSii = $VecCurEndsb;
	float $DistEndsii; 
	$DistEndsii = distance2Pts($CRV_ENDSii[0], $CRV_ENDSii[1]);
	float $DiffMathB = $DistEndsii / ($LengCRV_b/100.0);

	float $PerDiffSum = ($DiffMathA+$DiffMathB)/2.0;

		//print (" DiffMathA " +$DiffMathA + " DiffMathB " +$DiffMathB +"\n");
		//if(($DiffMathA> 96.5) && ($DiffMathB > 96.5)){
		//$PerDiffSum =99;
		//}else{$PerDiffSum =1;}

	int $triggerStraitCRV=0;
	vector $FoundEpipol;
	int $triggerNoTransENDA=0;
	int $triggerNoTransENDB=0;
	int $First_Second_Both_None=0;
	vector $PointsA[];
	vector $PointsB[];
	//print ("START FindIfCurveIsOrthoEpipol" +"\n");
float $MidCurveA[];
float $MidCurveB[];
vector $XYZdirectL[];
$XYZdirectL[0] = << 1,0,0>>;
$XYZdirectL[1] = << 0,1,0>>;
$XYZdirectL[2] = << 0,0,1>>;
vector $LineDirect_3D;
	if( $PerDiffSum>97.05){
	print ("FIST IF : ENGAGED PerDiffSum" +$PerDiffSum +"\n");
		print ("ENGAGED FindIfCurveIsOrthoEpipol" +"\n");
		$triggerStraitCRV=1;
		float $DDirEpipol[] = DirectionFN($MidPosFCam, $MidEpipolPosFCam);
		 $MidCurveA  = MidPoint($VecCurEndsa[0], $VecCurEndsa[1]);
		 $MidCurveB  = MidPoint($VecCurEndsb[0], $VecCurEndsb[1]);
		vector $DDirEpipolXYZ[];
		$DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
		$DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
		$DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
		vector $AllEpipolXYZ[];
		$AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
		$AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
		$AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);

		vector $EpipolD[];
		$EpipolD = $DDirEpipolXYZ;
		vector $LineMidi;
		vector $NewDirZi;
		float $AngleXi;
		int $Trueii=0;

		$NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
		//print ("FindIfCurveIsOrthoEpipol" +"\n");
		//print ($NewDirZi +"\n");  
		//print ("FindIfCurveIsOrthoEpipol" +"\n");
		//print ($NewDirZi +"\n");  
		//print ("FindIfCurveIsOrthoEpipol" +"\n");
		//print ($NewDirZi +"\n");      
		$FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
$LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
	}


	if($weighedtFindingsZ<$weighedtFindingsN){
/////////////////////////////REMOVED


/////////////////////////////
		//if(($DistB<$DistA)||($weighedtFindingsZ<$weighedtFindingsN)){
		if( ($weighedtFindingsZ<$weighedtFindingsN)){

			cycleBackgroundColor;			
			$PositionsZ_B = ReverseVectorArray($PositionsZ_B);
			$VecPtsMirrorB = ReverseVectorArray($VecPtsMirrorB);
			$VecCurEndsb = ReverseVectorArray($VecCurEndsb);
			$VecPtsMirrorEnds_B = ReverseVectorArray($VecPtsMirrorEnds_B);
		}
	}


	string $queryLocCurveEnds3D[];
	$queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
	$queryLocCurveEnds3D = `sort $queryLocCurveEnds3D`;
	int $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
	int $SizeCrvi = (`size($queryLocCurveEnds3D)`)/2;
	int $TrackAllExisting3DCrv[] = CreatePairIntIndex($SizeCrvi);
	string $LayerCurvesRangeA[];
	$LayerCurvesRangeA = `editDisplayLayerMembers -q  layerCurvesINRange1`;
	int $SizeCrvR =  `size($LayerCurvesRangeA)` ;
	string $ExpandedString[];
	clear $ExpandedString;
	int $Cn=0;
	for($eachIntCC in $TrackAllExisting3DCrv){
		$ExpandedString[$Cn] = $LayerCurvesRangeA[$eachIntCC];
		$Cn++;
	} 
	int $triggerNoTrans = 0;
	int $triggerNoTransA = 0;
	int $triggerNoTransB = 0;
	int $triggerNoTrans = 0;
	vector $VecOnPlaneA[];	 
	vector $VecOnPlaneB[];

	vector $IntersectEnds_Ax[];
	clear $IntersectEnds_Ax;
	int $iia = 0;
	vector $Intersect_A[]; 
	
	float $PointToCamDir[];
	float $PointsClos[];
	vector $PositionsZ_Ai[];
	vector $PositionsZ_Bi[];
	string $ThefirstCurve;
	string $ThefirstCurvei;

int $trigger_straitC =0;
if(!(`size($queryLocCurveEnds3D)` > 2)){
	print ("ENGAGED PerDiffSum " +$PerDiffSum +"\n");
if($PerDiffSum >95.05){
		vector $PositionsZ_Bii[];
		vector $PositionsZ_Aii[];	
						int $iis = 0;
						vector $XIntersect_Ax[2];						 
						for ($eachVecx in  $VecCurEndsb){
							$XIntersect_Ax[$iis] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsb[$iis], $CamPos_M, $VecPtsMirrorEnds_A[$iis]));		
							$iis++;
						}
$XIntersect_Ax[2] =  $XIntersect_Ax[1];
$XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));	
$XIntersect_Ax[0] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[0]);
$XIntersect_Ax[2] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[2]);
		$PositionsZ_Bii= $XIntersect_Ax;							
		$PositionsZ_Aii= VecPtsToZMirrorPts($PositionsZ_Bii);
	 $ThefirstCurve = VecArrayToCurve($XIntersect_Ax);
					vector  $PtsMirrorAi[];					
						$PtsMirrorAi= VecPtsToZMirrorPts($XIntersect_Ax);
	 $ThefirstCurvei = VecArrayToCurve($PtsMirrorAi);	

$trigger_straitC =1;
}
}

////////////
	if(`size( $queryLocCurveEnds3D)`>2){	
		
		vector $LocCurveEndsVec3D[] = PointArray($queryLocCurveEnds3D);		
		for ($eachVecx in  $VecCurEndsa)
		{
			$IntersectEnds_Ax[$iia] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsa[$iia], $CamPos_M, $VecPtsMirrorEnds_B[$iia]));
			$iia++;
		}

		float $distToCurveE_A[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[0]);
		int $AllLocsi[] = CreateIntIndex(`size($LocCurveEndsVec3D)`);
		string $AllLocs_String[] = IntArrayToStringArray($AllLocsi);
		string $EmptyStringNewOrderA[];
		float $newOrdersZA[] = SortFloatArrayAndString($distToCurveE_A, $AllLocs_String, $EmptyStringNewOrderA);
		$EmptyStringNewOrderA = ReverseStringArray($EmptyStringNewOrderA);
		int $New_AllLocs_A[];
		$New_AllLocs_A= ArrayToIntList($EmptyStringNewOrderA);
		int $Near_index_A = $New_AllLocs_A[0];
		float $Distance_A = $distToCurveE_A[$Near_index_A];
		float $Found_pt_A[] = $LocCurveEndsVec3D[$Near_index_A];		
		float $newOrdersZAM[] = $Found_pt_A;
		$newOrdersZAM[0] = $Found_pt_A[0] *-1;	
		float $distToCurveE_B[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $IntersectEnds_Ax[1]);		
		string $EmptyStringNewOrderB[];
		float $newOrdersZB[] = SortFloatArrayAndString($distToCurveE_B, $AllLocs_String, $EmptyStringNewOrderB);
		$EmptyStringNewOrderB = ReverseStringArray($EmptyStringNewOrderB);
		int $New_AllLocs_B[];
		$New_AllLocs_B = ArrayToIntList($EmptyStringNewOrderB);
		int $Near_index_B = $New_AllLocs_B[0];
		float $Distance_B = $distToCurveE_B[$Near_index_B];
		float $Found_pt_B[] = $LocCurveEndsVec3D[$Near_index_B];
		float $newOrdersZBM[] = $Found_pt_B;
		$newOrdersZBM[0] = $Found_pt_B[0] *-1;
		
		$PointsA[0] = FloatToVec($Found_pt_A);
		$PointsA[1] = FloatToVec($Found_pt_B);
		vector $PointsB[];
		$PointsB[0] = FloatToVec($newOrdersZAM); // negative mirror of first endpoint of first curve
		$PointsB[1] = FloatToVec($newOrdersZBM);		
		
		$VecOnPlaneA = VecPointsToCameraPlane($PointsA);		 
		$VecOnPlaneB = VecPointsToCameraPlane($PointsB);
		
		string $NewFoundLocs[];
		$NewFoundLocs[0] = $queryLocCurveEnds3D[$Near_index_A];
		$NewFoundLocs[1] = $queryLocCurveEnds3D[$Near_index_B];
		string $arrayCurvesNear[];
		$arrayCurvesNear[0] = ("Plane"+$NewFoundLocs[0]);
		$arrayCurvesNear[1] = ("Plane"+$NewFoundLocs[1]);
		$NewFoundLocs = $arrayCurvesNear;
		vector $LocOnPlaneVec[] = PointArray($NewFoundLocs);
		float $distToPlaneLoc[];
		$distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocOnPlaneVec[0]);
		$distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocOnPlaneVec[1]);
vector $LoCz_3D[];
vector $TXI = << -1.0 , 1.0, 1.0>>;
$LoCz_3D[0] = MultVec($IntersectEnds_Ax[0],$TXI);
$LoCz_3D[1] = MultVec($IntersectEnds_Ax[1], $TXI);

////////////////////////
	float $DistToIntersectTOnear[];
		$DistToIntersectTOnear[0] = distance2Pts($IntersectEnds_Ax[0], $PointsA[0]);
		$DistToIntersectTOnear[1] = distance2Pts($IntersectEnds_Ax[1], $PointsA[1]);
		$DistToIntersectTOnear[2] = distance2Pts($LoCz_3D[0], $PointsB[0]);
		$DistToIntersectTOnear[3] = distance2Pts($LoCz_3D[1], $PointsB[1]);

		float $distToPlaneLoc3D[];
		$distToPlaneLoc3D[0] = distance2Pts($VecCurEndsa[0], $PointsA[0]);
		$distToPlaneLoc3D[1] = distance2Pts($VecCurEndsa[1], $PointsA[1]);
		$distToPlaneLoc3D[2] = distance2Pts($VecCurEndsb[0], $PointsB[0]);
		$distToPlaneLoc3D[3] = distance2Pts($VecCurEndsb[1], $PointsB[1]);
//////////////////////////				
	
		float $DiffMathA =  $DistToIntersectTOnear[0]/ ($distToPlaneLoc3D[0]/100.0);
		float $DiffMathB =  $DistToIntersectTOnear[1] / ($distToPlaneLoc3D[1]/100.0);
		float $DiffMathAm =  $DistToIntersectTOnear[2]/ ($distToPlaneLoc3D[2]/100.0);
		float $DiffMathBm =  $DistToIntersectTOnear[3] / ($distToPlaneLoc3D[3]/100.0);

float $relativeDistanceA = ($DiffMathA+$DiffMathAm)/2.0;
float $relativeDistanceB = ( $DiffMathB+$DiffMathBm)/2.0;
	/*
		float $relativeDistanceAi = ($Distance_A+$distToPlaneLoc[0])/2.0;
		float $relativeDistanceBi = ($Distance_B+$distToPlaneLoc[1])/2.0;
		float $relativeDistanceAZ = distance2Pts($VecOnPlaneA[0], $PointsA[0]);
		float $relativeDistanceBZ = distance2Pts($VecOnPlaneB[0], $PointsB[0]);
		float $DiffMathAi =  $relativeDistanceAi/ ($relativeDistanceAZ/100.0);
		float $DiffMathBi =  $relativeDistanceBi / ($relativeDistanceBZ/100.0);
		float $TimesMathAi =  $relativeDistanceA*$relativeDistanceAZ/ ($distToPlaneLoc3D[0]/100.0); 
		float $TimesMathBi =  $relativeDistanceB*$relativeDistanceBZ/ ($distToPlaneLoc3D[1]/100.0);
		//float $SnapR = 1.95;		
print ("\n");
print ("relativeDistanceA "+"\n");
print ($relativeDistanceA+"\n");
print ("relativeDistanceB "+"\n");
print ($relativeDistanceB+"\n");
print ("\n");
print ("TimesMathA "+"\n");
print ($TimesMathA+"\n");
print ("\n");
print ("TimesMathB "+"\n");
print ($TimesMathB+"\n");
print ("\n");
*/

		if($relativeDistanceA<$SnapR){			
			$triggerNoTransA++;
		}
		if($relativeDistanceA <$SnapR){			
			$triggerNoTransB++;
		}
		if(!($relativeDistanceA<$SnapR)){
			$VecOnPlaneA[0] = $VecCurEndsa[0];
			$VecOnPlaneB[0] = $VecCurEndsb[0];
			$triggerNoTransENDA=1;
		}else{$triggerNoTrans++;
			$First_Second_Both_None =0;
		}		if(!($relativeDistanceB<$SnapR)){
			$VecOnPlaneA[1] = $VecCurEndsa[1];
			$VecOnPlaneB[1] = $VecCurEndsb[1];
			$triggerNoTransENDB=1;
		}else{$triggerNoTrans++;
			$First_Second_Both_None =1;

			if($triggerNoTransENDA==0){ $First_Second_Both_None =-2;}

		}

		if($triggerNoTrans==0){
			$First_Second_Both_None =-1;}

		//if(($triggerNoTransENDA +$triggerNoTransENDB)== 2){
		//}

		//if(($triggerNoTransENDA +$triggerNoTransENDB)== 0){
		//}


		int $ConnectedEnds = $triggerNoTransENDA + $triggerNoTransENDB;
		vector $UnconnectedEnds[];
		if($triggerNoTransENDA==1){
			$UnconnectedEnds[0]= $VecOnPlaneA[0];
			$UnconnectedEnds[1]= $VecOnPlaneB[0];
		}else{$UnconnectedEnds[0]= $VecOnPlaneA[1];
			$UnconnectedEnds[1]= $VecOnPlaneB[1];}

		string $arrayCurvesNearA[];
		clear $arrayCurvesNearA;
		string $arrayCurvesNearB[];
		clear $arrayCurvesNearA;
		int $AddAB = $triggerNoTransA+$triggerNoTransB;
		int $New_AllLocs_AB[];
		float $distToCurveE_AB[];


		if($triggerNoTrans!=0){
			vector $PositionsZ_A[];
			
			$PositionsZ_A = VecCurveCvs($CurveItemZai );
			$PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEndsa,$VecOnPlaneA, $PositionsZ_A);
			$PositionsZ_Bi = Matrix_Curve_TranslationCC($VecCurEndsb, $VecOnPlaneB, $PositionsZ_B);
			clear $VecPtsMirrorA;
			$VecPtsMirrorA= VecPtsToZMirrorPts( $PositionsZ_Ai);
			clear $VecPtsMirrorB;
			$VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_Bi);
			$PositionsZ_A = $PositionsZ_Ai;
			$PositionsZ_B = $PositionsZ_Bi;
			cycleBackgroundColor;
		}

	}
	vector $Intersect_LineB_a;
	vector $Intersect_LineB_b;

	//print (" IsOrthoTrueZi Eq  "+$IsOrthoLineTrue +"\n");
	int $PairInt[];

	if($triggerNoTrans==0){
if($PerDiffSum >97.0){

		vector $PositionsZ_Bii[];
		vector $PositionsZ_Aii[];		
						int $iis = 0;
						vector $XIntersect_Ax[2];						 
						for ($eachVecx in  $VecCurEndsb){
							$XIntersect_Ax[$iis] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEndsb[$iis], $CamPos_M, $VecPtsMirrorEnds_A[$iis]));		
							$iis++;
						}
$XIntersect_Ax[2] =  $XIntersect_Ax[1];
$XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
$XIntersect_Ax[0] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[0]);
$XIntersect_Ax[2] = ClosestPoint2LineVec($LineDirect_3D, $XIntersect_Ax[1], $XIntersect_Ax[2]);

		$PositionsZ_Bii= $XIntersect_Ax;							
		$PositionsZ_Aii= VecPtsToZMirrorPts($PositionsZ_Bii);

	 $ThefirstCurve = VecArrayToCurve($XIntersect_Ax);
					vector  $PtsMirrorAi[];					
						$PtsMirrorAi= VecPtsToZMirrorPts($XIntersect_Ax);
	 $ThefirstCurvei = VecArrayToCurve($PtsMirrorAi);			

$trigger_straitC =1;
}
}


	if($triggerNoTrans!=0){

		//print ("triggerNoTrans Doesnt not Eq ZERO" +"\n");

		if($IsOrthoLineTrue==1){
			//print ("IsOrthoLineTrue Eq ONE" +"\n");

			if($AxisOrthoLine!=0){

				//print ("AxisOrthoLine Doesnt not Eq ZERO" +"\n");

				if($First_Second_Both_None>=0){
					//print ("First_Second_Both_None LESS then ZERO!" +"\n");

					//if($AxisOrthoLine==0){ 	
if($trigger_straitC==1){

						$FloatDirEpipol = DirectionFN($VecOnPlaneA[$First_Second_Both_None], $FoundEpipol);
						$FloatDirEpipolB= DirectionFN($VecOnPlaneB[$First_Second_Both_None], $FoundEpipol);
						if($AxisOrthoLine==0){
						//print ("AxisOrthoLine Eq ZERO!" +"\n");
						//print ("line ortho Direction same as CAM epipole"); 

							float $lineEPointA[]= MultLenToDirAddToPoint($LengCRV_a, $FloatDirEpipol, $VecOnPlaneA[$First_Second_Both_None]);

							vector $Xdirection = << 1.0,0.0,0.0>>;
							$Intersect_LineB_a = FloatToVec (lineIntersection($PointsA[$First_Second_Both_None], $Xdirection, $lineEPointA,(DirectionFN( $CamPos_A,$lineEPointA)) ));

							float $Point3DA[] = $Intersect_LineB_a;
							float $Point3DAM[] = {($Point3DA[0]*-1), $Point3DA[1],$Point3DA[2]};

						}


						if($First_Second_Both_None==1){
							//print ("First_Second_Both_None Eq ONE! " +"\n");
							$PairInt={0,1};

						}else{ $PairInt={2,3};
							//print ("First_Second_Both_None NOT Eq ONE! " +"\n");
						}						
						
						vector $Intersect_BX[];	 
						$Intersect_BX= VecPtsToZMirrorPts($IntersectEnds_Ax);
						vector $PairVectors[];
						$PairVectors[0]=FloatToVec(FloatPointsToCamPlane($IntersectEnds_Ax[0]));
						$PairVectors[1]= FloatToVec(FloatPointsToCamPlane($Intersect_BX[0]));
						$PairVectors[2]=FloatToVec(FloatPointsToCamPlane($IntersectEnds_Ax[1]));
						$PairVectors[3]= FloatToVec(FloatPointsToCamPlane($Intersect_BX[1]));
						vector $EpipolXLine = DirectionFN( $MidEpipolPosFCam, $PairVectors[$PairInt[0]]) ;

						$Intersect_LineB_a = FloatToVec (lineIntersection($VecOnPlaneA[$First_Second_Both_None], $FloatDirEpipol, $MidEpipolPosFCam,$EpipolXLine));
						//Loc $Intersect_LineB_a;
						$Intersect_LineB_b = FloatToVec (lineIntersection($VecOnPlaneB[$First_Second_Both_None], $FloatDirEpipolB, $MidEpipolPosFCam,$EpipolXLine));
						//Loc $Intersect_LineB_b;					
						
						clear $PositionsZ_A;
						clear $PositionsZ_B;
						clear $VecPtsMirrorEnds_A;
						clear $VecPtsMirrorEnds_B;
						clear $VecPtsMirrorA;
						clear $VecPtsMirrorB;
						$PositionsZ_A[0] =  $VecOnPlaneA[$First_Second_Both_None];
						$PositionsZ_A[1]= FloatToVec (MidPoint($VecOnPlaneA[$First_Second_Both_None],$Intersect_LineB_a));
						$PositionsZ_A[2] =  $Intersect_LineB_a;
						$PositionsZ_B[0] =  $VecOnPlaneB[$First_Second_Both_None];
						$PositionsZ_B[1]= FloatToVec (MidPoint($VecOnPlaneB[$First_Second_Both_None], $Intersect_LineB_b));
						$PositionsZ_B[2] =  $Intersect_LineB_b;
						$VecPtsMirrorEnds_A = VecPtsToZMirrorPts( $VecCurEndsa);
						$VecPtsMirrorEnds_B= VecPtsToZMirrorPts( $VecCurEndsb);
						$VecPtsMirrorA = VecPtsToZMirrorPts( $PositionsZ_A);
						$VecPtsMirrorB= VecPtsToZMirrorPts( $PositionsZ_B);
					 }
				}
			}
		}
	}


if($trigger_straitC!=1){
	int $iiz = 0;
	vector $Intersect_A[];

	for ($eachVecx in  $VecPtsMirrorA)
	{
		$Intersect_A[`size($Intersect_A)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_B[$iiz], $CamPos_M, $VecPtsMirrorA[$iiz]));
		$iiz++;
	}
	 
	 $ThefirstCurve = VecArrayToCurve($Intersect_A);
	modifySelectedCurves smooth $Smooth 0;
	vector $Intersect_B[];	
	$Intersect_B= VecPtsToZMirrorPts($Intersect_A);
	 $ThefirstCurvei = VecArrayToCurve($Intersect_B);
	modifySelectedCurves smooth $Smooth 0;
	vector $EndrEndsa[] = VecCurveEnds({$ThefirstCurvei});	
	int $EndsAtZero= isCurveEndAtZY($EndrEndsa);
int $STEPSZ = 200;
string $curvesZi = $ThefirstCurve;
float $angleZi[];
float $TotalDegii[];
int $LowX;
float $TrackCi[]; 
float $anglesMade[];						
$curvesZi = CurvatureIsCircleData($curvesZi, $STEPSZ, $angleZi, $TotalDegii, $LowX, $TrackCi, $anglesMade);
delete $ThefirstCurve;
$ThefirstCurve = $curvesZi;
string $curvesZii = $ThefirstCurvei;
$curvesZii = CurvatureIsCircleData($curvesZii, $STEPSZ, $angleZi, $TotalDegii, $LowX, $TrackCi, $anglesMade);
delete $ThefirstCurvei;
$ThefirstCurvei = $curvesZii;

	if($EndsAtZero>0){
		sets -include ZEdgeCurvesSet ({$ThefirstCurvei,$ThefirstCurve});
	}

}	
	delete $VanishingPointsLinesTempGuides;
	clear $VanishingPointsLinesTempGuides;
	delete $CurveItemZai $CurveItemZbi;
	clear $StereoCurveZ;
	$addNumbersA =0;
	clear $VanishingPointGlobal;

	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $ThefirstCurve;
	ResetTranslation({$ThefirstCurve});
	CurveIndexVecTracking({$ThefirstCurve});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ThefirstCurve;
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $ThefirstCurvei;
	ResetTranslation({$ThefirstCurvei});
	CurveIndexVecTracking({$ThefirstCurvei});  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ThefirstCurvei;
	evalVectorIndexAdditionSubtract;
	EVALCamScripts;
} 










proc int isCurveEndAtZY(vector $EndVectors[]){
float $ThreeFs[];
int $Number =0;
for($eachVec in $EndVectors){
$ThreeFs = $eachVec;
if($ThreeFs[0] == 0){
$Number++;
}}
return $Number;
}



global int $ifSingleCurve;
$ifSingleCurve =0;
createDisplayLayer -name "VanishingPointsLines"  -empty;
setAttr VanishingPointsLines.visibility 1; setAttr VanishingPointsLines.displayType 0; setAttr VanishingPointsLines.color 0;

////////////////////////////////////////////////


/*
string $OneCurve[] = `ls -sl`;
string $OneCurveS = $OneCurve[0];
int $TFNS = 1;
string $CurveNS;
$CurveNS = IScircleTF($OneCurveS,$TFNS);
print $TFNS;
vector $EmptyVectorArrayA[];
string $NewOneCurveS;
if($TFNS==1){
 $NewOneCurveS = EllipesSketchFitting($CurveNS, $EmptyVectorArrayA);
}else{  $NewOneCurveS = $OneCurveS;}

int $NewArrayAEllipZ[] = NewVecOrderEllipZ($NewOneCurveS, $EmptyVectorArrayA, $MidEpipolPosFCam);
vector $EmptyVectorArrayB[];
string $NewOneCurveSB;
string $OneCurve[] = `ls -sl`;
 $NewOneCurveSB = EllipesSketchFitting($OneCurve[0], $EmptyVectorArrayB);
int $NewArrayBEllipZ[] = NewVecOrderEllipZ($NewOneCurveSB, $EmptyVectorArrayB, $MidEpipolPosFCam);
string $StereoCircle[]= Eval3DCircleStereo( $NewArrayBEllipZ  , $EmptyVectorArrayB ,  $NewArrayAEllipZ , $EmptyVectorArrayA );

// print $EmptyVectorArrayA; 
int $IndexTrackE[];
$IndexTrackE = CreateIntIndex(`size($EmptyVectorArrayA)`);
//select -r $NewOneCurveS;
	float $CamPos_A[];
	$CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
	float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;	
	float $MidEpipolZx[] = MidPoint($CamPos_M, $CamPos_A);	
	float $MidEpipolPosFCam[]= FloatPointsToCamPlane($MidEpipolZx);
// Loc $MidEpipolPosFCam;

	float $EllipesPos_A[];
	$EllipesPos_A = `xform -q -ws -t $NewOneCurveS`;
	vector $Dir_VecMAIN;
		$Dir_VecMAIN =  DirectionFN($MidEpipolPosFCam, $EllipesPos_A);	

float $allAngiX[];
float $DIff;
vector $threeVecs[];
int $TwoZeroOne[] = {0,1};
int $TFmostRArray[];
clear $allAngiX; clear $TFmostRArray;
$threeVecs[0] = FloatToVec($MidEpipolPosFCam); 
$threeVecs[1] = FloatToVec($EllipesPos_A); 

for($EachVector in $EmptyVectorArrayA){
$DIff = FindDirectionDiff($Dir_VecMAIN, $MidEpipolPosFCam, $EachVector);
if($DIff!= 0){
 $allAngiX[`size($allAngiX)`]=  VAnglesofThreeVec($MidEpipolPosFCam, $EllipesPos_A, $EachVector);
$threeVecs[2] = $EachVector;
 $TFmostRArray[`size($TFmostRArray)`] = MostRightClockWiseInt ($threeVecs, $TwoZeroOne);
}else{ $allAngiX[`size($allAngiX)`]= 0;  $TFmostRArray[`size($TFmostRArray)`] =0;}
}

float $AllAngiX_RIGHT[];
float $AllAngiX_LEFT[];
int $LargestIntR_KEY[];
int $LargestIntL_KEY[];
clear $LargestIntR_KEY;
clear $LargestIntL_KEY;
clear $AllAngiX_LEFT;
clear $AllAngiX_RIGHT;
int $COUNT_Nlr=0;
for($EachIntarray in $TFmostRArray){
if($EachIntarray==1){
$AllAngiX_RIGHT[`size($AllAngiX_RIGHT)`]= $allAngiX[$COUNT_Nlr];
$LargestIntR_KEY[`size($LargestIntR_KEY)`]=$COUNT_Nlr;
}
if($EachIntarray==0){
$AllAngiX_LEFT[`size($AllAngiX_LEFT)`]= $allAngiX[$COUNT_Nlr];
$LargestIntL_KEY[`size($LargestIntL_KEY)`]=$COUNT_Nlr;
}
$COUNT_Nlr++;
}


int $LargestIntR[] = SortNumbersIntIndex($AllAngiX_RIGHT);
$LargestIntR = ReverseIntArray($LargestIntR);
// Loc $EmptyVectorArrayA[$LargestIntR_KEY[$LargestIntR[0]]];
int $LargestIntL[] = SortNumbersIntIndex($AllAngiX_LEFT);
$LargestIntL = ReverseIntArray($LargestIntL);
// Loc $EmptyVectorArrayA[$LargestIntL_KEY[$LargestIntL[0]]];
print $LargestIntR_KEY[$LargestIntR[0]];
print $LargestIntL_KEY[$LargestIntL[0]];
// test int $NewStartInt = $LargestIntL_KEY[$LargestIntL[0]];
//  $IndexTrackE
int $SizeE = `size($EmptyVectorArrayA)`;
int $NewArrayInt;
int $NewArrayIntX[];
int $Add=0;
for($EachIntX in $IndexTrackE){
$NewArrayIntX[`size($NewArrayIntX)`] = fmod(($NewStartInt+$Add),$SizeE);
$Add++;
}

// just to see the result - $NewArrayIntX = ReverseIntArray($NewArrayIntX);

int $NewArrayAEllipZ[] = NewVecOrderEllipZ($NewOneCurveS, $EmptyVectorArrayA, $MidEpipolPosFCam);
vector $EmptyVectorArrayB[];
string $NewOneCurveSB;
string $OneCurve[] = `ls -sl`;
 $NewOneCurveSB = EllipesSketchFitting($OneCurve[0], $EmptyVectorArrayB);
int $NewArrayBEllipZ[] = NewVecOrderEllipZ($NewOneCurveSB, $EmptyVectorArrayB, $MidEpipolPosFCam);
string $StereoCircle[]= Eval3DCircleStereo( $NewArrayBEllipZ  , $EmptyVectorArrayB ,  $NewArrayAEllipZ , $EmptyVectorArrayA );



*/








proc float  FindDirectionDiff(vector $Line_Y_zeroMain, vector $VecCurEndsA, vector $VecCurEndsB){
	vector $Dir_VecA;
	float $Addit[];
	float $AdditR;
		$Dir_VecA =  DirectionFN($VecCurEndsA,$VecCurEndsB);		
		$VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
		$Addit = $VecLineDirM ;
		$AdditR = $Addit[0]+$Addit[1]+$Addit[2];
return $AdditR;
}

global int $ForceOrthoOFFON;
$ForceOrthoOFFON = 0;


proc string [] ForceOrtho(string  $CurveItemAX[]){

// string  $CurveItemAX[] =`ls -sl`;
	global string $StereoCurveZ[];
	global int $addNumbersA;
	global float $AngleEpiPole;
	global int $IsOrthoLineTrue;
	global int $AxisOrthoLine;

//string  $CurveItemAX[] =`ls -sl`;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemAX[0];

 				/////////////////////
				vector $Positions[];					
				$Positions = VecCurveEps($CurveItemAX[0]);				
				$TempCrv = VecArrayToCurve($Positions);
delete $CurveItemAX[0];
	vector $VecCurEnds[] = VecCurveEnds({$TempCrv});
	string $queryLocCurveEnds[] = queryLocOnLivePlaneBLayer(); 
	string $queryLocCurveEndsOLD[] = $queryLocCurveEnds;
	int $edgeZsetA;
	int $edgeZsetB;
$edgeZsetA = 0;
$edgeZsetB = 0;
	string $newNames;	
	float $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
	float $NdistA,$NdistB;
	string $NearCurvesEnds[];

string $BothCurves[];
 	if(`size($queryLocCurveEnds)` >= 2){

		vector $LocCurveEndsVec[] = PointArray($queryLocCurveEnds);
		string $EmptyStringNewOrderA[];
		float $distancesEachToCurve[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
		float $distancesEachToCurveB[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);

int $ReducedIndexA[] = floatArrayCountDuplicates($distancesEachToCurve);
int $ReducedIndexB[] = floatArrayCountDuplicates($distancesEachToCurveB);
float $distAz[];
float $distBz[];
for($eachInt in $ReducedIndexA){
$distAz[`size($distAz)`]= $distancesEachToCurve[$eachInt];
}
for($eachInt in $ReducedIndexB){
$distBz[`size($distBz)`]= $distancesEachToCurveB[$eachInt];
}

//clear $NearestInt;
//clear $NearestIntB;
		int $NearestInt[] = SortNumbersIntIndex($distAz);	
		int $NearestIntB[] = SortNumbersIntIndex($distBz);

int $NewIntIndexAA = $ReducedIndexA[$NearestInt[0]];
int $NewIntIndexBB = $ReducedIndexB[$NearestIntB[0]];


		$EmptyStringNewOrderA[0] = $queryLocCurveEnds[$ReducedIndexA[$NearestInt[0]]];
		$EmptyStringNewOrderA[1] = $queryLocCurveEnds[$ReducedIndexB[$NearestIntB[0]]];
$NearestInt[0] =  $NewIntIndexAA;
$NearestIntB[0] = $NewIntIndexBB;

		
		$NdistA = $distancesEachToCurve[$NearestInt[0]];
		$NdistB= $distancesEachToCurveB[$NearestIntB[0]];
string $LocA = $queryLocCurveEnds[$NearestInt[0]];
string $LocB = $queryLocCurveEnds[$NearestIntB[0]];

//Loc $LocCurveEndsVec[$NearestInt[0]];
//Loc $LocCurveEndsVec[$NearestIntB[0]];

vector $EndSnapAndEndProject[];
clear $EndSnapAndEndProject;
string $LocName;
string $Loc_AorB="";
int $NearestIndex;
vector $endNotNearZ[];
vector $NearEndZ;
int $NearestIndexEach;
//////////////////////////////////////////
	if($NdistA<$NdistB){
$LocName =$LocA;
	$NearestIndex=$NearestInt[0];
      $NearEndZ = $VecCurEnds[0];
$endNotNearZ[0] = $VecCurEnds[1];
$Loc_AorB="B";
	}else{
$Loc_AorB="A";
$LocName =$LocB;
	$NearestIndex=$NearestIntB[0];
      $NearEndZ = $VecCurEnds[1];
$endNotNearZ[0] = $VecCurEnds[0];}
//////////////////////
// very very rare event
	if($NdistA==$NdistB){
$Loc_AorB="A";
$LocName =$LocA;
	$NearestIndex=$NearestInt[0];
      $NearEndZ = $VecCurEnds[0];
$endNotNearZ[0] = $VecCurEnds[1];
	}
/////////////////////
	if($NearestInt[0]==$NearestIntB[0]){
$LocName =$LocA;
	$NearestIndex=$NearestInt[0];
}
//////////////////////////////////////////
		string $newNames = stringArrayToString($queryLocCurveEnds, " ");
		string $newNamesResultAX = substituteAllString($newNames, "Plane", "");		
		 string $AllarrayCurvesNear[];
		$AllarrayCurvesNear = stringToStringArray($newNamesResultAX, " ");
	string $NewFoundLocs[];
		$NewFoundLocs[0]  = $AllarrayCurvesNear[$NearestIndex];
	string $arrayCurvesNear[];
		$arrayCurvesNear[0] = $queryLocCurveEnds[$NearestIndex];
/*
// needed for later for edgeCurves and dynamic local axis plane mirroring
		string $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");	
	 	string $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
		string $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
*/


		vector $LocOnPlaneVec[] = PointArray($arrayCurvesNear );
		vector $Loc3D_Vec[] = PointArray($NewFoundLocs );
	vector $ALLLoc3D_VecAB[] = PointArray($AllarrayCurvesNear);

 vector $ReducedVecAB[];
int $ReducedIndexXAB[];
if($Loc_AorB == "A"){
$ReducedIndexXAB = $ReducedIndexA;
 $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexA,$ALLLoc3D_VecAB);
}
if($Loc_AorB == "B"){
$ReducedIndexXAB = $ReducedIndexB;
 $ReducedVecAB = NewVecOrderWithINTKey($ReducedIndexB,$ALLLoc3D_VecAB);
}

	vector $ALLLoc3D_Vec[];
$ALLLoc3D_Vec = $ReducedVecAB;

vector $MovedEndPointPlane[] = MoveVectors($NearEndZ, $LocOnPlaneVec[0], $endNotNearZ);
vector $CRV_ENDSi[];
$CRV_ENDSi[0]= $LocOnPlaneVec[0];
$CRV_ENDSi[1]= $MovedEndPointPlane[0];
	float $CamPos_A[];	 
	$CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
	float $EpipolXx[] = {0.0,$CamPos_A[1],$CamPos_A[2]};	
	float $PlaneEpipolXx[]= FloatPointsToCamPlane( $EpipolXx); 
	float $EpipolYx[] = {$CamPos_A[0],0.0,$CamPos_A[2]};	
	float $PlaneEpipolYx[]= FloatPointsToCamPlane( $EpipolYx); 
	float $EpipolZx[] = {$CamPos_A[0],$CamPos_A[1],0.0};	
	float $PlaneEpipolZx[]= FloatPointsToCamPlane( $EpipolZx);
float $MidCurveA[] = MidPoint($CRV_ENDSi[0], $CRV_ENDSi[1]);
float $DistEndsi = distance2Pts($CRV_ENDSi[0], $CRV_ENDSi[1]);
vector $DDirEpipolXYZ[];
$DDirEpipolXYZ[0] = PositiveDirectionLine($MidCurveA, $PlaneEpipolXx);
$DDirEpipolXYZ[1] = PositiveDirectionLine($MidCurveA, $PlaneEpipolYx);
$DDirEpipolXYZ[2] = PositiveDirectionLine($MidCurveA, $PlaneEpipolZx);
vector $EpipolD[];
 $EpipolD = $DDirEpipolXYZ;
vector $AllEpipolXYZ[];
$AllEpipolXYZ[0] = FloatToVec($PlaneEpipolXx);
$AllEpipolXYZ[1] = FloatToVec($PlaneEpipolYx);
$AllEpipolXYZ[2] = FloatToVec($PlaneEpipolZx);
vector $XYZdirectL[];
$XYZdirectL[0] = << 1,0,0>>;
$XYZdirectL[1] = << 0,1,0>>;
$XYZdirectL[2] = << 0,0,1>>;
vector $LineMidi;
vector $NewDirZi;
$NewDirZi = FindIfCurveIsOrthoEpipol( $EpipolD, $CRV_ENDSi, $DistEndsi, $LineMidi);
vector $FoundEpipol = $AllEpipolXYZ[$AxisOrthoLine];
vector $LineDirect_3D = $XYZdirectL[$AxisOrthoLine];
int $AxisOrthoLineA = $AxisOrthoLine;
// 3d start point $Loc3D_Vec[0]  free Endpoint of plane curve $MovedEndPointPlane[0]
	vector $Dir_CamRay;
		$Dir_CamRay =  DirectionFN($MovedEndPointPlane[0],$CamPos_A);	

// lineIntersection NOTE arguments are in this order: Point then Line ...Point then Line
	 string $CurvesV[];
	 string $LocsV[];
vector $First3dIntersect = lineIntersection( $MovedEndPointPlane[0], $Dir_CamRay, $Loc3D_Vec[0], $LineDirect_3D);
vector $PointN_LineC = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $First3dIntersect);
float  $FPointN_LineC[];

float $Dist_3D = distance2Pts($PointN_LineC, $Loc3D_Vec[0]);

	vector $NewPlanePoint = FloatToVec(FloatPointsToCamPlane($PointN_LineC)); 
	float $Xx, $Yy, $Zz;
	float $Xxi, $Yyi, $Zzi;
	float $XY[];
	float $XYZi[];
	$XYZi  = $PointN_LineC;
	float $XYZadd[];
	$XYZadd  = $PointN_LineC; 

$XYZi[0] = $XYZadd[0]+$XYZadd[1];
$XYZi[1] = $XYZadd[1]+$XYZadd[2];
$XYZi[2] = $XYZadd[0]+$XYZadd[2]; 	
	int $iVc=0;
vector $One;
int $TrackFoundN[];
int $TrackN[];
clear $TrackFoundN;
float $Xd;
float $Yd;
float $Zd;
int $TwoPointsi[];
if($AxisOrthoLineA ==2){
$TwoPointsi[0] = 0;
}
if($AxisOrthoLineA ==1){
$TwoPointsi[0] = 2;
}
if($AxisOrthoLineA ==0){
$TwoPointsi[0] = 1;
}
int $AXIS = $AxisOrthoLineA;

int $ALLlikeness[];
int $ALLlikenessForce[];
clear $ALLlikeness;
float $Dx,$Dy,$Dz;
vector $each;
int $i =0;
int $TriggerPoints;
float $All_X[];
float $All_Y[];
float $All_Z[];
float $All_ZYX[];
float $All_ZYXDiff[];
float $diffXYZ;
float $Dist_3DNear = (($Dist_3D/3.0)*2.0);

	 for ($each in $ALLLoc3D_Vec){	
	
		 $One = $ALLLoc3D_Vec[$i];		
	$XY[0] = $Xx  = $One.x;
	$XY[1] = $Yy  = $One.y;
	$XY[2] = $Zz  = $One.z;

 if( $ReducedIndexXAB[$iVc]!= $NearestIndex ){

$TriggerPoints=0;
if( (equivalentTol($XYZadd[0], $Xx,  0.01) )==1){
$All_X[$i] = $Xx;
$TriggerPoints++;
}
if( (equivalentTol($XYZadd[1], $Yy,  0.01) )==1){
$All_Y[$i] = $Yy;
$TriggerPoints++;
}
if( (equivalentTol($XYZadd[2], $Zz,  0.01) )==1){
$All_Z[$i] = $Zz;
$TriggerPoints++;
}

 if( $TriggerPoints<2){
 $diffXYZ = `abs ($XY[$AXIS] - $XYZadd[$AXIS])`;
 if(($diffXYZ< $Dist_3DNear)&&($diffXYZ!=0)){
$All_ZYX[`size($All_ZYX)`] =$XY[$AXIS];
$All_ZYXDiff[`size($All_ZYXDiff)`] = $diffXYZ;
}
 }


if( $TriggerPoints==2){

$ALLlikeness[`size($ALLlikeness)`] = $ReducedIndexXAB[$i];
}
}
$i++;
	$iVc++;
}


int $SortedForce[];
float $newOrderFloat;

if(`size($All_ZYXDiff)`> 0){
 $SortedForce = SortNumbersIntIndex($All_ZYXDiff);
 $newOrderFloat = $All_ZYX[$SortedForce[0]];

}


if(`size($ALLlikeness)`> 0){


select -cl;  
 for($eachIn in $ALLlikeness){
 select -add $AllarrayCurvesNear[$eachIn];
PAUSE;
 }


vector $NearPointsXYZ[] ;
clear $NearPointsXYZ;
$iVc =0;
for($eachIn in $ALLlikeness){
 if( $iVc!= $NearestIndex ){
$NearPointsXYZ[`size($NearPointsXYZ )`] =  $ALLLoc3D_VecAB[$eachIn];
}
$iVc++;
}


float $distTo3DCurveEnd[] = ArrayDistancesVecTofloat($NearPointsXYZ, $PointN_LineC);
int $Sorted[] = SortNumbersIntIndex($distTo3DCurveEnd);
$NearPointsXYZ = NewVecOrderWithINTKey($Sorted,$NearPointsXYZ);

float $SdistTo3DCurveEnd[]; 
clear $SdistTo3DCurveEnd;
for($eachIn in $Sorted){
$SdistTo3DCurveEnd[`size($SdistTo3DCurveEnd)`] = $distTo3DCurveEnd[$eachIn];
}

int $ReducedIndex[] = floatArrayCountDuplicates($SdistTo3DCurveEnd);
vector $ReducedVec[];
$ReducedVec = NewVecOrderWithINTKey($ReducedIndex,$NearPointsXYZ);

vector $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $ReducedVec[0]);
	vector $VecLineDirMi;
	float $Additi[];
	float $AdditiB[];
	float $AdditRi;
float $AdditRiX;	
		$VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
		$Additi = $VecLineDirMi ;
		$AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
$Additi = $LineDirect_3D;
$AdditiB = $DirLineCrossXYZi ;
	$AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
// if($AdditRi = 0.0){ then snap to point IF the direction is the same

int $OntheSameLine =0;
		if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
$OntheSameLine =1;
}


vector $PointN_LineXYZ ;
float $DistSnap;
vector $SnapN;
vector $SnapPlaceN;
int $CountN=0;
for($eachVec in $ReducedVec){


vector $DirLineCrossXYZi = DirectionFN($Loc3D_Vec[0], $eachVec);
	vector $VecLineDirMi;
	float $Additi[];
	float $AdditiB[];
	float $AdditRi;
float $AdditRiX;	
		$VecLineDirMi = ($LineDirect_3D - $DirLineCrossXYZi);
		$Additi = $VecLineDirMi ;
		$AdditRi = $Additi[0]+$Additi[1]+$Additi[2];
$Additi = $LineDirect_3D;
$AdditiB = $DirLineCrossXYZi ;
	$AdditRiX = $Additi[0]+$AdditiB[0]+$Additi[1]+$AdditiB[1]+$Additi[2]+$AdditiB[2];
		if(($AdditRi == 0.0)||($AdditRiX == 0.0)){
$PointN_LineXYZ = $eachVec;
print " on same Line ";
}else{

$PointN_LineXYZ  = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $eachVec);

}

if( (distance2Pts($PointN_LineXYZ, $PointN_LineC))>0.001){
$LocsV[`size($LocsV)`] = `Loc $PointN_LineXYZ`;
$CurvesV[`size($CurvesV)`] = curve2points($eachVec, $PointN_LineXYZ);
PAUSE;
}

if($CountN==0){
 $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
$SnapN = $eachVec;
$SnapPlaceN = $PointN_LineXYZ;
}

if($CountN!=0){
print  $DistSnap;
 if((distance2Pts($PointN_LineXYZ, $PointN_LineC))<  $DistSnap){
$SnapN = $eachVec;
 $DistSnap = distance2Pts($PointN_LineXYZ, $PointN_LineC);
$SnapPlaceN = $PointN_LineXYZ;

}
}
$CountN++;
}



	vector $DirLineSnapXYZ = DirectionFN( $SnapN, $SnapPlaceN);
vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $SnapPlaceN);

delete $CurvesV;
delete $LocsV;

float $EulerAngleA[];
	//$EulerAngleA  = EulerAngB($DirLineSnapXYZ,$LineDirect_3D);
 if(($EulerAngleA[3] >85)&&($EulerAngleA[3]<95)){



float $Dist_3DSnap = distance2Pts($PointN_LineC, $SnapPlaceN);
  if($Dist_3DSnap<($Dist_3D/2.0)){
cycleBackgroundColor;
PAUSE;
	vector $VecLineDirM;
	float $Addit[];
	float $AdditR;	
		$VecLineDirM = ($DirLineAA-$DirLineBB);
		$Addit = $VecLineDirM ;
		$AdditR = $Addit[0]+$Addit[1]+$Addit[2];
int $AddInt = $AdditR;
		 if($AddInt == 0){
$PointN_LineC = $SnapPlaceN;
PAUSE; PAUSE; PAUSE;
cycleBackgroundColor;
PAUSE;
cycleBackgroundColor;
PAUSE;
cycleBackgroundColor;
PAUSE;
cycleBackgroundColor;
PAUSE;
cycleBackgroundColor;
PAUSE;
cycleBackgroundColor;
PAUSE;
 }
}
 }else{ 

if(`size($All_ZYXDiff)`> 0){
cycleBackgroundColor;
PAUSE; PAUSE;
cycleBackgroundColor;
PAUSE; PAUSE;
 $FPointN_LineC =  $PointN_LineC;
 $FPointN_LineC[$AXIS] = $newOrderFloat;
vector $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
	vector $VecLineDirM;
	float $Addit[];
	float $AdditR;	
		$VecLineDirM = ($DirLineAA-$DirLineBB);
		$Addit = $VecLineDirM ;
		$AdditR = $Addit[0]+$Addit[1]+$Addit[2];
print ("AdditR : "+$AdditR +"\n"); 
int $AddInt = $AdditR;
		 if($AddInt == 0){
print ("AdditR WENT THROUGHT: "+$AdditR +"\n"); 
$PointN_LineC = $PointN_TEMP;
cycleBackgroundColor;
PAUSE;
cycleBackgroundColor;
PAUSE;
cycleBackgroundColor;
PAUSE;
}
}


  }
 
}else{
if(`size($All_ZYXDiff)`> 0){
cycleBackgroundColor;
PAUSE; PAUSE;
cycleBackgroundColor;
PAUSE; PAUSE;
vector $PointN_TEMP = << $FPointN_LineC[0],  $FPointN_LineC[1],  $FPointN_LineC[2] >>;
vector $DirLineAA = DirectionFN($Loc3D_Vec[0], $PointN_LineC);
vector $DirLineBB = DirectionFN($Loc3D_Vec[0], $PointN_TEMP);
	vector $VecLineDirM;
	float $Addit[];
	float $AdditR;	
		$VecLineDirM = ($DirLineAA-$DirLineBB);
		$Addit = $VecLineDirM ;
		$AdditR = $Addit[0]+$Addit[1]+$Addit[2];
print ("AdditR : "+$AdditR +"\n"); 
int $AddInt = $AdditR;
		 if($AddInt == 0){
print ("AdditR WENT THROUGHT: "+$AdditR +"\n"); 
$PointN_LineC = $PointN_TEMP;
cycleBackgroundColor;
PAUSE;
cycleBackgroundColor;
PAUSE;
cycleBackgroundColor;
PAUSE;
}
}
}

//}

// $LocsV[`size($LocsV)`] = `Loc $First3dIntersect`;
// $LocsV[`size($LocsV)`] = `Loc $PointN_LineC`;	
// $CurvesV[`size($CurvesV)`] = curve2points($First3dIntersect, $PointN_LineC);

vector $Points3DPair_And_2DPair[];
$Points3DPair_And_2DPair[0]= $Loc3D_Vec[0];
$Points3DPair_And_2DPair[1]= $PointN_LineC;
$Points3DPair_And_2DPair[2]= $LocOnPlaneVec[0];
$Points3DPair_And_2DPair[3]= $NewPlanePoint;

delete $TempCrv;
string $CurvesVi = curve2points($Loc3D_Vec[0], $PointN_LineC);
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 10 -d 3 -tol 0.05 $CurvesVi;

vector $Crv_Pts[]; 
 $Crv_Pts = VecCurveEps($CurvesVi );
vector $MirrorAcrossPlaneVecs[] = VecMultMatrixMirror($Crv_Pts);
	string $TheSecondCurve = VecArrayToCurve($MirrorAcrossPlaneVecs);
//delete $CurvesV;
//delete  $LocsV;
clear $StereoCurveZ;
$BothCurves[0] = $CurvesVi;	
$BothCurves[1] = $TheSecondCurve;	
$StereoCurveZ = $BothCurves;	
	$addNumbersA =-3;
	ResetTranslation($BothCurves);
	CurveIndexVecTracking($BothCurves);  
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $BothCurves;
	evalVectorIndexAdditionSubtract;
	EVALCamScripts;
clear $StereoCurveZ;
}
return $BothCurves;
}

//////////////////////////////////////////////////////////

proc int [] floatArrayCountDuplicates(float $listX[]){
float $list[] = $listX;
	float $item, $result[], $CollectR[];
	int $index = 0;
int $X = 0;
int $Xi = 0;
int $C = 0;
int $NumberE[];
int $NoneDup[];
$result = $list;	
	for ($item in $list) {
$NumberE[$X] = floatArrayCount($item, $result);
		if (1 == $NumberE[$X]) {
		$NoneDup[`size($NoneDup)`] = $Xi;		
		}else{
		if (1 < $NumberE[$X]) {
	floatArrayRemoveAtIndex($X, $result);
	$X--;		
		}
			}
$Xi++;
$X++;	}	
	return $NoneDup;
}

//////////////////////////////////////////////////////

proc int floatArrayCount(float $item, float $list[]){
	int $result = 0;	
	float $listItem;	
	for ($listItem in $list) {
		if ($item == $listItem) $result++;	}	
	return $result;
}

proc floatArrayRemoveToIndex(int $ix, float $floatArray[]){
int $ixX= 0;
while($ixX<$ix){
floatArrayRemoveAtIndex(0, $floatArray);
$ixX++;
}
}



proc int floatArrayRemoveAtIndex( int $index, float $list[] ){
	int     $i;
	float  $result[];
	int     $len = size( $list );
 
if( $index > $len  || $index < 0 ){
		return( false );
	}
	 
for( $i = 0; $i < $index; $i++ ){
		$result[$i] = $list[$i];
	}
 
for( ; $i < $len - 1; $i++ ){
		$result[$i] = $list[$i + 1];
	}	 
	$list = $result;
	return( true );
}




////////////////////////////////

/*

 if(($XY[$TwoPointsi[0]] != $XYZadd[$TwoPointsi[0]])){
print (" !!!yes TRIGGER two HERE!!"+"\n");

}


if( (equivalentTol($XYZadd[0], $Xx,  0.1) )==1){
$ALLlikeness[`size($ALLlikeness)`] = $iVc;
}
if( (equivalentTol($XYZadd[1], $Yy,  0.1) )==1){
$ALLlikeness[`size($ALLlikeness)`] = $iVc;
}
if( (equivalentTol($XYZadd[2], $Zz,  0.1) )==1){
$ALLlikeness[`size($ALLlikeness)`] = $iVc;
}


if (( $XYZadd[0] ==$Xx)&&( $XYZadd[1] ==$Yy)){
$ALLlikeness[`size($ALLlikeness)`] = $iVc;
}

if (( $XYZadd[1] ==$Yy)&&( $XYZadd[2] ==$Zz)){
$ALLlikeness[`size($ALLlikeness)`] = $iVc;
}

if (( $XYZadd[2] ==$Zz)&&( $XYZadd[0] ==$Xx)){
$ALLlikeness[`size($ALLlikeness)`] = $iVc;
}

}
 }
		$iVc++;
}
*/

//////////////////////////////////

 /*

	float $Xx, $Yy, $Zz;
	float $Xxi, $Yyi, $Zzi;
	float $XY[];
	float $XYZi[];
	$XYZi  = $PointN_LineC;
	float $XYZadd[];
	$XYZadd  = $PointN_LineC;
$XYZi[0] = $XYZadd[0]+$XYZadd[1];
$XYZi[1] = $XYZadd[1]+$XYZadd[2];
$XYZi[2] = $XYZadd[0]+$XYZadd[2]; 	
	int $iVc=0;
vector $One;
int $TrackFoundN[];
int $TrackN[];
clear $TrackFoundN;
float $Xd;
float $Yd;
float $Zd;
int $TwoPointsi[];
if($AxisOrthoLineA ==2){
$TwoPointsi[0] = 0;
}
if($AxisOrthoLineA ==1){
$TwoPointsi[0] = 2;
}
if($AxisOrthoLineA ==0){
$TwoPointsi[0] = 1;
}
int $ALLlikeness[];
clear $ALLlikeness;
float $Dx,$Dy,$Dz;

	for ($each in $ALLLoc3D_Vec){	

	 
		 $One = $ALLLoc3D_Vec[$iVc];		
	$XY[0] = $Xx  = $One.x;
	$XY[1] = $Yy  = $One.y;
	$XY[2] = $Zz  = $One.z;


if  (( $XYZadd[0]!=0 )&&($Xx!=0)){
if  (( $XYZadd[1]!=0 )&&($Yy!=0)){
if  (( $XYZadd[2]!=0 )&&($Zz!=0)){
if($iVc==0){
 $Xd =  ($XYZi[0] - ($Xx )) ;
 $Yd =  ($XYZi[1] - ($Yy )) ;
 $Zd =  ($XYZi[2] - ($Zz)) ;
}

 if( $iVc!= $NearestIndex ){
if(($XY[$TwoPointsi[0]] != $XYZadd[$TwoPointsi[0]])){



//  if  ( (equivalentTol($XY[0], $XYZadd[0],  0.01) )==1 ){

 if (((equivalentTol( $XY[0], $XYZadd[0],  0.00001 ) )!=1 )  || ((equivalentTol($XY[1], $XYZadd[1],  0.00001))!=1) || ((equivalentTol($XY[2], $XYZadd[2],  0.00001))!=1 )){

//equivalentTol($XY[0], $XYZadd[0],  0.01) equivalentTol($XY[1], $XYZadd[1],  0.01)
//  if(  ($XY[0] == $XYZadd[0] )   ||   ($XY[1] == $XYZadd[1] )  ||   ($XY[2] == $XYZadd[2] )   ){
//  if(  ($XY[0] == $XYZadd[0] )   ||   ($XY[1] == $XYZadd[1] )  ||   ($XY[2] == $XYZadd[2] )   ){
print  " HERE PASSED ";
if($iVc==13){
print  " HERE PASSED ";
}
if($iVc==0){
 $Xd =  ($XYZi[0] - ($Xx )) ;
 $Yd =  ($XYZi[1] - ($Yy )) ;
 $Zd =  ($XYZi[2] - ($Zz)) ;
  $Dx =  `sqrt ($XYZi[0] + $Xx)`;
  $Dy =  `sqrt ($XYZi[1] + $Yy)`;
  $Dz =  `sqrt ($XYZi[2] + $Zz)`;
}
 

$ALLlikeness[`size($ALLlikeness)`] = $iVc;

if( $iVc!= 0 ){

if($Xd > ( `abs($XYZi[0] - ($Xx))` )){
$Xd = $Xx; 
$TrackN[0]= $iVc;
}
if($Xd == ( `abs($XYZi[0] - ($Xx))` )){
if(`sqrt ($XYZi[0] + $Xx)`< $Dx){
$TrackN[0]= $iVc;
  $Dx =  `sqrt ($XYZi[0] + $Xx)`;
}
}

if($Yd > ( `abs($XYZi[1] - ($Yy))` )){
$Yd = $Yy; 
$TrackN[1]= $iVc;}

if($Yd == ( `abs($XYZi[1] - ($Yy))` )){
if(`sqrt ($XYZi[1] + $Yy)`< $Dy){
$TrackN[1]= $iVc;
  $Dy =  `sqrt ($XYZi[1] + $Yy)`;
}
}

if($Zd > ( `abs($XYZi[2] - ($Zz))` )){
$Zd = $Zz; 
$TrackN[2]= $iVc;}

if($Zd == ( `abs($XYZi[2] - ($Zz))` )){
if(`sqrt ($XYZi[2] + $Zz)`< $Dz){
$TrackN[2]= $iVc;
  $Dz =  `sqrt ($XYZi[2] + $Zz)`;
}
}

}
}



///////////////

 }

}
}
}



}
		$iVc++;
	}



*/



//print $ALLlikeness;


//print $ALLlikeness;
//print $TrackN;
//print $NearestIndex


/*
if($Xd >= ( ($XYZi[0] - ($Xx+$Yy)) )){
$Xd = $Xx; 
$TrackN[0]= $iVc;
if($iVc==13){
print  " HERE1 ";
}

}


if($Yd >= ( ($XYZi[1] - ($Yy+$Zz)) )){
$Yd = $Yy; 
$TrackN[1]= $iVc;

if($iVc==13){
print  " HERE2 ";
}
}


if($Zd >= ( ($XYZi[2] - ($Xx+$Zz)) )){
$Zd = $Zz; 
$TrackN[2]= $iVc;
if($iVc==13){
print  " HERE3 ";
}




clear $NearPointsXYZ;
for($eachIn in $ALLlikeness){
$NearPointsXYZ[`size($NearPointsXYZ )`]=  $ALLLoc3D_Vec[$eachIn];

}

for($eachIn in $ALLlikeness){
select -add $AllarrayCurvesNear[$eachIn];

}
*/










proc vector [] VecMultMatrixMirror(vector $pointZ[]){

matrix $m2[4][4]= <<	-1.0, 0.0, 0.0, 0.0;
             		0.0, 1.0, 0.0, 0.0;
             		0.0, 0.0, 1.0, 0.0;
             		0.0, 0.0, 0.0, 1.0>>;

float $MatrixB[] = `MatrixToFloat($m2)`;
vector $FLoatPointA[];
for($eachVec in $pointZ){
 $FLoatPointA[`size($FLoatPointA)`] = FloatToVec(pointMatrixMult( $eachVec, $MatrixB ));
}
return $FLoatPointA;
}

////////////////////////////////

////////////////////////////////


proc vector [] MoveVectors(vector $Pos_A, vector $VecLoc, vector $Crv_Pts[]){

	vector $DirLine = DirectionFN( $VecLoc, $Pos_A);
	float $DistToPoint = distance2Pts($Pos_A, $VecLoc);

// DISTANCE TIMES DIRECTION VEC PLUS POINT VECTOR To translate
vector $TranstatedVecs[];
clear $TranstatedVecs;
for($eachVector in $Crv_Pts){
$TranstatedVecs[`size($TranstatedVecs)`] = ($eachVector+($DistToPoint*$DirLine));
}
return $TranstatedVecs;
}

////////////////////////////////

/*
// playing around  used at the end of new force othro script
vector $PointN_Line = ClosestPoint2LineVec($Dir_CamRay, $MovedEndPointPlane[0], $Loc3D_Vec[0]);  
$LocsV[`size($LocsV)`] = `Loc $PointN_Line`;
$CurvesV[`size($CurvesV)`] = curve2points($MovedEndPointPlane[0], (($Dir_CamRay*$Dist2D3D)+$MovedEndPointPlane[0]));
$CurvesV[`size($CurvesV)`] = curve2points($Loc3D_Vec[0], $PointN_Line);
vector $PointN_LineB = ClosestPoint2LineVec($LineDirect_3D, $Loc3D_Vec[0], $PointN_Line);
$LocsV[`size($LocsV)`] = `Loc $PointN_LineB`;
$CurvesV[`size($CurvesV)`] = curve2points($PointN_LineB, $PointN_Line);
*/


proc string [] VanishingCurves( string  $CurveItemA[]){

//     string  $CurveItemA[] =`ls -sl`;
	global string $VanishingPointsLinesTempGuides[];
	global int $ifSingleCurve;
string $VanishingLOC[];
//float $SnapD = 0.013;
float $SnapD = 0.003;
				global vector $TempVectorsCrv[];
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 100 -d 3 -tol 0.05 $CurveItemA[0];

 				/////////////////////
				vector $Positions[];				
				if(size($TempVectorsCrv)>0){
				clear $TempVectorsCrv;}
				$Positions = VecCurveCvs($CurveItemA[0]);				
				$TempCrv = VecArrayToCurve($Positions);

				rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $TempCrv;
				vector $PositionsZ_Ax[];				
				$PositionsZ_Ax = VecCurveEps($TempCrv);

				vector $ZYplaneMatrix[];
				$ZYplaneMatrix[0] = <<0, 0, 0>>;
				$ZYplaneMatrix[1] = <<0, 1, 0>>;
				$ZYplaneMatrix[2] = <<0, 0, 1>>;
				float $CamPos1[];
				$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
						
				$TempVectorsCrv  = LineIntersectPlaneCam( $PositionsZ_Ax, $CamPos1, $ZYplaneMatrix);
				delete $TempCrv;
				////////////////////

	float $Pi = 3.1415926535;
	float $pi = 3.1415926535;
	float $CamPos1[];
	$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
	float $CamerasDirectionVectorNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
	float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
	float $MultDirForWard[] = multiplyFloat(-1, $CamerasDirectionVector);
	float $MultDirCam[] = multiplyFloat(-3, $CamerasDirectionVector);
	float $FloatDirectionCamNormalA[] = AddFloats($CamPos1, $MultDirCam);
	float $DirectionVectorXn[] = {-2,0,0};
	float $DirectionVectorX[] = {2,0,0};
	float $DirectionVectorY[] = {0,-2,0};
	float $DirectionVectorYn[] = {0,2,0};
	float $DirectionVectorZn[] = {0,0,-2};
	float $DirectionVectorZ[] = {0,0,2};
	vector $VecDirection_A_XYZ[];
	$VecDirection_A_XYZ[0] = <<-2,0,0>>;
	$VecDirection_A_XYZ[1] = <<2,0,0>>;
	$VecDirection_A_XYZ[2] = <<0,2,0>>;
	$VecDirection_A_XYZ[3] = <<0,-2,0>>;
	$VecDirection_A_XYZ[4] = <<0,0,-2>>;
	$VecDirection_A_XYZ[5] = <<0,0,2>>;
	vector $VecDirectionXYZ[];
	$VecDirectionXYZ[0] = <<-1,0,0>>;
	$VecDirectionXYZ[1] = <<1,0,0>>;
	$VecDirectionXYZ[2] = <<0,1,0>>;
	$VecDirectionXYZ[3] = <<0,-1,0>>;
	$VecDirectionXYZ[4] = <<0,0,-1>>;
	$VecDirectionXYZ[5] = <<0,0,1>>;
	float $FloatPointDirectionXn[] = AddFloats($CamPos1, $DirectionVectorXn);
	float $FloatPointDirectionX[] = AddFloats($CamPos1, $DirectionVectorX);
	float $FloatPointDirectionY[] = AddFloats($CamPos1, $DirectionVectorY);
	float $FloatPointDirectionYn[] = AddFloats($CamPos1, $DirectionVectorYn);
	float $FloatPointDirectionZn[] = AddFloats($CamPos1, $DirectionVectorZn);
	float $FloatPointDirectionZ[] = AddFloats($CamPos1, $DirectionVectorZ);
	vector $VecXYZs[5];
	clear $VecXYZs;
	$VecXYZs[0] = FloatToVec($FloatPointDirectionXn);
	$VecXYZs[1] = FloatToVec($FloatPointDirectionX);
	$VecXYZs[2] = FloatToVec($FloatPointDirectionY);
	$VecXYZs[3] = FloatToVec($FloatPointDirectionYn);
	$VecXYZs[4] = FloatToVec($FloatPointDirectionZn);
	$VecXYZs[5] = FloatToVec($FloatPointDirectionZ);
	vector $VecXYZsOnPlane[]= VecPointsToCameraPlane($VecXYZs);
	float $AverageVecXYZsOnP[] =  AverageVectorPoint($VecXYZsOnPlane);
	string $DirectionsZ[] = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
	vector $FloatDirxyz[5];
	$FloatDirxyz[0] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[0]));
	$FloatDirxyz[1] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[1]));
	$FloatDirxyz[2] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[3]));
	$FloatDirxyz[3] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[2]));
	$FloatDirxyz[4] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[4]));
	$FloatDirxyz[5] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[5]));
	string $Alll ="";
	string $AllStrings[];
	float $AnglesAll[];
	clear $AllStrings $AnglesAll ;
	for ($eachOrthD in $VecDirectionXYZ){
		float $EulerAngleA[] = EulerAngB($eachOrthD, $CamerasDirectionVector);
		$AnglesAll[`size($AnglesAll)`]= $EulerAngleA[3];
		string $stringFloat[]= FloatArrayToStringArray($EulerAngleA);
		$Alll  = stringArrayToString($stringFloat, " ");
		$AllStrings[`size($AllStrings)`]= $Alll;
	}
	string $EmptyIndxNewOrder[];
	clear $EmptyIndxNewOrder;
	int $indexAx[] = CreateIntIndex(6);
	string $stringIndTr[]= IntArrayToStringArray($indexAx);
	float $ANgnew[] = SortFloatArrayAndString( $AnglesAll, $stringIndTr, $EmptyIndxNewOrder);
	$EmptyIndxNewOrder = ReverseStringArray($EmptyIndxNewOrder);
	string $BestThree[];
	$BestThree = {$EmptyIndxNewOrder[0], $EmptyIndxNewOrder[1], $EmptyIndxNewOrder[2]};
	$BestThree = ReverseStringArray($BestThree);
	$BestThree = stringArrayRemoveDuplicates ($BestThree);
	int $indexAxNew[] = ArrayToIntList( $BestThree);
	vector $VecCurEnds[] = VecCurveEnds($CurveItemA);

	float $LengCRV_a = `arclen $CurveItemA`;	
	float $DistEndsi; 
	$DistEndsi = distance2Pts($VecCurEnds[0], $VecCurEnds[1]);
	float $DiffMathA = $DistEndsi / ($LengCRV_a/100.0);
	
	float $AverageVecCurEndsP[] =  AverageVectorPoint($VecCurEnds);
	vector $VecXYZsOnPlaneiY[]; 
	float $FloatPointDirectionZniY[];
	float $CurveDirectionZiY[];
	float $FloatPointDirectionZniiY[];
	vector $VecXYZsOnPlaneiiY[];
	float $CurveDirectionZiiY[];
	int $Count =0;
	float  $CurvePsD[] =  DirectionF($VecCurEnds[0], $VecCurEnds[1]);
	float  $FloatPointDirectVpoint[]; 
	vector  $VecXYZsOnPlaneVpoint[];
	float  $CurveDirectionVpoint[];
	size($EmptyIndxNewOrder);
	string $DirectionsZ[] = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
	int $color;
	int $colori[];
	clear $colori;
	int $iiX =0;
	for($eachDirection in $indexAxNew){
		if($eachDirection ==0 || $eachDirection ==1){$colori[`size($colori)`] = 13;}
		if($eachDirection ==3 || $eachDirection ==2){$colori[`size($colori)`] = 14;}
		if($eachDirection ==4 || $eachDirection ==5){$colori[`size($colori)`] = 6;}
	}
	string $CurvesV[];
clear $CurvesV;
	int $Cindex =0;
	for ($eachDii in $indexAxNew){
		int $IndexZ = $indexAxNew[$Count];
		
		$FloatPointDirectionZniY  = AddFloats( $VecCurEnds[1], $VecDirection_A_XYZ[$IndexZ]);
		$VecXYZsOnPlaneiY = VecPointsToCameraPlane($FloatPointDirectionZniY);
		$CurveDirectionZiY =  DirectionF($VecCurEnds[1],  $VecXYZsOnPlaneiY[0]);
		$FloatPointDirectionZniiY = AddFloats( $VecCurEnds[0], $VecDirection_A_XYZ[$IndexZ]);
		$VecXYZsOnPlaneiiY = VecPointsToCameraPlane($FloatPointDirectionZniiY);
		$CurveDirectionZiiY =  DirectionF($VecCurEnds[0],  $VecXYZsOnPlaneiiY[0]);
		float $locsAi[] = lineIntersection($VecCurEnds[1], $CurveDirectionZiY, $VecCurEnds[0],  $CurveDirectionZiiY);
		
		$CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[0], $locsAi);
		string $CirTemp[] = `ls -sl`;
		SetItemColorString ($CirTemp[0], $colori[$Cindex]);
		$CurvesV[`size($CurvesV)`] = curve2points($VecCurEnds[1], $locsAi);
		string $CirTempi[] = `ls -sl`;
		SetItemColorString ($CirTempi[0], $colori[$Cindex]);
		editDisplayLayerMembers -noRecurse VanishingPointsLines $CurvesV;
		$Cindex++;
		$Count++;
	}
	 
	$ifSingleCurve = 0;
	string $newCurveii;
	string $CurveAv[];
	vector $PositionsZ_A[];
	vector $PositionsZ_Aii[];
	float $CamPos_A[];
	$CamPos_A = `xform -q -ws -t ZCURVEModelingCAM`;
	float $CamPos_M[] = ` MirrorFloatXYZ 0 $CamPos_A`;
	float $CamNormM[] = ` MirrorFloatXYZ 0 $MultDirCam`;		
	float $MidEpipolZx[] = MidPoint($CamPos_M, $CamPos_A);	
	float $MidEpipolPosFCam[]= FloatPointsToCamPlane($MidEpipolZx);

	DirectionFN($MidEpipolPosFCam,$VecCurEnds[1]);
	DirectionFN($VecCurEnds[0],$VecCurEnds[1]);
	vector $Line_Y_zeroMain = PositiveDirectionLine($MidEpipolPosFCam,$VecCurEnds[1]);
	vector $Dir_VecA;
	float $Addit[];
	float $AdditR;
	$Dir_VecA =   PositiveDirectionLine($VecCurEnds[0],$VecCurEnds[1]);		
	$VecLineDirM = ($Dir_VecA+$Line_Y_zeroMain);
	$Addit = $VecLineDirM ;
	$AdditR = $Addit[0]+$Addit[1]+$Addit[2];

	
	vector  $VecPtsMirrorEnds_A[];
	$VecPtsMirrorEnds_A= VecPtsToZMirrorPts( $VecCurEnds);
	vector $VIntersectEnds_A[];
	int $triggerMiddle =0;
	string $newNamesResultA1;
	string $ThreeDCurvesNear[];
	vector $ObjLoc3DCurv[];
	$VIntersectEnds_A[0] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[1], $CamPos_M, $VecPtsMirrorEnds_A[0]));
	$VIntersectEnds_A[1] = FloatToVec (lineIntersectionF($CamPos_A, $VecCurEnds[0], $CamPos_M, $VecPtsMirrorEnds_A[1]));
	string $queryLocCurveEnds3D[];
	$queryLocCurveEnds3D = `editDisplayLayerMembers  -q LocCurveEnds`;
	int $GetSizeOfCRV_ends = `size($queryLocCurveEnds3D)`;
	float $IntersectEnds_Ai[];
	float $IntersectEnds_Bi[];
	$IntersectEnds_Ai =  FloatPointsToCamPlane($VIntersectEnds_A[0]);
	$IntersectEnds_Bi = FloatPointsToCamPlane($VIntersectEnds_A[1]);
	string $CurveItemAa[] ;
	$CurveItemAa[0] = $CurveItemA[0];
	string $queryLocCurveEnds[] = queryLocOnLivePlaneBLayer(); 
	string $queryLocCurveEndsOLD[] = queryLocOnLivePlaneBLayer();
	int $edgeZsetA;
	int $edgeZsetB;
$edgeZsetA = 0;
$edgeZsetB = 0;
	string $newNames;	
	float $DistanceLocX = distance2Pts($VecCurEnds[0], $VecCurEnds[1] );
	float $NdistA,$NdistB;
	string $NearCurvesEnds[];



	if(`size($queryLocCurveEnds)` > 2){

		vector $LocCurveEndsVec[] = PointArray($queryLocCurveEnds);
		string $EmptyStringNewOrderA[];
		float $distancesEachToCurve[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[0]);
		int $NearestInt[] = SortNumbersIntIndex($distancesEachToCurve);
		$EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[0]];
		float $distancesEachToCurveB[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $VecCurEnds[1]);
		int $NearestIntB[] = SortNumbersIntIndex($distancesEachToCurveB);
		$EmptyStringNewOrderA[1] = $queryLocCurveEnds[$NearestIntB[0]];

	
		$NdistA = $distancesEachToCurve[$NearestInt[0]];
		$NdistB= $distancesEachToCurveB[$NearestIntB[0]];

	string $StringAllNearA[];
 if(($NdistA<$SnapD)||($NdistB<$SnapD)){	
	
	int $i;
int $iv =-1;
float $distsA = $NdistA;
float $distsB = $NdistB;
  for (  $i = 1; $i < 5; $i++) {
if( $distsA < $distsB){
		$NdistA = $distancesEachToCurve[$NearestInt[$i]];
if($iv==-1){
$iv++;
$StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[0]];}
  	if (equivalentTol($NdistA, $distsA, 0.001) == 1){  
$StringAllNearA[$iv++] = $queryLocCurveEnds[$NearestInt[$i]];
}
}


}

//print $StringAllNearA;
//print ("NdistA :" +$NearestInt[$i]+" "+$NdistA+"  NdistB :"+$NearestIntB[$i]+" "+$NdistB+"\n");

		$newNames = stringArrayToString( $StringAllNearA, " ");
		string $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
		string $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
		string $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
		string $arrayCurvesNearA[];
		$arrayCurvesNearA = stringToStringArray($newNamesResultC, " ");
int $CRV_index_number =0;
int $CRc =0;
int $CRcT =0;
for($eachCurve in $arrayCurvesNearA){
if(`sets -im ZEdgeCurvesSet $eachCurve` ==1){
$CRV_index_number = $CRc;
$CRcT++;
break;
}
$CRc++;
}
 
if($CRcT ==1){
$EmptyStringNewOrderA[0] = $queryLocCurveEnds[$NearestInt[$CRc]];
}
}
	
	$NdistA = $distancesEachToCurve[$NearestInt[0]];
		$NdistB= $distancesEachToCurveB[$NearestIntB[0]];
		
		$newNames = stringArrayToString($EmptyStringNewOrderA, " ");
string $newNamesResultAx = substituteAllString($newNames, "Plane", "");
		string $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
		string $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
		string $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
		string $arrayCurvesNear[];
		$arrayCurvesNear = stringToStringArray($newNamesResultC, " ");
		$NearCurvesEnds[0] = $arrayCurvesNear[0];
		$NearCurvesEnds[1] = $arrayCurvesNear[1];

	string $arrayCurvesNearA1[];
		$arrayCurvesNearA1 = stringToStringArray($newNamesResultAx, " ");

	vector $LocCurveEndsVec_3D[] = PointArray($arrayCurvesNearA1);
 
 
vector $LoCz_3D[];
$LoCz_3D = $LocCurveEndsVec_3D;

/*
	vector $FloatDirCam[1];
	$FloatDirCam[0] = FloatToVec (DirectionF($CamPos1, $VecXYZs[0]));
	$FloatDirCam[1] = FloatToVec (DirectionF($CamPos1, $VecXYZs[1]));
vector $PointN_LineA = ClosestPoint2LineVec($LineDirect_3D, $VecCurEnds[0], $LocCurveEndsVec_3D[0]);
		float $distToPlaneLoc[];
		$distToPlaneLoc[0] = distance2Pts($VecCurEndsa[0], $LocCurveEndsVec_3D[0]);
		$distToPlaneLoc[1] = distance2Pts($VecCurEndsa[1], $LocCurveEndsVec_3D[1]);                                     
float $relativeDistanceA = ($Distance_A+$distToPlaneLoc[0])/2.0;
float $relativeDistanceB = ($Distance_B+$distToPlaneLoc[1])/2.0;
*/



vector $TXI = << -1.0 , 1.0, 1.0>>;
$LoCz_3D[2] = MultVec($LoCz_3D[0],$TXI);
$LoCz_3D[3] = MultVec($LoCz_3D[1], $TXI);
for($eachItemVEC in $LoCz_3D){
$VanishingLOC[`size($VanishingLOC)`] = Loc($eachItemVEC);
string $SetCol = `setAttr ($VanishingLOC[size($VanishingLOC)-1]+".overrideColor ") 6 `;
setAttr ( $VanishingLOC[size($VanishingLOC)-1]+".scale") 5.0 5.0 5.0;
}

appendStringArray($CurvesV, $VanishingLOC, size($VanishingLOC));
//string $edgeZsetAB[] = `sets -q ZEdgeCurvesSet`;
//select -r $edgeZsetAB;
		$edgeZsetA = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[0]`;
		$edgeZsetB = `sets -im ZEdgeCurvesSet  $arrayCurvesNear[1]`;
float $ThreepointVecs[];
int $COuntN =0;
int $EDGEpoints[];
for($eachVec in $LocCurveEndsVec_3D){
$ThreepointVecs = $eachVec;
	if (equivalentTol($ThreepointVecs[0], 0.00, 0.001) == 1){  
$EDGEpoints[$COuntN]= 1;
}else{$EDGEpoints[$COuntN]= 0;}
$COuntN++;
}
	$edgeZsetA =$EDGEpoints[0];
	$edgeZsetB =$EDGEpoints[1];

 
if(($NdistA<$SnapD)||($NdistB<$SnapD)){
if(($NearCurvesEnds[0] == $NearCurvesEnds[1])&&( ($edgeZsetA+$edgeZsetB) ==2)){

	if($NdistA<$NdistB){
	$edgeZsetA =1;
	$edgeZsetB =0;
	}
	if($NdistA>$NdistB){
	$edgeZsetA =0;
	$edgeZsetB =1;
	}
if($edgeZsetA==0){$NdistA=100;}
if($edgeZsetB==0){$NdistB=100;}

}
}

if(($NdistA>$SnapD)&&($NdistB>$SnapD)){
	$edgeZsetA =0;
	$edgeZsetB =0; 
}


	}
 

int $pointNearEdgeCurve[];

if(($edgeZsetA==1)&&($NdistA<$SnapD)){
$pointNearEdgeCurve[0]= 1;
}
if(($edgeZsetA==1)&&($NdistA>$SnapD)){
$pointNearEdgeCurve[0]= 0;
}
if(($edgeZsetA==0)&&($NdistA>$SnapD)){
$pointNearEdgeCurve[0]= 0;
}
if(($edgeZsetA==0)&&($NdistA<$SnapD)){
$pointNearEdgeCurve[0]= 2;
}

if(($edgeZsetB==1)&&($NdistB<$SnapD)){
$pointNearEdgeCurve[1]= 1;
}
if(($edgeZsetB==1)&&($NdistB>$SnapD)){
$pointNearEdgeCurve[1]= 0;
}
if(($edgeZsetB==0)&&($NdistB>$SnapD)){
$pointNearEdgeCurve[1]= 0;
}
if(($edgeZsetB==0)&&($NdistB<$SnapD)){
$pointNearEdgeCurve[1]= 2;
}



/////////////////////////////////////////////
	float $EdgeDist;

	if($edgeZsetA==1){
		$EdgeDist =$NdistA;
	}else{$EdgeDist=$NdistB;}

	int $SnappingVector=0;
	float $smallestDistance;
	if($NdistA<$NdistB){
		$SnappingVector=0;
	}else{$SnappingVector=1;}
	
	 if($NdistA>$SnapD){
	 $edgeZsetA = 0;
	 }
	 	if($NdistB>$SnapD){
	 $edgeZsetB = 0;
	 }
int $OneIsNotNearThePlane =0;
if(($NdistA>$SnapD)||($NdistB<$SnapD)){
if(($NdistA<$SnapD)||($NdistB>$SnapD)){
$OneIsNotNearThePlane =1;
}
}

if(($NdistA<$SnapD)||($NdistB<$SnapD)){ 
if(($edgeZsetA==1)||($edgeZsetB==1)){
$EdgeDist =0.001;
}
}

	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




if($pointNearEdgeCurve[0]+$pointNearEdgeCurve[1]== 1){


	
			$newNamesResultA1 = substituteAllString($newNames, "Plane", "");			
			$ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
			$ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
			float $A[], $B[];
			$A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
			$A= `MakeCleanFloats($A)`;
			$B= `MakeCleanFloats($B)`;
			if(($A[0] ==0)||($B[0] ==0)){

				$triggerMiddle =2;
				$ifSingleCurve=1;
				vector $NearVecPts[];
				if($edgeZsetA==1){
					$NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
					$NearVecPts[1]= $VecCurEnds[1];
				}else{
					$NearVecPts[0]= $VecCurEnds[0];
					$NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
				}
				rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
						
				vector $PositionsZ_A[];
				clear $PositionsZ_A;
				$PositionsZ_A = VecCurveEps($CurveItemA[0]);
				vector $PositionsZ_Aii[];  
				if($EdgeDist<2.5){
			
					$PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A); 	 
					$PositionsZ_Aii = $PositionsZ_Ai;
				} 
				vector $PositionsZ_Aiix[];
				$PositionsZ_Aiix[0] = <<0, 0, 0>>;
				$PositionsZ_Aiix[1] = <<0, 1, 0>>;
				$PositionsZ_Aiix[2] = <<0, 0, 1>>;
				float $CamPos1[];
				$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
				vector $VecTest[];
				if($EdgeDist<2.5){
					$VecTest  = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
				}else{$VecTest  = LineIntersectPlaneCam($PositionsZ_A, $CamPos1, $PositionsZ_Aiix);
				}
				$CurveAv[0] = VecArrayToCurveB($VecTest);			
			}
		
	}



		if( $pointNearEdgeCurve[1]==1){

			$newNamesResultA1 = substituteAllString($newNames, "Plane", "");	 
			$ThreeDCurvesNear = stringToStringArray($newNamesResultA1, " ");
			$ObjLoc3DCurv  = PointArrayT({$ThreeDCurvesNear[0],$ThreeDCurvesNear[1]});
			float $A[], $B[];
			$A =  $ObjLoc3DCurv[0]; $B =  $ObjLoc3DCurv[1];
$A = MakeCleanFloatsZ($A);
$B = MakeCleanFloatsZ($B);

			if(($A[0] ==0)&&($B[0] ==0)){

				// NOTE these two
				$triggerMiddle =2;
				$ifSingleCurve=1;

				vector $NearVecPts[];
				$NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[0]));
				$NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($ObjLoc3DCurv[1]));
				rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];
				vector $PositionsZ_A[];
				clear $PositionsZ_A;
				$PositionsZ_A = VecCurveEps($CurveItemA[0]);
				delete $CurveItemA;
				$CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);
			
				string $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
				$evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
				eval($evalSmooth);
				vector $PositionsZ_A[];
				clear $PositionsZ_A;
				$PositionsZ_A = VecCurveEps($CurveItemA[0]);
				$PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
				vector $PositionsZ_Aii[];  	
if($DiffMathA >95.0){				 
						$PositionsZ_Aii[0] = $NearVecPts[0];
						$PositionsZ_Aii[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
						$PositionsZ_Aii[2]= $NearVecPts[1];

} else{
				$PositionsZ_Aii = $PositionsZ_Ai;}
				vector $PositionsZ_Aiix[];
				$PositionsZ_Aiix[0] = <<0, 0, 0>>;
				$PositionsZ_Aiix[1] = <<0, 1, 0>>;
				$PositionsZ_Aiix[2] = <<0, 0, 1>>;
				float $CamPos1[];
				$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
				vector $VecTest[] = LineIntersectPlaneCam( $PositionsZ_Aii, $CamPos1, $PositionsZ_Aiix);
if($DiffMathA >95.0){	$CurveAv[0] = VecArrayToCurve($VecTest);}else{
				$CurveAv[0] = VecArrayToCurve($VecTest);}
			}
		} 


		if($triggerMiddle==0){

			if($GetSizeOfCRV_ends>0){  
				vector $LocCurveEndsVec3D[] = PointArray($queryLocCurveEnds3D);
				float $distancesTo3DCurveEnd[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[0]);
				int $Sorted[] = SortNumbersIntIndex($distancesTo3DCurveEnd);
				float $NptsDist = $distancesTo3DCurveEnd[$Sorted[0]];
				float $distancesTo3DCurveEndi[] = ArrayDistancesVecTofloat($LocCurveEndsVec3D, $VIntersectEnds_A[1]);
				int $Sortedi[] = SortNumbersIntIndex($distancesTo3DCurveEndi);
				float $NptsDisti = $distancesTo3DCurveEndi[$Sortedi[0]];
				vector $FistAndSecond[];
				$FistAndSecond[0]=$LocCurveEndsVec3D[$Sorted[0]];
				$FistAndSecond[1]=$LocCurveEndsVec3D[$Sortedi[0]];
				string $LocNames[];
				$LocNames[0]=$queryLocCurveEnds3D[$Sorted[0]];
				$LocNames[1]=$queryLocCurveEnds3D[$Sortedi[0]];
				$LocNames[2]=$queryLocCurveEnds3D[$Sorted[1]];
				$LocNames[3]=$queryLocCurveEnds3D[$Sortedi[1]];
				vector $VecA= $FistAndSecond[0];
				vector $VecB= $FistAndSecond[1];
				float $XX= $VecA.x;
				float $XXX= $VecB.x;
				if( ($XX*-1)==$XXX){    
					if($NptsDist<2.5){   

						vector $NearVecPts[];
						$NearVecPts[0]= FloatToVec(FloatPointsToCamPlane($VecA));
						$NearVecPts[1]= FloatToVec(FloatPointsToCamPlane($VecB));
						rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 1 -tol 0.05 $CurveItemA[0];				 
						$PositionsZ_A = VecCurveEps($CurveItemA[0]);
						delete $CurveItemA;
						$CurveItemA[0] = VecArrayToCurveB($PositionsZ_A);
						string $evalSmooth = "smoothCurve -ch 1 -rpo 1 -s 195.5 "+  $CurveItemA[0];
						$evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
						eval($evalSmooth);
						vector $PositionsZ_A[];
						clear $PositionsZ_A;
						vector $PositionsZ_Ai[];

if($DiffMathA >95.0){
					 
						$PositionsZ_Ai[0] = $NearVecPts[0];
						$PositionsZ_Ai[1]= FloatToVec (MidPoint($NearVecPts[0],$NearVecPts[1]));
						$PositionsZ_Ai[2]= $NearVecPts[1];

}else{
						$PositionsZ_A = VecCurveEps($CurveItemA[0]);						
						$PositionsZ_Ai = Matrix_Curve_TranslationCC($VecCurEnds,$NearVecPts, $PositionsZ_A);
}
						vector $ReversePositionsZ_Ai[] = ReverseVectorArray($PositionsZ_Ai);
						vector  $PtsMirrorAi[];
						clear $PtsMirrorAi;
						$PtsMirrorAi= VecPtsToZMirrorPts($ReversePositionsZ_Ai);
						int $iiz = 0;
						vector $XIntersect_Ax[];
						clear $XIntersect_Ax;
						for ($eachVecx in  $ReversePositionsZ_Ai){
							$XIntersect_Ax[`size($XIntersect_Ax)`] = FloatToVec (lineIntersectionF($CamPos_A, $PositionsZ_Ai[$iiz], $CamPos_M, $PtsMirrorAi[$iiz]));		
							$iiz++;
						}
if($DiffMathA >95.0){
$XIntersect_Ax[1]= FloatToVec (MidPoint($XIntersect_Ax[0],$XIntersect_Ax[2]));
}

						$CurveAv =  VecArrayToSplitCurve($XIntersect_Ax);
						rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];
						rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];
						string $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
						$evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
						eval($evalSmooth);
						string $evalSmoothi = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[1];
						$evalSmoothi += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
						eval($evalSmoothi);
						$ifSingleCurve=1;
					}
				} 
			}
		}
	
	$VanishingPointsLinesTempGuides = $CurvesV;
	if(( $ifSingleCurve == 1)&&($triggerMiddle ==0)){
		delete $CurveItemA[0];
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];	
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];	
		ResetTranslation($CurveAv);
		CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
		editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[1];
		sets -include ZEdgeCurvesSet $CurveAv;
	}else{
		if(( $ifSingleCurve == 1)&&($triggerMiddle ==1)){
			delete $CurveItemA[0];
			rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[0];	
			rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv[1];	
			ResetTranslation($CurveAv);
			CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
		} 
	}

	 if( ($ifSingleCurve == 1)&&($triggerMiddle ==2)){
		delete $CurveItemA[0];
	 	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 20 -d 3 -tol 0.05 $CurveAv;
		string $evalSmooth = "smoothCurve -ch 0 -rpo 1 -s  195.5 "+ $CurveAv[0];
						$evalSmooth += ".cv" + "\[" + "\"" +"\*"+"\""+"\]";
						eval($evalSmooth);
	 	sets -include ZEdgeCurvesSet $CurveAv;
		ResetTranslation($CurveAv);
		CurveIndexVecTracking($CurveAv);  editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $CurveAv[0];
	 }
return $CurvesV;
} 

proc vector [] VecPointsToCameraPlane(vector $V[]){
	vector $p = `xform -q -ws -t "LiveSurfaceB"`;
	vector $C = `xform -q -ws -t ZCURVEModelingCAM`;
	vector $n1 = nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0); 
	float $D, $D1;	
	vector $F, $e, $M, $F1, $P, $F2, $P1, $F3, $F4, $O[]; 	 
	int $C1;
	$C1=0; 
	for($e in $V){
		$F = DirectionF($C, $e);
		$M = $e+($F);
		$D = distance2Pts($e, $p);
		$F2 = $p+($D*$n1);	
		$P1 = ClosestPoint2LineVec($n1, $p, $e);
		$F3 = DirectionF($P1, $p);
		$D1 = distance2Pts($P1, $p);
		$F4 = $e+($D1*$F3);
		$P = ClosestPoint2LineVec(DirectionF($P1, $p), $e, $M);
		$F1 = DirectionF($P, $M);
		$O[$C1] = FloatToVec (lineIntersection($F4, $F1, $e, $F));	
		$C1++;
	}	 
	return $O;
}
