
/////////        ThreeCirclesMakeMiddleCi    //////////




//Select two locators and one circle
string $LocSel[] = `ls -sl`;
vector $Vec[] = PointArrayT($LocSel);

float $ObjsCirclesRad = CirclesRadius({$LocSel[2]});

vector $VecLineDir = PositiveDirectionLine($Vec[0], $Vec[1]);
float $PointN[] = ClosestPoint2Line($VecLineDir, $Vec[0], $Vec[2]);
float $Di = distance2Pts( $Vec[2] , $PointN);
float $DiffL = ($ObjsCirclesRad-$Di)*2.0;
int $returnValue=0;
if($Di<$ObjsCirclesRad){
$returnValue =1;}
if($Di==$ObjsCirclesRad){
$returnValue =0;}
if($Di>$ObjsCirclesRad){
$returnValue =-1;}

if($returnValue==1){
float $FloatDirXn[] = DirectionF( $Vec[2], $Vec[0]);

 float $PointNii[] = MultLenToDirAddToPoint($Di, DirectionF( $Vec[2], $PointN), $PointN);
Loc $PointNii;
float $DistAddiR2 = $Di*2.0;
float $HightD = sqrt (abs ((`pow $Di 2`) - (`pow $ObjsCirclesRad 2`)));

 float $PointNiii[] = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[1], $Vec[0]), $PointN);
Loc $PointNiii;
 float $PointNiiiB[] = MultLenToDirAddToPoint($HightD, DirectionF( $Vec[0], $Vec[1]), $PointN);
Loc $PointNiiiB;

curve2points($PointNiii,$PointNiiiB);

}

/////////////////////////////////////
////////////////////////////////////

////////// add into this






////////// add into this

///select two Circles..


proc IntersectTwoCircles(){

vector $directionABs[];
vector $PosABs[];
float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
//float $FloatDirXn[] = DirectionF($AverageVecXYZsOnP, $VecXYZs[0]);
float $R1=$ObjsCircles[0];
float $R2=$ObjsCircles[1];

//print $directionABs;
vector $VperpCirc = crossProduct( $directionABs[1], $directionABs[2], 0, 0 );

// P is the distance between 2 circles
float $P = $ObjsCircles[2];
float $r1 = $R1;
float $r2 = $R2;

	float $Pi = 3.1415926535;
	float $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1)));
	float $AngleNPi =  ($Arcangle*180.0)/$Pi;
	float $AngleN = $AngleNPi;
	float $Lengths[] = HightsOfIsoscelesTriangle($P, $r1, $r2);


float $allRadii[];
clear $allRadii;
vector $AllPos[];
clear $AllPos;
//are circles inside each other
float $distRad = distance2Pts($PosABs[0],$PosABs[1])-(abs ($r1+$r2));

//toward Each other

 float $PointNx[] = MultLenToDirAddToPoint(abs (distance2Pts($PosABs[0],$PosABs[1])-$r1), DirectionF( $PosABs[1], $PosABs[0]), $PosABs[1]);
Loc  $PointNx;
 float $PointNz[] = MultLenToDirAddToPoint(abs ($r2), DirectionF( $PosABs[1], $PosABs[0]), $PosABs[1]);
Loc  $PointNz;
vector $MidPtC = FloatToVec (MidPoint($PointNx,$PointNz));

float $Di = distance2Pts( $MidPtC , $PosABs[0]);
//float $DistAddiR2 = $Di*2.0;
//float $HightD = sqrt (abs ((`pow $Di 2`) - (`pow $ObjsCircles[1] 2`)));
//Loc $MidPtC;

// float $PointNiii[] = MultLenToDirAddToPoint($HightD, $VperpCirc, $MidPtC);
//Loc $PointNiii;



float $MidPointsA[];
	$MidPointsA = $MidPtC;

	float $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
	float $distCircToMidZ = distance2Pts ($PointNx, $PointNz);

	float $rRiP = $R1 + $R2;
	float $PercentA = ((  $R2 /$rRiP) * (100.0) );
	float $percentOf = $distCircToMidZ/ (100.0/$PercentA);
	float $distCircToMidA = $R1 - $percentOf;
	float $MultDirPCRr1[] = multiplyFloat($distCircToMidA, $directionABs[0]);
	float $AddMultDirPCRr1[] = AddFloats($PosABs[0], $MultDirPCRr1);
	spaceLocator -p 0 0 0;
	MoveObject2($AddMultDirPCRr1);


	$AngleN = $Arcangle;
	float $tsDAR = ( $AngleN)*-1;
	float $tsDBR = ( $AngleN)*1;

	float $rotatsA[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
	float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
	float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
	spaceLocator -p 0 0 0;
	MoveObject2($AddMultDirPCA1);

	float $rotatsB[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
	float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
	float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
	spaceLocator -p 0 0 0;
	MoveObject2($AddMultDirPCA2);
	
	curve2points($AddMultDirPCA1, $AddMultDirPCA2);
	

}







proc ThreeCirclesMakeMiddleCi(){
string $ObjectItemC[];
 $ObjectItemC = `ls -sl`;

vector $directionABs[];
vector $PosABs[];
clear $PosABs;
float $ObjsCircles[];
 $ObjsCircles  = CirclesRadiusDirectionZ($directionABs, $PosABs);
int $SizeN = `size($ObjectItemC)`;

int $N[] = CreateIntIndex(3);
vector $pointOnlineV[];
float $RadiiMdist;
float $NewMidCC[];
float $NewMidCCi[];
vector $CRmidPts[];
vector $all_intersectsV[];



///select -r $ObjectItemC[$N[0]] $ObjectItemC[$N[1]];
int $b;
  for($b = 0; $b < ($SizeN);$b++){
vector $DirecA = FloatToVec(DirectionFN($PosABs[$N[1]],$PosABs[$N[0]]));

 $RadiiMdist = (distance2Pts( $PosABs[$N[0]], $PosABs[$N[1]] ))-($ObjsCircles[$N[0]]+$ObjsCircles[$N[1]]);
 $NewMidCC =  MultLenToDirAddToPoint(($ObjsCircles[$N[0]]+($RadiiMdist/2.0)), $DirecA, $PosABs[$N[0]]);
Loc $NewMidCC;
$CRmidPts[$b] = FloatToVec( $NewMidCC );

$N = CycleInt($N);
}

print $CRmidPts;
vector $MidAverage = FloatToVec( AverageVectorPoint($CRmidPts));
Loc $MidAverage;


vector $CRmidPtsB[];
clear $CRmidPtsB;

int $b;
$b = 0;
  for($b = 0; $b < ($SizeN);$b++){
vector $DirecA = FloatToVec(DirectionFN($PosABs[$N[0]],$MidAverage));

 $RadiiMdist = (distance2Pts( $PosABs[$N[0]], $MidAverage ))-($ObjsCircles[$N[0]]);
 $NewMidCC =  MultLenToDirAddToPoint(($RadiiMdist), $DirecA, $MidAverage);
Loc $NewMidCC;
$CRmidPtsB[$b] = FloatToVec( $NewMidCC );

$N = CycleInt($N);
}


vector $CRmidPtsC[];
Circle3PtZFloatsIII($CRmidPtsB[0], $CRmidPtsB[1], $CRmidPtsB[2]);
string $NewCircle[] = `ls -sl`;
ResetTransEachSL;
int $b;
$b = 0;
  for($b = 0; $b < ($SizeN);$b++){

select -r $NewCircle[0] $ObjectItemC[$N[0]];
$all_intersectsV[$b] = `IntersectTwoCircles`;
vector $DirecB = FloatToVec(DirectionFN($all_intersectsV[$b],$PosABs[$N[0]]));
 $NewMidCCi =  MultLenToDirAddToPoint($ObjsCircles[$N[0]], $DirecB, $PosABs[$N[0]]);
Loc $NewMidCCi;
$CRmidPtsC[$b] = FloatToVec( $NewMidCCi );
$N = CycleInt($N);
}

delete $NewCircle[0];

Circle3PtZFloatsIII($CRmidPtsC[0], $CRmidPtsC[1], $CRmidPtsC[2]);
ResetTransEachSL;
}



