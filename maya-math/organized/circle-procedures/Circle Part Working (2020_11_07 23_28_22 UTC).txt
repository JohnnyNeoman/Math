proc appendAll(string $to[], string $from[]){
appendStringArray($to, $from, size($from));
}


proc CPOC(){
string $TwoItemz[] = `ls -sl`;
 string $LocatorTrans[] = `spaceLocator`;
 string $LocatorCPOC= ClosestPOC($TwoItemz[0], $LocatorTrans[0]);
select -r $LocatorTrans $LocatorCPOC;
pm_connectWithCurve;
select -r $LocatorTrans;
}

proc CPOS(){
string $TwoItemz[] = `ls -sl`;
 string $LocatorTrans[] = `spaceLocator`;
 string $LocatorCPOC= ClosestPOS($TwoItemz[0], $LocatorTrans[0]);
select -r $LocatorTrans $LocatorCPOC;
pm_connectWithCurve;
select -r $LocatorTrans;
}

proc Move(float $Point[], string $name){
move  -ws $Point[0] $Point[1] $Point[2] $name;
}




proc string curve2points(float $TanEnd1[], float $intersectposD1[]){

float $CircleDistanceAB = `getDistance $TanEnd1 $intersectposD1`;
int $RDistAB = RoundFloat($CircleDistanceAB, 0.0);

float $MiddlePoint1[] = MidPoint($TanEnd1, $intersectposD1);
float $CircleDistanceAM1 = `getDistance $TanEnd1 $MiddlePoint1`;
int $RDistM1 =  RoundFloat($CircleDistanceAM1, 0.0);

float $MiddlePointA1[] = MidPoint($TanEnd1, $MiddlePoint1);
float $MiddlePointB1[] = MidPoint($MiddlePoint1, $intersectposD1);

string $CurveMade = `curve -d 3 
-p $TanEnd1[0] $TanEnd1[1] $TanEnd1[2] 
-p $MiddlePointA1[0] $MiddlePointA1[1] $MiddlePointA1[2] 
-p $MiddlePoint1[0] $MiddlePoint1[1] $MiddlePoint1[2] 
-p $MiddlePointB1[0] $MiddlePointB1[1] $MiddlePointB1[2]  
-p $intersectposD1[0] $intersectposD1[1] $intersectposD1[2]  -k 0 -k 0 -k 0 -k $RDistM1 -k $RDistAB -k $RDistAB -k $RDistAB` ;
return $CurveMade;
}





	proc string ClosestPOS(string $mySurf, string $toObject){
 $myCPOC = `createNode closestPointOnMesh`;
makeIdentity -apply true -t 0 -r 0 -s 1 -n 0 $mySurf;
      connectAttr ($mySurf+".worldMesh") ($myCPOC+".inMesh");
      string $Locator[] = `spaceLocator`;      
      connectAttr ($myCPOC+".position") ($Locator[0]+".translate");  
      connectAttr ($toObject+".translate") ($myCPOC+".inPosition");
select -r $toObject;
return $myCPOC;
}


	proc string ClosestPOC(string $myCurve, string $toObject){
 $myCPOC = `createNode closestPointOnCurve`;
      connectAttr ($myCurve+".worldSpace") ($myCPOC+".inCurve");
      string $Locator[] = `spaceLocator`;      
      connectAttr ($myCPOC+".position") ($Locator[0]+".translate");  
      connectAttr ($toObject+".translate") ($myCPOC+".inPosition");
return $Locator[0];
}


proc float[] DirectionF(float $EACHCVposAZ[], float $EACHCVposBZ[]){

vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
float $MagVectorZ1 = mag($vectorZ1); 
float $MagVectorZ2 = mag($vectorZ2);
float $EACHCVposHigher[];
float $EACHCVposLower[];
$EACHCVposHigher = $EACHCVposBZ;
$EACHCVposLower = $EACHCVposAZ;

/////////////////////////////////////
vector $UnitVectorMagPosHigher[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
float $vector_SubUnitMagVec1[];
$vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 

vector $UnitVectorMagPosLower[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
float $vector_SubUnitMagVec2[];
$vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]); 

vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
float $UnitDirection[] = $vectorUnit;
///////////////////////////////////////////////// ////
return $UnitDirection;
}

proc float[] DirectionFString(string $twoItem[]){
string $twoItem[];
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
for ($eachZA in $twoItem) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}
vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
float $MagVectorZ1 = mag($vectorZ1); 
float $MagVectorZ2 = mag($vectorZ2);
float $EACHCVposHigher[];
float $EACHCVposLower[];
$EACHCVposHigher = $EACHCVposBZ;
$EACHCVposLower = $EACHCVposAZ;

/////////////////////////////////////
vector $UnitVectorMagPosHigher[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
float $vector_SubUnitMagVec1[];
$vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 
vector $UnitVectorMagPosLower[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
float $vector_SubUnitMagVec2[];
$vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]); 
vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
float $UnitDirection[] = $vectorUnit;
///////////////////////////////////////////////// ////
return $UnitDirection;
}



proc CurveExtrude(){
xform -cp;
string $selectedCurves[] = `ls -sl`;
string $allCurve[];
for ($each in $selectedCurves){
string $newcurves[] = `duplicate -rr $each `;
appendStringArray ($allCurve, $newcurves, 1);
loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true $each $newcurves[0];
}
select -r $allCurve;
xform -cp;
}



proc float[] DirectionTwoPoints(float $EACHCVposAZ[], float $EACHCVposBZ[]){
string $CurveItem[];

vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
float $MagVectorZ1 = mag($vectorZ1); 
float $MagVectorZ2 = mag($vectorZ2);
float $EACHCVposHigher[];
float $EACHCVposLower[];
$EACHCVposHigher = $EACHCVposBZ;
$EACHCVposLower = $EACHCVposAZ;
/////////////////////////////////////
vector $UnitVectorMagPosHigher[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
float $vector_SubUnitMagVec1[];
$vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 
vector $UnitVectorMagPosLower[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
float $vector_SubUnitMagVec2[];
$vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]); 
vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
float $UnitDirection[] = $vectorUnit;
///////////////////////////////////////////////// ////
return $UnitDirection;
}


proc float[] DirectionFromFirst2SecondPoint(){
string $CurveItem[];
$twoItem = `ls -sl -fl`;

float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
for ($eachZA in $twoItem) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}

vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
float $MagVectorZ1 = mag($vectorZ1); 
float $MagVectorZ2 = mag($vectorZ2);
float $EACHCVposHigher[];
float $EACHCVposLower[];
$EACHCVposHigher = $EACHCVposBZ;
$EACHCVposLower = $EACHCVposAZ;

/////////////////////////////////////
vector $UnitVectorMagPosHigher[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
float $vector_SubUnitMagVec1[];
$vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 

vector $UnitVectorMagPosLower[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
float $vector_SubUnitMagVec2[];
$vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]); 

vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
float $UnitDirection[] = $vectorUnit;
///////////////////////////////////////////////// ////
return $UnitDirection;
}



	proc float getCurveLength( string $curve){
string $arcLenNode = `createNode arcLengthDimension`;
connectAttr -f ( $curve + ".worldSpace[0]" ) ( $arcLenNode + ".nurbsGeometry" );
setAttr ( $arcLenNode + ".uParamValue" ) `getAttr ( $curve + ".maxValue" )`;
float $curveLength = `getAttr ( $arcLenNode + ".arcLength" )`;
string $parent[] = `listRelatives -p $arcLenNode`;
//delete $parent;
return $curveLength;
}




proc vector[] getpositions(string $objectlist[]){

vector $pointsV[];
string $objectlistF[] = `ls -fl $objectlist`;
int $iX = 0;
for ($each in $objectlistF){
if (catch($pointsV[$iX] = `pointPosition -w  $each`)){
$pointsV[$iX] = `xform -q -ws - rp $each`;
	} 
$iX++;
}
return $pointsV; 
}


proc float[] Matrix4ToFloat(matrix $m[][]){
float $MatrixPoints[];
$MatrixPoints = {($m[0][0]), ($m[0][1]), ($m[0][2]), ($m[0][3]), 
                 ($m[1][0]), ($m[1][1]), ($m[1][2]), ($m[1][3]), 
                 ($m[2][0]), ($m[2][1]), ($m[2][2]), ($m[2][3]), 
                 ($m[3][0]), ($m[3][1]), ($m[3][2]), ($m[3][3])};
return $MatrixPoints;
}


proc CurveExtrude(){

xform -cp;
string $selectedCurves[] = `ls -sl`;
string $allCurve[];
for ($each in $selectedCurves){
string $newcurves[] = `duplicate -rr $each `;
scaleConstraint -offset 1 1 1 -weight 1 $each $newcurves[0];
appendStringArray ($allCurve, $newcurves, 1);
loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true $each $newcurves[0];
}
select -r $allCurve;
xform -cp;
}

//CurveExtrude;


proc float linearToInternal( float $linear )
{
  float $factor = 1.0;
  string $pref = `currentUnit -q -l`;
  if ( "mm" == $pref ) $factor = 0.1;
  if ( "m" == $pref ) $factor = 100.0;
  if ( "inch" == $pref ) $factor = 2.54;
  if ( "ft" == $pref ) $factor = 30.48;
  if ( "yard" == $pref ) $factor = 91.44;

  return ( $linear * $factor );
}



proc float linear_to_internal( float $linear )
{
  float $factor = 1.0;
  string $pref = `currentUnit -q -l`;
  if ( "mm" == $pref ) $factor = 0.1;
  if ( "m" == $pref ) $factor = 100.0;
  if ( "inch" == $pref ) $factor = 2.54;
  if ( "ft" == $pref ) $factor = 30.48;
  if ( "yard" == $pref ) $factor = 91.44;

  return ( $linear * $factor );
}

proc float linear_to_ui( float $linear )
{
  float $factor = 1.0;
  string $pref = `currentUnit -q -l`;
  if ( "mm" == $pref ) $factor = 10.0;
  if ( "m" == $pref ) $factor = 0.01;
  if ( "inch" == $pref ) $factor = 0.3937007874;
  if ( "ft" == $pref ) $factor = 0.03280839895;
  if ( "yard" == $pref ) $factor = 0.01093613298;

  return ( $linear * $factor );
}


proc float angle_to_internal( float $angle )
{
  string $pref = `currentUnit -q -a`;
  if ( "deg" == $pref )
  {
    $angle = $angle * 0.0174532925;
  }

  return $angle;
}


proc appendAll(string $to[], string $from[]){
appendStringArray($to, $from, size($from));
}






proc float[] facenormal(string $selObj[]){
string $stringFaceNormalZ[] = `polyInfo -faceNormals $selObj[0]`;
string $buffer[];
int $numTokens;
  $numTokens = `tokenize $stringFaceNormalZ[0] ":" $buffer`;
string $stringFaceNormalZ2[] = {$buffer[1]};
string $stringFaceNor = $buffer[1];
string $buffer2[];
int $numTokens2;
$numTokens2 = `tokenize $stringFaceNor " " $buffer2`;
float $TheNormal[] = stringtofloat($buffer2);
return $TheNormal;
}

proc float[] stringtofloat(string $bufferA[]){
string $buffer1 = $bufferA[0];
string $buffer2 = $bufferA[1];
string $buffer3 = $bufferA[2];
float $TheNormalX = $buffer1;
float $TheNormalY = $buffer2;
float $TheNormalZ = $buffer3;
float $TheNormalAll[] = { $TheNormalX, $TheNormalY, $TheNormalZ };
return $TheNormalAll;
}



proc int CurveEPnumber(string $myCurve){
string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
return $numEPrealNum;
}

proc string[] StartofCurveScriptRetopo2(string  $captureCurveName[]){

Removefromsurface;
string $objectcurv[];
$objectcurv = `ls -sl`;
string $myCurve = $objectcurv[0];

int $curveTypeSwitchC = `IsCircle`;

if ( $curveTypeSwitchC == 1 ){
string $newCircle[] = `CIRCLESCRIPTZ ($objectcurv)`;
rotate -r -os 90 0 0 ;
}

float $arcL1 = `arclen $myCurve`;

//float $arcL2 = ( $arcL1 / 1.5 );
string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPRebuildNum = ($numEPrealNum * 2 );  
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s $numEPRebuildNum -d 3 -tol  0.001 $myCurve;

//CopySelected;  DUPLICATE IT 
string $DupicateZ[] = `duplicate -rr $myCurve`;
select -r $myCurve;
SmoothCurvatureB3(0.1);
float $arcL2 = `arclen $myCurve`;
print $arcL1;
print $arcL2;
print $myCurve;
print $DupicateZ;
select -r $DupicateZ;

float $percentDIffZ = PercentDiff_Curve_to_Arc($arcL2,$arcL1);
int $curveEPsZ = CurveEPnumber($myCurve);

if (($percentDIffZ < 98.0)||($curveEPsZ < 5)) {  delete $myCurve;
rename $DupicateZ[0] $myCurve;
$DupicateZ = `duplicate -rr $myCurve`;
select -r $myCurve;
SmoothCurvatureB3($arcL1);
float $arcL3 = `arclen $myCurve`;
int $curveEPsZ2 = CurveEPnumber($myCurve);
float $percentDIffZ2 = PercentDiff_Curve_to_Arc($arcL3,$arcL1);
//ERROR here
if ($percentDIffZ2 > 98.0){ delete $DupicateZ[0];
select -r $myCurve;} else {
delete $myCurve;
rename $DupicateZ[0] $myCurve;
select -r $myCurve;
}
}else{  delete $DupicateZ[0];
select -r $myCurve;}

string $digitalSkeleton[];
$numInts = size($digitalSkeleton);
if ( $numInts > 0 ){
clear $digitalSkeleton;
}

string $CurveItemA = $objectcurv[0];
string $CurveSelection[] = `ls -fl  ($CurveItemA+".ep[0:*]")`; 
string $CurveEPzCount = size ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
//float $arcL4 = `arclen $myCurve`;


///////////////GATHER ALL BUILDING  STRUCTURE/////////##
appendStringArray($digitalSkeleton, $objectcurv,  1);
///////////////////////////////////////////////// ////##
float $EACHCVposA[];
float $EACHCVposB[];	
string $AllIntersectCurveZ[];
$numInts = size($AllIntersectCurveZ);
if ( $numInts > 0 ){
clear $AllIntersectCurveZ;
}
string $IntersectCurves[];
string $MakeExtrudeSurface[];
string $MakeBirailSurface[];
string $MakeXBetween[];
string $MakeIntersectCurvez[];
string $MakespaceLocator[];
 float $eachCVpos[];
	string $each;
for ($each in $CurveSelection) {     	
	$eachCVpos = `pointPosition -w  $each`;
$MakeIntersectCurvez[0] = `curve -d 1 -p 0 0 0 -p  12 0 0 -k 0 -k 1 -n IntersectCurve` ;
appendStringArray($AllIntersectCurveZ,  $MakeIntersectCurvez, 1);
$numInts = size($AllIntersectCurveZ);
extendCurvePresetArgList( "2", {"0",  "0","0","0","100","0","0","0","0","1","1","1"} );

rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 2 -kcp  0 -kep 1 -kt 0 -s 22 -d 3 -tol 0.001 ;
move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakeIntersectCurvez[0];
//PAUSE;
aimConstraint -offset 0 0 0 -weight 0.5 - aimVector -1 0 0 -upVector 0 0 -1 -worldUpType  "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM    $MakeIntersectCurvez[0];
//PAUSE;
}
print $AllIntersectCurveZ;
$captureCurveName = $objectcurv;
select -r $captureCurveName;
delete $objectcurv;
return $AllIntersectCurveZ;
}



proc string[] SmoothCurvatureB3(float $curveM ){

string $curves[] = `ls -sl`;
string $myCurve = $curves[0];
rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 2 ); 
//Above was Times * 4 

string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`; 
$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
	float $step = $numEPrealNum2;  
	$curve = "curve -d 3";
	float $curveMin = $curveM;
int $Par = 0;
int $a;
int $ii = 0;	
  for($a = 0; $a <= $step;$a++){
$ii = $ii + 1;
  	$t =  $a/$step;
 	$Par = ($a/$step);
	setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
  	float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
	float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
		if ( $CurvatureRadi <=  $curveMin){ PAUSE;
	$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
	}

if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
}


if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
}

}

string $Newcurvez = `eval($curve)`;
string $Newcurve[] = {$Newcurvez};
delete $paramlocatorpointOnCurvex $spaceLocatorB; 
delete $curves;
rename $Newcurve $myCurve;  
$Newcurve = {$myCurve};

return $Newcurve; 
}


proc float PercentDiff_Curve_to_Arc(float  $arclenghtzARC, float $arclenghtzDRAWN){

float $FLOAT1;
float $FLOAT2;
if($arclenghtzARC < $arclenghtzDRAWN){
$FLOAT1 = $arclenghtzARC; $FLOAT2 = $arclenghtzDRAWN;}
if($arclenghtzARC > $arclenghtzDRAWN){
$FLOAT1 = $arclenghtzDRAWN; $FLOAT2 = $arclenghtzARC; }
float $PercentA;

if($arclenghtzARC == $arclenghtzDRAWN){
$PercentA = 0;}else{
$PercentA = ((float($FLOAT1) / $FLOAT2) * (100) ); }
return $PercentA;
}



/*
//print ("cycle "+$XiX);
//print ("Gate2 "+$Gate2);
//print ("a "+$a);
print $a;
//$a3 = $A2;
//print $a;
//PointsGetDistanceFLOAT($valuesC, $valuesA);
// Result: 0.127273 // 
//Editing Here <=  float $OneUnitFirstStep =   112/10.181818;    float $UnitLOne = 10.181818 /  2; //0.127273
//float $UnitLOneTest2 = ($UnitLOne / 40);
//68.398615 58.339062
// float $UnitLOneTest = 0.127273 * 40;
//############################  
// float $UnitLOneTest2 = ($UnitLOne / 40);
//############################
 //$UnitDistance  = $UnitDistanceA;
// 10.181818 // 
//$UnitDistanceHalf = $UnitDistance/2;
// 5.090909 // 
//  float $OneUnitFirstStepB =  $UnitLOne/11;   float $OneUnitFirstStepC = (($OneUnitFirstStepB)  /($OneUnitFirstStep))*(110)/2; 


print ($UnitDistance + "\n");
print ($DistanceAB   + "\n");
print ($DivideTotalWithUnit + "\n");
print ($PercentDistanceZ + "\n");
print ($RDivideTotalWithUnit + "\n");
print ($a + "\n");
print ($A2 + "\n");
//if ( $DistanceAB <= $DistanceFourth ){  polySphere -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 - ch 1; 
//print ("0000  At One Fourth Distance  0000" +  "\n");  }
print ($switchN  + "\n");
print ($triggerA  + "\n");
print ($DistanceAB   + "\n");
print ($DistanceCD   + "\n");
print ($DivideTotalWithUnit   + "\n"); 
*/

if ( `objExists NurbsPlanes` == 0  ) {
createDisplayLayer -name "NurbsPlanes" - number 1 -empty;
setAttr NurbsPlanes.color 30;
}
if ( `objExists IntersectFormLayer` == 0  ) {
createDisplayLayer -name "IntersectFormLayer" - number 1 -empty;
setAttr IntersectFormLayer.color 30;
}
if ( `objExists IntersectFormLayerOutofRange` ==  0  ) {
createDisplayLayer -name  "IntersectFormLayerOutofRange" -number 1 -empty;
setAttr IntersectFormLayerOutofRange.color 2;
}
if ( `objExists IntersectFormLayerINRange` == 0   ) {
createDisplayLayer -name  "IntersectFormLayerINRange" -number 1 -empty;
setAttr IntersectFormLayerINRange.color 3;
}
if ( `objExists layerYZYXPlains` == 0  ) {
createDisplayLayer -name "layerYZYXPlains" - number 1 -empty;
}
if ( `objExists layerAllCurves1` == 0  ) {
createDisplayLayer -name "layerAllCurves1" - number 1 -empty;
}
if ( `objExists layerEdgeCurveZ1` == 0  ) {
createDisplayLayer -name "layerEdgeCurveZ1" - number 1 -empty;
}
if ( `objExists layerCurvesOutofRange1` == 0  ) {
createDisplayLayer -name "layerCurvesOutofRange1"  -number 1 -empty;
setAttr layerCurvesOutofRange1.color 12;
}
if ( `objExists layerCurvesINRange1` == 0  ) {
createDisplayLayer -name "layerCurvesINRange1" - number 1 -empty;
setAttr layerCurvesINRange1.color 6;
}
if ( `objExists TheLastCurvesSet` == 0  ) {
string $newSet3 = `sets -name TheLastCurvesSet`;
}
if ( `objExists ZEdgeCurvesSet` == 0  ) {
string $newSet1 = `sets -name ZEdgeCurvesSet`;
}
if ( `objExists ZPlaneCurvesSet` == 0  ) {
string $newSet2 = `sets -name ZPlaneCurvesSet`;
}


//ALL GLOBAL INT#######################//
//ALL GLOBAL INT#######################//
//ALL GLOBAL INT#######################//

global int $xii;
global int $xii = 0;

int $script_jobToolChangedNum1 = 505;
int $script_jobToolChangedNum2 = 606;
int $scriptt_jobAllCurvesToolsNumA;
int $scriptt_jobAllCurvesToolsNumB;

//WHat it does : scriptjob that runs when camera is translated or rotated //
int $jobNumtranslateCAM;
int $jobNumrotateCAM;

//WHat it does :  keeps track on number of curve strokes drawn //
int $addNumbersA;
$addNumbersA = 0;

global int $script_jobNumIdle_MoveZCURVEM;
global string $dialogBoxWin;

//WHat it does : string collects all curves created with script //
global string $EdgeCurveZ2[];
global int $plainNum;
clear $EdgeCurveZ2;

//WHat it does : draw a strait line in some otho direction... draw a wiggly line.. draw a circle and see what happens
global int $plainNum = 0;

//////////////////
global string $CamConeLocator[];
string $newCAMSet1;
/////////////////
//ALL GLOBAL INT#######################//
//ALL GLOBAL INT#######################//
//ALL GLOBAL INT#######################//



proc int AddorSubtract(int $Number, int $AorS){
if ($AorS == 1){ $Number++; return $Number; } 
if ($AorS == 0){ $Number--; return $Number; }
if ($AorS == 2){ $Number = 0; return $Number; }  
}




proc int CurveEPnumber(string $myCurve){
string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
return $numEPrealNum;
}

proc string[] StartofCurveScriptRetopo2(string  $captureCurveName[]){

Removefromsurface;
string $objectcurv[];
$objectcurv = `ls -sl`;
string $myCurve = $objectcurv[0];



float $arcL1 = `arclen $myCurve`;

//float $arcL2 = ( $arcL1 / 1.5 );
string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPRebuildNum = ($numEPrealNum * 2 );  
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s $numEPRebuildNum -d 3 -tol  0.001 $myCurve;

//CopySelected;  DUPLICATE IT 
string $DupicateZ[] = `duplicate -rr $myCurve`;
select -r $myCurve;
SmoothCurvatureB3(0.1);
float $arcL2 = `arclen $myCurve`;
print $arcL1;
print $arcL2;
print $myCurve;
print $DupicateZ;
select -r $DupicateZ;

float $percentDIffZ = PercentDiff_Curve_to_Arc($arcL2,$arcL1);
int $curveEPsZ = CurveEPnumber($myCurve);

if (($percentDIffZ < 98.0)||($curveEPsZ < 5)) {  delete $myCurve;
rename $DupicateZ[0] $myCurve;
$DupicateZ = `duplicate -rr $myCurve`;
select -r $myCurve;
SmoothCurvatureB3($arcL1);
float $arcL3 = `arclen $myCurve`;
int $curveEPsZ2 = CurveEPnumber($myCurve);
float $percentDIffZ2 = PercentDiff_Curve_to_Arc($arcL3,$arcL1);
//ERROR here
if ($percentDIffZ2 > 98.0){ delete $DupicateZ[0];
select -r $myCurve;} else {
delete $myCurve;
rename $DupicateZ[0] $myCurve;
select -r $myCurve;
}
}else{  delete $DupicateZ[0];
select -r $myCurve;}

string $digitalSkeleton[];
$numInts = size($digitalSkeleton);
if ( $numInts > 0 ){
clear $digitalSkeleton;
}

string $CurveItemA = $objectcurv[0];
string $CurveSelection[] = `ls -fl  ($CurveItemA+".ep[0:*]")`; 
string $CurveEPzCount = size ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
//float $arcL4 = `arclen $myCurve`;


///////////////GATHER ALL BUILDING  STRUCTURE/////////##
appendStringArray($digitalSkeleton, $objectcurv,  1);
///////////////////////////////////////////////// ////##
float $EACHCVposA[];
float $EACHCVposB[];	
string $AllIntersectCurveZ[];
$numInts = size($AllIntersectCurveZ);
if ( $numInts > 0 ){
clear $AllIntersectCurveZ;
}
string $IntersectCurves[];
string $MakeExtrudeSurface[];
string $MakeBirailSurface[];
string $MakeXBetween[];
string $MakeIntersectCurvez[];
string $MakespaceLocator[];
 float $eachCVpos[];
	string $each;
for ($each in $CurveSelection) {     	
	$eachCVpos = `pointPosition -w  $each`;
$MakeIntersectCurvez[0] = `curve -d 1 -p 0 0 0 -p  12 0 0 -k 0 -k 1 -n IntersectCurve` ;
appendStringArray($AllIntersectCurveZ,  $MakeIntersectCurvez, 1);
$numInts = size($AllIntersectCurveZ);
extendCurvePresetArgList( "2", {"0",  "0","0","0","100","0","0","0","0","1","1","1"} );

rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 2 -kcp  0 -kep 1 -kt 0 -s 22 -d 3 -tol 0.001 ;
move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakeIntersectCurvez[0];
//PAUSE;
aimConstraint -offset 0 0 0 -weight 0.5 - aimVector -1 0 0 -upVector 0 0 -1 -worldUpType  "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM    $MakeIntersectCurvez[0];
//PAUSE;
}

$captureCurveName = $objectcurv;
select -r $captureCurveName;
delete $objectcurv;
return $AllIntersectCurveZ;
}




proc string[] StartofCurveScriptRetopo3 (string $PolygonShapeZ[], string  $ProjectionCurves[], string $CurveName[]){

string $PolygonShape[];
$PolygonShape[0] = $PolygonShapeZ[0];
string $AllIntersectCurveZA[] =  $ProjectionCurves;
//$PolygonShape[0] = $PolygonShapeZA[0]; 
//string $AllIntersectCurveZA[] =  $retopoProjectionCurves;
//print $retopoProjectionCurves;
makeIdentity -apply true -t 0 -r 0 -s 1 -n 0  $PolygonShape;
int $KillScript = 1;
string $curve = "curve -d 3";
string $Allcurves[];
$Allcurves = $AllIntersectCurveZA;
int $curvesNumber = size($Allcurves) -1;
int $iY = -1; 
float $ZeroDistanceAB = 0.0;
int $switchN = 0;
int $Xi = 1;
string $curvePoints = "";
float $step = 1;  
  string $crShape[];
string $myCurve;
while ($curvesNumber > $iY ){
if ($KillScript == 0 ){$iY = 1000;}
$iY++;
int $a = 1;
int $ADDSUB = 1;
int $ADDSUB2 = 2;
$b = 0;
///////////////////
$switchN = 0;
//////////////////
$Xi = 1;
$step = 1;  
float $arclenghtOne = `arclen $Allcurves[0]`;

$myCurve =  $Allcurves[$iY];
      $cube = $PolygonShape[0];
      $myCPOM = `createNode closestPointOnMesh`;
      connectAttr ($cube+".worldMesh")  ($myCPOM+".inMesh");
      $LocatorResultA = `spaceLocator -p 0 0 0 -n  LocA`;
      $LocA = $LocatorResultA[0];
      connectAttr ($myCPOM+".position")  ($LocA+".translate");
      $LocatorResultB = `spaceLocator -p 0 0 0 -n  LocB`;
      $LocB = $LocatorResultB[0];
      connectAttr ($LocB+".translate")  ($myCPOM+".inPosition");
string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
   $connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position") ($LocB  + ".translate")`;
  $crShape = `listRelatives -s $myCurve`;
 int $XiX = 0;
float $DistanceFourth;
int $triggerA = 0;
float $UnitDistance;
float $DivideTotalWithUnit;
int $RDivideTotalWithUnit;
int $A2;
float $UnitDistanceA;
int $Gate2 = 0;
int $Gate1 = 0;
float $UnitDistanceFourth;
float $UnitDistanceHalf;
int $a3 = 1;
int $Demo = 0;

int $PassedTargetNum = 0;

while($Xi > 0 ){


$XiX++;
if ($XiX == 1000){$Xi = 0; $KillScript = 0;}
float $valuesC[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
float $valuesD[] = `getAttr  ($myCPOM+".position")`;
float $DistanceCD  = PointsGetDistanceFLOAT ($valuesC, $valuesD);

////IF triggered ----- "$step = 40; $a = $a * 40" 
// then --- $a = AddorSubtract($a ,$ADDSUB) which  adds 1 making t = 80/40 t = 81/40
$a = AddorSubtract($a ,$ADDSUB);
  	$t =  $a/$step;

 setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t;
$para = `getAttr ($paramlocatorpointOnCurvex +  ".parameter")`;
float $valuesA[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
float $valuesB[] = `getAttr  ($myCPOM+".position")`;
float $DistanceAB  = PointsGetDistanceFLOAT ($valuesA, $valuesB);

if ($XiX < 32){ $Gate1 = $XiX;}
if ($XiX == 1){ $Gate2 = 1;
$UnitDistanceFourth = $DistanceAB/4;
$UnitDistanceA  = PointsGetDistanceFLOAT ($valuesC, $valuesA);
}
/*
$DivideTotalWithUnit = $DistanceCD /  $UnitDistance;
$RDivideTotalWithUnit = $DivideTotalWithUnit;
*/
/////////////////////////////////////
if ($XiX == $Gate2){ $Gate2 = $Gate1;
$UnitDistance  = $UnitDistanceA;
$UnitDistanceHalf = $UnitDistance/2;
$DivideTotalWithUnit = ($DistanceAB/2) /  $UnitDistanceHalf;
$A2 = ($DivideTotalWithUnit +1);
if ($A2 >= 1){
$a = $a + $A2;
}else{ int $IFequivalent = equivalentTol ($DistanceAB, $ZeroDistanceAB, 0.1);
  	if ($IFequivalent == 1){  
  		$curve += " -p "+$valuesB[0]+"  "+$valuesB[1]+" "+$valuesB[2];
   select -r $LocB $LocA;
delete $myCPOM $LocA $LocB  $paramlocatorpointOnCurvex;  
 $Xi = 0; 
  	}}
}


///////////////////////////////////

//if ( $DistanceAB > $DistanceCD ) { print ("0000  Passed Target Distance  0000" +  "\n"); $PassedTargetNum++;}

//0000  Passed Target Distance  0000

if ($switchN == 0){
if ($triggerA == 0){
if (( $DistanceAB <= $UnitDistanceHalf ) && (  $DistanceAB < $DistanceCD )) {$ADDSUB = 1; $step  = 40; $a = $a * 40; 
$triggerA = 1; } 
}
if (!($XiX == $Gate2)){
if($PassedTargetNum<1){
if ( $DistanceAB > $DistanceCD ) { $ADDSUB = 0;  $step = 20; $a = $a * 20; $switchN = 1;  
print ("0000  Passed Target Distance  0000" +  "\n"); }
}
}
}


if ($switchN == 2){ 
if ( $DistanceAB > 4){ $ADDSUB = 1;  $step = 1; $a = $a / 20; $switchN = 0; $PassedTargetNum++; print ("0000  Passed False Target  0000" +  "\n");}else{
if ( $DistanceAB > $DistanceCD ) { $ADDSUB = 1;  $step = 40; $a = $a * 40;  $switchN = 3; 
$ADDSUB2 = 1; }
}
}

if ($switchN == 1){ $switchN = 2; }
int $IFequivalent = equivalentTol($DistanceAB,  $ZeroDistanceAB, 0.1);
  	if ($IFequivalent == 1){  
  		$curve += " -p "+$valuesB[0]+"  "+$valuesB[1]+" "+$valuesB[2];
   select -r $LocB $LocA;
delete $myCPOM $LocA $LocB  $paramlocatorpointOnCurvex;  
 $Xi = 0; 
  	}


$b = AddorSubtract($b ,$ADDSUB2);
if ( $b > 10 ){ delete $myCPOM $LocA $LocB  $paramlocatorpointOnCurvex;
 $Xi = 0; }
//////////////////////////////////


}
}
string $Newcurvez = `eval($curve)`;
rename $Newcurvez $CurveName[0];
string $Newcurve[] = $CurveName;
string $NewcurveA[] = `ls -sl`;
delete $ProjectionCurves; 
return $Newcurve; 
}


////////////////////////////////

proc float[] AverageVectorPoint(vector $worldPosZ[]) {
int $vectorSize = size($worldPosZ);
int $vecCount = size($worldPosZ) ;
float $Added_floats[] = { 0.0, 0.0, 0.0};
float $FloatFromVec[];
float $VposA;
float $VposB;
float $VposC;
int $Vii = 0;
while ($Vii < $vecCount){
float $FloatFromVecA[] = $worldPosZ[$Vii];
$VposA = $FloatFromVecA[0];
$VposB = $FloatFromVecA[1];
$VposC = $FloatFromVecA[2];
$Added_floats = {($FloatFromVecA[0] +  $Added_floats[0]), ($FloatFromVecA[1] +  $Added_floats[1]), ($FloatFromVecA[2] +  $Added_floats[2])} ;
$Vii++;
}	
	float $a = ($Added_floats[0]) /  $vectorSize;
	float $b = ($Added_floats[1]) /  $vectorSize;
	float $c = ($Added_floats[2]) /  $vectorSize;
	float $PointsAverage[] = {$a , $b , $c};
return $PointsAverage;

}


proc int CurveEPnumber(string $myCurve){
string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
return $numEPrealNum;
}


global proc string[] IntersectItems(string  $initialArray[], string $IntersectArrayItems[] ){
string $myIntersector = `stringArrayIntersector`;
stringArrayIntersector -edit -intersect  $initialArray $myIntersector;
stringArrayIntersector -edit -intersect  $IntersectArrayItems $myIntersector;
string $results[] = `stringArrayIntersector - query $myIntersector`;
stringArrayIntersector -edit -reset  $myIntersector;
return $results;
}


proc float[] GetCenterPointofFace(float  $CurveXYZ[]){

int $Cnsize= `size $CurveXYZ`;
int $Cnsize_p= ($Cnsize/3) -1;
int $ix = -1;
int $Xii = -3; int $Yii = -2; int $Zii = -1;
vector $points[];
clear $points;
while ($ix < $Cnsize_p){
$ix++;
$Xii = $Xii + 3;
$Yii = $Yii + 3;
$Zii = $Zii + 3;
$points[$ix] = <<$CurveXYZ[$Xii], $CurveXYZ [$Yii], $CurveXYZ[$Zii]>>;
}
float $FacePoint[] = AverageVectorPoint($points);
return $FacePoint;
}


proc ConnectMesh(string $selectOUT[], string  $selectIN[]){
        $outmmesh = ($selectOUT[0] + ".outMesh"); 
        $inmmesh = ($selectIN[0] + ".inMesh");
$connect = `connectAttr -f $outmmesh $inmmesh`;
}


proc ConnectMeshScale(string $selectOUT[], string  $selectIN[]){
        $outmmesh = ($selectOUT[0] + ".scale"); 
        $inmmesh = ($selectIN[0] + ".scale");
$connect = `connectAttr -f $outmmesh $inmmesh`;
}


proc int FaceEdgeNumber(string $face){
string $PolyEg[] = `polyListComponentConversion  -fromFace -toEdge $face`; 
$PolyEg = `ls -fl $PolyEg`;
int $EdgeNumber = `size($PolyEg)`;
return $EdgeNumber;
}


proc string CreateCurve(float $CurveLength, int  $CurveNSpans, string $Curvename)
{
string $CurvenextSel[] = `ls -sl`;
float $CurveLengthC = $CurveLength;
int $CurveNSpansC = $CurveNSpans;
global string $CurvenameCobj;
string $CurvenameCobj = $Curvename;

$CurveNSpansC = $CurveNSpansC - 1;
float $CurveCurvPart = $CurveLengthC/ $CurveNSpansC;
string $CurvecurveP = "";

float $Curvei = 0;
while ($Curvei <= $CurveLengthC) 
{
$CurvecurveP = ($CurvecurveP+"-p 0 "+$Curvei+" 0  ");
$Curvei = $Curvei + $CurveCurvPart;
}
$CurvecurveP = ("curve -d 3 "+$CurvecurveP+";");
eval $CurvecurveP;
string $renamed = `rename $CurvenameCobj`;
//select $CurvenextSel;
return $renamed ;
}


proc string getSelectionType(){
string $selectionFindType[] = `ls -sl`;
string $idnodeType2;
string $Relativesselection[];
	$Relativesselection = `listRelatives $selectionFindType[0]`;
if (size($Relativesselection)== 0){ $idnodeType2 = `nodeType $Relativesselection[0]`;} else{
$idnodeType2 = `nodeType $Relativesselection[0]`;}
return $idnodeType2;
}

string $selection[]=`ls -sl`; string $sel=$selection[0]; if(size($sel)>0 && `attributeExists "Speed" $sel`) getAttr $sel.Speed;

global proc string[] stringArrayMatchToArray (string $item, string $list[]){
string $FoundMatchedItem[];
int $resultZ = false;	
string $MatchedItem[];	
	for ($each in $list) {
string $OneiteminArrayList = $each;
string $matchedItem[];
$matchedItem = {`match $item $OneiteminArrayList `};
int $sizeMatchedItems = `size($matchedItem)`;
int $matchedBlankN = isValidString($matchedItem[0], "([a-zA-Z]+)([a-zA-Z0-9_])*");
		if (($sizeMatchedItems >  0) && ($matchedBlankN > 0)){
		$resultZ = true;
if ($resultZ == true ){ $FoundMatchedItem[0] = ($OneiteminArrayList); }
			break;	}
	}		
	return  $FoundMatchedItem;
}




proc PrintAllNodeTypes(){
	string $arrayListType[];
	$arrayListType = `ls -nodeTypes`;
int $size = size($arrayListType);
float $CollumsA = float($size)/4.0;
float $CollumsB = float($size)/3.0;
	string $commandPrint = "";
	int $iXiA = 0;
int $iXiB = 0;
int $iXiC = 0;
	while ($iXiA < ($CollumsB-1)){
		
$iXiB = $iXiA +1;
$iXiC = $iXiB +1;

print ("// " + $arrayListType[$iXiA] + "          "); print ("// " + $arrayListType[$iXiB] + "          "); print ("// " + $arrayListType[$iXiC] + "\n");
//$commandPrint = "print" + " " + "(" + "\""+ $arrayListType[$iXiA] + " "+ "\""+")" + ";"+"\n";
		//eval($commandPrint);
		$iXiA++;
}
}


/*

proc replaceObjectsAndKeepOriginalConnections(  int $rot, int $scale, int $inst, int  $keepOriginal )
{

int $rot = 1; int $scale= 1; int $inst= 1; int $keepOriginal = 1;


	string $list[] = `ls -sl -tr`;
	int $size = `size $list`;
string $replacmentObject[0] = {$list[$size-1]};
	
	if ($size<2){
		error (uiRes ("m_replaceObjects.kReplaceObjectsErrorInvalid"))  ;
	}

	int $i = 0;
string $duplicateObject[];

	while ($i < ($size-1))
	{
		select -r ($list[$size-1]);
		if ($inst == 1){
			$duplicateObject = `duplicate -rr $list[$size-1]`; 
		}else if ($inst == 2){
			instance; 
		}else{
			//confirm object is a  reference
			int $reference =  `reference -q -isNodeReferenced`;
			if ($reference){
				 duplicateReference 0 "";
			} else {
				error (uiRes ("m_replaceObjects.kReplaceObjectsErrorReference" )) ;
			}
		}
		


		//string $new[] = `ls -sl`;


string $polyFaceSelected[0] = {$list[$i]};

string $shapes[] = `listRelatives -s -path  $polyFaceSelected`;
string $shapesOne[0] = {$shapes[0]};
string $stringNames = $shapesOne[0];

string $arrayItems[];
string $matchitem[] = {`match "\\|" $stringNames`};
string $newList[];
if (size($matchitem)>0){    

	$arrayItems = stringToStringArray($stringNames , "|");
 	$newList = stringArrayMatchToArray($item, $arrayItems);
}



string $AllConnections[] = `listConnections  $shapes[0]`;
listConnections group1|brick1|brick1Shape;

int $Vii = 0;

string $ConnectionsToMeshALL = `connectionInfo -isSource $AllConnections[$Vii]`;
$Vii++;

//string $list[] = `listConnections -type wire  $shapes[0]`;
string $oneshapeZ  = $shapes[0];
$oneshapeZ  += ".inMesh";
print $oneshapeZ;
string $ConnectionsToMeshZ = `connectionInfo -sfd  $oneshapeZ`;
string $item = "Shape";

deformer -e -g $new[0] ffd1;

print $duplicateObject

//listConnections



string $arrayONE[];
	$arrayONE = stringToStringArray ($ConnectionsToMeshZ, ".");
if (size($arrayONE) > 0){

string $polyFaceSelectedDup[0] = {$duplicateObject[0]};
string $Duplicateshapes[] = `listRelatives -s - path $polyFaceSelectedDup`;
string $oneDuplicateshapeZ = $Duplicateshapes[0];
//$oneDuplicateshapeZ += ".inMesh";
//connectAttr -force $arrayONE  $oneDuplicateshapeZ;
substituteGeometry $shapes[0] $Duplicateshapes [0];
}

}




		//Get and set Worldspace values	-  use rotate pivot in case translate has been  frozen	
		float $trans[] = `xform -q -ws - rotatePivot $list[$i]`; 	
		xform -a -ws -t $trans[0] $trans [1] $trans[2] $new[0];

		if ($rot) 
		{
			float $rotate[] =  `getAttr ($list[$i]+".r")`; 	
			setAttr ($new[0]+".r") 	 $rotate[0] $rotate[1] $rotate[2];
		}

		if ($scale)
		{
			float $scale[] = `getAttr  ($list[$i]+".s")`; 	
			setAttr ($new[0]+".s") 	 $scale[0] $scale[1] $scale[2];
		}

		string $parent[] = `listRelatives  -parent $list[$i]`;
		
		if ($parent[0] != ""){

			string $selection[] = `ls  -sl`;
			parent $selection[0]  $parent[0];			
		}


		
		delete $list[$i];

		$i++;
	}

	// if copy or instance
	//if (($inst != 3) && ($keepOriginal ==  0))
		//delete ($list[$size-1]);
	select -cl;
}


*/



/*
commandEcho -state on;
polyDuplicateAndConnect pPlane1;


//select -r $shapes;


string $polyFaceSelected[] = `ls -sl`;
string $shapes[] = `listRelatives -s -path  $polyFaceSelected`;
//string $list[] = `listConnections -type wire  $shapes[0]`;
string $oneshapeZ  = $shapes[0];
$oneshapeZ  += ".inMesh";
print $oneshapeZ;
string $ConnectionsToMeshZ = `connectionInfo -sfd  $oneshapeZ`;
string $arrayONE[];
	$arrayONE = stringToStringArray ($ConnectionsToMeshZ, " ");
if (size($arrayONE) > 0){

string $polyFaceSelectedDup[] = `ls -sl`;
string $Duplicateshapes[] = `listRelatives -s - path $polyFaceSelectedDup`;
string $oneDuplicateshapeZ = $Duplicateshapes[0];

//$oneDuplicateshapeZ += ".inMesh";
//connectAttr -force $arrayONE  $oneDuplicateshapeZ;

substituteGeometry -reWeightDistTolerance 50.0  $shapes[0] $Duplicateshapes[0];



}


substituteGeometry -retainOldGeometry - oldGeometryToLayer $shapes[0] $Duplicateshapes [0];

-oldGeometryToLayer


if (size($list) > 0){
if (size($list) == 1){

}
}

isConnected wire1.outputGeometry[0]  polySurfaceShape3.inMesh;

connectionInfo -is $oneshapeZ; 
connectionInfo -dfs $oneshapeZ;
string $ConnectionsToMeshZ = `connectionInfo -sfd  $oneshapeZ`;
string $arrayONE[];
	$arrayONE = stringToStringArray ($ConnectionsToMeshZ, " ");

connectAttr -force ffd1.outputGeometry[0]  |pCube1|pCubeShape1.inMesh;

string $ConnectionsZ =  destinationNodeNameFromConnection($oneshapeZ);
print $ConnectionsZ;

polyExtrudeFacet 
-constructionHistory 1 
-keepFacesTogether 1 
-pvx 1.956866086 
-pvy 0 
-pvz -3.265890372 
-divisions 1 
-twist 0 
-taper 1 
-off 0 
-smoothingAngle 30 $polyFaceSelected[0];

polySelectSp -ring; ConvertSelectionToFaces;

setAttr ($polyFaceSelected[1]+".translate") -type  double3 0 0 -0.475 ;
setAttr ($polyFaceSelected[1]+".localScale") - type double3 1 1 1.016687 ;
setAttr ($polyFaceSelected[1]+".localScale") - type double3 1.35 1.35 1.372527 ;
setAttr ($polyFaceSelected[1]+".localTranslate")  -type double3 0 0 0.0766679 ;
setAttr ($polyFaceSelected[1]+".localTranslate")  -type double3 0 0 0.147452 ;

*/






proc AdvancedCurveMODprojectOnSurface(string  $AllIntersectCurveSA[], string $INarrayA[],  string $PolygonShapeXi[]){


int $Error = 0;

$Error++;
print ("error Here "+$Error);

string $polyShapRetopo[] = $PolygonShapeXi;

float $eachCVposSTART[];
float $eachCVposEND[];
string $MakespaceLocatorSTART[];
string $MakespaceLocatorEND[];
string $digitalSkeletonA[];
string $NewStraitCurve[];
int $numInts;
$numInts = size($digitalSkeletonA);
if ( $numInts > 0 ){
clear $digitalSkeletonA;
}

string $AllIntersectCurveS[] =  $AllIntersectCurveSA;
//EvalSmoothCurves;
//$digitalSkeletonA =  `StartofCurveScriptIntersectZX`;


string $AllCurveZ[];
$numInts = size($AllCurveZ);
if ( $numInts > 0 ){
clear $AllCurveZ;
} 
string $AllSpaceLocatorZ[];
$numInts = size($AllSpaceLocatorZ);
if ( $numInts > 0 ){
clear $AllSpaceLocatorZ;
} 


string $renamed[];
string $rebuildit[];
string $ZIntersectionCurveZA[];
string $intersectionCurve[]; 
string $MakeSpaceLocator[];
string $objectLocaterz[];
string $AllparamlocatorZ[];
int $numparam;

string $MakespaceLocatorZSE[];
string $SEspaceLocSetofSetz; 
string $paramANDCurve3[];
string $paramANDCurve2[];
string $paramANDCurve[];
string $paramCurveNAMES[];



string $paramlocatorZ[];
$numInts = size($paramlocatorZ);
if ( $numInts > 0 ){
clear $paramlocatorZ;
} 


string $intersectZ[];
string $ZBetween[];
string $objectCurveA[];
string $objectCurve[];
clear  $objectCurve;
float $EACHCVposA[];
float $EACHCVposB[];
float $p1Z; 	
int $moveCurve = 0;


string $objectSelection[];
$numInts = size($objectSelection);
if ( $numInts > 0 ){
clear $objectSelection;
} 

$objectSelection = `editDisplayLayerMembers -q  layerCurvesINRange1`;
int $numparam;
int $EdgecurvesizeNUM = size($objectSelection);




///errors here

if ($EdgecurvesizeNUM > 0){

float $tol = 0.45;
float $dir[3] ;	
		$dir = nurbsViewDirectionVector (0) ;
float $dirX, $dirY, $dirZ;
$dirX = $dir[0];
$dirY = $dir[1];
$dirZ = $dir[2];

string $eachZ;
string $curveIntersectZA;
int $Xxi = -1;

for ( $eachZ in $objectSelection ){

$objectCurve[0] = $eachZ;	
$Xxi++;
print $Xxi ;
$curveIntersectZA = `curveIntersect -ch off - useDirection on -direction $dirX $dirY $dirZ  $objectSelection[$Xxi] $AllIntersectCurveS`;
int $numTokens;		
string $tokens[];
$numTokens = `tokenize $curveIntersectZA " "  $tokens`;

print $numTokens;
if ($numTokens == 2){
///////////////GATHER ALL BUILDING  STRUCTURE/////////##

 $objectCurve[0] = $eachZ;
appendStringArray($AllCurveZ, $objectCurve, 1);
string $buffer[];
$numTokens = `tokenize $curveIntersectZA " "  $buffer`;
$paramlocatorZ[0] = eval("paramLocator " +   $objectCurve[0] + ".u[" + $buffer[0] + "]");
appendStringArray($AllparamlocatorZ,  $paramlocatorZ, 1);
appendStringArray($digitalSkeletonA,  $paramlocatorZ, 1);
        float $intersectposA[];	
	$intersectposA = `pointPosition -w  $paramlocatorZ[0]`;
string $objectLocaterzA[];
$objectLocaterzA = `spaceLocator -p 0 0 0 -n  IntersectZLocaterZ3D`;
move  -ws $intersectposA[0] $intersectposA[1]  $intersectposA[2] $objectLocaterzA[0];
appendStringArray($AllSpaceLocatorZ,  $objectLocaterzA, 1);
clear $objectCurve; 
}
}

appendStringArray($digitalSkeletonA,  $AllSpaceLocatorZ, size($AllSpaceLocatorZ));
  string $shorterList[] =  stringArrayRemoveDuplicates($AllCurveZ);
$AllCurveZ = $shorterList;
 int $CurvesCUTinto = size($AllCurveZ);
if ($CurvesCUTinto == 1){string $oneLocatorZ[] =  {$AllparamlocatorZ[0]}; $AllparamlocatorZ =  $oneLocatorZ; }
$numparam = size($AllparamlocatorZ);
if (($CurvesCUTinto == 2) && ($numparam == 4)){
string $oneLocatorZa[] = {$AllparamlocatorZ[0]}; 
string $oneLocatorZb[] = {$AllparamlocatorZ[1]}; 
$AllparamlocatorZ = {$oneLocatorZa[0],  $oneLocatorZb[0]}; 
}
$numparam = size($AllparamlocatorZ);
int $numInts = size($AllSpaceLocatorZ);
if (($CurvesCUTinto == 2) && ($numInts == 4)){
string $oneLocatorZ2a[] = {$AllSpaceLocatorZ[0]}; 
string $oneLocatorZ2b[] = {$AllSpaceLocatorZ[1]}; 
$AllSpaceLocatorZ = {$oneLocatorZ2a[0],  $oneLocatorZ2b[0]}; 
}

$numInts = size($AllSpaceLocatorZ);
if ( $numparam > 0 ){
  string $shorterList[] =  stringArrayRemoveDuplicates($AllparamlocatorZ);
$AllparamlocatorZ = $shorterList;
}

$numparam = size($AllparamlocatorZ);
$numInts = size($AllSpaceLocatorZ);

select -cl  ;
print $AllparamlocatorZ;


$SEspaceLocSetofSetz = `sets -name  SEspaceLocSetofSets`;	
$paramANDCurve3 = `paramToCurvePts3(  $AllparamlocatorZ )`;
$paramANDCurve2 = `paramToCurvePts2(  $AllparamlocatorZ )`;
$paramANDCurve = `paramToCurvePts(  $AllparamlocatorZ )`;
$paramCurveNAMES = `tokenizeparam( $paramANDCurve  )`;

$MakespaceLocatorZSE = EvalMoveCurvesTOend ($paramANDCurve, $paramCurveNAMES,  $paramANDCurve3, $AllparamlocatorZ,  $SEspaceLocSetofSetz);

if (size($MakespaceLocatorZSE) > 0){
appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
}
int $setsNumber = `sets -q -size  $SEspaceLocSetofSetz`;
if ($setsNumber > 0){
string $subsets[];
$subsets = `sets -q $SEspaceLocSetofSetz`;
//appendStringArray($digitalSkeletonA, $subsets,  size($subsets));

}

/////////////////////
// end of if Size of Curves are greater then ONE 

}


print $numparam;


/////////////////////
/////////////////////
/////////////////////


	if ( $numparam == 0 ){

int $trueORfalse = 0;
int $trueORfalse2 = 0;
string $oldName = $AllIntersectCurveS[0];
$trueORfalse = FindIfCurveCrossesZ ($AllIntersectCurveS);
string $newname[]; 
if ($trueORfalse == 1){
$newname = CutCurveIFConditionTRUETransitZ ($AllIntersectCurveS);
$trueORfalse2 = 1;
ResetTranslation($newname);
rename $newname $oldName;
$AllIntersectCurveS = {$oldName}; 
}
if ($trueORfalse == 0){
ResetTranslation($AllIntersectCurveS);
}

MirrorANDrename($AllIntersectCurveS);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $AllIntersectCurveS;

//if($intZplainF > 0)  {
//select -r $ParentArc;
//MirrorANDrename($AllIntersectCurveS);
//}




} else if ( $numparam == 1 ){



string $renamed[]; 
$renamed[0] = $AllIntersectCurveS[0];
ResetTranslation($renamed);
float $arclenghtDrawCurve = `arclen  $AllIntersectCurveS[0]`;
float $arcLenCurveFrac = $arclenghtDrawCurve/5;
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($renamed[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($renamed[0] + ".cv[0]") ;		 	
$CurveSelection[1] = ($renamed[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}



if (size($MakespaceLocatorZSE) > 0){

int $ZEROorONE;
 int $foundA = stringArrayGmatch ("SEspaceLocatorSTART3DZ*",  $MakespaceLocatorZSE);
 int $foundB = stringArrayGmatch ("SEspaceLocatorEND3DZ*", $MakespaceLocatorZSE);
if (( $foundA == 1 ) || ( $foundB == 1 )) {
float $eachCVposSTART[] = `pointPosition -w  ($MakespaceLocatorZSE[0])`;

float $movePIVOT[];

$ZEROorONE = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVposSTART);
string $pointEP;

if ( $ZEROorONE == 0){ $movePIVOT = $EACHCVposAZ;  move $movePIVOT[0] $movePIVOT[1] $movePIVOT[2]  ($renamed[0] + ".scalePivot") ($renamed[0] +  ".rotatePivot") ; $pointEP = $CurveSelection[0];  }
if ( $ZEROorONE == 1){ $movePIVOT = $EACHCVposBZ;  move $movePIVOT[0] $movePIVOT[1] $movePIVOT[2]  ($renamed[0] + ".scalePivot") ($renamed[0] +  ".rotatePivot") ; $pointEP = $CurveSelection[1];  }

//ADD SOFT SELECT HERE
select -r $pointEP;
softSelect -e -softSelectEnabled true;
softSelect -e -softSelectDistance  $arcLenCurveFrac;

move -rpr $eachCVposSTART[0] $eachCVposSTART[1]  $eachCVposSTART[2];
xform -cp $renamed[0];
softSelect -e -softSelectEnabled false;
FlattenCurveOnMesh( $AllIntersectCurveS,  $polyShapRetopo);

}
}



if (size($MakespaceLocatorZSE) == 0){
string $paramANDCurveA2[];
$paramANDCurveA2 = `paramToCurvePts2(  $AllparamlocatorZ )`;
string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[0]`;
string $AllCurveZA = ("A"+ $AllCurveZ[0]+"A");
delete $AllCurveZA;
delete $AllCurveZ;

string $AllCurveZ2[];
string $newCurveZA[];
string $newCurveBB[];

for ($each in $detachCurve1){

$newCurveBB[0] = `rename $each Curve`;
MirrorANDrename($newCurveBB);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $newCurveBB[0];
ArrayInsertAtEnd( $newCurveZA, $newCurveBB[0]);
}


string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurveZA[0]);
ArrayInsertAtEnd( $INarrayA,$newCurveZA[1]);
  string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;
$AllCurveZ = $newCurveZA;
}



delete $digitalSkeletonA;
ResetTranslation($renamed);
string $renamed2[];
$renamed2 = $renamed;

///////////////////////////////////////////////// ///////
// IF Drawn Curve is connected to the end of  another curve thast is in EdgeSet
// the curve drawn can be on a edge curve which  is eather protruding from the ZY plain 
// or it lies on the ZY plain. if it is at one of  the two ends of a protruding EdgeCurve
// then the drawn curve intersecting at  EdgeCurves Ends is eather also protruding from ZY  plain or 
// is positioned freely at the other end.. which  means it could be crossing the ZY plain which  means     
// It would need to be cut

$Error++;
print ("error Here "+$Error);

int $ifNearEnds = size($MakespaceLocatorZSE);
int $AllCurveCVsZeroAndLast = FindIfCurveISonZ ($AllCurveZ);
int $edgeZsetA = `sets -im ZEdgeCurvesSet  $AllCurveZ[0]`;
int $ZeroX = 0;
if (( $ifNearEnds == 1) && (  $AllCurveCVsZeroAndLast == 1) && ( $edgeZsetA ==  1)) {
vector $AllCurveCVENDs[] = `VecCurveEnds ($AllCurveZ)`;
vector $renamed2CVENDs[] = `VecCurveEnds ($renamed2)`;
float $renamed2CVENDAs[] = $renamed2CVENDs[0];
float $renamed2CVENDBs[] = $renamed2CVENDs[1];
float $AllCurveCVENDAs[] = $AllCurveCVENDs[0];
float $AllCurveCVENDBs[] = $AllCurveCVENDs[1];
float $FloatZ1[] = $renamed2CVENDAs;
float $FloatZ2[] = $renamed2CVENDBs;
float $FloatZ3[] = $AllCurveCVENDAs;
float $FloatZ4[] = $AllCurveCVENDBs;
$renamed2CVENDAs = `MakeCleanFloats($FloatZ1)`;
$renamed2CVENDBs = `MakeCleanFloats($FloatZ2)`;
$AllCurveCVENDAs = `MakeCleanFloats($FloatZ3)`;
$AllCurveCVENDBs = `MakeCleanFloats($FloatZ4)`;
int $CombA = PointsEquivalentTol ($renamed2CVENDAs, $AllCurveCVENDAs);
int $CombB = PointsEquivalentTol ($renamed2CVENDBs, $AllCurveCVENDBs);
int $CombC = PointsEquivalentTol ($renamed2CVENDAs, $AllCurveCVENDBs);
float $intersectFloat[];
if ($CombA == 3 ){ $intersectFloat =  $AllCurveCVENDAs;}
if ($CombB == 3 ){ $intersectFloat =  $AllCurveCVENDBs;}
if ($CombC == 3 ){ $intersectFloat =  $AllCurveCVENDBs;}
float $Zero0x = 0.0;
$ZeroX = equivalentTol($Zero0x, $intersectFloat [0], 0.001);
}
$intZplainF = 1;
if ($ZeroX == 1){
$intZplainF = `ZplainFlatten`;
if($intZplainF == 0){
FlattenCurveToZplain($renamed);
}
}
if ($AllCurveCVsZeroAndLast == 2){
$intZplainF = `ZplainFlatten`;
if($intZplainF == 0){
FlattenCurveToZplain($renamed2);
}
}
int $trueORfalse = 0;
int $trueORfalse2 = 0;
if ($ZeroX == 0){
$trueORfalse = FindIfCurveCrossesZ($renamed2);
string $newname[]; 
if (($trueORfalse == 1) && ($ZeroX == 0)){
$newname = CutCurveIFConditionTRUETransitZ ($renamed2);
$trueORfalse2 = 1;
ResetTranslation($newname);
rename $newname $renamed2; 
}
}  


string $newnamed[0] = {$renamed2[0]};
ResetTranslation($newnamed);
//string $ParentArc[];
//$ParentArc = Strait_ARC_or_FreeForm($newnamed,  5.5, 2.5 );

if($intZplainF > 0)  {
select -r $newnamed;
MirrorANDrename($newnamed);
}
if (($ZeroX == 1) || ($trueORfalse2 == 1)){
sets -include ZEdgeCurvesSet $newnamed;
 }

//ArrayInsertAtEnd( $INarrayA, $newnamed[0]);
print "check Here6";
ResetTranslation($newnamed);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $newnamed;




select -r $newnamed[0];
EvalAddingCurves;
EvalcreatSphere;


//////////////////////////////////////END OF ONE  CURVE
} else if ( $numparam > 2 ){
// Buffers of u para of DrawnCurve placed in a  Array then Sorted. ///

if (size($MakespaceLocatorZSE) > 0){
appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
}
delete $digitalSkeletonA;
} else if ( $numparam == 2 ){


//////////////////////////////////////
////NEW NEW NEW


$rebuildit = $AllIntersectCurveS;
//NEW START//
//ResetTranslation($rebuildit);
select -r $AllIntersectCurveS $AllCurveZ[0];
	 string $bufferCutCurve[];
	string $ZIntersectionCurveZ[];
	string $afterCut[];
	string $numTokensZ;
	int $n, $i;
cutCurvePreset(1,1,0.01,6,-0.7767,0.1104,- 0.6201,1,2);
	$afterCut = `ls -sl`;
		$n = size($afterCut);
		for( $i=0; $i<$n; $i+=1 ) {
			// Now, two of these are  bad, two are OK:
			if( `getAttr ($afterCut [$i] + ".spans")` < 1){ delete $afterCut[$i];
			} else {			
$numTokensZ = `tokenize $afterCut[$i] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; 
}		
}
if (catch(`select -r $bufferCutCurve[0]  $AllCurveZ[1]`)){
select -r $AllIntersectCurveS $AllCurveZ[1];
	} else { print "hereCUT2"; }
cutCurvePreset(1,1,0.001,6,-0.7767,0.1104,- 0.6201,1,2);
	$afterCut = `ls -sl`;
		$n = size($afterCut);
		for( $i=0; $i<$n; $i+=1 ) {
			// Now, two of these are  bad, two are OK:
			if( `getAttr ($afterCut [$i] + ".spans")` < 1){ delete $afterCut[$i];
			} else {			
$numTokensZ = `tokenize $afterCut[$i] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; 
}		
}
$renamed[0] = `rename $ZIntersectionCurveZ[0]  Curve`;
string $ZIntersectionCurveZB[];
 $ZIntersectionCurveZB = `listRelatives -shapes  $renamed`;
if (size($ZIntersectionCurveZB) > 0 ){
string $ListCONCurveZA[];
 $ListCONCurveZA = `listConnections  $ZIntersectionCurveZB`;
if (size( $ListCONCurveZA) > 0){
string $ListCONCurveZB[];
 $ListCONCurveZB = `listConnections -shapes 0 - source 0 $ListCONCurveZA`;
delete  $ListCONCurveZA $ListCONCurveZB;
}
}
$rebuildit = $renamed;
ResetTranslation($rebuildit);

if ( size($MakespaceLocatorZSE) == 0  ) {
string $paramANDCurveA2[];
$paramANDCurveA2 = `paramToCurvePts2(  $AllparamlocatorZ )`;
string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[0]`;
string $detachCurve2[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[1]`;
delete $AllCurveZ;
string $newCurves1[];
string $newCurves2[];
for ($each in $detachCurve1){
string $newCurve;
$newCurve = `rename $each Curve`;
ArrayInsertAtEnd( $newCurves1, $newCurve);
}
for ($each in $detachCurve2){
string $newCurve;
$newCurve = `rename $each Curve`;
ArrayInsertAtEnd( $newCurves2, $newCurve);
}
string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);
ArrayInsertAtEnd( $INarrayA, $newCurves2[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves2[1]);
ResetTranslationEach($newCurves1);
ResetTranslationEach($newCurves2);
  string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;
$AllCurveZ = $newCurves1;
ArrayInsertAtEnd( $AllCurveZ, $newCurves2[0]);
ArrayInsertAtEnd( $AllCurveZ, $newCurves2[1]);
}

int $ONEspaceLOC = 0;
string $newCurves1[];
if (size($MakespaceLocatorZSE) == 1){
$ONEspaceLOC = 1;
string $subsetsA[];
$subsetsA = `sets -q $SEspaceLocSetofSetz`;
string $subsetsB[]; string $subsetsB2[];
$subsetsB = `sets -q $subsetsA`;
$subsetsB2[0] = $subsetsB[0];
$subsetsB3[0] = $subsetsB[1];
string $SetItemA = ($subsetsB2[0]);
string $SetItemB = ($subsetsB3[0]);
string $subsetItemNeeded[];
int $setATrueFalse = `gmatch $SetItemA "*->*"`;
int $setBTrueFalse = `gmatch $SetItemB "*->*"`;
if ($setATrueFalse == 1){
$subsetItemNeeded[0] = $subsetsB2[0];
}else{ $subsetItemNeeded[0] = $subsetsB3[0]; }
string $bufferZ[];
$numTokensX = `tokenize $subsetItemNeeded[0] "->"  $bufferZ`;
print $bufferZ; 
string $CurveLOCZ[] =  {$bufferZ[1]};
string $paramANDCurveA02[];
$paramANDCurveA02 = `paramToCurvePts2( $CurveLOCZ  )`;
string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA02[0]`;
delete $subsetsB[0];
string $newCurves1[];
for ($each in $detachCurve1){
string $newCurve;
$newCurve = `rename $each Curve`;
ArrayInsertAtEnd( $newCurves1, $newCurve);
}
string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);
  string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;
RemoveNoLongerExistingFromArray ($AllparamlocatorZ);
delete $AllparamlocatorZ; 
}
if ( size($MakespaceLocatorZSE) > 0  ) {
appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;	 		
$CurveSelection[1] = ($rebuildit[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
$MakeXBetweenB[0] = `curve -d 1 -p $EACHCVposAZ [0] $EACHCVposAZ[1] $EACHCVposAZ[2] -p  $EACHCVposBZ[0] $EACHCVposBZ[1] $EACHCVposBZ[2]  -k 0 -k 2 -n                        XCurveBetweenB`;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 0 -d 1 -tol 0.001  $MakeXBetweenB[0];
appendStringArray($digitalSkeletonA,  $MakeXBetweenB, 1);
}
}
wire -gw false -en 1.000000 -ce 0.000000 -li  1.000000 -w $MakeXBetweenB[0] -dds 0 50.000000  $rebuildit[0];
  
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($MakeXBetweenB[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($MakeXBetweenB[0] + ".cv [0]") ;			
$CurveSelection[1] = ($MakeXBetweenB[0] + ".cv["  + $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
				}
int $ZEROorONEA;
int $ZEROorONEB;
string $locZSE0[];
string $locZSE1[];
 int $foundAZ0;
 int $foundBZ0;
 int $foundAX1;
 int $foundBX1;
int $i = 0;
int $iX = 0;
float $eachCVpos1[];
float $eachCVpos2[];
float $movePIVOT1[];
float $movePIVOT2[];
	if (size($MakespaceLocatorZSE) == 1){	 $i = 1; }
	if (size($MakespaceLocatorZSE) == 2){ 	 $iX = 2; }
	if (( $i == 1) || ( $iX == 2)){
$locZSE0[0] = $MakespaceLocatorZSE[0];
$eachCVpos1 = `pointPosition -w  ($MakespaceLocatorZSE[0])`;
	if ( $iX == 2){
$locZSE1[0] = $MakespaceLocatorZSE[1];
$eachCVpos2 = `pointPosition -w  ($MakespaceLocatorZSE[1])`;
	}
	if (( $i == 1) || ( $iX == 2)) {

$ZEROorONEA = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVpos1);
if ( $ZEROorONEA == 0){ $movePIVOT1 =  $eachCVpos1; print "cv ZERO"; }
if ( $ZEROorONEA == 1){ $movePIVOT1 =  $eachCVpos1; print "cv LAST"; }
if ( $iX == 2){
$ZEROorONEB = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVpos2);
if ( $ZEROorONEB == 0){ $movePIVOT2 =  $eachCVpos2; print "cv ZERO"; }
if ( $ZEROorONEB == 1){ $movePIVOT2 =  $eachCVpos2; print "cv LAST"; }
move -ws $movePIVOT2[0] $movePIVOT2[1]  $movePIVOT2[2] $CurveSelection[$ZEROorONEB];
  	}

move -ws $movePIVOT1[0] $movePIVOT1[1]  $movePIVOT1[2] $CurveSelection[$ZEROorONEA];
  				}
delete -ch $rebuildit;
delete $digitalSkeletonA; 				 	}
}
/////////////////////////////

int $CVsZeroAndLast;
if ( size($MakespaceLocatorZSE) > 0  ) {
if ( `objExists ZEdgeCurvesSet` == 1  ) {
if ( $ONEspaceLOC == 0  ) {
int $edgeZsetA = `sets -im ZEdgeCurvesSet  $AllCurveZ[0]`;
int $edgeZsetB = `sets -im ZEdgeCurvesSet  $AllCurveZ[1]`;
$CVsZeroAndLast = FindIfCurveISonZ($rebuildit);
if (($edgeZsetA == 1) && ($edgeZsetB == 1)){
print "Intersects edgeZset Curves";
string $CurveSelectionZ[];
int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );	
$CurveSelectionZ[0] = ($rebuildit[0] + ".cv[" +  "0:" + $numCVrealNum + "]") ;
if ($CVsZeroAndLast == 2){
string $CurveSelectionX[];
$CurveSelectionX = `ls -fl $CurveSelectionZ[0]`;
for ($eachZA in $CurveSelectionX) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
move -ws 0 $eachCVpos[1] $eachCVpos[2] $eachZA ; 
}
}
xform -cp;
}
}
}
}
ResetTranslation($rebuildit);
select -r $rebuildit;
//string $ParentArc[];
//$ParentArc = Strait_ARC_or_FreeForm($rebuildit,  5.5, 2.5 );
print $CVsZeroAndLast;
//FROM HERE DOWN all -- $rebuildit -- strings[]  WERE $ParentArc  

if($CVsZeroAndLast < 2){
select -r $rebuildit;
MirrorANDrename($rebuildit);
}

if ( $CVsZeroAndLast > 0){ 
sets -include ZEdgeCurvesSet $rebuildit;
 }
ArrayInsertAtEnd( $INarrayA, $rebuildit[0]);
ResetTranslation($rebuildit);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $rebuildit;
select -r $rebuildit[0];
EvalAddingCurves;
EvalcreatSphere;
////////////////////TRIGGER###################### #######////////////////
}
RemoveNoLongerExistingFromArray ($digitalSkeletonA);
if (size($digitalSkeletonA) > 0){
delete $digitalSkeletonA;
}
RemoveNoLongerExistingFromArray ($AllparamlocatorZ);
if (size($AllparamlocatorZ) > 0){
delete $AllparamlocatorZ;
} 
if ( `objExists $SEspaceLocSetofSetz` == 1  ) { 	
select -r -ne $SEspaceLocSetofSetz;
delete;
}
}


proc string ConvertPolyFacesIntoNurbSurface(){
string $PolyFaceslist[] = `ls -sl`;
string $NewPolyFaces[] = ` polyChipOff -ch 1 -kft  1 -dup 0 -off 0 $PolyFaceslist`;
print $NewPolyFaces;
string $HistoryConnections[] = ` listHistory - future true -pruneDagObjects false  $NewPolyFaces`;
string $polySep[] = `polySeparate -rs 1 -ch 0  $HistoryConnections[1]`;
select -r $polySep[1];
string $PolygonNew[0] = {$polySep[1]};
parent -w $PolygonNew;
string $PolyFaces = ( $PolygonNew[0] +".f[*]");
string $AllPolyFaces[] = `ls -fl $PolyFaces`;
string $AllPolyFaces2[] = `ls $PolyFaces`;

string $diffEdgeVertz[] = GetEdgeVertex ($PolygonNew);
string $ReturnObjects = "";
float $valuesP[];

for ($eachP in $diffEdgeVertz){
$valuesP = `pointPosition -w ($eachP)`;	
string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorCX`; 
move -ws $valuesP[0] $valuesP[1] $valuesP[2]  $spaceLocatorB;
$ReturnObjects += $spaceLocatorB[0]+" ";
}
string $DiffPolyBorderEdges[] =  GetdiffEdgesOfBorder($PolygonNew);
string $SelectedPolyBorderEdges[] =  PolyBorderEdges($PolygonNew);

	int $sizeBorderEdges = size ($SelectedPolyBorderEdges) -1;
string $EdgeVertzStart[0] = {$diffEdgeVertz[0]};
stringArrayRemoveAtIndex(0, $diffEdgeVertz);
string $NearEdges[] = GetNearEdges ($EdgeVertzStart);
string $NearEdgesOne[0] = {$NearEdges[0]};
string $NearEdgesSecond[0] = {$NearEdges[1]};
appendStringArray($DiffPolyBorderEdges,  $NearEdgesSecond, 1);
 string $diffA[] = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdges);
string $orderedArray[0] = {$NearEdgesOne[0]};
int $Xi = 1;
while ($Xi < $sizeBorderEdges){
$Xi++;
string $NearEdgesA[] = GetNearEdges ($NearEdgesOne);
appendStringArray($DiffPolyBorderEdges,  $NearEdgesOne, 1);
  string $diffB[] = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdgesA);

string $EdgesVertex[] = ls(" -fl",polyListComponentConversion(" -toVertex",$diffB[0]));
int $ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
appendStringArray($orderedArray, $diffB, 1);
$NearEdgesOne = $diffB;
}
appendStringArray($orderedArray,  $NearEdgesSecond, 1);

$EdgeLists = "";
int $iix = 0;
int $iiV = 0;
for ($each in $orderedArray){
string $oneItem[0] = {$each};
string $EdgesVertex[] = ls(" -fl",polyListComponentConversion("-toVertex",  $oneItem[0]));
if ( $iix > 0){
$ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
if ( $ifTrue == 1){ $iiV++; if ( $iiV == 1){
$EdgeLists += " "+$oneItem[0]+" "+"VERT";} if (  $iiV == 2){ $EdgeLists += " "+$oneItem[0]; $iiV =  0; } }
if ( $ifTrue == 0){ $EdgeLists += " "+$oneItem [0]; }
}
if ( $iix == 0){  $EdgeLists += $oneItem[0]; }
$iix++;
}

string $bufferList[];
$numTokens = `tokenize $EdgeLists "VERT"  $bufferList`;
string $EdgeCurves[];
clear $EdgeCurves;
string $EdgesVertexEach[];
string $ListA[];
  for($eachBuffer in $bufferList){
string $ListA[] = `stringToStringArray  $eachBuffer " "`;
//string $EdgesVertexEach[] = ls(" -fl",polyListComponentConversion("-toVertex",  $ListA));
string $EdgesVertexEachOrder[] =  VertLoopEdgeLoop($ListA);
	$curve = "curve -d 1";	
float $values[];
  for($eachVert in $EdgesVertexEachOrder){ 
$values = `pointPosition -w ($eachVert)`;		
	$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
}
string $Newcurvez = `eval($curve)`;
string $NewcurveX[];
$NewcurveX = {$Newcurvez};
appendStringArray($EdgeCurves, $NewcurveX, 1);

}
select -r $EdgeCurves;
string $NurbSurfaceFromPolyFaces =  `alternativeBoundry`;
delete -ch $EdgeCurves;
delete $PolygonNew;
$ReturnObjects += $NurbSurfaceFromPolyFaces;
$ReturnObjects += " "+$EdgeCurves[0] +"  "+$EdgeCurves[1] +" "+$EdgeCurves[2] +"  "+$EdgeCurves[3] ;
select -r $EdgeCurves;
print $ReturnObjects;
return $ReturnObjects;
}


/////////////////////


proc string[] CreatePolyFromFloats(float  $BoxPointsX[]){

float $bbox[] = $BoxPointsX;
float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox [2]};
float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox [5]};
float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox [2]};
float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox [5]};
///
vector $BoxPointZ[];
$BoxPointZ[0] = <<$bbox[0], $bbox[4], $bbox[2]>>;
$BoxPointZ[1] = <<$bbox[3], $bbox[4], $bbox[2]>>;
$BoxPointZ[2] = <<$bbox[3], $bbox[4], $bbox[5]>>;
$BoxPointZ[3] = <<$bbox[0], $bbox[4], $bbox[5]>>;

int $sizeVecBox = size($BoxPointZ);
string $polyZ = "polyCreateFacet";
int $ZiI = 0;
progressWindow -ii true -title "Working" -status  "Moving Verts" -max (size($BoxPointZ)) -progress  0;
while ($ZiI < $sizeVecBox){
	float $values[] = $BoxPointZ[$ZiI];
$polyZ += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
$ZiI++;
	progressWindow -e -s 1;
				if (`progressWindow -q -ic`)
				{
					 progressWindow -endProgress;
					error  "User Interupt.";
				}


}
print $polyZ;
string $NewPolyZz[0] = `eval($polyZ)`;
progressWindow -endProgress;
select -r $NewPolyZz;
ResetTranslation($NewPolyZz);
return $NewPolyZz;
}


///////////////////////////////////////////////// /////////////////////////////////


global proc float GetDistancePointPositionFLOAT (string $objectFirst, string $objectSecond){
float $pointAZ1[]; float $pointAZ2[];
if (catch($pointAZ1 = `pointPosition -w  ($objectFirst)`)){
print "using Xform"; $pointAZ1 = `xform -q -ws -rp ($objectFirst)`;
	} 
if (catch($pointAZ2 = `pointPosition -w  ($objectSecond)`)){
print "using Xform"; $pointAZ1 = `xform -q -ws -rp ($objectSecond)`;
	} 
$dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy =  $pointAZ1[1] - $pointAZ2[1];
$dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2; 
float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
return $distanceA2; 
}



///////////////////////////////////////////////// ////////////

 proc string alternativeBoundry(){
	int $hist = `constructionHistory -q - tgl`;
	global int $gSelectNurbsCurvesBit;
	global int $gSelectIsoparmsBit;
	global int $gSelectCurvesOnSurfacesBit;
	global int $gSelectSurfaceEdgeBit;
	string $curves[] = `filterExpand -ex true  -sm $gSelectNurbsCurvesBit -sm  $gSelectIsoparmsBit -sm  $gSelectCurvesOnSurfacesBit -sm    $gSelectSurfaceEdgeBit`;
	string $surface = "";
	int $n = size($curves);
	int $i;
	if( $n < 4 ) return $surface;
	string $cmd = "boundary -or 0 -ep 0 -rn 1  -po 0 -ept 0.001 -ch  " + $hist + " ";
	// Rebuild them into linears (keep cvs):
	for( $i=0; $i<$n; $i+=1 ) {
		string $now[] = `rebuildCurve -ch  0 -rpo 1 -kcp on -d 1 -rt 0 $curves[$i]`;
		$curves[$i] = $now[0];
		$cmd = $cmd + $curves[$i] + " ";
	}

	// Convert back into cubic:
	string $res[] = eval($cmd);
	if( size($res) > 0 ) {
		$surface = $res[0];
rebuildSurface -ch $hist -rpo 1 -rt 0 -end 1 -kr  0 -kcp 0 -kc 0 -su 0 -du 3 -sv 0 -dv 3 -tol 0.001  -fr 0  -dir 2 $surface;		
	}

	if( !$hist ) {
		for( $i=0; $i<$n; $i+=1 ) {
			delete $curves[$i];
		}
	}

	select -r $curves;
	return $surface;
}



///////////////////////////////////////////////// //////////////

	
	global proc CreateCircleINpolyFaces(){

string $FirstPolyFaceslist[] = `ls -sl`;
string $bufferListShape[];
$numTokensA = `tokenize $FirstPolyFaceslist[0]  "." $bufferListShape`;
print  $bufferListShape;
string $PolyName[0] = {$bufferListShape[0]};

string $nurbSurfaceSelectionC  =  `ConvertPolyFacesIntoNurbSurface`;
string $ListofItemConvert[] =  `stringToStringArray $nurbSurfaceSelectionC " "`;

print $nurbSurfaceSelectionC ;
string $FirstPolyEdgelist[] = `ls -sl`;
select -r $FirstPolyEdgelist;
print $FirstPolyEdgelist;

int $CurveEPzCount[];
int $Xiii = 0;
string $CurveEPzCountS[];
for ($eachEP in $FirstPolyEdgelist){
	string $CurveSelection[] = `ls -fl  ($eachEP+".ep[0:*]")`; 
	 $CurveEPzCountS[$Xiii] = size ($CurveSelection);
$Xiii++;
}


print  $CurveEPzCountS;
  string $CurveEPNumbersList[] =  stringArrayRemoveDuplicates( $CurveEPzCountS);


//$CurveEPNumbersList = `sort  $CurveEPNumbersList`;
int $SpanX = $CurveEPNumbersList[0];
$SpanX = $SpanX - 1;
int $SpanZ = $CurveEPNumbersList[1];
$SpanZ = $SpanZ - 1;
int $ifEqual = 0;
if ($SpanX == $SpanZ ){ $ifEqual = 1;}
//boundarySurface2.v[0] in V $NurbsBorderCv  Number
//LOC
string $CLocators[] = { $ListofItemConvert[0],  $ListofItemConvert[1], $ListofItemConvert[2],  $ListofItemConvert[3]};
//SURF
string $nurbSurfaceSelectionZ[] =   {$ListofItemConvert[4]} ;
string $MiddleNurbSurface = (  $nurbSurfaceSelectionZ[0] +".uv[0.5][0.5]");
float $middlePoint[] = `pointPosition -w  $MiddleNurbSurface`;
string $FourPointsNurbSurA = (  $nurbSurfaceSelectionZ[0] +".uv[0.9][0.5]");
string $FourPointsNurbSurB = (  $nurbSurfaceSelectionZ[0] +".uv[0.1][0.5]");
string $FourPointsNurbSurC = (  $nurbSurfaceSelectionZ[0] +".uv[0.5][0.9]");
string $FourPointsNurbSurD = (  $nurbSurfaceSelectionZ[0] +".uv[0.5][0.1]");
float $distancePointZ[] =  {GetDistancePointPositionFLOAT ($FourPointsNurbSurA, $FourPointsNurbSurB),  GetDistancePointPositionFLOAT   ($FourPointsNurbSurC, $FourPointsNurbSurD)};
int $AB = 0; 
int $surfaceAB;
int $surfaceCD;
$surfaceAB = $SpanZ;
$surfaceCD = $SpanX;

if ($distancePointZ[0] > $distancePointZ[1]){ 
$AB = 1;
} else { $AB = 0; }
/*
if ( $AB == 1 ){
$surfaceAB = $SpanX;
$surfaceCD = $SpanZ; } else { $surfaceAB =  $SpanZ;
$surfaceCD = $SpanX; }
*/
float $newdistance[] = `sort $distancePointZ`;
print $distancePointZ;
float $CircleDZ = $newdistance[0] / 2.75;
string $circleshape[];
clear $circleshape;
string $circleshape[] = `circle -c 0 0 0 -nr 0 1  0 -sw 360 -r $CircleDZ -d 3 -ut 0 -tol 0.001 -s 8  -ch 1`;
move -ws $middlePoint[0] $middlePoint[1]  $middlePoint[2] $circleshape;
normalConstraint -weight 1 -aimVector 0 1 0 - upVector 0 1 0 -worldUpType "vector" - worldUpVector 0 1 0 $nurbSurfaceSelectionZ  $circleshape;
string $myCurve =  $circleshape[0];
string $allcurvesB[];
clear $allcurvesB;
for($eachLOC in $CLocators){
      $myCPOC = `createNode closestPointOnCurve`;
      connectAttr ($myCurve+".worldSpace")  ($myCPOC+".inCurve");
//delete THIS when done/////////////
      $spaceResultA = `spaceLocator -p 0 0 0 -n  LocatorC`; 
      $LOCB = $spaceResultA[0];
      connectAttr ($myCPOC+".position")  ($LOCB+".translate");
      $LocA = $eachLOC;
      connectAttr ($LocA+".translate")  ($myCPOC+".inPosition");
float $valuesZ1[] = getAttr  ($myCPOC+".position");
float $valuesZ2[];
$valuesZ2 = `pointPosition -w ($LocA)`;	
string $curveBetween[] = MakeCurveBetweenFloats ($valuesZ1, $valuesZ2);
appendStringArray($allcurvesB, $curveBetween,1);
delete $LOCB $myCPOC;
}
///////////////////////////////////
string $ProjecCurvs = "";
for($eachCurvB in $allcurvesB){
string $proJCurv[] = `projectCurve -ch true -rn  false -un  true  -tol 0.001 $eachCurvB  $nurbSurfaceSelectionZ `;
	$ProjecCurvs += $proJCurv[1]+"\+"+" "; }
    string $ProjecCurvresultA =  substituteAllString($ProjecCurvs, "jectC",  "jectionC");
print $ProjecCurvresultA;
string $ProjecCurvsB = $ProjecCurvresultA;
string $ProjecCurvresultB = substituteAllString ($ProjecCurvsB, "+", "_Shape1");  
print $ProjecCurvresultB;    
string $ListProjecCurv[] = `stringToStringArray  $ProjecCurvresultB " "`;
//## End of Corner Curves Start of Circle  Projection //
string $proJCurvA[] = `projectCurve -ch true -rn  false -un  true  -tol 0.001 $circleshape[0]  $nurbSurfaceSelectionZ `;
string $ProjecCurvsA = "";
$ProjecCurvsA += $proJCurvA[1]+"\+"+" ";
    string $ProjecCurvresultC =  substituteAllString($ProjecCurvsA, "jectC",  "jectionC");
string $ProjecCurvsD = $ProjecCurvresultC;
    string $ProjecCurvresultE =  substituteAllString($ProjecCurvsD, "+",  "_Shape1");
string $ListProjecCurvF[] = `stringToStringArray  $ProjecCurvresultE " "`;
print $ProjecCurvsD ;
print $ListProjecCurvF;
string $boundZ1[];
string $thelist[] = { $ListProjecCurv[0],  $ListProjecCurv[1], $ListProjecCurv[2],  $ListProjecCurv[3], $ListProjecCurvF[0] };

string $FourPointsNurbSurA = (  $nurbSurfaceSelectionZ[0] +".uv[0.9][0.5]");
string $FourPointsNurbSurB = (  $nurbSurfaceSelectionZ[0] +".uv[0.1][0.5]");
string $FourPointsNurbSurC = (  $nurbSurfaceSelectionZ[0] +".uv[0.5][0.9]");
string $FourPointsNurbSurD = (  $nurbSurfaceSelectionZ[0] +".uv[0.5][0.1]");

string $surfaceA[] = `trim -ch on -o on -rpo off  -lu 0.9 -lv 0.5 $nurbSurfaceSelectionZ[0]  $thelist[0] $thelist[0] $thelist[1] $thelist[2]    $thelist[3] $thelist[4]`;
string $surfaceB[] = `trim -ch on -o on -rpo off  -lu 0.1 -lv 0.5 $nurbSurfaceSelectionZ[0]  $thelist[0] $thelist[0] $thelist[1] $thelist[2]    $thelist[3] $thelist[4]`;
string $surfaceC[] = `trim -ch on -o on -rpo off  -lu 0.5 -lv 0.9 $nurbSurfaceSelectionZ[0]  $thelist[0] $thelist[0] $thelist[1] $thelist[2]    $thelist[3] $thelist[4]`;
string $surfaceD[] = `trim -ch on -o on -rpo off  -lu 0.5 -lv 0.1 $nurbSurfaceSelectionZ[0]  $thelist[0] $thelist[0] $thelist[1] $thelist[2]    $thelist[3] $thelist[4]`;
string $AllsurfaceA_D[] = {$surfaceA[0],  $surfaceB[0], $surfaceC[0], $surfaceD[0]};
string $trimedSurfA[] = `rebuildSurface -ch 1 - rpo 1 -rt 6 -end 1 -kr 2 -kcp 0 -kc 0 -su 3 -du 0  -sv $surfaceAB -dv 0 -tol 0.001 -fr 0  -dir 2    $surfaceA[0]`;
string $trimedSurfB[] = `rebuildSurface -ch 1 - rpo 1 -rt 6 -end 1 -kr 2 -kcp 0 -kc 0 -su 3 -du 0  -sv $surfaceAB -dv 0 -tol 0.001 -fr 0  -dir 2    $surfaceB[0]`;
string $trimedSurfC[] = `rebuildSurface -ch 1 - rpo 1 -rt 6 -end 1 -kr 2 -kcp 0 -kc 0 -su 3 -du 0  -sv $surfaceCD -dv 0 -tol 0.001 -fr 0  -dir 2    $surfaceC[0]`; 
string $trimedSurfD[] = `rebuildSurface -ch 1 - rpo 1 -rt 6 -end 1 -kr 2 -kcp 0 -kc 0 -su 3 -du 0  -sv $surfaceCD -dv 0 -tol 0.001 -fr 0  -dir 2    $surfaceD[0]`;

string $finalSurface[] = `makeSingleSurface -mnd  1  -ch 1 -f 2 -pt 1 -pc 58 -chr 0.9 -ft 0.01 -mel  0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -   ucr 0 -cht 0.01 -es 0 -ntr 0 -stitchTolerance  0.6099 $trimedSurfA[0] $trimedSurfB[0]  $trimedSurfC[0] $trimedSurfD[0]`;


delete -ch $finalSurface[0] $thelist  $nurbSurfaceSelectionZ $allcurvesB;
delete $allcurvesB;
delete $thelist;
delete $CLocators $nurbSurfaceSelectionZ ;
delete -ch $AllsurfaceA_D;
delete $AllsurfaceA_D;
delete $FirstPolyEdgelist;
string $combinedPolys[] = `polyUnite -ch 0  $PolyName $finalSurface[0]`;
//polyMergeVertex  -d 0.475 -am 1 -ch 0  $combinedPolys[0];
print $finalSurface;
print $PolyName;
print $circleshape;

}

/////////////////////END


global proc int FindifArraysContain(string  $FirstList[], string $array2[]){
  int $found;
int $Trigger;
for ($each in $FirstList){
string $oneItemz = $each;
$found = stringArrayContains($oneItemz, $array2);
if ( $found == 1 ){ $Trigger = 1; break; }
}
return $Trigger;
}

proc ArrayToVertexFaceNormal(){
$list = `ls -sl`;
$surface = $list[0];
$object = $list[1];
string $PolyFaceZ = ( $surface +".f[*]");
string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
select -r $AllPolyFaceZ;
ShrinkPolygonSelectionRegion;
string $EdgePolyFaceZ[] = `ls -sl -fl`;
string $PolyEdgelistA[] = ls("- fl",polyListComponentConversion(  "-toVertex",  "-fromFace",$EdgePolyFaceZ));
select -cl  ;
string $newobject[];
//
for ($eachV in $PolyEdgelistA){
string $Vert = $eachV;
	$newobject = `duplicate -rr -un $object`;	
		float $pos[];	
	$pos = `pointPosition -w $Vert`;	
	move  -ws $pos[0] $pos[1] $pos[2]  $newobject;
normalConstraint -weight 1 -aimVector 0 1 0 - upVector 0 1 0 -worldUpType "vector" - worldUpVector 0 1 0 $surface $newobject; 
}
}



 proc string[] ConvertPolyPlaneIntoNurbSurfaceZ (string $PolygonNew[]){

string $PolyFaces = ( $PolygonNew[0] +".f[*]");
string $AllPolyFaces[] = `ls -fl $PolyFaces`;
string $AllPolyFaces2[] = `ls $PolyFaces`;

string $diffEdgeVertz[] = GetEdgeVertex ($PolygonNew);
string $ReturnObjects = "";
float $valuesP[];

for ($eachP in $diffEdgeVertz){
$valuesP = `pointPosition -w ($eachP)`;	
string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorCX`; 
move -ws $valuesP[0] $valuesP[1] $valuesP[2]  $spaceLocatorB;
$ReturnObjects += $spaceLocatorB[0]+" ";
}
string $DiffPolyBorderEdges[] =  GetdiffEdgesOfBorder($PolygonNew);
string $SelectedPolyBorderEdges[] =  PolyBorderEdges($PolygonNew);

	int $sizeBorderEdges = size ($SelectedPolyBorderEdges) -1;
string $EdgeVertzStart[0] = {$diffEdgeVertz[0]};
stringArrayRemoveAtIndex(0, $diffEdgeVertz);
string $NearEdges[] = GetNearEdges ($EdgeVertzStart);
string $NearEdgesOne[0] = {$NearEdges[0]};
string $NearEdgesSecond[0] = {$NearEdges[1]};
appendStringArray($DiffPolyBorderEdges,  $NearEdgesSecond, 1);
 string $diffA[] = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdges);
string $orderedArray[0] = {$NearEdgesOne[0]};
int $Xi = 1;
while ($Xi < $sizeBorderEdges){
$Xi++;
string $NearEdgesA[] = GetNearEdges ($NearEdgesOne);
select -r $NearEdgesA;
appendStringArray($DiffPolyBorderEdges,  $NearEdgesOne, 1);
  string $diffB[] = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdgesA);
select -r $diffB;
string $EdgesVertex[] = ls(" -fl",polyListComponentConversion("- toVertex",$diffB[0]));
int $ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
appendStringArray($orderedArray, $diffB, 1);
$NearEdgesOne = $diffB;
}
appendStringArray($orderedArray,  $NearEdgesSecond, 1);

$EdgeLists = "";

int $iix = 0;
int $iiV = 0;
for ($each in $orderedArray){
string $oneItem[0] = {$each};
string $EdgesVertex[] = ls(" -fl",polyListComponentConversion("-toVertex",  $oneItem[0]));
playButtonStepForward;
select -r $EdgesVertex;
playButtonStepForward;
if ( $iix > 0){
$ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
if ( $ifTrue == 1){ $iiV++; if ( $iiV == 1){
$EdgeLists += " "+$oneItem[0]+" "+"VERT";} if (  $iiV == 2){ $EdgeLists += " "+$oneItem[0]; $iiV =  0; } }
if ( $ifTrue == 0){ $EdgeLists += " "+$oneItem [0]; }
}
if ( $iix == 0){  $EdgeLists += $oneItem[0]; }
$iix++;
}

string $bufferList[];
$numTokens = `tokenize $EdgeLists "VERT"  $bufferList`;
string $EdgeCurves[];
clear $EdgeCurves;
string $EdgesVertexEach[];
string $ListA[];
  for($eachBuffer in $bufferList){
string $ListA[] = `stringToStringArray  $eachBuffer " "`;
//string $EdgesVertexEach[] = ls(" -fl",polyListComponentConversion("-toVertex",  $ListA));
string $EdgesVertexEachOrder[] =  VertLoopEdgeLoop($ListA);
	$curve = "curve -d 1";	
float $values[];
  for($eachVert in $EdgesVertexEachOrder){  playButtonStepForward; 
select -r $eachVert; playButtonStepForward;
$values = `pointPosition -w ($eachVert)`;		
	$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
}
string $Newcurvez = `eval($curve)`;
string $NewcurveX[];
$NewcurveX = {$Newcurvez};
appendStringArray($EdgeCurves, $NewcurveX, 1);

}
select -r $EdgeCurves;
string $NurbSurfaceFromPolyFaces[0] =  {`alternativeBoundry`};
delete -ch $NurbSurfaceFromPolyFaces;
delete -ch $EdgeCurves;
delete $PolygonNew;
string $ListofItemConvert[] =  `stringToStringArray $ReturnObjects " "`;
delete $ListofItemConvert;
return $NurbSurfaceFromPolyFaces;
}




///////////////////////////////////////////////// ////////////////////////////////////////

/////////////////////////////////////
 proc string ConvertPolyFacesIntoNurbSurface(){

string $PolyFaceslist[] = `ls -sl`;
string $NewPolyFaces[] = ` polyChipOff -ch 1 -kft  1 -dup 0 -off 0 $PolyFaceslist`;
print $NewPolyFaces;
string $HistoryConnections[] = ` listHistory - future true -pruneDagObjects false  $NewPolyFaces`;
string $polySep[] = `polySeparate -rs 1 -ch 0  $HistoryConnections[1]`;
select -r $polySep[1];
string $PolygonNew[0] = {$polySep[1]};
parent -w $PolygonNew;
select -r $PolygonNew;
print $PolygonNew ;
string $PolyFaces = ( $PolygonNew[0] +".f[*]");
string $AllPolyFaces[] = `ls -fl $PolyFaces`;
string $AllPolyFaces2[] = `ls $PolyFaces`;

string $diffEdgeVertz[] = GetEdgeVertex ($PolygonNew);
string $ReturnObjects = "";
float $valuesP[];

for ($eachP in $diffEdgeVertz){
$valuesP = `pointPosition -w ($eachP)`;	
string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorCX`; 
move -ws $valuesP[0] $valuesP[1] $valuesP[2]  $spaceLocatorB;
$ReturnObjects += $spaceLocatorB[0]+" ";
}
string $DiffPolyBorderEdges[] =  GetdiffEdgesOfBorder($PolygonNew);
string $SelectedPolyBorderEdges[] =  PolyBorderEdges($PolygonNew);

	int $sizeBorderEdges = size ($SelectedPolyBorderEdges) -1;
string $EdgeVertzStart[0] = {$diffEdgeVertz[0]};
stringArrayRemoveAtIndex(0, $diffEdgeVertz);
string $NearEdges[] = GetNearEdges ($EdgeVertzStart);
string $NearEdgesOne[0] = {$NearEdges[0]};
string $NearEdgesSecond[0] = {$NearEdges[1]};
appendStringArray($DiffPolyBorderEdges,  $NearEdgesSecond, 1);
 string $diffA[] = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdges);
string $orderedArray[0] = {$NearEdgesOne[0]};
int $Xi = 1;
while ($Xi < $sizeBorderEdges){
$Xi++;
string $NearEdgesA[] = GetNearEdges ($NearEdgesOne);
select -r $NearEdgesA;
appendStringArray($DiffPolyBorderEdges,  $NearEdgesOne, 1);
  string $diffB[] = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdgesA);
select -r $diffB;
string $EdgesVertex[] = ls(" -fl",polyListComponentConversion("- toVertex",$diffB[0]));
int $ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
appendStringArray($orderedArray, $diffB, 1);
$NearEdgesOne = $diffB;
}
appendStringArray($orderedArray,  $NearEdgesSecond, 1);

$EdgeLists = "";

int $iix = 0;
int $iiV = 0;
for ($each in $orderedArray){
string $oneItem[0] = {$each};
string $EdgesVertex[] = ls(" -fl",polyListComponentConversion("-toVertex",  $oneItem[0]));
playButtonStepForward;
select -r $EdgesVertex;
playButtonStepForward;
if ( $iix > 0){
$ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
if ( $ifTrue == 1){ $iiV++; if ( $iiV == 1){
$EdgeLists += " "+$oneItem[0]+" "+"VERT";} if (  $iiV == 2){ $EdgeLists += " "+$oneItem[0]; $iiV =  0; } }
if ( $ifTrue == 0){ $EdgeLists += " "+$oneItem [0]; }
}
if ( $iix == 0){  $EdgeLists += $oneItem[0]; }
$iix++;
}

string $bufferList[];
$numTokens = `tokenize $EdgeLists "VERT"  $bufferList`;
string $EdgeCurves[];
clear $EdgeCurves;
string $EdgesVertexEach[];
string $ListA[];
  for($eachBuffer in $bufferList){
string $ListA[] = `stringToStringArray  $eachBuffer " "`;
//string $EdgesVertexEach[] = ls(" -fl",polyListComponentConversion("-toVertex",  $ListA));
string $EdgesVertexEachOrder[] =  VertLoopEdgeLoop($ListA);
	$curve = "curve -d 1";	
float $values[];
  for($eachVert in $EdgesVertexEachOrder){  playButtonStepForward; 
select -r $eachVert; playButtonStepForward;
$values = `pointPosition -w ($eachVert)`;		
	$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
}
string $Newcurvez = `eval($curve)`;
string $NewcurveX[];
$NewcurveX = {$Newcurvez};
appendStringArray($EdgeCurves, $NewcurveX, 1);

}

string $NurbSurfaceFromPolyFaces[0] =  {`alternativeBoundry`};
delete -ch $NurbSurfaceFromPolyFaces;
delete -ch $EdgeCurves;
delete $PolygonNew;
$ReturnObjects += $NurbSurfaceFromPolyFaces[0];
select -r $EdgeCurves;
print $ReturnObjects;
return $ReturnObjects;
}

///////////////////////////////////////////////// ////////////////////////////////////////

///////////////////////////////////////////////// ////////////////////////////////////////Procs  Needed For Above Global Proc

global proc string[] GetNearEdges(string  $edgeArray[]){
string $PolyVertexFromEdges[] = ls(" -fl",polyListComponentConversion("- toVertex",$edgeArray[0]));
string $PolyEdgesFromVertex[] = ls(" -fl",polyListComponentConversion("-toEdge",  $PolyVertexFromEdges));
return $PolyEdgesFromVertex;
} 




global proc string[] VertLoopEdgeLoop(string  $edgeZ[]){

	string	$verts[];
	string $v0[]=`polyListComponentConversion  -tv $edgeZ[0]`;
		$v0=`ls -fl $v0`;
	string $v1[]=`polyListComponentConversion  -tv $edgeZ[1]`;
		$v1=`ls -fl $v1`;
		$v0=`stringArrayRemove $v1 $v0`;
		$verts[0]=$v0[0];
		
		for($i=0;$i<size($edgeZ);$i++)
		{
			string 	$v0[] =`polyListComponentConversion -tv $edgeZ[$i]`;
			
				$v0=`ls -fl $v0`;
				 $v0=`stringArrayRemove $verts $v0`;
				$verts[size ($verts)]=$v0[0];
		}
		
	return	$verts;
}




global proc int IfIntersect(string $ArrayA[],  string $ArrayB[]){
string $myIntersector = `stringArrayIntersector`;
stringArrayIntersector -edit -intersect $ArrayA  $myIntersector;
stringArrayIntersector -edit -intersect $ArrayB  $myIntersector;
string $findIntersection[] =  `stringArrayIntersector -query $myIntersector`;
stringArrayIntersector -edit -reset  $myIntersector;
int $sizeofItems = size($findIntersection);
return $sizeofItems;
}


global proc string[] PolyBorderEdges(string  $polyZ[]){
string $PolyFaceZ = ( $polyZ[0] +".f[*]");
string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
string $PolyEdgesFromFaceZ[] =  ls(" -fl",polyListComponentConversion("- toEdge",$AllPolyFaceZ));
select -r $PolyEdgesFromFaceZ;
polyConvertToShellBorder;
string $SelectedPolyBorderEdgeZ[] = `ls -sl -fl`;
return $SelectedPolyBorderEdgeZ;
}




global proc string[] GetdiffEdgesOfBorder(string  $poly[]){
string $PolyFaceZ = ( $poly[0] +".f[*]");
string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
string $PolyEdgesFromFaceZ[] =  ls(" -fl",polyListComponentConversion("- toEdge",$AllPolyFaceZ));
select -r $PolyEdgesFromFaceZ;
polyConvertToShellBorder;
string $SelectedPolyBorderEdgeZ[] = `ls -sl -fl`;
  string $diffEdgeZ[] = stringArrayRemoveExact ($SelectedPolyBorderEdgeZ, $PolyEdgesFromFaceZ);
select -r $diffEdgeZ;
return $diffEdgeZ;
}


global proc string[] GetEdgeVertex(string $poly []){
string $PolyFaceZ = ( $poly[0] +".f[*]");
string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
select -r $AllPolyFaceZ;
polyConvertToShellBorder;
ConvertSelectionToContainedEdges;
ConvertSelectionToContainedFaces;
string $EdgePolyFaceZ[] = `ls -sl -fl`;
string $PolyEdgelistA[] = ls(" -fl",polyListComponentConversion("-border", "- toVertex", "-fromFace", $EdgePolyFaceZ));
select -r $PolyEdgelistA;
string $PolyEdgelistB[] = ls(" -fl",polyListComponentConversion( "-toVertex", "- fromFace", $EdgePolyFaceZ));
select -r $PolyEdgelistB;
  string $diffEdgeZ[] = stringArrayRemoveExact ($PolyEdgelistA, $PolyEdgelistB);
select -r $diffEdgeZ;
return $diffEdgeZ; 
}




global proc int stringArrayGmatchIndex(string  $itemA[], string $list[]){
string $item = $itemA[0];
	int $result = false;	
int $ResultIndex = 0;
int $Index = 0;	
	string $listItem;	
	for ($EachlistItem in $list) {
		if ( $EachlistItem == $item ){
		$result = true; $ResultIndex =  $Index;
			break;	}
$Index++;
	}	
	return $ResultIndex;
}


global proc polySelectEdgesPattern(string  $method)
{
	string $edges[] = `getEdges`;
	int $size = `size $edges`;

	if ($size > 1)
	{
		string $buffer[];

		tokenize $edges[0] "[]" $buffer;
		string $cmd = "polySelect -";
		$cmd += $method;
		$cmd += " ";
		$cmd += $buffer[1];

		tokenize $edges[1] "[]" $buffer;
		$cmd += " ";
		$cmd += $buffer[1];

		eval($cmd);
	}
}


global proc string[] SortEvenArrays(string  $ArrayItems[]){
string $newItemsList[];
int $getsize = size($ArrayItems);
int $i = 0;	
$iX = 0;
	while($i < $getsize){
$iX++;
if ( $iX == 2){
string $oneitem[0] = {$ArrayItems[$i]};
appendStringArray($newItemsList, $oneitem, 1);
$iX = 0;
}
$i++;
}
return $newItemsList;
}


global proc string[] ArrayFromAllinString(string  $list){

string $singleStringItemB[];
string $singleStringItemA[];
int $i = 0;
int $Indexi = 0;
int $triggerends = 0;
string $listA = $list; 
while ( $triggerends < 1 ) { 
$i++;
$singleStringItemA = {`substring $listA $i $i`};
if (size($singleStringItemA[0]) == 0){
$triggerends = 2; } else {
appendStringArray($singleStringItemB,  $singleStringItemA, 1);
}
$Indexi++;
if ($Indexi == 20){ $triggerends = 2;}
}
return $singleStringItemB;
}


global proc int[] ArrayToIntList(string  $singleStringItemB[]){
int $Numberlist[];
int $triggerendsB = 0;
int $newlistSize = size($singleStringItemB);
int $ci = 0;
while ( $triggerendsB < $newlistSize ) { 
$Numberlist[$ci] = $singleStringItemB[$ci];
$ci++;
$triggerendsB = $triggerendsB + 1;
}
print $Numberlist;
return $Numberlist;
}



global proc string[] CycleNumberString(string  $singleStringItemC[]){
int $SizeOfArray;
$SizeOfArray = size($singleStringItemC) -1;
string $last[0] = {$singleStringItemC [$SizeOfArray]};
string $first[0] = {$singleStringItemC[0]};
  stringArrayRemoveAtIndex(0,  $singleStringItemC);
  appendStringArray($singleStringItemC, $first,  1);
return $singleStringItemC; 
}



proc string[] SortPatternArrays(string  $ArrayItems[], int $NumberlistA[]){

int $getsizeNlist = size($NumberlistA);
int $iN = 0;	
string $newItemsList[];
int $getsize = size($ArrayItems);
int $i = 0;	
$iX = 0;
	while($i < $getsize){
$iX++;
if ( $NumberlistA[$iN] == 0){
string $oneitem[0] = {$ArrayItems[$i]};
appendStringArray($newItemsList, $oneitem, 1);
if ( $iN == $getsizeNlist){ $iN = -1;}
$iX = 0;
}

$iN++;
$i++;
}
return $newItemsList;
}




proc string[] SortEvenArraysInt(string $ArrayItems [], int $Num){

string $newItemsList[];
int $getsize = size($ArrayItems);
int $i = 0;	
$iX = 0;
	while($i < $getsize){
$iX++;
if ( $Num == 2){
if ( $iX == 2){
string $oneitem[0] = {$ArrayItems[$i]};
appendStringArray($newItemsList, $oneitem, 1);
$iX = 0;
}
}

if ( $Num == 1){
if ( $iX == 1){
string $oneitem[0] = {$ArrayItems[$i]};
appendStringArray($newItemsList, $oneitem, 1);
}
if ( $iX == 2){ $iX = 0;}
}

$i++;
}
return $newItemsList;
}



proc string[] CompareCurveIntersect (string  $objectLoc[]){
string $objectLocZ[];
string $CurveintersectZ;
string $ItemLists[];
$objectLocZ = $objectLoc;
int $X = size($objectLocZ) -1;
int $Z = size($objectLocZ);
int $i = 1;
int $n = -1;
int $n2 = 0;
for( $i = 0; $i < $X; $i ++ ) {
$n = $n + 1;
$Z = $Z - 1;
$ix = 0;
$n2 = $n + 1;
while ($Z > $ix++){	
$CurveintersectZ = `curveIntersect -ch 0 - tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2] `;
if (size($CurveintersectZ) > 0) {	
ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
} else { print "no Intersect"; }
$n2++;
}
}
return $ItemLists;
}

////////////


proc string[] CompareCurveIntersectTwoCurves (string $objectLocA[], string $objectAll[]){

string $CurveintersectZA;
string $CurveintersectZB;
string $ItemLists[];

int $Z = size($objectLocA) -1;
int $X = size( $objectAll) -1;
int $ix = 0;
int $n2 = 0;

while ($X > $ix++){	
$CurveintersectZA = `curveIntersect -ch 0 - tolerance 0.001 $objectLocA[0] $objectAll[$n2]`;
if (size($CurveintersectZA) > 0) {	
$CurveintersectZB = `curveIntersect -ch 0 - tolerance 0.001 $objectLocA[1] $objectAll[$n2]`;
if (size($CurveintersectZB) > 0) {	
ArrayInsertAtEnd( $ItemLists, $objectAll[$n2]);
}
} else { print "no Intersect"; }
$n2++;

}
return $ItemLists;
}





proc string[] CompareCurveIntersect4 (string  $objectLoc[]){
string $objectLocZ[];
string $CurveintersectZ;
string $ItemLists[];
$objectLocZ = $objectLoc;
int $X = size($objectLocZ) -1;
int $Z = size($objectLocZ);
int $i = 1;
int $n = -1;
int $n2 = 0;
for( $i = 0; $i < $X; $i ++ ) {
$n = $n + 1;
$Z = $Z - 1;
$ix = 0;
$n2 = $n + 1;
while ($Z > $ix++){	
$CurveintersectZ = `curveIntersect -ch 0 - tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2] `;
if (size($CurveintersectZ) > 0) {	
ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
} else { print "no Intersect"; }
$n2++;
}
}

  string $shorterList[] =  stringArrayRemoveDuplicates($ItemLists);
$ItemLists = $shorterList;
return $ItemLists;
}



proc string[] CompareCurveIntersect2 (string  $object[], string $objectlist[]){

int $X = size($objectlist);

string $ItemListsA[];
$ix = 0;
$iz = 1;
while ($X > $ix++){	

string $CurveintersectZ = `curveIntersect -ch 0  -tolerance 0.001 $object[0] $objectlist[$ix]`;
if (size($CurveintersectZ) > 0) {	
ArrayInsertAtEnd( $ItemListsA, $objectlist[$ix]);
} 
}
return $ItemListsA;
}



proc string[] CompareCurveIntersect5 (string  $objectLoc[], string $objectLocB[]){
string $objectLocZ[];
string $CurveintersectZ;
string $ItemLists[];

$objectLocZ = $objectLoc;

int $X = size($objectLocZ) ;

int $Z = size($objectLocB);
int $i = 1;
int $n = -1;
int $n2 = 0;
for( $i = 0; $i < $X; $i ++ ) {
$n = $n + 1;
$Z = $Z - 1;
$ix = 0;
$n2 = $n + 1;
while ($Z > $ix++){	
$CurveintersectZ = `curveIntersect -ch 0 - tolerance 0.001 $objectLocZ[$n] $objectLocB[$n2] `;
if (size($CurveintersectZ) > 0) {	
ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
} else { print "no Intersect"; }
$n2++;
}
}

  string $shorterList[] =  stringArrayRemoveDuplicates($ItemLists);
$ItemLists = $shorterList;
return $ItemLists;
}



proc setRotationAxis(string $objectitem1[]){
//
string $objectitem1[] = `ls -sl`;
select -cl  ;
string $groupRotAX;
$groupRotAX = `group -w -em -n RotAxiz`; xform - os -piv 0 0 0 $groupRotAX;
string $itemA = $objectitem1[0];
string $itemB = $objectitem1[1];
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0  $itemB;
float $rotationsA[] = `getAttr  ($itemA+".rotate")`;
setAttr ($groupRotAX+".rotate") $rotationsA[0]  $rotationsA[1] $rotationsA[2];
parent -absolute $itemB $groupRotAX;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0  $itemB; parent -w $itemB;
delete $groupRotAX;
}




proc string[] MakeCIRCLE(string $ObjectCurve[]) {


string $CIRCLEX[];
string $ObjectCurveduplicate[] = `duplicate -rr  $ObjectCurve`;
setAttr ($ObjectCurveduplicate[0] + ".translate")  0 0 0;
setAttr ($ObjectCurveduplicate[0] + ".rotate") 0 0 0;
select -cl  ;
float $rotationz[];
$rotationz = `xform -q -rotation $ObjectCurve`;
float $translationz[];
$translationz = `xform -q -translation  $ObjectCurve`;
float $bbox[] = `exactWorldBoundingBox  $ObjectCurveduplicate`;
//print("Bounding box ranges from: " +
//      $bbox[0] + "," + $bbox[1] + "," + $bbox [2] + ", to " +
//      $bbox[3] + "," + $bbox[4] + "," + $bbox [5] + ".\n");
spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
move -ws $bbox[0] $bbox[1] $bbox[2]  BoxspaceLocatorA;
spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
move -ws $bbox[3] $bbox[4] $bbox[5]  BoxspaceLocatorB;
spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
move -ws $bbox[3] $bbox[1] $bbox[2]  BoxspaceLocatorC;
spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;
// xform -query -worldSpace -translation;
/////////////////////////////////////////
float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox [2]};
float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox [5]};
float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox [2]};
float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox [5]};

$BoxPointA = `MakeCleanFloats($BoxPointA)`;
$BoxPointB = `MakeCleanFloats($BoxPointB)`;
$BoxPointC = `MakeCleanFloats($BoxPointC)`;
$BoxPointD = `MakeCleanFloats($BoxPointD)`;

float $BoxMPointAC[] = MidPointBetween ($BoxPointA, $BoxPointC);
float $BoxMPointBD[] = MidPointBetween ($BoxPointB, $BoxPointD);
float $BoxMPointAD[] = MidPointBetween ($BoxPointA, $BoxPointD);
float $BoxMPointBC[] = MidPointBetween ($BoxPointB, $BoxPointC);
//   MoveObjectSelection($BoxMPointAC);

float $BoxMPointAC[] = MidPointBetween ($BoxPointA, $BoxPointC);
float $BoxMPointBD[] = MidPointBetween ($BoxPointB, $BoxPointD);
float $BoxMPointAD[] = MidPointBetween ($BoxPointA, $BoxPointD);
float $BoxMPointBC[] = MidPointBetween ($BoxPointB, $BoxPointC);

float $CrossMPointAB[] = MidPointBetween ($BoxPointA, $BoxPointB);
move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
float $translationzMiddle[];
$translationzMiddle = `xform -q -translation  BoxspaceLocatorMiddle`;

float $distanceA = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointC);
float $distanceB = PointsGetDistanceFLOAT ($BoxPointB, $BoxPointC);
$distanceAverage =  (($distanceA + $distanceB) *  (0.5)) ;
$radiusX = ( $distanceAverage / 2);
//if / then 
float $squarePercentA;
float $squarePercentB;
if ( $distanceA > $distanceAverage) {
$squarePercentA = (( $distanceAverage /  $distanceA ) * (100));
}
if ( $distanceA < $distanceAverage) {
$squarePercentA = (( $distanceA /  $distanceAverage ) * (100));
}
if ( $distanceB > $distanceAverage) {
$squarePercentB = (( $distanceAverage /  $distanceB ) * (100));
}
if ( $distanceB < $distanceAverage) {
$squarePercentB = (( $distanceB /  $distanceAverage ) * (100));
}
/////////////////////
int $squareA;
$squareA = 0;
int $squareB;
$squareB = 0;
print $squarePercentA ;
if ( $squarePercentA > 55)  {
$squareA = (0 + 1); 
} else {
$squareA = 0;
}
print $squareA;
print $squarePercentB ;
if ( $squarePercentB > 55)  {
$squareB = ($squareB + 1);
} else {
$squareB = 0;
}
$addSquareResults = ($squareA + $squareB);

 circle -nr 0 1 0 -c $translationzMiddle[0]  $translationzMiddle[1] $translationzMiddle[2] -r  $radiusX;
$CIRCLEX = `ls -sl`;
float $rotationz[];
$rotationz = `xform -q -rotation $ObjectCurve`;
setAttr ($CIRCLEX[0] + ".rotateX") $rotationz[0];
setAttr ($CIRCLEX[0] + ".rotateY") $rotationz[1];
setAttr ($CIRCLEX[0] + ".rotateZ") $rotationz[2];
float $translationz[];
$translationz = `xform -q -translation  $ObjectCurve[0]`;
setAttr ($CIRCLEX[0] + ".translateX")  $translationz[0];
setAttr ($CIRCLEX[0] + ".translateY")  $translationz[1];
setAttr ($CIRCLEX[0] + ".translateZ")  $translationz[2];

delete $ObjectCurveduplicate  BoxspaceLocatorA BoxspaceLocatorB  BoxspaceLocatorC BoxspaceLocatorD  BoxspaceLocatorMiddle;

string $NewNameZ = `rename $CIRCLEX "$ObjectCurve[0]"`;
delete $ObjectCurve;
$CIRCLEX = {$NewNameZ};
return $CIRCLEX;

}



proc string[] CIRCLESCRIPTZ(string $ObjectCurve[]) {

//CIRCLE SCRIPT

string $CIRCLEX[];

//string $newCircle[] = `CIRCLESCRIPTZ ($drawcurve)`;
//string $ObjectCurve[] = $drawcurve;

string $ObjectCurveduplicate[] = `duplicate -rr  $ObjectCurve`;
setAttr ($ObjectCurveduplicate[0] + ".translate")  0 0 0;
setAttr ($ObjectCurveduplicate[0] + ".rotate") 0  0 0;
select -cl  ;
float $rotationz[];
$rotationz = `xform -q -rotation $ObjectCurve`;
float $translationz[];
$translationz = `xform -q -translation  $ObjectCurve`;
float $bbox[] = `exactWorldBoundingBox  $ObjectCurveduplicate`;
//print("Bounding box ranges from: " +
//      $bbox[0] + "," + $bbox[1] + "," + $bbox [2] + ", to " +
//      $bbox[3] + "," + $bbox[4] + "," + $bbox [5] + ".\n");
spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
move -ws $bbox[0] $bbox[1] $bbox[2]  BoxspaceLocatorA;
spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
move -ws $bbox[3] $bbox[4] $bbox[5]  BoxspaceLocatorB;
spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
move -ws $bbox[3] $bbox[1] $bbox[2]  BoxspaceLocatorC;
spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;
// xform -query -worldSpace -translation;
/////////////////////////////////////////
float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox [2]};
float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox [5]};
float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox [2]};
float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox [5]};

$BoxPointA = `MakeCleanFloats($BoxPointA)`;
$BoxPointB = `MakeCleanFloats($BoxPointB)`;
$BoxPointC = `MakeCleanFloats($BoxPointC)`;
$BoxPointD = `MakeCleanFloats($BoxPointD)`;

float $BoxMPointAC[] = MidPointBetween ($BoxPointA, $BoxPointC);
float $BoxMPointBD[] = MidPointBetween ($BoxPointB, $BoxPointD);
float $BoxMPointAD[] = MidPointBetween ($BoxPointA, $BoxPointD);
float $BoxMPointBC[] = MidPointBetween ($BoxPointB, $BoxPointC);
//   MoveObjectSelection($BoxMPointAC);

float $BoxMPointAC[] = MidPointBetween ($BoxPointA, $BoxPointC);
float $BoxMPointBD[] = MidPointBetween ($BoxPointB, $BoxPointD);
float $BoxMPointAD[] = MidPointBetween ($BoxPointA, $BoxPointD);
float $BoxMPointBC[] = MidPointBetween ($BoxPointB, $BoxPointC);

float $CrossMPointAB[] = MidPointBetween ($BoxPointA, $BoxPointB);
move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
float $translationzMiddle[];
$translationzMiddle = `xform -q -translation  BoxspaceLocatorMiddle`;

float $distanceA = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointC);
float $distanceB = PointsGetDistanceFLOAT ($BoxPointB, $BoxPointC);
$distanceAverage =  (($distanceA + $distanceB) *  (0.5)) ;
$radiusX = ( $distanceAverage / 2);
//if / then 
float $squarePercentA;
float $squarePercentB;
if ( $distanceA > $distanceAverage) {
$squarePercentA = (( $distanceAverage /  $distanceA ) * (100));
}
if ( $distanceA < $distanceAverage) {
$squarePercentA = (( $distanceA /  $distanceAverage ) * (100));
}
if ( $distanceB > $distanceAverage) {
$squarePercentB = (( $distanceAverage /  $distanceB ) * (100));
}
if ( $distanceB < $distanceAverage) {
$squarePercentB = (( $distanceB /  $distanceAverage ) * (100));
}
/////////////////////
int $squareA;
$squareA = 0;
int $squareB;
$squareB = 0;
print $squarePercentA ;
if ( $squarePercentA > 55)  {
$squareA = (0 + 1); 
} else {
$squareA = (0);
}
print $squareA;
print $squarePercentB ;
if ( $squarePercentB > 55)  {
$squareB = ($squareB + 1);
} else {
$squareB = (0);
}
$addSquareResults = ($squareA + $squareB);
if ( $addSquareResults == 2 ){
 circle -nr 0 1 0 -c $translationzMiddle[0]  $translationzMiddle[1] $translationzMiddle[2] -r  $radiusX;
$CIRCLEX = `ls -sl`;
float $rotationz[];
$rotationz = `xform -q -rotation $ObjectCurve`;
setAttr ($CIRCLEX[0] + ".rotateX") $rotationz[0];
setAttr ($CIRCLEX[0] + ".rotateY") $rotationz[1];
setAttr ($CIRCLEX[0] + ".rotateZ") $rotationz[2];
float $translationz[];
$translationz = `xform -q -translation  $ObjectCurve[0]`;
setAttr ($CIRCLEX[0] + ".translateX")  $translationz[0];
setAttr ($CIRCLEX[0] + ".translateY")  $translationz[1];
setAttr ($CIRCLEX[0] + ".translateZ")  $translationz[2];
//TEMP CHANGE
//string $currPanel = `getPanel -withFocus` ,  $camera ;
//$camera = `modelPanel -q -camera $currPanel`;
//setAttr ($CIRCLEX[0] + ".rotate") `getAttr  ($ObjectCurve[0] + ".rotate")`;
delete $ObjectCurve $ObjectCurveduplicate  BoxspaceLocatorA BoxspaceLocatorB  BoxspaceLocatorC BoxspaceLocatorD  BoxspaceLocatorMiddle;
}
else {
delete $ObjectCurveduplicate BoxspaceLocatorA  BoxspaceLocatorB BoxspaceLocatorC  BoxspaceLocatorD BoxspaceLocatorMiddle;
}
string $NewNameZ = `rename $CIRCLEX "Curve"`;
$CIRCLEX = {$NewNameZ};
return $CIRCLEX;

}


proc EvalSmoothCurves(){
SmoothCurvature3(8);
//SmoothCurvatureReverse6(18);
}

proc EvalSmoothCurvesB(){
SmoothCurvatureB3(8);
}

proc string[] Make_Middle_of_Curve_ParamlocatorZ (string $objectCurveSelected[]){

float $arclenghtzALL = `arclen  $objectCurveSelected`;
float $arclenghtzDivide = $arclenghtzALL / 2.0;

int $numCVs = `getAttr -size  ($objectCurveSelected[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($objectCurveSelected[0] +  ".cv[0]") ;			
$CurveSelection[1] = ($objectCurveSelected[0] +  ".cv[" + $numCVrealNum + "]") ;
string $paramlocatorZARC[];
$paramlocatorZARC[0] = eval("paramLocator " +   $objectCurveSelected[0] + ".u[" + 0.0 + "]");

float $step = 10; 
int $a = 1;
  	float $t =  $a/$step;

setAttr ( $paramlocatorZARC[0] +  ".localPositionX") $t;
string $paramANDCurve[] = `paramToCurvePts(  $paramlocatorZARC )`;
float $arclenghtzparamZ = `eval("arclen" + " " +  $paramANDCurve[0])`;

float $divZZ = $arclenghtzDivide /  $arclenghtzparamZ ;
float $divZZ2 = $t * $divZZ ;
setAttr ( $paramlocatorZARC[0] +  ".localPositionX") $divZZ2;
////////////////////// Moved ParamLoc to middle

float $posA[];
float $posB[];
float $posC[];
$posA = `pointPosition -w $CurveSelection[0]`;
$posB = `pointPosition -w $paramlocatorZARC[0]`;
$posC = `pointPosition -w $CurveSelection[1]`;
string $CircularArcFromCurve[];
$CircularArcFromCurve[0] = `createNode  makeThreePointCircularArc`;
setAttr ($CircularArcFromCurve[0] + ".pt1")  $posA[0] $posA[1] $posA[2] ;
setAttr ($CircularArcFromCurve[0] + ".pt2")  $posB[0] $posB[1] $posB[2];
setAttr ($CircularArcFromCurve[0] + ".pt3")  $posC[0] $posC[1] $posC[2];
setAttr ($CircularArcFromCurve[0] + ".d") 3;
setAttr ($CircularArcFromCurve[0] + ".s") 8;
string $ArcCurve[];
$ArcCurve[0] = `createNode nurbsCurve` ; 
connectAttr ($CircularArcFromCurve[0] + ".oc")  ($ArcCurve[0] +".cr");
//delete $objectCurveSelected; 
string $ParentArc[];
$ParentArc = `listRelatives -parent $ArcCurve`;
ResetTranslation($ParentArc);
string $MakeArcLocator[]; $MakeArcLocator =  `spaceLocator -p 0 0 0 -n ArcLocator`;
move -ws $posB[0] $posB[1] $posB[2]  $MakeArcLocator;
$ConnectLocToPoint2 = `connectAttr -f  ($MakeArcLocator[0] + ".translate") (  $CircularArcFromCurve[0] + ".pt2")`;

string $ArcZ[];
$ArcZ[0] = `rename $ParentArc  $objectCurveSelected`; 
delete $paramlocatorZARC;
select -r $ArcZ;
return $ArcZ; 

}

///////////////////////////////////////////////// /////////////////////

///////////////////////////////////////////////// ///////////////////////

	proc string[] Strait_ARC_or_FreeForm (string $renamed[], float $ArcN, float $StraitN  ){


int $free = 0;
string $nameString = $renamed[0];
SetCurveRotation($nameString);
string $ParentArc[];
//smoothCurve -ch 1 -rpo 1 -s 6.60 ($nameString  +".cv[*]");
float $objectAcurve01 = arclen ($renamed);

select -r $nameString;
int $TrueorFalseCircle = `IsCircle`;
if ($TrueorFalseCircle == 1){
string $newCircle[] = `MakeCIRCLE($renamed)`;
$ParentArc = $newCircle;
makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $ParentArc;
}else{

float $curveEndsDis01 =  GetDistanceBetweenCurveEnds($renamed);
float $PercentENDsDiffL = XpercentLess_thenY ($objectAcurve01, $curveEndsDis01);
int $straitTrigger = 0;

if ( $PercentENDsDiffL < 2 ){ $straitTrigger = 1;  }

float $objectAcurveD01 = $objectAcurve01 / 1.5;
int $Cvz = $objectAcurveD01;
if( $objectAcurve01 < 1.0){ $Cvz = 4; }
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001 $renamed;

string $objectB[];
string $objectC[];

string $DeleteCurveA[];
string $DeleteCurveB[];


string $CurveBetween[];
float $PercentDiffS;
if ($straitTrigger == 1){
vector $VectorCurveEndZ[] = VecCurveEnds ($renamed);
float $posA[] =  $VectorCurveEndZ[0];
float $posB[] =  $VectorCurveEndZ[1];
$CurveBetween = MakeCurveBetweenFloats($posA,  $posB);
ResetTranslation($CurveBetween);
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001  $CurveBetween;
$ParentArc = $CurveBetween; $DeleteCurveA =  $renamed; $DeleteCurveB = $objectB;
}


if ( $straitTrigger == 0 ){
string $objectB[] =  Make_Middle_of_Curve_ParamlocatorZ($renamed);
ResetTranslation($objectB);
string $objectC[] = {$renamed[0], $objectB[0]};
ResetTranslationEach($objectC);
float $objectAcurveL = arclen ($renamed);
float $objectBcurveL = arclen ($objectB);
float $PercentDiffL = XpercentLess_thenY ($objectBcurveL, $objectAcurveL);
if ($PercentDiffL  < $ArcN){

$ParentArc = $objectB;  $DeleteCurveA = $renamed; 
}else{ 

$free = 1;
 $ParentArc = $renamed; $DeleteCurveA = $objectB;  }

}

delete $DeleteCurveA;
rename $ParentArc $nameString;
$ParentArc[0] = $nameString;


if ( $free == 1 ){ select -r $ParentArc;  EvalSmoothCurves;
string $nameString = $ParentArc[0];
float $objectAcurve02 = arclen ($renamed);
float $objectAcurveD02 = $objectAcurve02 / 1.5;
int $Cvz2 = $objectAcurveD02;
if( $objectAcurve01 < 1.0){ $Cvz2 = 4; }
//rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 - kcp 0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001  $renamed;
 }

}

return $ParentArc; 

}



proc string[] SmoothCurvature4(float $curveM ,  int $Steps ){

string $curves[] = `ls -sl`;
string $myCurve = $curves[0];
rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = `size  ($CurveSelection)`;
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 3 );
if ($Steps > 8 ){ $numEPrealNum2 = $Steps; }  

string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`; 
$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
int $trigger = 0;
$curve = "";
float $curveMin = $curveM;
while ( $trigger < 1 ){
	float $step = $numEPrealNum2;  
	$curve = "curve -d 3";
	
int $Par = 0;
int $a;
int $ii = 0;	
int $CVpoints = 0;	
  for($a = 0; $a <= $step;$a++){
$ii = $ii + 1;
  	$t =  $a/$step;
 	$Par = ($a/$step);
	setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
  	float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
	float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
		if ( $CurvatureRadi <=  $curveMin){
	$CVpoints++;
	$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
	}

if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
$CVpoints++;
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
}
if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
$CVpoints++;
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
}
}
if ( $CVpoints < 8 ){ $curveMin++; }
if ( $CVpoints >= 8 ){ $trigger = 1; }

}

string $Newcurvez = `eval($curve)`;
string $Newcurve[] = {$Newcurvez};
delete $paramlocatorpointOnCurvex $spaceLocatorB; 
delete $curves;
rename $Newcurve $myCurve;  
$Newcurve = {$myCurve};

return $Newcurve; 
}
//////////////////////////






proc string[] SmoothCurvature13(float $curveM ){

string $curves[] = `ls -sl`;
float $arcL1 = `arclen $curves[0]`;
float $arcL1B = ( $arcL1 + ((-1) * ( $arcL1 / 10  )));
string $myCurve = $curves[0];
string $crShape[] = `listRelatives -s $curves[0] `;
rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 1 );  
string $Newcurve[];
string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`; 
$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
int $trigger = 0;
$curve = "";
int $Par = 0;
int $b = 0;
int $ii = 0;
int $a = 0;
float $curveMin = $curveM;
float $CurvatureRadi2;
string $Newcurvez;
string $Newcurve[];
while ( $trigger < 1 ){
	float $step = $numEPrealNum2;  
	$curve = "curve -d 3";
int $CVpoints = 0;	
  for($a = 0; $a <= $step;$a++){	
$ii = $ii + 1;
  	$t =  $a/$step;
 	$Par = $a/$step;
	setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
if ( $Par > 0.0 ){ $b = $a -1; $Par2 = $b/$step;
	 $CurvatureRadi2 = `pointOnCurve -top 1  -pr $Par2 -cr $crShape[0]`; }
  	float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
	float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;

float $AverageCurvatureRadi = (($CurvatureRadi +  $CurvatureRadi2) / 2);

		if ( $AverageCurvatureRadi <=  $curveMin){
	$CVpoints++;
	$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
	}

if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
$CVpoints++;
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
}
if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
$CVpoints++;
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
}
}
if ( $CVpoints < 8 ){ $curveMin++; }
if ( $CVpoints > 2 ){
string $Newcurvez = `eval($curve)`;
$Newcurve = {$Newcurvez};
float $arcL2 = `arclen $Newcurve[0]`;
if ( $arcL2 < $arcL1B ){ delete $Newcurve;  $trigger = 0; $numEPrealNum2 = $numEPrealNum2 +  3;   }
if (( $CVpoints >= 8 )&& ( $arcL2 > $arcL1B )){  $trigger = 1; }
}
}

delete $paramlocatorpointOnCurvex $spaceLocatorB; 
delete $curves;
rename $Newcurve $myCurve;  
$Newcurve = {$myCurve};

return $Newcurve; 
}

/*
string $retopoProjectionCurves[] =  `StartofCurveScriptRetopo2($CaptureCurveNameA)`; 
string $AllIntersectCurveSA[] =  StartofCurveScriptRetopo3( $PolygonShapeZA,  $retopoProjectionCurves, $CaptureCurveNameA );
EvalSmoothCurves;
select -r $AllIntersectCurveSA;
FlattenCurveOnMesh( $AllIntersectCurveSA,  $PolygonShapeZA);
*/
///////////////////////////////////////////////// /
// SmoothCurvature3(3);
///////////////////////////////////////////////// /



proc string[] SmoothCurvature3(float $curveM ){

string $curves[] = `ls -sl`;
string $myCurve = $curves[0];
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
smoothCurve -ch 0 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 2 ); 
//Above was Times * 4 

string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`; 
$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
	float $step = $numEPrealNum2;  
	$curve = "curve -d 3";
	float $curveMin = 8;
int $Par = 0;
int $a;
int $ii = 0;	
  for($a = 0; $a <= $step;$a++){
$ii = $ii + 1;
  	$t =  $a/$step;
 	$Par = ($a/$step);
	setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
  	float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
	float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
		if ( $CurvatureRadi <=  $curveMin){   
	$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
	}

if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
}

if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
}
}

///////////////////////////////////////////////// ////
string $Newcurvez = `eval($curve)`;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $Newcurvez;
float $numLength = (`arclen $Newcurvez`) +1; 
int $StepZNum = $numLength;
delete $paramlocatorpointOnCurvex $spaceLocatorB; 
delete $curves;
///////////////////////////////////////////////// //////
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s $StepZNum -d 3 -tol 0.001  $Newcurvez;
string $Newcurve[] = {$Newcurvez};
rename $Newcurve $curves;  
$Newcurve = {$curves[0]};
return $Newcurve; 
}
/////////////////////////
//  SmoothCurvatureB3(6);

///////////////////////
proc string[] SmoothCurvatureB3(float $curveM ){

string $curves[] = `ls -sl`;
string $myCurve = $curves[0];
rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 2 ); 
//Above was Times * 4 

string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`; 
$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
	float $step = $numEPrealNum2;  
	$curve = "curve -d 3";
	float $curveMin = $curveM;
int $Par = 0;
int $a;
int $ii = 0;	
  for($a = 0; $a <= $step;$a++){
$ii = $ii + 1;
  	$t =  $a/$step;
 	$Par = ($a/$step);
	setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
  	float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
	float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
		if ( $CurvatureRadi <=  $curveMin){   
	$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
	}

if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
}


if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
}

}

string $Newcurvez = `eval($curve)`;
string $Newcurve[] = {$Newcurvez};
delete $paramlocatorpointOnCurvex $spaceLocatorB; 
delete $curves;
rename $Newcurve $myCurve;  
$Newcurve = {$myCurve};

return $Newcurve; 
}
//////////////////////////////////




////////////////////////////////////

proc string[] SmoothCurvatureReverse6(float  $curveM ){

string $curves[] = `ls -sl`;
string $myCurve = $curves[0];
rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 2 ); 
//Above was Times * 4 

string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`; 
$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
	float $step = $numEPrealNum2;  
	$curve = "curve -d 3";
	float $curveMin = $curveM;
int $Par = 0;
int $a;
int $ii = 0;	
  for($a = 0; $a <= $step;$a++){
$ii = $ii + 1;
  	$t =  $a/$step;
 	$Par = ($a/$step);
	setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
  	float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
	float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
		if ( $CurvatureRadi >=  $curveMin){
	$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
	}

if (( $CurvatureRadi < $curveMin) && ( $ii == 1  )){
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
}


if (( $CurvatureRadi < $curveMin) && ( $Par ==  1.0 )){
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
}

}

string $Newcurvez = `eval($curve)`;
string $Newcurve[] = {$Newcurvez};
delete $paramlocatorpointOnCurvex $spaceLocatorB; 
delete $curves;
rename $Newcurve $curves;  
$Newcurve = {$curves[0]};

return $Newcurve; 
}





proc float XpercentLess_thenY(float $Ix, float  $Iy){
float $N;
float $Ni;
if ( $Ix > $Iy){
 $Ni = $Ix; $N = $Iy; } else { $N = $Ix;  $Ni =  $Iy; }
float $PercentA;
float $PercentB;
$PercentA = ((float($N) / $Ni) * (100) );
$PercentB = 100 - $PercentA;
return $PercentB;
}
//////////////////////////////////////

////////////////////////////////////




////////////////////////////////////////
proc EvalStrait_ARC_or_FreeForm(){
string $curveItem[] = `ls -sl`;
Strait_ARC_or_FreeForm($curveItem, 5.5, 2.5 );
}

//////////////////////////////////////////

proc int Strait_ARC_or_FreeFormFind(string  $renamed[], float $ArcN, float $StraitN ){

int $SAF = 0;
string $nameString = $renamed[0];
string $ParentArc[];
//rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 - kcp 0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001 $renamed;
string $objectB[] =  Make_Middle_of_Curve_ParamlocatorZ($renamed);
ResetTranslation($objectB);
string $objectC[] = {$renamed[0], $objectB[0]};
ResetTranslationEach($objectC);
float $objectAcurve = GET_AREA_OF_CURVE  ($renamed);
float $objectBcurve = GET_AREA_OF_CURVE  ($objectB);
/////////////////////////

float $PercentDiff = XpercentLess_thenY ($objectBcurve, $objectAcurve);

float $objectAcurveL = arclen ($renamed);
float $objectBcurveL = arclen ($objectB);
float $PercentDiffL = XpercentLess_thenY ($objectBcurveL, $objectAcurveL);
float $PercentAverage = ($PercentDiff +  $PercentDiffL) /2;

vector $VectorCurveEndZ[] = VecCurveEnds ($renamed);
float $posA[] =  $VectorCurveEndZ[0];
float $posB[] =  $VectorCurveEndZ[1];
string $CurveBetween[] = MakeCurveBetweenFloats ($posA, $posB);
ResetTranslation($CurveBetween);
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001  $CurveBetween;
float $objectCcurveL = arclen ($CurveBetween);
float $PercentDiffS = XpercentLess_thenY ($objectCcurveL, $objectAcurveL);
print ("PercentDiff_Curve_to_Arc AREA  "+$PercentDiff + "\n");
print ("PercentDiff_Curve_to_Arc L  "+$PercentDiffL + "\n");
print (" " + "\n");
print ("PercentDiff_Curve_to_Arc Average  "+$PercentAverage + "\n");
print (" " + "\n");
print ("PercentDiff_Curve_to_STRAIT  "+$PercentDiffS + "\n");

string $DeleteCurveA[];
string $DeleteCurveB[];
 
if (($PercentAverage< $ArcN) && ($PercentDiffS >  $StraitN)){
print ("ARC Curve"+ "\n"); $SAF = 0;

}else if ($PercentDiffS < $StraitN){
print ("STRAIT Curve"+ "\n"); $SAF = 1;

} else { 
print ("FREEFORM Curve"+ "\n"); $SAF = 2;
 }

delete $CurveBetween  $objectB;

return $SAF; 

}



proc int AddorSubtract(int $Number, int $AorS){

if ($AorS == 1){ $Number++; return $Number;} 
if ($AorS == 0){ $Number--; return $Number;}
if ($AorS == 2){ $Number = 0; return $Number;}  

}
///////////////////////////////////////////////// /

  proc float RoundFloat(float $val,float $dec){
  	$sign = `sign $val`;
  	float $dec = `pow 10 $dec`;
  	$val = (int) (($val + $sign*5/($dec*10))  * $dec);
  	$val = ($val / $dec);
  	return $val;
  }

//////////////////////////////////////




proc int IsCircle() {

//StraitCurves SCRIPT

int $IsCircle = 0;

string $ObjectCurve[];
string $StraitCurve[];
$ObjectCurve = `ls -selection`;
xform -cp;
resetPivot;
duplicatePreset (1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1);
string $ObjectCurveduplicate[];

$ObjectCurveduplicate = `ls -selection`;
setAttr ($ObjectCurveduplicate[0] + ".translate")  0 0 0;
setAttr ($ObjectCurveduplicate[0] + ".rotate") 0  0 0;
playButtonStepForward; select -cl  ;

float $rotationz[];
$rotationz = `xform -q -rotation $ObjectCurve`;
float $translationz[];
$translationz = `xform -q -translation  $ObjectCurve`;
float $ArcLength = `arclen $ObjectCurve[0]`;

float $bbox[] = `exactWorldBoundingBox  $ObjectCurveduplicate`;
print("Bounding box ranges from: " +
      $bbox[0] + "," + $bbox[1] + "," + $bbox[2]  + ", to " +
      $bbox[3] + "," + $bbox[4] + "," + $bbox[5]  + ".\n");


spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
move -ws $bbox[0] $bbox[1] $bbox[2]  BoxspaceLocatorA;
spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
move -ws $bbox[3] $bbox[4] $bbox[5]  BoxspaceLocatorB;
spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
move -ws $bbox[3] $bbox[1] $bbox[2]  BoxspaceLocatorC;
spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;

// xform -query -worldSpace -translation;


float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox [2]};
float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox [5]};
float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox [2]};
float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox [5]};

$BoxPointA = `MakeCleanFloats($BoxPointA)`;
$BoxPointB = `MakeCleanFloats($BoxPointB)`;
$BoxPointC = `MakeCleanFloats($BoxPointC)`;
$BoxPointD = `MakeCleanFloats($BoxPointD)`;

float $BoxMPointAC[] = MidPointBetween ($BoxPointA, $BoxPointC);
float $BoxMPointBD[] = MidPointBetween ($BoxPointB, $BoxPointD);
float $BoxMPointAD[] = MidPointBetween ($BoxPointA, $BoxPointD);
float $BoxMPointBC[] = MidPointBetween ($BoxPointB, $BoxPointC);
//   MoveObjectSelection($BoxMPointAC);

///////////////////////////////
///////////////////////////////

float $CrossMPointAB[] = MidPointBetween ($BoxPointA, $BoxPointB);

// BoxspaceLocatorMiddle CHANGES need here in the  future

float $translationzMiddle[];
$translationzMiddle = $CrossMPointAB;


float $CurveCVzero[] = GetCurveCVposENDS ($ObjectCurveduplicate, 0);
float $CurveCVLast[] = GetCurveCVposENDS ($ObjectCurveduplicate, 1);
float $distanceBetween = PointsGetDistanceFLOAT ($CurveCVzero, $CurveCVLast);

int $pA1 = PointsEquivalentTol ($CurveCVzero,$BoxPointA); 
int $pA2 = PointsEquivalentTol ($CurveCVLast,$BoxPointA);
int $pC1 = PointsEquivalentTol ($CurveCVzero,$BoxPointC); 
int $pC2 = PointsEquivalentTol ($CurveCVLast,$BoxPointC); 

int $AorC = 0;
if (($pA1 == 3) || ($pA2 == 3)){
$AorC = 1;
}
if (($pC1 == 3) || ($pC2 == 3)){
$AorC = 2;
}  
float $distanceA = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointC);
float $distanceB = PointsGetDistanceFLOAT ($BoxPointB, $BoxPointC);

float $distanceC = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointD);

float $distanceAverage =  (($distanceA +  $distanceB) * (0.5)) ;
float $radiusX = ( $distanceAverage / 2.0);

float $distanceAverageA = $distanceC ;
float $radiusXA = (($distanceC) * (0.5)) ;
// Result: 38.390151 // 

float $Pi = 3.141593;
float $circleArc = (($Pi) * ($distanceC));

float $percentLess = XpercentLess_thenY(  $circleArc, $ArcLength);

float $squarePercentA;
float $squarePercentB;

if ( $distanceA > $distanceAverage) {
$squarePercentA = (( $distanceAverage /  $distanceA ) * (100));
}

if ( $distanceA < $distanceAverage) {
$squarePercentA = (( $distanceA /  $distanceAverage ) * (100));
}

if ( $distanceB > $distanceAverage) {
$squarePercentB = (( $distanceAverage /  $distanceB ) * (100));
}
if ( $distanceB < $distanceAverage) {
$squarePercentB = (( $distanceB /  $distanceAverage ) * (100));
}
/////////////////////


int $squareA = 0;
int $squareB = 0;
if ( $squarePercentA > 55){
$squareA = 1; 
}
if ( $squarePercentB > 55){
$squareB =  1; 
}

string $StraitCurve[];

$addSquareResults = ($squareA + $squareB);
if (( $addSquareResults == 2 ) && ( $percentLess  < 12.0 )) {
$IsCircle = 1;

} else { 
// Not Diagonal curves
$IsCircle = 0;
}

/*
setAttr ($StraitCurve[0] + ".rotateX")  $rotationz[0];
setAttr ($StraitCurve[0] + ".rotateY")  $rotationz[1];
setAttr ($StraitCurve[0] + ".rotateZ")  $rotationz[2];
setAttr ($StraitCurve[0] + ".translateX")  $translationz[0];
setAttr ($StraitCurve[0] + ".translateY")  $translationz[1];
setAttr ($StraitCurve[0] + ".translateZ")  $translationz[2];
*/

select -r $ObjectCurveduplicate BoxspaceLocatorA  BoxspaceLocatorB BoxspaceLocatorC  BoxspaceLocatorD BoxspaceLocatorMiddle;
delete;
print ("IsCircle " + $IsCircle);
print ("percentLess " + $percentLess);
print ("addSquareResults " + $addSquareResults);
return $IsCircle;

}
////////////////////////////////


proc string CurveIntersectZX(string $objectcurv[]){

string $plainName;
	
string $digitalSkeleton[];
$numInts = size($digitalSkeleton);
if ( $numInts > 0 ){
clear $digitalSkeleton;
}

///////////////GATHER ALL BUILDING  STRUCTURE/////////##

///////////////////////////////////////////////// ////##
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($objectcurv[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($objectcurv[0] + ".cv[0]")  ;			
$CurveSelection[1] = ($objectcurv[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposA[];
float $EACHCVposB[];	
string $AllIntersectCurveZ[];
$numInts = size($AllIntersectCurveZ);
if ( $numInts > 0 ){
clear $AllIntersectCurveZ;
}
string $IntersectCurves[];
string $MakeExtrudeSurface[];
string $MakeBirailSurface[];
string $MakeXBetween[];
string $MakeIntersectCurvez[];
string $MakespaceLocator[];

        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $CurveSelection[0]  )`;
$MakespaceLocator = `spaceLocator -p 0 0 0 -n  IntersectZLocaterZ3D`;
$MakeIntersectCurvez[0] = `curve -d 1 -p 0 0 0 -p  12 0 0 -k 0 -k 1 -n IntersectCurve` ;
appendStringArray($AllIntersectCurveZ,  $MakeIntersectCurvez, 1);
appendStringArray($digitalSkeleton,  $MakespaceLocator, 1);
$numInts = size($AllIntersectCurveZ);
extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakespaceLocator[0];
move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakeIntersectCurvez[0];
aimConstraint -offset 0 0 0 -weight 0.5 - aimVector -1 0 0 -upVector 0 0 -1 -worldUpType  "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM      $MakeIntersectCurvez[0];

$EACHCVposA = $eachCVpos;

string $surfX = "Xplane";
float $intersectPoint[] = GetSurfaceIntersectPoint($MakeIntersectCurvez[0], $surfX);

$duplicateCamPlain1 = `duplicate -rr LiveSurfaceB`;
$plainName = $duplicateCamPlain1[0];
xform -cp $duplicateCamPlain1;
ResetTranslation($duplicateCamPlain1);
Move $intersectPoint $duplicateCamPlain1[0];
extendSurface -ch 0 -em 0 -et 0 -d 100 -jn 1 -rpo 1 -es 2 -ed 2   $duplicateCamPlain1;
///

delete $digitalSkeleton;
return $plainName; 
}
////////////////////////////////

////////////////////////////////

proc float[] GetSurfaceIntersectPoint(string $Curvez, string $surf){

string $objectCurve = $Curvez;
string $MakeExtrudeSurface[];
$MakeExtrudeSurface = `extrude -ch true -rn false -po 0 -et 0 -upn 1 -length 3.000 -rotation 0 -scale 1 -dl 3 -n CURVEZextrude $Curvez` ;
string $iSurf = $MakeExtrudeSurface[0];
string $surf = "Xplane";
string $paramlocatorZ[];

string $intersectZ[];
float $intersectposA[];

if (catchQuiet($intersectZ = `intersect -ch 0 - cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ  $iSurf $surf `)){
	print "error";
	} else {
///////////////GATHER ALL BUILDING  STRUCTURE/////////##
///////////////
string $curveIntersectZ[];
$curveIntersectZ[0] = `curveIntersect -ch 0 - tolerance 0.00001 $intersectZ $objectCurve`;
string $buffer[];
$numTokens = `tokenize $curveIntersectZ[0] " "  $buffer`;
$paramlocatorZ[0] = eval("paramLocator " +   $objectCurve + ".u[" + $buffer[1] + "]");
        
	$intersectposA = `pointPosition -w  $paramlocatorZ[0]`;
}
delete $intersectZ $paramlocatorZ;
delete $MakeExtrudeSurface;
$intersectposA = `MakeCleanFloats($intersectposA)`;
return $intersectposA;
}

////////////////////////////////


proc AdvancedCurveMODprojectTAN(string $INarrayA [], int $plainNum ){

float $eachCVposSTART[];
float $eachCVposEND[];
string $MakespaceLocatorSTART[];
string $MakespaceLocatorEND[];
string $digitalSkeletonA[];

string $NewStraitCurve[];

$numInts = size($digitalSkeletonA);
if ( $numInts > 0 ){
clear $digitalSkeletonA;
}


$digitalSkeletonA =  `StartofCurveScriptIntersectZX`;
//Huge re-occuring problem is here

string $AllCurveZ[];
$numInts = size($AllCurveZ);
if ( $numInts > 0 ){
clear $AllCurveZ;
} 
string $AllSpaceLocatorZ[];
$numInts = size($AllSpaceLocatorZ);
if ( $numInts > 0 ){
clear $AllSpaceLocatorZ;
} 
string $renamed[];
string $rebuildit[];
string $ZIntersectionCurveZA[];
string $intersectionCurve[]; 
string $MakeSpaceLocator[];
string $objectLocaterz[];
string $AllparamlocatorZ[];
clear $AllparamlocatorZ;
string $intersectZ[];
string $surf[];
string$ZBetween[];
string $objectCurve[];
float $EACHCVposA[];
float $EACHCVposB[];
float $p1Z; 	
int $moveCurve = 0;
int $SE = 0;
 int $foundCurve = 0;

setAttr "subCurve1.minValue" 0.85;
setAttr "subCurve2.minValue" 0.85;

$surf[0] = ("IntersectLoftZ");

//This reduces number of curves it has to  recursively Search through.... But it could be  faster
string $objectSelection[] =  `editDisplayLayerMembers -q layerCurvesINRange1`;
int $EdgecurvesizeNUM = size($objectSelection);

	string $each;
for ($each in $objectSelection) {
	string $iSurf[] = `extrude -ch 1 -et 0 -l  0.05 -n AxisSelection ( $each )`;
if (catchQuiet($intersectZ = `intersect -ch 0 - cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ  $iSurf[0] $surf[0]`)){
	
	delete `ls -sl`;
	} else {
///////////////GATHER ALL BUILDING  STRUCTURE/////////##
///////////////
$objectCurve[0] = $each;
appendStringArray($AllCurveZ, $objectCurve, 1);
delete $intersectZ;
delete $iSurf;
$foundCurve++;
if ($foundCurve == 2){ $foundCurve = 0; break;} 
}
}

setAttr "subCurve1.minValue" 0.0;
setAttr "subCurve2.minValue" 0.0;

setAttr "subCurve1.maxValue" 0.15;
setAttr "subCurve2.maxValue" 0.15;



int $EdgecurvesizeNUM = size($objectSelection);
	string $each;
for ($each in $objectSelection) {

	string $iSurf[] = `extrude -ch 1 -et 0 -l  0.05 -n AxisSelection ( $each )`;
if (catchQuiet($intersectZ = `intersect -ch 0 - cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ  $iSurf[0] $surf[0]`)){
	
	delete `ls -sl`;
	} else {
///////////////GATHER ALL BUILDING  STRUCTURE/////////##

///////////////
$objectCurve[0] = $each;
appendStringArray($AllCurveZ, $objectCurve, 1);
delete $intersectZ;
delete $iSurf;
$foundCurve++;
if ($foundCurve == 2){ $foundCurve = 0; break;} 
}
}

setAttr "subCurve1.maxValue" 1.0;
setAttr "subCurve2.maxValue" 1.0;


  string $shorterListA[] =  stringArrayRemoveDuplicates($AllCurveZ);
$AllCurveZ = $shorterListA;

///////////////////////////////////////////////// ////
if (size($AllCurveZ) > 2){
print "Intersected 2 Curves";
string $ItemListsZ[];
$ItemListsZ = `CompareCurveIntersect($AllCurveZ) `;
  string $diffCurvesSame[] =  stringArrayRemoveExact($ItemListsZ, $AllCurveZ);
if (size($diffCurvesSame) == 1){
ResetTranslationEach($ItemListsZ);
ArrayInsertAtEnd( $ItemListsZ, $diffCurvesSame [0]);
 string $NearestCurvesSame[] =  NearestObjectArray(1, $ItemListsZ);
string $TwoCurvesBest[];
ArrayInsertAtEnd( $TwoCurvesBest,  $diffCurvesSame[0]);
ArrayInsertAtEnd( $TwoCurvesBest,  $NearestCurvesSame[0]);
$objectSelection = $TwoCurvesBest;
}
}
///////////////////////////////////////////////// ////

setAttr "subCurve1.minValue" 0.85;
setAttr "subCurve2.minValue" 0.85;

$EdgecurvesizeNUM = size($objectSelection);
	string $each;
for ($each in $objectSelection) {

	string $iSurf[] = `extrude -ch 1 -et 0 -l  0.05 -n AxisSelection ( $each )`;
if (catchQuiet($intersectZ = `intersect -ch 0 - cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ  $iSurf[0] $surf[0]`)){
	
	delete `ls -sl`;
	} else {
///////////////GATHER ALL BUILDING  STRUCTURE/////////##
appendStringArray($digitalSkeletonA, $iSurf, 1);
appendStringArray($digitalSkeletonA, $intersectZ,  1); 
///////////////
$objectCurve[0] = $each;
string $objectCurveZ[] = `ls -sl -tl 1`;
appendStringArray($AllCurveZ, $objectCurve, 1);
string $curveIntersectZ[];
$curveIntersectZ[0] = `curveIntersect -ch 0 - tolerance 0.00001 $intersectZ $objectCurve[0]`;
string $buffer[];
$numTokens = `tokenize $curveIntersectZ[0] " "  $buffer`;
$paramlocatorZ[0] = eval("paramLocator " +   $objectCurve[0] + ".u[" + $buffer[1] + "]");
appendStringArray($AllparamlocatorZ,  $paramlocatorZ, 1);
appendStringArray($digitalSkeletonA,  $paramlocatorZ, 1);
        float $intersectposA[];	
	$intersectposA = `pointPosition -w  $paramlocatorZ[0]`;
string $objectLocaterzA[];
$objectLocaterzA = `spaceLocator -p 0 0 0 -n  IntersectZLocaterZ3D`;
move  -ws $intersectposA[0] $intersectposA[1]  $intersectposA[2] $objectLocaterzA[0];
///////////
appendStringArray($AllSpaceLocatorZ,  $objectLocaterzA, 1);
///////////
$foundCurve++;
if ($foundCurve == 2){ $foundCurve = 0; break;} 
}
}

setAttr "subCurve1.minValue" 0.0;
setAttr "subCurve2.minValue" 0.0;

setAttr "subCurve1.maxValue" 0.15;
setAttr "subCurve2.maxValue" 0.15;



$EdgecurvesizeNUM = size($objectSelection);
	string $each;
for ($each in $objectSelection) {

	string $iSurf[] = `extrude -ch 1 -et 0 -l  0.05 -n AxisSelection ( $each )`;
if (catch($intersectZ = `intersect -ch 0 -cos 0  -fs 1 -tol 0.001 -name IntersectSURFACZ $iSurf[0]  $surf[0]`)){
	
	delete `ls -sl`;
	} else {
///////////////GATHER ALL BUILDING  STRUCTURE/////////##
appendStringArray($digitalSkeletonA, $iSurf, 1);
appendStringArray($digitalSkeletonA, $intersectZ,  1); 
///////////////
$objectCurve[0] = $each;
string $objectCurveZ[] = `ls -sl -tl 1`;
appendStringArray($AllCurveZ, $objectCurve, 1);
string $curveIntersectZ[];
$curveIntersectZ[0] = `curveIntersect -ch 0 - tolerance 0.00001 $intersectZ $objectCurve[0]`;
string $buffer[];
$numTokens = `tokenize $curveIntersectZ[0] " "  $buffer`;
$paramlocatorZ[0] = eval("paramLocator " +   $objectCurve[0] + ".u[" + $buffer[1] + "]");
appendStringArray($AllparamlocatorZ,  $paramlocatorZ, 1);
appendStringArray($digitalSkeletonA,  $paramlocatorZ, 1);
        float $intersectposA[];	
	$intersectposA = `pointPosition -w  $paramlocatorZ[0]`;
string $objectLocaterzA[];
$objectLocaterzA = `spaceLocator -p 0 0 0 -n  IntersectZLocaterZ3D`;
move  -ws $intersectposA[0] $intersectposA[1]  $intersectposA[2] $objectLocaterzA[0];
///////////
appendStringArray($AllSpaceLocatorZ,  $objectLocaterzA, 1);
///////////
$foundCurve++;
if ($foundCurve == 2){ $foundCurve = 0; break;} 
}
}


setAttr "subCurve1.maxValue" 1.0;
setAttr "subCurve2.maxValue" 1.0;

///////////////////////////////////////////////// /////////////////////////////////

///////////////////////////////////////////////// /////////////////////////////////

appendStringArray($digitalSkeletonA,  $AllSpaceLocatorZ, size($AllSpaceLocatorZ));
  string $shorterList[] =  stringArrayRemoveDuplicates($AllCurveZ);
$AllCurveZ = $shorterList;

 int $CurvesCUTinto = size($AllCurveZ);
if ($CurvesCUTinto == 1){string $oneLocatorZ[] =  {$AllparamlocatorZ[0]}; $AllparamlocatorZ =  $oneLocatorZ; }

int $numparam = size($AllparamlocatorZ);
if (($CurvesCUTinto == 2) && ($numparam == 4)){
string $oneLocatorZa[] = {$AllparamlocatorZ[0]}; 
string $oneLocatorZb[] = {$AllparamlocatorZ[1]}; 
$AllparamlocatorZ = {$oneLocatorZa[0],  $oneLocatorZb[0]}; 
}
$numparam = size($AllparamlocatorZ);

int $numInts = size($AllSpaceLocatorZ);
if (($CurvesCUTinto == 2) && ($numInts == 4)){
string $oneLocatorZ2a[] = {$AllSpaceLocatorZ[0]}; 
string $oneLocatorZ2b[] = {$AllSpaceLocatorZ[1]}; 
$AllSpaceLocatorZ = {$oneLocatorZ2a[0],  $oneLocatorZ2b[0]}; 
}
$numInts = size($AllSpaceLocatorZ);



if ( $numparam > 0 ){
//$paramlocatorZ[0] = `rename ParamLocatorShape`;
  string $shorterList[] =  stringArrayRemoveDuplicates($AllparamlocatorZ);
$AllparamlocatorZ = $shorterList;
}
$numparam = size($AllparamlocatorZ);
$numInts = size($AllSpaceLocatorZ);
if ( $numparam == 1 ){
float $EACHCVposA[];
$EACHCVposA = `positionOne($AllparamlocatorZ[0]) `;
float $EACHCVposA[] = `positionOne ($AllparamlocatorZ[0])`;
}
if ( $numparam == 1 ){
float $EACHCVposA[];
$EACHCVposA = `positionOne($AllparamlocatorZ[0]) `;
float $EACHCVposA[] = `positionOne ($AllparamlocatorZ[0])`;
}

select -cl  ;
string $MakespaceLocatorZSE[];
string $SEspaceLocSetofSetz = `sets -name  SEspaceLocSetofSets`;	
string $paramANDCurve3[] = `paramToCurvePts3(  $AllparamlocatorZ )`;
string $paramANDCurve2[] = `paramToCurvePts2(  $AllparamlocatorZ )`;
string $paramANDCurve[] = `paramToCurvePts(  $AllparamlocatorZ )`;
string $paramCurveNAMES[] = `tokenizeparam(  $paramANDCurve )`;
$MakespaceLocatorZSE = EvalMoveCurvesTOend ($paramANDCurve, $paramCurveNAMES,  $paramANDCurve3, $AllparamlocatorZ,  $SEspaceLocSetofSetz);

if (size($MakespaceLocatorZSE) > 0){
appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
}
int $setsNumber = `sets -q -size  $SEspaceLocSetofSetz`;
if ($setsNumber > 0){
string $subsets[];
$subsets = `sets -q $SEspaceLocSetofSetz`;
//appendStringArray($digitalSkeletonA, $subsets,  size($subsets));
}
  
print $digitalSkeletonA;
string $objectcurv[0] = {$digitalSkeletonA[0]};

if ( $numparam == 0 ){

/////////////////////////////////////////////////////########################


string $plainXa = CurveIntersectZX($objectcurv);

string $intersectionCurvePlainX[];
	$intersectionCurvePlainX = `intersect  -ch 0 - fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves" $plainXa`;
string $theintersectA[];
$theintersectA = $intersectionCurvePlainX;
string $theintersectCURVEsA[];
$theintersectCURVEsA = `listRelatives -children  $theintersectA`;
parent -w $theintersectCURVEsA;
delete $theintersectA;
//select -r $theintersectCURVEsA;
delete $plainXa;

string $newnameA = "Curve";
string $renamedA2 = `rename $theintersectCURVEsA $newnameA`; 
$intersectionCurvePlainX = {$renamedA2};

int $trueORfalseA = 0;
int $trueORfalseA2 = 0;
$trueORfalseA = FindIfCurveCrossesZ($intersectionCurvePlainX);
string $newname[]; 
if ($trueORfalseA == 1){
CutCurveIFConditionTRUETransitZ($intersectionCurvePlainX);
$trueORfalse2A = 1;
ResetTranslation($intersectionCurvePlainX);
}  

/////////////////////////////////
if ($trueORfalseA == 0){
ResetTranslation($intersectionCurvePlainX);
}
string $ParentArc[];
$ParentArc = Strait_ARC_or_FreeForm($intersectionCurvePlainX,  1.9, 1.5 );
select -r $ParentArc;
MirrorANDrename($ParentArc);

if ($trueORfalseA2 == 1){
sets -include ZEdgeCurvesSet $ParentArc;
 }


///////////////////////////////////////////////// ///////
///////////////////////////////////////////////// ///////

ArrayInsertAtEnd( $INarrayA, $ParentArc[0]);


ResetTranslation($ParentArc);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ParentArc;
select -r $ParentArc[0];
EvalAddingCurves;
EvalcreatSphere;

/////////////////////////////////////////////////////////////////////////////////////////////////////

} else if ( $numparam == 1 ){

print ("numparam IS 1" + "\n");
print ("numparam IS 1" + "\n");

//ONE LOCATOR // print $AllSpaceLocatorZ;
//ONE LOCATOR  /////////////////////////////////////////////


//appendStringArray($digitalSkeletonA,  $AllSpaceLocatorZ, 1);
string $objectSelection[0] = $AllSpaceLocatorZ;
string $cameraANDlocator[];
$cameraANDlocator[0] = "LiveSurfaceB"; 
float $point1[];
float $point2[];
	$point1 = `xform -query -worldSpace - translation ( $objectSelection[0])`;
	$point2 = `xform -query -worldSpace - translation ( $cameraANDlocator[0])`;
$dx = $point1[0] - $point2[0];
$dy = $point1[1] - $point2[1];
$dz = $point1[2] - $point2[2];
float $distance;
 $distance = `sqrt( ($dx * $dx) + ($dy * $dy) +  ($dz * $dz) )`;
$scalePlane = $distance;
nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr  1 -n "cutingplaneAlign";
scale -r $scalePlane $scalePlane $scalePlane;
performRebuildSurfaceSet 1 1 0 0.001 4 4 3 3 1 2  1 0 2 1 0.05 0 0;
if ($plainNum == 0){
setAttr "cutingplaneAlign.rotateX" (`getAttr  ("ZCURVEModelingCAM" + ".rotateX")`+90);
setAttr "cutingplaneAlign.rotateY" `getAttr  ("ZCURVEModelingCAM" + ".rotateY")`;
setAttr "cutingplaneAlign.rotateZ" `getAttr  ("ZCURVEModelingCAM" + ".rotateZ")`;
}

//  float $angleofStraitCurve[] =  `EulerAngleofCurve`;

if ($plainNum == 1){ setAttr  cutingplaneAlign.rotateZ 90; setAttr  cutingplaneAlign.rotateX 45; }
if ($plainNum == 2){ setAttr  cutingplaneAlign.rotateZ 90; setAttr  cutingplaneAlign.rotateX -45; }
if ($plainNum == 3){ setAttr  cutingplaneAlign.rotateZ 90; }
if ($plainNum == 4){ setAttr  cutingplaneAlign.rotateX 90; } 
if ($plainNum == 5){ setAttr  cutingplaneAlign.rotate 0.0 0.0 0.0; } 
print $objectSelection; 
        float $Locaterpos[];	
	$Locaterpos = `pointPosition -w (  $objectSelection[0] )`;
	move  -ws $Locaterpos[0] $Locaterpos[1]  $Locaterpos[2] cutingplaneAlign ;
string $intersectionCurveMake1[];
$intersectionCurveMake1 = `intersect  -ch false  -fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves"  "cutingplaneAlign" `;
  
string $theintersect[];
$theintersect = $intersectionCurveMake1;
string $theintersectCURVEs[];
$theintersectCURVEs = `listRelatives -children  $theintersect`;
parent -w $theintersectCURVEs;
delete $theintersect;
select -r $theintersectCURVEs $AllCurveZ;

	 string $bufferCutCurve[];
	string $ZIntersectionCurveZ[];
	string $afterCut[];
	string $numTokensZ;
	int $n, $i;

cutCurvePreset(1,1,0.001,6,-0.7767,0.1104,- 0.6201,1,2);
	$afterCut = `ls -sl`;
		$n = size($afterCut);
		for( $i=0; $i<$n; $i+=1 ) {
			// Now, two of these are  bad, two are OK:
			if( `getAttr ($afterCut [$i] + ".spans")` < 1){ delete $afterCut[$i];
			} else {			
$numTokensZ = `tokenize $afterCut[$i] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; }
		}
string $ZIntersectionCurveZA[];
$ZIntersectionCurveZA = `listRelatives -shapes  $ZIntersectionCurveZ`;
string $renamed[]; 
$renamed[0] = `rename $ZIntersectionCurveZ Curve`;
ResetTranslation($renamed);
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($renamed[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($renamed[0] + ".cv[0]") ;		 	
$CurveSelection[1] = ($renamed[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}

if (size($MakespaceLocatorZSE) > 0){
int $ZEROorONE;
 int $foundA = stringArrayGmatch ("SEspaceLocatorSTART3DZ*",  $MakespaceLocatorZSE);
 int $foundB = stringArrayGmatch ("SEspaceLocatorEND3DZ*", $MakespaceLocatorZSE);
if (( $foundA == 1 ) || ( $foundB == 1 )) {
float $eachCVposSTART[] = `pointPosition -w  ($MakespaceLocatorZSE[0])`;
float $movePIVOT[];
$ZEROorONE = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVposSTART);
if ( $ZEROorONE == 0){ $movePIVOT = $EACHCVposAZ;  move $movePIVOT[0] $movePIVOT[1] $movePIVOT[2]  ($renamed[0] + ".scalePivot") ($renamed[0] +                        ".rotatePivot") ;}
if ( $ZEROorONE == 1){ $movePIVOT = $EACHCVposBZ;  move $movePIVOT[0] $movePIVOT[1] $movePIVOT[2]  ($renamed[0] + ".scalePivot") ($renamed[0] +                        ".rotatePivot") ; }
move -rpr $eachCVposSTART[0] $eachCVposSTART[1]  $eachCVposSTART[2] $renamed[0];
xform -cp $renamed[0];
}
}

if (size($MakespaceLocatorZSE) == 0){
string $paramANDCurveA2[];
$paramANDCurveA2 = `paramToCurvePts2(  $AllparamlocatorZ )`;
string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[0]`;

delete $AllCurveZ;
string $AllCurveZ2[];
string $newCurves1[];
for ($each in $detachCurve1){
string $newCurve;
$newCurve = `rename $each Curve`;
ArrayInsertAtEnd( $newCurves1, $newCurve);
}
string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;

$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);
  string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;
$AllCurveZ = $newCurves1;
}

delete $digitalSkeletonA cutingplaneAlign;
ResetTranslation($renamed);
string $renamed2[];
$renamed2 = $renamed;
///////////////////////////////////////////////// ///////
///////////////////////////////////////////////// ///////

// IF Drawn Curve is connected to the end of  another curve thast is in EdgeSet
// the curve drawn can be on a edge curve which  is eather protruding from the ZY plain 
// or it lies on the ZY plain. if it is at one of  the two ends of a protruding EdgeCurve
// then the drawn curve intersecting at  EdgeCurves Ends is eather also protruding from ZY  plain or 
// is positioned freely at the other end.. which  means it could be crossing the ZY plain which  means     
 // It would need to be cut

int $ifNearEnds = size($MakespaceLocatorZSE);
int $AllCurveCVsZeroAndLast = FindIfCurveISonZ ($AllCurveZ);
int $edgeZsetA = `sets -im ZEdgeCurvesSet  $AllCurveZ[0]`;
int $ZeroX = 0;

if (( $ifNearEnds == 1) && (  $AllCurveCVsZeroAndLast == 1) && ( $edgeZsetA ==  1)) {

vector $AllCurveCVENDs[] = `VecCurveEnds ($AllCurveZ)`;
vector $renamed2CVENDs[] = `VecCurveEnds ($renamed2)`;

float $renamed2CVENDAs[] = $renamed2CVENDs[0];
float $renamed2CVENDBs[] = $renamed2CVENDs[1];
float $AllCurveCVENDAs[] = $AllCurveCVENDs[0];
float $AllCurveCVENDBs[] = $AllCurveCVENDs[1];

float $FloatZ1[] = $renamed2CVENDAs;
float $FloatZ2[] = $renamed2CVENDBs;
float $FloatZ3[] = $AllCurveCVENDAs;
float $FloatZ4[] = $AllCurveCVENDBs;

$renamed2CVENDAs = `MakeCleanFloats($FloatZ1)`;
$renamed2CVENDBs = `MakeCleanFloats($FloatZ2)`;
$AllCurveCVENDAs = `MakeCleanFloats($FloatZ3)`;
$AllCurveCVENDBs = `MakeCleanFloats($FloatZ4)`;

int $CombA = PointsEquivalentTol ($renamed2CVENDAs, $AllCurveCVENDAs);
int $CombB = PointsEquivalentTol ($renamed2CVENDBs, $AllCurveCVENDBs);
int $CombC = PointsEquivalentTol ($renamed2CVENDAs, $AllCurveCVENDBs);

float $intersectFloat[];
if ($CombA == 3 ){ $intersectFloat =  $AllCurveCVENDAs;}
if ($CombB == 3 ){ $intersectFloat =  $AllCurveCVENDBs;}
if ($CombC == 3 ){ $intersectFloat =  $AllCurveCVENDBs;}
print $intersectFloat;
float $Zero0x = 0.0;
$ZeroX = equivalentTol($Zero0x, $intersectFloat [0], 0.001);

}

$intZplainF = 1;
if ($ZeroX == 1){
$intZplainF = `ZplainFlatten`;
if($intZplainF == 0){
FlattenCurveToZplain($renamed);
}
}

if ($AllCurveCVsZeroAndLast == 2){
$intZplainF = `ZplainFlatten`;
if($intZplainF == 0){
FlattenCurveToZplain($renamed);
}
}

int $trueORfalse = 0;
int $trueORfalse2 = 0;

if ($ZeroX == 0){
$trueORfalse = FindIfCurveCrossesZ($renamed2);
print ("IF_Curve_Crosses_Z True-OR-False"+"  "+$trueORfalse);
string $newname[]; 
if (($trueORfalse == 1) && ($ZeroX == 0)){
$newname = CutCurveIFConditionTRUETransitZ ($renamed2);
$trueORfalse2 = 1;
ResetTranslation($newname);
rename $newname $renamed; 
}
}  

/////////////////////////////////
string $newnamed[0] = {$renamed2[0]};
ResetTranslation($renamed);
string $ParentArc[];
$ParentArc = Strait_ARC_or_FreeForm($newnamed,  1.5, 2.5 );
if($intZplainF > 0)  {
select -r $ParentArc;
MirrorANDrename($ParentArc);
}
if (($ZeroX == 1) || ($trueORfalse2 == 1)){
sets -include ZEdgeCurvesSet $ParentArc;
 }


///////////////////////////////////////////////// ///////
///////////////////////////////////////////////// ///////

ArrayInsertAtEnd( $INarrayA, $ParentArc[0]);

ResetTranslation($ParentArc);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ParentArc;
select -r $ParentArc[0];
EvalAddingCurves;
EvalcreatSphere;

///////////////////////END OF ONE  CURVE
//////////////////////////////////////

} else if ( $numparam > 2 ){


if (size($MakespaceLocatorZSE) > 0){
appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
}
delete $digitalSkeletonA;
//////////////////////////////////////
//////////////////////////////////////

} else if ( $numparam == 2 ){


//////////////////////
//START OF 2 Curves

int $boundSurfTrigger = 0;
string $BoundaryA[];
string $NewboundryA[];
string $objectCurveIntersectAZ[] =  CompareCurveIntersect($AllCurveZ );
string $objectLayerCurvesRangeA[] =  `queryLayerRangeMembers`;
int $numberofAllcurves = size ($objectLayerCurvesRangeA);
if ($numberofAllcurves > 3){

string $diffNearestCurvesWithIntersectsA[] =  stringArrayRemoveExact($AllCurveZ,  $objectLayerCurvesRangeA);
string $diffNearestCurvesWithIntersectsB[] =  stringArrayRemoveExact($AllCurveZ,  $objectLayerCurvesRangeA);
string $AllCurveZA[0] = {$AllCurveZ[0]};
string $AllCurveZB[0] = {$AllCurveZ[1]};
SecondArrayInsertAtEndofArray(  $diffNearestCurvesWithIntersectsA, $AllCurveZA);
SecondArrayInsertAtEndofArray(  $diffNearestCurvesWithIntersectsB, $AllCurveZB);
string $allNearcurves[];
if ($numberofAllcurves < 6){ 
  string $diffCurvesAll[] =  stringArrayRemoveExact($AllCurveZ,  $objectLayerCurvesRangeA);
 $allNearcurves = $diffCurvesAll; }else{
int $ni = 6;

	string $NearestCurvesZAi[] =  (NearestObjectArray($ni,  $diffNearestCurvesWithIntersectsA));
string $NearestCurvesZBi[] = (NearestObjectArray ($ni, $diffNearestCurvesWithIntersectsB));
$allNearcurves = $NearestCurvesZAi;
appendStringArray($allNearcurves,  $NearestCurvesZBi, size($NearestCurvesZBi));
  string $shorterListA[] =  stringArrayRemoveDuplicates($allNearcurves);
$allNearcurves = $shorterListA;
}

string $allNearcurvesIntersects[] =  CompareCurveIntersectTwoCurves($AllCurveZ,  $allNearcurves);

if (size($allNearcurvesIntersects) == 2 ){
$BoundaryA = `boundary -ch 1 -or 0 -ep 1 -rn 1 - po 0 -ept 0.1 $AllCurveZ[0]  $allNearcurvesIntersects[0] $AllCurveZ[1]  $allNearcurvesIntersects[1]  `;
$NewboundryA = {$BoundaryA[0]};
appendStringArray($digitalSkeletonA,  $NewboundryA, 1);
$boundSurfTrigger = 1;
}
}

int $paramloc = size($AllparamlocatorZ);
int $paramlocIndexA;
int $paramlocIndexB;
if ($paramloc > 2){
int $paramlocRealIndex = $paramloc -1;
$paramlocIndexA = $paramlocRealIndex -1;
$paramlocIndexB = $paramlocRealIndex;
} else {$paramlocIndexA = 0;
$paramlocIndexB = 1;}

float $EACHCVposA[] = `positionOne ($AllparamlocatorZ[$paramlocIndexA])`;
float $EACHCVposB[] = `positionOne ($AllparamlocatorZ[$paramlocIndexB])`;
$ZBetween[0] = `curve -d 1 -p $EACHCVposA[0]  $EACHCVposA[1] $EACHCVposA[2] -p $EACHCVposB[0]  $EACHCVposB[1] $EACHCVposB[2] -k 0 -k 2 -n             ZCurveBetween`;
string $duplicateCurvez1[];
string $duplicateCurvez2[];

$duplicateCurvez1 = `duplicateCurve -ch 0 -rn 0  -local 0  "LiveSurfaceBShape.u[0]" `;
xform -cp $duplicateCurvez1;
$duplicateCurvez2 = `duplicateCurve -ch 0 -rn 0  -local 0  "LiveSurfaceBShape.u[1]" `;
xform -cp $duplicateCurvez2;
ResetTranslation($duplicateCurvez1);
ResetTranslation($duplicateCurvez2);
move  -ws $EACHCVposA[0] $EACHCVposA[1]  $EACHCVposA[2] $duplicateCurvez1;
move  -ws $EACHCVposB[0] $EACHCVposB[1]  $EACHCVposB[2] $duplicateCurvez2;
string $LoftduplicateCurvez[];
$LoftduplicateCurvez = `loft -ch 0 -u 1 -c 0 -ar  1 -d 3 -ss 4 -rn 0 -po 0 -rsn true  $duplicateCurvez1 $duplicateCurvez2`;
extendSurface -ch 0 -em 0 -et 2 -d 100 -jn 1 -rpo  1 -es 2 -ed 0  $LoftduplicateCurvez;
extendSurface -ch 0 -em 0 -et 0 -d 10 -jn 1 -rpo  1 -es 2 -ed 1  $LoftduplicateCurvez;

//RESET ITS 000 TRANS
ResetTranslation($ZBetween);
$ZBetweenDUP = `duplicate -rr $ZBetween[0]`;
$ZBetweenDUP2 = `duplicate -rr $ZBetween[0]`;
///////////////GATHER ALL BUILDING  STRUCTURE/////////##
appendStringArray($digitalSkeletonA, $ZBetween,  1);
appendStringArray($digitalSkeletonA,  $LoftduplicateCurvez, 1);
appendStringArray($digitalSkeletonA,  $duplicateCurvez1, 1);
appendStringArray($digitalSkeletonA,  $duplicateCurvez2, 1);
appendStringArray($digitalSkeletonA,  $ZBetweenDUP, 1);
appendStringArray($digitalSkeletonA,  $ZBetweenDUP2, 1);
appendStringArray($digitalSkeletonA,  $AllSpaceLocatorZ, 2);
///////////////GATHER ALL BUILDING  STRUCTURE/////////##
string $TANGENT[];
string $TANGENTloftA[];
string $TANGENTloft[];
$TANGENTA = `loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss  4 -rn 0 -po 0 -rsn true -n TANGENTSURFACE  $AllCurveZ[0] $AllCurveZ[1]`;
extendSurface -ch 0 -em 0 -et 0 -d 100 -jn 1 -rpo  1 -es 2 -ed 0 -n $TANGENTA $TANGENTA;
$TANGENT[0] = `curve -d 3 -p 0 0 0 -p 0 0 -1.5 -p  0 0 -3 -p 0 0 -4.5 -k 0 -k 0 -k 0 -k 4.5 -k 4.5  -k 4.5 -n TANGENTCURVE` ;
string $surfaceUsed[];
if ($boundSurfTrigger == 1){ normalConstraint - weight 1 -aimVector 0 0 1 -upVector 0 0 1 - worldUpType "vector" -worldUpVector 1 0 0  $NewboundryA   TANGENTCURVE ;
$surfaceUsed = $NewboundryA;
}else{
normalConstraint -weight 1 -aimVector 0 0 1 - upVector 0 0 1 -worldUpType "vector" - worldUpVector 1 0 0 TANGENTSURFACE TANGENTCURVE ;
$surfaceUsed = {"TANGENTSURFACE"};
}
//////////////////////////
//////////////////////////////


//AVERAGEbetween two Locators

shadingNode -asUtility plusMinusAverage;
rename plusMinusAverageA;
setAttr plusMinusAverageA.operation 3;                                               
connectAttr -force plusMinusAverageA.output3D (  "|" + "TANGENTCURVE" + ".translate");
connectAttr -f ( $AllSpaceLocatorZ[0] +  ".translate") plusMinusAverageA.input3D[1];
connectAttr -f ( $AllSpaceLocatorZ[1] +  ".translate") plusMinusAverageA.input3D[0];
string $CurveSelection2[]; 
int $numCVs = `getAttr -size ("TANGENTCURVE" +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );			
$CurveSelection2[1] = ("TANGENTCURVE" + ".cv[" +  $numCVrealNum + "]") ;
        float $TANGENTCURVEposA[];	
	$TANGENTCURVEposA = `pointPosition -w (  $CurveSelection2[1]  )`;
move  -ws $TANGENTCURVEposA[0] $TANGENTCURVEposA [1] $TANGENTCURVEposA[2] ZCurveBetween1;
$TANGENTloft = `loft -ch 1 -u 1 -c 0 -ar 1 -d 3  -ss 4 -rn 0 -po 0 -rsn true -n  PROJECTonTANGENTSURFACE ZCurveBetween  ZCurveBetween1`;
extendSurface -ch 0 -em 0 -et 0 -d 100 -jn 1 -rpo  1 -es 2 -ed 1  "PROJECTonTANGENTSURFACE";
delete -ch PROJECTonTANGENTSURFACE;
float $TANCURVEAposA[];
	$TANCURVEAposA = `xform -query - worldSpace -translation TANGENTCURVE`;
string $TANGENTZ[];
$TANGENTZ[0] = `curve -d 3 -p 0 0 0 -p -1.5 0 0  -p -3 0 0 -p -4.5 0 0 -k 0 -k 0 -k 0 -k 4.5 -k  4.5 -k 4.5 -n TANGENTCURVEZ` ;
move  -ws $TANCURVEAposA[0] $TANCURVEAposA[1]  $TANCURVEAposA[2] TANGENTCURVEZ;
aimConstraint -offset 0 0 0 -weight 0.5 - aimVector -1 0 0 -upVector 0 0 -1 -worldUpType  "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM  $TANGENTZ;
///////////////GATHER ALL BUILDING  STRUCTURE/////////##
appendStringArray($digitalSkeletonA, $TANGENTZ,  1);
appendStringArray($digitalSkeletonA, $TANGENTA,  1);
appendStringArray($digitalSkeletonA, $TANGENT,  1);
appendStringArray($digitalSkeletonA,  $TANGENTloft, 1);
///////////////////////////////////////////////// ////##
string $CurveSelectionZ[]; 
int $numCVsA = `getAttr -size ($TANGENTZ[0] +  ".controlPoints")`;
int $numCVrealNumA = ( $numCVsA -1 );		
$CurveSelectionZ[0] = ($TANGENTZ[0] + ".cv[" +  $numCVrealNumA + "]") ;
string $CurveSelectionX[]; 
int $numCVsB = `getAttr -size ($TANGENT[0] +  ".controlPoints")`;
int $numCVrealNumB = ( $numCVsB -1 );			
$CurveSelectionX[0] = ($TANGENT[0] + ".cv[" +  $numCVrealNumB + "]") ;
string $CurveSelectionY[]; 
$CurveSelectionY[0] = ($TANGENTZ[0] + ".cv[" + 0  + "]") ;

// This Corrects the problem of constraining a  curve to the normal of a Surf while wanting
// the curve to point from the surface towards  the camera but with out knowing the surface  normal direction
// so this flips the surface to use the surface  setting that matches the shortest distance from  curve end to CAM
// hence fixing if the curve is pointing the  wrong way;
string $ZCAM[] = {"ZCURVEModelingCAM"};
float $CAMfromTANX2 =  GetDistancePointPositionFLOAT($ZCAM[0],  $CurveSelectionX[0]);
reverseSurface -d 1 -ch 1 -rpo 1 $surfaceUsed;
float $CAMfromTANX3 =  GetDistancePointPositionFLOAT($ZCAM[0],  $CurveSelectionX[0]);
if($CAMfromTANX2 < $CAMfromTANX3){ reverseSurface  -d 1 -ch 1 -rpo 1 $surfaceUsed; }
float $TANZfromTANX2;
$TANZfromTANX2 = GetDistancePointPositionFLOAT ($CurveSelectionZ[0], $CurveSelectionX[0]);
        float $p1[];		
	$p1 = `pointPosition -w (  $CurveSelectionZ[0]  )`;
        float $p2[];		
	$p2 = `pointPosition -w (  $CurveSelectionX[0]  )`;
      	float $p3[];		
	$p3 = `pointPosition -w (  $CurveSelectionY[0]  )`;
	float $mid1[3];
	$mid1 = midPoint2Pts( $p1, $p2 );
		string $TANGENTY[];
		string $TANGENTloftY[];
			$TANGENTY[0] = `curve -d 1 -p $p3[0] $p3[1] $p3 [2] -p $mid1[0] $mid1[1] $mid1[2] -k 0 -k 2 -n  TANGENTCURVEY`;
			appendStringArray($digitalSkeletonA, $TANGENTY,  1);

			move  -ws $mid1[0] $mid1[1] $mid1[2]  $ZBetweenDUP2;
  
$TANGENTloftY = `loft -ch 0 -u 1 -c 0 -ar 1 -d 3  -ss 4 -rn 0 -po 0 -rsn true -n  PROJECTonTANGENTSURFACEY $ZBetweenDUP2  $ZBetween`;
  
	extendSurface -ch 0 -em 0 -et 2 -d 100 -jn 1 -rpo  1 -es 2 -ed 2  "PROJECTonTANGENTSURFACEY";
	extendSurface -ch 0 -em 0 -et 2 -d 100 -jn 1 -rpo  1 -es 2 -ed 2  "PROJECTonTANGENTSURFACEY";
  
appendStringArray($digitalSkeletonA,  $TANGENTloftY, 1);
string $queryIntersectFormLayer[];
$queryIntersectFormLayer =  `editDisplayLayerMembers -q IntersectFormLayer`;
	if (size( $queryIntersectFormLayer) > 0){
		$TANGENTloft[0] = $queryIntersectFormLayer[0]; 
		$TANGENTA[0] = $queryIntersectFormLayer[0]; 
		$TANGENTloftY[0] = $queryIntersectFormLayer[0]; 
		$LoftduplicateCurvez[0] =  $queryIntersectFormLayer[0]; 
}
string $rebuildit[];
string $intersectionCurveMake[];
string $intersectionCurve[];
print $boundSurfTrigger;
	if ($boundSurfTrigger == 1){ 
	$intersectionCurveMake = `intersect  -ch false - fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves"  $NewboundryA `;
		}else{
		$intersectionCurveMake = `intersect  -ch false - fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves"  $TANGENTloft[0] `;
}

$intersectionCurve = `listRelatives  $intersectionCurveMake`; 
		if ((size($intersectionCurve) > 1) || (  $TANZfromTANX2 < 2.25 )) {
	delete $intersectionCurve; 
	delete $intersectionCurveMake;
	string $intersectionCurveMake2[];
	string $intersectionCurve2[];
 	$intersectionCurveMake2 = `intersect  -ch  false -fs 0 -cos 0 -tol 0.001  "SurfaceinterectCurves" $TANGENTA[0] `;
	$intersectionCurve2 = `listRelatives  $intersectionCurveMake2`;
print $TANGENTA; print "intersectionCurve2"; 
		if (size($intersectionCurve2) >  1){
			delete  $intersectionCurve2; 
			delete  $intersectionCurveMake2;
			string  $intersectionCurveMake3[];
			string  $intersectionCurve3[];
 			$intersectionCurveMake3 =  `intersect  -ch false -fs 0 -cos 0 -tol 0.001  "SurfaceinterectCurves" $TANGENTloftY[0] `;
			$intersectionCurve3 =  `listRelatives $intersectionCurveMake3`;

				if (size ($intersectionCurve3) > 1) {

					delete  $intersectionCurve3; 
					delete  $intersectionCurveMake3;
					string  $intersectionCurveMake4[];
					string  $intersectionCurve4[];
					 $intersectionCurveMake4 = `intersect  -ch false  -fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves"      $LoftduplicateCurvez[0] `;
					 $intersectionCurve4 = `listRelatives  $intersectionCurveMake4`;
					parent -w  $intersectionCurve4;
					string  $renamed[]; 
					$renamed [0] = `rename $intersectionCurve4 Curve`; 
					 $rebuildit = $renamed;
					 ResetTranslation($rebuildit);
///////////////////////////////////////////////
select -r $intersectionCurve3 $AllCurveZ[0];

	 string $bufferCutCurve[];
	string $ZIntersectionCurveZ[];
	string $afterCut[];
	string $numTokensZ;
	int $n, $i;
cutCurvePreset(1,1,0.01,6,-0.7767,0.1104,- 0.6201,1,2);
	$afterCut = `ls -sl`;
		$n = size($afterCut);
		for( $i=0; $i<$n; $i+=1 ) {
			// Now, two of these are  bad, two are OK:
			if( `getAttr ($afterCut [$i] + ".spans")` < 1){ delete $afterCut[$i];
			} else {			
$numTokensZ = `tokenize $afterCut[$i] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; 
}		}
	if (catch(`select -r $bufferCutCurve[0]  $AllCurveZ[1]`)){
select -r $intersectionCurve3 $AllCurveZ[1];
	} else { print "hereCUT2"; }
cutCurvePreset(1,1,0.001,6,-0.7767,0.1104,- 0.6201,1,2);
	$afterCut = `ls -sl`;
		$n = size($afterCut);
		for( $i=0; $i<$n; $i+=1 ) {
			// Now, two of these are  bad, two are OK:
			if( `getAttr ($afterCut [$i] + ".spans")` < 1){ delete $afterCut[$i];
			} else {			
$numTokensZ = `tokenize $afterCut[$i] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; 
}		}
$renamed[0] = `rename $ZIntersectionCurveZ[0]  Curve`;
string $ZIntersectionCurveZB[];
 $ZIntersectionCurveZB = `listRelatives -shapes  $renamed`;
if (size($ZIntersectionCurveZB) > 0 ){
string $ListCONCurveZA[];
 $ListCONCurveZA = `listConnections  $ZIntersectionCurveZB`;
if (size( $ListCONCurveZA) > 0){
string $ListCONCurveZB[];
 $ListCONCurveZB = `listConnections -shapes 0 - source 0 $ListCONCurveZA`;
delete  $ListCONCurveZA $ListCONCurveZB;
}
}
$rebuildit = $renamed;



///////////
							 		} else { 


print "parent intersectionCurve3"; 
parent -w $intersectionCurve3;
//CHANGE
$rebuildit = $intersectionCurve3;
ResetTranslation($rebuildit);
select -r $intersectionCurve3 $AllCurveZ[0];

	 string $bufferCutCurve[];
	string $ZIntersectionCurveZ[];
	string $afterCut[];
	string $numTokensZ;
	int $n, $i;
cutCurvePreset(1,1,0.01,6,-0.7767,0.1104,- 0.6201,1,2);
	$afterCut = `ls -sl`;
		$n = size($afterCut);
		for( $i=0; $i<$n; $i+=1 ) {
			// Now, two of these are  bad, two are OK:
			if( `getAttr ($afterCut [$i] + ".spans")` < 1){ delete $afterCut[$i];
			} else {			
$numTokensZ = `tokenize $afterCut[$i] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; 
}
		}
//string $ZIntersectionCurveZA[];
// $ZIntersectionCurveZA = `listRelatives -shapes  $ZIntersectionCurveZ`;


if (catch(`select -r $bufferCutCurve[0]  $AllCurveZ[1]`)){
select -r $intersectionCurve3 $AllCurveZ[1];
	} else { print "hereCUT2"; }


cutCurvePreset(1,1,0.001,6,-0.7767,0.1104,- 0.6201,1,2);
	$afterCut = `ls -sl`;
		$n = size($afterCut);
		for( $i=0; $i<$n; $i+=1 ) {
			// Now, two of these are  bad, two are OK:
			if( `getAttr ($afterCut [$i] + ".spans")` < 1){ delete $afterCut[$i];
			} else {			
$numTokensZ = `tokenize $afterCut[$i] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; 
}
		}



$renamed[0] = `rename $ZIntersectionCurveZ[0]  Curve`;
string $ZIntersectionCurveZB[];
 $ZIntersectionCurveZB = `listRelatives -shapes  $renamed`;
if (size($ZIntersectionCurveZB) > 0 ){
string $ListCONCurveZA[];
 $ListCONCurveZA = `listConnections  $ZIntersectionCurveZB`;
if (size( $ListCONCurveZA) > 0){
string $ListCONCurveZB[];
 $ListCONCurveZB = `listConnections -shapes 0 - source 0 $ListCONCurveZA`;
delete  $ListCONCurveZA $ListCONCurveZB;
}
}
$rebuildit = $renamed;

}} else {
parent -w $intersectionCurve2;
string $renamed[]; 
$renamed[0] = `rename $intersectionCurve2 Curve`;
//CHANGE
$rebuildit = $renamed;
ResetTranslation($rebuildit); 
print "parent intersectionCurve002"; }
} else {
$intersectionCurve = `listRelatives  $intersectionCurveMake`; 
parent -w $intersectionCurve;
string $renamed[]; 
$renamed[0] = `rename $intersectionCurve Curve`; 
$rebuildit = $renamed;
ResetTranslation($rebuildit);
} 

if ( size($MakespaceLocatorZSE) == 0  ) {


string $paramANDCurveA2[];
$paramANDCurveA2 = `paramToCurvePts2(  $AllparamlocatorZ )`;
string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[0]`;
string $detachCurve2[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[1]`;
delete $AllCurveZ;
string $newCurves1[];
string $newCurves2[];
for ($each in $detachCurve1){
string $newCurve;
$newCurve = `rename $each Curve`;
ArrayInsertAtEnd( $newCurves1, $newCurve);
}

for ($each in $detachCurve2){
string $newCurve;
$newCurve = `rename $each Curve`;
ArrayInsertAtEnd( $newCurves2, $newCurve);
}

string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);
ArrayInsertAtEnd( $INarrayA, $newCurves2[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves2[1]);

ResetTranslationEach($newCurves1);
ResetTranslationEach($newCurves2);
string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;

$AllCurveZ = $newCurves1;
ArrayInsertAtEnd( $AllCurveZ, $newCurves2[0]);
ArrayInsertAtEnd( $AllCurveZ, $newCurves2[1]);
}

//////////////////
///////////////PROBLEMS HERE ####################

int $ONEspaceLOC = 0;
string $newCurves1[];
if (size($MakespaceLocatorZSE) == 1){
$ONEspaceLOC = 1;
print "MakespaceLocatorZSE_is_ONE";
string $subsetsA[];
$subsetsA = `sets -q $SEspaceLocSetofSetz`;
string $subsetsB[]; string $subsetsB2[];
$subsetsB = `sets -q $subsetsA`;
$subsetsB2[0] = $subsetsB[0];
$subsetsB3[0] = $subsetsB[1];
string $SetItemA = ($subsetsB2[0]);
string $SetItemB = ($subsetsB3[0]);
string $subsetItemNeeded[];
int $setATrueFalse = `gmatch $SetItemA "*->*"`;
int $setBTrueFalse = `gmatch $SetItemB "*->*"`;
if ($setATrueFalse == 1){
$subsetItemNeeded[0] = $subsetsB2[0];
}else{ $subsetItemNeeded[0] = $subsetsB3[0]; }
string $bufferZ[];
$numTokensX = `tokenize $subsetItemNeeded[0] "->"  $bufferZ`;
string $CurveLOCZ[] =  {$bufferZ[1]};

string $paramANDCurveA02[];
$paramANDCurveA02 = `paramToCurvePts2( $CurveLOCZ  )`;
string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA02[0]`;

delete $subsetsB[0];
string $newCurves1[];
for ($each in $detachCurve1){
string $newCurve;
$newCurve = `rename $each Curve`;
ArrayInsertAtEnd( $newCurves1, $newCurve);
}

string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);

  string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;
RemoveNoLongerExistingFromArray ($AllparamlocatorZ);
delete $AllparamlocatorZ; 
}

if ( size($MakespaceLocatorZSE) > 0  ) {
appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;	 		
$CurveSelection[1] = ($rebuildit[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
$MakeXBetweenB[0] = `curve -d 1 -p $EACHCVposAZ [0] $EACHCVposAZ[1] $EACHCVposAZ[2] -p  $EACHCVposBZ[0] $EACHCVposBZ[1] $EACHCVposBZ[2]  -k 0 -k 2 -n                        XCurveBetweenB`;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 0 -d 1 -tol 0.001  $MakeXBetweenB[0];
appendStringArray($digitalSkeletonA,  $MakeXBetweenB, 1);
}
}
wire -gw false -en 1.000000 -ce 0.000000 -li  1.000000 -w $MakeXBetweenB[0] -dds 0 50.000000  $rebuildit[0];
  
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($MakeXBetweenB[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($MakeXBetweenB[0] + ".cv [0]") ;			
$CurveSelection[1] = ($MakeXBetweenB[0] + ".cv["  + $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
				}
int $ZEROorONEA;
int $ZEROorONEB;
string $locZSE0[];
string $locZSE1[];
 int $foundAZ0;
 int $foundBZ0;
 int $foundAX1;
 int $foundBX1;
int $i = 0;
int $iX = 0;
float $eachCVpos1[];
float $eachCVpos2[];
float $movePIVOT1[];
float $movePIVOT2[];
	if (size($MakespaceLocatorZSE) == 1){	 $i = 1; }
	if (size($MakespaceLocatorZSE) == 2){ 	 $iX = 2; }
	if (( $i == 1) || ( $iX == 2)){
$locZSE0[0] = $MakespaceLocatorZSE[0];
$eachCVpos1 = `pointPosition -w  ($MakespaceLocatorZSE[0])`;
	if ( $iX == 2){
$locZSE1[0] = $MakespaceLocatorZSE[1];
$eachCVpos2 = `pointPosition -w  ($MakespaceLocatorZSE[1])`;
	}
	if (( $i == 1) || ( $iX == 2)) {

$ZEROorONEA = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVpos1);
if ( $ZEROorONEA == 0){ $movePIVOT1 =  $eachCVpos1; print "cv ZERO"; }
if ( $ZEROorONEA == 1){ $movePIVOT1 =  $eachCVpos1; print "cv LAST"; }
if ( $iX == 2){

$ZEROorONEB = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVpos2);
if ( $ZEROorONEB == 0){ $movePIVOT2 =  $eachCVpos2; print "cv ZERO"; }
if ( $ZEROorONEB == 1){ $movePIVOT2 =  $eachCVpos2; print "cv LAST"; }
move -ws $movePIVOT2[0] $movePIVOT2[1]  $movePIVOT2[2] $CurveSelection[$ZEROorONEB];
  	}

move -ws $movePIVOT1[0] $movePIVOT1[1]  $movePIVOT1[2] $CurveSelection[$ZEROorONEA];
 				}
delete -ch $rebuildit;
RemoveNoLongerExistingFromArray ($digitalSkeletonA);
if (size($digitalSkeletonA) > 0){
delete $digitalSkeletonA; }

	}
}

///////////////////////////////////////////////// ////////////////////////////


int $CVsZeroAndLast;
if ( size($MakespaceLocatorZSE) > 0  ) {

if ( `objExists ZEdgeCurvesSet` == 1  ) {
//Flattening X to Zero
if ( $ONEspaceLOC == 0  ) {

int $edgeZsetA = `sets -im ZEdgeCurvesSet  $AllCurveZ[0]`;
int $edgeZsetB = `sets -im ZEdgeCurvesSet  $AllCurveZ[1]`;
$CVsZeroAndLast = FindIfCurveISonZ($rebuildit);

if (($edgeZsetA == 1) && ($edgeZsetB == 1)){
print "Intersects edgeZset Curves";
string $CurveSelectionZ[];
int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );	
$CurveSelectionZ[0] = ($rebuildit[0] + ".cv[" +  "0:" + $numCVrealNum + "]") ;

if ($CVsZeroAndLast == 2){
string $CurveSelectionX[];
$CurveSelectionX = `ls -fl $CurveSelectionZ[0]`;
for ($eachZA in $CurveSelectionX) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
move -ws 0 $eachCVpos[1] $eachCVpos[2] $eachZA ; 
}
}
xform -cp;
}
}
}
}
  
ResetTranslation($rebuildit);
select -r $rebuildit;
string $ParentArc[];
$ParentArc = Strait_ARC_or_FreeForm($rebuildit,  5.5, 2.5 );

if($CVsZeroAndLast < 2)  {
select -r $ParentArc;
MirrorANDrename($ParentArc);
}
if ( $CVsZeroAndLast > 0){ 
sets -include ZEdgeCurvesSet $ParentArc;
 }
//delete $rebuildit;
ArrayInsertAtEnd( $INarrayA, $ParentArc[0]);
////////////////////////////////ADDON
ResetTranslation($ParentArc);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ParentArc;
select -r $ParentArc[0];
EvalAddingCurves;
////////////////////TRIGGER###################### #######////////////////
EvalcreatSphere;
////////////////////TRIGGER###################### #######////////////////
}
RemoveNoLongerExistingFromArray ($digitalSkeletonA);
if (size($digitalSkeletonA) > 0){
delete $digitalSkeletonA;
}
RemoveNoLongerExistingFromArray ($AllparamlocatorZ);
if (size($AllparamlocatorZ) > 0){
delete $AllparamlocatorZ;
} 

if ( `objExists $SEspaceLocSetofSetz` == 1  ) { 	
select -r -ne $SEspaceLocSetofSetz;
delete;
}

//END of "If elses"

}


///////////////////////////////////////////////// ///////////////////////////////////////////////// ////
///////////////////////////////////////////////// ///////////////////////////////////////////////// ////
///////////////////////////////////////////////// ///////////////////////////////////////////////// ////
///////////////////////////////////////////////// ///////////////////////////////////////////////// ////
///////////////////////////////////////////////// ///////////////////////////////////////////////// ////
///////////////////////////////////////////////// ///////////////////////////////////////////////// ////
///////////////////////////////////////////////// ///////////////////////////////////////////////// ////
//###############_END_########################### #





proc float[] EulerAngleofTwoPoints(float  $EACHCVposAZ[], float $EACHCVposBZ[]){

vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
float $MagVectorZ1 = mag($vectorZ1); 
float $MagVectorZ2 = mag($vectorZ2);
float $EACHCVposHigher[];
float $EACHCVposLower[];
if ( $MagVectorZ1 > $MagVectorZ2 ){
print (" posA is Higher " + "\n");
$EACHCVposHigher = $EACHCVposAZ;
$EACHCVposLower = $EACHCVposBZ;
}
if ( $MagVectorZ1 < $MagVectorZ2  ){
print (" posB is Higher " + "\n");
$EACHCVposHigher = $EACHCVposBZ;
$EACHCVposLower = $EACHCVposAZ;
}
float $pointCVAB_MidPoint[] = MidPointBetween ($EACHCVposHigher, $EACHCVposLower);
/////////////////////////////////////
vector $UnitVectorMagPosHigher[] =  MagTimesUnitVecs($EACHCVposHigher,  $pointCVAB_MidPoint);
float $vector_SubUnitMagVec1[];
$vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 
vector $UnitVectorMagPosLower[] =  MagTimesUnitVecs($EACHCVposLower,  $pointCVAB_MidPoint);
float $vector_SubUnitMagVec2[];
$vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]); 
///////////////////////////////////////////////// ////
float $curveArclenZ  = PointsGetDistanceFLOAT ($EACHCVposAZ, $EACHCVposBZ);
float $DivideIt  = $curveArclenZ / 2.0;
float $DivideIt2  = $DivideIt * -1;
float $pointB1[] = {0.0 , 0.0 , $DivideIt} ;
float $pointB2[] = {0.0 , 0.0 , $DivideIt2} ;
/// NOTE curve ENds will not allways Line up and  may be inverted
//let $F1 be the first CV $F2 the last .. $F3  third point
int $Z = FindclosetTOcurveENDz($pointB1,  $pointB2, $vector_SubUnitMagVec2);
if ($Z == 1){ print "new floats"; $pointB1 =  $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
float $EulerAngleA[] = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2   $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2 [1]     $vector_SubUnitMagVec2[2]`;
float $EulerAngleB[] = `angleBetween -euler -v1  $pointB2[0] $pointB2[1] $pointB2[2] -v2  $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1 [1]     $vector_SubUnitMagVec1[2]`;

return $EulerAngleA;
}

proc float[] getYrotationOFcam(){
float $CamerasDirectionVector[] ;
float $CamerasPositionz[];
float $CamLengthVector[];
//============================================
float $CamerasDirectionVector[] =  nurbsViewDirectionVector(0);
//============================================ ;)  nurbsViewDirectionVector =====
string $currPanel = `getPanel -withFocus` ,  $camera ;
string $Camera = `modelEditor -q -camera  $currPanel`;
$CamerasPositionz = `camera -q -position  $Camera`;
float $CP[] = $CamerasPositionz;

$CamLengthVector = AddFloats ($CamerasDirectionVector, $CP);

float $CamEulerAngleN[] = {$CamLengthVector[0],  0.0, $CamLengthVector[2]};
float $CamEulerAngleNi[] = {$CamerasPositionz[0],  0.0, $CamerasPositionz[2]};
float $CamEulerAngle[] = EulerAngleofTwoPoints ($CamEulerAngleN, $CamEulerAngleNi);

return $CamEulerAngle;
}


proc float[] getXrotationOfCam(){
float $CamerasDirectionVector[] ;
float $CamerasPositionz[];
float $CamLengthVector[];
//============================================
float $CamerasDirectionVector[] =  nurbsViewDirectionVector(0);
//============================================ ;)  nurbsViewDirectionVector =====
string $currPanel = `getPanel -withFocus` ,  $camera ;
string $Camera = `modelEditor -q -camera  $currPanel`;
$CamerasPositionz = `camera -q -position  $Camera`;
float $CP[] = $CamerasPositionz;
$CamLengthVector = AddFloats ($CamerasDirectionVector, $CP);

float $CamEulerAngleN[] = {$CamLengthVector[0],  0.0, $CamLengthVector[2]};
float $CamEulerAngleNi[] = {$CamerasPositionz[0],  0.0, $CamerasPositionz[2]};
float $CamEulerAngle[] = EulerAngleofTwoPoints ($CamEulerAngleN, $CamEulerAngleNi);

float $CamEulerAngleX[] = EulerAngleofTwoPoints ($CamLengthVector, $CP);

//cross is needed
return $CamEulerAngle;
}


proc float magF(float $AnglePointA[]){
vector $AngleP = << $AnglePointA[0], $AnglePointA[1], $AnglePointA[2] >>;
float $AnglePointB = mag($AngleP);
return $AnglePointB;
}



proc float[] multiplyFloat(float  $posA, float $posB[]){
float $AddposA_AND_posB_float[];
$TimesposA_AND_posB_float = {($posA * $posB[0]),  ($posA * $posB[1]), ($posA * $posB[2])} ;
return $TimesposA_AND_posB_float;
}


proc float [] unitF(float $AnglePointA[]){
vector $AngleP = << $AnglePointA[0], $AnglePointA[1], $AnglePointA[2] >>;
float $AnglePointB[] = unit($AngleP);
return $AnglePointB;
}


proc float [] RotPoint(float $posF[], float $Ax[], float $Ndegrees){

vector $myVec = << $posF[0], $posF[1], $posF[2] >>;
vector $Axis = << $Ax[0], $Ax[1], $Ax[2] >>;
vector $rot_Vec = rot($myVec, $Axis, $Ndegrees);
float $Roatation[] = $rot_Vec;
return $Roatation;
}





/*

-40.829 

-40.829 18.8 0.0


proc float[] getYrotationOFcam(){

float $CamerasDirectionVector[] ;
float $CamerasPositionz[];
float $CamLengthVector[];
//============================================
float $CamerasDirectionVector[] =  nurbsViewDirectionVector(0);
//============================================ ;)  nurbsViewDirectionVector =====
string $currPanel = `getPanel -withFocus` ,  $camera ;
string $Camera = `modelEditor -q -camera  $currPanel`;
$CamerasPositionz = `camera -q -position  $Camera`;
float $CP[] = $CamerasPositionz;
float $One[] ={1, 1, 1};
float $Zero[] ={0, 0, 0};
$CamLengthVector = AddFloats ($CamerasDirectionVector, $CP);

print $CamerasDirectionVector

print unitF $CamerasDirectionVector

float $magCam = `magF $CP`;

vector $UnitVecMagZ[] =  MagTimesUnitVecs($CP,  $CamLengthVector);
float $UnitVectorMagF[] = $UnitVecMagZ[0];

float $vector_SubUnitMagVec1[];
float $UnitDirectionFloatA[] = SubtractFloats ($CamLengthVector,$UnitVectorMagF); 
Loc $UnitDirectionFloatA;
float $UnitpointXY[] = {0.0, $UnitDirectionFloatA[1], $UnitDirectionFloatA[2]};
float $UnitpointY[] = {$UnitDirectionFloatA[0],  0.0, $UnitDirectionFloatA[2]};
Loc $UnitpointXY;
Loc $UnitpointY;
float $UnitHightZY = $UnitpointXY[1]

Loc $CP;
Loc $CamLengthVector;


//float $Direction[] = DirectionTwoPoints($CamLengthVector, $CP);

float $CamEulerAngleN[] = {$CamLengthVector[0],  0.0, $CamLengthVector[2]};

float $CamEulerAngleNi[] = {$CamerasPositionz[0],  0.0, $CamerasPositionz[2]};
float $CamEulerAngleNiiX[] = {$CP[0], 0.0, $CP[2]};

float $CamHightZYPlain[] = {0.0, $CP[1], 0.0};
float $HightZY = $CP[1];

Loc $CamEulerAngleN;

//The same Bottom
Loc $CamEulerAngleNi;
Loc $CamEulerAngleNiiX;
///////////////////////////////////////////////// ////



float $CamEulerAngleN1[] = { 0.0, $CamLengthVector[1], $CamLengthVector[2]};
// Result: 0 18.89263 20.698596 // 
float $CamEulerAngleNi1[] = { 0.0, $CamerasPositionz[1], $CamerasPositionz[2]};
// Result: 0 18.238829 19.982298 // 

float $CamEulerAngleN2i[] = {0.0,  0.0, $CamLengthVector[2]};

Loc $CamEulerAngleN1 ;
Loc $CamEulerAngleN2i ;

 float $Zero[] ={0, 0, 0};

float $CamEulerAngleX[] = EulerAngleofTwoPoints ($CamEulerAngleN1, $Zero);

float $CamEulerAngleN2[] = { 0.0, $CamLengthVector[1], $CamLengthVector[2]};
float $CamEulerAngleNi2[] = { 0.0, $CamerasPositionz[1], $CamerasPositionz[2]};

float $CamEulerAngleN[] = {$CamLengthVector[0],  0.0, $CamLengthVector[2]};

//This one is the floor rotate this point the degrees in Y
float $CamEulerAngleNi[] = {$CamerasPositionz[0],  0.0, $CamerasPositionz[2]};


float $CamEulerAngleA[] = EulerAngleofTwoPoints ($CamEulerAngleN1, $CamEulerAngleNi1);

float $CamEulerAngleB[] = EulerAngleofTwoPoints ($CamEulerAngleN, $CamEulerAngleNi);
float $CamEulerAngleBNeg = $CamEulerAngleB[1] *-1;
float $EulerAngleBRad = deg_to_rad($CamEulerAngleB[1]);
float $EulerAngleBRadN = deg_to_rad($CamEulerAngleBNeg);

float $Ax[] = { 0, 1, 0};

float $CamHightZYPlain[] = {0.0, $CP[1], 0.0};
float $HightZY = $CP[1];

float $RotationPointUnit[] = RotPoint($UnitpointY, $Ax, $EulerAngleBRadN);
$RotationPointUnit = `MakeCleanFloats $RotationPointUnit`;
Loc $RotationPointUnit;

float $RotationPoint[] = RotPoint($CamEulerAngleNi, $Ax, $EulerAngleBRadN);
$RotationPoint = `MakeCleanFloats $RotationPoint`;

///###
float $AnglePointUnitA[] = {0.0, $UnitHightZY, $RotationPointUnit[2]};
Loc $AnglePointUnitA;

//////////////////////////////////////////


float $AnglePointA[] = {0.0, $HightZY, $RotationPoint[2]};
vector $AngleP = << $AnglePointA[0], $AnglePointA[1], $AnglePointA[2] >>;
float $AnglePointB[] = unit($AngleP);
float $AnglePointC[] = AddFloats ($AnglePointB, $AnglePointA);

float $CamEulerAngleX[] = EulerAngleofTwoPoints ($AnglePointUnitA, $Zero);

float $CamEulerAngleX[] = EulerAngleofTwoPoints ($AnglePointA, $AnglePointC);

Loc $CamEulerAngleNi;
Loc $RotationPoint;
Loc $AnglePointA;

float $CamEulerAngle[] = EulerAngleofTwoPoints ($CamEulerAngleN, $CamEulerAngleNi);

print $CamEulerAngleX;
print " ";
print $CamEulerAngle;

Loc ($CamEulerAngleN);

//RotPoint(float $posF[], float $Ax[], float $Ndegrees)


//cross is needed
return $CamEulerAngle;
}

*/
proc float [] GetAngleEulerBetween(float $pointA[], float $pointB[]){
float $AngleEuler[] = `angleBetween -euler -v1 $pointA[0] $pointA[1] $pointA[2] -v2 $pointB[0] $pointB[1] $pointB[2]`;
return $AngleEuler;
}

// -39.649 

///////////////////////////////

//float $CamEulerAngleA[] = `getYrotationOFcam`;
//SetRotations($objectSet, $CamEulerAngleA);
//string $objectSet[];
//$objectSet = `ls -sl`;
////////////////////////////////

////////////////////////////////


proc Loc(float $Points[]){
spaceLocator -p $Points[0] $Points[1] $Points[2];
}

proc int ZplainFlatten(){
int $Y = 0;
float $CamEulerAngle[] = `getYrotationOFcam`;
float $CamEulerAngleY = `abs $CamEulerAngle[1]`;
if ($CamEulerAngleY < 22.0){
$Y = 1; print "Less then 22";
}
return $Y;
}


///////////////////////////////
//string $objectSet[];
//$objectSet = `ls -sl`;
//float $CurveEulerAngleA[] = `EulerAngleofCurve`;
//SetRotations($objectSet, $CurveEulerAngleA);
////////////////////////////////

proc setRotationAxisFloat(string $objectitem1[], float $rotationsA[]){
//
select -cl  ;
string $groupRotAX;
$groupRotAX = `group -w -em -n RotAxiz`; xform - os -piv 0 0 0 $groupRotAX;
string $itemB = $objectitem1[0];
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0  $itemB;
setAttr ($groupRotAX+".rotate") $rotationsA[0]  $rotationsA[1] $rotationsA[2];
parent -absolute $itemB $groupRotAX;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0  $itemB; parent -w $itemB;
delete $groupRotAX;
}


proc float[] EulerAngleofCurve(){
string $CurveItem[];
$CurveItem = `ls -sl`;
string $CurveSelection[];
int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 		
$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}
vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
float $MagVectorZ1 = mag($vectorZ1); 
float $MagVectorZ2 = mag($vectorZ2);
float $EACHCVposHigher[];
float $EACHCVposLower[];
if ( $MagVectorZ1 > $MagVectorZ2 ){
print (" posA is Higher " + "\n");
$EACHCVposHigher = $EACHCVposAZ;
$EACHCVposLower = $EACHCVposBZ;
}
if ( $MagVectorZ1 < $MagVectorZ2  ){
print (" posB is Higher " + "\n");
$EACHCVposHigher = $EACHCVposBZ;
$EACHCVposLower = $EACHCVposAZ;
}
float $pointCVAB_MidPoint[] = MidPointBetween ($EACHCVposHigher, $EACHCVposLower);
/////////////////////////////////////
vector $UnitVectorMagPosHigher[] =  MagTimesUnitVecs($EACHCVposHigher,  $pointCVAB_MidPoint);
float $vector_SubUnitMagVec1[];
$vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 
vector $UnitVectorMagPosLower[] =  MagTimesUnitVecs($EACHCVposLower,  $pointCVAB_MidPoint);
float $vector_SubUnitMagVec2[];
$vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]); 
///////////////////////////////////////////////// ////
float $curveArclenZ  = `arclen $CurveItem`;
float $DivideIt  = $curveArclenZ / 2.0;
float $DivideIt2  = $DivideIt * -1;
float $pointB1[] = {0.0 , 0.0 , $DivideIt} ;
float $pointB2[] = {0.0 , 0.0 , $DivideIt2} ;
/// NOTE curve ENds will not allways Line up and  may be inverted
//let $F1 be the first CV $F2 the last .. $F3  third point
int $Z = FindclosetTOcurveENDz($pointB1,  $pointB2, $vector_SubUnitMagVec2);
if ($Z == 1){ print "new floats"; $pointB1 =  $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
float $EulerAngleA[] = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2   $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2 [1]     $vector_SubUnitMagVec2[2]`;
float $EulerAngleB[] = `angleBetween -euler -v1  $pointB2[0] $pointB2[1] $pointB2[2] -v2  $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1 [1]     $vector_SubUnitMagVec1[2]`;

return $EulerAngleA;
}

///////////////////////////////////////////////// ////

///////////////////////////////////////////////// ////

proc float[] MidPointBetween(float $loc1[],  float $loc2[]) {
	float $a = ($loc2[0] + $loc1[0]) * (0.5);
	float $b = ($loc2[1] + $loc1[1]) * (0.5);
	float $c = ($loc2[2] + $loc1[2]) * (0.5);

	float $MidPoint[] = {$a , $b , $c};
	return $MidPoint;
	}
///////////////////////////////////////////////// ////

///////////////////////////////////////////////// ////

proc int  PointsEquivalentTol( float $posA[],  float $posB[]){
int $pX = equivalentTol($posA[0], $posB[0],  0.001);
int $pY = equivalentTol($posA[1], $posB[1],  0.001);
int $pZ = equivalentTol($posA[2], $posB[2],  0.001);
int $addedResults = $pX + $pY + $pZ;
if ($addedResults == 3 ){ print "Points  equivalent"; 
}
return $addedResults;
}
///////////////////////////////////////////////// ////


//////////////////////////////////////////
proc vector[] MagTimesUnitVecs(vector  $vectorZFlatYHigher, vector $vectorZFlatYLower){
float $MagVectorZYHigher = mag ($vectorZFlatYHigher); 
float $MagVectorZYLower = mag ($vectorZFlatYLower); 
vector $unitVectormagZYHL[];
$unitVectormagZYHL[0] = $MagVectorZYHigher *  unit($vectorZFlatYHigher);
$unitVectormagZYHL[1] = $MagVectorZYLower * unit ($vectorZFlatYLower);
print $unitVectormagZYHL;
return $unitVectormagZYHL;
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float[] AppendFloatsZ(float $posA[], float  $posB[], int $XYZ){
float $AddposA_AND_posB_float[];
if($XYZ == 0){ $AddposA_AND_posB_float = {$posB [0], $posA[1], $posA[2]} ; }
if($XYZ == 1){ $AddposA_AND_posB_float = {$posA [0], $posB[1], $posA[2]} ; }
if($XYZ == 2){ $AddposA_AND_posB_float = {$posA [0], $posA[1], $posB[2]} ; }
return $AddposA_AND_posB_float;
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float[] CycleFloatsZ(float $posA[], float  $posB[], int $XYZ1, int $XYZ2){
float $AddposA_AND_posB_float[];
if(($XYZ1 == 0) && ($XYZ2 == 1)){  $AddposA_AND_posB_float = {$posA[1], $posA[0],  $posA[2]} ; } //01 xy
if(($XYZ1 == 0) && ($XYZ2 == 2)){  $AddposA_AND_posB_float = {$posA[2], $posB[1],  $posA[0]} ; } //02 xz
if(($XYZ1 == 1) && ($XYZ2 == 2)){  $AddposA_AND_posB_float = {$posA[0], $posA[2],  $posB[1]} ; } //12 yz
return $AddposA_AND_posB_float;
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float[] AddFloats(float $posA[], float  $posB[]){
float $AddposA_AND_posB_float[];
$AddposA_AND_posB_float = {($posA[0] + $posB[0]),  ($posA[1] + $posB[1]), ($posA[2] + $posB[2])} ;
return $AddposA_AND_posB_float;
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float[] SubtractFloats(float $posA[], float  $posB[]){
float $SubtractposA_AND_posB_float[];
$SubtractposA_AND_posB_float = {($posA[0] -  $posB[0]), ($posA[1] - $posB[1]), ($posA[2] -  $posB[2])} ;
return $SubtractposA_AND_posB_float;
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float[] multiplyFloat(float  $posA, float $posB[]){
float $AddposA_AND_posB_float[];
$TimesposA_AND_posB_float = {($posA * $posB[0]),  ($posA * $posB[1]), ($posA * $posB[2])} ;
return $TimesposA_AND_posB_float;
}
//////////////////////////////////////////


//////////////////////////////////////////
proc float[] Add_Float_to_3PointFloats(float  $posA, float $posB[]){
float $AddposA_AND_posB_float[];
$AddposA_AND_posB_float = {($posA + $posB[0]),  ($posA + $posB[1]), ($posA + $posB[2])} ;
return $AddposA_AND_posB_float;
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float[] SubtractFloat_to_3PointFloats(float  $posA, float $posB[]){
float $SubtractposA_AND_posB_float[];
$SubtractposA_AND_posB_float = {($posA - $posB [0]), ($posA - $posB[1]), ($posA - $posB[2])} ;
return $SubtractposA_AND_posB_float;
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float GetDegreesFromFloat(float $posA[],  float $posB[]){
vector $xvex = << $posA[0], $posA[1], $posA[2] >>  ;
vector $yvex = << $posB[0], $posB[1], $posB[2] >>  ;
float $xy_angle = angle ($xvex, $yvex) ;
float $Some_degrees = `rad_to_deg $xy_angle`;
print $Some_degrees;
return $Some_degrees; 
}

///////////////////////////////////////////////// ////
proc SetRotations(string $objectSet[], float  $EulerAngleA[]){
setAttr ($objectSet[0] + ".rotate") $EulerAngleA [0] $EulerAngleA[1] $EulerAngleA[2] ;
}
proc SetTranslations(string $objectSet[], float  $EulerAngleA[]){
setAttr ($objectSet[0] + ".translate")  $EulerAngleA[0] $EulerAngleA[1] $EulerAngleA[2] ;
}
///////////////////////////////////////////////// ////
///////////////////////////////////////////////// ////


//////////TEST///////////////////////////
//string $ObjectSelectionz[];
//$ObjectSelectionz = `ls -sl`;

//string $curveObject[];
//$curveObject = `ls -sl`;
//float $translationZ[] = `ResetTranslation ($curveObject)`;
//float $EulerAngleCurveObject[] =  `EulerAngleofCurve`;
//SetRotations($ObjectSelectionz,  $EulerAngleCurveObject);
//SetTranslations($ObjectSelectionz,  $translationZ);
//////////////////////////////////////////

//float $pi = 3.141593 ;
//float $pointZero[];
//$pointZero = << 0, 0, 0 >>;
float $Axis_x[];
float $Axis_y[];
float $Axis_z[];
$AxisF_x = << 1, 0, 0 >>;
$AxisF_y = << 0, 1, 0 >>;
$AxisF_z = << 0, 0, 1 >>;
vector $Axis_X = << 1, 0, 0 >>;
vector $Axis_Y = << 0, 1, 0 >>;
vector $Axis_Z = << 0, 0, 1 >>;

//////////////////////////////////////////

proc float GetDistanceBetweenCurveEnds(string  $CurveItem[]){
string $CurveSelection[];
int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 		
$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}
$dAx = $EACHCVposAZ[0] - $EACHCVposBZ[0]; $dAy =  $EACHCVposAZ[1] - $EACHCVposBZ[1];
$dAz = $EACHCVposAZ[2] - $EACHCVposBZ[2]; float  $distanceA2; 
float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
return $distanceA2; 
}
//////////////////////////////////////////

//////////////////////////////////////////


proc float GetDistancePointPositionFLOAT(string  $objectFirst, string $objectSecond){
float $pointAZ1[]; float $pointAZ2[];
if (catch($pointAZ1 = `pointPosition -w  ($objectFirst)`)){
print "using Xform"; $pointAZ1 = `xform -q -ws - rp ($objectFirst)`;
	} 
if (catch($pointAZ2 = `pointPosition -w  ($objectSecond)`)){
print "using Xform"; $pointAZ1 = `xform -q -ws - rp ($objectSecond)`;
	} $dAx = $pointAZ1[0] - $pointAZ2[0];  $dAy = $pointAZ1[1] - $pointAZ2[1];
$dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2; 
float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
return $distanceA2; 
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float GetDistanceFLOAT(string $objectFirst,  string $objectSecond){
float $pointAZ1[]; float $pointAZ2[];
	if (catch($pointAZ1 = `pointPosition -w  ($objectFirst)`)){
print "using Xform"; $pointAZ1 = `xform -q -ws - rp ($objectFirst)`;
	} 
if (catch($pointAZ2 = `pointPosition -w  ($objectSecond)`)){
print "using Xform"; $pointAZ1 = `xform -q -ws - rp ($objectSecond)`;
	} 
$dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy =  $pointAZ1[1] - $pointAZ2[1];
$dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2; 
float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
return $distanceA2; 
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float PointsGetDistanceFLOAT(float  $pointAZ1[], float $pointAZ2[]){
$dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy =  $pointAZ1[1] - $pointAZ2[1];
$dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2; 
float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
return $distanceA2; 
}
//////////////////////////////////////////

//////////////////////////////////////////
proc float getDistance(float  $pointAZ1[], float $pointAZ2[]){
$dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy =  $pointAZ1[1] - $pointAZ2[1];
$dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2; 
float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
return $distanceA2; 
}
//////////////////////////////////////////

proc float GetDistanceBetweenCurveEnds(string  $CurveItem[]){
string $CurveSelection[];
int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 		
$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}
$dAx = $EACHCVposAZ[0] - $EACHCVposBZ[0]; $dAy =  $EACHCVposAZ[1] - $EACHCVposBZ[1];
$dAz = $EACHCVposAZ[2] - $EACHCVposBZ[2]; float  $distanceA2; 
float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
return $distanceA2; 

}



//////////////////////////////////////////
proc int ZeroOrONE(string $objectLoc[]){
string $objectLocZ[];
$objectLocZ = $objectLoc;
int $X = size($objectLocZ) -1;
int $Z = size($objectLocZ);
int $i = 1;
int $n = -1;
int $n2 = 0;
float $SubtractAB[];
float $posA[];
float $posB[];
int $Zero0rOne = 0;
for( $i = 0; $i < $X; $i ++ ) {
$n = $n + 1;
$Z = $Z - 1;
$ix = 0;
$n2 = $n + 1;
while ($Z > $ix++){

	$posA = `xform -q -wd -translation  $objectLocZ[$n]`;
	$posB = `xform -q -wd -translation  $objectLocZ[$n2]`;
$n2++;	
$SubtractAB = SubtractFloats($posA, $posB);
if (($SubtractAB[0] == 0) && ($SubtractAB[1] ==  0) && ($SubtractAB[2] == 0 )){
print "yes AB";
$Zero0rOne = 1;
}
}
}
return $Zero0rOne;
}

//////////////////////////////////////////

//////////////////////////////////////////
proc MoveObject(float $addfloatVector1[], string  $VectorUnitLoc[] ){
move -ws $addfloatVector1[0] $addfloatVector1[1]  $addfloatVector1[2] $VectorUnitLoc[0];
}
proc MoveObjectSelection(float $addfloatVector1 []){
string $VectorUnitLoc[];
$VectorUnitLoc = `ls -selection`;
move -ws $addfloatVector1[0] $addfloatVector1[1]  $addfloatVector1[2] $VectorUnitLoc[0];
}
//////////////////////////////////////////

proc float[] GetCurveCVposENDS(string $CurveItem [], int $ix){
string $CurveSelection[];
int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 		
$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}
if ($ix == 0){
return $EACHCVposAZ; }
if ($ix == 1){
return $EACHCVposBZ; }
}

//////////////////////////////////////////

//////////////////////////////////////////

//////////////////////////////////////////
// $scriptt_jobNum = `scriptJob -event  DagObjectCreated StraitCurvesSCRIPTZ - compressUndo true -protected`;


//////////////////////////////////////////


//////////////////////////////////////////

proc FlattenCurveToZplain(string $renamed[]){
string $CurveSelectionZ[];
int $numCVs = `getAttr -size ($renamed[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );	
$CurveSelectionZ[0] = ($renamed[0] + ".cv[" +  "0:" + $numCVrealNum + "]") ;
string $CurveSelectionX[];
$CurveSelectionX = `ls -fl $CurveSelectionZ[0]`;
for ($eachZA in $CurveSelectionX) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
move -ws 0 $eachCVpos[1] $eachCVpos[2] $eachZA ; 
}
}
//////////////////////////////////////////

//////////////////////////////////////////

proc vector[] VecCurveEnds(string $CurveItem[]){
string $CurveSelection[];
int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 		
$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}
vector $VectorCurveEnds[];
$VectorCurveEnds[0] = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
$VectorCurveEnds[1] = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;

return $VectorCurveEnds; 
}

//////////////////////////////////////////

//////////////////////////////////////////

global proc string[] MakeCurveBetweenFloats(float  $posA[], float $posB[]){
string $ZBetween[];
$ZBetween[0] = `curve -d 1 -p $posA[0] $posA[1]  $posA[2] -p $posB[0] $posB[1] $posB[2] -k 0 -k 2  -n ZCurveBetween`;
return $ZBetween;
}
//////////////////////////////////////////

//////////////////////////////////////////

proc float[] MakeCleanFloats(float $FloatZ[]){
string $POSAe = $FloatZ[0]; string $POSBe =  $FloatZ[1];
string $POSCe = $FloatZ[2];
string $nameAe; string $nameBe; string $nameCe;
$nameAe = `match "e" $POSAe`;
$nameBe = `match "e" $POSBe`;
$nameCe = `match "e" $POSCe`;
int $zeroORZe1 = `gmatch "e" $nameAe`;
int $zeroORZe2 = `gmatch "e" $nameBe`;
int $zeroORZe3 = `gmatch "e" $nameCe`;
if ( $zeroORZe1 == 1){ $FloatZ[0] = 0.0; }
if ( $zeroORZe2 == 1){ $FloatZ[1] = 0.0; }
if ( $zeroORZe3 == 1){ $FloatZ[2] = 0.0; }
return $FloatZ;
}

////////////////////////////////////////////

proc float MakeCleanFloat1(float $FloatZ){
string $POSAe = $FloatZ; 
string $nameAe; 
$nameAe = `match "e" $POSAe`;
int $zeroORZe1 = `gmatch "e" $nameAe`;
if ( $zeroORZe1 == 1){ $FloatZ = 0.0; }
return $FloatZ;
}
//////////


//proc float PercentDiff_Curve_to_Arc(float  $arclenghtzARC, float $arclenghtzDRAWN){
///float $PercentA;
//$PercentA = ((float($arclenghtzARC) /  $arclenghtzDRAWN) * (100) );
//return $PercentA;
//}

proc float PercentDiff_Curve_to_Arc(float  $arclenghtzARC, float $arclenghtzDRAWN){
float $FLOAT1;
float $FLOAT2;
if($arclenghtzARC < $arclenghtzDRAWN){
$FLOAT1 = $arclenghtzARC; $FLOAT2 = $arclenghtzDRAWN;}
if($arclenghtzARC > $arclenghtzDRAWN){
$FLOAT1 = $arclenghtzDRAWN; $FLOAT2 = $arclenghtzARC; }
float $PercentA;
if($arclenghtzARC == $arclenghtzDRAWN){
$PercentA = 0;}else{
$PercentA = ((float($FLOAT1) / $FLOAT2) * (100) ); }
return $PercentA;
}


///////////////////////////////////////////////// ///////////////////////////////////////////////// ////


proc string[] paramToCurvePts3( string  $locatorShapes[] ){
	string $curveName[];
	int $i;
	int $numLocators = size($locatorShapes);
	for( $i = 0; $i < $numLocators; $i ++ ) {
// Get the parent transform above the locator  shape
string $parent1[] = `listRelatives -p  $locatorShapes[$i]`;
string $parent2[] = `listRelatives -p $parent1 [0]`;
string $parent3[] = `listRelatives -p $parent2 [0]`;		
$curveName[ size($curveName) ] = $parent3[0];
}
return $curveName;
}


proc string[] paramToCurvePts2( string $locatorShapes[] ){

	string $selectionList[];
	string $curveName;
	float $parm;
	int $i;
	int $numLocators = size($locatorShapes);
	for( $i = 0; $i < $numLocators; $i ++ ) {
// Get the parent transform above the locator shape
string $parent1[] = `listRelatives -p $locatorShapes[$i]`;

string $parent2[] = `listRelatives -p $parent1[0]`;
		$curveName = $parent2[0];
		if( `nodeType $curveName` != "nurbsCurve" ) continue;

string $pmm;
		if( !catch($pmm = `createNode pointMatrixMult`) ) {
	float $pos[] = `getAttr ($locatorShapes[$i] + ".localPosition")`;
			$parm = `getAttr ($parent1[0] + ".translateX")`;
setAttr ($pmm +".inPoint") -type double3  $pos[0] $pos[1] $pos[2];
			setAttr ($pmm +".vectorMultiply") true ;
			connectAttr ($parent1[0]+".worldMatrix[0]") ($pmm+".inMatrix") ;
			float $result[] = `getAttr ($pmm+".output")` ;
			$parm = $result[0];

	string $selectionItem = $curveName + ".u[" + $parm + "]";
			$selectionList[ size($selectionList) ] = $selectionItem;

delete $pmm;
		}
	}
	return $selectionList;
}


////////////////////////////////////////////////////////
proc string[] paramToCurvePts( string $locatorShapes[] ){

	string $selectionList[];
	string $curveName;
	float $parm;
	int $i;
	int $numLocators = size($locatorShapes);
	for( $i = 0; $i < $numLocators; $i ++ ) {
// Get the parent transform above the locator shape
string $parent1[] = `listRelatives -p $locatorShapes[$i]`;

string $parent2[] = `listRelatives -p $parent1[0]`;
		$curveName = $parent2[0];
		if( `nodeType $curveName` != "nurbsCurve" ) continue;

string $pmm;
		if( !catch($pmm = `createNode pointMatrixMult`) ) {
	float $pos[] = `getAttr ($locatorShapes[$i] + ".localPosition")`;
			$parm = `getAttr ($parent1[0] + ".translateX")`;
setAttr ($pmm +".inPoint") -type double3  $pos[0] $pos[1] $pos[2];
			setAttr ($pmm +".vectorMultiply") true ;
			connectAttr ($parent1[0]+".worldMatrix[0]") ($pmm+".inMatrix") ;
			float $result[] = `getAttr ($pmm+".output")` ;
			$parm = $result[0];

	string $selectionItem = $curveName + ".u["  + "0.0" + ":" + $parm + "]";
			$selectionList[ size($selectionList) ] = $selectionItem;

delete $pmm;
		}
	}
	return $selectionList;
}
////////////////////////////////////////////////////////

////////////////////////////////////////////////////////

proc string[] tokenizeparam( string $paramANDCurveZ[] ){
	string $selectionList[];
	int $i;
	int $num = size($paramANDCurveZ);
	for( $i = 0; $i < $num; $i ++ ) {
string $bufferA[];
$numTokensA = `tokenize $paramANDCurveZ[$i] "." $bufferA`;
	string $selectionItem = $bufferA[0];
			$selectionList[ size($selectionList) ] = $selectionItem;
	}
	return $selectionList;
}
////////////////////////////////////////////////////////

////////////////////////////////////////////////////////

proc string[] EvalMoveCurvesTOend(string  $paramANDCurveZ[], string $paramCurveNAMEZ[],  string $paramANDCurve3[], string  $AllparamlocatorZ[],      string   $set){
	int $i;
int $iX;
$iX = -1;
string $SEspaceLocSet;
	int $numparamANDCurveNAMEZ = size ($paramCurveNAMEZ);
string $MakespaceLocatorSE[],  $MakespaceLocatorEND[], $CurveSelection[],  $MakespaceLocatorSTART[]; 
float $eachCVposSTART[], $eachCVposEnd[];

	for( $i = 0; $i < $numparamANDCurveNAMEZ;  $i ++ ) {

float $arclenghtzIntersectZ = `eval("arclen" + "  " + $paramANDCurveZ[$i])`;
float $arclenghtzALL = `arclen $paramCurveNAMEZ [$i]`;

int $arclenghtzIntTIMES = ($arclenghtzIntersectZ  * 1000) ;
int $arclenghtzTOTALnumTIMEZ = ($arclenghtzALL  *1000) ;
//asume there is only one curve intersect
int $PercentA;
$PercentA = ((float($arclenghtzIntTIMES) /  $arclenghtzTOTALnumTIMEZ) * (100) );

if (( $PercentA > 85 ) || ( $PercentA < 15 )){
int $numCVs = `getAttr -size ($paramCurveNAMEZ [$i] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($paramCurveNAMEZ[$i] +  ".cv[0]") ;			
$CurveSelection[1] = ($paramCurveNAMEZ[$i] +  ".cv[" + $numCVrealNum + "]") ;

if ( $PercentA > 85 ) { 
// move to curve end
$MakespaceLocatorEND = `spaceLocator -p 0 0 0 -n  SEspaceLocatorEND3DZ`;		
	$eachCVposEND = `pointPosition -w  ($CurveSelection[1])`;
move  -ws $eachCVposEND[0] $eachCVposEND[1]  $eachCVposEND[2] $MakespaceLocatorEND[0];
appendStringArray($MakespaceLocatorSE,  $MakespaceLocatorEND, 1);
}

if ( $PercentA < 15 ) { 
$MakespaceLocatorSTART = `spaceLocator -p 0 0 0  -n SEspaceLocatorSTART3DZ`;	
	$eachCVposSTART = `pointPosition -w  ($CurveSelection[0])`;
move  -ws $eachCVposSTART[0] $eachCVposSTART[1]  $eachCVposSTART[2] $MakespaceLocatorSTART;
appendStringArray($MakespaceLocatorSE,  $MakespaceLocatorSTART, 1);

		}
	}

if (( $PercentA < 85 ) && ( $PercentA > 15 )){
$iX = $iX +1;
select -cl;
print $AllparamlocatorZ[$i];
print ("_____not near ends_____" + "\n");
string $setName = ("SEisnotLocSESet"+$iX);
$SEspaceLocSet = `sets -name $setName`;
sets -include $SEspaceLocSet $paramANDCurve3[$i];
sets -include $SEspaceLocSet $AllparamlocatorZ [$i];
sets -include $set $SEspaceLocSet;
}
}
return $MakespaceLocatorSE;
}


proc float GET_AREA_OF_CURVE (string $obj[]){

float $area = 0;
float $centroid[] = `xform -q -ws -t ($obj[0])`;
string $CurveItemA = $obj[0];
string $numcvnames[] = `ls -fl ($CurveItemA+".cv [*]")`; 
int $numcvs = size($numcvnames);

for ($iC=0;$iC<$numcvs;$iC++){
  if ($iC<($numcvs-1)){
     string $cvname0 = $obj[0] + ".cv[" + $iC +  "]";
     string $getpos0 = "pointPosition " +  $cvname0;
     float $pos0[] = `eval $getpos0`;
     string $cvname1 = $obj[0] + ".cv[" + ($iC+1)  + "]";
     string $getpos1 = "pointPosition " +  $cvname1;
     float $pos1[] = `eval $getpos1`;
 $pos0 = `MakeCleanFloats($pos0)`;
 $pos1 = `MakeCleanFloats($pos1)`;

     float $aP = `distanceBetween {$centroid [0],$centroid[1],$centroid[2]} {$pos0[0],$pos0 [1],$pos0[2]}`;
     float $bP = `distanceBetween {$pos0 [0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1 [2]}`;
     float $cP = `distanceBetween {$pos1 [0],$pos1[1],$pos1[2]} {$centroid[0],$centroid [1],$centroid[2]}`;
     float $triarea = 0.25* sqrt ( ($aP+$bP+$cP)  * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP)  );
	 clear $pos0;
	 clear $pos1;
     $area = $area + $triarea;


   } else{
     string $cvname0 = $obj[0] + ".cv[" + $iC +  "]";
     string $getpos0 = "pointPosition " +  $cvname0;
     float $pos0[] = `eval $getpos0`;
     string $cvname1 = $obj[0] + ".cv[" + ($iC+1)  + "]";
     string $getpos1 = "pointPosition " +  $cvname1;
     float $pos1[] = `eval $getpos1`;
 $pos0 = `MakeCleanFloats($pos0)`;
 $pos1 = `MakeCleanFloats($pos1)`;
     float $aP = `distanceBetween {$centroid [0],$centroid[1],$centroid[2]} {$pos0[0],$pos0 [1],$pos0[2]}`;
     float $bP = `distanceBetween {$pos0 [0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1 [2]}`;
     float $cP = `distanceBetween {$pos1 [0],$pos1[1],$pos1[2]} {$centroid[0],$centroid [1],$centroid[2]}`;
     float $triarea = 0.25* sqrt ( ($aP+$bP+$cP)  * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP)  );
	 clear $pos0;
	 clear $pos1;
     $area = $area + $triarea;
     }
  }
clear $numcvnames;
return $area;
}


proc string[]  Make_Middle_of_Curve_ParamlocatorZ002(string  $objectCurveSelected[]){
float $arclenghtzALL = `arclen  $objectCurveSelected`;
float $arclenghtzDivide = $arclenghtzALL / 2.0;
float $arclenghtzDivideROUNDED =  `RoundfloatingPointoff($arclenghtzDivide)`;  
int $numCVs = `getAttr -size  ($objectCurveSelected[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($objectCurveSelected[0] +  ".cv[0]") ;			
$CurveSelection[1] = ($objectCurveSelected[0] +  ".cv[" + $numCVrealNum + "]") ;
int $numCVrealNumDivide = $numCVrealNum / 2; 
if ($numCVrealNumDivide > 2){ $numCVrealNumDivide  = $numCVrealNumDivide -1; } 
float $arclenghtzHalf = `arclen  ($objectCurveSelected[0] + ".u[0.0:" +  $numCVrealNumDivide + "]")`;
float $arclenghtzHalfROUNDED =  `RoundfloatingPointoff($arclenghtzHalf)`; 
float $iz = 0.0; int $M;
 if ( $arclenghtzDivideROUNDED >  $arclenghtzHalfROUNDED){
print "Greater_then"; $M = 0;  $iz = 0.01;}
 if ( $arclenghtzDivideROUNDED <  $arclenghtzHalfROUNDED){
print "Less_then"; $M = 1; $iz = -0.01;}
$paramlocatorZARC[0] = eval("paramLocator " +   $objectCurveSelected[0] + ".u[" +  $numCVrealNumDivide + "]");
float $iX = float($numCVrealNumDivide); 
int $i = 1;
while ($i > 0){
$iX = $iX + $iz;
setAttr ( $paramlocatorZARC[0] +  ".localPositionX") $iX;
string $paramANDCurve[] = `paramToCurvePts(  $paramlocatorZARC )`;
float $arclenghtzparamZ = `eval("arclen" + " " +  $paramANDCurve[0])`;
float $arclenghtzparamZROUNDED =  `RoundfloatingPointoff($arclenghtzparamZ)`;
if($M == 0){
if (($arclenghtzparamZROUNDED ==  $arclenghtzDivideROUNDED) ||  ($arclenghtzparamZROUNDED >  $arclenghtzDivideROUNDED)){
$i = 0; }
}
if($M == 1){
if (($arclenghtzparamZROUNDED ==  $arclenghtzDivideROUNDED) ||  ($arclenghtzparamZROUNDED <  $arclenghtzDivideROUNDED)){
$i = 0; }
}
}
float $posA[];
float $posB[];
float $posC[];
$posA = `pointPosition -w $CurveSelection[0]`;
$posB = `pointPosition -w $paramlocatorZARC[0]`;
$posC = `pointPosition -w $CurveSelection[1]`;
string $CircularArcFromCurve[];
$CircularArcFromCurve[0] = `createNode  makeThreePointCircularArc`;
setAttr ($CircularArcFromCurve[0] + ".pt1")  $posA[0] $posA[1] $posA[2] ;
setAttr ($CircularArcFromCurve[0] + ".pt2")  $posB[0] $posB[1] $posB[2];
setAttr ($CircularArcFromCurve[0] + ".pt3")  $posC[0] $posC[1] $posC[2];
setAttr ($CircularArcFromCurve[0] + ".d") 3;
setAttr ($CircularArcFromCurve[0] + ".s") 8;
string $ArcCurve[];
$ArcCurve[0] = `createNode nurbsCurve` ; 
connectAttr ($CircularArcFromCurve[0] + ".oc")  ($ArcCurve[0] +".cr");
//delete $objectCurveSelected; 
string $ParentArc[];
$ParentArc = `listRelatives -parent $ArcCurve`;
ResetTranslation($ParentArc);

string $ArcZ[];
$ArcZ[0] = `rename $ParentArc  $objectCurveSelected`; 
delete $paramlocatorZARC;
select -r $ArcZ;
return $ArcZ; 

}

proc ResetTranslationEach(string $oneItemz[]){
for ($each in $oneItemz){
xform -cp $each;
	vector $worldPos = `xform -q -ws -rp  $each`;
			move -rpr 0 0 0 $each;
			makeIdentity -apply true  -t 1 -r 0 -s 0 $each;
			xform -t ($worldPos.x)  ($worldPos.y) ($worldPos.z) $each;
}
}
///////////////////////////////////////////////// //////////////////////////////////////////

///////////////////////////////////////////////// //////////////////////////////////////////

proc string[] CompareCurveIntersect (string  $objectLoc[]){
string $objectLocZ[];
string $CurveintersectZ;
string $ItemLists[];
$objectLocZ = $objectLoc;
int $X = size($objectLocZ) -1;
int $Z = size($objectLocZ);
int $i = 1;
int $n = -1;
int $n2 = 0;
for( $i = 0; $i < $X; $i ++ ) {
$n = $n + 1;
$Z = $Z - 1;
$ix = 0;
$n2 = $n + 1;
while ($Z > $ix++){	
$CurveintersectZ = `curveIntersect -ch 0 - tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2] `;
if (size($CurveintersectZ) > 0) {	
ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
} else { print "no Intersect"; }
$n2++;
}
}
return $ItemLists;
}

///////////////////////////////////////////////// //////////////////////////////////////////

///////////////////////////////////////////////// //////////////////////////////////////////
proc float RoundfloatingPointoff(float  $floatingPointNumZ){
int $roundoff = $floatingPointNumZ *100;
float $roundoff2 = float($roundoff) * 0.01;
return $roundoff2;
}

///////////////////////////////////////////////// //////////////////////////////////////////

///////////////////////////////////////////////// //////////////////////////////////////////
proc float[]  Make_Middle_of_Curve_ParamlocatorFloat(string  $objectCurveSelected[]){
float $arclenghtzALL = `arclen  $objectCurveSelected`;
float $arclenghtzDivide = $arclenghtzALL / 2.0;
float $arclenghtzDivideROUNDED =  `RoundfloatingPointoff($arclenghtzDivide)`;   
$paramlocatorZARC[0] = eval("paramLocator " +   $objectCurveSelected[0] + ".u[" + 0.00 + "]");
float $iX = 0.00; 
int $i = 1;
string $posALL[];
float $posB[];
while ($i > 0){
$iX = $iX + 0.01;
setAttr ( $paramlocatorZARC[0] +  ".localPositionX") $iX;
string $paramANDCurve[] = `paramToCurvePts(  $paramlocatorZARC )`;
float $arclenghtzparamZ = `eval("arclen" + " " +  $paramANDCurve[0])`;
float $arclenghtzparamZROUNDED =  `RoundfloatingPointoff($arclenghtzparamZ)`;
if (($arclenghtzparamZROUNDED ==  $arclenghtzDivideROUNDED) ||  ($arclenghtzparamZROUNDED >  $arclenghtzDivideROUNDED)){
$i = 0;
}
}
	$posB = `pointPosition -w  $paramlocatorZARC[0]`;
delete $paramlocatorZARC;
return $posB ; 
}

///////////////////////////////////////////////// //////////////////
proc float[] MidPoint(float $loc1[],  float $loc2[]) {
	float $a = ($loc2[0] + $loc1[0]) * (0.5);
	float $b = ($loc2[1] + $loc1[1]) * (0.5);
	float $c = ($loc2[2] + $loc1[2]) * (0.5);

	float $vPoint[] = {$a , $b , $c};
	return $vPoint;
	}

///////////////////////////////////////////////// //////////////////

///////////////////////////////////////////////// //////////////////
proc float[] MidPointBetween(float $loc1[],  float $loc2[]) {
	float $a = ($loc2[0] + $loc1[0]) * (0.5);
	float $b = ($loc2[1] + $loc1[1]) * (0.5);
	float $c = ($loc2[2] + $loc1[2]) * (0.5);

	float $MidPoint[] = {$a , $b , $c};
	return $MidPoint;
	}

///////////////////////////////////////////////// //////////////////

proc float distanceBetween(float $loc1[], float  $loc2[]) {
	float $a = `pow ($loc2[0] - $loc1[0]) 2`;
	float $b = `pow ($loc2[1] - $loc1[1]) 2`;
	float $c = `pow ($loc2[2] - $loc1[2]) 2`;
	float $distance = `sqrt ( $a+$b+$c )`;
	return $distance;
	}
///////////////////////////////////////////////// ///////
///////////////////////////////////////////////// ///////
// string $objectA[0] = `ls -sl`;
// MirrorANDrename($objectA);
///////////////////////////////////////////////// ///////


///////////////////////////////////////////////// //////////////////////////////////////////


proc MirrorANDrename(string $objectA[]){

ResetTranslation($objectA);
	float $posA[];	
	$posA = `xform -q -os -translation   $objectA[0]`;
xform -ws -pivots 0 $posA[1] $posA[2];
duplicate -rr -renameChildren $objectA; scale -r  -1 1 1; 
string $objectDup[] = `ls -sl`;
int $ifCurvetype = `ISobjectSelectedTypeCurve`;

string $firstcurveRelativesA1[] = `listRelatives  -shapes $objectDup`;

int $numa  = `match "[0-9]+" $objectA[0]`;
string $nameAZ;
$nameAZ = `match "[a-zA-Z]+" $objectA[0]`;

string $renamez = ("A" + $nameAZ + $numa + "A");
string $renameShape = ("A" + $nameAZ + "Shape" +  $numa + "A");
string $renameitzA[];
select -r $objectDup[0];
$renameitzA[0] = `rename $objectDup[0] $renamez`;
 makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;
ResetTranslation($renameitzA);

if ($ifCurvetype == 1){
string $ArcLOCZ[];
string $selectedCurve[];
clear $selectedCurve;
$selectedCurve = $objectA;
string $firstcurveRelatives1[];
$firstcurveRelatives1 = `listRelatives -shapes   $selectedCurve`;
string $firstcurveConnectionsz2[];
$firstcurveConnectionsz2 = ` listHistory -future   false -pruneDagObjects true   $firstcurveRelatives1`;
int $sizeOfConnections = `size ($firstcurveConnectionsz2)`;
if ($sizeOfConnections > 0){
string $ArcCURVEnode =   "makeThreePointCircularArc*";
int $IFArcCurveIStrue = stringArrayGmatch  ($ArcCURVEnode, $firstcurveConnectionsz2);

if ($IFArcCurveIStrue == 0){

string $renameitzA[];
string $renameitzB[];
//$renameitzA[0] = `rename $objectDup[0]  $renamez`;
$renameitzB[0] = `rename $firstcurveRelativesA1 [0] $renameShape`;

 makeIdentity -apply true -t 1 -r 1 -s 1 -n 0  $renameitzA;
ResetTranslation($renameitzA);

}else if ($IFArcCurveIStrue == 1){ 
	string $ArcCURVEnodeZ[];
	string $firstcurveRelatives3[];
	$ArcCURVEnodeZ =   stringArrayGmatchToArray($ArcCURVEnode,   $firstcurveConnectionsz2);
	$firstcurveRelatives3 = `listHistory -  future 0 -pruneDagObjects 0 $ArcCURVEnodeZ`;
	string $ArcCURVEnodeLOC = "ArcLocator*";

int $IFArcLOCIStrue = stringArrayGmatch  ($ArcCURVEnodeLOC, $firstcurveRelatives3);

if ($IFArcLOCIStrue == 1){ 
	$ArcLOCZ = stringArrayGmatchToArray  ($ArcCURVEnodeLOC, $firstcurveRelatives3);
float $getXLoc = `getAttr ($ArcLOCZ[0]   +".translateX")`;
float $MirrorXLoc = $getXLoc * -1; 

string $objectDupLocs[] = `duplicate -rr   $ArcLOCZ[0]`; 
select -r $objectDupLocs;
group -w; 
xform -os -piv 0 0 0;

scale -r -1 1 1;
//string $objectLOCDup[] = `listRelatives   $objectDup`; 
select -r $objectDupLocs;
 //capture trans, rot, and scale of object to   match
        $outmmesh = ($ArcLOCZ[0] + ".translate"); 
        $inmmesh = ($objectDupLocs[0] +   ".translate");
{
$connect = `connectAttr -f $outmmesh $inmmesh`;
}
select -r $ArcLOCZ;
string $objectDupLocs2[] = `duplicate -rr   $ArcLOCZ[0]`; 
setAttr ($objectDupLocs2[0] +".translateX")   $MirrorXLoc;
parentConstraint -mo -weight 1 $objectDupLocs[0]   $objectDupLocs2[0];
select -r $objectDupLocs2;
Make_Middle_of_Curve_ParamlocatorZMirror  ($renameitzA, $objectDupLocs2);
select -r $objectA ;
}
}
}
}

}

///////////////////////////////////////////////// //



proc int MatchIsTrue (string $item, string $list[]){
	int $result = false;	
	string $listItem;
       string $ItemA;
int $XiN = 0;
string $MatchedItem[];	
	for ($Eachlist in $list) {
	$ItemA = `match "$item" $Eachlist`;
		if ( `gmatch $ItemA $Eachlist` ==  1){
		$result = true;
if ($result == true ){ $XiN = 1; $MatchedItem =  {$Eachlist};}
			break;	}
	}

	
	return $XiN;
}


///////////////////////////////////////////////// //
proc int FindIfCurveCrossesZ(string $rebuildit[]){
int $ZeroOneORTwo;


string $CurveSelection[]; 
int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;	 		
$CurveSelection[1] = ($rebuildit[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];
	$EACHCVposAZ = `pointPosition -w (  $CurveSelection[0]  )`;		
	$EACHCVposBZ = `pointPosition -w (  $CurveSelection[1]  )`;
string $POSA = $EACHCVposAZ[0];
string $nameA;
$nameA = `match "-" $POSA`;
int $zeroOR1Z = `gmatch "-" $nameA`;
string $POSB = $EACHCVposBZ[0];
string $nameB;
$nameB = `match "-" $POSB`;
int $zeroOR2Z = `gmatch "-" $nameB`;
int $ZeroOneORTwo = $zeroOR1Z + $zeroOR2Z;
string $POSAe = `abs $EACHCVposAZ[0]`;
string $POSBe = `abs $EACHCVposBZ[0]`;
string $nameAe;
$nameAe = `match "e" $POSAe`;
string $nameBe;
$nameBe = `match "e" $POSBe`;
int $zeroOR1Ze = `gmatch "e" $nameAe`;
int $zeroOR2Ze = `gmatch "e" $nameBe`;
if (($zeroOR1Ze == 1 ) || ($zeroOR2Ze == 1 )){
print "is Zero";
$ZeroOneORTwo = 0;
print $ZeroOneORTwo;
}
return $ZeroOneORTwo;
}

///////////////////////////////////////////////// //

///////////////////////////////////////////////// //

proc int GetDistance(string $objectFirst, string  $objectSecond){
float $pointAZ1[]; float $pointAZ2[];
	$pointAZ1 = `xform -query -worldSpace - translation ($objectFirst)`;
	$pointAZ2 = `xform -query -worldSpace - translation ($objectSecond)`;
$dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy =  $pointAZ1[1] - $pointAZ2[1];
$dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2; 
$distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy *  $dAy) + ($dAz * $dAz) )`;
int $distanceA2roundoff;  
int $distanceA2roundoff = $distanceA2; 
return $distanceA2roundoff; 
}

///////////////////////////////////////////////// //

///////////////////////////////////////////////// //
proc string[] CutCurveIFConditionTRUETransitZ (string $rebuildit[]){
int $XiScaleTimes;
int $XiScale;
string $remainingCurve[];
int $ZeroOneORTwoZ = FindIfCurveCrossesZ ($rebuildit);
 if ($ZeroOneORTwoZ == 1){ 
float $CURVEAposA[];
	$CURVEAposA = `xform -query -worldSpace  -translation $rebuildit[0]`;
float $CURVEA_AREA = `GET_AREA_OF_CURVE ($rebuildit)`;
string $ZcutingplaneZZ[];
$ZcutingplaneZZ = `nurbsPlane -ch on -o on -po 0  -ax 0 1 0 -w 1 -lr 1 -n "ZcutingplaneZZ"`;
setAttr "ZcutingplaneZZ.rotateZ" 90;
$XiScale = GetDistance($rebuildit[0],  $ZcutingplaneZZ[0]);
$XiScaleTimes = ($XiScale * 3) + $CURVEA_AREA;
scale -r $XiScaleTimes $XiScaleTimes  $XiScaleTimes $ZcutingplaneZZ;
string $curveIntersectZ[];
string $intersectZZCUT[];
	string $iSurfZ[] = `extrude -ch 1 -et 0  -l 0.5 -n AxisSelectionZ ( $rebuildit )`;
$intersectZZCUT = `intersect -ch 0 -cos 0 -fs 1  -tol 0.001 -name IntersectSURFACZ $iSurfZ[0]  $ZcutingplaneZZ[0]`;
select -r $intersectZZCUT;
$curveIntersectZ[0] = `curveIntersect -ch 0 - tolerance 0.00001 $intersectZZCUT $rebuildit[0]`;
string $buffer[];
int $numTokensZa;
string $paramlocatorZ[];
$numTokensZa = `tokenize $curveIntersectZ[0] " "  $buffer`;
$paramlocatorZ[0] = `eval("paramLocator " +   $rebuildit[0] + ".u[" + $buffer[1] + "]")`;
int $X = 0;
string $paramANDCurve[];
$paramANDCurve  = `paramToCurvePts2(  $paramlocatorZ)`;
string $curvesZ[];
$curvesZ = `detachCurve -ch 1 -cos on -rpo 1  $paramANDCurve`;
string $curveZ0[];
$curveZ0[0] = $curvesZ[0];
string $curveZ1[];
$curveZ1[0] = $curvesZ[1];
ResetTranslation($curveZ0);
ResetTranslation($curveZ1);
float $EACHCVposAZ[];
float $EACHCVposBZ[];
	$EACHCVposAZ = `xform -query -worldSpace  -translation ( $curvesZ[0]  )`;		
	$EACHCVposBZ = `xform -query -worldSpace  -translation ( $curvesZ[1]  )`;
string $POSA = $EACHCVposAZ[0];
string $nameA;
$nameA = `match "-" $POSA`;
int $zeroOR1Z = `gmatch "-" $nameA`;
string $POSB = $EACHCVposBZ[0];
string $nameB;
$nameB = `match "-" $POSB`;
int $zeroOR2Z = `gmatch "-" $nameB`;
if ($zeroOR1Z == 1){
delete $curvesZ[0];
$X = 1; }
if ($zeroOR2Z == 1){
delete $curvesZ[1]; 
$X = 2;}
if ($X == 2){
select -r $curvesZ[0]; }
if ($X == 1){
select -r $curvesZ[1]; }
$remainingCurve = `ls -sl`;
delete $intersectZZCUT $ZcutingplaneZZ  AxisSelectionZ ; 
}
$rebuildit = $remainingCurve;
return $remainingCurve;
}
///////////////////////////////////////////////// //

///////////////////////////////////////////////// //
proc int FindIfCurveISonZ(string $rebuildit[]){
string $CurveSelection[];
int $iZ = 0; 
int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;	 		
$CurveSelection[1] = ($rebuildit[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];
	$EACHCVposAZ = `pointPosition -w (  $CurveSelection[0]  )`;		
	$EACHCVposBZ = `pointPosition -w (  $CurveSelection[1]  )`;
string $POSA = $EACHCVposAZ[0];
string $ScientNotationNameA;
$ScientNotationNameA = `match "e" $POSA`;
int $zeroOR1Z = `gmatch "e"  $ScientNotationNameA`;
if (($EACHCVposAZ[0] == 0) || ($zeroOR1Z == 1)){
print "yes";
$iZ = $iZ + 1;
}
string $POSB = $EACHCVposBZ[0];
string $ScientNotationNameB;
$ScientNotationNameB = `match "e" $POSB`;
int $zeroOR2Z = `gmatch "e"  $ScientNotationNameB`;
if (($EACHCVposBZ[0] == 0) || ($zeroOR2Z == 1)){
print "yes";
$iZ = $iZ + 1;
}
return $iZ;
}

///////////////////////////////////////////////// //
///////////////////////////////////////////////// //

proc PAUSE(){
playButtonStepForward;
}

///////////////////////////////////////////////// //
///////////////////////////////////////////////// //

proc averagingNode(string $firstObjectz, string  $averageObjectz, string $LastObjectz){
string $averaging[];
$averaging[0] = `shadingNode -asUtility  plusMinusAverage`;
setAttr ($averaging[0] + ".operation") 3;   
connectAttr -force ( $firstObjectz +  ".translate")($averaging[0] + ".input3D[1]"); 
connectAttr -force ($averaging[0] + ".output3D") ("|" + $averageObjectz + ".translate");                                         
connectAttr -force ( $LastObjectz +  ".translate")($averaging[0] + ".input3D[0]"); 
}
///////////////////////////////////////////////// ///////

///////////////////////////////////////////////// ///////

proc int ArrayInsertAtEnd( string $INarray[],  string $NewItem){ 
int $SizeOfArray;
$SizeOfArray = size($INarray);
$INarray[$SizeOfArray] = ( $NewItem );
return $SizeOfArray;
}
///////////////////////////////////////////////// ///////
proc ResetTranslation(string $oneItemz[]){
xform -cp $oneItemz[0];
	vector $worldPos = `xform -q -ws -rp  $oneItemz[0]`;
			move -rpr 0 0 0  $oneItemz[0];
			makeIdentity -apply true  -t 1 -r 0 -s 0 $oneItemz[0];
			xform -t ($worldPos.x)  ($worldPos.y) ($worldPos.z) $oneItemz[0];
}
///////////////////////////////////////////////// ///////

///////////////////////////////////////////////// ///////

proc float[] positionOne(string $eachZA){       	
 float $eachCVpos[] = `pointPosition -w $eachZA`;
return $eachCVpos;
}
///////////////////////////////////////////////// ///////

////if ( eval("gmatch $list $item") == 1){
//print "yes"; }
// BELOW PROC Gmatches a list of items in an  array to one "thing" like a shortname 
//ALL THE CHARAs in one sting and RETURNS - a  Zero or one

///////////////////////////////////////////////// ///////

proc int stringArrayGmatch(string $item, string  $list[]){
	int $result = false;	
	string $listItem;	
	for ($listItem in $list) {
		if ( `gmatch $listItem $item` ==  1){
		$result = true;
			break;	}
	}	
	return $result;
}
///////////////////////////////////////////////// ///////





proc int FindclosetTOcurveENDz(float $a1[], float  $a2[], float $b1[]){
int $binaryAnswer;
float $distance1;
float $distance2;
float $pointA1[];
float $pointA2[];
float $pointB1[];
float $dAx;
float $dAy;
float $dAz;
$pointA1 = $a1;
$pointA2 = $b1;
$dAx = $pointA1[0] - $pointA2[0];
$dAy = $pointA1[1] - $pointA2[1];
$dAz = $pointA1[2] - $pointA2[2];
$distanceA = `sqrt( ($dAx * $dAx) + ($dAy * $dAy)  + ($dAz * $dAz) )`;
$distance1 = $distanceA;
$pointB1 = $a2;
$dAx = $pointB1[0] - $pointA2[0];
$dAy = $pointB1[1] - $pointA2[1];
$dAz = $pointB1[2] - $pointA2[2];
$distanceB = `sqrt( ($dAx * $dAx) + ($dAy * $dAy)  + ($dAz * $dAz) )`;
$distance2 = $distanceB;
if ($distance1 < $distance2){ 
$binaryAnswer = 0;
return $binaryAnswer; 
}
if ( $distance2 < $distance1 ){
$binaryAnswer = 1;
return $binaryAnswer;
}

}

///////////////////////////////////////////////// ///////
///////////////////////////////////////////////// ///////

proc string[] NearestObjectArray(int $n, string  $ItemsSelectedinArray[]){
int $NearestObjectN = $n;
string $NearestCurvesZ[];
$numIntx = size($NearestCurvesZ);
if ( $numIntx > 0 ){
clear $NearestCurvesZ;
}
string $array1[] = $ItemsSelectedinArray;
string $array2[] = $ItemsSelectedinArray;
string $arrayMainObject1[] =  $ItemsSelectedinArray;
string $ArrayTwoObjectX[0];
int $indexN = 0;
int $NearestObjectNumbers = $NearestObjectN;
$ObjN = -1;
$ObjN2 = 0;
while($ObjN++ < $NearestObjectNumbers ){
string $array1Count = size ($array1) -1;
int $array1Number = $array1Count;
stringArrayRemoveAtIndex($array1Count, $array1);
string $diff[] = stringArrayRemoveExact($array1,  $arrayMainObject1);
string $CompareAllShapesCount = size ($array1);
int $curvenumbers = $CompareAllShapesCount;
$i = 1;
while($i++ < $curvenumbers ){
//DISTANCE A
float $pointA1[];
float $pointA2[];
	$pointA1 = `xform -query -worldSpace - translation ( $diff)`;
	$pointA2 = `xform -query -worldSpace - translation ($array1[0])`;
$dAx = $pointA1[0] - $pointA2[0];
$dAy = $pointA1[1] - $pointA2[1];
$dAz = $pointA1[2] - $pointA2[2];
float $distanceA;
$distanceA = `sqrt( ($dAx * $dAx) + ($dAy * $dAy)  + ($dAz * $dAz) )`;
//DISTANCE B
float $pointB1[];
float $pointB2[];
	$pointB1 = `xform -query -worldSpace - translation ( $diff)`;
	$pointB2 = `xform -query -worldSpace - translation ( $array1[1])`;
$dBx = $pointB1[0] - $pointB2[0];
$dBy = $pointB1[1] - $pointB2[1];
$dBz = $pointB1[2] - $pointB2[2];
float $distanceB;
$distanceB = `sqrt( ($dBx * $dBx) + ($dBy * $dBy)  + ($dBz * $dBz) )`;
if( $distanceA < $distanceB ){
stringArrayRemoveAtIndex(1, $array1);
}
if( $distanceA > $distanceB ){
stringArrayRemoveAtIndex(0, $array1);
}
}
appendStringArray($NearestCurvesZ, $array1, 1);
string $oneitem[];
$oneitem[0] = $array1[0];
string $arrayLast[] = stringArrayRemoveExact ($oneitem, $arrayMainObject1);
$array1 = $arrayLast;
$array2 = $arrayLast;
$arrayMainObject1 = $arrayLast;
$indexN++;
stringArrayInsertAtIndex(($indexN),  $ArrayTwoObjectX, $arrayLast[0]);
}
string $array1[]; 
clear $array1;
string $array2[];
clear $array2;
string $arrayMainObject1[];
clear $arrayMainObject1;
string $return[];
$return = $NearestCurvesZ;
return $return; 
}
///////////////////////////////////////////////// ///////


proc string[] CreateCAMforIntCurveScript(){

CreateCameraOnly;
rename ZCURVEModelingCAM;
lookThroughModelPanelClipped ZCURVEModelingCAM  modelPanel4 0.001 1000;
nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr  1 -n "LiveSurfaceB";
editDisplayLayerMembers -noRecurse  layerYZYXPlains "LiveSurfaceB";


//////////////////
string $CamConeLocator[];
clear $CamConeLocator;
curve -d 3 -p 0 0 0 -p 0 0 -4 -p 0 0 -8 -p 0 0 - 12 -k 0 -k 0 -k 0 -k 12 -k 12 -k 12 -n  Deletethiscurve ;
extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
$objectZcurv = `ls -sl`;
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($objectZcurv[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($objectZcurv[0] + ".cv[0]")  ;			
$CurveSelection[1] = ($objectZcurv[0] + ".cv[" +  $numCVrealNum + "]") ;
	string $each;
for ($each in $CurveSelection) {
        float $eachCVpos[]; $eachCVpos =  `pointPosition -w ( $each  )`;
string $MakespaceLocator[]; $MakespaceLocator =  `spaceLocator -p 0 0 0 -n LocatorA`;
ArrayInsertAtEnd($CamConeLocator,  $MakespaceLocator[0]);
move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakespaceLocator[0];
}
string $objectZ[]; clear $objectZ; string  $MakespaceLocator[]; clear $MakespaceLocator ;  
int $LocatorLoop = 0; int $LocatorLoopA = -1;
while ($LocatorLoop++ < 7) {
$LocatorLoopA = $LocatorLoopA +1; 
if ($LocatorLoopA == 0){
clear $objectZ; 
stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
stringArrayInsertAtIndex(1, $objectZ,  "LocatorA1");
}
if ($LocatorLoopA > 0){
clear $objectZ; 
stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
stringArrayInsertAtIndex(1, $objectZ,  $MakespaceLocator[0]);
}
if ($LocatorLoopA < 7){
$MakespaceLocator = `spaceLocator -p 0 0 0 -n  LocatorMiddleDistance`;
ArrayInsertAtEnd($CamConeLocator,  $MakespaceLocator[0]);
averagingNode($objectZ[0], $MakespaceLocator[0],  $objectZ[1]);
}
}
ArrayInsertAtEnd( $CamConeLocator,  $CamConeLocator[0]);
stringArrayRemoveAtIndex(0, $CamConeLocator);
parentConstraint -mo -weight 1 ZCURVEModelingCAM  LocatorA1 ;
parentConstraint -mo -weight 1 ZCURVEModelingCAM  LocatorA;
delete  Deletethiscurve;
align -atl -x Mid -y Mid -z Mid LiveSurfaceB  ZCURVEModelingCAM;

move -r -os -wd 0 5 5 ZCURVEModelingCAM ;
setAttr "ZCURVEModelingCAM.rotateX" -45;
setAttr "LiveSurfaceB.rotateX" (`getAttr  ("ZCURVEModelingCAM" + ".rotateX")`+90);
setAttr "LiveSurfaceB.rotateY" `getAttr  ("ZCURVEModelingCAM" + ".rotateY")`;
setAttr "LiveSurfaceB.rotateZ" `getAttr  ("ZCURVEModelingCAM" + ".rotateZ")`;
align -atl -x Mid -y Mid -z Mid LiveSurfaceB  ZCURVEModelingCAM;
move -r -os -wd 0 -0.7 0 LiveSurfaceB ;
move -r -os -wd 0 0 0.210031 LiveSurfaceB ;

parentConstraint -mo -weight 1 ZCURVEModelingCAM  LiveSurfaceB;
setAttr "ZCURVEModelingCAM.translateX" 48 ;
setAttr "ZCURVEModelingCAM.translateY" 41 ;
setAttr "ZCURVEModelingCAM.translateZ" 48 ;
setAttr "ZCURVEModelingCAM.rotateX" -25 ;
setAttr "ZCURVEModelingCAM.rotateY" 45;
setAttr "ZCURVEModelingCAM.rotateZ" 0;
return $CamConeLocator;
}
///////////////////////////////////////////////// ///////

///////////////////////////////////////////////// ///////


proc Removefromsurface(){

string $curves[] = `ls -sl`;
string $buffer[];
$numTokensz = `tokenize $curves[0] "->" $buffer`;
print $buffer; 
string $myCurve =  $buffer[1];
string $CapsNewCurve = capitalizeString ($myCurve);

rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.001 $buffer[1];

if (size($buffer) < 2 ){ $myCurve =  $curves[0];}
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
print  ($numEPs + "\n"); 
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 1.5); 

string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`; 
$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
	float $step = $numEPrealNum2;  
	$curve = "curve -d 1";
int $a;
  for($a = 0; $a <= $step;$a++){
  	$t =  $a/$step; 	
	setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
  
  	float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;	
if (($values[0] == 0.0 ) && ($values[1] == 0.0 )  && ($values[2] == 0.0 )){
  	float $values[] = `pointPosition -w  $CurveSelection[$numEPrealNum]`;
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
} else { $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];}
}
string $Newcurvez = `eval($curve)`;
string $Newcurve[] = {$Newcurvez};
delete $curves;
delete $paramlocatorpointOnCurvex $spaceLocatorB; 
string $renamedX = `rename $Newcurve  $CapsNewCurve`;  
$Newcurve = {$renamedX};
rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.001 $Newcurve;
select -r $Newcurve; 
}






////////////////////

	proc string[] StartofCurveScriptIntersectZX(){

	Removefromsurface;
	
string $digitalSkeleton[];
$numInts = size($digitalSkeleton);
if ( $numInts > 0 ){
clear $digitalSkeleton;
}
string $objectcurv[];
$objectcurv = `ls -sl`;
///////////////GATHER ALL BUILDING  STRUCTURE/////////##
appendStringArray($digitalSkeleton, $objectcurv,  1);
///////////////////////////////////////////////// ////##
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($objectcurv[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($objectcurv[0] + ".cv[0]")  ;			
$CurveSelection[1] = ($objectcurv[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposA[];
float $EACHCVposB[];	
string $AllIntersectCurveZ[];
$numInts = size($AllIntersectCurveZ);
if ( $numInts > 0 ){
clear $AllIntersectCurveZ;
}
string $IntersectCurves[];
string $MakeExtrudeSurface[];
string $MakeBirailSurface[];
string $MakeXBetween[];
string $MakeIntersectCurvez[];
string $MakespaceLocator[];
	string $each;
for ($each in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $each   )`;
$MakespaceLocator = `spaceLocator -p 0 0 0 -n  IntersectZLocaterZ3D`;
$MakeIntersectCurvez[0] = `curve -d 1 -p 0 0 0 -p  12 0 0 -k 0 -k 1 -n IntersectCurve` ;
appendStringArray($AllIntersectCurveZ,  $MakeIntersectCurvez, 1);
appendStringArray($digitalSkeleton,  $MakespaceLocator, 1);
$numInts = size($AllIntersectCurveZ);
extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakespaceLocator[0];
move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakeIntersectCurvez[0];
aimConstraint -offset 0 0 0 -weight 0.5 - aimVector -1 0 0 -upVector 0 0 -1 -worldUpType  "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM      $MakeIntersectCurvez[0];
if ( $numInts == 1 ){
$EACHCVposA = $eachCVpos;
}
if ( $numInts == 2 ){
$EACHCVposB = $eachCVpos;
$MakeXBetween[0] = `curve -d 1 -p $EACHCVposA[0]  $EACHCVposA[1] $EACHCVposA[2] -p $EACHCVposB[0]  $EACHCVposB[1] $EACHCVposB[2] -k 0 -k 2 -n      XCurveBetween`;
appendStringArray($digitalSkeleton,  $MakeXBetween, 1);
}
}
$MakeExtrudeSurface = `extrude -ch true -rn 0 -po  0 -et 0 -upn 0 -fixedPath 1 -d 0 0 0 -length 3 - rotation 0 -scale 1 -dl 3 -n CURVEZextrude      $objectcurv` ;
$MakeBirailSurface = `singleProfileBirailSurface  -ch 1 -po 0 -tm 1 -tp1 0 -n SurfaceinterectCurves  CURVEZextrude.v[0] $AllIntersectCurveZ[0]      $AllIntersectCurveZ[1]`;
string $curveFromSurfaceDup[] = `duplicateCurve  -ch 1 -rn 0 -local 0  "SurfaceinterectCurves.u [1]"` ;
string $curveFromSurfaceLoft[] = `loft -ch 1 -u 1  -c 0 -ar 1 -d 3 -ss 4 -rn 1 -po 0 -rsn true -n  IntersectLoftZ $curveFromSurfaceDup[0]      $objectcurv` ;
// GATHER ALL BUILDING STRUCTURE//
appendStringArray($digitalSkeleton,  $curveFromSurfaceDup, 1);
appendStringArray($digitalSkeleton,  $curveFromSurfaceLoft, 1);
appendStringArray($digitalSkeleton,  $MakeExtrudeSurface, 1);
appendStringArray($digitalSkeleton,  $MakeBirailSurface, 1);
appendStringArray($digitalSkeleton,  $AllIntersectCurveZ, 2);

return $digitalSkeleton; 
}


proc int ArrayInsertAtEnd( string $INarray[],  string $NewItem){ 
int $SizeOfArray;
$SizeOfArray = size($INarray);
$INarray[$SizeOfArray] = ( $NewItem );
return $SizeOfArray;
}
/////////////////////////////////
proc int SecondArrayInsertAtEndofArray( string  $INarray[], string $NewItem[]){ 
int $SizeOfArray;
$SizeOfArray = size($INarray);
$INarray[$SizeOfArray] = ( $NewItem[0] );
return $SizeOfArray;
}

proc string[] RemoveNoLongerExistingFromArray (string $EdgeCurveZ1[]){
int $SizeOfArrayA = size($EdgeCurveZ1);
if ( $SizeOfArrayA > 0){
int $SizeOfArray = size($EdgeCurveZ1) -1;
int $i = -1;
int $E = -1;
while( $E < $SizeOfArray ){
$i++;
$E++;

if ( `objExists $EdgeCurveZ1[$i]` == 0  ) {
 stringArrayRemoveAtIndex($i, $EdgeCurveZ1);
if ($i == 0) { $i = -1;} else { $i = $i -1;}   
}

}
print $EdgeCurveZ1;
int $SizeOfArrayB = size($EdgeCurveZ1);
}
return $EdgeCurveZ1;
}

	proc appendMultiStringArray( string  $copyTo[], string $copyFrom1[], string  $copyFrom2[]){

$numberToCopy1 = size($copyFrom1);
if( $numberToCopy1 > 0){
	int $i;
	int $j = size($copyTo);
	for( $i = 0; $i < $numberToCopy1; $i++,  $j++ ){
		$copyTo[$j] = $copyFrom1[$i]; }
}
$numberToCopy2 = size($copyFrom2);
if( $numberToCopy2 > 0){
	int $k = size($copyTo);
	for( $i = 0; $i < $numberToCopy2; $i++,  $k++ ){
		$copyTo[$k] = $copyFrom2[$i]; }
}
}

////////////////////////////////////

proc MoveZSURFACEModelingCAM(string  $ConeLocator[]){

string $queryIntersectFormLayerA[] =  `editDisplayLayerMembers -q  IntersectFormLayerOutofRange`;
string $queryIntersectFormLayerB[] =   `editDisplayLayerMembers -q  IntersectFormLayerINRange`  ;

string $queryIntersectFormLayerC[];
clear $queryIntersectFormLayerC; 
appendMultiStringArray(  $queryIntersectFormLayerC,  $queryIntersectFormLayerA,  $queryIntersectFormLayerB );
print $queryIntersectFormLayerC;

if (size( $queryIntersectFormLayerC) > 0){

string $listofallSurfaces[];
$listofallSurfaces = $queryIntersectFormLayerC;


string $ObjectsINcamLightCone[];
string $OutofRange[];
layerEditorRemoveObjects  IntersectFormLayerINRange ;
editDisplayLayerMembers -noRecurse "defaultLayer"  $ObjectsINcamLightCone;
layerEditorRemoveObjects  IntersectFormLayerOutofRange ;
editDisplayLayerMembers -noRecurse "defaultLayer"  $OutofRange;
clear $ObjectsINcamLightCone;
string $objectZ[];
if (size($objectZ) > 0){ clear $objectZ; }  
stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
stringArrayInsertAtIndex(1, $objectZ,  "LocatorA1");
float $pointA1[];
float $pointA2[];
	$pointA1 = `xform -query -worldSpace - translation ( $objectZ[0])`;
	$pointA2 = `xform -query -worldSpace - translation ($objectZ[1])`;
$dAx = $pointA1[0] - $pointA2[0];
$dAy = $pointA1[1] - $pointA2[1];
$dAz = $pointA1[2] - $pointA2[2];
float $distanceAz;
$distanceAz = `sqrt( ($dAx * $dAx) + ($dAy *  $dAy) + ($dAz * $dAz) )`;
int $radiusZ;
int $distanceAzNUM;
$distanceAzNUM = $distanceAz;
$radiusZ = $distanceAzNUM /2;
int $loopLocatorsCam = 0;
int $loopA = -1;
int $z = -1;
string $currentLocatorZ[];
while ($loopLocatorsCam++ < 7){
$loopA = $loopA +1;
if ($loopA > 0){
$distanceAzNUM = $radiusZ;
}
$radiusZ = $distanceAzNUM /2;
$z = $z +1;
string $currentLocatorZ[];
$currentLocatorZ[0] = $ConeLocator[$z];
//string all locators in order
for ($each in $listofallSurfaces) {


float $pointAZ1[];
float $pointAZ2[];
	$pointAZ1 = `xform -query -worldSpace - translation ($currentLocatorZ)`;
	$pointAZ2 = `xform -query -worldSpace - translation ($each)`;
$dAx = $pointAZ1[0] - $pointAZ2[0];
$dAy = $pointAZ1[1] - $pointAZ2[1];
$dAz = $pointAZ1[2] - $pointAZ2[2];
float $distanceA2;
$distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy *  $dAy) + ($dAz * $dAz) )`;

if ( $distanceA2 < $radiusZ ){
stringArrayInsertAtIndex(0,  $ObjectsINcamLightCone, $each);
}
}
}
  string $shorterList[] =  stringArrayRemoveDuplicates ($ObjectsINcamLightCone);
$ObjectsINcamLightCone = $shorterList;
  $OutofRange = stringArrayRemoveExact ($ObjectsINcamLightCone, $listofallSurfaces);
editDisplayLayerMembers -noRecurse  IntersectFormLayerOutofRange $OutofRange;
editDisplayLayerMembers -noRecurse  IntersectFormLayerINRange $ObjectsINcamLightCone;
}
}

proc string[] MoveZCURVEModelingCAM(string  $EdgeCurves[], string $ConeLocator[]){

string $listofallcurves[];
$listofallcurves = $EdgeCurves;

string $ObjectsINcamLightCone[];
string $OutofRange[];
layerEditorRemoveObjects layerCurvesINRange1 ;
editDisplayLayerMembers -noRecurse "defaultLayer"  $ObjectsINcamLightCone;
layerEditorRemoveObjects layerCurvesOutofRange1 ;
editDisplayLayerMembers -noRecurse "defaultLayer"  $OutofRange;
clear $ObjectsINcamLightCone;
string $objectZ[];
if (size($objectZ) > 0){ clear $objectZ; }  
stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
stringArrayInsertAtIndex(1, $objectZ,  "LocatorA1");
float $pointA1[];
float $pointA2[];
	$pointA1 = `xform -query -worldSpace - translation ( $objectZ[0])`;
	$pointA2 = `xform -query -worldSpace - translation ($objectZ[1])`;
$dAx = $pointA1[0] - $pointA2[0];
$dAy = $pointA1[1] - $pointA2[1];
$dAz = $pointA1[2] - $pointA2[2];
float $distanceAz;
$distanceAz = `sqrt( ($dAx * $dAx) + ($dAy *  $dAy) + ($dAz * $dAz) )`;
int $radiusZ;
int $distanceAzNUM;
$distanceAzNUM = $distanceAz;
$radiusZ = $distanceAzNUM /2;
int $loopLocatorsCam = 0;
int $loopA = -1;
int $z = -1;
string $currentLocatorZ[];
while ($loopLocatorsCam++ < 7){
$loopA = $loopA +1;
if ($loopA > 0){
$distanceAzNUM = $radiusZ;
}
$radiusZ = $distanceAzNUM /2;
$z = $z +1;
string $currentLocatorZ[];
$currentLocatorZ[0] = $ConeLocator[$z];
//string all locators in order
for ($each in $listofallcurves) {
float $pointAZ1[];
float $pointAZ2[];
	$pointAZ1 = `xform -query -worldSpace - translation ($currentLocatorZ)`;
	$pointAZ2 = `xform -query -worldSpace - translation ($each)`;
$dAx = $pointAZ1[0] - $pointAZ2[0];
$dAy = $pointAZ1[1] - $pointAZ2[1];
$dAz = $pointAZ1[2] - $pointAZ2[2];
float $distanceA2;
$distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy *  $dAy) + ($dAz * $dAz) )`;

if ( $distanceA2 < $radiusZ ){
stringArrayInsertAtIndex(0,  $ObjectsINcamLightCone, $each);
}
}
}
  string $shorterList[] =  stringArrayRemoveDuplicates ($ObjectsINcamLightCone);
$ObjectsINcamLightCone = $shorterList;
  $OutofRange = stringArrayRemoveExact ($ObjectsINcamLightCone, $listofallcurves);
editDisplayLayerMembers -noRecurse  layerCurvesOutofRange1 $OutofRange;
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ObjectsINcamLightCone;
return $ObjectsINcamLightCone;
}


proc LockModelingCAM(){
setAttr -lock true "ZCURVEModelingCAM.tx";
setAttr -lock true "ZCURVEModelingCAM.ty";
setAttr -lock true "ZCURVEModelingCAM.tz";
setAttr -lock true "ZCURVEModelingCAM.rx";
setAttr -lock true "ZCURVEModelingCAM.ry";
setAttr -lock true "ZCURVEModelingCAM.rz";
}

proc UnLockModelingCAM(){
setAttr -lock false "ZCURVEModelingCAM.tx";
setAttr -lock false "ZCURVEModelingCAM.ty";
setAttr -lock false "ZCURVEModelingCAM.tz";
setAttr -lock false "ZCURVEModelingCAM.rx";
setAttr -lock false "ZCURVEModelingCAM.ry";
setAttr -lock false "ZCURVEModelingCAM.rz";
}

proc int stringArrayMatch(string $item, string  $list[]){
	int $result = false;	
	string $listItem;
string $listMatch;	
	for ($listItem in $list) {
$listMatch = `match $item $listItem`;
		if ( size($listMatch) > 0){
		$result = true; break; }
	}	
	return $result;
}
//////////////////////////////////////////

//////////////////////////////////////////
proc int ISobjectSelectedTypeCurve2(){
	int $result = false;	
string $C[];
$C = `ls -sl`;
string $nametypeZ[] = `ls -showType $C`;
string $names1 = "curve";
string $names2 = "Curve";
string $names3 = "cv";
string $names4 = "ep";
int $zeroOR1A = stringArrayMatch($names1,  $nametypeZ);
int $zeroOR1B = stringArrayMatch($names2,  $nametypeZ);
int $zeroOR1C = stringArrayMatch($names3,  $nametypeZ);
int $zeroOR1D = stringArrayMatch($names4,  $nametypeZ);
int $zeroOR1B = stringArrayMatch($names1,  $nametypeZ);
if (( $zeroOR1A == 1) || ( $zeroOR1B == 1)){
if (( $zeroOR1C == 1) || ( $zeroOR1D == 1)){
$result = false;
} else { $result = true; }
}
	return $result;
}
//-conditionTrue
//$scriptt_jobNum = `scriptJob -conditionTrue  ISobjectSelectedTypeCurve2 -compressUndo true - protected`;
//////////////////////////////////////////


proc int ISobjectSelectedTypeCurve(){
string $C[];
$C = `ls -sl`;
string $nametypeZ[] = `ls -showType $C`;
string $nameA;
$nameA = `match "[a-zA-Z]+" $nametypeZ[0]`;
int $zeroOR1Z = `gmatch "Curve" $nameA`;
print $zeroOR1Z;
return $zeroOR1Z;
}



//SWITCH///////////////////////////////////////// //////////////////////
global string $proc =  "StartofCurveScriptIntersectXYZ;";

proc stringsStart(){
string $stringsStart = ("global string $proc = "  +"\"StartofCurveScriptIntersectXYZ;"+"\";");
eval( $stringsStart );
print $stringsStart;
}

///////////////////////////////////////////////// ////////////////
///////////////////////////////////////////////// ////////////////
proc stringsA(){
string $stringsA = ("global string $proc = "  +"\"EvalDrawCurveDisConnectA;"+"\";");
eval( $stringsA );

}

proc stringsB(){
string $stringsB = ("global string $proc = "  +"\"EvalDrawCurveDisConnectB;"+"\";");
eval( $stringsB );
}
proc stringsC(){
string $stringsC = ("global string $proc = "  +"\"RUNprojectTAN;"+"\";");
eval( $stringsC );
}
///////////////////////////////////////////////// ////////////////
///////////////////////////////////////////////// ////////////////
///////////////////////////////////////////////// ////////////////
///////////////////////////////////////////////// ////////////////


///////////////////////////////////////////////// ////////////////
proc EvalStart(){
evalDeferred start; }

proc start(){
stringsStart; }

///////////////////////////////////////////////// ////////////////

proc StartofCurveScriptIntersectXYZ(){
string $deleteLiveCurveShape;
string $deleteLiveCurve;
int $firstcurveswitch;
string $objectcurV[];
clear $objectcurV;
$objectcurV = `ls -sl`;
ResetTranslation($objectcurV);
string $objectSelection[] = { "Zcurvez",  "Xcurvez" };
string $oneSelection[];
clear $oneSelection;
for ($each in $objectSelection) {
int $ISTRUE03B = catchQuiet($intersectCurveZ03 =  `curveIntersect -ch 0 -ud 0 -tol 0.01 $objectcurV  $each`);
int $numIntZ03 = size($intersectCurveZ03);
	if (($ISTRUE03B > 0) || ($numIntZ03 > 0))  {
 stringArrayInsertAtIndex(0, $oneSelection,  $each);
}
}
int $getSize = size ($oneSelection);
	if ( $getSize > 1){
	print "wrong";
//run once scriptjob... JUst run again
$firstcurveswitch = 0;
}
if ( $getSize == 1){
if ( `gmatch $oneSelection[0] "Zcurvez"` == 1){ 
print "Zcurvez";
$firstcurveswitch = 1;
 }
if ( `gmatch $oneSelection[0] "Xcurvez"` == 1){ 
print "Zcurvez";
$firstcurveswitch = 2;
 }
}
switch($firstcurveswitch) {
	case 0:
	print "wrong";
delete $objectcurV;
EvalStart;
break;
	case 1:
select -r Zplane;
rebuildSurface -ch 0 -rpo 1 -rt 6 -end 1 -kr 2 - kcp 0 -kc 1 -su 98 -du 3 -sv 98 -dv 3 -tol 0.001  -fr 0  -dir 2 "Zplane";
select -cl  ;
select -r Zplane;
PAUSE;
select -cl  ;
PAUSE;
select -r Zplane;
PAUSE;
select -cl  ;
rebuildSurface -ch 0 -rpo 1 -rt 6 -end 1 -kr 2 - kcp 0 -kc 1 -su 1 -du 3 -sv 1 -dv 3 -tol 0.001 - fr 0  -dir 2 "Zplane";
makeLive Zplane;
delete $objectcurV;

stringsA;

break;
	case 2:
select -r Xplane;
rebuildSurface -ch 0 -rpo 1 -rt 6 -end 1 -kr 2 - kcp 0 -kc 1 -su 98 -du 3 -sv 98 -dv 3 -tol 0.001  -fr 0  -dir 2 "Xplane";
select -cl  ;
select -r Xplane;
PAUSE;
select -cl  ;
PAUSE;
select -r Xplane;
PAUSE;
select -cl  ;
rebuildSurface -ch 0 -rpo 1 -rt 6 -end 1 -kr 2 - kcp 0 -kc 1 -su 1 -du 3 -sv 1 -dv 3 -tol 0.001 - fr 0  -dir 2 "Xplane";
makeLive Xplane;
delete $objectcurV;
string $deleteLiveCurveShape;
$deleteLiveCurveShape = "XplaneShape- >drawCurveShape";
string $deleteLiveCurve;
$deleteLiveCurve = "XplaneShape->drawCurve";

stringsB;

break;
}
}

////////////////////////

proc DrawCurveDisConnectA(int $xii){
global string $EdgeCurveZ2[];
global int $xii;
int $xi = $xii;
rename drawCurve;
duplicateCurve -ch 1 -rn 0 -local 0 ;
rename drawCurveA;
if ($xi == 0 ){

DeleteHistory ZplaneShape->drawCurveShape;
delete ZplaneShape->drawCurveShape;
delete ZplaneShape->drawCurve;
}
string $Renamed1[];
string $Renamed2[];
$Renamed1[0] = `rename drawCurveA Curve`;
ResetTranslation($Renamed1); 
if ( `gmatch $Renamed1[0] "Curve"` == 1){
$Renamed2[0] = `rename $Renamed1 Curve0`;
$Renamed1 = $Renamed2;
}
ResetTranslation($Renamed1); 
select -r $Renamed1;
string $ParentArc[];
$ParentArc = `Make_Middle_of_Curve_ParamlocatorZ ($Renamed1)`;
delete $Renamed1;
rename $ParentArc $Renamed1;
sets -include ZEdgeCurvesSet $Renamed1;
select -r ZEdgeCurvesSet;
editDisplayLayerMembers -noRecurse  layerAllCurves1 $Renamed1;
evalEdgecurvesZ2;
EvalAddingCurves;
RUNMoveZCURVEM;
eval(" $jobNumtranslateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.translate  RUNMoveZCURVEM`;");
eval(" $jobNumrotateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.rotate  RUNMoveZCURVEM`;");
makeLive LiveSurfaceB ;
stringsC;

}


proc DrawCurveDisConnectB(int $xii){
global string $EdgeCurveZ2[];
global int $xii;
int $xi = $xii;
rename drawCurve;
duplicateCurve -ch 1 -rn 0 -local 0 ;
rename drawCurveA;
if ($xi == 0 ){

DeleteHistory XplaneShape->drawCurveShape;
delete XplaneShape->drawCurveShape;
delete XplaneShape->drawCurve;
}
string $Renamed1[];
string $Renamed2[];
$Renamed1[0] = `rename drawCurveA Curve`; 
ResetTranslation($Renamed1); 
int $trueORfalse = FindIfCurveCrossesZ ($Renamed1);
print $trueORfalse;
if ( $trueORfalse == 1){ 
CutCurveIFConditionTRUETransitZ($Renamed1); }
select -r $Renamed1;
string $rebuildfirstcurve[];
$rebuildfirstcurve = `rebuildCurve -ch 0 -rpo 1  -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 16 -d 3  -tol 0.001 $Renamed1`;
string $ParentArc[];
$ParentArc = `Make_Middle_of_Curve_ParamlocatorZ ($rebuildfirstcurve)`;
print $ParentArc;
delete $Renamed1;
rename $ParentArc Curve;
$ParentArc = {"Curve"};
$Renamed1 = $ParentArc;
if ( $trueORfalse == 1){ 
sets -include ZEdgeCurvesSet $ParentArc;
 }

if ( `gmatch $Renamed1[0] "Curve"` == 1){
$Renamed2[0] = `rename $Renamed1 Curve0`;
$Renamed1 = $Renamed2;
}

MirrorANDrename($Renamed1);
editDisplayLayerMembers -noRecurse  layerAllCurves1 $Renamed1;
select -r $Renamed1;
evalEdgecurvesZ2;
EvalAddingCurves;
RUNMoveZCURVEM;
eval(" $jobNumtranslateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.translate  RUNMoveZCURVEM`;");
eval(" $jobNumrotateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.rotate  RUNMoveZCURVEM`;");
makeLive LiveSurfaceB ;
stringsC;

}

/////////////////////

proc EvalDrawCurveDisConnectA(){
eval("DrawCurveDisConnectA($xii);");
}
proc EvalDrawCurveDisConnectB(){
eval("DrawCurveDisConnectB($xii);");
}

proc int ifCurveToolsCTX1(){
string $whichCtx;
$whichCtx = `currentCtx`;
string $list[] = { "pencilContext"};   
	int $result = false;	
	string $listItem;
string $listMatch;	
	for ($listItem in $list) {
$listMatch = `match $whichCtx $listItem`;
		if ( size($listMatch) > 0){
		$result = true; break; }
	}	
	return $result;
}

///////////////

///////////////

proc int ifCurveToolsCTX2(){
string $whichCtx;
$whichCtx = `currentCtx`;
string $list[] = {"curveContextEP",  "curveAddPtContext"};   
	int $result = false;	
	string $listItem;
string $listMatch;	
	for ($listItem in $list) {
$listMatch = `match $whichCtx $listItem`;
		if ( size($listMatch) > 0){
		$result = true; break; }
	}	
	return $result;
}

//

proc int ifCurveToolsCTX3(){
string $whichCtx;
$whichCtx = `currentCtx`;
string $list[] = {"threePointArcContext"};   
	int $result = false;	
	string $listItem;
string $listMatch;	
	for ($listItem in $list) {
$listMatch = `match $whichCtx $listItem`;
		if ( size($listMatch) > 0){
		$result = true; break; }
	}	
	return $result;
}

///////////////

proc int ifCurveToolsCTX4(){
string $whichCtx;
$whichCtx = `currentCtx`;
string $list[] = {"selectSuperContext",  "moveSuperContext", "lassoSelectContext",  "RotateSuperContext",
 "scaleSuperContext", "xformManipContext",  "softModContext" };   
	int $result = false;	
	string $listItem;
string $listMatch;	
	for ($listItem in $list) {
$listMatch = `match $whichCtx $listItem`;
		if ( size($listMatch) > 0){
		$result = true; break; }
	}	
	return $result;
}
/////////////////////////////////////

proc EvalAutoCurvesScripts(){

int $IsCurveToolSelected1 = `ifCurveToolsCTX1`;
if ($IsCurveToolSelected1 == 1){
eval("$xii = 0;");
eval("EVALKILLjobB ($scriptt_jobAllCurvesToolsNumB);");
EvalAllCurvesTools; }

int $IsCurveToolSelected2 = `ifCurveToolsCTX2`;
if ($IsCurveToolSelected2 == 1){
eval("$xii = 0;");
eval("EVALKILLjobA ($scriptt_jobAllCurvesToolsNumA);");
EvalAllCurvesTools2;
 }

int $IsCurveToolSelected3 = `ifCurveToolsCTX3`;
if ($IsCurveToolSelected3 == 1){
eval("$xii = 1;");
eval("EVALKILLjobA ($scriptt_jobAllCurvesToolsNumA);");
EvalAllCurvesTools2;
 }

int $IsCurveToolSelected4 = `ifCurveToolsCTX4`;
if ($IsCurveToolSelected4 == 1){
setAttr layerYZYXPlains.visibility 0;
string $itemsCurrentlySelectedZ[] = `ls -sl`;
select -cl  ;
makeLive;
select -r $itemsCurrentlySelectedZ; 
 } 

if ($IsCurveToolSelected4 == 0){
string $queryCURVESz[] =  `queryLayerRangeMembers`;
if  (size($queryCURVESz) > 0){
setAttr layerYZYXPlains.visibility 1;
makeLive LiveSurfaceB;
}
 }

}

///////////////

proc AutoCurveScripts(){
int $ifCond_is_True =  `ISobjectSelectedTypeCurve2`;
if ($ifCond_is_True == 1){
//   This is just the curve script you need this  to be where the switch is
eval"evalEcho($proc);";
}
}

proc AutoCurveScripts2(){
EvalKillToolChangedNum1;
 EvalCurveToolChanged2;
evalDeferred("$script_jobToolChangedNum1 =  `scriptJob -event ToolChanged  EvalAutoCurvesScripts`;");
}

proc EvalAllCurvesTools(){
eval("int $scriptt_jobAllCurvesToolsNumA =  `scriptJob -event DagObjectCreated  AutoCurveScripts -compressUndo true -protected  `;");
}
proc EvalAllCurvesTools2(){
eval("int $scriptt_jobAllCurvesToolsNumB =  `scriptJob -event DagObjectCreated  AutoCurveScripts2 -compressUndo true -protected  `;");
}

proc EvalCurveToolChanged2(){
eval("int $script_jobToolChangedNum2 = `scriptJob  -runOnce 1 -event ToolChanged  AutoCurveScripts`;");
}

proc EVALKILLjobA(int  $scriptt_jobAllCurvesToolsNumA ){
if (! $scriptt_jobAllCurvesToolsNumA == 0  ) {
EvalKilljobAllCurvesToolsNumA; }
}

proc EVALKILLjobB(int  $scriptt_jobAllCurvesToolsNumB ){
if (! $scriptt_jobAllCurvesToolsNumB == 0  ) {
EvalKilljobAllCurvesToolsNumB; }
}

proc EvalKilljobAllCurvesToolsNumA(){
eval("scriptJob -kill  $scriptt_jobAllCurvesToolsNumA -force;");
}

proc EvalKilljobAllCurvesToolsNumB(){
eval("scriptJob -kill  $scriptt_jobAllCurvesToolsNumB -force;");
}

proc EvalKillToolChangedNum1(){
eval("scriptJob -kill $script_jobToolChangedNum1  -force;");
}

proc EvalRUNToolChangedNum1(){
eval("int $script_jobToolChangedNum1 = `scriptJob  -event ToolChanged EvalAutoCurvesScripts`;");
}

proc RUNprojectTAN(){
$runitA = "AdvancedCurveMODprojectTAN ($EdgeCurveZ2, $plainNum);";
eval($runitA);
}

proc RUNMoveZCURVEM(){
int $script_jobNumIdle_MoveZCURVEM = `scriptJob   -runOnce 1 -event idle EVALCamScripts`;
}

proc int addNumbers(){
int $CreatedObjectCurve =  `ISobjectSelectedTypeCurve`;
return $CreatedObjectCurve; 
}

proc int addedNumbers(int $addNumbersA){
int $numerOfCreatedCurve = `addNumbers`;
int $numerOfCreated = $numerOfCreatedCurve; 
if ($numerOfCreated == 1){
int $addNumberZ = $addNumbersA +  $numerOfCreatedCurve;
$addNumbersA = $addNumberZ;
print $addNumbersA;
}
return $addNumbersA;
}

proc EvalAddingCurves(){
$runitA = "$addNumbersA = addedNumbers ($addNumbersA);";
eval($runitA);
}

proc EvalcreatSphere(){
$runitA = "creatSphere($addNumbersA);";
eval($runitA);
}

proc evalEdgecurvesZ2(){
eval("$EdgeCurveZ2 = `editDisplayLayerMembers -q  layerAllCurves1`;");
}

proc creatSphere(int $addNumbersA ){
int $x = $addNumbersA;
print ($addNumbersA + "\n");
if ($x == 200){
//LockModelingCAM;
print "FOUR CURVES";
MakeAutoBoundryUI;
}
}

proc makeSurfaceAndclose(string $dialogBoxWin){
eval("deleteUI $dialogBoxWin;");
eval("int  $script_jobNumIdle_KILLtanCurveRUNautoboundry =  `scriptJob  -runOnce 1 -event idle  KILLtanCurveRUNautoboundry`;");
eval("$addNumbersA = 0;");
}

proc SkipAutoBoundry(string $dialogBoxWin){
eval("deleteUI $dialogBoxWin;");
eval("$addNumbersA = 0;");
}

global proc MakeAutoBoundryUI(){

global string $dialogBoxWin;
$dialogBoxWin = `window 
- title "JFS AutoBoundry" 
-resizeToFitChildren true 
-interactivePlacement 
-toolbox true`;

columnLayout -adjustableColumn true;

nodeIconButton -style "iconAndTextHorizontal"
-label "Make Surface From Curve Network"
-width 90
-height 40
-image1 "skin.xpm"
-command "makeSurfaceAndclose($dialogBoxWin)";

string $button2 = `nodeIconButton -style  "textOnly"
-label "Skip"
-width 60
-height 30
-marginWidth 5
 -command "SkipAutoBoundry($dialogBoxWin)"`;
showWindow $dialogBoxWin;
eval("$dialogBoxWin = $dialogBoxWin;");
}


proc KILLtanCurveRUNautoboundry(){
eval("scriptJob -kill $jobNumtranslateCAM - force;");
eval("scriptJob -kill $jobNumrotateCAM -force;");
eval("scriptJob -kill $script_jobToolChangedNum1  -force;");
evalDeferred BOUNDRYeveryNthCurve;
}

proc TRIGGER_RUNjobNumTAN(){
eval("$script_jobToolChangedNum1 = `scriptJob - event ToolChanged EvalAutoCurvesScripts`;");
eval("$jobNumtranslateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.translate  RUNMoveZCURVEM`;");
eval("$jobNumrotateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.rotate  RUNMoveZCURVEM`;");
}

proc EVALCamScripts(){
$runit = "CatchMoveZCURVECAM($EdgeCurveZ2,  $CamConeLocator);";
 eval($runit); }
proc EVALCamScripts2(){
$runit = "MoveZSURFACEModelingCAM ($CamConeLocator);";
 eval($runit); }


proc CatchMoveZCURVECAM(string $EdgeCurveZ2[],  string $CamConeLocator[]){
if ( catchQuiet(MoveZCURVEModelingCAM ($EdgeCurveZ2, $CamConeLocator))) {
RemoveNoLongerExistingFromArray( $EdgeCurveZ2);
MoveZCURVEModelingCAM($EdgeCurveZ2,  $CamConeLocator);
  } else {
      print "move Cam";
  }
}


proc string[] queryLayerRangeMembers(){
string $query[];
string $queryOutofRangeLayer[];
string $queryINRangeLayer[];
 $queryOutofRangeLayer = `editDisplayLayerMembers  -q layerCurvesOutofRange1`;
 $queryINRangeLayer = `editDisplayLayerMembers -q  layerCurvesINRange1`;
if (size($queryOutofRangeLayer) > 0){
  appendStringArray($query,  $queryOutofRangeLayer, size ($queryOutofRangeLayer));
}
if (size($queryINRangeLayer) > 0){
  appendStringArray($query, $queryINRangeLayer,  size($queryINRangeLayer));
}  
return $query;
}


proc BOUNDRYeveryNthCurve(){

string $everyFirstCurveShapeset[];
string $query[];
clear $query;
string $queryOutofRangeLayer[];
string $queryINRangeLayer[];
 $queryOutofRangeLayer = `editDisplayLayerMembers  -q layerCurvesOutofRange1`;
 $queryINRangeLayer = `editDisplayLayerMembers -q  layerCurvesINRange1`;
if (size($queryOutofRangeLayer) > 0){
  appendStringArray($query,  $queryOutofRangeLayer, size ($queryOutofRangeLayer));
}
if (size($queryINRangeLayer) > 0){
  appendStringArray($query, $queryINRangeLayer,  size($queryINRangeLayer));
}  
///////////////////////
$everyFirstCurveShapeset = `ls -assemblies  $query`;
string $newEdgeCurve[];
clear $newEdgeCurve;

select -r $everyFirstCurveShapeset;

$newEdgeCurve = `AutoBoundryScript ($everyFirstCurveShapeset)`;

print $newEdgeCurve; 
layerEditorEmpty layerCurvesINRange1;
layerEditorEmpty layerCurvesOutofRange1;
layerEditorEmpty layerEdgeCurveZ1;
editDisplayLayerMembers -noRecurse  layerEdgeCurveZ1 $newEdgeCurve;
eval("$EdgeCurveZ2 = `editDisplayLayerMembers -q  layerEdgeCurveZ1`;");
UnLockModelingCAM;
evalDeferred TRIGGER_RUNjobNumTAN;
}

proc string[] AutoBoundryScript(string  $everyFirstCurveShapeset[]){
string $EdgeCurveZ[];
string $EdgeCurveZ2[];
clear $EdgeCurveZ2;
string $EdgeCurveZ3[];
string $newallCurves[];
$newallCurves = $everyFirstCurveShapeset;

string $ZnewfoundEdge[];
for ( $Zeachboundry in $newallCurves ) {
string $ZselectedCurve[];
clear $ZselectedCurve;
$ZselectedCurve[0] = $Zeachboundry;
string $ZfirstcurveRelatives[];
$ZfirstcurveRelatives = `listRelatives -shapes  $ZselectedCurve`;
string $ZfirstcurveConnectionsz[];
$ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
string $Zfirstcurveshapes[];
$Zfirstcurveshapes = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;

if (size($Zfirstcurveshapes) == 1){
 appendStringArray($ZnewfoundEdge,  $ZselectedCurve, 1);
}
if (size($Zfirstcurveshapes) == 0){
 appendStringArray($ZnewfoundEdge,  $ZselectedCurve, 1);
}
}
$everyFirstCurveShapeset = $ZnewfoundEdge; 


int $everycurveSize = size ($everyFirstCurveShapeset);
while( size($everyFirstCurveShapeset) > 3 ){ 

int $everycurveSizeIndex = size ($everyFirstCurveShapeset) -1;
string $FirstCurvesZ[];
$FirstCurvesZ[0] = $everyFirstCurveShapeset [$everycurveSizeIndex];

string $firstcurveRelatives[];
$firstcurveRelatives = `listRelatives -shapes  $FirstCurvesZ`;
string $firstcurveConnectionsz[];
$firstcurveConnectionsz = `listConnections  $firstcurveRelatives`;
string $firstcurveshapes[];
$firstcurveshapes = `listConnections -shapes 1  $firstcurveConnectionsz`;
string $firstcurveConn[] = stringArrayRemove ($firstcurveRelatives, $firstcurveshapes);
int $numberofconnections = size($firstcurveConn);

if ( $numberofconnections >= 2 ) {
stringArrayRemoveAtIndex($everycurveSizeIndex,  $everyFirstCurveShapeset);
int $everycurveSizeIndex = size ($everyFirstCurveShapeset) -1;
string $FirstCurvesZ[];
$FirstCurvesZ[0] = $everyFirstCurveShapeset [$everycurveSizeIndex];
}

int $everycurveSize = size ($everyFirstCurveShapeset);
int $divide;
int $switchNumber;
if (( $everycurveSize < 1000 ) && (  $everycurveSize >= 500 )){
$divide = $everycurveSize / 50;
$switchNumber = 0; 
print $divide;}
if (( $everycurveSize < 500 ) && (  $everycurveSize >= 250 )){
$divide = $everycurveSize / 25; 
$switchNumber = 0;}
if (( $everycurveSize < 250 ) && (  $everycurveSize >= 100 )){
$divide = $everycurveSize / 12; }
if (( $everycurveSize < 100 ) && (  $everycurveSize >= 50 )){
$divide = $everycurveSize / 5; 
$switchNumber = 0;}
if (( $everycurveSize < 50 ) && ( $everycurveSize  >= 20 )){
$divide =$everycurveSize / 4; 
$switchNumber = 0;}
if (( $everycurveSize < 20 ) && ( $everycurveSize  > 18 )){
$divide = $everycurveSize / 2;
$switchNumber = 0;
print $divide;
 }
if ( $everycurveSize <= 18 ){
$switchNumber = 1;
 }

int $n;

switch($switchNumber) 

{
	case 0:
	int $n = $divide;
	string $NearestCurvesZ[] =  (NearestObjectArray($n,  $everyFirstCurveShapeset));
	int $n2 = $n * 2;
	string $NearestCurvesZn2[] =  (NearestObjectArray($n2,  $everyFirstCurveShapeset));
break;

	case 1:
	string $NearestCurvesZ[] =  $everyFirstCurveShapeset;
	string $NearestCurvesZn2[] =  $everyFirstCurveShapeset;
break;

}
print $NearestCurvesZ; 
string $TEMPzCurveAAb[];
if ( size($TEMPzCurveAAb) > 0){
clear $TEMPzCurveAAb;
}
int $ISTRUE0A1;
int $numIntZZ;
for ( $eachZ in $NearestCurvesZ ) {

int $ISTRUE0A1 = catchQuiet($intersectCurveZ0 =  `curveIntersect -ch 0 -ud 0 -tol 0.01  $FirstCurvesZ $eachZ`);
int $numIntZZ = size($intersectCurveZ0);
	if (($ISTRUE0A1 > 0) || ($numIntZZ > 0))  {
stringArrayInsertAtIndex(0, $TEMPzCurveAAb,  $eachZ);
}
}
$NearestCurvesZ = $TEMPzCurveAAb;
string $TEMPzCurveA[0];
$numInts2 = size($TEMPzCurveA);
if ( $numInts2 > 0 ){
clear $TEMPzCurveA;
}

string $diff[];
if ( size($diff) > 0){
clear $diff;
}
$diff = stringArrayRemove($NearestCurvesZ,  $NearestCurvesZn2);
int $switchNumberA;
if( size($diff) == 0 ) {
clear $everyFirstCurveShapeset;
clear $NearestCurvesZ; 
$switchNumberA = 0;
} else if( size($diff) > 0 ){
$switchNumberA = 1;
} 

if(( size($NearestCurvesZ) == 3 ) &&  ($everycurveSize == 3)) {
$switchNumberA = 0; }
switch($switchNumberA) 

{
	case 0:
print "done";
break;

case 1:

for ( $eachAB in $diff ) {
int $ISTRUE0B = catchQuiet($intersectCurveZ1 =  `curveIntersect -ch 0 -ud 0 -tol 0.01  $FirstCurvesZ $eachAB`);
int $numIntZZZ = size($intersectCurveZ1);
	if (($ISTRUE0B > 0) || ($numIntZZZ > 0))  {
 stringArrayInsertAtIndex(0, $TEMPzCurveA,  $eachAB);
}
}
string $NearestCurvesZA[];
int $numInts2a;
$numInts2a = size($NearestCurvesZA);
if ( $numInts2a > 0 ){
clear $NearestCurvesZA;
} 
$NearestCurvesZA = stringArrayCatenate ($NearestCurvesZ, $TEMPzCurveA);
$NearestCurvesZ = $NearestCurvesZA;
string $diffremove[];
int $numInts2a;
$numInts2a = size($diffremove);
if ( $numInts2a > 0 ){
clear $diffremove;
} 
$diffremove = stringArrayRemove($TEMPzCurveA,  $diff);
string $TEMPAlldiffCurveZBBBB[];
$numInts = size($TEMPAlldiffCurveZBBBB);
if ( $numInts > 0 ){
clear $TEMPAlldiffCurveZBBBB;
} 
$TEMPAlldiffCurveZBBBB = $diffremove;
///////////////////////////////////////////////// /////

string $diffX[]; clear $diffX; string  $boundaryCurves[]; clear $boundaryCurves; 
int $numIntxZB; string $OtherCurves[]; clear  $OtherCurves; string $oneboundaryCurve[]; clear  $oneboundaryCurve;
string $boundaryCurvesAA[]; string  $oneboundaryCurve[]; clear $oneboundaryCurve;
string $boundaryCurves[]; 
clear $boundaryCurves;
string $boundaryCurves1[]; 
clear $boundaryCurves1;
	int $X = 1;
	int $ENDLOOPA;
	int $i = 1;
	int $ENDLOOP;
	int $B = 0;
	int $ISTRUE0A001;
	int $numIntZZA;
	int $numIntZZAB;
	int $ISTRUE0B002;
	int $endtrigger = 0;

	while (size($NearestCurvesZ) > 0 ){
	 if ( $endtrigger == 2 ){ 
	clear $NearestCurvesZ;
	size($NearestCurvesZ); 
				} 
for ( $each in $NearestCurvesZ ) {
stringArrayInsertAtIndex(0, $boundaryCurves1,  $each);
clear $oneboundaryCurve; 
stringArrayInsertAtIndex(0, $oneboundaryCurve,  $boundaryCurves1[0]);
 $X = 1;
$ENDLOOPA = size($TEMPAlldiffCurveZBBBB);
for ( $eachA in $TEMPAlldiffCurveZBBBB ) {
stringArrayInsertAtIndex(0, $boundaryCurves1,  $each);
clear $oneboundaryCurve; 
stringArrayInsertAtIndex(0, $oneboundaryCurve,  $boundaryCurves1[0]);
int $ISTRUE0A001 = catchQuiet($intersectCurveZ0A  = `curveIntersect -ch 0 -ud 0 -tol 1.0 $each  $eachA`);
$ENDLOOPA = size($TEMPAlldiffCurveZBBBB);
$X++;
int $numIntZZA = size($intersectCurveZ0A);
if ((($ISTRUE0A001 == 0) && ( $X == $ENDLOOPA))  || (($numIntZZA == 0) && ( $X == $ENDLOOPA))) {
string $removecurveAz2[];
$removecurveAz2[0] = $each;
$NearestCurvesZ = stringArrayRemove ($removecurveAz2, $NearestCurvesZ);
} else if (($ISTRUE0A001 > 0) || ($numIntZZA >  0)){
	string $diffX[];
	clear $diffX;
	$diffX = stringArrayRemoveExact ($oneboundaryCurve, $NearestCurvesZ);
$ENDLOOP = size($diffX);
	for ( $eachB in $diffX ) {
 if ( $endtrigger == 2 ){ 
clear $NearestCurvesZ; } 
	int $ISTRUE0B002 = catchQuiet ($intersectCurveZAB = `curveIntersect -ch 0 -ud 0  -tol 0.001 $eachA $eachB`);
int $numIntZZAB = size($intersectCurveZAB);
int $numsizeNearest = size($NearestCurvesZ); 
if (( $endtrigger == 0 ) && ( $numsizeNearest < 2  )){
 string $removeoneFromeveryFirstA[];
$removeoneFromeveryFirstA = stringArrayRemove ($FirstCurvesZ, $everyFirstCurveShapeset);
clear $NearestCurvesZ; }
	if (($ISTRUE0B002 > 0) || ($numIntZZAB >  0)) {
///////
string $Intersectboundarycurves[];
string $myIntersector = `stringArrayIntersector`;
string $Foundboundarycurves[];
clear $Foundboundarycurves;
stringArrayInsertAtIndex(0, $Foundboundarycurves,  $FirstCurvesZ[0]);
stringArrayInsertAtIndex(0, $Foundboundarycurves,  $each);
stringArrayInsertAtIndex(0, $Foundboundarycurves,  $eachA);
stringArrayInsertAtIndex(0, $Foundboundarycurves,  $eachB);
for ( $eachboundry in $Foundboundarycurves ) {

string $selectedCurve[];
clear $selectedCurve;
$selectedCurve[0] = $eachboundry;
string $firstcurveRelatives[];
$firstcurveRelatives = `listRelatives -shapes  $selectedCurve`;
string $firstcurveConnectionsz[];
$firstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true $firstcurveRelatives`;
string $firstcurveshapes[];
$firstcurveshapes = `listConnections -shapes 1 - type nurbsSurface $firstcurveConnectionsz`;
stringArrayIntersector -edit -allowDuplicates  false -intersect $firstcurveshapes  $myIntersector;
}
$Intersectboundarycurves =  `stringArrayIntersector -query $myIntersector`;

stringArrayIntersector -edit -reset  $myIntersector;
if (size($Intersectboundarycurves) == 0){
///////	
	boundary -ch 1 -or 0 -ep 1 -rn 1 -po 0 - ept 0.1 $FirstCurvesZ $each $eachA $eachB;
	string $objectA[] =`ls -sl`;
MirrorANDrename($objectA);
editDisplayLayerMembers -noRecurse  IntersectFormLayerINRange $objectA;


}
$endtrigger = $endtrigger +1;
if ( $endtrigger == 1 || $endtrigger == 2 ) {
stringArrayInsertAtIndex(0, $boundaryCurves,  $each);
stringArrayInsertAtIndex(0, $boundaryCurves,  $eachB);
stringArrayInsertAtIndex(0, $boundaryCurves,  $eachA);
}
if ( $endtrigger < 2 ){
string $removecurveAz[]; string $removecurveBz[];  string $removecurveCz[]; 
	$removecurveAz[0] = $each;	
	$removecurveBz[0] = $eachB;
	$removecurveCz[0] = $eachA;
string $NearestCurvesZ[] = stringArrayRemove ($removecurveAz, $NearestCurvesZ);
string $NearestCurvesZ[] = stringArrayRemove ($removecurveBz, $NearestCurvesZ);
string $TEMPAlldiffCurveZBBBB[] =  stringArrayRemove($removecurveCz,  $TEMPAlldiffCurveZBBBB); }
else if ( $endtrigger == 2 ){ 
clear $NearestCurvesZ; }
  
		     } 
	}
//end of if
}
//end of For
}
}
}

int $boundaryCurvessize = size($boundaryCurves); 
if( $boundaryCurvessize > 0 ) {

for ( $eachboundry in $boundaryCurves ) {
string $selectedCurve[];
clear $selectedCurve;
$selectedCurve[0] = $eachboundry;
string $firstcurveRelatives[];
$firstcurveRelatives = `listRelatives -shapes  $selectedCurve`;
string $firstcurveConnectionsz[];
$firstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true $firstcurveRelatives`;
string $firstcurveshapes[];
$firstcurveshapes = `listConnections -shapes 1 - type nurbsSurface $firstcurveConnectionsz`;
int $numberofconnections = size ($firstcurveshapes);
if ( $numberofconnections == 2 ) {
string $firstcurveConn[] = stringArrayRemove ($selectedCurve, $everyFirstCurveShapeset);
$everyFirstCurveShapeset = $firstcurveConn;
}
}

}
string $removeoneFromeveryFirst[];
$removeoneFromeveryFirst = stringArrayRemove ($FirstCurvesZ, $everyFirstCurveShapeset);
$everyFirstCurveShapeset =  $removeoneFromeveryFirst;
clear $FirstCurvesZ; 
break;
}

}
return $newallCurves;
}

/////////////////////////////////////

/////////////////////////////////////

proc string[]  Make_Middle_of_Curve_ParamlocatorZMirror(string  $objectCurveSelected[], string $MakeArcLocatorZ []){

float $arclenghtzALL = `arclen  $objectCurveSelected`;
float $arclenghtzDivide = $arclenghtzALL / 2.0;
int $numCVs = `getAttr -size  ($objectCurveSelected[0] + ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($objectCurveSelected[0] +  ".cv[0]") ;			
$CurveSelection[1] = ($objectCurveSelected[0] +  ".cv[" + $numCVrealNum + "]") ;
string $paramlocatorZARC[];
$paramlocatorZARC[0] = eval("paramLocator " +   $objectCurveSelected[0] + ".u[" + 0.0 + "]");

float $step = 10; 
int $a = 1;
  	float $t =  $a/$step;

setAttr ( $paramlocatorZARC[0] +  ".localPositionX") $t;
string $paramANDCurve[] = `paramToCurvePts(  $paramlocatorZARC )`;
float $arclenghtzparamZ = `eval("arclen" + " " +  $paramANDCurve[0])`;

float $divZZ = $arclenghtzDivide /  $arclenghtzparamZ ;
float $divZZ2 = $t * $divZZ ;
setAttr ( $paramlocatorZARC[0] +  ".localPositionX") $divZZ2;
////////////////////// Moved ParamLoc to middle

float $posA[];
float $posB[];
float $posC[];
$posA = `pointPosition -w $CurveSelection[0]`;
$posB = `pointPosition -w $paramlocatorZARC[0]`;
$posC = `pointPosition -w $CurveSelection[1]`;
string $CircularArcFromCurve[];
$CircularArcFromCurve[0] = `createNode  makeThreePointCircularArc`;
setAttr ($CircularArcFromCurve[0] + ".pt1")  $posA[0] $posA[1] $posA[2] ;
setAttr ($CircularArcFromCurve[0] + ".pt2")  $posB[0] $posB[1] $posB[2];
setAttr ($CircularArcFromCurve[0] + ".pt3")  $posC[0] $posC[1] $posC[2];
setAttr ($CircularArcFromCurve[0] + ".d") 3;
setAttr ($CircularArcFromCurve[0] + ".s") 8;
string $ArcCurve[];
$ArcCurve[0] = `createNode nurbsCurve` ; 
connectAttr ($CircularArcFromCurve[0] + ".oc")  ($ArcCurve[0] +".cr");
//delete $objectCurveSelected; 
string $ParentArc[];
$ParentArc = `listRelatives -parent $ArcCurve`;
ResetTranslation($ParentArc);
$ConnectLocToPoint2 = `connectAttr -f  ($MakeArcLocatorZ[0] + ".translate") (  $CircularArcFromCurve[0] + ".pt2")`;
string $ArcZ[];
$ArcZ[0] = `rename $ParentArc  $objectCurveSelected`; 
delete $paramlocatorZARC;
delete $objectCurveSelected;

return $ArcZ; 

}

global proc int stringArrayGmatch(string $item,  string $list[]){
	int $result = false;	
	string $listItem;
	
	for ($listItem in $list) {
		if ( `gmatch $listItem $item` ==  1){
		$result = true;
			break;	}
	}	
	return $result;
}
///////////////////////

//returns the first single Item array if string  matches that item  
//EX. string "red"  match array { "bluered",  "blueblue", "greenblue" } returns "bluered" as a  string array[].

//string $testGmatch = "red";  string  $matcharrayTest[] = { "red", "blueblue",  "greenblue" };
//string $matchedinArray[] =  stringArrayGmatchToArray($testGmatch,  $matcharrayTest);
// Result: red // 

global proc string[] stringArrayGmatchToArray (string $item, string $list[]){
	int $result = false;	
	string $listItem;
string $MatchedItem[];	
	for ($listItem in $list) {
		if ( `gmatch $listItem $item` ==  1){
		$result = true;
if ($result == true ){ $MatchedItem =  {$listItem};}
			break;	}
	}	
	return $MatchedItem;
}




/////////////////////

proc string[] StraitCurvesSCRIPTZ() {
//StraitCurves SCRIPT 5000

string $ObjectCurve[];
string $StraitCurve[];
$ObjectCurve = `ls -selection`;
xform -cp;
resetPivot;
duplicatePreset (1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1);
string $ObjectCurveduplicate[];

$ObjectCurveduplicate = `ls -selection`;
setAttr ($ObjectCurveduplicate[0] + ".translate")  0 0 0;
setAttr ($ObjectCurveduplicate[0] + ".rotate") 0  0 0;
playButtonStepForward; select -cl  ;

float $rotationz[];
$rotationz = `xform -q -rotation $ObjectCurve`;
float $translationz[];
$translationz = `xform -q -translation  $ObjectCurve`;

float $bbox[] = `exactWorldBoundingBox  $ObjectCurveduplicate`;
print("Bounding box ranges from: " +
      $bbox[0] + "," + $bbox[1] + "," + $bbox[2]  + ", to " +
      $bbox[3] + "," + $bbox[4] + "," + $bbox[5]  + ".\n");

spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
move -ws $bbox[0] $bbox[1] $bbox[2]  BoxspaceLocatorA;
spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
move -ws $bbox[3] $bbox[4] $bbox[5]  BoxspaceLocatorB;
spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
move -ws $bbox[3] $bbox[1] $bbox[2]  BoxspaceLocatorC;
spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;

// xform -query -worldSpace -translation;


float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox [2]};
float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox [5]};
float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox [2]};
float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox [5]};

$BoxPointA = `MakeCleanFloats($BoxPointA)`;
$BoxPointB = `MakeCleanFloats($BoxPointB)`;
$BoxPointC = `MakeCleanFloats($BoxPointC)`;
$BoxPointD = `MakeCleanFloats($BoxPointD)`;

float $BoxMPointAC[] = MidPointBetween ($BoxPointA, $BoxPointC);
float $BoxMPointBD[] = MidPointBetween ($BoxPointB, $BoxPointD);
float $BoxMPointAD[] = MidPointBetween ($BoxPointA, $BoxPointD);
float $BoxMPointBC[] = MidPointBetween ($BoxPointB, $BoxPointC);
//   MoveObjectSelection($BoxMPointAC);

///////////////////////////////
///////////////////////////////

float $CrossMPointAB[] = MidPointBetween ($BoxPointA, $BoxPointB);
// BoxspaceLocatorMiddle CHANGES need here in the  future
float $translationzMiddle[];
$translationzMiddle = $CrossMPointAB;

float $CurveCVzero[] = GetCurveCVposENDS ($ObjectCurveduplicate, 0);
float $CurveCVLast[] = GetCurveCVposENDS ($ObjectCurveduplicate, 1);

int $pA1 = PointsEquivalentTol ($CurveCVzero,$BoxPointA); 
int $pA2 = PointsEquivalentTol ($CurveCVLast,$BoxPointA);
int $pC1 = PointsEquivalentTol ($CurveCVzero,$BoxPointC); 
int $pC2 = PointsEquivalentTol ($CurveCVLast,$BoxPointC); 

int $AorC = 0;
if (($pA1 == 3) || ($pA2 == 3)){
$AorC = 1;
}
if (($pC1 == 3) || ($pC2 == 3)){
$AorC = 2;
}  
float $distanceA = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointC);
float $distanceB = PointsGetDistanceFLOAT ($BoxPointB, $BoxPointC);
float $distanceAverage =  (($distanceA +  $distanceB) * (0.5)) ;
float $radiusX = ( $distanceAverage / 2.0);

float $squarePercentA;
float $squarePercentB;
if ( $distanceA > $distanceAverage) {
$squarePercentA = (( $distanceAverage /  $distanceA ) * (100));
}
if ( $distanceA < $distanceAverage) {
$squarePercentA = (( $distanceA /  $distanceAverage ) * (100));
}
if ( $distanceB > $distanceAverage) {
$squarePercentB = (( $distanceAverage /  $distanceB ) * (100));
}
if ( $distanceB < $distanceAverage) {
$squarePercentB = (( $distanceB /  $distanceAverage ) * (100));
}
/////////////////////


int $squareA = 0;
int $squareB = 0;
if ( $squarePercentA > 55){
$squareA = 1; 
}
if ( $squarePercentB > 55){
$squareB =  1; 
}

string $StraitCurve[];
$addSquareResults = ($squareA + $squareB);
if ( $addSquareResults == 2 ){

//Eval Diaginal curve
// USE $radiusX for curve points

if ( $AorC == 1){
$StraitCurve[0] = `curve -d 1 -p $BoxPointA[0]  $BoxPointA[1] $BoxPointA[2] -p $BoxPointB[0]  $BoxPointB[1] $BoxPointB[2]`;
}
if ( $AorC == 2){
$StraitCurve[0] = `curve -d 1 -p $BoxPointC[0]  $BoxPointC[1] $BoxPointC[2] -p $BoxPointD[0]  $BoxPointD[1] $BoxPointD[2]`;
}

} else { 

// Not Diagonal curves

int $XZ = 0;
if ( $distanceA > $distanceB) {
$XZ = 1;
}
if ( $distanceA < $distanceB) {
$XZ = 2;
}
if ($XZ == 1){
//$BoxMPointAD  $BoxMPointBC
$StraitCurve[0] = `curve -d 1 -p $BoxMPointAD[0]  $BoxMPointAD[1] $BoxMPointAD[2] -p $BoxMPointBC [0] $BoxMPointBC[1] $BoxMPointBC[2]`;
}
if ($XZ == 2){
//$BoxMPointAC $BoxMPointBD
$StraitCurve[0] = `curve -d 1 -p $BoxMPointAC[0]  $BoxMPointAC[1] $BoxMPointAC[2] -p $BoxMPointBD [0] $BoxMPointBD[1] $BoxMPointBD[2]`;
}
}
setAttr ($StraitCurve[0] + ".rotateX")  $rotationz[0];
setAttr ($StraitCurve[0] + ".rotateY")  $rotationz[1];
setAttr ($StraitCurve[0] + ".rotateZ")  $rotationz[2];
setAttr ($StraitCurve[0] + ".translateX")  $translationz[0];
setAttr ($StraitCurve[0] + ".translateY")  $translationz[1];
setAttr ($StraitCurve[0] + ".translateZ")  $translationz[2];

select -r $ObjectCurve $ObjectCurveduplicate  BoxspaceLocatorA BoxspaceLocatorB  BoxspaceLocatorC BoxspaceLocatorD  BoxspaceLocatorMiddle;
delete;
select -r $StraitCurve;
return $StraitCurve;

}

/////////////////////


//////////////////////////


/////////////////////////

proc StartupItems(){

optionVar -fv "totalAnimateRollTime" 0.9;
select -r  Text_byxDrawingxaxLinexOverxOnexofxThexCurves_1;
allViewFit(0);
allViewFit(1);
select -cl  ;
goToView -1;
pause -sec 2;
optionVar -fv "totalAnimateRollTime" 2.5;
goToView -1;
optionVar -fv "totalAnimateRollTime" 0.4;
setAttr "ZCURVEModelingCAM.centerOfInterest"  72.916917;
eval("int $script_jobToolChangedNum1 = `scriptJob  -event ToolChanged EvalAutoCurvesScripts`;");
PencilCurveTool;
curveSketchCtx -e -d 3 `currentCtx`;
setAttr layerYZYXPlains.visibility 1;

}

proc StartupItemsPart2(){
setAttr "ZCURVEModelingCAM.centerOfInterest"  72.916917;
eval("int $script_jobToolChangedNum1 = `scriptJob  -event ToolChanged EvalAutoCurvesScripts`;");
PencilCurveTool;
curveSketchCtx -e -d 3 `currentCtx`;
setAttr layerYZYXPlains.visibility 1;
}

proc StartupItemsPart3(){
setAttr "ZCURVEModelingCAM.centerOfInterest"  72.916917;
//eval("int $script_jobToolChangedNum1 = `scriptJob  -event ToolChanged EvalAutoCurvesScripts`;");
PencilCurveTool;
curveSketchCtx -e -d 3 `currentCtx`;
setAttr layerYZYXPlains.visibility 1;
}

///////////////////////////////////////////////// ///////////////
proc ResetTransEachSL(){
string $oneItemz[] = `ls -sl`;
for ($each in $oneItemz){
xform -cp $each;
	vector $worldPos = `xform -q -ws -rp  $each`;
			move -rpr 0 0 0 $each;
			makeIdentity -apply true  -t 1 -r 0 -s 0 $each;
			xform -t ($worldPos.x)  ($worldPos.y) ($worldPos.z) $each;
}
}
//ResetTransEachSL;

proc FlattenCurveOnMesh( string $curve[], string  $Mesh[]){

string $PolygonShapeZ1[0] = {$Mesh[0]};
string $CurveZOne[0] = {$curve[0]};
string $CurveSelection[] = `ls -fl ($CurveZOne[0]  +".ep[0:*]")`; 

    string $PolyX = $PolygonShapeZ1[0];
      $myCPOM = `createNode closestPointOnMesh`;
      connectAttr ($PolyX+".worldMesh")  ($myCPOM+".inMesh");
      $LocatorResultA = `spaceLocator -p 0 0 0 -n  LocA`;
      $LocA = $LocatorResultA[0];
      connectAttr ($myCPOM+".position")  ($LocA+".translate");
      $LocatorResultB = `spaceLocator -p 0 0 0 -n  LocB`;
      $LocB = $LocatorResultB[0];
      connectAttr ($LocB+".translate")  ($myCPOM+".inPosition");

  for ($Eachep in $CurveSelection ) {
	float $pointPos[];
	$pointPos = `pointPosition -w ($Eachep)`;
 move -ws $pointPos[0] $pointPos[1] $pointPos[2]  $LocB;
float $valuesB[] = `getAttr  ($myCPOM+".position")`;
 move -ws $valuesB[0] $valuesB[1] $valuesB[2]  $Eachep;
}

delete  $myCPOM $LocA $LocB;
$Newcurvez = $CurveZOne;
}
//////////////////////////////////////////////

proc int NumberOFSurf(string $Zeachboundry){
int $XnumOFcurveConnections;
string $ZfirstcurveRelatives[];
$ZfirstcurveRelatives = `listRelatives -shapes $Zeachboundry`;
string $ZfirstcurveConnectionsz[];
$ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
int $historyShapes = `size($ZfirstcurveConnectionsz)`;
if ($historyShapes > 0){
string $Zfirstcurveshapes[];
$ZfirstcurveshapesA = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;
$ZfirstcurveshapesB = `listConnections -shapes 1  -type mesh $ZfirstcurveConnectionsz`;
$XnumOFcurveConnections = (`size($ZfirstcurveshapesA)`) + (`size($ZfirstcurveshapesB)`) ;
}else{ $XnumOFcurveConnections = 0;}

return $XnumOFcurveConnections;
}

//////////////////////////////////////////////


proc string[] ForAllCurvesFindSurfaceEdges(string $newallCurves[]){
string $ZnewfoundEdge[];
for ( $Zeachboundry in $newallCurves ) {
string $ZselectedCurve[];
$ZselectedCurve[0] = $Zeachboundry;
int $Zfirstcurveshapesi = `NumberOFSurf($Zeachboundry)`;
if ($Zfirstcurveshapesi == 1){
 appendStringArray($ZnewfoundEdge, $ZselectedCurve, 1);
}
if ($Zfirstcurveshapesi == 0){
 appendStringArray($ZnewfoundEdge,  $ZselectedCurve, 1);
}
}
return $ZnewfoundEdge;
}

proc FindNumOfConnectionsToCurveRemove(string $boundaryCurves[], int $XiC, string $everyFirstCurveShapeset[]){
for ( $eachboundry in $boundaryCurves ) {
string $selectedCurve[];
int $numberofconnections = NumberOFSurf($eachboundry);
if ( $numberofconnections == $XiC ) {
string $firstcurveConn[] = stringArrayRemove ($selectedCurve, $everyFirstCurveShapeset);
$everyFirstCurveShapeset = $firstcurveConn;
}
}
}



proc vector[] GetVectorArrayBetweenCurveEnds(string $CurveItem[]){
string $CurveSelection[];
int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 		
$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[]; float $EACHCVposBZ[]; int $numIntZB = 0; string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];	 $eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){$EACHCVposAZ = $eachCVpos;}
if ( $numIntZB == 2 ){$EACHCVposBZ = $eachCVpos;}
}
vector $CurveA = << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
vector $CurveB = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;	
vector $CurveAB[]; $CurveAB[0] = $CurveA; $CurveAB[1] = $CurveB;
return $CurveAB; 
}



proc int  PointsEquivalentTol( float $posA[],  float $posB[]){
int $pX = equivalentTol($posA[0], $posB[0],  0.01);
int $pY = equivalentTol($posA[1], $posB[1],  0.01);
int $pZ = equivalentTol($posA[2], $posB[2],  0.01);
int $addedResults = $pX + $pY + $pZ;
if ($addedResults == 3 ){ print "Points  equivalent"; 
}
return $addedResults;
}


proc int FindifCurveEndsMeet(vector $CurveA1[], vector $CurveA2[]){
int $CurveMeetsTrue = 0;
int $indexN = 0;
int $indexN2 = 0;
while ($indexN < 2){
float $firstC[];
$firstC = $CurveA1[$indexN];
float $SecondCA[];
$SecondC = $CurveA2[0];
float $SecondCA[];
$SecondCA = $CurveA2[1];
int $NumberE = PointsEquivalentTol( $firstC, $SecondC);
int $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);
if (($NumberE == 3)||($NumberE2 == 3)){$CurveMeetsTrue = $CurveMeetsTrue +1; }
if ($indexN==1){$indexN1 = 1;}
$indexN++;
}
return $CurveMeetsTrue;
}


	proc int ValueOfCurveSurfInterConnections(string $Zeachboundry[]){

int $NumberofConnectionZ = 0;
string $myIntersector = `stringArrayIntersector`;
for ( $eachboundry in $Zeachboundry ) {
string $ZfirstcurveRelatives[];
$ZfirstcurveRelatives = `listRelatives -shapes $eachboundry`;
string $ZfirstcurveConnectionsz[];
$ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
int $historyShapes = `size($ZfirstcurveConnectionsz)`;

			if ($historyShapes > 0){
string $Zfirstcurveshapes[];
$ZfirstcurveshapesA = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;
$ZfirstcurveshapesB = `listConnections -shapes 1  -type mesh $ZfirstcurveConnectionsz`;
int $CA = `size($ZfirstcurveshapesA)`;
int $CB = `size($ZfirstcurveshapesB)`;

if (($CA > 0) || ($CB > 0)){
if ($CA > 0){
$NumberofConnectionZ++;
stringArrayIntersector -edit -allowDuplicates  false -intersect $ZfirstcurveshapesA $myIntersector;
		}
if ($CB > 0){
$NumberofConnectionZ++;
stringArrayIntersector -edit -allowDuplicates  false -intersect $ZfirstcurveshapesB $myIntersector;
		}
}else{ //no shapes connections of anytype Exist ZERO
$NumberofConnectionZ = 0;
				}
			}
		}
string $Intersectboundarycurves[];
$Intersectboundarycurves =  `stringArrayIntersector -query $myIntersector`;
stringArrayIntersector -edit -reset  $myIntersector;
int $XnumOFcurveConnections = `size($Intersectboundarycurves)`;
return $XnumOFcurveConnections;
}


proc int IfCurvesTouch(string $curveA, string $curveB){
string $Acurve[];
$Acurve = {$curveA};
string $Bcurve[];
$Bcurve = {$curveB};
vector $CurveOne[] = GetVectorArrayBetweenCurveEnds($Acurve);
vector $CurveTwo[] = GetVectorArrayBetweenCurveEnds($Bcurve);
int $intIfTrue = FindifCurveEndsMeet($CurveOne, $CurveTwo);
return $intIfTrue;
}



proc string[] StartofCurveScriptRetopo3 (string $PolygonShapeZ[], string  $ProjectionCurves[], string $CurveName[]){

string $PolygonShape[];
$PolygonShape[0] = $PolygonShapeZ[0];
string $AllIntersectCurveZA[] =  $ProjectionCurves;
//$PolygonShape[0] = $PolygonShapeZA[0]; 
//string $AllIntersectCurveZA[] =  $retopoProjectionCurves;
//print $retopoProjectionCurves;
makeIdentity -apply true -t 0 -r 0 -s 1 -n 0  $PolygonShape;
int $KillScript = 1;
string $curve = "curve -d 3";
string $Allcurves[];
$Allcurves = $AllIntersectCurveZA;
int $curvesNumber = size($Allcurves) -1;
int $iY = -1; 
float $ZeroDistanceAB = 0.0;
int $switchN = 0;
int $Xi = 1;
string $curvePoints = "";
float $step = 1;  
  string $crShape[];
string $myCurve;
while ($curvesNumber > $iY ){
if ($KillScript == 0 ){$iY = 1000;}
$iY++;
int $a = 1;
int $ADDSUB = 1;
int $ADDSUB2 = 2;
$b = 0;
///////////////////
$switchN = 0;
//////////////////
$Xi = 1;
$step = 1;  
float $arclenghtOne = `arclen $Allcurves[0]`;

$myCurve =  $Allcurves[$iY];
      $cube = $PolygonShape[0];
      $myCPOM = `createNode closestPointOnMesh`;
      connectAttr ($cube+".worldMesh")  ($myCPOM+".inMesh");
      $LocatorResultA = `spaceLocator -p 0 0 0 -n  LocA`;
      $LocA = $LocatorResultA[0];
      connectAttr ($myCPOM+".position")  ($LocA+".translate");
      $LocatorResultB = `spaceLocator -p 0 0 0 -n  LocB`;
      $LocB = $LocatorResultB[0];
      connectAttr ($LocB+".translate")  ($myCPOM+".inPosition");
string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
   $connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position") ($LocB  + ".translate")`;
  $crShape = `listRelatives -s $myCurve`;
 int $XiX = 0;
float $DistanceFourth;
int $triggerA = 0;
float $UnitDistance;
float $DivideTotalWithUnit;
int $RDivideTotalWithUnit;
int $A2;
float $UnitDistanceA;
int $Gate2 = 0;
int $Gate1 = 0;
float $UnitDistanceFourth;
float $UnitDistanceHalf;
int $a3 = 1;
int $Demo = 0;

int $PassedTargetNum = 0;

while($Xi > 0 ){


$XiX++;
if ($XiX == 1000){$Xi = 0; $KillScript = 0;}
float $valuesC[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
float $valuesD[] = `getAttr  ($myCPOM+".position")`;
float $DistanceCD  = PointsGetDistanceFLOAT ($valuesC, $valuesD);

////IF triggered ----- "$step = 40; $a = $a * 40" 
// then --- $a = AddorSubtract($a ,$ADDSUB) which  adds 1 making t = 80/40 t = 81/40
$a = AddorSubtract($a ,$ADDSUB);
  	$t =  $a/$step;

 setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t;
$para = `getAttr ($paramlocatorpointOnCurvex +  ".parameter")`;
float $valuesA[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
float $valuesB[] = `getAttr  ($myCPOM+".position")`;
float $DistanceAB  = PointsGetDistanceFLOAT ($valuesA, $valuesB);

if ($XiX < 32){ $Gate1 = $XiX;}
if ($XiX == 1){ $Gate2 = 1;
$UnitDistanceFourth = $DistanceAB/4;
$UnitDistanceA  = PointsGetDistanceFLOAT ($valuesC, $valuesA);
}
/*
$DivideTotalWithUnit = $DistanceCD /  $UnitDistance;
$RDivideTotalWithUnit = $DivideTotalWithUnit;
*/
/////////////////////////////////////
if ($XiX == $Gate2){ $Gate2 = $Gate1;
$UnitDistance  = $UnitDistanceA;
$UnitDistanceHalf = $UnitDistance/2;
$DivideTotalWithUnit = ($DistanceAB/2) /  $UnitDistanceHalf;
$A2 = ($DivideTotalWithUnit +1);
if ($A2 >= 1){
$a = $a + $A2;
}else{ int $IFequivalent = equivalentTol ($DistanceAB, $ZeroDistanceAB, 0.1);
  	if ($IFequivalent == 1){  
  		$curve += " -p "+$valuesB[0]+"  "+$valuesB[1]+" "+$valuesB[2];
   select -r $LocB $LocA;
delete $myCPOM $LocA $LocB  $paramlocatorpointOnCurvex;  
 $Xi = 0; 
  	}}
}




///////////////////////////////////

//if ( $DistanceAB > $DistanceCD ) { print ("0000  Passed Target Distance  0000" +  "\n"); $PassedTargetNum++;}

//0000  Passed Target Distance  0000

if ($switchN == 0){
if ($triggerA == 0){
if (( $DistanceAB <= $UnitDistanceHalf ) && (  $DistanceAB < $DistanceCD )) {$ADDSUB = 1; $step  = 40; $a = $a * 40; 
$triggerA = 1; } 
}
if (!($XiX == $Gate2)){
if($PassedTargetNum<1){
if ( $DistanceAB > $DistanceCD ) { $ADDSUB = 0;  $step = 20; $a = $a * 20; $switchN = 1;  
print ("0000  Passed Target Distance  0000" +  "\n"); }
}
}
}


if ($switchN == 2){ 
if ( $DistanceAB > 4){ $ADDSUB = 1;  $step = 1; $a = $a / 20; $switchN = 0; $PassedTargetNum++; print ("0000  Passed False Target  0000" +  "\n");}else{
if ( $DistanceAB > $DistanceCD ) { $ADDSUB = 1;  $step = 40; $a = $a * 40;  $switchN = 3; 
$ADDSUB2 = 1; }
}
}

if ($switchN == 1){ $switchN = 2; }
int $IFequivalent = equivalentTol($DistanceAB,  $ZeroDistanceAB, 0.1);
  	if ($IFequivalent == 1){  
  		$curve += " -p "+$valuesB[0]+"  "+$valuesB[1]+" "+$valuesB[2];
   select -r $LocB $LocA;
delete $myCPOM $LocA $LocB  $paramlocatorpointOnCurvex;  
 $Xi = 0; 
  	}


$b = AddorSubtract($b ,$ADDSUB2);
if ( $b > 10 ){ delete $myCPOM $LocA $LocB  $paramlocatorpointOnCurvex;
 $Xi = 0; }
//////////////////////////////////


}
}
string $Newcurvez = `eval($curve)`;
rename $Newcurvez $CurveName[0];
string $Newcurve[] = $CurveName;
string $NewcurveA[] = `ls -sl`;
delete $ProjectionCurves; 
return $Newcurve; 
}


/////////////////////////////


proc AdvancedCurveMODprojectOnSurface(string  $AllIntersectCurveSA[], string $INarrayA[],  string $PolygonShapeXi[]){


int $Error = 0;

$Error++;
print ("error Here "+$Error);

// string $polyShapRetopo[] = $PolygonShapeZA;
string $polyShapRetopo[] = $PolygonShapeXi;



float $eachCVposSTART[];
float $eachCVposEND[];
string $MakespaceLocatorSTART[];
string $MakespaceLocatorEND[];
string $digitalSkeletonA[];
string $NewStraitCurve[];
int $numInts;
$numInts = size($digitalSkeletonA);
if ( $numInts > 0 ){
clear $digitalSkeletonA;
}

string $AllIntersectCurveS[] =  $AllIntersectCurveSA;
//EvalSmoothCurves;
//$digitalSkeletonA =  `StartofCurveScriptIntersectZX`;


string $AllCurveZ[];
$numInts = size($AllCurveZ);
if ( $numInts > 0 ){
clear $AllCurveZ;
} 
string $AllSpaceLocatorZ[];
$numInts = size($AllSpaceLocatorZ);
if ( $numInts > 0 ){
clear $AllSpaceLocatorZ;
} 


string $renamed[];
string $rebuildit[];
string $ZIntersectionCurveZA[];
string $intersectionCurve[]; 
string $MakeSpaceLocator[];
string $objectLocaterz[];
string $AllparamlocatorZ[];
int $numparam;

string $MakespaceLocatorZSE[];
string $SEspaceLocSetofSetz; 
string $paramANDCurve3[];
string $paramANDCurve2[];
string $paramANDCurve[];
string $paramCurveNAMES[];



string $paramlocatorZ[];
$numInts = size($paramlocatorZ);
if ( $numInts > 0 ){
clear $paramlocatorZ;
} 


string $intersectZ[];
string $ZBetween[];
string $objectCurveA[];
string $objectCurve[];
clear  $objectCurve;
float $EACHCVposA[];
float $EACHCVposB[];
float $p1Z; 	
int $moveCurve = 0;


string $objectSelection[];
$numInts = size($objectSelection);
if ( $numInts > 0 ){
clear $objectSelection;
} 

$objectSelection = `editDisplayLayerMembers -q  layerCurvesINRange1`;
int $numparam;
int $EdgecurvesizeNUM = size($objectSelection);




///errors here

if ($EdgecurvesizeNUM > 0){

float $tol = 0.45;
float $dir[3] ;	
		$dir = nurbsViewDirectionVector (0) ;
float $dirX, $dirY, $dirZ;
$dirX = $dir[0];
$dirY = $dir[1];
$dirZ = $dir[2];

string $eachZ;
string $curveIntersectZA;
int $Xxi = -1;

for ( $eachZ in $objectSelection ){

$objectCurve[0] = $eachZ;	
$Xxi++;
print $Xxi ;
$curveIntersectZA = `curveIntersect -ch off - useDirection on -direction $dirX $dirY $dirZ  $objectSelection[$Xxi] $AllIntersectCurveS`;
int $numTokens;		
string $tokens[];
$numTokens = `tokenize $curveIntersectZA " "  $tokens`;

print $numTokens;
if ($numTokens == 2){
///////////////GATHER ALL BUILDING  STRUCTURE/////////##

 $objectCurve[0] = $eachZ;
appendStringArray($AllCurveZ, $objectCurve, 1);
string $buffer[];
$numTokens = `tokenize $curveIntersectZA " "  $buffer`;
$paramlocatorZ[0] = eval("paramLocator " +   $objectCurve[0] + ".u[" + $buffer[0] + "]");
appendStringArray($AllparamlocatorZ,  $paramlocatorZ, 1);
appendStringArray($digitalSkeletonA,  $paramlocatorZ, 1);
        float $intersectposA[];	
	$intersectposA = `pointPosition -w  $paramlocatorZ[0]`;
string $objectLocaterzA[];
$objectLocaterzA = `spaceLocator -p 0 0 0 -n  IntersectZLocaterZ3D`;
move  -ws $intersectposA[0] $intersectposA[1]  $intersectposA[2] $objectLocaterzA[0];
appendStringArray($AllSpaceLocatorZ,  $objectLocaterzA, 1);
clear $objectCurve; 
}
}

appendStringArray($digitalSkeletonA,  $AllSpaceLocatorZ, size($AllSpaceLocatorZ));
  string $shorterList[] =  stringArrayRemoveDuplicates($AllCurveZ);
$AllCurveZ = $shorterList;
 int $CurvesCUTinto = size($AllCurveZ);
if ($CurvesCUTinto == 1){string $oneLocatorZ[] =  {$AllparamlocatorZ[0]}; $AllparamlocatorZ =  $oneLocatorZ; }
$numparam = size($AllparamlocatorZ);
if (($CurvesCUTinto == 2) && ($numparam == 4)){
string $oneLocatorZa[] = {$AllparamlocatorZ[0]}; 
string $oneLocatorZb[] = {$AllparamlocatorZ[1]}; 
$AllparamlocatorZ = {$oneLocatorZa[0],  $oneLocatorZb[0]}; 
}
$numparam = size($AllparamlocatorZ);
int $numInts = size($AllSpaceLocatorZ);
if (($CurvesCUTinto == 2) && ($numInts == 4)){
string $oneLocatorZ2a[] = {$AllSpaceLocatorZ[0]}; 
string $oneLocatorZ2b[] = {$AllSpaceLocatorZ[1]}; 
$AllSpaceLocatorZ = {$oneLocatorZ2a[0],  $oneLocatorZ2b[0]}; 
}

$numInts = size($AllSpaceLocatorZ);
if ( $numparam > 0 ){
  string $shorterList[] =  stringArrayRemoveDuplicates($AllparamlocatorZ);
$AllparamlocatorZ = $shorterList;
}

$numparam = size($AllparamlocatorZ);
$numInts = size($AllSpaceLocatorZ);

select -cl  ;
print $AllparamlocatorZ;


$SEspaceLocSetofSetz = `sets -name  SEspaceLocSetofSets`;	
$paramANDCurve3 = `paramToCurvePts3(  $AllparamlocatorZ )`;
$paramANDCurve2 = `paramToCurvePts2(  $AllparamlocatorZ )`;
$paramANDCurve = `paramToCurvePts(  $AllparamlocatorZ )`;
$paramCurveNAMES = `tokenizeparam( $paramANDCurve  )`;

$MakespaceLocatorZSE = EvalMoveCurvesTOend ($paramANDCurve, $paramCurveNAMES,  $paramANDCurve3, $AllparamlocatorZ,  $SEspaceLocSetofSetz);

if (size($MakespaceLocatorZSE) > 0){
appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
}
int $setsNumber = `sets -q -size  $SEspaceLocSetofSetz`;
if ($setsNumber > 0){
string $subsets[];
$subsets = `sets -q $SEspaceLocSetofSetz`;
//appendStringArray($digitalSkeletonA, $subsets,  size($subsets));

}

/////////////////////
// end of if Size of Curves are greater then ONE 

}


print $numparam;


/////////////////////
/////////////////////
/////////////////////


	if ( $numparam == 0 ){

int $trueORfalse = 0;
int $trueORfalse2 = 0;
string $oldName = $AllIntersectCurveS[0];
$trueORfalse = FindIfCurveCrossesZ ($AllIntersectCurveS);
string $newname[]; 
if ($trueORfalse == 1){
$newname = CutCurveIFConditionTRUETransitZ ($AllIntersectCurveS);
$trueORfalse2 = 1;
ResetTranslation($newname);
rename $newname $oldName;
$AllIntersectCurveS = {$oldName}; 
}
if ($trueORfalse == 0){
ResetTranslation($AllIntersectCurveS);
}

select -r $AllIntersectCurveS;
MirrorANDrename($AllIntersectCurveS);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $AllIntersectCurveS;


} else if ( $numparam == 1 ){

///START OF CURVE = 1

string $renamed[]; 
$renamed[0] = $AllIntersectCurveS[0];
ResetTranslation($renamed);
float $arclenghtDrawCurve = `arclen  $AllIntersectCurveS[0]`;
float $arcLenCurveFrac = $arclenghtDrawCurve/5;
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($renamed[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($renamed[0] + ".cv[0]") ;		 	
$CurveSelection[1] = ($renamed[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}


select -r $renamed $AllCurveZ;
	 string $bufferCutCurve[];
	string $ZIntersectionCurveZ[];
	string $afterCut[];
	string $numTokensZ;
	int $n, $i;


cutCurvePreset(1,1,0.001,2,0.4982,0.8536,0.1523,2,2);
	$afterCut = `ls -sl`;
				// Now, One of these are  bad, One is OK:
			if( `getAttr ($afterCut [0] + ".spans")` < `getAttr ($afterCut [1] + ".spans")`){ delete $afterCut[0];
	$numTokensZ = `tokenize $afterCut[1] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0];
} else { delete $afterCut[1];		
$numTokensZ = `tokenize $afterCut[0] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; }
		
// print $bufferCutCurve;
string $ZIntersectionCurveZA[];
 $ZIntersectionCurveZA = `listRelatives -shapes  $bufferCutCurve[0]`;
$renamed[0] = `rename $ZIntersectionCurveZ[0] $renamed[0]`;
ResetTranslation($renamed);
print $renamed;

if (size($MakespaceLocatorZSE) > 0){

int $ZEROorONE;
 int $foundA = stringArrayGmatch ("SEspaceLocatorSTART3DZ*",  $MakespaceLocatorZSE);
 int $foundB = stringArrayGmatch ("SEspaceLocatorEND3DZ*", $MakespaceLocatorZSE);
if (( $foundA == 1 ) || ( $foundB == 1 )) {
float $eachCVposSTART[] = `pointPosition -w  ($MakespaceLocatorZSE[0])`;

float $movePIVOT[];

$ZEROorONE = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVposSTART);
string $pointEP;

if ( $ZEROorONE == 0){ $movePIVOT = $EACHCVposAZ;  move $movePIVOT[0] $movePIVOT[1] $movePIVOT[2]  ($renamed[0] + ".scalePivot") ($renamed[0] +  ".rotatePivot") ; $pointEP = $CurveSelection[0];  }
if ( $ZEROorONE == 1){ $movePIVOT = $EACHCVposBZ;  move $movePIVOT[0] $movePIVOT[1] $movePIVOT[2]  ($renamed[0] + ".scalePivot") ($renamed[0] +  ".rotatePivot") ; $pointEP = $CurveSelection[1];  }

//ADD SOFT SELECT HERE
select -r $pointEP;
softSelect -e -softSelectEnabled true;
softSelect -e -softSelectDistance  $arcLenCurveFrac;

move -rpr $eachCVposSTART[0] $eachCVposSTART[1]  $eachCVposSTART[2];
xform -cp $renamed[0];
softSelect -e -softSelectEnabled false;
FlattenCurveOnMesh( $AllIntersectCurveS,  $polyShapRetopo);

}
}

if (size($MakespaceLocatorZSE) == 0){

float $eachCVposSTARTB[] = `pointPosition -w  ($AllparamlocatorZ[0])`;
float $CurveEndFloat[];
$ZEROorONEB = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVposSTARTB);
string $pointEP;
if ( $ZEROorONEB == 0){ $pointEP = $CurveSelection[0];  $CurveEndFloat = $EACHCVposAZ;}
if ( $ZEROorONEB == 1){ $pointEP = $CurveSelection[1];  $CurveEndFloat = $EACHCVposBZ;}
//print $pointEP;
//print $CurveEndFloat;
$eachCVposSTARTB = `MakeCleanFloats($eachCVposSTARTB)`;
$CurveEndFloat = `MakeCleanFloats($CurveEndFloat)`;
int $CurveANDIntersectIsTrue = PointsEquivalentTol ($eachCVposSTARTB, $CurveEndFloat); 
if ($CurveANDIntersectIsTrue == 0){
move -rpr $eachCVposSTARTB[0] $eachCVposSTARTB[1]  $eachCVposSTARTB[2] $pointEP;
}
string $paramANDCurveA2[];
$paramANDCurveA2 = `paramToCurvePts2(  $AllparamlocatorZ )`;
string $CurveNameA[] = `paramToCurvePts3(  $AllparamlocatorZ )`;
string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[0]`;
string $AllCurveZA = ("A"+ $CurveNameA[0]+"A");
string $TwoCutCurveZ[] = `ls -sl`;
delete $AllCurveZA;
delete $CurveNameA;
string $AllCurveZ2[];
string $newCurveZA[];
string $newCurveBB[];
int $AllCurveNumA = `size($AllCurveZ)`;
int $detachCurveNumA = `size($detachCurve1)`;
int $OriginalCurveNum = ($AllCurveNumA + $detachCurveNumA);
RemoveNoLongerExistingFromArray ($AllCurveZ);
RemoveNoLongerExistingFromArray ($detachCurve1);
int $AllCurveNumB = `size($AllCurveZ)`;
int $detachCurveNumB = `size($detachCurve1)`;
int $CurveNumB = ($AllCurveNumB + $detachCurveNumB);
string $NewCurvesCut[];
if($CurveNumB == 2){
if (!($CurveNumB == $OriginalCurveNum)&&(($AllCurveNumB > 0)&&($detachCurveNumB > 0))){
appendStringArray($NewCurvesCut, $AllCurveZ, size($AllCurveZ));
appendStringArray($NewCurvesCut, $detachCurve1, size($detachCurve1));
}
}
if (($AllCurveNumB == 0) && ($detachCurveNumB == 2)){
appendStringArray($NewCurvesCut, $detachCurve1, size($detachCurve1));
}
if (($AllCurveNumB == 2) && ($detachCurveNumB == 0)){
appendStringArray($NewCurvesCut, $AllCurveZ, size($AllCurveZ));
}
RemoveNoLongerExistingFromArray ($AllparamlocatorZ);
if (size($AllparamlocatorZ) > 0){
delete $AllparamlocatorZ;
}
ResetTranslation($NewCurvesCut);
for ($each in $NewCurvesCut){
string $newCurveBB[];
$newCurveBB[0] = `rename $each Curve`;
select -r $newCurveBB[0];
MirrorANDrename($newCurveBB);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $newCurveBB[0];
ArrayInsertAtEnd( $newCurveZA, $newCurveBB[0]);
}
string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurveZA[0]);
ArrayInsertAtEnd( $INarrayA,$newCurveZA[1]);
  string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;
$AllCurveZ = $newCurveZA;
}

RemoveNoLongerExistingFromArray ($digitalSkeletonA);
if (size($digitalSkeletonA) > 0){
delete $digitalSkeletonA; }
ResetTranslation($renamed);
string $renamed2[];
$renamed2 = $renamed;

///////////////////////////////////////////////// ///////
// IF Drawn Curve is connected to the end of  another curve thast is in EdgeSet
// the curve drawn can be on a edge curve which  is eather protruding from the ZY plain 
// or it lies on the ZY plain. if it is at one of  the two ends of a protruding EdgeCurve
// then the drawn curve intersecting at  EdgeCurves Ends is eather also protruding from ZY  plain or 
// is positioned freely at the other end.. which  means it could be crossing the ZY plain which  means     
// It would need to be cut
int $ifNearEnds = 0;
if (size($MakespaceLocatorZSE) > 0){
$ifNearEnds = size($MakespaceLocatorZSE);
}

//int $ifNearEnds = size($MakespaceLocatorZSE);
int $AllCurveCVsZeroAndLast = FindIfCurveISonZ ($AllCurveZ);
if ( `objExists ZEdgeCurvesSet` == 0  ) {
string $newSet1 = `sets -name ZEdgeCurvesSet`;
}
int $edgeZsetA = `sets -im ZEdgeCurvesSet  $AllCurveZ[0]`;
int $ZeroX = 0;
if (( $ifNearEnds == 1) && (  $AllCurveCVsZeroAndLast == 1) && ( $edgeZsetA ==  1)) {
vector $AllCurveCVENDs[] = `VecCurveEnds ($AllCurveZ)`;
vector $renamed2CVENDs[] = `VecCurveEnds ($renamed2)`;
float $renamed2CVENDAs[] = $renamed2CVENDs[0];
float $renamed2CVENDBs[] = $renamed2CVENDs[1];
float $AllCurveCVENDAs[] = $AllCurveCVENDs[0];
float $AllCurveCVENDBs[] = $AllCurveCVENDs[1];
float $FloatZ1[] = $renamed2CVENDAs;
float $FloatZ2[] = $renamed2CVENDBs;
float $FloatZ3[] = $AllCurveCVENDAs;
float $FloatZ4[] = $AllCurveCVENDBs;
$renamed2CVENDAs = `MakeCleanFloats($FloatZ1)`;
$renamed2CVENDBs = `MakeCleanFloats($FloatZ2)`;
$AllCurveCVENDAs = `MakeCleanFloats($FloatZ3)`;
$AllCurveCVENDBs = `MakeCleanFloats($FloatZ4)`;
int $CombA = PointsEquivalentTol ($renamed2CVENDAs, $AllCurveCVENDAs);
int $CombB = PointsEquivalentTol ($renamed2CVENDBs, $AllCurveCVENDBs);
int $CombC = PointsEquivalentTol ($renamed2CVENDAs, $AllCurveCVENDBs);
float $intersectFloat[];
if ($CombA == 3 ){ $intersectFloat =  $AllCurveCVENDAs;}
if ($CombB == 3 ){ $intersectFloat =  $AllCurveCVENDBs;}
if ($CombC == 3 ){ $intersectFloat =  $AllCurveCVENDBs;}
float $Zero0x = 0.0;
$ZeroX = equivalentTol($Zero0x, $intersectFloat [0], 0.001);
}
$intZplainF = 1;
if ($ZeroX == 1){
$intZplainF = `ZplainFlatten`;
if($intZplainF == 0){
FlattenCurveToZplain($renamed);
}
}
if ($AllCurveCVsZeroAndLast == 2){
$intZplainF = `ZplainFlatten`;
if($intZplainF == 0){
FlattenCurveToZplain($renamed2);
}
}
int $trueORfalse = 0;
int $trueORfalse2 = 0;
if ($ZeroX == 0){
$trueORfalse = FindIfCurveCrossesZ($renamed2);
string $newname[]; 
if (($trueORfalse == 1) && ($ZeroX == 0)){
$newname = CutCurveIFConditionTRUETransitZ ($renamed2);
$trueORfalse2 = 1;
ResetTranslation($newname);
rename $newname $renamed2; 
}
}  

string $newnamed[0] = {$renamed2[0]};
ResetTranslation($newnamed);
RemoveNoLongerExistingFromArray ($AllparamlocatorZ);
if (size($AllparamlocatorZ) > 0){
delete $AllparamlocatorZ;
} 
if($intZplainF > 0)  {
select -r $newnamed;
MirrorANDrename($newnamed);
}
if (($ZeroX == 1) || ($trueORfalse2 == 1)){
sets -include ZEdgeCurvesSet $newnamed;
}

//ArrayInsertAtEnd( $INarrayA, $newnamed[0]);
print "check Here6";
ResetTranslation($newnamed);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $newnamed;
RemoveNoLongerExistingFromArray ($digitalSkeletonA);
if (size($digitalSkeletonA) > 0){
delete $digitalSkeletonA;
}


select -r $newnamed[0];
EvalAddingCurves;
EvalcreatSphere;

//////////////////////////////////////END OF ONE  CURVE
//////////////////////////////////////END OF ONE  CURVE

} else if ( $numparam > 2 ){

//IF INTETSECT MORE THEN 2CURVES can be changed here
// Buffers of u para of DrawnCurve placed in a  Array then Sorted. ///
if (size($MakespaceLocatorZSE) > 0){
appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
}
delete $digitalSkeletonA;

} else if ( $numparam == 2 ){

//////////////////////////////////////
////NEW NEW NEW

$rebuildit = $AllIntersectCurveS;
print $rebuildit;
//NEW START//
//ResetTranslation($rebuildit);
select -r $AllIntersectCurveS $AllCurveZ[0];
	 string $bufferCutCurve[];
	string $ZIntersectionCurveZ[];
	string $afterCut[];
	string $numTokensZ;
	int $n, $i;


cutCurvePreset(1,1,0.001,2,0.4982,0.8536,0.1523,2,2);
	$afterCut = `ls -sl`;
				// Now, One of these are  bad, One is OK:
			if( `getAttr ($afterCut [0] + ".spans")` < `getAttr ($afterCut [1] + ".spans")`){ delete $afterCut[0];
	$numTokensZ = `tokenize $afterCut[1] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0];
} else { delete $afterCut[1];		
$numTokensZ = `tokenize $afterCut[0] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; }
		
// print $bufferCutCurve;
string $ZIntersectionCurveZA[];
 $ZIntersectionCurveZA = `listRelatives -shapes  $bufferCutCurve[0]`;


select -r $ZIntersectionCurveZA $AllCurveZ[1];

cutCurvePreset(1,1,0.001,2,0.4982,0.8536,0.1523,2,2);
			$afterCut = `ls -sl`;
				// Now, One of these are  bad, One is OK:
			if( `getAttr ($afterCut [0] + ".spans")` < `getAttr ($afterCut [1] + ".spans")`){ delete $afterCut[0];
	$numTokensZ = `tokenize $afterCut[1] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0];
} else { delete $afterCut[1];		
$numTokensZ = `tokenize $afterCut[0] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; }
		
// print $bufferCutCurve;
//THIS IS LIKELY WHERE OTHER PROBLEMS EXIST!!!!!!!!!!!!!!!!!!! DO NOT RENAME THE SHAPE NODE!!!!!

//THIS IS LIKELY WHERE OTHER PROBLEMS EXIST!!!!!!!!!!!!!!!!!!! DO NOT RENAME THE SHAPE NODE!!!!!


//THIS IS LIKELY WHERE OTHER PROBLEMS EXIST!!!!!!!!!!!!!!!!!!! DO NOT RENAME THE SHAPE NODE!!!!!



print $afterCut;
RemoveNoLongerExistingFromArray ($afterCut);
string $ZIntersectionCurveZB[];
 $ZIntersectionCurveZB = `listRelatives -shapes $afterCut[0]`;
print $ZIntersectionCurveZB;
print $afterCut[0];
print $rebuildit[0];

$renamed[0] = `rename $afterCut[0] $rebuildit`;
string $ZIntersectionCurveZC[];
 $ZIntersectionCurveZC = `listRelatives -shapes $renamed[0]`;


$rebuildit = $renamed;
ResetTranslation($rebuildit);

if ( size($MakespaceLocatorZSE) == 0  ) {
string $paramANDCurveA2[];
$paramANDCurveA2 = `paramToCurvePts2(  $AllparamlocatorZ )`;
string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[0]`;
string $detachCurve2[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[1]`;
delete $AllCurveZ;
string $newCurves1[];
string $newCurves2[];
for ($each in $detachCurve1){
string $newCurveA;
$newCurveA = `rename $each Curve`;
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $newCurveA;
ArrayInsertAtEnd( $newCurves1, $newCurveA);
}
for ($each in $detachCurve2){
string $newCurveB;
$newCurveB = `rename $each Curve`;
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $newCurveB;
ArrayInsertAtEnd( $newCurves2, $newCurveB);
}


string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);
ArrayInsertAtEnd( $INarrayA, $newCurves2[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves2[1]);
ResetTranslationEach($newCurves1);
ResetTranslationEach($newCurves2);
  string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;
$AllCurveZ = $newCurves1;
ArrayInsertAtEnd( $AllCurveZ, $newCurves2[0]);
ArrayInsertAtEnd( $AllCurveZ, $newCurves2[1]);
}

int $ONEspaceLOC = 0;
string $newCurves1[];
if (size($MakespaceLocatorZSE) == 1){
$ONEspaceLOC = 1;
string $subsetsA[];
$subsetsA = `sets -q $SEspaceLocSetofSetz`;
string $subsetsB[]; string $subsetsB2[];
$subsetsB = `sets -q $subsetsA`;
$subsetsB2[0] = $subsetsB[0];
$subsetsB3[0] = $subsetsB[1];
string $SetItemA = ($subsetsB2[0]);
string $SetItemB = ($subsetsB3[0]);
string $subsetItemNeeded[];
int $setATrueFalse = `gmatch $SetItemA "*->*"`;
int $setBTrueFalse = `gmatch $SetItemB "*->*"`;
if ($setATrueFalse == 1){
$subsetItemNeeded[0] = $subsetsB2[0];
}else{ $subsetItemNeeded[0] = $subsetsB3[0]; }
string $bufferZ[];
$numTokensX = `tokenize $subsetItemNeeded[0] "->"  $bufferZ`;
print $bufferZ; 
string $CurveLOCZ[] =  {$bufferZ[1]};
string $paramANDCurveA02[];
$paramANDCurveA02 = `paramToCurvePts2( $CurveLOCZ  )`;
string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA02[0]`;
delete $subsetsB[0];
string $newCurves1[];
for ($each in $detachCurve1){
string $newCurve;
$newCurve = `rename $each Curve`;
ArrayInsertAtEnd( $newCurves1, $newCurve);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $newCurve;
}
string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);
  string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;
RemoveNoLongerExistingFromArray ($AllparamlocatorZ);
delete $AllparamlocatorZ; 
}



if ( size($MakespaceLocatorZSE) > 0  ) {
appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;	 		
$CurveSelection[1] = ($rebuildit[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
$MakeXBetweenB[0] = `curve -d 1 -p $EACHCVposAZ [0] $EACHCVposAZ[1] $EACHCVposAZ[2] -p  $EACHCVposBZ[0] $EACHCVposBZ[1] $EACHCVposBZ[2]  -k 0 -k 2 -n                        XCurveBetweenB`;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 0 -d 1 -tol 0.001  $MakeXBetweenB[0];
appendStringArray($digitalSkeletonA,  $MakeXBetweenB, 1);
}
}
wire -gw false -en 1.000000 -ce 0.000000 -li  1.000000 -w $MakeXBetweenB[0] -dds 0 50.000000  $rebuildit[0];
PAUSE;
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($MakeXBetweenB[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($MakeXBetweenB[0] + ".cv [0]") ;			
$CurveSelection[1] = ($MakeXBetweenB[0] + ".cv["  + $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
for ($eachZA in $CurveSelection) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
				}
int $ZEROorONEA;
int $ZEROorONEB;
string $locZSE0[];
string $locZSE1[];
 int $foundAZ0;
 int $foundBZ0;
 int $foundAX1;
 int $foundBX1;
int $i = 0;
int $iX = 0;
float $eachCVpos1[];
float $eachCVpos2[];
float $movePIVOT1[];
float $movePIVOT2[];
	if (size($MakespaceLocatorZSE) == 1){	 $i = 1; }
	if (size($MakespaceLocatorZSE) == 2){ 	 $iX = 2; }
	if (( $i == 1) || ( $iX == 2)){
$locZSE0[0] = $MakespaceLocatorZSE[0];
$eachCVpos1 = `pointPosition -w  ($MakespaceLocatorZSE[0])`;
	if ( $iX == 2){
$locZSE1[0] = $MakespaceLocatorZSE[1];
$eachCVpos2 = `pointPosition -w  ($MakespaceLocatorZSE[1])`;
	}
	if (( $i == 1) || ( $iX == 2)) {

$ZEROorONEA = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVpos1);
if ( $ZEROorONEA == 0){ $movePIVOT1 =  $eachCVpos1; print "cv ZERO"; }
if ( $ZEROorONEA == 1){ $movePIVOT1 =  $eachCVpos1; print "cv LAST"; }
if ( $iX == 2){
$ZEROorONEB = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVpos2);
if ( $ZEROorONEB == 0){ $movePIVOT2 =  $eachCVpos2; print "cv ZERO"; }
if ( $ZEROorONEB == 1){ $movePIVOT2 =  $eachCVpos2; print "cv LAST"; }
move -ws $movePIVOT2[0] $movePIVOT2[1]  $movePIVOT2[2] $CurveSelection[$ZEROorONEB];
PAUSE;	}

move -ws $movePIVOT1[0] $movePIVOT1[1]  $movePIVOT1[2] $CurveSelection[$ZEROorONEA];
PAUSE;				}
delete -ch $rebuildit;
delete $digitalSkeletonA; 				 	}
}

/////////////////////////////

int $CVsZeroAndLast;
if ( size($MakespaceLocatorZSE) > 0  ) {
if ( `objExists ZEdgeCurvesSet` == 1  ) {
if ( $ONEspaceLOC == 0  ) {
int $edgeZsetA = `sets -im ZEdgeCurvesSet  $AllCurveZ[0]`;
int $edgeZsetB = `sets -im ZEdgeCurvesSet  $AllCurveZ[1]`;
$CVsZeroAndLast = FindIfCurveISonZ($rebuildit);
if (($edgeZsetA == 1) && ($edgeZsetB == 1)){
print "Intersects edgeZset Curves";
string $CurveSelectionZ[];
int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );	
$CurveSelectionZ[0] = ($rebuildit[0] + ".cv[" +  "0:" + $numCVrealNum + "]") ;
if ($CVsZeroAndLast == 2){
string $CurveSelectionX[];
$CurveSelectionX = `ls -fl $CurveSelectionZ[0]`;
for ($eachZA in $CurveSelectionX) {
        float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
move -ws 0 $eachCVpos[1] $eachCVpos[2] $eachZA ; 
}
}
xform -cp;
}
}
}
}

FlattenCurveOnMesh( $rebuildit,  $polyShapRetopo);
ResetTranslation($rebuildit);

//string $ParentArc[];
//$ParentArc = Strait_ARC_or_FreeForm($rebuildit,  5.5, 2.5 );
//print $CVsZeroAndLast;
//FROM HERE DOWN all -- $rebuildit -- strings[]  WERE $ParentArc  

if($CVsZeroAndLast < 2){
select -r $rebuildit;
MirrorANDrename($rebuildit);
}

if ( $CVsZeroAndLast > 0){ 
sets -include ZEdgeCurvesSet $rebuildit;
 }
ArrayInsertAtEnd( $INarrayA, $rebuildit[0]);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $rebuildit;
select -r $rebuildit[0];
EvalAddingCurves;
EvalcreatSphere;
////////////////////TRIGGER###################### #######////////////////
}
RemoveNoLongerExistingFromArray ($digitalSkeletonA);
if (size($digitalSkeletonA) > 0){
delete $digitalSkeletonA;
}

RemoveNoLongerExistingFromArray ($AllparamlocatorZ);
if (size($AllparamlocatorZ) > 0){
delete $AllparamlocatorZ;
} 
if ( `objExists $SEspaceLocSetofSetz` == 1  ) { 	
select -r -ne $SEspaceLocSetofSetz;
delete;
}
}


////END OF PROC////////////////////////////////////////////////////


proc StartupItems(){

optionVar -fv "totalAnimateRollTime" 0.9;
select -r   Text_byxDrawingxaxLinexOverxOnexofxThexCurves_1;
allViewFit(0);
allViewFit(1);
select -cl  ;
goToView -1;
pause -sec 2;
optionVar -fv "totalAnimateRollTime" 2.5;
goToView -1;
optionVar -fv "totalAnimateRollTime" 0.4;
setAttr "ZCURVEModelingCAM.centerOfInterest"   72.916917;
eval("int $script_jobToolChangedNum1 = `scriptJob   -event ToolChanged EvalAutoCurvesScripts`;");
PencilCurveTool;
curveSketchCtx -e -d 3 `currentCtx`;
setAttr layerYZYXPlains.visibility 1;

}

/////////////////////////////

/////////////////////////////



//////////
//////////
//////////
//////////
/*
file -f -options "v=0"  -typ "mayaBinary" -o   "C:/Users/johnny/Documents/maya/projects/default/  scenes/RetopoMakeworkToday2.mb";addRecentFile   ("C:/Users/johnny/Documents/maya/projects/default  /scenes/RetopoMakeworkToday2.mb", "mayaBinary");


scriptJob -killAll -force;
select -r LiveSurfaceB ;
MakeLive;
select -r pCube1 ;
string $PolygonShapeZA[] = `ls -sl`;
PencilCurveTool;
DisplayWireframe;
/////Stiner
int $n = 12;
float $angleArray = 360/$n;
*/


/////////////////////////////////////////////////  ///////////////
proc ResetTransEachSL(){
string $oneItemz[] = `ls -sl`;
for ($each in $oneItemz){
xform -cp $each;
	vector $worldPos = `xform -q -ws -rp   $each`;
			move -rpr 0 0 0 $each;
			makeIdentity -apply true   -t 1 -r 0 -s 0 $each;
			xform -t ($worldPos.x)   ($worldPos.y) ($worldPos.z) $each;
}
}
//ResetTransEachSL;
/////////////////////////////////////////////////  ///////////////
/////////////////////////////////////////////////  ///////////////




if ( `objExists ZCURVEModelingCAM` == 0  ) {
handleScriptEditorAction "toggleSuppressInfos";
handleScriptEditorAction  "toggleSuppressWarnings";
handleScriptEditorAction "toggleSuppressErrors";
setWireframeOnShadedOption 1 modelPanel4;
//ONE or the other Below -
$CamConeLocator = `CreateCAMforIntCurveScript`;
if ( `objExists CamConeLocatorSet` == 0  ) {
$newCAMSet1 = `sets -name CamConeLocatorSet`;
sets -include CamConeLocatorSet $CamConeLocator;
}
createStageOneForRetopo;
select -r $CamConeLocator;
HideSelectedObjects;
shadingNode -asShader lambert;
$material = `shadingNode -asShader lambert -name  LIVEsurfaceslambert`;
	$sg = `sets -renderable true - noSurfaceShader true -empty -name ($material +  "SG")`;
setAttr "LIVEsurfaceslambert.transparency" -type  double3 1 1 1 ;
defaultNavigation -source LIVEsurfaceslambert - destination  |LiveSurfaceB|LiveSurfaceBShape.instObjGroups[0]  -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert",  "LiveSurfaceBShape.instObjGroups[0]");
defaultNavigation -source LIVEsurfaceslambert - destination |Zplane|ZplaneShape.instObjGroups[0]  -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert",  "ZplaneShape.instObjGroups[0]");
defaultNavigation -source LIVEsurfaceslambert - destination |Xplane|XplaneShape.instObjGroups[0]  -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert",  "XplaneShape.instObjGroups[0]");
//createStageOne;
}


if (( `objExists ZCURVEModelingCAM` == 1  )&& (  `objExists layerCurvesINRange1` == 1 )) {
if ( `objExists CamConeLocatorSet` == 1  ) {
eval( "global string $CamConeLocator[];");
eval( "$CamConeLocator= `sets -q  CamConeLocatorSet`;");
}
}






//CHANGES MADE

proc FlattenCurveOnMesh( string $curve[], string  $Mesh[]){

string $PolygonShapeZ1[0] = {$Mesh[0]};
string $CurveZOne[0] = {$curve[0]};
string $CurveSelection[] = `ls -fl ($CurveZOne[0]  +".ep[0:*]")`; 

    string $PolyX = $PolygonShapeZ1[0];
      $myCPOM = `createNode closestPointOnMesh`;
      connectAttr ($PolyX+".worldMesh")  ($myCPOM+".inMesh");
      $LocatorResultA = `spaceLocator -p 0 0 0 -n  LocA`;
      $LocA = $LocatorResultA[0];
      connectAttr ($myCPOM+".position")  ($LocA+".translate");
      $LocatorResultB = `spaceLocator -p 0 0 0 -n  LocB`;
      $LocB = $LocatorResultB[0];
      connectAttr ($LocB+".translate")  ($myCPOM+".inPosition");

  for ($Eachep in $CurveSelection ) {
	float $pointPos[];
	$pointPos = `pointPosition -w ($Eachep)`;
 move -ws $pointPos[0] $pointPos[1] $pointPos[2]  $LocB;
float $valuesB[] = `getAttr  ($myCPOM+".position")`;
 move -ws $valuesB[0] $valuesB[1] $valuesB[2]  $Eachep;
}

delete  $myCPOM $LocA $LocB;
$Newcurvez = $CurveZOne;
}


proc createStageOne(){

nurbsPlane -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u  1 -v 1 -ch 1 -n Zplane;
rotate -r -os 0 0 -90 ;
setAttr "Zplane.scaleX" 3000;
setAttr "Zplane.scaleY" 3000;
setAttr "Zplane.scaleZ" 3000; 
nurbsPlane -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u  1 -v 1 -ch 1 -n Xplane;
setAttr "Xplane.scaleX" 3000;
setAttr "Xplane.scaleY" 3000;
setAttr "Xplane.scaleZ" 3000;

editDisplayLayerMembers -noRecurse  NurbsPlanes "Zplane";
editDisplayLayerMembers -noRecurse  NurbsPlanes "Xplane";
layerEditorLayerButtonVisibilityChange NurbsPlanes;

textCurves -ch 0 -f "Courier New|h-19|w700|c0" -t  "Select The Z Axis OR the X Axis ";
rotate -r -os 0 90 0 ;
move -r 0 0 59.5 ;
move -r 0 19 0 ;
textCurves -ch 0 -f "Courier New|h-19|w700|c0" -t  "by Drawing a Line Over One of The Curves";
rotate -r -os 0 90 0 ;
move -r 0 0 59.5 ;
move -r 0 12.5 0 ;
string $Zc[];
string $Xc[];
$Zc[0] = `curve -d 3 -p 0 0 0 -p 0 0 4 -p 0  0 8 -p 0 0 12 -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -n  Zcurvez`;
$Xc[0] = `curve -d 3 -p 0 0 0 -p 4 0 0 -p 8  0 0 -p 12 0 0 -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -n  Xcurvez`;
rename $Zc "Zcurvez" ;
rename $Xc "Xcurvez" ;
if ( `objExists layerZcurvez` == 0  ) {
createDisplayLayer -name "layerZcurvez" -number 1  -empty;
setAttr layerZcurvez.color 6;
editDisplayLayerMembers -noRecurse layerZcurvez  Zcurvez;
}
//
if ( `objExists layerXcurvez` == 0  ) {
createDisplayLayer -name "layerXcurvez" -number 1  -empty;
setAttr layerXcurvez.color 13;
editDisplayLayerMembers -noRecurse layerXcurvez  "Xcurvez";
}
//rename |Xcurvez|curveShape2 "XcurvezShape2" ;
//rename |Zcurvez|curveShape1 "ZcurvezShape1" ;
}
///////////////////////////////////////////////// //

proc createStageOneForRetopo(){
nurbsPlane -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u  1 -v 1 -ch 1 -n Zplane;
//OLD editDisplayLayerMembers -noRecurse  layerYZYXPlains "Zplane";
rotate -r -os 0 0 -90 ;
setAttr "Zplane.scaleX" 3000;
setAttr "Zplane.scaleY" 3000;
setAttr "Zplane.scaleZ" 3000; 
nurbsPlane -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u  1 -v 1 -ch 1 -n Xplane;
setAttr "Xplane.scaleX" 3000;
setAttr "Xplane.scaleY" 3000;
setAttr "Xplane.scaleZ" 3000;

editDisplayLayerMembers -noRecurse  NurbsPlanes "Zplane";
editDisplayLayerMembers -noRecurse  NurbsPlanes "Xplane";
layerEditorLayerButtonVisibilityChange NurbsPlanes;

curve -d 3 -p 0 0 0 -p 0 0 4 -p 0 0 8 -p 0 0 12  -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -n Zcurvez;
curve -d 3 -p 0 0 0 -p 4 0 0 -p 8 0 0 -p 12 0 0  -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -n Xcurvez;
if ( `objExists layerZcurvez` == 0  ) {
createDisplayLayer -name "layerZcurvez" -number 1  -empty;
setAttr layerZcurvez.color 6;
editDisplayLayerMembers -noRecurse layerZcurvez  Zcurvez;
}
//
if ( `objExists layerXcurvez` == 0  ) {
createDisplayLayer -name "layerXcurvez" -number 1  -empty;
setAttr layerXcurvez.color 13;
editDisplayLayerMembers -noRecurse layerXcurvez  "Xcurvez";
}
}

proc StartupItemsPart2(){

setAttr "ZCURVEModelingCAM.centerOfInterest"   72.916917;
eval("int $script_jobToolChangedNum1 = `scriptJob   -event ToolChanged EvalAutoCurvesScripts`;");
PencilCurveTool;
curveSketchCtx -e -d 3 `currentCtx`;
setAttr layerYZYXPlains.visibility 1;

}


proc PreStartup1(){

setAttr "ZCURVEModelingCAM.centerOfInterest"   72.916917;
PencilCurveTool;
curveSketchCtx -e -d 3 `currentCtx`;

}

///////////////////////////////////////////////

///////////////////////////////////////////////

//This IF statement checks if CurveScripts That   Build Setup have already been RUN 
//and Already Exist


global string $CamConeLocator[];
string $newCAMSet1;

//select -r $CamConeLocator;

if ( `objExists ZCURVEModelingCAM` == 0  ) {

handleScriptEditorAction "toggleSuppressInfos";
handleScriptEditorAction   "toggleSuppressWarnings";
handleScriptEditorAction "toggleSuppressErrors";
setWireframeOnShadedOption 1 modelPanel4;
//ONE or the other Below -

$CamConeLocator = `CreateCAMforIntCurveScript`;

if ( `objExists CamConeLocatorSet` == 0  ) {
$newCAMSet1 = `sets -name CamConeLocatorSet`;
sets -include CamConeLocatorSet $CamConeLocator;
}


//createStageOneForRetopo;
createStageOne;

select -r $CamConeLocator;
HideSelectedObjects;
shadingNode -asShader lambert;
$material = `shadingNode -asShader lambert -name   LIVEsurfaceslambert`;
	$sg = `sets -renderable true -  noSurfaceShader true -empty -name ($material +   "SG")`;
setAttr "LIVEsurfaceslambert.transparency" -type   double3 1 1 1 ;
defaultNavigation -source LIVEsurfaceslambert -  destination   |LiveSurfaceB|LiveSurfaceBShape.instObjGroups[0]   -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert",   "LiveSurfaceBShape.instObjGroups[0]");
defaultNavigation -source LIVEsurfaceslambert -  destination |Zplane|ZplaneShape.instObjGroups[0]   -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert",   "ZplaneShape.instObjGroups[0]");
defaultNavigation -source LIVEsurfaceslambert -  destination |Xplane|XplaneShape.instObjGroups[0]   -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert",   "XplaneShape.instObjGroups[0]");
//createStageOne;

}


if (( `objExists ZCURVEModelingCAM` == 1  )&& (   `objExists layerCurvesINRange1` == 1 )) {
if ( `objExists CamConeLocatorSet` == 1  ) {
eval( "global string $CamConeLocator[];");
eval( "$CamConeLocator= `sets -q   CamConeLocatorSet`;");
}
}


//ONE or the other Below -
////////////////////////////////////////////////////////////////////////////////////
//START

//PreStartup1;
//select -r Xplane;

evalDeferred StartupItemsPart2;

/////////////////////////////////////////////////////////////////////////////////////
//evalDeferred StartupItems;