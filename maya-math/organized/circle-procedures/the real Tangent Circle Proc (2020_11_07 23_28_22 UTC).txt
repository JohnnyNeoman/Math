proc CreateVectorInfoAtSelected(){

string $oneItemz[] = `ls -sl -fl`;
for ($each in $oneItemz){
xform -cp $each;
	vector $worldPos = `xform -q -ws -t  $each`;
string $type = getTypeItemString({$each});
if(!($type == "controlPoint")){
			move -rpr 0 0 0 $each;
			makeIdentity -apply true  -t 1 -r 0 -s 0 $each;
			xform -t ($worldPos.x)  ($worldPos.y) ($worldPos.z) $each;
}

float $worldPosF[] = `xform -q -ws -t $each`;
string $resultZa =("<< " +  $worldPos+" >>");
string $textN[] = `textCurves -ch 0 -f "Times New Roman|h-2|w400|c0" -t $resultZa`;
toggle -cv -state 0-ep -hull -normal -sf -origin;
move -ws $worldPosF[0] $worldPosF[1] $worldPosF[2] $textN;
string $UserCaM = `modelEditor -q -camera modelPanel4`; 
aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $UserCaM $textN;
}


}


proc string Circles_Direction(float $Point[], float $FloatDir[], float $FloatNum){
string $circleItem[] = `circle -c $Point[0] $Point[1] $Point[2] 
-nr $FloatDir[0] $FloatDir[1] $FloatDir[2] 
-sw 360 
-r $FloatNum 
-d 3 -ut 0 -tol 0.001 -s 8 -ch 1`;

//setRotationAxisFloat(string $objectitem1[], float $rotationsA[])
return $circleItem[0];
}

proc ResetTransEachSL(){
string $oneItemz[] = `ls -sl`;
for ($each in $oneItemz){
xform -cp $each;
	vector $worldPos = `xform -q -ws -rp $each`;
			move -rpr 0 0 0 $each;
			makeIdentity -apply true -t 1 -r 0 -s 0 $each;
			xform -t ($worldPos.x) ($worldPos.y) ($worldPos.z) $each;
}
}


proc float [] ArcLengthArray(string $Objs[]){
float $ArcLengths[];
for($each in $Objs){
$ArcLengths[`size($ArcLengths)`]= `arclen $each`;
}
return $ArcLengths;
}

//CircleFromCurveZYX 0 0 1;

	proc CircleFromCurveT(){
string $StraitCurve[] = `ls -sl`;
ResetTransEachSL;
float $ArcLengthOne = `arclen $StraitCurve[0]`;
$ArcLengthOne = $ArcLengthOne/2;
float $CurvPos[] = `xform -q -ws -rp $StraitCurve[0]`;
float $tangent[] = `pointOnCurve -t -pr 0.5 $StraitCurve[0]`;
$tangent = `unit <<$tangent[0], $tangent[1], $tangent[2]>>`;
string $circles = Circles_Direction($CurvPos, $tangent, $ArcLengthOne);
ResetTransEachSL;
}

proc float [] lineIntersectionF(float $PosA[], float $PosB[], float $PosC[], float $PosD[]){ 
float $DirAB[] = DirectionF ($PosA, $PosB);
float $DirCD[] = DirectionF ($PosC, $PosD);
 float $locsA[] = lineIntersection($PosA, $DirAB, $PosC, $DirCD);
return $locsA;
}

	proc CircleFromCurveN(int $X, int $Y, int $Z ){
string $StraitCurve[] = `ls -sl`;
ResetTransEachSL;
float $ArcLengthOne = `arclen $StraitCurve[0]`;
$ArcLengthOne = $ArcLengthOne/2;
float $CurvPos[] = `xform -q -ws -rp $StraitCurve[0]`;
float $t[3], $n[3];
  vector $tan, $norm, $bi;

   //$t $n are just directions....
    $t = `pointOnCurve -ch off -pr 0.5 -nt $StraitCurve[0]`;
    $n = `pointOnCurve -ch off -pr 0.5 -nn $StraitCurve[0]`;
    // Maya promises normalized tangent and normal,
    // but they really aren't.    
    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
//## Note the int One 1 inthe middle...
    $norm = `unit << $n[0], $n[0], $n[0] >>`;    
    // Calculate the binormal.   
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
                 << ($norm.x), ($norm.y), ($norm.z) >>`;
    $bi = `unit $bi`;
string $circles = Circles_Direction($CurvPos,$bi, $ArcLengthOne);
ResetTransEachSL;
}

// CircleFromCurveZYX 1 0 0;

	proc CircleFromCurveZYX(int $X, int $Y, int $Z ){
string $StraitCurve[] = `ls -sl`;
ResetTransEachSL;
float $ArcLengthOne = `arclen $StraitCurve[0]`;
$ArcLengthOne = $ArcLengthOne/2;
float $CurvPos[] = `xform -q -ws -rp $StraitCurve[0]`;
float $t[3], $n[3];
  vector $tan, $norm, $bi;
   //$t $n are just directions....
    $t = `pointOnCurve -ch off -pr 0.5 -nt $StraitCurve[0]`;
    $n = `pointOnCurve -ch off -pr 0.5 -nn $StraitCurve[0]`;
    // Maya promises normalized tangent and normal,
    // but they really aren't.    
    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
//## Note the int One 1 inthe middle...
    $norm = `unit << $X, $Y, $Z >>`;    
    // Calculate the binormal.   
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
                 << ($norm.x), ($norm.y), ($norm.z) >>`;
    $bi = `unit $bi`;
string $circles = Circles_Direction($CurvPos,$bi, $ArcLengthOne);
ResetTransEachSL;
}

proc float CirclesRadius(string $selectedObjects[]){
string $CurveSelectionA[] = `ls -fl ($selectedObjects[0]+".ep[0]")`; 
 float $FloatPointA[] = `pointPosition -w  $CurveSelectionA[0]`;
 float $worldPosA[];
       $worldPosA = `xform -q -ws -a -rp $selectedObjects[0]`;
 float $CircleRadiusA = getDistance($FloatPointA, $worldPosA);
return $CircleRadiusA;
}


proc float [] CirclesRadiusDirection(vector $directionAB[], vector $PosAB[]){

string $selectedObjects[];
clear $selectedObjects;
$selectedObjects = `ls -sl`;
string $CurveSelectionA[] = `ls -fl ($selectedObjects[0]+".ep[0]")`; 
string $CurveSelection_a2[] = `ls -fl ($selectedObjects[0]+".ep[3]")`; 

string $CurveSelectionB[] = `ls -fl ($selectedObjects[1]+".ep[0]")`; 
string $CurveSelection_b2[] = `ls -fl ($selectedObjects[1]+".ep[3]")`; 

 float $FloatPointa2[] = `pointPosition -w  $CurveSelection_a2[0]`;
 float $FloatPointb2[] = `pointPosition -w  $CurveSelection_b2[0]`;	
 float $FloatPointA[] = `pointPosition -w  $CurveSelectionA[0]`;
 float $FloatPointB[] = `pointPosition -w  $CurveSelectionB[0]`;

 float $worldPosA[];
       $worldPosA = `xform -q -ws -a -rp $selectedObjects[0]`;
 float $CircleRadiusA = getDistance($FloatPointA, $worldPosA);
 float $worldPosB[];
	$worldPosB= `xform -q -ws -a -rp $selectedObjects[1]`;

$directionAB[0] = FloatToVec (DirectionF($worldPosA,$worldPosB));
$directionAB[1] = FloatToVec (DirectionF($worldPosB,$worldPosA));
$PosAB[0] = FloatToVec ($worldPosA);
$PosAB[1] = FloatToVec ($worldPosB);
 float $CirclesDistance  = getDistance ($worldPosA, $worldPosB);

float $FloatDirNormalCurveA[] = Normal3Points($worldPosA,$FloatPointa2,$FloatPointA);
$directionAB[2] = FloatToVec ($FloatDirNormalCurveA);

 float $CircleRadiusB = getDistance ($FloatPointB, $worldPosB);
 float $RadiusAB[] = {$CircleRadiusA, $CircleRadiusB,$CirclesDistance};
return $RadiusAB;
}

proc string Circles_Direction(float $Point[], float $FloatDir[], float $FloatNum){
string $circleItem[] = `circle -c $Point[0] $Point[1] $Point[2] 
-nr $FloatDir[0] $FloatDir[1] $FloatDir[2] 
-sw 360 
-r $FloatNum 
-d 3 -ut 0 -tol 0.001 -s 8 -ch 1`;

//setRotationAxisFloat(string $objectitem1[], float $rotationsA[])
return $circleItem[0];
}

proc MoveObject2(float $addfloatVector1[]){
string $VectorUnitLoc[] = `ls -sl`;
move -r $addfloatVector1[0] $addfloatVector1[1] $addfloatVector1[2] $VectorUnitLoc[0];
}

/*

proc vector [] PointToCircleTangents(float $CircleRadiusA, float $worldPosA[], float $worldPosB[], float $FloatDirNormal[]){

vector $directionABs[];
float $R1 = $CircleRadiusA;

$directionABs[0] = FloatToVec (DirectionF($worldPosA,$worldPosB));
$directionABs[1] = FloatToVec (DirectionF($worldPosB,$worldPosA));

// P is the distance between 2 circles
float $P = distance2Pts ($worldPosA, $worldPosB);
float $r1 = $R1;
float $r1Z = $R1*2;
//HightsOfIsoscelesTriangle($P, $r1Z, $P);
float $Pi = 3.1415926535;
float $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1Z 2.000`) - (`pow $P 2.000`) )/(2.000*$P*$r1Z)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN =   $AngleNPi;
//float $ts = atand( (`abs ($r1 - $r2)`) /$P);
float $MultDirPC1[] = multiplyFloat($r1, $directionABs[0]);
float $AddMultDirPCA1[] = AddFloats($worldPosA, $MultDirPC1);

$AngleN = $Arcangle;
float $tsDAR = ( $AngleN)*-1;
float $tsDBR = ( $AngleN)*1;
//The first argument represents a point, the second an axis and the third an angle in radians
float $rotatsA[] = `rot $directionABs[0] $FloatDirNormal $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($worldPosA, $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $FloatDirNormal $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($worldPosA, $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);

vector $pointsT[];
$pointsT[0] = FloatToVec ($AddMultDirPCA1);
$pointsT[1] = FloatToVec ($AddMultDirPCA2);
return $pointsT;
}

*/




proc vector[] PointArrayT(string $ObjectList[]){

float $pointAZ1[];
vector $VecArray[];
int $XiV = 0;
for ($each in $ObjectList){
if (catch($pointAZ1 = `xform -q -ws -t ($each)`)){
$pointAZ1 = `pointPosition -w ($each)`;
} 
$VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
$XiV++;
}
return $VecArray;
}




proc TangentPointCircles(){

ResetTransEachSL;
vector $directionABs[];
vector $PosABs[];
float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
//float $FloatDirXn[] = DirectionF($AverageVecXYZsOnP, $VecXYZs[0]);
float $R1=$ObjsCircles[0];

// P is the distance between 2 circles
float $P = $ObjsCircles[2];
float $r1 = $R1;
float $r1Z = $R1*2;
HightsOfIsoscelesTriangle($P, $r1Z, $P);
float $Pi = 3.1415926535;
float $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1Z 2.000`) - (`pow $P 2.000`) )/(2.000*$P*$r1Z)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN =   $AngleNPi;
//float $ts = atand( (`abs ($r1 - $r2)`) /$P);
float $MultDirPC1[] = multiplyFloat($r1, $directionABs[0]);
float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);

$AngleN = $Arcangle;
float $tsDAR = ( $AngleN)*-1;
float $tsDBR = ( $AngleN)*1;
//The first argument represents a point, the second an axis and the third an angle in radians
//the normal $directionABs[2]
float $rotatsA[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);


float $rotatsC[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPCB1[] = multiplyFloat($r1, $rotatsC);
float $AddMultDirPCB1[] = AddFloats($PosABs[1], $MultDirPCB1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB1);
float $rotatsD[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPCB2[] = multiplyFloat($r1, $rotatsD);
float $AddMultDirPCB2[] = AddFloats($PosABs[1], $MultDirPCB2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB2);
curve2points($AddMultDirPCA1, $AddMultDirPCB1);
curve2points($AddMultDirPCA2, $AddMultDirPCB2);

curve2points($AddMultDirPCA1, $PosABs[0]);
curve2points($AddMultDirPCA2, $PosABs[0]);
curve2points($AddMultDirPCA1, $PosABs[1]);
curve2points($AddMultDirPCA2, $PosABs[1]);

}





proc Loc(float $Points[]){
spaceLocator -p $Points[0] $Points[1] $Points[2];
}
proc CircleBetweenCircle(){

string $selectedObjects[];
clear $selectedObjects;
$selectedObjects = `ls -sl`;

// select -r $selectedObjects[0]; // CIRCLE A
string $CurveSelectionA[] = `ls -fl ($selectedObjects[0]+".ep[0]")`; 
string $CurveSelectionB[] = `ls -fl ($selectedObjects[1]+".ep[0]")`; 
 float $FloatPointA[];	
	$FloatPointA = `pointPosition -w  $CurveSelectionA[0]`;
 float $worldPosA[];
       $worldPosA = `xform -q -ws -a -rp $selectedObjects[0]`;
 float $CircleRadiusA = getDistance($FloatPointA, $worldPosA);

 float $FloatPointB[];	
	$FloatPointB = `pointPosition -w  $CurveSelectionB[0]`;
float $worldPosB[];
	$worldPosB= `xform -q -ws -a -rp $selectedObjects[1]`;
 float $CircleRadiusB = getDistance ($FloatPointB, $worldPosB);

float $MidPoints[];
$MidPoints = MidPoint($worldPosA,  $worldPosB);
spaceLocator -p $MidPoints[0] $MidPoints[1] $MidPoints[2];
ResetTransEachSL;
float $DirectionToMid[] = DirectionTwoPoints($worldPosA, $worldPosB);
float $DirectionToMid2R[] = DirectionTwoPoints($worldPosB, $worldPosA);
/////////////////////////
float $PointA[] = multiplyFloat($CircleRadiusA, $DirectionToMid2R);
//then Add $PointToMid to
float $CircPointA[] = AddFloats($worldPosA,$PointA);
Loc($CircPointA);


/////////////////////////
float $PointB[] = multiplyFloat($CircleRadiusB, $DirectionToMid);
//then Add $PointToMid to
float $CircPointB[] = AddFloats($worldPosB,$PointB);
Loc($CircPointB);
/////////////////////////
float $GlobalMiddle[] = MidPoint($CircPointA, $CircPointB);
Loc($GlobalMiddle);
float $CircleDistanceAB = `getDistance $worldPosB $worldPosA`;
float $GlobalDistanceAB = (`getDistance $CircPointA $CircPointB`)/2;
float $DistanceABRadusB = $CircleDistanceAB/2;


////////////////
float $CircleSTotalDistanceD =  $DistanceABRadusB + $CircleRadiusA + $CircleRadiusB;
float $FinalRadus = `abs ($CircleDistanceAB - $CircleRadiusA - $CircleRadiusB)`;
float $FinalRadusB = $FinalRadus/2;
float $DistanceToMiddle = $FinalRadusB + $CircleRadiusB;
$DistanceToMiddle = $DistanceToMiddle *-1;
float $PointToMid[] = multiplyFloat($DistanceToMiddle, $DirectionToMid);
Loc($PointToMid);

//then Add $PointToMid to
float $CirclePoint[] = AddFloats($worldPosB,$PointToMid);
Loc($CirclePoint);
string $circlesDAB[] = `circle -c $CirclePoint[0] $CirclePoint[1] $CirclePoint[2] -nr 0 1 0 -sw 360 -r $FinalRadusB -d 3 -ut 0 -tol 0.001 -s 8 -ch 1`;
ResetTransEachSL;

}

/*
float $ObjsCirclesRad[];
vector $PosABs[];
vector $directionABs[];
vector $CurveInter[] = TangentPointCirVectors( $ObjsCirclesRad, $PosABs, $directionABs);
*/

proc vector [] TangentPointCirVectors(float $ObjsCirclesRad[], vector $PosABs[], vector $directionABs2[] ){

vector $CircIntersectABs[];
float $R1=$ObjsCirclesRad[0];
float $R2=$ObjsCirclesRad[1];
// P is the distance between 2 circles
vector $directionABs[];
float $P = distance2Pts ($PosABs[0], $PosABs[1]);
$directionABs[0] = FloatToVec (DirectionF($PosABs[0],$PosABs[1]));
$directionABs[1] = FloatToVec (DirectionF($PosABs[1],$PosABs[0]));
float $r1 = $R1;
float $r2 = $R2;
float $Pi = 3.1415926535;
float $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN = $AngleNPi;
float $Lengths[] = HightsOfIsoscelesTriangle($P, $r1, $r2);
float $MultDirPCR1[] = multiplyFloat($r1, $directionABs[0]);
float $AddMultDirPCR1[] = AddFloats($PosABs[0], $MultDirPCR1);
float $MultDirPCR2[] = multiplyFloat($r2, $directionABs[1]);
float $AddMultDirPCR2[] = AddFloats($PosABs[1], $MultDirPCR2);
float $MidPointsA[];
$MidPointsA = MidPoint($AddMultDirPCR1, $AddMultDirPCR2);
float $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
float $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
////////////////////////////////////////////////
////////////////////////////////////////////////
$AngleN = $Arcangle;
float $tsDAR = ( $AngleN)*-1;
float $tsDBR = ( $AngleN)*1;
//The first argument represents a point, the second an axis and the third an angle in radians
//the normal $directionABs[2]
float $rotatsA[] = `rot $directionABs[0] $directionABs2[0] $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $directionABs2[0] $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);

$CircIntersectABs[0] = << $AddMultDirPCA1[0], $AddMultDirPCA1[1], $AddMultDirPCA1[2] >>;
$CircIntersectABs[1] = << $AddMultDirPCA2[0], $AddMultDirPCA2[1], $AddMultDirPCA2[2] >>;
return $CircIntersectABs;
}



proc vector [] TangentPointCirclesVec2(){
ResetTransEachSL;
vector $CircIntersectABs[];
vector $directionABs[];
vector $PosABs[];
float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
float $R1=$ObjsCircles[0];
float $R2=$ObjsCircles[1];
// P is the distance between 2 circles

float $P = distance2Pts ($PosABs[0], $PosABs[1]);
float $r1 = $R1;
float $r2 = $R2;
float $Pi = 3.1415926535;
float $Arcangle = acos ((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1))) ;
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN = $AngleNPi;
float $Lengths[] = HightsOfIsoscelesTriangle($P, $r1, $r2);
float $MultDirPCR1[] = multiplyFloat($r1, $directionABs[0]);
float $AddMultDirPCR1[] = AddFloats($PosABs[0], $MultDirPCR1);
float $MultDirPCR2[] = multiplyFloat($r2, $directionABs[1]);
float $AddMultDirPCR2[] = AddFloats($PosABs[1], $MultDirPCR2);
float $MidPointsA[];
$MidPointsA = MidPoint($AddMultDirPCR1, $AddMultDirPCR2);
float $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
float $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
////////////////////////////////////////////////
////////////////////////////////////////////////
$AngleN = $Arcangle;
float $tsDAR = ( $AngleN)*-1;
float $tsDBR = ( $AngleN)*1;
//The first argument represents a point, the second an axis and the third an angle in radians
//the normal $directionABs[2]
float $rotatsA[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);

$CircIntersectABs[0] = << $AddMultDirPCA1[0], $AddMultDirPCA1[1], $AddMultDirPCA1[2] >>;
$CircIntersectABs[1] = << $AddMultDirPCA2[0], $AddMultDirPCA2[1], $AddMultDirPCA2[2] >>;
return $CircIntersectABs;
}

/////////////////////////

/*
string $StraitCurve[] = `ls -sl`;
float $ArcLengthOne = `arclen $StraitCurve[0]`;
float $ArcLengthRadius = $ArcLengthOne/2;
float $ArcLenRadiusSDi = (`hypot $ArcLengthRadius $ArcLengthRadius`)*2;
float $ArcLenRadiusSRa = (`hypot $ArcLengthRadius $ArcLengthRadius`);

ResetTransEachSL;
vector $directionABs[];
vector $PosABs[];
float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
float $R1=$ObjsCircles[0];
float $R2=$ObjsCircles[1];

float $RadiusSRa1 = (`hypot $R1 $R1`);
float $RadiusSDi1 = $RadiusSRa1 *2;
float $RadiusSRa2 = (`hypot $R2 $R2`);
float $RadiusSDi2 = $RadiusSRa2 *2;

string $LargeCir[] = `ls -sl`;
float $CirclesRadiusLarge = CirclesRadius($LargeCir);
float $LarCirPos[] = `xform -q -ws -a -rp $LargeCir[0]`;

string $LargeCirIN[] = `ls -sl`;
float $CirclesRadiusLargeIN = CirclesRadius($LargeCirIN);
float $LarCirPosIN[] = `xform -q -ws -a -rp $LargeCirIN[0]`;

string $SmallCir[] = `ls -sl`;
float $CirclesRadiusSmall = CirclesRadius($SmallCir);
float $SmallCirPos[] = `xform -q -ws -a -rp $SmallCir[0]`;

float $r1 = $R1;
float $r2 = $R2;
float $r3 = $R1+$R2;


float $MultDirPCR1[] = multiplyFloat($r1, $directionABs[0]);
float $AddMultDirPCR1[] = AddFloats($PosABs[0], $MultDirPCR1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCR1);
float $MultDirPCR2[] = multiplyFloat($r2, $directionABs[1]);
float $AddMultDirPCR2[] = AddFloats($PosABs[1], $MultDirPCR2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCR2);

float $rad90 = `deg_to_rad 90`;
float $rad45 = `deg_to_rad 45`;
float $rad180 = `deg_to_rad 180`;

float $rotats90A[] = `rot $directionABs[0] $directionABs[2] $rad90`;
float $MultDir90PC1[] = multiplyFloat($r1, $rotats90A);
float $TopLargeInsideC[] = AddFloats($PosABs[0], $MultDir90PC1);
spaceLocator -p 0 0 0;
MoveObject2($TopLargeInsideC);
//Top Large Inside C
float $rotats90Az[] = `rot $directionABs[0] $directionABs[2] $rad180`;
float $MultDir90PC1z[] = multiplyFloat($r1, $rotats90Az);
float $pointX[] = AddFloats($PosABs[0], $MultDir90PC1z);
spaceLocator -p 0 0 0;
MoveObject2($pointX);
//Top Left Side Large Inside C pointX
float $rotats90B[] = `rot $directionABs[0] $directionABs[2] $rad90`;
float $MultDir90PC2[] = multiplyFloat($r2, $rotats90B);
float $TopSmallInsideC[] = AddFloats($PosABs[1], $MultDir90PC2);
spaceLocator -p 0 0 0;
MoveObject2($TopSmallInsideC);
//Top Small Inside C
float $rotats90Bz[] = `rot $directionABs[0] $directionABs[2] $rad45`;
float $MultDir90PC2z[] = multiplyFloat($RadiusSRa2, $rotats90Bz);
float $TopSmallInsideCz[] = AddFloats($PosABs[1], $MultDir90PC2z);
spaceLocator -p 0 0 0;
MoveObject2($TopSmallInsideCz);
float $rotz[] = `rot $directionABs[1] $directionABs[2] $rad180`;
float $Multz[] = multiplyFloat($r2, $rotz);
float $TopSmallz[] = AddFloats($PosABs[1], $Multz);
spaceLocator -p 0 0 0;
MoveObject2($TopSmallz);

float $RDirZ[] = DirectionF ($pointX, $TopSmallInsideCz);
float $RDirX[] = DirectionF ($PosABs[0], $TopLargeInsideC);
curve2points($pointX, $TopSmallInsideCz);
curve2points($PosABs[0], $TopLargeInsideC);

 float $GothlocsA[] = lineIntersection($AddMultDirPCR1, $RDirX, $pointX, $RDirZ );
spaceLocator -p 0 0 0;
MoveObject2($GothlocsA);

float $DisBetweenGothLocs = distance2Pts($AddMultDirPCR1,$GothlocsA);
float $DisAdding = $DisBetweenGothLocs;
vector $GothVecs[];
clear $GothVecs;
$GothVecs[0] = `FloatToVec($GothlocsA)`;
int $ixV = 0;
int $nNVi = 12;
float $Mul[],$Add[];
while ($nNVi > $ixV){
	$Mul = multiplyFloat($DisAdding, $RDirX);
	$Add = AddFloats($GothlocsA, $Mul);
$GothVecs[`size($GothVecs)`] = `FloatToVec($Add)`; 
$DisAdding += $DisBetweenGothLocs;
$ixV++;
}

print $GothVecs;
for ($each in $GothVecs){
Loc $each;
}


   
float $Z_zero[] = $pointX; 
float $intersectCPoint2[] = lineIntersectionF( $Z_zero, $GothVecs[1], $TopSmallz, $TopLargeInsideC);
spaceLocator -p 0 0 0;
MoveObject2($intersectCPoint2);

float $intersectCPoint3[] = lineIntersectionF( $LarCirPos, $GothVecs[1], $SmallCirPos, $GothVecs[3]);
spaceLocator -p 0 0 0;
MoveObject2($intersectCPoint3);

curve2points($Z_zero, $GothVecs[1]);
curve2points($TopSmallz, $TopLargeInsideC);

curve2points($LarCirPos, $GothVecs[1]);
curve2points($SmallCirPos, $GothVecs[3]);

//Pos 1 // $TopLargeInsideC//radius 1 // $RadiusSRa1//Pos 2 // $TopSmallInsideC//radius 2 //$RadiusSRa2
vector $PosABsZ[];
clear $PosABsZ;
float $ObjsCirclesRadZ[];
vector $directionABsZ[];
clear $directionABsZ;
$directionABsZ[0] = $directionABs[2];

$PosABsZ[0]= `FloatToVec $TopLargeInsideC`;
$ObjsCirclesRadZ[0]= $RadiusSRa1;
$PosABsZ[1]= `FloatToVec $LarCirPos`;
$ObjsCirclesRadZ[1]=  $CirclesRadiusLarge;
///////////////
///////////////
vector $CurveInter[];
clear $CurveInter;
	$CurveInter = TangentPointCirVectors( $ObjsCirclesRadZ, $PosABsZ, $directionABsZ);
print $CurveInter;
///////////////
//Below Compare Both Vecs to $pointX which is the point 
//where Both Larg inner Cirs Touch Outer Largest Circle Every other Circle is nested in
vector $CurveInterOne[];
clear $CurveInterOne;
 int $IFequivalent;
if(`size($CurveInter)`>1){
for ($eachVec in $CurveInter){
 $IFequivalent = PointsEquivalentTol ($pointX, $eachVec );
  	if (!($IFequivalent == 3)){  $CurveInterOne[`size($CurveInterOne)`]=$eachVec; 
$CurveInter = $CurveInterOne; break;
}
}
}

print  $CurveInterOne;
///////////////
///////////////

$PosABsZ[0]= `FloatToVec $TopLargeInsideC`;
$ObjsCirclesRadZ[0]= $RadiusSRa1;
$PosABsZ[1]= `FloatToVec $SmallCirPos`;
$ObjsCirclesRadZ[1]=  $CirclesRadiusSmall;

vector $CurveInter2[];
clear $CurveInter2;
	$CurveInter2 = TangentPointCirVectors( $ObjsCirclesRadZ, $PosABsZ, $directionABsZ);

//Below Compare Both Vecs to $AddMultDirPCR2 which is the point 
//where Both Larg & Small inner Cirs Touch

vector $CurveInterOneB[];
clear $CurveInterOneB;
 int $IFequivalent;
if(`size($CurveInter2)`>1){
for ($eachVec in $CurveInter2){
 $IFequivalent = PointsEquivalentTol ($AddMultDirPCR2, $eachVec );
  	if (!($IFequivalent == 3)){  $CurveInterOneB[`size($CurveInterOneB)`]=$eachVec; 
$CurveInter2 = $CurveInterOneB; break;
}
}
}

print $CurveInterOneB;
///////////////
///////////////

// Circle3PtZFloats($CurveInterOne[0], $CurveInterOneB[0], $intersectCPoint2);
 Circle3PtZFloats($CurveInterOne[0], $CurveInterOneB[0], $intersectCPoint2);
//####FIXXXXXXXXXXX
ResetTransEachSL;
string $NCir[] = `ls -sl`;
float $CirclesRadNCir = CirclesRadius($NCir);
float $NCirPos[] = `xform -q -ws -a -rp $NCir[0]`;

//$intersectCPoint2 
print $directionABs[2]

float $GothF[] = $GothVecs[1];
float $DirectF[] = $directionABs[2];
vector $PointTan[] = PointToCircleTangents($r1, $LarCirPosIN, $GothVecs[1],  $DirectF);
print $PointTan;

vector $PointTanOne[];
clear $PointTanOne;
 int $IFequivalent;
if(`size($PointTan)`>1){
for ($eachVecC in $PointTan){
 $IFequivalent = PointsEquivalentTol ($pointX, $eachVecC );
  	if (!($IFequivalent == 3)){  $PointTanOne[`size($PointTanOne)`]=$eachVecC; 
$PointTan = $PointTanOne; break;
}
}
}

Loc $PointTan[0];


float $intersectMiiPoint3[] = lineIntersectionF( $GothVecs[0], $CurveInterOneB[0], $TopSmallz, $TopSmallInsideCz);
spaceLocator -p 0 0 0;
MoveObject2($intersectMiiPoint3);

float $intersectMiiiP[] = lineIntersectionF( $CurveInterOneB[0], $GothVecs[0], $pointX, $TopSmallz);
spaceLocator -p 0 0 0;
MoveObject2($intersectMiiiP);


float $RDirXs[] = DirectionF ($TopSmallz,$intersectMiiPoint3);
float $DisBetween45DegSmalF = distance2Pts($TopSmallz,$intersectMiiPoint3);
float $DisAdding =  $DisBetween45DegSmalF ;
vector $s45Vecs[];
clear $s45Vecs;
$s45Vecs[0] = `FloatToVec($TopSmallz)`;
int $ixV = 0;
int $nNVi = 12;
float $Mul[],$Add[];
while ($nNVi > $ixV){
	$Mul = multiplyFloat($DisAdding, $RDirXs);
	$Add = AddFloats($TopSmallz, $Mul);
$s45Vecs[`size($s45Vecs)`] = `FloatToVec($Add)`; 
$DisAdding +=  $DisBetween45DegSmalF ;
$ixV++;
}

print $s45Vecs;
for ($each in $s45Vecs){
Loc $each;
}


int $Gg = 2;

// vector $PointTan[] = PointToCircleTangents($r1, $LarCirPosIN, $GothVecs[1],  $DirectF);
vector $PointTan2[] = PointToCircleTangents($CirclesRadiusLarge, $LarCirPos, $s45Vecs[$Gg], $DirectF);

$Gg = 4;
vector $PointTan3[] = PointToCircleTangents($CirclesRadNCir, $NCirPos, $s45Vecs[$Gg], $DirectF);
Loc $PointTan2[1];
Loc $PointTan3[1];
Loc $PointTan[0];

 Circle3PtZFloats($PointTan[0], $PointTan2[1], $PointTan3[1]);

ResetTransEachSL;
string $NCirB[]= `ls -sl` ;
float $CirclesRadNCir1 = CirclesRadius( $NCirB);
 float $NCirPosB[] = `xform -q -ws -a -rp $NCirB`;

int $Goth = 2;

int $Ag= 2;
int $Agg= 5;

$Gg = $Ag++;

vector $PointTan6[] = PointToCircleTangents($r1, $LarCirPosIN, $GothVecs[2],  $DirectF);

vector $PointTan4[] = PointToCircleTangents($CirclesRadiusLarge, $LarCirPos, $s45Vecs[3], $DirectF);

vector $PointTan5[] = PointToCircleTangents($CirclesRadNCir1, $NCirPosB, $s45Vecs[12], $DirectF);


$Goth++;

Loc $PointTan4[1];
Loc $PointTan5[0];
Loc $PointTan6[1];


 Circle3PtZFloats($PointTan4[1], $PointTan5[0], $PointTan6[1]);

ResetTransEachSL;
string $NCirB[]= `ls -sl` ;
float $CirclesRadNCir1 = CirclesRadius( $NCirB);
 float $NCirPosB[] = `xform -q -ws -a -rp $NCirB`;





vector $PointTan[] = PointToCircleTangents($r1, $LarCirPosIN, $GothVecs[1],  $DirectF);
vector $PointTan2[] = PointToCircleTangents($CirclesRadiusLarge, $LarCirPos, $s45Vecs[2], $DirectF);
vector $PointTan3[] = PointToCircleTangents($CirclesRadNCir, $NCirPos, $s45Vecs[4], $DirectF);
1
2
4

2
3
6
vector $PointTan6[] = PointToCircleTangents($r1, $LarCirPosIN, $GothVecs[2],  $DirectF);
vector $PointTan4[] = PointToCircleTangents($CirclesRadiusLarge, $LarCirPos, $s45Vecs[3], $DirectF);
vector $PointTan5[] = PointToCircleTangents($CirclesRadNCir1, $NCirPosB, $s45Vecs[6], $DirectF);



string $ObjectList[]= `ls -sl`;


vector $Vecs[]= PointArrayT($ObjectList);
print $Vecs;
//clear $Vecs;
float $FloatM1= $Vecs[0]*5;
vector $Vecsa= abs($Vecs[0]+$Vecs[1])+ abs ($Vecs[2]+$Vecs[3]) ;

float $FloatDirT[] = DirectionF($Vecs[0], $Vecs[1]);

float $intersectPii[] = lineIntersectionF( $Vecs[0], $Vecs[1], $Vecs[2], $Vecs[3]);
Loc $intersectPii;
// Result: 8 0 10 // 

	// Get the vector p1-p2, p3-p4
	// Get the vector  p3-p4
vector $Ui= $Vecs[0];
vector $Vi= $Vecs[1];
float $p1[] =  FloatToVec($Vecs[0]);
float $p2[] =  FloatToVec($Vecs[1]);
float $p3[] =  FloatToVec($Vecs[2]);
float $p4[] =  FloatToVec($Vecs[3]);

vector $Doti = ($Ui.x * $Vi.x) + ($Ui.y * $Vi.y) + ($Ui.z * $Vi.z);
vector $perp = ($Ui.x * $Vi.y) - ($Ui.y * $Vi.x);  //2D

vector $A1 =$Vecs[0];
vector $A2 =$Vecs[1];
vector $B1 =$Vecs[2];
vector $B2 =$Vecs[3];




sqrt (($A1.x*$A2.x) + ($A1.y*$A2.y) + ($A1.z*$A2.z));

vector $BB1 = `cross ($B2-$B1) ($A1-$B1)`;
vector $BB2 = `cross($A2-$A1) ($B2-$B1)`;
vector $AA1 = `cross ($A2-$A1) ($A1-$B1)`;
vector $AA2 = `cross($A2-$A1) ($B2-$B1)`;


float $nAa = `dot $BB1 $BB2`;
float $nBb = `dot $AA1 $AA2`;

// $nA = dot(cross($B2-$B1,$A1-$B1),cross($A2-$A1,$B2-$B1));
// $nB = dot(cross($A2-$A1,$A1-$B1),cross($A2-$A1,$B2-$B1));
// d = dot(cross($A2-$A1,$B2-$B1),cross($A2-$A1,$B2-$B1));
// A0 = $A1 + ($nA/d)*($A2-$A1);
// B0 = $B1 + ($nB/d)*($B2-$B1);

vector $DD1 =  `cross($A2-$A1) ($B2-$B1)`;
vector $CC1 =  `cross($A2-$A1) ($B2-$B1)`;


float $Dd = `dot  $DD1 $CC1` ;
float $A0 = $A1 + ($nAa/$Dd)*($A2-$A1);
float $B0 = $B1 + ($nBb/$Dd)*($B2-$B1);
	float $p1p2[3];
	float $p1p3[3];
	$p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
	$p1p3[0] = $p4[0]-$p3[0]; 		$p1p3[1] = $p4[1]-$p3[1]; 		$p1p3[2]= $p4[2]-$p3[2];

print $p1p2;
print $p1p3;


float $intersectPii[] = lineIntersectionF( $Vecs[0], $Vecs[1], $Vecs[2], $Vecs[3]);
print  $Vecs;
// Result: 8 0 10 // 
print  $Vecs;
6 0 2
7 0 6
4 0 10
10 0 10

float $normal[3];
	$normal = crossProduct( $p1p2, $p1p3, 0, 0 );
Loc $normal;
$x=dot(FloatToVec($p1p2), FloatToVec($p1p3));
$w=cross(FloatToVec($p1p2), FloatToVec($p1p3));

Loc $intersectPii;
vector $VecT1= $Vecs[0]+0;
vector $VecT2= $Vecs[3]+0;
vector $Vec11= $Vecs[0]-$Vecs[1];
vector $Vec22= $Vecs[2]-$Vecs[3];
Loc $Vec11;
Loc $Vec22;

cross $Vecs[0] $Vecs[1]

// Result: 12 0 10 // 
print $Vecs[0];
12 0 12
12 0 7

5 0 10
8 0 10

<<12, 0, 12>>
 <<0, 0, 5>>

<<8, 0, 10>>
<<-3, 0, 0>>

vector $VecOone = `FloatToVec($intersectPii)`;


$LarCirPos
$LarCirPosIN
$SmallCirPos

$CirclesRadNCir
$NCirPos

Loc $s45Vecs[3];



    vector   $u = $A2 - $A1;
    vector   $v = $B2 - $B1;
    vector   $w = $A2 - $B2;
dot $u $u;

    float    $a = `dot $u $u `;        // always >= 0
    float    $b = `dot $u $v `;
    float    $c = `dot $v $v `;        // always >= 0
    float    $d = `dot $u $w `;
    float    $e = `dot $v $w `;
    float    $D = $a*$c - $b*$b;       // always >= 0
    float    $sc, $tc;

//dot(u,v)   ((u).x * (v).x + (u).y * (v).y + (u).z * (v).z)
vector $Doti = ($Ui.x * $Vi.x) + ($Ui.y * $Vi.y) + ($Ui.z * $Vi.z);

norm(v)    sqrt(`dot $v $v` )


proc float dist3D_Line_to_Line( Line $L1, Line $L2)
{

float $SMALL_NUM = 0.00000001;

    Vector   $u = L1.P1 - L1.P0;
    Vector   $v = L2.P1 - L2.P0;
    Vector   $w = L1.P0 - L2.P0;

    float    $a = dot($u,$u);        // always >= 0
    float    $b = dot($u,$v);
    float    $c = dot($v,$v);        // always >= 0
    float    $d = dot($u,$w);
    float    $e = dot($v,$w);
    float    $D = $a*$c - $b*$b;       // always >= 0
    float    $sc, $tc;

    // compute the line parameters of the two closest points
    if ($D < $SMALL_NUM) {         // the lines are almost parallel
        $sc = 0.0;
        $tc = ($b>$c ? $d/$b : $e/$c);   // use the largest denominator
    }
    else {
        $sc = ($b*$e - $c*$d) / $D;
        $tc = ($a*$e - $b*$d) / $D;
    }

    // get the difference of the two closest points
    vector   $dP 
= $w + ($sc * $u) - ($tc * $v);  // = $L1($sc) - $L2($tc)

 sqrt(`dot $u $u` )

float $XX = ($sc)-($tc);


    return norm($dP);   // return the closest distance
}


// float $CircleRadiusA=$r1;
// float $worldPosA[] = $LarCirPosIN;
// float $worldPosB[]=$GothF;
// float $FloatDirNormal[]=$DirectF;


proc vector [] PointToCircleTangents(float $CircleRadiusA, float $worldPosA[], float $worldPosB[], float $DirNormalF[]){

vector $directionABs[];
float $R1 = $CircleRadiusA;
vector $DirNormal = FloatToVec ($DirNormalF);
$directionABs[0] = FloatToVec (DirectionF($worldPosA,$worldPosB));
$directionABs[1] = FloatToVec (DirectionF($worldPosB,$worldPosA));

// P is the distance between 2 circles
float $P = distance2Pts ($worldPosA, $worldPosB);
float $r1 = $R1;
float $r1Z = $R1*2;
//HightsOfIsoscelesTriangle($P, $r1Z, $P);
float $Pi = 3.1415926535;
float $Arcangle = acos((((`pow $P 2.000`) +  ((`pow $r1Z 2.000`) - (`pow $P 2.000`)) ) /(2.000*$P*$r1Z)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN =   $AngleNPi;
//float $ts = atand( (`abs ($r1 - $r2)`) /$P);
float $MultDirPC1[] = multiplyFloat($r1, $directionABs[0]);
float $AddMultDirPCA1[] = AddFloats($worldPosA, $MultDirPC1);

$AngleN = $Arcangle;
float $tsDAR = ( $AngleN)*-1;
float $tsDBR = ( $AngleN)*1;
//The first argument represents a point, the second an axis and the third an angle in radians
//$directionABs[1] is reverse for a reason
float $rotatsA[] = `rot $directionABs[1] $DirNormal $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($worldPosA, $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $DirNormal $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($worldPosA, $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);

vector $pointsT[];
$pointsT[0] = FloatToVec ($AddMultDirPCA1);
$pointsT[1] = FloatToVec ($AddMultDirPCA2);
return $pointsT;
}










*/





proc TangentPointCircles2(){
ResetTransEachSL;
vector $directionABs[];
vector $PosABs[];
float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
//float $FloatDirXn[] = DirectionF($AverageVecXYZsOnP, $VecXYZs[0]);
float $R1=$ObjsCircles[0];
float $R2=$ObjsCircles[1];

// P is the distance between 2 circles
float $P = $ObjsCircles[2];
float $r1 = $R1;
float $r2 = $R2;

float $Pi = 3.1415926535;
float $Arcangle = acos((((`pow $P 2.000`) + (`pow $r1 2.000`) - (`pow $r2 2.000`) )/(2.000*$P*$r1)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN = $AngleNPi;
float $Lengths[] = HightsOfIsoscelesTriangle($P, $r1, $r2);

//rotate -r -os 0 0 -29.65067 ;
// Result: Hight 4.990127 // 
// Result: BASE 8.77128 // 
// Result: BASE 5.953653 // 

//float $ts = atand( (`abs ($r1 - $r2)`) /$P);

float $MultDirPCR1[] = multiplyFloat($r1, $directionABs[0]);
float $AddMultDirPCR1[] = AddFloats($PosABs[0], $MultDirPCR1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCR1);
float $MultDirPCR2[] = multiplyFloat($r2, $directionABs[1]);
float $AddMultDirPCR2[] = AddFloats($PosABs[1], $MultDirPCR2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCR2);

float $MidPointsA[];
$MidPointsA = MidPoint($AddMultDirPCR1, $AddMultDirPCR2);
spaceLocator -p 0 0 0;
MoveObject2($MidPointsA);
float $distCircToMid = distance2Pts ($PosABs[0], $MidPointsA);
float $distCircToMidZ = distance2Pts ($AddMultDirPCR1, $AddMultDirPCR2);
spaceLocator -p 0 0 0;
MoveObject2($PosABs[0]);


////////////////////////////////////////////////
float $rRiP = $R1 + $R2;
float $PercentA = ((  $R2 /$rRiP) * (100.0) );
float $percentOf = $distCircToMidZ/ (100.0/$PercentA);
////////////////////////////////////////////////

float $distCircToMidA = $R1 - $percentOf;

float $MultDirPCRr1[] = multiplyFloat($distCircToMidA, $directionABs[0]);
float $AddMultDirPCRr1[] = AddFloats($PosABs[0], $MultDirPCRr1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCRr1);

//float $r1Z = $distCircToMidA*2;


$AngleN = $Arcangle;
float $tsDAR = ( $AngleN)*-1;
float $tsDBR = ( $AngleN)*1;
//The first argument represents a point, the second an axis and the third an angle in radians
//the normal $directionABs[2]
float $rotatsA[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);


float $rotatsC[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPCB1[] = multiplyFloat($r1, $rotatsC);
float $AddMultDirPCB1[] = AddFloats($PosABs[1], $MultDirPCB1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB1);
float $rotatsD[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPCB2[] = multiplyFloat($r1, $rotatsD);
float $AddMultDirPCB2[] = AddFloats($PosABs[1], $MultDirPCB2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB2);
curve2points($AddMultDirPCA1, $AddMultDirPCB1);
curve2points($AddMultDirPCA2, $AddMultDirPCB2);

curve2points($AddMultDirPCA1, $PosABs[0]);
curve2points($AddMultDirPCA2, $PosABs[0]);
curve2points($AddMultDirPCA1, $PosABs[1]);
curve2points($AddMultDirPCA2, $PosABs[1]);

}



TangentPointCircles;
CircleBetweenCircle;
TangentCircles;



proc TangentCircles(){
ResetTransEachSL;
vector $directionABs[];
vector $PosABs[];
float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
//float $FloatDirXn[] = DirectionF($AverageVecXYZsOnP, $VecXYZs[0]);
float $R1=$ObjsCircles[0];
float $R2=$ObjsCircles[1];

// P is the distance between 2 circles
float $P = $ObjsCircles[2];

float $DiCircleInBetween = $P -($R1 + $R2);
float $RadiCircleInBetween = $DiCircleInBetween/2;
float $DisCircBetweenFromR1 = $R1+$RadiCircleInBetween ;
//mult Direction Circ1 to Circ 2 by distance DisCircBetweenFromR1 
//add to Pos Circ R1 

float $MultDirM[] = multiplyFloat($DisCircBetweenFromR1, $directionABs[0]);
float $AddMultM[] = AddFloats($PosABs[0], $MultDirM);
spaceLocator -p 0 0 0;
MoveObject2($AddMultM);
string $circlesM = Circles_Direction($AddMultM,$directionABs[2], $RadiCircleInBetween);

float $Rn1 =  (1.0/(`sqrt $R1`)) + (1.0/(`sqrt $R2` ));
float $Rn = 1.0/$Rn1;
float $R = `pow $Rn 2`;
float $xc = `sqrt (4*$R1*$R)`;
float $yc = `sqrt (4*$R2*$R)`;
float $CurveL = $xc+$yc;
float $pi = 3.1415926535;

float $r1 = $R1;
float $r2 = $R2;
//float $ts = atand( (`abs ($r1 - $r2)`) /$P);

float $ts = acos ( (`abs ($r1 - $r2)`) /$P);
float $tsD = (`rad_to_deg $ts`);
float $tsDA = (`rad_to_deg $ts`)*1;
float $tsDB = (`rad_to_deg $ts`)*-1;
float $tsDAR = ( $ts)*1;
float $tsDBR = ( $ts)*-1;
//The first argument represents a point, the second an axis and the third an angle in radians
//the normal $directionABs[2]
float $rotatsA[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);
float $rotatsC[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPCB1[] = multiplyFloat($r2, $rotatsC);
float $AddMultDirPCB1[] = AddFloats($PosABs[1], $MultDirPCB1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB1);
float $rotatsD[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPCB2[] = multiplyFloat($r2, $rotatsD);
float $AddMultDirPCB2[] = AddFloats($PosABs[1], $MultDirPCB2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB2);
curve2points($AddMultDirPCA1, $AddMultDirPCB1);
curve2points($AddMultDirPCA2, $AddMultDirPCB2);


float $FloatDirectionTa1Tb2[] = DirectionF($AddMultDirPCA1, $AddMultDirPCB1);
float $MultDirT[] = multiplyFloat($xc, $FloatDirectionTa1Tb2);
float $FloatDirT[] = AddFloats($AddMultDirPCA1, $MultDirT);
float $FloatDirectionTCa[] = DirectionF($AddMultDirPCA1, $PosABs[0]);
float $MultDirTCa[] = multiplyFloat($R, $FloatDirectionTCa);
float $FloatDirTc[] = AddFloats($FloatDirT, $MultDirTCa);
spaceLocator -p 0 0 0;
MoveObject2($FloatDirTc);
string $circlesA = Circles_Direction($FloatDirTc,$directionABs[2], $R);
float $FloatDirectionTa1Tb3[] = DirectionF($AddMultDirPCA2, $AddMultDirPCB2);
float $MultDirTCb[] = multiplyFloat($xc, $FloatDirectionTa1Tb3);
float $FloatDirTb[] = AddFloats($AddMultDirPCA2, $MultDirTCb);
float $FloatDirectionTCb[] = DirectionF($AddMultDirPCA2, $PosABs[0]);
float $MultDirTCb[] = multiplyFloat($R, $FloatDirectionTCb);
float $FloatDirTcb[] = AddFloats($FloatDirTb, $MultDirTCb);
spaceLocator -p 0 0 0;
MoveObject2($FloatDirTcb);
string $circlesA = Circles_Direction($FloatDirTcb,$directionABs[2], $R);

}

proc float [] MultLenToDirAddToPoint(float $Length, float $Dir[], float $Pos[]){
float $MultLengthDir[] = multiplyFloat($Length, $Dir);
float $AddMultDirPos[] = AddFloats($Pos, $MultLengthDir);
return $AddMultDirPos;
}

proc TangentCircleBetweenCircle(){
string $circles[] = `ls -sl`;
ResetTransEachSL;
vector $directionABs[];
vector $PosABs[];
float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
//float $FloatDirXn[] = DirectionF($AverageVecXYZsOnP, $VecXYZs[0]);
float $R1=$ObjsCircles[0];
float $R2=$ObjsCircles[1];

float $Rn1 =  (1.0/(`sqrt $R1`)) + (1.0/(`sqrt $R2` ));
float $Rn = 1.0/$Rn1;
float $R = `pow $Rn 2`;

float $xc = `sqrt (4*$R1*$R)`;
float $yc = `sqrt (4*$R2*$R)`;
float $CurveL = $xc+$yc;
float $pi = 3.1415926535;

// P is the distance between 2 circles
float $P = $ObjsCircles[2];
float $r1 = $R1;
float $r2 = $R2;
//float $ts = atand( (`abs ($r1 - $r2)`) /$P);

float $ts = acos ( (`abs ($r1 - $r2)`) /$P);
float $tsD = (`rad_to_deg $ts`);
float $tsDA = (`rad_to_deg $ts`)*1;
float $tsDB = (`rad_to_deg $ts`)*-1;
float $tsDAR = ( $ts)*1;
float $tsDBR = ( $ts)*-1;
//The first argument represents a point, the second an axis and the third an angle in radians
//the normal $directionABs[2]
float $rotatsA[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);
float $rotatsC[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPCB1[] = multiplyFloat($r2, $rotatsC);
float $AddMultDirPCB1[] = AddFloats($PosABs[1], $MultDirPCB1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB1);
float $rotatsD[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPCB2[] = multiplyFloat($r2, $rotatsD);
float $AddMultDirPCB2[] = AddFloats($PosABs[1], $MultDirPCB2);
spaceLocator -p 0 0 0;

MoveObject2($AddMultDirPCB2);
curve2points($AddMultDirPCA1, $AddMultDirPCB1);

curve2points($AddMultDirPCA2, $AddMultDirPCB2);

float $Uall[];
string $myCPOCA = `closestPointOnCurve -na "myClosestPointOnCurve" -ip $AddMultDirPCA1[0] $AddMultDirPCA1[1] $AddMultDirPCA1[2] $circles[0]`;
float $U = `getAttr ($myCPOCA+".u")`;
$Uall[`size($Uall)`]= $U;
setAttr ($myCPOCA+".inPosition") $AddMultDirPCA2[0] $AddMultDirPCA2[1] $AddMultDirPCA2[2];
 $U = `getAttr ($myCPOCA+".u")`;
$Uall[`size($Uall)`]= $U;

//PART 1//////////////////////////////////////////////////////////////

string $UpointCurveOne[];
$UpointCurveOne[0] = ($circles[0] + ".u[" + $Uall[0] + "]");
$UpointCurveOne[1] = ($circles[0] + ".u[" + $Uall[1] + "]");

//PART 2//////////////////////////////////////////////////////////////

string $UpointCurve2A = ($selectedObjects[1] + ".u[" + $buffer2[0] + "]");
string $UpointCurve2B = ($selectedObjects[1] + ".u[" + $buffer2[1] + "]");

/////////////////////////////////////////////////////////////////////////

string $NewcurvesA[];
string $DetachReturn[];
int $Ix=0;
for ($each in $AddMultDirPCA2){
$DetachReturn =  `detachCurve -ch 0 -cos off -rpo 1 $UpointCurveOne[$Ix]` ;
for ($eachD in $DetachReturn){
$NewcurvesA[`size($NewcurvesA)`] = $eachD; }
$Ix++;
}



print $NewcurvesA;

string $NewcurvesA[] = `detachCurve -ch 1 -cos on -rpo 1 $UpointCurveOne[0] $UpointCurveOne[1]`;


detachCurve -ch 0 -cos off -rpo 1 $UpointCurve2A;
string $NewcurvesB[] = `detachCurve -ch 0 -cos off -rpo 1 $UpointCurve2B`;
select -r $NewcurvesA $NewcurvesB;
ResetTransEachSL;

int $ZeroOrOneC1 = 0;
string $CenterCurvesA[];
string $OuterCurvesA[];
vector $AposD1[];
int $iXv = 0;
for ($each in $NewcurvesA){
	$AposD1[$iXv] = `xform -q -ws -a -rp $each`;
if($iXv==1){
$ZeroOrOneC1 = FindclosetTOcurveENDz($AposD1[0], $AposD1[1], $MidPoints);
}
$iXv++;
}
int $OuterC1 = 0;
if($ZeroOrOneC1==0){ $OuterC1 = 1;}

$OuterCurvesA[0] = $NewcurvesA[$OuterC1];
$CenterCurvesA[0] = $NewcurvesA[$ZeroOrOneC1];

int $ZeroOrOneC2 = 0;
string $CenterCurvesB[];
string $OuterCurvesB[];
vector $AposD2[];
int $iIXv = 0;
for ($each in $NewcurvesB){
	$AposD2[$iIXv] = `xform -q -ws -a -rp $each`;
if($iIXv==1){
$ZeroOrOneC2 = FindclosetTOcurveENDz($AposD2[0], $AposD2[1], $MidPoints);
}
$iIXv++;
}


int $OuterC2 = 0;
if($ZeroOrOneC2==0){ $OuterC2 = 1;}


$OuterCurvesB[0] = $NewcurvesB[$OuterC2];
$CenterCurvesB[0] = $NewcurvesB[$ZeroOrOneC2];

select -r $OuterCurvesA $OuterCurvesB;
select -r $CenterCurvesA $CenterCurvesB;



delete $paramlocatorC $paramlocatorD;
delete $CenterCurvesA $CenterCurvesB $circlesItem;



}



proc TangentCirclesAtand(string $MathCommand){
ResetTransEachSL;
string $CirclesSelected[] =`ls -sl`;
vector $directionABs[];
vector $PosABs[];
float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
//float $FloatDirXn[] = DirectionF($AverageVecXYZsOnP, $VecXYZs[0]);
float $R1=$ObjsCircles[0];
float $R2=0;

float $Rn1 =  (1.0/(`sqrt $R1`)) ;
float $Rn = 1.0/$Rn1;
float $R = `pow $Rn 2`;
float $xc = `sqrt (4*$R1*$R)`;
float $yc = `sqrt (4*$R2*$R)`;
float $CurveL = $xc+$yc;
float $pi = 3.1415926535;
// P is the distance between 2 circles
float $P = $ObjsCircles[2];
float $r1 = $R1;
float $r2 = $R2;
//float $ts = acos( (`abs ($r1 - $r2)`) /$P);
float $ts ;
//$stringCommand = ("$ts = "+$MathCommand+"( (`abs ($r1 - $r2)`));");
string  $stringCommand = ( $MathCommand+"(($r1 - $r2)/$P);");
$ts = evalEcho($stringCommand);
print $ts ;

//float $ts =atand( (`abs ($r1 - $r2)`) /$P);
//float $ts = atand( ($r1 - $r2) /$P);

float $tsD = (`rad_to_deg $ts`);
float $tsDA = (`rad_to_deg $ts`)*1;
float $tsDB = (`rad_to_deg $ts`)*-1;
float $tsDAR = ( $ts)*1;
float $tsDBR = ( $ts)*-1;
//The first argument represents a point, the second an axis and the third an angle in radians
//the normal $directionABs[2]
float $rotatsA[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPC1[] = multiplyFloat($r1, $rotatsA);
float $AddMultDirPCA1[] = AddFloats($PosABs[0], $MultDirPC1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA1);
float $rotatsB[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPC2[] = multiplyFloat($r1, $rotatsB);
float $AddMultDirPCA2[] = AddFloats($PosABs[0], $MultDirPC2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCA2);
float $rotatsC[] = `rot $directionABs[0] $directionABs[2] $tsDAR`;
float $MultDirPCB1[] = multiplyFloat($r2, $rotatsC);
float $AddMultDirPCB1[] = AddFloats($PosABs[1], $MultDirPCB1);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB1);
float $rotatsD[] = `rot $directionABs[0] $directionABs[2] $tsDBR`;
float $MultDirPCB2[] = multiplyFloat($r2, $rotatsD);
float $AddMultDirPCB2[] = AddFloats($PosABs[1], $MultDirPCB2);
spaceLocator -p 0 0 0;
MoveObject2($AddMultDirPCB2);
curve2points($AddMultDirPCA1, $AddMultDirPCB1);
curve2points($AddMultDirPCA2, $AddMultDirPCB2);
float $FloatDirectionTa1Tb2[] = DirectionF($AddMultDirPCA1, $AddMultDirPCB1);
float $MultDirT[] = multiplyFloat($xc, $FloatDirectionTa1Tb2);
float $FloatDirT[] = AddFloats($AddMultDirPCA1, $MultDirT);
float $FloatDirectionTCa[] = DirectionF($AddMultDirPCA1, $PosABs[0]);
float $MultDirTCa[] = multiplyFloat($R, $FloatDirectionTCa);
float $FloatDirTc[] = AddFloats($FloatDirT, $MultDirTCa);
spaceLocator -p 0 0 0;
MoveObject2($FloatDirTc);
string $circlesA = Circles_Direction($FloatDirTc,$directionABs[2], $R);
float $FloatDirectionTa1Tb3[] = DirectionF($AddMultDirPCA2, $AddMultDirPCB2);
float $MultDirTCb[] = multiplyFloat($xc, $FloatDirectionTa1Tb3);
float $FloatDirTb[] = AddFloats($AddMultDirPCA2, $MultDirTCb);
float $FloatDirectionTCb[] = DirectionF($AddMultDirPCA2, $PosABs[0]);
float $MultDirTCb[] = multiplyFloat($R, $FloatDirectionTCb);
float $FloatDirTcb[] = AddFloats($FloatDirTb, $MultDirTCb);
spaceLocator -p 0 0 0;
MoveObject2($FloatDirTcb);
string $circlesA = Circles_Direction($FloatDirTcb,$directionABs[2], $R);

select -r $CirclesSelected;
}



proc float [] Normal3Points(float $p1[],float $p2[],float $p3[]){ 

float $center[]; 
float $normal[];
	// Get the vector p1-p2, p1-p3
	//
	float $p1p2[3];
	float $p1p3[3];	
	$p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
	$p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
      	// Get the normal to the plane formed by p1, p2, p3, which is the
	// cross prod of p1-p2 and p1-p3	
	vector $normalV[];
	$normalV = crossProduct( $p1p2, $p1p3, 0, 0 );
float $normal[] = `unit $normalV[0]`;
return $normal;
}

proc MatchCurveLengthToCurve(){
string $Objs[] =`ls -sl`;
int $sizeCs = (`size($Objs)`)-1;
string $ObjsEnd[] =`ls -tl $sizeCs $Objs`;
string $ObjsFirst[] =`ls -hd 1 $Objs`;
float $compare = `arclen $ObjsFirst`;
float $ArcLengthAdd;
for($each in $ObjsEnd){
$ArcLengths = `arclen $each`;
$ArcLengthAdd = $compare - $ArcLengths;
if($ArcLengthAdd>0){
extendCurve -cos 0 -ch 1 -em 0 -et 0 -d $ArcLengthAdd  -s 0 -jn true -rmk true -rpo on $each ;
}

}
}


proc CurveLengthToFloat(float $Number){
string $Objs[] =`ls -sl`;
for($each in $Objs){
$ArcLengths = `arclen $each`;
$ArcLengthAdd = $Number - $ArcLengths;
if($ArcLengthAdd>0){
extendCurve -cos 0 -ch 1 -em 0 -et 0 -d $ArcLengthAdd  -s 0 -jn true -rmk true -rpo on $each ;
}
}
}

proc float TotalArcLength(){
string $Objs[] =`ls -sl`;
float $ArcLengths = 0.0;
for($each in $Objs){
$ArcLengths += `arclen $each`;
}
return $ArcLengths;
}

proc string makeCurvePointDirectionLength(float $Length, float $Direction[], float $posA[]){
float $MultDir[] = multiplyFloat($Length,  $Direction);
float $FloatDirectionNormalA[] = AddFloats($posA, $MultDir);
string $CurveBetween;
$CurveBetween = curve2points($posA,  $FloatDirectionNormalA);
return $CurveBetween;
}

proc vector[] PointArray(string $ObjectList[]){

float $pointAZ1[];
vector $VecArray[];
int $XiV = 0;
for ($each in $ObjectList){
if (catch($pointAZ1 = `pointPosition -w ($each)`)){
$pointAZ1 = `xform -q -ws - rp ($each)`;
} 
$VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
$XiV++;
}
return $VecArray;
}





proc float [] HightsOfIsoscelesTriangle(float $SideA, float $SideB, float $SideC){

float $Pi = 3.1415926535;
float $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN = $AngleNPi;
print $AngleN;
print "//";

float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
float $ArcangleC2 = $ArcangleC*2.0;
print $ArcangleC2;
float $AngleNB = 180.00 -($ArcangleC2 + $AngleNPi) ;
float $Angle_a = $ArcangleC2; 
float $Angle_b = $AngleN; 
float $Angle_c = $AngleNB;

float $AngleN2 = 180.0 -($Angle_b + $Angle_c) ;
//Two are the same//
float $Angle_A = $AngleN2; 
float $Angle_B = $AngleN; 
float $Angle_C = $AngleN;
//Angle of Right Tri in Isoceles
float $AngleOfRightAndA = (180.000 -($AngleN2 +90.000));
float $AngleOfRightA = ($AngleOfRightAndA/180.000)*$Pi;
float $AngleN2R = ($AngleN2/180.0000)*$Pi; 
float $HightfromB = sqrt ( ((`pow $SideA 2.000`) + (`pow $SideC 2.000`)) - ((2.000*$SideA*$SideC)*(`cos($AngleN2R+$AngleN2R )`)) )/2.000 ;
float $AngleOfRightA = ($AngleOfRightAndA/180.0000)*$Pi;
float $HightfromC = sqrt ( ((`pow $SideA 2.000`) + (`pow $SideC 2.000`)) - ((2.000*$SideA*$SideC)*(`cos ($AngleOfRightA*2.000 )`)) )/2.000 ;
float $HightsCandB[] = { $HightfromC, $HightfromB};
return $HightsCandB;

}

////////////////////////////////////////
proc float [] AnglesofTriangle(float $SideA, float $SideB, float $SideC){

float $Pi = 3.1415926535;
float $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN = $AngleNPi;

float $Arcangle = acos((((`pow $SideA 2.000`) + (`pow $SideB 2.000`) - (`pow $SideC 2.000`) )/(2.000*$SideA*$SideB)));
float $AngleNPi =  ($Arcangle*180)/$Pi;
float $AngleN = $AngleNPi;

float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideC 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideC)));
float $ArcangleC2 = $ArcangleC*2.0;
float $AngleNB = 180.00 -($ArcangleC2 + $AngleNPi) ;
float $Angle_a = $ArcangleC2; 
float $Angle_b = $AngleN; 
float $Angle_c = $AngleNB;
float $Add = $Angle_a + $Angle_b + $Angle_c;
float $Angle_ABC[] = {$Angle_a, $Angle_b, $Angle_c} ;
return $Angle_ABC;
}
////////////////////////////////////////
//
/*
// AngleOfTriangle
string $ObjsCurve[] =`ls -sl`;
float $allcurveLengths[] = ArcLengthArray($ObjsCurve);
float $SideA = $allcurveLengths[0];
float $SideB = $allcurveLengths[1];
float $SideC = $allcurveLengths[2];

 AnglesofTriangle($SideA, $SideB, $SideC);
float $A = AnglesofTriangle($SideC, $SideA, $SideB);
 AnglesofTriangle($SideB, $SideC, $SideA);


float $A = $allcurveLengths*$allcurveLengths;

rotate -r -os 0 -75.605364 0 ;

*/

proc float [] ArcLengthArray(string $Objs[]){
float $ArcLengths[];
for($each in $Objs){
$ArcLengths[`size($ArcLengths)`]= `arclen $each`;
}
return $ArcLengths;
}

//CircleFromCurveZYX 1 0 0;

	proc CircleFromCurveT(){
string $StraitCurve[] = `ls -sl`;
ResetTransEachSL;
float $ArcLengthOne = `arclen $StraitCurve[0]`;
$ArcLengthOne = $ArcLengthOne/2;
float $CurvPos[] = `xform -q -ws -rp $StraitCurve[0]`;
float $tangent[] = `pointOnCurve -t -pr 0.5 $StraitCurve[0]`;
$tangent = `unit <<$tangent[0], $tangent[1], $tangent[2]>>`;
string $circles = Circles_Direction($CurvPos, $tangent, $ArcLengthOne);
ResetTransEachSL;
}

/*
string $StraitCurve[] = `ls -sl`;
float $ArcLengthOne = `arclen $StraitCurve[0]`;
float $ArcLengthRadius = $ArcLengthOne/2;
float $ArcLenRadiusSDi = (`hypot $ArcLengthRadius $ArcLengthRadius`)*2;
float $ArcLenRadiusSRa = (`hypot $ArcLengthRadius $ArcLengthRadius`);

ResetTransEachSL;
vector $directionABs[];
vector $PosABs[];
float $ObjsCircles[] = CirclesRadiusDirection($directionABs, $PosABs);
float $R1=$ObjsCircles[0];
float $R2=$ObjsCircles[1];

float $ArcLenRadiusSRa1 = (`hypot $R1 $R1`);
float $ArcLenRadiusSDi1 = $ArcLenRadiusSRa1 *2;

*/

//CircleFromCurveRadiusZYX 1 0 0;

	proc CircleFromCurveRadiusZYX(int $X, int $Y, int $Z ){
string $StraitCurve[] = `ls -sl`;
ResetTransEachSL;
float $ArcLengthOne = `arclen $StraitCurve[0]`;
float $CurvPos[] = `xform -q -ws -rp $StraitCurve[0]`;
float $t[3], $n[3];
  vector $tan, $norm, $bi;
   //$t $n are just directions....
    $t = `pointOnCurve -ch off -pr 0.5 -nt $StraitCurve[0]`;
    $n = `pointOnCurve -ch off -pr 0.5 -nn $StraitCurve[0]`;
    // Maya promises normalized tangent and normal,
    // but they really aren't.    
    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
//## Note the int One 1 inthe middle...
    $norm = `unit << $X, $Y, $Z >>`;    
    // Calculate the binormal.   
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
                 << ($norm.x), ($norm.y), ($norm.z) >>`;
    $bi = `unit $bi`;
string $circles = Circles_Direction($CurvPos,$bi, $ArcLengthOne);
ResetTransEachSL;
}


	proc CircleFromCurveN(int $X, int $Y, int $Z ){
string $StraitCurve[] = `ls -sl`;
ResetTransEachSL;
float $ArcLengthOne = `arclen $StraitCurve[0]`;
$ArcLengthOne = $ArcLengthOne/2;
float $CurvPos[] = `xform -q -ws -rp $StraitCurve[0]`;
float $t[3], $n[3];
  vector $tan, $norm, $bi;

   //$t $n are just directions....
    $t = `pointOnCurve -ch off -pr 0.5 -nt $StraitCurve[0]`;
    $n = `pointOnCurve -ch off -pr 0.5 -nn $StraitCurve[0]`;
    // Maya promises normalized tangent and normal,
    // but they really aren't.    
    $tan  = `unit << $t[0], $t[1], $t[2] >>`;
//## Note the int One 1 inthe middle...
    $norm = `unit << $n[0], $n[0], $n[0] >>`;    
    // Calculate the binormal.   
    $bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
                 << ($norm.x), ($norm.y), ($norm.z) >>`;
    $bi = `unit $bi`;
string $circles = Circles_Direction($CurvPos,$bi, $ArcLengthOne);
ResetTransEachSL;
}





proc string [] SteinerChain(float $RAa, float $RBb){

//
//float $RA = 22.0;
//float $RB = 15.680;

float $pi = 3.1415926535;
float $Pi = 3.1415926535;
float $RA;
float $RB;

string $circleA[];
string $circleB[];
string $circles[];


if(!( $RAa==$RBb)){
if( $RAa<$RBb){
$RA = $RBb;
$RB = $RAa;}else{ $RA = $RAa; $RB =  $RBb;}

//float $RA = 22.0;
//float $RB = 15.68;



$circleA = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RA -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
$circleB = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $RB -d 3 -ut 0 -tol 0.001 -s 32 -ch 1`;
float $R2 = $RA;
float $R1 = $RB;
float $DCircle = (($R2 - $R1)/2.0) + $R1 ;
float $Rii = (($R2 - $R1)/2.0);

float $SideA = $RB + $Rii;
float $SideB = $Rii*2;

//GOT it for SURE
//HightsOfIsoscelesTriangle($SideA, $SideB, $SideA)
float $ArcangleC = asind((((`pow $SideB 2.000`) + (`pow $SideA 2.000`) - (`pow $SideA 2.000`) )/(2.000*$SideB*$SideA)));
float $ArcangleC2 = $ArcangleC*2.0;

float $Aii =  (`asin ($RB/($RB + $Rii))`);
//float $Ni = $pi/$Aii;
//  $Ni = (rad_to_deg($Aii)) ;


float $number3 = 360.0/$ArcangleC2; 

float $NofCirclesC = ((`sin 1`)*($pi)) / (( ($R2 - $R1)/($R2 + $R1)/1) );
float $NofCirclesA = ((`cos 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );
float $NofCirclesB = ((`tan 1`)*($pi)) / ( ($R2 - $R1)/($R2 + $R1) );

float $NofCirclesa =  (($pi)/ (`acos (($R2 - $R1)/($R2 + $R1))`));
float $NofCirclesb =  ($pi)/ (`atan (($R2 - $R1)/($R2 + $R1))`);
float $NofCirclesc =   ($pi)/(`asin (($R2 - $R1)/($R2 + $R1))`);

//float $subtract = ($NofCirclesa -($NofCirclesb + $NofCirclesc))*4;
//float $subtract = $NofCirclesB - $NofCirclesA;
//float $subtract = ($subtract + $NofCirclesC)/2;
//float $subtractA = (($NofCirclesB - $NofCirclesA)+ $NofCirclesC)/2;
//float $subtractB = ($NofCirclesA - $NofCirclesC+$NofCirclesB)/2;
//float $number3 = 360/$NofCirclesC; 
//
//float $Ni = (rad_to_deg($subtract)) ;
//float $Ni = $pi/ $subtract;
//float $number3 = 360/$Ni; 
//$number3 = $subtract;

//float $subtract = ($NofCirclesA - $NofCirclesC+$NofCirclesB)/2;
/*
float $dec = 1; 
 float $val= $subtract*0.1;
  	$sign = `sign $val`;
  	float $dec = `pow 10 $dec`;
  	$val = (int) (($val + $sign*5/($dec*10))  * $dec);
  	$val = ($val / $dec);
	$val = $val*10;
$subtract = $val;
//float $subtract = ($NofCirclesA - $NofCirclesC+$NofCirclesB)/2;
*/
int $NumberCs = $number3;
int $n = $NumberCs;
float $len = $DCircle;
float $r = $DCircle;
	float $x[] = createRegularPolygonX( $n, $r ) ;
	float $y[] = createRegularPolygonY( $n, $r ) ;
	// create the n-sided polygon. 
string $circlesC[];
	float $z = 0.0 ;
	int $i ;
	for( $i = 0 ; $i < $n ; $i++ ) {
$circlesC = `circle -c $x[$i] $y[$i] $z -nr 0 0 1 -sw 360 -r $Rii -d 3 -ut 0 -tol 0.001 -s 16 -ch 1`;

$circles[`size($circles)`] = $circlesC[0];
makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $circles[0];
xform -cp $circles[0];
//rotate -r -os 0 0 45 $circles[0];
//aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "scene" $circleB[0] $circles[0];
	
	}


//$circles[`size($circles)`] = $circleA[0];
//$circles[`size($circles)`] = $circleB[0];

select -r $circleA $circleB $circles ;
//select -r $circles ;
return $circles;
}
}


proc string[] CycleNumberString(string  $singleStringItemC[]){
int $SizeOfArray;
$SizeOfArray = size($singleStringItemC) -1;
string $last[0] = {$singleStringItemC [$SizeOfArray]};
string $first[0] = {$singleStringItemC[0]};
  stringArrayRemoveAtIndex(0,  $singleStringItemC);
  appendStringArray($singleStringItemC, $first,  1);
return $singleStringItemC; 
}


/*

string $Circ[] = SteinerChain(22.0, 17.00);

int $Sc = (`size($Circ)`);
int $ScH =($Sc/2)-3;
int $ix = 0;
int $ix2 = 1;
while($ix < $Sc){
select -r $Circ[0] $Circ[$ScH];
$Circ = CycleNumberString($Circ);
TangentCircles;
if($ix2==($Sc-1)){$ix2=-1;}
 $ix++;
$ix2++;
}

for ($each in $circles){
select -r $circleB ;
select -tgl $each;
TangentCircles;}



float $As = 22.0;
float $Bs = 0.05;
int $c;
int $S = 340;
int $sizeN ;
int $sizeNa ;
string $circ[];
string $circL[];
clear $circL;
  for($c = 1; $c <= $S; $c++ ){
$sizeNa = $sizeN;
if(`size( $circL)`>0){ delete $circL; clear $circL;
}
 $circ =  SteinerChain($As, $Bs) ;
$circL = $circ;
$sizeN = `size( $circ)`;
PAUSE; 

$As += 0.00;
$Bs += 0.00521;

}

print $Bs;
  proc float round(float $val,float $dec){
int $Xn = 5;
//float $dec = 0;
//float $val = 42.02;
int $Dn = $dec;
int $Dn2 = $dec;
float $divideAs = $val/2;
float $divideA = $val/5;
float $divideB = $val/10;
float $divideC = $val/100;
float $divideD = $val/1000;
if ($divideAs < 1) { $Xn = 1; $Dn = 2; $Dn2 = 1; }
if (($divideAs > 1) && ($divideA < 1)) { $Xn = 1; $Dn = 2; $Dn2 = 1;}
if (($divideA > 1) && ($divideB < 1)) { $Xn = 5; }
if (($divideB > 1) && ($divideC < 1)) { $Xn = 10; }
if (($divideC > 1) && ($divideD < 1)) { $Xn = 50; }
//print ($Xn + "\n");
$dec = $Dn;
$sign = `sign $val`;
  	float $dec = `pow 10 $dec`;
  	$val = (int) (($val + $sign*5/($dec*10)) * $dec);
  	$val = ($val / $dec);

float $divide = $val/$Xn;
 float $val2 = $divide;
float $dec2 = $Dn2;
$sign2 = `sign $val2`;
  	float $dec2 = `pow 10 $dec2`;
  	$val2 = (int) (($val2 + $sign*5/($dec2*10)) * $dec2);
  	$val2 = ($val2 / $dec2);
float $times = $val2 * $Xn;

  	return $times;
  }
  


string $Selection[];
$Selection = `ls -sl`;

for ($each in $Selection){

select -r $each;

  
  float $step = 700;  
  $curve = "curve -d 1";
  string $crShape[] = `listRelatives -s`;
  float $oldvalues[] = `pointOnCurve -top 1 -pr 0 $crShape[0]`;
  $oldvalues = {round($oldvalues[0],0),round($oldvalues[1],0),round($oldvalues[2],0)};
  for($a = 1; $a <= $step;$a++){
  	$t =  $a/$step;
  	float $values[] = `pointOnCurve -top 1 -pr $t $crShape[0]`;
  	$values = {round($values[0],0),round($values[1],0),round($values[2],0)};
  	if($values[0] != $oldvalues[0] && $values[2] != $oldvalues[2]){
  		$curve += " -p "+$oldvalues[0]+" "+$values[1]+" "+$values[2];
  	}	
  	$curve += " -p "+$values[0]+" "+$values[1]+" "+$values[2];
  	$oldvalues = $values;
  }
  eval($curve);
select -r $curve;

select -cl  ;
}


*/

proc float[] createRegularPolygonY( int $n, float $r )
{
	int $i ;
	float $x[] ;
	float $angle = 360.0 / $n ;

	for( $i = 0 ; $i < $n ; $i++ ) {
		float $a = $i * $angle ;	
		$x[$i] =  $r * cos(deg_to_rad($a)) ;
	}
	return $x ;	
}

proc float[] createRegularPolygonX( int $n,float $r )
{
	int $i ;
	float $x[] ;
	float $angle = 360.0 / $n ;
	for( $i = 0 ; $i < $n ; $i++ ) {
		float $a = $i * $angle ;	
		$x[$i] =  $r * sin(deg_to_rad($a)) ;
	}
	return $x ;	
}



/*

proc CurvatureUtility(float $curveM, $NumberofSteps ){

//


TangentCirclesAtand("sin");
TangentCirclesAtand("cos");
TangentCirclesAtand("tan");
TangentCirclesAtand("tand");
TangentCirclesAtand("atan");
TangentCirclesAtand("asin");
TangentCirclesAtand("acos");
TangentCirclesAtand("atand");
TangentCirclesAtand("asind");
TangentCirclesAtand("acosd");

string $failedMathCommand = "";

int $trigger = 0;


print ($MathFunc[0] +" "+ $MathFunc[1] +"\n");




string $MathFunc[] =  {"sin", "cos", "tan", "tand", "atan", "asin", "acos", "atand", "asind", "acosd"};

int $trigger = 0;
int $ColorLayer = 1;
string $failedMathCommand = "";
for ($eachA in $MathFunc){
for ($eachB in $MathFunc){
print ($eachA +" "+ $eachB +"\n");
string $MathCommandA = $eachA;
string $MathCommandB = $eachB;

//}
//}


//string $MathCommandA = $MathFunc[0];
//string $MathCommandB = $MathFunc[1];

float $r=2;
float $n = 10;

	float $step = 60;  
	$curve = "curve -d 3";

	float $x[] ;
       float $y[] ;
	float $angle = 360.0 / $n ;

$trigger = 0;
int $Par = 0;
float $a1;
float $iiZ =0.0;
int $i = 0;
float $directStep = 0.25;
float $G;

float $XYa;
float $XYb;

  for($a1 = 1; $a1 <= $step; $a1++ ){
  	$t =  $a1/$step;
 	$Par = ($a1/$step);
  	

	float $a2 = $i * $angle ;	


	$a2 = deg_to_rad($a2);
float $XYa;
float $XYb;
string  $stringCommandA = ( $MathCommandA +" "+ $a2 );
string  $stringCommandB = ( $MathCommandB +" "+ $a2 );
  if ( catch ( eval($stringCommandA) )  ) {
  $failedMathCommand += $MathCommandA;
   $trigger = 1; 
break;
  }   

if ( catch ( eval($stringCommandB) )  ) {
  $failedMathCommand += $MathCommandB;
   $trigger = 1; 
break;
  }

float $XYa = eval($stringCommandA);	
float $XYb = eval($stringCommandB);

$x[$i] = $r * $XYa ;
$y[$i] = $r * $XYb ;
		

	// $x[$i] =  $r * cos(deg_to_rad($a2)) ;
	// $y[$i] =  $r * sin(deg_to_rad($a2)) ;
if($iiZ>0){
 $G = `gamma $iiZ`;
}else{$G = $iiZ;}
float $values[] = { $x[$i], $y[$i], $G};
$i++;
 $iiZ += $directStep;
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];


}

///////
if($trigger==0){
string $Newcurvez = `eval($curve)`;
string $LayyerName = ($MathCommandA+"_"+$MathCommandB);
string $layer = `createDisplayLayer -name $LayyerName -empty`;
 setAttr ($layer+".color") $ColorLayer;
editDisplayLayerMembers -noRecurse $layer $Newcurvez;
$ColorLayer++;
}


}
}

print $failedMathCommand;



//float $valuesZYPlane[] = {0.0, $values[1], $values[2]};
//float $valuesZXPlane[] = {$values[0], 0.0, $values[2]};
//float $valuesZ[] = {0.0, 0.0, $values[2]};
//float $valuesX[] = {$values[0], 0.0, 0.0};



rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $Newcurvez;
float $numLength = (`arclen $Newcurvez`) +1; 
int $StepZNum = $numLength;
delete $paramlocatorpointOnCurvex $spaceLocatorB; 
//delete $curves;
///////////////////////////////////////////////// //////
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s $StepZNum -d 3 -tol 0.001  $Newcurvez;


//string $Newcurve[] = {$Newcurvez};
//rename $Newcurve $curves;  
//$Newcurve = {$curves[0]};
//return $Newcurve; 
}








proc MirrorANDrename(string $objectA[]){

ResetTranslation($objectA);
	float $posA[];	
	$posA = `xform -q -os -translation   $objectA[0]`;
xform -ws -pivots 0 $posA[1] $posA[2];
duplicate -rr -renameChildren $objectA; scale -r  -1 1 1; 
string $objectDup[] = `ls -sl`;
int $ifCurvetype = `ISobjectSelectedTypeCurve`;

string $firstcurveRelativesA1[] = `listRelatives  -shapes $objectDup`;

int $numa  = `match "[0-9]+" $objectA[0]`;
string $nameAZ;
$nameAZ = `match "[a-zA-Z]+" $objectA[0]`;

string $renamez = ("A" + $nameAZ + $numa + "A");
string $renameShape = ("A" + $nameAZ + "Shape" +  $numa + "A");
string $renameitzA[];
select -r $objectDup[0];
$renameitzA[0] = `rename $objectDup[0] $renamez`;
 makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;
ResetTranslation($renameitzA);

if ($ifCurvetype == 1){
string $ArcLOCZ[];
string $selectedCurve[];
clear $selectedCurve;
$selectedCurve = $objectA;
string $firstcurveRelatives1[];
$firstcurveRelatives1 = `listRelatives -shapes   $selectedCurve`;
string $firstcurveConnectionsz2[];
$firstcurveConnectionsz2 = ` listHistory -future   false -pruneDagObjects true   $firstcurveRelatives1`;
int $sizeOfConnections = `size ($firstcurveConnectionsz2)`;
if ($sizeOfConnections > 0){
string $ArcCURVEnode =   "makeThreePointCircularArc*";
int $IFArcCurveIStrue = stringArrayGmatch  ($ArcCURVEnode, $firstcurveConnectionsz2);

if ($IFArcCurveIStrue == 0){

string $renameitzA[];
string $renameitzB[];
//$renameitzA[0] = `rename $objectDup[0]  $renamez`;
$renameitzB[0] = `rename $firstcurveRelativesA1 [0] $renameShape`;

 makeIdentity -apply true -t 1 -r 1 -s 1 -n 0  $renameitzA;
ResetTranslation($renameitzA);

}else if ($IFArcCurveIStrue == 1){ 
	string $ArcCURVEnodeZ[];
	string $firstcurveRelatives3[];
	$ArcCURVEnodeZ = stringArrayGmatchToArray($ArcCURVEnode, $firstcurveConnectionsz2);
	$firstcurveRelatives3 = `listHistory -  future 0 -pruneDagObjects 0 $ArcCURVEnodeZ`;
	string $ArcCURVEnodeLOC = "ArcLocator*";

int $IFArcLOCIStrue = stringArrayGmatch  ($ArcCURVEnodeLOC, $firstcurveRelatives3);

if ($IFArcLOCIStrue == 1){ 
	$ArcLOCZ = stringArrayGmatchToArray  ($ArcCURVEnodeLOC, $firstcurveRelatives3);
float $getXLoc = `getAttr ($ArcLOCZ[0]   +".translateX")`;
float $MirrorXLoc = $getXLoc * -1; 

string $objectDupLocs[] = `duplicate -rr   $ArcLOCZ[0]`; 
select -r $objectDupLocs;
group -w; 
xform -os -piv 0 0 0;

scale -r -1 1 1;
//string $objectLOCDup[] = `listRelatives   $objectDup`; 
select -r $objectDupLocs;
 //capture trans, rot, and scale of object to   match
        $outmmesh = ($ArcLOCZ[0] + ".translate"); 
        $inmmesh = ($objectDupLocs[0] +   ".translate");
{
$connect = `connectAttr -f $outmmesh $inmmesh`;
}
select -r $ArcLOCZ;
string $objectDupLocs2[] = `duplicate -rr   $ArcLOCZ[0]`; 
setAttr ($objectDupLocs2[0] +".translateX")   $MirrorXLoc;
parentConstraint -mo -weight 1 $objectDupLocs[0]   $objectDupLocs2[0];
select -r $objectDupLocs2;
Make_Middle_of_Curve_ParamlocatorZMirror  ($renameitzA, $objectDupLocs2);
select -r $objectA ;
}
}
}
}

}








//returns the first single Item array if string matches that item  
//EX. string "red"  match array { "bluered", "blueblue", "greenblue" } returns "bluered" as a string array[].

//string $testGmatch = "red";  string $matcharrayTest[] = { "red", "blueblue", "greenblue" };
//string $matchedinArray[] = stringArrayGmatchToArray($testGmatch, $matcharrayTest);
// Result: red // 

global proc string[] stringArrayGmatchToArray(string $item, string $list[]){
	int $result = false;	
	string $listItem;
string $MatchedItem[];	
	for ($listItem in $list) {
		if ( `gmatch $listItem $item` == 1){
		$result = true;
if ($result == true ){ $MatchedItem = {$listItem};}
			break;	}
	}	
	return $MatchedItem;
}

/////////////

*/
